<!-- doc/src/sgml/syntax.sgml -->

<chapter id="sql-syntax">
<!--
 <title>SQL Syntax</title>
-->
 <title>SQLの構文</title>

 <indexterm zone="sql-syntax">
  <primary>syntax</primary>
  <secondary>SQL</secondary>
 </indexterm>
 <indexterm zone="sql-syntax">
  <primary>構文</primary>
  <secondary>SQL</secondary>
 </indexterm>

 <para>
<!--
  This chapter describes the syntax of SQL.  It forms the foundation
  for understanding the following chapters which will go into detail
  about how SQL commands are applied to define and modify data.
-->
本章ではSQLの構文について説明します。
本章の内容は、データの定義や変更のためにSQLコマンドを適用する方法について詳しく説明する以後の章を理解する上での基礎となります。
 </para>

 <para>
<!--
  We also advise users who are already familiar with SQL to read this
  chapter carefully because it contains several rules and concepts that
  are implemented inconsistently among SQL databases or that are
  specific to <productname>PostgreSQL</productname>.
-->
この章はSQLデータベース間で異なって実装されたり、または<productname>PostgreSQL</productname>に固有な幾つかの規則と概念を含んでいるので、SQLについて熟知しているユーザも本章を注意深く読むことをお勧めします。
 </para>

 <sect1 id="sql-syntax-lexical">
<!--
  <title>Lexical Structure</title>
-->
  <title>字句の構造</title>

  <indexterm>
   <primary>token</primary>
  </indexterm>
  <indexterm>
   <primary>トークン</primary>
  </indexterm>

  <para>
<!--
   SQL input consists of a sequence of
   <firstterm>commands</firstterm>.  A command is composed of a
   sequence of <firstterm>tokens</firstterm>, terminated by a
   semicolon (<quote>;</quote>).  The end of the input stream also
   terminates a command.  Which tokens are valid depends on the syntax
   of the particular command.
-->
SQLの入力は、ひと続きの<firstterm>コマンド</firstterm>からなります。
コマンドは<firstterm>トークン</firstterm>が繋がったもので構成され、最後はセミコロン（<quote>;</quote>）で終わります。
入力ストリームの終了もやはりコマンドを終わらせます。
どのトークンが有効かは特定のコマンドの構文によります。
  </para>

  <para>
<!--
   A token can be a <firstterm>key word</firstterm>, an
   <firstterm>identifier</firstterm>, a <firstterm>quoted
   identifier</firstterm>, a <firstterm>literal</firstterm> (or
   constant), or a special character symbol.  Tokens are normally
   separated by whitespace (space, tab, newline), but need not be if
   there is no ambiguity (which is generally only the case if a
   special character is adjacent to some other token type).
-->
トークンは<firstterm>キーワード</firstterm>、<firstterm>識別子</firstterm>、<firstterm>引用符で囲まれた識別子</firstterm>、<firstterm>リテラル</firstterm>（もしくは定数）、特別な文字シンボルです。
トークンは通常空白（スペース、タブ、改行）で区切られますが、曖昧さがなければ（一般的には特別な文字が他のトークン型と隣接している場合のみ）必要ありません。
  </para>

   <para>
<!--
    For example, the following is (syntactically) valid SQL input:
-->
例えば、以下のものは（構文的に）正しいSQLの入力です。
<programlisting>
SELECT * FROM MY_TABLE;
UPDATE MY_TABLE SET A = 5;
INSERT INTO MY_TABLE VALUES (3, 'hi there');
</programlisting>
<!--
    This is a sequence of three commands, one per line (although this
    is not required; more than one command can be on a line, and
    commands can usefully be split across lines).
-->
この例は1行に1つのコマンドを記述した、3つのコマンドが連続しています（必ずしも1つのコマンドを1行で書く必要はありません。 1行に複数のコマンドを入力することも可能ですし、1つのコマンドを複数行に分けて記述することも可能です）。
   </para>

  <para>
<!--
   Additionally, <firstterm>comments</firstterm> can occur in SQL
   input.  They are not tokens, they are effectively equivalent to
   whitespace.
-->
さらに、入力されたSQLに<firstterm>コメント</firstterm>が付いていても構いません。
コメントはトークンではなく、その効果は空白と同じです。
  </para>

  <para>
<!--
   The SQL syntax is not very consistent regarding what tokens
   identify commands and which are operands or parameters.  The first
   few tokens are generally the command name, so in the above example
   we would usually speak of a <quote>SELECT</quote>, an
   <quote>UPDATE</quote>, and an <quote>INSERT</quote> command.  But
   for instance the <command>UPDATE</command> command always requires
   a <token>SET</token> token to appear in a certain position, and
   this particular variation of <command>INSERT</command> also
   requires a <token>VALUES</token> in order to be complete.  The
   precise syntax rules for each command are described in <xref linkend="reference"/>.
-->
SQL構文は、どのトークンがコマンドを識別し、どれがオペランドでどれがパラメータかに関してはさほど首尾一貫していません。
最初のいくつかのトークンは一般にコマンド名です。
したがって、上記の例において<quote>SELECT</quote>、<quote>UPDATE</quote>、<quote>INSERT</quote>コマンドについて通常説明することになります。
しかし、例えば<command>UPDATE</command>コマンドでは、<token>SET</token>トークンが特定の位置に常に記述されなければなりませんし、この例で使われている<command>INSERT</command>コマンドを完結するためには<token>VALUES</token>トークンが必要です。
それぞれのコマンドの正確な構文規則は<xref linkend="reference"/>で説明されています。
  </para>

  <sect2 id="sql-syntax-identifiers">
<!--
   <title>Identifiers and Key Words</title>
-->
   <title>識別子とキーワード</title>

   <indexterm zone="sql-syntax-identifiers">
    <primary>identifier</primary>
    <secondary>syntax of</secondary>
   </indexterm>
   <indexterm zone="sql-syntax-identifiers">
    <primary>識別子</primary>
    <secondary>の構文</secondary>
   </indexterm>

   <indexterm zone="sql-syntax-identifiers">
    <primary>name</primary>
    <secondary>syntax of</secondary>
   </indexterm>
   <indexterm zone="sql-syntax-identifiers">
    <primary>名前</primary>
    <secondary>の構文</secondary>
   </indexterm>

   <indexterm zone="sql-syntax-identifiers">
    <primary>key word</primary>
    <secondary>syntax of</secondary>
   </indexterm>
   <indexterm zone="sql-syntax-identifiers">
    <primary>キーワード</primary>
    <secondary>の構文</secondary>
   </indexterm>

   <para>
<!--
    Tokens such as <token>SELECT</token>, <token>UPDATE</token>, or
    <token>VALUES</token> in the example above are examples of
    <firstterm>key words</firstterm>, that is, words that have a fixed
    meaning in the SQL language.  The tokens <token>MY_TABLE</token>
    and <token>A</token> are examples of
    <firstterm>identifiers</firstterm>.  They identify names of
    tables, columns, or other database objects, depending on the
    command they are used in.  Therefore they are sometimes simply
    called <quote>names</quote>.  Key words and identifiers have the
    same lexical structure, meaning that one cannot know whether a
    token is an identifier or a key word without knowing the language.
    A complete list of key words can be found in <xref
    linkend="sql-keywords-appendix"/>.
-->
上記の例に出てくる<token>SELECT</token>、<token>UPDATE</token>、もしくは<token>VALUES</token>のようなトークンは、<firstterm>キーワード</firstterm>の一例です。
キーワードとは、SQL言語で決まった意味を持っている単語です。
<token>MY_TABLE</token>トークンや<token>A</token>トークンは<firstterm>識別子</firstterm>の一例です。
これらは、使われるコマンドによって、テーブル、列、他のデータベースオブジェクトの名前を識別します。
したがって、単に<quote>名前</quote>と呼ばれることもあります。
キーワードと識別子は同じ字句の構造を持つため、言語を知らなくてはトークンが識別子なのかキーワードなのかわからないということになります。
全てのキーワードのリストは<xref linkend="sql-keywords-appendix"/>にあります。
   </para>

   <para>
<!--
    SQL identifiers and key words must begin with a letter
    (<literal>a</literal>-<literal>z</literal>, but also letters with
    diacritical marks and non-Latin letters) or an underscore
    (<literal>_</literal>).  Subsequent characters in an identifier or
    key word can be letters, underscores, digits
    (<literal>0</literal>-<literal>9</literal>), or dollar signs
    (<literal>$</literal>).  Note that dollar signs are not allowed in identifiers
    according to the letter of the SQL standard, so their use might render
    applications less portable.
    The SQL standard will not define a key word that contains
    digits or starts or ends with an underscore, so identifiers of this
    form are safe against possible conflict with future extensions of the
    standard.
-->
SQL識別子とキーワードは、文字（<literal>a</literal>〜<literal>z</literal>および発音区別符号付き文字と非Latin文字）、アンダースコア（<literal>_</literal>）で始まらなければいけません。
識別子またはキーワードの中で続く文字は、文字、アンダースコア、数字（<literal>0</literal>〜<literal>9</literal>）あるいはドル記号（<literal>$</literal>）を使用できます。
標準SQLの記述に従うと、ドル記号は識別子内では使用できないことに注意してください。
ですから、これを使用するとアプリケーションの移植性は低くなる可能性があります。
標準SQLでは、数字を含む、あるいはアンダースコアで始まったり終わったりするキーワードは定義されていません。
したがって、この形式の識別子は標準の今後の拡張と競合する可能性に対して安全です。
   </para>

   <para>
    <indexterm><primary>identifier</primary><secondary>length</secondary></indexterm>
    <indexterm><primary>識別子</primary><secondary>長さ</secondary></indexterm>
<!--
    The system uses no more than <symbol>NAMEDATALEN</symbol>-1
    bytes of an identifier; longer names can be written in
    commands, but they will be truncated.  By default,
    <symbol>NAMEDATALEN</symbol> is 64 so the maximum identifier
    length is 63 bytes. If this limit is problematic, it can be raised by
    changing the <symbol>NAMEDATALEN</symbol> constant in
    <filename>src/include/pg_config_manual.h</filename>.
-->
システムは<symbol>NAMEDATALEN</symbol>-1バイトより長い識別子を使いません。
より長い名前をコマンドで書くことはできますが、短く切られてしまいます。
デフォルトでは<symbol>NAMEDATALEN</symbol>は64なので、識別子は最長で63バイトです。
この制限が問題になる場合は、<filename>src/include/pg_config_manual.h</filename>内の<symbol>NAMEDATALEN</symbol>定数の値を変更して増やすことができます。
   </para>

   <para>
    <indexterm>
     <primary>case sensitivity</primary>
     <secondary>of SQL commands</secondary>
    </indexterm>
    <indexterm>
     <primary>大文字小文字の区別</primary>
     <secondary>SQLコマンドの</secondary>
    </indexterm>
<!--
    Key words and unquoted identifiers are case-insensitive.  Therefore:
-->
キーワードと引用符付きでない識別子は大文字と小文字を区別しません。
したがって、
<programlisting>
UPDATE MY_TABLE SET A = 5;
</programlisting>
<!--
    can equivalently be written as:
-->
は、以下の文と同じ意味になります。
<programlisting>
uPDaTE my_TabLE SeT a = 5;
</programlisting>
<!--
    A convention often used is to write key words in upper
    case and names in lower case, e.g.:
-->
慣習的によく使われる方法では、キーワードを大文字で、名前を小文字で書きます。
例えば下記のようになります。
<programlisting>
UPDATE my_table SET a = 5;
</programlisting>
   </para>

   <para>
    <indexterm>
     <primary>quotation marks</primary>
     <secondary>and identifiers</secondary>
    </indexterm>
    <indexterm>
     <primary>引用符</primary>
     <secondary>および識別子</secondary>
    </indexterm>
<!--
    There is a second kind of identifier:  the <firstterm>delimited
    identifier</firstterm> or <firstterm>quoted
    identifier</firstterm>.  It is formed by enclosing an arbitrary
    sequence of characters in double-quotes
    (<literal>"</literal>). <!&#45;- " font-lock mania &#45;-> A delimited
    identifier is always an identifier, never a key word.  So
    <literal>"select"</literal> could be used to refer to a column or
    table named <quote>select</quote>, whereas an unquoted
    <literal>select</literal> would be taken as a key word and
    would therefore provoke a parse error when used where a table or
    column name is expected.  The example can be written with quoted
    identifiers like this:
-->
識別子には副次的な種類もあります。
<firstterm>区切り識別子</firstterm>あるいは<firstterm>引用符付き識別子</firstterm>です。
任意の文字の連なりを二重引用符（<literal>"</literal>）で囲んだものです。<!-- " フォントロック狂 -->
区切り識別子は常に識別子であって、キーワードではありません。
ですから、<literal>"select"</literal>は<quote>select</quote>という名前の列あるいはテーブルを問い合わせるために使えますが、引用符の付かない<literal>select</literal>はキーワードとして理解されるので、テーブルもしくは列名が期待される部分では解析エラーを起こします。
引用符付き識別子は下記の例のように書くことができます。
<programlisting>
UPDATE "my_table" SET "a" = 5;
</programlisting>
   </para>

   <para>
<!--
    Quoted identifiers can contain any character, except the character
    with code zero.  (To include a double quote, write two double quotes.)
    This allows constructing table or column names that would
    otherwise not be possible, such as ones containing spaces or
    ampersands.  The length limitation still applies.
-->
引用符付き識別子は、コード0の文字以外であればどのような文字でも使えます。
（二重引用符を含めたい場合は、二重引用符を2つ入力します。）
これにより、空白やアンパサンド（&amp;）を含むテーブル名や列名など、この方法がなければ作れないような名前のものを作ることが可能になります。
この場合においても長さの制限は適用されます。
   </para>

   <para>
<!--
    Quoting an identifier also makes it case-sensitive, whereas
    unquoted names are always folded to lower case.  For example, the
    identifiers <literal>FOO</literal>, <literal>foo</literal>, and
    <literal>"foo"</literal> are considered the same by
    <productname>PostgreSQL</productname>, but
    <literal>"Foo"</literal> and <literal>"FOO"</literal> are
    different from these three and each other.  (The folding of
    unquoted names to lower case in <productname>PostgreSQL</productname> is
    incompatible with the SQL standard, which says that unquoted names
    should be folded to upper case.  Thus, <literal>foo</literal>
    should be equivalent to <literal>"FOO"</literal> not
    <literal>"foo"</literal> according to the standard.  If you want
    to write portable applications you are advised to always quote a
    particular name or never quote it.)
-->
引用符が付かない名前は常に小文字に解釈されますが、識別子を引用符で囲むことによって大文字と小文字が区別されます。
例えば、識別子<literal>FOO</literal>、<literal>foo</literal>、<literal>"foo"</literal>は<productname>PostgreSQL</productname>によれば同じものとして解釈されますが、<literal>"Foo"</literal>と<literal>"FOO"</literal>は、これら3つとも、またお互いに違ったものとして解釈されます。
（<productname>PostgreSQL</productname>が引用符の付かない名前を小文字として解釈することは標準SQLと互換性がありません。標準SQLでは引用符の付かない名前は大文字に解釈されるべきだとされています。
したがって標準SQLによれば、<literal>foo</literal>は<literal>"FOO"</literal>と同じであるべきで、<literal>"foo"</literal>とは異なるはずなのです。
もし移植可能なアプリケーションを書きたいならば、特定の名前は常に引用符で囲むか、あるいはまったく囲まないかのいずれかに統一することをお勧めします。）
   </para>

   <indexterm>
     <primary>Unicode escape</primary>
     <secondary>in identifiers</secondary>
   </indexterm>
   <indexterm>
     <primary>Unicodeエスケープ</primary>
     <secondary>識別子中</secondary>
   </indexterm>

   <para>
<!--
    A variant of quoted
    identifiers allows including escaped Unicode characters identified
    by their code points.  This variant starts
    with <literal>U&amp;</literal> (upper or lower case U followed by
    ampersand) immediately before the opening double quote, without
    any spaces in between, for example <literal>U&amp;"foo"</literal>.
    (Note that this creates an ambiguity with the
    operator <literal>&amp;</literal>.  Use spaces around the operator to
    avoid this problem.)  Inside the quotes, Unicode characters can be
    specified in escaped form by writing a backslash followed by the
    four-digit hexadecimal code point number or alternatively a
    backslash followed by a plus sign followed by a six-digit
    hexadecimal code point number.  For example, the
    identifier <literal>"data"</literal> could be written as
-->
引用符付き識別子には異形があり、コード番号で識別されるエスケープされたUnicode文字を含むことができます。
この異形は、<literal>U&amp;</literal>（大文字または小文字のUの後にアンパサンド）で始まり、その直後に空白を間に入れずに二重引用符を続けます。
例えば、<literal>U&amp;"foo"</literal>となります。
（これにより演算子<literal>&amp;</literal>との不明確性が生じることに注意してください。
この問題を回避するには空白を演算子の前後に入れます。）
引用符の中で、Unicode文字はバックスラッシュとそれに続く4桁16進数の文字コード番号で、またはもう1つの方法として、バックスラッシュに続いてプラス符号、そして続いた6桁16進数の文字コード番号によりエスケープ形式で指定されます。
例えば、識別子<literal>"data"</literal>は次のように書くことができます。
<programlisting>
U&amp;"d\0061t\+000061"
</programlisting>
<!--
    The following less trivial example writes the Russian
    word <quote>slon</quote> (elephant) in Cyrillic letters:
-->
次の少し意味のある例はロシア語の<quote>slon</quote>（象）をキリル文字で書いたものです。
<programlisting>
U&amp;"\0441\043B\043E\043D"
</programlisting>
   </para>

   <para>
<!--
    If a different escape character than backslash is desired, it can
    be specified using
    the <literal>UESCAPE</literal><indexterm><primary>UESCAPE</primary></indexterm>
    clause after the string, for example:
-->
バックスラッシュ以外のエスケープ文字を使用したい場合、文字列の後に<literal>UESCAPE</literal><indexterm><primary>UESCAPE</primary></indexterm>句を使用して指定できます。例をあげます。
<programlisting>
U&amp;"d!0061t!+000061" UESCAPE '!'
</programlisting>
<!--
    The escape character can be any single character other than a
    hexadecimal digit, the plus sign, a single quote, a double quote,
    or a whitespace character.  Note that the escape character is
    written in single quotes, not double quotes,
    after <literal>UESCAPE</literal>.
-->
エスケープ文字には、16進表記用の文字、プラス記号、単一引用符、二重引用符、空白文字以外の任意の単一文字を使用できます。
エスケープ文字は<literal>UESCAPE</literal>の後に二重引用符ではなく単一引用符で記述していることに注意してください。
   </para>

   <para>
<!--
    To include the escape character in the identifier literally, write
    it twice.
-->
識別子内にエスケープ文字をそのまま含めるためには、それを2つ記述してください。
   </para>

   <para>
<!--
    Either the 4-digit or the 6-digit escape form can be used to
    specify UTF-16 surrogate pairs to compose characters with code
    points larger than U+FFFF, although the availability of the
    6-digit form technically makes this unnecessary.  (Surrogate
    pairs are not stored directly, but are combined into a single
    code point.)
-->
U+FFFFより大きなコードポイントを持つ文字を構成するUTF-16サロゲートペアを指定するために、4桁と6桁の形式のどちらかを使用できますが、技術的には6桁形式の機能によりこれは不要になります。
（サロゲートペアは直接格納されるわけではなく、一つのコードポイントに結合されます。）
   </para>

   <para>
<!--
    If the server encoding is not UTF-8, the Unicode code point identified
    by one of these escape sequences is converted to the actual server
    encoding; an error is reported if that's not possible.
-->
サーバ符号化方式がUTF-8でない場合、このエスケープシーケンスの1つで指定されたUnicodeコードポイントは実際のサーバ符号化方式へと変換されます。それが可能でない場合にはエラーが報告されます。
   </para>
  </sect2>


  <sect2 id="sql-syntax-constants">
<!--
   <title>Constants</title>
-->
   <title>定数</title>

   <indexterm zone="sql-syntax-constants">
    <primary>constant</primary>
   </indexterm>
   <indexterm zone="sql-syntax-constants">
    <primary>定数</primary>
   </indexterm>

   <para>
<!--
    There are three kinds of <firstterm>implicitly-typed
    constants</firstterm> in <productname>PostgreSQL</productname>:
    strings, bit strings, and numbers.
    Constants can also be specified with explicit types, which can
    enable more accurate representation and more efficient handling by
    the system. These alternatives are discussed in the following
    subsections.
-->
<productname>PostgreSQL</productname>には、3つの<firstterm>暗黙に型付けされる定数</firstterm>があります。
文字列、ビット文字列、そして数字です。
定数は明示的な型で指定することもでき、その場合はシステムによる、より正確な表現と効率の良い操作が可能になります。
こうした他の方法については、次の副節で説明します。
   </para>

   <sect3 id="sql-syntax-strings">
<!--
    <title>String Constants</title>
-->
    <title>文字列定数</title>

    <indexterm zone="sql-syntax-strings">
     <primary>character string</primary>
     <secondary>constant</secondary>
    </indexterm>
    <indexterm zone="sql-syntax-strings">
     <primary>文字列</primary>
     <secondary>定数</secondary>
    </indexterm>

    <para>
     <indexterm>
      <primary>quotation marks</primary>
      <secondary>escaping</secondary>
     </indexterm>
     <indexterm>
      <primary>引用符</primary>
      <secondary>エスケープ</secondary>
     </indexterm>
<!--
     A string constant in SQL is an arbitrary sequence of characters
     bounded by single quotes (<literal>'</literal>), for example
     <literal>'This is a string'</literal>.  To include
     a single-quote character within a string constant,
     write two adjacent single quotes, e.g.,
     <literal>'Dianne''s horse'</literal>.
     Note that this is <emphasis>not</emphasis> the same as a double-quote
     character (<literal>"</literal>). <!&#45;- font-lock sanity: " &#45;->
-->
SQLにおける文字列定数は、単一引用符（<literal>'</literal>）で括られた任意の文字の並びです。
例えば、<literal>'This is a string'</literal>です。
文字列定数内に単一引用符を含めるには、2つ続けて単一引用符を記述します。
例えば、<literal>'Dianne''s horse'</literal>です。
二重引用符(<literal>"</literal>)とは同一では<emphasis>ない</emphasis>点に注意してください。<!-- font-lock sanity: " -->
    </para>

    <para>
<!--
     Two string constants that are only separated by whitespace
     <emphasis>with at least one newline</emphasis> are concatenated
     and effectively treated as if the string had been written as one
     constant.  For example:
-->
2つの文字列定数が、<emphasis>少なくとも1つの改行</emphasis>を含んだ空白のみで区切られている場合は、2つの定数は連結され、実質的に1つの定数として書かれたように処理されます。
例を示します。
<programlisting>
SELECT 'foo'
'bar';
</programlisting>
<!--
     is equivalent to:
-->
は、
<programlisting>
SELECT 'foobar';
</programlisting>
<!--
     but:
-->
と同じです。しかし、
<programlisting>
SELECT 'foo'      'bar';
</programlisting>
<!--
     is not valid syntax.  (This slightly bizarre behavior is specified
     by <acronym>SQL</acronym>; <productname>PostgreSQL</productname> is
     following the standard.)
-->
は有効な構文ではありません。
（このちょっとした奇妙な振舞いは<acronym>SQL</acronym>で決められているもので、<productname>PostgreSQL</productname>ではこの標準に従っています。）
    </para>
   </sect3>

   <sect3 id="sql-syntax-strings-escape">
<!--
    <title>String Constants with C-Style Escapes</title>
-->
    <title>C形式エスケープでの文字列定数</title>

     <indexterm zone="sql-syntax-strings-escape">
      <primary>escape string syntax</primary>
     </indexterm>
     <indexterm zone="sql-syntax-strings-escape">
      <primary>エスケープ文字列構文</primary>
     </indexterm>
     <indexterm zone="sql-syntax-strings-escape">
      <primary>backslash escapes</primary>
     </indexterm>
     <indexterm zone="sql-syntax-strings-escape">
      <primary>バックスラッシュエスケープ</primary>
     </indexterm>

    <para>
<!--
     <productname>PostgreSQL</productname> also accepts <quote>escape</quote>
     string constants, which are an extension to the SQL standard.
     An escape string constant is specified by writing the letter
     <literal>E</literal> (upper or lower case) just before the opening single
     quote, e.g., <literal>E'foo'</literal>.  (When continuing an escape string
     constant across lines, write <literal>E</literal> only before the first opening
     quote.)
     Within an escape string, a backslash character (<literal>\</literal>) begins a
     C-like <firstterm>backslash escape</firstterm> sequence, in which the combination
     of backslash and following character(s) represent a special byte
     value, as shown in <xref linkend="sql-backslash-table"/>.
-->
<productname>PostgreSQL</productname>では、また、<quote>エスケープ</quote>文字列定数を受け付けます。
これは標準SQLの拡張です。
エスケープ文字列定数は、<literal>E</literal>（大文字でも小文字でもかまいません）を開始単一引用符の直前に記述することで指定されます。
例えば<literal>E'foo'</literal>です。
（複数行に渡るエスケープ文字列定数では、最初の開始引用符の前にのみ<literal>E</literal>を記述してください。）
エスケープ文字列の中では、バックスラッシュ文字（<literal>\</literal>）によりC言語のような<firstterm>バックスラッシュ</firstterm>シーケンスが開始し、その中でバックスラッシュとそれに続く文字の組み合わせが（<xref linkend="sql-backslash-table"/>で示したように）特別なバイト値を表現します。
    </para>

     <table id="sql-backslash-table">
<!--
      <title>Backslash Escape Sequences</title>
-->
      <title>バックスラッシュエスケープシーケンス</title>
      <tgroup cols="2">
      <thead>
       <row>
<!--
        <entry>Backslash Escape Sequence</entry>
-->
        <entry>バックスラッシュエスケープシーケンス</entry>
<!--
        <entry>Interpretation</entry>
-->
        <entry>解釈</entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry><literal>\b</literal></entry>
<!--
        <entry>backspace</entry>
-->
        <entry>後退</entry>
       </row>
       <row>
        <entry><literal>\f</literal></entry>
<!--
        <entry>form feed</entry>
-->
        <entry>改ページ</entry>
       </row>
       <row>
        <entry><literal>\n</literal></entry>
<!--
        <entry>newline</entry>
-->
        <entry>改行</entry>
       </row>
       <row>
        <entry><literal>\r</literal></entry>
<!--
        <entry>carriage return</entry>
-->
        <entry>復帰</entry>
       </row>
       <row>
        <entry><literal>\t</literal></entry>
<!--
        <entry>tab</entry>
-->
        <entry>タブ</entry>
       </row>
       <row>
        <entry>
         <literal>\<replaceable>o</replaceable></literal>,
         <literal>\<replaceable>oo</replaceable></literal>,
         <literal>\<replaceable>ooo</replaceable></literal>
         (<replaceable>o</replaceable> = 0&ndash;7)
        </entry>
<!--
        <entry>octal byte value</entry>
-->
        <entry>8進数バイト値</entry>
       </row>
       <row>
        <entry>
         <literal>\x<replaceable>h</replaceable></literal>,
         <literal>\x<replaceable>hh</replaceable></literal>
         (<replaceable>h</replaceable> = 0&ndash;9, A&ndash;F)
        </entry>
<!--
        <entry>hexadecimal byte value</entry>
-->
        <entry>16進数バイト値</entry>
       </row>
       <row>
        <entry>
         <literal>\u<replaceable>xxxx</replaceable></literal>,
         <literal>\U<replaceable>xxxxxxxx</replaceable></literal>
         (<replaceable>x</replaceable> = 0&ndash;9, A&ndash;F)
        </entry>
<!--
        <entry>16 or 32-bit hexadecimal Unicode character value</entry>
-->
        <entry>16もしくは32ビットの16進数 Unicode 文字値</entry>
       </row>
      </tbody>
      </tgroup>
     </table>

    <para>
<!--
     Any other
     character following a backslash is taken literally. Thus, to
     include a backslash character, write two backslashes (<literal>\\</literal>).
     Also, a single quote can be included in an escape string by writing
     <literal>\'</literal>, in addition to the normal way of <literal>''</literal>.
-->
バックスラッシュの後のそのほかの全ての文字はそのまま扱われます。
従って、バックスラッシュ文字を含ませるときは2つのバックスラッシュ（<literal>\\</literal>）を記載します。
同時に、エスケープ文字列の中では、単一引用符を、通常の方法の<literal>''</literal>に加え、<literal>\'</literal>としても含めることができます。
    </para>

    <para>
<!--
     It is your responsibility that the byte sequences you create,
     especially when using the octal or hexadecimal escapes, compose
     valid characters in the server character set encoding.
     A useful alternative is to use Unicode escapes or the
     alternative Unicode escape syntax, explained
     in <xref linkend="sql-syntax-strings-uescape"/>; then the server
     will check that the character conversion is possible.
-->
特に8進数や16進数エスケープを用いて作成されるバイトシーケンスが、サーバ文字セット符号化方式において有効な文字で構成されていることはコードを書く人の責任です。
便利な代替手段は、Unicodeエスケープか、<xref linkend="sql-syntax-strings-uescape"/>で説明するもう一つのUnicodeエスケープ構文を代わりとして使用することです。そうすればサーバが文字変換を可能か検査するでしょう。
    </para>

    <caution>
    <para>
<!--
     If the configuration parameter
     <xref linkend="guc-standard-conforming-strings"/> is <literal>off</literal>,
     then <productname>PostgreSQL</productname> recognizes backslash escapes
     in both regular and escape string constants.  However, as of
     <productname>PostgreSQL</productname> 9.1, the default is <literal>on</literal>, meaning
     that backslash escapes are recognized only in escape string constants.
     This behavior is more standards-compliant, but might break applications
     which rely on the historical behavior, where backslash escapes
     were always recognized.  As a workaround, you can set this parameter
     to <literal>off</literal>, but it is better to migrate away from using backslash
     escapes.  If you need to use a backslash escape to represent a special
     character, write the string constant with an <literal>E</literal>.
-->
設定パラメータ<xref linkend="guc-standard-conforming-strings"/>が <literal>off</literal>の場合、<productname>PostgreSQL</productname>はバックスラッシュエスケープを通常の文字列定数とエスケープ文字列定数の両方で認識します。
しかし、<productname>PostgreSQL</productname> 9.1からデフォルトは<literal>on</literal>になりました。これはバックスラッシュエスケープがエスケープ文字列定数でのみ認識されます。
この振る舞いは標準SQL仕様に即していますが、バックスラッシュエスケープを常に認識するという歴史的な動作に依存しているアプリケーションは動作しなくなるでしょう。
回避策として、このパラメータを<literal>off</literal>にすることはできますが、バックスラッシュエスケープの使用を避けるよう移植するのが良いでしょう。
特殊文字を表現するためにバックスラッシュを使用する必要がある場合、<literal>E</literal>をつけて文字列定数を記述してください。
    </para>

    <para>
<!--
     In addition to <varname>standard_conforming_strings</varname>, the configuration
     parameters <xref linkend="guc-escape-string-warning"/> and
     <xref linkend="guc-backslash-quote"/> govern treatment of backslashes
     in string constants.
-->
<varname>standard_conforming_strings</varname>の他に、設定パラメータ<xref linkend="guc-escape-string-warning"/>および<xref linkend="guc-backslash-quote"/>が文字列定数内のバックスラッシュの動作を決定します。
    </para>
    </caution>

    <para>
<!--
     The character with the code zero cannot be in a string constant.
-->
コードゼロの文字は文字列定数の中に入れられません。
    </para>
   </sect3>

   <sect3 id="sql-syntax-strings-uescape">
<!--
    <title>String Constants with Unicode Escapes</title>
-->
    <title>Unicodeエスケープがある文字列定数</title>

    <indexterm  zone="sql-syntax-strings-uescape">
     <primary>Unicode escape</primary>
     <secondary>in string constants</secondary>
    </indexterm>
    <indexterm  zone="sql-syntax-strings-uescape">
     <primary>Unicodeエスケープ</primary>
     <secondary>文字列定数中</secondary>
    </indexterm>

    <para>
<!--
     <productname>PostgreSQL</productname> also supports another type
     of escape syntax for strings that allows specifying arbitrary
     Unicode characters by code point.  A Unicode escape string
     constant starts with <literal>U&amp;</literal> (upper or lower case
     letter U followed by ampersand) immediately before the opening
     quote, without any spaces in between, for
     example <literal>U&amp;'foo'</literal>.  (Note that this creates an
     ambiguity with the operator <literal>&amp;</literal>.  Use spaces
     around the operator to avoid this problem.)  Inside the quotes,
     Unicode characters can be specified in escaped form by writing a
     backslash followed by the four-digit hexadecimal code point
     number or alternatively a backslash followed by a plus sign
     followed by a six-digit hexadecimal code point number.  For
     example, the string <literal>'data'</literal> could be written as
-->
<productname>PostgreSQL</productname>は同時に、文字コード番号で任意のUnicode文字を指定可能な文字列に対するもう一つのエスケープ構文を提供します。
Unicodeエスケープ文字列定数は、<literal>U&amp;</literal>（大文字・小文字のUの後にアンパサンド）で始まり、その直後に、空白を間にはさまず、開始引用符が続きます。
例えば、<literal>U&amp;'foo'</literal>となります。
（これにより演算子<literal>&amp;</literal>との曖昧性が生じることに注意してください。
この問題を回避するには空白を演算子の前後に入れます。）
引用符の中で、Unicode文字はバックスラッシュとそれに続く4桁16進数の文字コード番号で、またはもう1つの方法として、バックスラッシュに続いてプラス符号、そして続いた6桁16進数の文字コード番号によりエスケープ形式で指定されます。
例えば、文字列<literal>'data'</literal>は次のように書かれます。
<programlisting>
U&amp;'d\0061t\+000061'
</programlisting>
<!--
     The following less trivial example writes the Russian
     word <quote>slon</quote> (elephant) in Cyrillic letters:
-->
次の少し意味のある例はロシア語の<quote>slon</quote>（象）をキリル文字で書いたものです。
<programlisting>
U&amp;'\0441\043B\043E\043D'
</programlisting>
    </para>

    <para>
<!--
     If a different escape character than backslash is desired, it can
     be specified using
     the <literal>UESCAPE</literal><indexterm><primary>UESCAPE</primary></indexterm>
     clause after the string, for example:
-->
バックスラッシュ以外のエスケープ文字を使用したい場合、文字列の後に<literal>UESCAPE</literal><indexterm><primary>UESCAPE</primary></indexterm>句を使用して指定できます。例をあげます。
<programlisting>
U&amp;'d!0061t!+000061' UESCAPE '!'
</programlisting>
<!--
     The escape character can be any single character other than a
     hexadecimal digit, the plus sign, a single quote, a double quote,
     or a whitespace character.
-->
エスケープ文字には、16進表記用の文字、プラス記号、単一引用符、二重引用符、空白文字以外の任意の単一文字を使用できます。
    </para>

    <para>
<!--
     To include the escape character in the string literally, write
     it twice.
-->
識別子内にエスケープ文字をそのまま含めるためには、それを2つ記述してください。
    </para>

    <para>
<!--
     Either the 4-digit or the 6-digit escape form can be used to
     specify UTF-16 surrogate pairs to compose characters with code
     points larger than U+FFFF, although the availability of the
     6-digit form technically makes this unnecessary.  (Surrogate
     pairs are not stored directly, but are combined into a single
     code point.)
-->
U+FFFFより大きなコードポイントを持つ文字を構成するUTF-16サロゲートペアを指定するために、4桁と6桁の形式のどちらかを使用できますが、技術的には6桁形式の機能によりこれは不要になります。
（サロゲートペアは直接格納されるわけではなく、一つのコードポイントに結合されます。）
    </para>

    <para>
<!--
     If the server encoding is not UTF-8, the Unicode code point identified
     by one of these escape sequences is converted to the actual server
     encoding; an error is reported if that's not possible.
-->
サーバ符号化方式がUTF-8でない場合、このエスケープシーケンスの1つで指定されたUnicodeコードポイントは実際のサーバ符号化方式へと変換されます。それが可能でない場合にはエラーが報告されます。
    </para>

    <para>
<!--
     Also, the Unicode escape syntax for string constants only works
     when the configuration
     parameter <xref linkend="guc-standard-conforming-strings"/> is
     turned on.  This is because otherwise this syntax could confuse
     clients that parse the SQL statements to the point that it could
     lead to SQL injections and similar security issues.  If the
     parameter is set to off, this syntax will be rejected with an
     error message.
-->
また、文字列定数に対するユニコードエスケープ構文は設定パラメータ<xref linkend="guc-standard-conforming-strings"/>が有効なときのみ動作します。
そうでないとこの構文は、SQL文を構文解釈するクライアントを混乱させ、SQLインジェクションや、それに類似したセキュリティ問題に繋がることさえあるからです。
パラメータがoffに設定されていれば、この構文はエラーメッセージを出して拒絶されます。
    </para>
   </sect3>

   <sect3 id="sql-syntax-dollar-quoting">
<!--
    <title>Dollar-Quoted String Constants</title>
-->
    <title>ドル記号で引用符付けされた文字列定数</title>

     <indexterm>
      <primary>dollar quoting</primary>
     </indexterm>
     <indexterm>
      <primary>ドル引用符付け</primary>
     </indexterm>

    <para>
<!--
     While the standard syntax for specifying string constants is usually
     convenient, it can be difficult to understand when the desired string
     contains many single quotes, since each of those must
     be doubled. To allow more readable queries in such situations,
     <productname>PostgreSQL</productname> provides another way, called
     <quote>dollar quoting</quote>, to write string constants.
     A dollar-quoted string constant
     consists of a dollar sign (<literal>$</literal>), an optional
     <quote>tag</quote> of zero or more characters, another dollar
     sign, an arbitrary sequence of characters that makes up the
     string content, a dollar sign, the same tag that began this
     dollar quote, and a dollar sign. For example, here are two
     different ways to specify the string <quote>Dianne's horse</quote>
     using dollar quoting:
-->
文字列定数の標準の構文はたいていの場合便利ですが、対象とする文字列内に多くの単一引用符があると、それらを全て二重にしなければなりませんので理解しづらくなります。
こうした状況においても問い合わせの可読性をより高めるために<productname>PostgreSQL</productname>は、<quote>ドル引用符付け</quote>という他の文字列定数の指定方法を提供します。
ドル引用符付けされた文字列定数は、ドル記号（<literal>$</literal>）、省略可能な0個以上の文字からなる<quote>タグ</quote>、ドル記号、文字列定数を構成する任意の文字の並び、ドル記号、この引用符付けの始めに指定したものと同じタグ、ドル記号から構成されます。
例えば、<quote>Dianne's horse</quote>という文字列をドル引用符付けを使用して指定する方法を、以下に2つ示します。
<programlisting>
$$Dianne's horse$$
$SomeTag$Dianne's horse$SomeTag$
</programlisting>
<!--
     Notice that inside the dollar-quoted string, single quotes can be
     used without needing to be escaped.  Indeed, no characters inside
     a dollar-quoted string are ever escaped: the string content is always
     written literally.  Backslashes are not special, and neither are
     dollar signs, unless they are part of a sequence matching the opening
     tag.
-->
ドル引用符付けされた文字列の内側では、単一引用符をエスケープすることなく使用できることを理解してください。
実際には、ドル引用符付けされた文字列の内側の文字はまったくエスケープが必要なく、文字列定数はすべてそのまま記述できます。
その並びが開始タグに一致しない限り、バックスラッシュもドル記号も特別なものではありません。
    </para>

    <para>
<!--
     It is possible to nest dollar-quoted string constants by choosing
     different tags at each nesting level.  This is most commonly used in
     writing function definitions.  For example:
-->
各入れ子レベルに異なるタグを付けることで、ドル引用符付けされた文字列を入れ子にできます。
これは、関数定義を作成する時に非常によく使用されます。
以下に例を示します。
<programlisting>
$function$
BEGIN
    RETURN ($1 ~ $q$[\t\r\n\v\\]$q$);
END;
$function$
</programlisting>
<!--
     Here, the sequence <literal>$q$[\t\r\n\v\\]$q$</literal> represents a
     dollar-quoted literal string <literal>[\t\r\n\v\\]</literal>, which will
     be recognized when the function body is executed by
     <productname>PostgreSQL</productname>.  But since the sequence does not match
     the outer dollar quoting delimiter <literal>$function$</literal>, it is
     just some more characters within the constant so far as the outer
     string is concerned.
-->
ここで、<literal>$q$[\t\r\n\v\\]$q$</literal>は、ドル引用符付けされた<literal>[\t\r\n\v\\]</literal>リテラル文字列を表し、<productname>PostgreSQL</productname>がこの関数本体を実行する時に認識されます。
しかし、この並びは、外側のドル引用符用の区切り文字<literal>$function$</literal>に一致しませんので、外側の文字列を対象としている場合は単なる文字の並びとなります。
    </para>

    <para>
<!--
     The tag, if any, of a dollar-quoted string follows the same rules
     as an unquoted identifier, except that it cannot contain a dollar sign.
     Tags are case sensitive, so <literal>$tag$String content$tag$</literal>
     is correct, but <literal>$TAG$String content$tag$</literal> is not.
-->
もしあれば、ドル引用符付けされた文字列のタグは、引用符付けされていない識別子と同じ規則に従います。
ただし、タグにドル記号を含めることはできません。
タグは大文字小文字を区別します。
したがって、<literal>$tag$String content$tag$</literal>は正しいのですが、<literal>$TAG$String content$tag$</literal>は間違いです。
    </para>

    <para>
<!--
     A dollar-quoted string that follows a keyword or identifier must
     be separated from it by whitespace; otherwise the dollar quoting
     delimiter would be taken as part of the preceding identifier.
-->
キーワードや識別子の後にドル引用符付けされた文字列を続ける場合は、空白でそれを区切らなければなりません。
さもないと、ドル引用符の区切り文字は、直前の識別子の一部として解釈されます。
    </para>

    <para>
<!--
     Dollar quoting is not part of the SQL standard, but it is often a more
     convenient way to write complicated string literals than the
     standard-compliant single quote syntax.  It is particularly useful when
     representing string constants inside other constants, as is often needed
     in procedural function definitions.  With single-quote syntax, each
     backslash in the above example would have to be written as four
     backslashes, which would be reduced to two backslashes in parsing the
     original string constant, and then to one when the inner string constant
     is re-parsed during function execution.
-->
ドル引用符付けは、標準SQLで定義されていません。
しかし、複雑な文字列リテラルを記述する場合は標準準拠の単一引用符構文よりも便利なことがよくあります。
特に、他の定数の内部に文字列定数を記述するような場合は役に立ちます。
こうした状況は手続き関数の定義でよく必要とされます。
単一引用符構文では、上の例のバックスラッシュはそれぞれ、4個のバックスラッシュで記述しなければなりません。
この4つのバックスラッシュは、元の文字列定数を解析する際に2つに減少され、そして、関数を実行する際に内部の文字列定数が再解析され1つに減少します。
    </para>
   </sect3>

   <sect3 id="sql-syntax-bit-strings">
<!--
    <title>Bit-String Constants</title>
-->
    <title>ビット文字列定数</title>

    <indexterm zone="sql-syntax-bit-strings">
     <primary>bit string</primary>
     <secondary>constant</secondary>
    </indexterm>
    <indexterm zone="sql-syntax-bit-strings">
     <primary>ビット文字列</primary>
     <secondary>定数</secondary>
    </indexterm>

    <para>
<!--
     Bit-string constants look like regular string constants with a
     <literal>B</literal> (upper or lower case) immediately before the
     opening quote (no intervening whitespace), e.g.,
     <literal>B'1001'</literal>.  The only characters allowed within
     bit-string constants are <literal>0</literal> and
     <literal>1</literal>.
-->
ビット文字列定数は<literal>B</literal>（大文字もしくは小文字）が始まりの引用符の前に付いている（間に空白はありません）通常の文字列定数のように見えます。
例えば<literal>B'1001'</literal>のようになります。
ビット文字列定数の中で許可される文字は<literal>0</literal>と<literal>1</literal>のみです。
    </para>

    <para>
<!--
     Alternatively, bit-string constants can be specified in hexadecimal
     notation, using a leading <literal>X</literal> (upper or lower case),
     e.g., <literal>X'1FF'</literal>.  This notation is equivalent to
     a bit-string constant with four binary digits for each hexadecimal digit.
-->
その他にも、ビット文字列定数は<literal>X'1FF'</literal>といった具合に、先頭に<literal>X</literal>（大文字または小文字）を使用して16進表記で指定することもできます。
この表記は、各16進数値をそれぞれ4つの2進数値に置き換えたビット文字列定数と同等です。
    </para>

    <para>
<!--
     Both forms of bit-string constant can be continued
     across lines in the same way as regular string constants.
     Dollar quoting cannot be used in a bit-string constant.
-->
どちらの形式のビット文字列定数でも、通常の文字列定数と同じように複数行にわたって続けて書くことができます。
ドル引用符付けはビット文字列定数で使用できません。
    </para>
   </sect3>

   <sect3 id="sql-syntax-constants-numeric">
<!--
    <title>Numeric Constants</title>
-->
    <title>数値定数</title>

    <indexterm>
     <primary>number</primary>
     <secondary>constant</secondary>
    </indexterm>
    <indexterm>
     <primary>数値</primary>
     <secondary>定数</secondary>
    </indexterm>

    <para>
<!--
     Numeric constants are accepted in these general forms:
-->
数値定数は下記の一般的な形で受け付けられます。
<synopsis>
<replaceable>digits</replaceable>
<replaceable>digits</replaceable>.<optional><replaceable>digits</replaceable></optional><optional>e<optional>+-</optional><replaceable>digits</replaceable></optional>
<optional><replaceable>digits</replaceable></optional>.<replaceable>digits</replaceable><optional>e<optional>+-</optional><replaceable>digits</replaceable></optional>
<replaceable>digits</replaceable>e<optional>+-</optional><replaceable>digits</replaceable>
</synopsis>
<!--
     where <replaceable>digits</replaceable> is one or more decimal
     digits (0 through 9).  At least one digit must be before or after the
     decimal point, if one is used.  At least one digit must follow the
     exponent marker (<literal>e</literal>), if one is present.
     There cannot be any spaces or other characters embedded in the
     constant, except for underscores, which can be used for visual grouping as
     described below.  Note that any leading plus or minus sign is not actually
     considered part of the constant; it is an operator applied to the
     constant.
-->
ここで<replaceable>digits</replaceable>は1つ以上の10進数字（0〜9）です。
小数点を使用する場合は、少なくとも1つの数字が小数点の前か後になくてはなりません。
指数記号<literal>e</literal>の付く形式を使う場合には<literal>e</literal>の後に少なくとも1つの数字がなければいけません。
以下に示す視覚的なグループ化のために使われるアンダースコア以外には、空白や他の文字は、定数の中に埋め込むことはできません。
プラスまたはマイナスの符号を先頭につけても、定数の一部とはみなされないことに注意してください。
これらの符号は定数に適用される演算子とみなされます。
    </para>

    <para>
<!--
     These are some examples of valid numeric constants:
-->
下記は有効な数値定数のいくつかの例です。
<literallayout>
42
3.5
4.
.001
5e2
1.925e-3
</literallayout>
    </para>

    <para>
<!--
     Additionally, non-decimal integer constants are accepted in these forms:
-->
さらに、以下の形式で非10進整数定数を受け入れます。
<synopsis>
0x<replaceable>hexdigits</replaceable>
0o<replaceable>octdigits</replaceable>
0b<replaceable>bindigits</replaceable>
</synopsis>
<!--
     where <replaceable>hexdigits</replaceable> is one or more hexadecimal digits
     (0-9, A-F), <replaceable>octdigits</replaceable> is one or more octal
     digits (0-7), and <replaceable>bindigits</replaceable> is one or more binary
     digits (0 or 1).  Hexadecimal digits and the radix prefixes can be in
     upper or lower case.  Note that only integers can have non-decimal forms,
     not numbers with fractional parts.
-->
ここで、<replaceable>hexdigits</replaceable>は1つ以上の16進数(0-9、A-F)、<replaceable>octdigits</replaceable>は1つ以上の8進数(0-7)、<replaceable>bindigits</replaceable>は1つ以上の2進数(0または1)です。
16進数と基数のプレフィックスは、大文字または小文字で指定できます。
小数部のある数字ではなく、整数のみが非10進形式になることに注意してください。
    </para>

    <para>
<!--
     These are some examples of valid non-decimal integer constants:
-->
以下に、有効な非10進整数定数の例を示します。
<literallayout>
0b100101
0B10011001
0o273
0O755
0x42f
0XFFFF
</literallayout>
    </para>

    <para>
<!--
     For visual grouping, underscores can be inserted between digits.  These
     have no further effect on the value of the constant.  For example:
-->
視覚的なグループ化のために、数字の間にアンダースコアを挿入できます。
これらは、定数の値にさらなる影響を与えません。
例:
<literallayout>
1_500_000_000
0b10001000_00000000
0o_1_755
0xFFFF_FFFF
1.618_034
</literallayout>
<!--
     Underscores are not allowed at the start or end of a numeric constant or
     a group of digits (that is, immediately before or after the decimal point
     or the exponent marker), and more than one underscore in a row is not
     allowed.
-->
数値定数または数値グループの先頭または末尾にアンダースコアを使用できません（つまり、小数点や指数記号の直前または直後にアンダースコアを使用できません）し、複数のアンダースコアを続けて使用することもできません。
    </para>

    <para>
     <indexterm><primary>integer</primary></indexterm>
     <indexterm><primary>bigint</primary></indexterm>
     <indexterm><primary>numeric</primary></indexterm>
<!--
     A numeric constant that contains neither a decimal point nor an
     exponent is initially presumed to be type <type>integer</type> if its
     value fits in type <type>integer</type> (32 bits); otherwise it is
     presumed to be type <type>bigint</type> if its
     value fits in type <type>bigint</type> (64 bits); otherwise it is
     taken to be type <type>numeric</type>.  Constants that contain decimal
     points and/or exponents are always initially presumed to be type
     <type>numeric</type>.
-->
小数点も指数も含まない数値定数の場合、まずその値が<type>integer</type>型（32ビット）に収まれば<type>integer</type>型であるとみなされます。
そうでない場合、<type>bigint</type>型（64ビット）で収まれば<type>bigint</type>型とみなされます。
どちらでもない場合は、<type>numeric</type>型とみなされます。
定数が小数点または指数あるいはその両方を含む場合は、常に最初に<type>numeric</type>型であるとみなされます。
    </para>

    <para>
<!--
     The initially assigned data type of a numeric constant is just a
     starting point for the type resolution algorithms.  In most cases
     the constant will be automatically coerced to the most
     appropriate type depending on context.  When necessary, you can
     force a numeric value to be interpreted as a specific data type
     by casting it.<indexterm><primary>type cast</primary></indexterm>
     For example, you can force a numeric value to be treated as type
     <type>real</type> (<type>float4</type>) by writing:
-->
数値定数に最初に割り振られるデータ型は、型解決アルゴリズムの開始点に過ぎません。
ほとんどの場合、定数は文脈に基づいて自動的に最も適切な型に変換されます。
必要であれば、特定のデータ型にキャストして、数値がそのデータ型として解釈されるように強制できます。
<indexterm><primary>型キャスト</primary></indexterm>
例えば、以下のようにして数値を<type>real</type>型（<type>float4</type>）として処理できます。

<programlisting>
<!--
REAL '1.23'  &#45;- string style
1.23::REAL   &#45;- PostgreSQL (historical) style
-->
REAL '1.23'  -- 文字列書式
1.23::REAL   -- （歴史的な）PostgreSQL書式
</programlisting>

<!--
     These are actually just special cases of the general casting
     notations discussed next.
-->
実のところ、これらは以下で説明する一般的なキャスト記法の特別な場合です。
    </para>
   </sect3>

   <sect3 id="sql-syntax-constants-generic">
<!--
    <title>Constants of Other Types</title>
-->
    <title>他の型の定数</title>

    <indexterm>
     <primary>data type</primary>
     <secondary>constant</secondary>
    </indexterm>
    <indexterm>
     <primary>データ型</primary>
     <secondary>定数</secondary>
    </indexterm>

    <para>
<!--
     A constant of an <emphasis>arbitrary</emphasis> type can be
     entered using any one of the following notations:
-->
<emphasis>任意の</emphasis>型の定数は下記の表記のいずれかを使って入力できます。
<synopsis>
<replaceable>type</replaceable> '<replaceable>string</replaceable>'
'<replaceable>string</replaceable>'::<replaceable>type</replaceable>
CAST ( '<replaceable>string</replaceable>' AS <replaceable>type</replaceable> )
</synopsis>
<!--
     The string constant's text is passed to the input conversion
     routine for the type called <replaceable>type</replaceable>. The
     result is a constant of the indicated type.  The explicit type
     cast can be omitted if there is no ambiguity as to the type the
     constant must be (for example, when it is assigned directly to a
     table column), in which case it is automatically coerced.
-->
文字列定数のテキストは<replaceable>type</replaceable>と呼ばれる型の入力変換ルーチンへと渡されます。
結果は指示された型の定数です。
明示的な型キャストは、定数がどの型でなければならないかについて曖昧な点がなければ（例えば定数が直接テーブル列に代入されている場合）省略しても構いません。
その場合自動的に型強制されます。
    </para>

    <para>
<!--
     The string constant can be written using either regular SQL
     notation or dollar-quoting.
-->
文字列定数は通常のSQL記法でもドル引用符付けでも記述できます。
    </para>

    <para>
<!--
     It is also possible to specify a type coercion using a function-like
     syntax:
-->
     関数のような構文を使って型強制を指定することも可能です。
<synopsis>
<replaceable>typename</replaceable> ( '<replaceable>string</replaceable>' )
</synopsis>
<!--
     but not all type names can be used in this way; see <xref
     linkend="sql-syntax-type-casts"/> for details.
-->
しかし、全ての型の名前でこの方法は使用できるというわけではありません。
詳細は<xref linkend="sql-syntax-type-casts"/>を参照してください。
    </para>

    <para>
<!--
     The <literal>::</literal>, <literal>CAST()</literal>, and
     function-call syntaxes can also be used to specify run-time type
     conversions of arbitrary expressions, as discussed in <xref
     linkend="sql-syntax-type-casts"/>.  To avoid syntactic ambiguity, the
     <literal><replaceable>type</replaceable> '<replaceable>string</replaceable>'</literal>
     syntax can only be used to specify the type of a simple literal constant.
     Another restriction on the
     <literal><replaceable>type</replaceable> '<replaceable>string</replaceable>'</literal>
     syntax is that it does not work for array types; use <literal>::</literal>
     or <literal>CAST()</literal> to specify the type of an array constant.
-->
<literal>::</literal>、<literal>CAST()</literal>や関数呼び出し構文は、<xref linkend="sql-syntax-type-casts"/>で説明する通り、任意の式の実行時の型変換を指定するために使うこともできます。
構文的なあいまいさをなくすために、<literal><replaceable>type</replaceable> '<replaceable>string</replaceable>'</literal>という形式は単なるリテラル定数を指定する場合にのみ使うことができます。
この他<literal><replaceable>type</replaceable> '<replaceable>string</replaceable>'</literal>構文には、配列型では動作しないという制限があります。
配列型の定数の型を指定する場合は<literal>::</literal>か<literal>CAST()</literal>を使用してください。
    </para>

    <para>
<!--
     The <literal>CAST()</literal> syntax conforms to SQL.  The
     <literal><replaceable>type</replaceable> '<replaceable>string</replaceable>'</literal>
     syntax is a generalization of the standard: SQL specifies this syntax only
     for a few data types, but <productname>PostgreSQL</productname> allows it
     for all types.  The syntax with
     <literal>::</literal> is historical <productname>PostgreSQL</productname>
     usage, as is the function-call syntax.
-->
<literal>CAST()</literal>構文はSQLに従っています。
<literal><replaceable>type</replaceable> '<replaceable>string</replaceable>'</literal>構文は、標準を一般化したものです。
SQLでは、この構文を数個のデータ型でのみ規定しています。
しかし、<productname>PostgreSQL</productname>ではすべての型で使用できます。
<literal>::</literal>付きの構文は、歴史的に<productname>PostgreSQL</productname>で使用されてきました。
関数呼び出し構文も同じく歴史的に使用されているものです。
    </para>
   </sect3>
  </sect2>

  <sect2 id="sql-syntax-operators">
<!--
   <title>Operators</title>
-->
   <title>演算子</title>

   <indexterm zone="sql-syntax-operators">
    <primary>operator</primary>
    <secondary>syntax</secondary>
   </indexterm>
   <indexterm zone="sql-syntax-operators">
    <primary>演算子</primary>
    <secondary>構文</secondary>
   </indexterm>

   <para>
<!--
    An operator name is a sequence of up to <symbol>NAMEDATALEN</symbol>-1
    (63 by default) characters from the following list:
-->
演算子は<symbol>NAMEDATALEN</symbol>-1（デフォルトは63）までの長さの、以下に示すリストに含まれる文字の並びです。
<literallayout>
+ - * / &lt; &gt; = ~ ! @ # % ^ &amp; | ` ?
</literallayout>

<!--
    There are a few restrictions on operator names, however:
-->
しかし、演算子の名前にはいくつかの制約があります。
    <itemizedlist>
     <listitem>
      <para>
<!--
       <literal>&#45;-</literal> and <literal>/*</literal> cannot appear
       anywhere in an operator name, since they will be taken as the
       start of a comment.
-->
<literal>--</literal>と<literal>/*</literal>は演算子名の中に使うことができません。
なぜならこれらはコメントの始まりと解釈されるからです。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       A multiple-character operator name cannot end in <literal>+</literal> or <literal>-</literal>,
       unless the name also contains at least one of these characters:
-->
複数文字の演算子名は、その名前が少なくとも下記の文字の1つ以上を含まない限り、<literal>+</literal>や<literal>-</literal>で終わることができません。
<literallayout>
~ ! @ # % ^ &amp; | ` ?
</literallayout>
<!--
       For example, <literal>@-</literal> is an allowed operator name,
       but <literal>*-</literal> is not.  This restriction allows
       <productname>PostgreSQL</productname> to parse SQL-compliant
       queries without requiring spaces between tokens.
-->
例えば、<literal>@-</literal>は演算子名として認められていますが、<literal>*-</literal>は認められていません。
この制限により<productname>PostgreSQL</productname>は、SQLに準拠する問い合わせをトークン同士の間に空白を要求せず、解析できます。
      </para>
     </listitem>
    </itemizedlist>
   </para>

   <para>
<!--
    When working with non-SQL-standard operator names, you will usually
    need to separate adjacent operators with spaces to avoid ambiguity.
    For example, if you have defined a prefix operator named <literal>@</literal>,
    you cannot write <literal>X*@Y</literal>; you must write
    <literal>X* @Y</literal> to ensure that
    <productname>PostgreSQL</productname> reads it as two operator names
    not one.
-->
非標準SQLの演算子名を使う場合、通常は曖昧さを回避するために、隣り合った演算子を空白で区切る必要があります。
例えば<literal>@</literal>という前置演算子を定義した場合、<literal>X*@Y</literal>とは書けません。
<productname>PostgreSQL</productname>がこれを確実に1つではなく2つの演算子名として解釈できるように、<literal>X* @Y</literal>と書く必要があります。
   </para>
  </sect2>

  <sect2 id="sql-syntax-special-chars">
<!--
   <title>Special Characters</title>
-->
   <title>特殊文字</title>

  <para>
<!--
   Some characters that are not alphanumeric have a special meaning
   that is different from being an operator.  Details on the usage can
   be found at the location where the respective syntax element is
   described.  This section only exists to advise the existence and
   summarize the purposes of these characters.
-->
英数字ではないいくつかの文字は、演算子であることとは異なる特殊な意味を持っています。
使用方法の詳細はそれぞれの構文要素についてのところで説明します。
本節では、単にその存在を知らせ、これらの文字の目的をまとめるに留めます。

   <itemizedlist>
    <listitem>
     <para>
<!--
      A dollar sign (<literal>$</literal>) followed by digits is used
      to represent a positional parameter in the body of a function
      definition or a prepared statement.  In other contexts the
      dollar sign can be part of an identifier or a dollar-quoted string
      constant.
-->
直後に数字が続くドル記号（<literal>$</literal>）は、関数定義の本体またはプリペアド文中の位置パラメータを表すために使われます。
他の文脈ではドル記号は識別子名の一部であるかもしれませんし、ドル引用符付けされた文字列定数の一部であるかもしれません。
     </para>
    </listitem>

    <listitem>
     <para>
<!--
      Parentheses (<literal>()</literal>) have their usual meaning to
      group expressions and enforce precedence.  In some cases
      parentheses are required as part of the fixed syntax of a
      particular SQL command.
-->
括弧（<literal>()</literal>）は、通常通り式をまとめ優先するという意味を持ちます。
場合によっては括弧は、特定のSQLコマンドの固定構文の一部として要求されることがあります。
     </para>
    </listitem>

    <listitem>
     <para>
<!--
      Brackets (<literal>[]</literal>) are used to select the elements
      of an array.  See <xref linkend="arrays"/> for more information
      on arrays.
-->
大括弧（<literal>[]</literal>）は、配列要素を選択するために使われます。
配列に関する詳しい情報は<xref linkend="arrays"/>を参照してください。
     </para>
    </listitem>

    <listitem>
     <para>
<!--
      Commas (<literal>,</literal>) are used in some syntactical
      constructs to separate the elements of a list.
-->
カンマ（<literal>,</literal>）は、リストの要素を区切るために構文的構成体で使われることがあります。
     </para>
    </listitem>

    <listitem>
     <para>
<!--
      The semicolon (<literal>;</literal>) terminates an SQL command.
      It cannot appear anywhere within a command, except within a
      string constant or quoted identifier.
-->
セミコロン（<literal>;</literal>）は、SQLコマンドの終わりを意味します。
文字列定数または引用符付き識別子以外では、コマンドの途中では使うことができません。
     </para>
    </listitem>

    <listitem>
     <para>
<!--
      The colon (<literal>:</literal>) is used to select
      <quote>slices</quote> from arrays. (See <xref
      linkend="arrays"/>.)  In certain SQL dialects (such as Embedded
      SQL), the colon is used to prefix variable names.
-->
コロン（<literal>:</literal>）は、配列から<quote>一部分</quote>を取り出すために使われます。
（<xref linkend="arrays"/>を参照してください。）
いくつかのSQL方言（埋め込みSQLなど）では、コロンは変数名の接頭辞として使われます。
     </para>
    </listitem>

    <listitem>
     <para>
<!--
      The asterisk (<literal>*</literal>) is used in some contexts to denote
      all the fields of a table row or composite value.  It also
      has a special meaning when used as the argument of an
      aggregate function, namely that the aggregate does not require
      any explicit parameter.
-->
アスタリスク（<literal>*</literal>）は、いくつかの文脈において、テーブル行や複合型の全てのフィールドを表現するために使用されます。
また、集約関数の引数として使われる場合も特殊な、つまり、その集約が明示的なパラメータをまったく必要としないという意味を持ちます。
     </para>
    </listitem>

    <listitem>
     <para>
<!--
      The period (<literal>.</literal>) is used in numeric
      constants, and to separate schema, table, and column names.
-->
ピリオド（<literal>.</literal>）は数値定数の中で使われます。
また、スキーマ名、テーブル名、列名を区切るためにも使われます。
     </para>
    </listitem>
   </itemizedlist>

   </para>
  </sect2>

  <sect2 id="sql-syntax-comments">
<!--
   <title>Comments</title>
-->
   <title>コメント</title>

   <indexterm zone="sql-syntax-comments">
    <primary>comment</primary>
    <secondary sortas="SQL">in SQL</secondary>
   </indexterm>
   <indexterm zone="sql-syntax-comments">
    <primary>コメント</primary>
    <secondary>SQL内の</secondary>
   </indexterm>

   <para>
<!--
    A comment is a sequence of characters beginning with
    double dashes and extending to the end of the line, e.g.:
-->
コメントは二重ハイフンで始まる文字の並びで、行の終わりまで続きます。
例えば以下のようになります。
<programlisting>
<!--
&#45;- This is a standard SQL comment
-->
-- これは標準SQLのコメントです
</programlisting>
   </para>

   <para>
<!--
    Alternatively, C-style block comments can be used:
-->
他にも、C言語様式のブロックコメントも使用できます。
<programlisting>
<!--
/* multiline comment
 * with nesting: /* nested block comment */
-->
/* ネストされた複数行にわたる
 * コメント /* ネストされたブロックコメント */
 */
</programlisting>
<!--
    where the comment begins with <literal>/*</literal> and extends to
    the matching occurrence of <literal>*/</literal>. These block
    comments nest, as specified in the SQL standard but unlike C, so that one can
    comment out larger blocks of code that might contain existing block
    comments.
-->
コメントは<literal>/*</literal>で始まり、対応する<literal>*/</literal>で終わります。
これらのブロックコメントはC言語とは異なり、標準SQLで規定されているように入れ子にできます。
したがって、既存のブロックコメントを含む可能性のある大きなコードのブロックをコメントアウトできます。
   </para>

   <para>
<!--
    A comment is removed from the input stream before further syntax
    analysis and is effectively replaced by whitespace.
-->
コメントは、その後の構文解析が行われる前に入力ストリームから取り去られ、事実上、空白で置き換えられます。
   </para>
  </sect2>

  <sect2 id="sql-precedence">
<!--
   <title>Operator Precedence</title>
-->
   <title>演算子の優先順位</title>

   <indexterm zone="sql-precedence">
    <primary>operator</primary>
    <secondary>precedence</secondary>
   </indexterm>
   <indexterm zone="sql-precedence">
    <primary>演算子</primary>
    <secondary>優先順位</secondary>
   </indexterm>

   <para>
<!--
    <xref linkend="sql-precedence-table"/> shows the precedence and
    associativity of the operators in <productname>PostgreSQL</productname>.
    Most operators have the same precedence and are left-associative.
    The precedence and associativity of the operators is hard-wired
    into the parser.
    Add parentheses if you want an expression with multiple operators
    to be parsed in some other way than what the precedence rules imply.
-->
<xref linkend="sql-precedence-table"/>は、<productname>PostgreSQL</productname>の演算子の優先順位と結合性を示しています。
ほとんどの演算子は同じ優先順位を持ち、左結合します。
演算子の優先順位と結合性はパーサに組み込まれています。
複数の演算子のある式を優先順位の規則が意味するのとは異なる順序で解析したい場合には、括弧で囲ってください。
   </para>

   <table id="sql-precedence-table">
<!--
    <title>Operator Precedence (highest to lowest)</title>
-->
    <title>演算子の優先順位（高いものから低いものへ）</title>

    <tgroup cols="3">
     <colspec colname="col1" colwidth="2*"/>
     <colspec colname="col2" colwidth="1*"/>
     <colspec colname="col3" colwidth="2*"/>
     <thead>
      <row>
<!--
       <entry>Operator/Element</entry>
-->
       <entry>演算子/要素</entry>
<!--
       <entry>Associativity</entry>
-->
       <entry>結合性</entry>
<!--
       <entry>Description</entry>
-->
       <entry>説明</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry><token>.</token></entry>
<!--
       <entry>left</entry>
-->
       <entry>左</entry>
<!--
       <entry>table/column name separator</entry>
-->
       <entry>テーブル/列名の区切り文字</entry>
      </row>

      <row>
       <entry><token>::</token></entry>
<!--
       <entry>left</entry>
-->
       <entry>左</entry>
<!--
       <entry><productname>PostgreSQL</productname>-style typecast</entry>
-->
       <entry><productname>PostgreSQL</productname>方式の型キャスト</entry>
      </row>

      <row>
       <entry><token>[</token> <token>]</token></entry>
<!--
       <entry>left</entry>
-->
       <entry>左</entry>
<!--
       <entry>array element selection</entry>
-->
       <entry>配列要素選択</entry>
      </row>

      <row>
       <entry><token>+</token> <token>-</token></entry>
<!--
       <entry>right</entry>
-->
       <entry>右</entry>
<!--
       <entry>unary plus, unary minus</entry>
-->
       <entry>単項加算、単項減算</entry>
      </row>

      <row>
       <entry><token>COLLATE</token></entry>
<!--
       <entry>left</entry>
-->
       <entry>左</entry>
<!--
       <entry>collation selection</entry>
-->
       <entry>照合順序選択</entry>
      </row>

      <row>
       <entry><token>AT</token></entry>
<!--
       <entry>left</entry>
-->
       <entry>左</entry>
       <entry><literal>AT TIME ZONE</literal></entry>
      </row>

      <row>
       <entry><token>^</token></entry>
<!--
       <entry>left</entry>
-->
       <entry>左</entry>
<!--
       <entry>exponentiation</entry>
-->
       <entry>累乗</entry>
      </row>

      <row>
       <entry><token>*</token> <token>/</token> <token>%</token></entry>
<!--
       <entry>left</entry>
-->
       <entry>左</entry>
<!--
       <entry>multiplication, division, modulo</entry>
-->
       <entry>掛け算、割り算、剰余</entry>
      </row>

      <row>
       <entry><token>+</token> <token>-</token></entry>
<!--
       <entry>left</entry>
-->
       <entry>左</entry>
<!--
       <entry>addition, subtraction</entry>
-->
       <entry>加算、減算</entry>
      </row>

      <row>
<!--
       <entry>(any other operator)</entry>
-->
       <entry>(その他の演算子)</entry>
<!--
       <entry>left</entry>
-->
       <entry>左</entry>
<!--
       <entry>all other native and user-defined operators</entry>
-->
       <entry>その他全ての組み込み、あるいはユーザ定義の演算子</entry>
      </row>

      <row>
       <entry><token>BETWEEN</token> <token>IN</token> <token>LIKE</token> <token>ILIKE</token> <token>SIMILAR</token></entry>
       <entry></entry>
<!--
       <entry>range containment, set membership, string matching</entry>
-->
       <entry>範囲内に包含、集合の要素、文字列の一致</entry>
      </row>

      <row>
       <entry><token>&lt;</token> <token>&gt;</token> <token>=</token> <token>&lt;=</token> <token>&gt;=</token> <token>&lt;&gt;</token>
</entry>
       <entry></entry>
<!--
       <entry>comparison operators</entry>
-->
       <entry>比較演算子</entry>
      </row>

      <row>
       <entry><token>IS</token> <token>ISNULL</token> <token>NOTNULL</token></entry>
       <entry></entry>
<!--
       <entry><literal>IS TRUE</literal>, <literal>IS FALSE</literal>, <literal>IS
       NULL</literal>, <literal>IS DISTINCT FROM</literal>, etc.</entry>
-->
       <entry><literal>IS TRUE</literal>、<literal>IS FALSE</literal>、<literal>IS
       NULL</literal>、<literal>IS DISTINCT FROM</literal>、その他</entry>
      </row>

      <row>
       <entry><token>NOT</token></entry>
<!--
       <entry>right</entry>
-->
       <entry>右</entry>
<!--
       <entry>logical negation</entry>
-->
       <entry>論理否定</entry>
      </row>

      <row>
       <entry><token>AND</token></entry>
<!--
       <entry>left</entry>
-->
       <entry>左</entry>
<!--
       <entry>logical conjunction</entry>
-->
       <entry>論理積</entry>
      </row>

      <row>
       <entry><token>OR</token></entry>
<!--
       <entry>left</entry>
-->
       <entry>左</entry>
<!--
       <entry>logical disjunction</entry>
-->
       <entry>論理和</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
<!--
    Note that the operator precedence rules also apply to user-defined
    operators that have the same names as the built-in operators
    mentioned above.  For example, if you define a
    <quote>+</quote> operator for some custom data type it will have
    the same precedence as the built-in <quote>+</quote> operator, no
    matter what yours does.
-->
演算子優先順位の規則は、上記で触れた組み込み演算子と同じ名前を持つユーザ定義演算子にも当てはまります。
例えばもし<quote>+</quote>演算子をある独自のデータ型に定義すると、新しい演算子が何をするかにかかわらず、<quote>+</quote>組み込み演算子と同じ優先順位を持つようになります。
   </para>

   <para>
<!--
    When a schema-qualified operator name is used in the
    <literal>OPERATOR</literal> syntax, as for example in:
-->
次の例のように、<literal>OPERATOR</literal>構文でスキーマで修飾された演算子名を使用する場合、
<programlisting>
SELECT 3 OPERATOR(pg_catalog.+) 4;
</programlisting>
<!--
    the <literal>OPERATOR</literal> construct is taken to have the default precedence
    shown in <xref linkend="sql-precedence-table"/> for
    <quote>any other operator</quote>.  This is true no matter
    which specific operator appears inside <literal>OPERATOR()</literal>.
-->
<literal>OPERATOR</literal>構文は、<xref linkend="sql-precedence-table"/>の<quote>その他の演算子</quote>で示されているデフォルトの優先順位を持つとみなされます。
これは、<literal>OPERATOR()</literal>にどの特定の演算子が入る場合でも変わりません。
   </para>

   <note>
    <para>
<!--
     <productname>PostgreSQL</productname> versions before 9.5 used slightly different
     operator precedence rules.  In particular, <token>&lt;=</token>
     <token>&gt;=</token> and <token>&lt;&gt;</token> used to be treated as
     generic operators; <literal>IS</literal> tests used to have higher priority;
     and <literal>NOT BETWEEN</literal> and related constructs acted inconsistently,
     being taken in some cases as having the precedence of <literal>NOT</literal>
     rather than <literal>BETWEEN</literal>.  These rules were changed for better
     compliance with the SQL standard and to reduce confusion from
     inconsistent treatment of logically equivalent constructs.  In most
     cases, these changes will result in no behavioral change, or perhaps
     in <quote>no such operator</quote> failures which can be resolved by adding
     parentheses.  However there are corner cases in which a query might
     change behavior without any parsing error being reported.
-->
9.5より前の<productname>PostgreSQL</productname>のバージョンでは少し異なる演算子優先順位規則を使っていました。
特に<token>&lt;=</token>、<token>&gt;=</token>、<token>&lt;&gt;</token>は一般的な演算子として扱われていました。<literal>IS</literal>テストは高い優先順位を持つとして使われていました。<literal>NOT BETWEEN</literal>とそれに関係する構文は振る舞いが一貫しておらず、<literal>BETWEEN</literal>ではなく<literal>NOT</literal>の優先順位を持つと見なされる場合がありました。
標準SQLにより準拠し、論理的に等しい構文の一貫しない扱いから来る混乱を減らすように、これらの規則は変更されました。
ほとんどの場合、これらの変更により振る舞いが変わることはないでしょうし、もし変わっても恐らく<quote>no such operator</quote>で失敗になるくらいでしょう。後者は括弧を追加することで解決できるでしょう。
しかしながら、稀に問い合わせがパースエラーを返すことなく振る舞いを変える場合があります。
    </para>
   </note>
  </sect2>
 </sect1>

 <sect1 id="sql-expressions">
<!--
  <title>Value Expressions</title>
-->
  <title>評価式</title>

  <indexterm zone="sql-expressions">
   <primary>expression</primary>
   <secondary>syntax</secondary>
  </indexterm>
  <indexterm zone="sql-expressions">
   <primary>式</primary>
   <secondary>の構文</secondary>
  </indexterm>

  <indexterm zone="sql-expressions">
   <primary>value expression</primary>
  </indexterm>
  <indexterm zone="sql-expressions">
   <primary>評価式</primary>
  </indexterm>

  <indexterm>
   <primary>scalar</primary>
   <see>expression</see>
  </indexterm>
  <indexterm>
   <primary>スカラ</primary>
   <see>式</see>
  </indexterm>

  <para>
<!--
   Value expressions are used in a variety of contexts, such
   as in the target list of the <command>SELECT</command> command, as
   new column values in <command>INSERT</command> or
   <command>UPDATE</command>, or in search conditions in a number of
   commands.  The result of a value expression is sometimes called a
   <firstterm>scalar</firstterm>, to distinguish it from the result of
   a table expression (which is a table).  Value expressions are
   therefore also called <firstterm>scalar expressions</firstterm> (or
   even simply <firstterm>expressions</firstterm>).  The expression
   syntax allows the calculation of values from primitive parts using
   arithmetic, logical, set, and other operations.
-->
評価式は、例えば<command>SELECT</command>コマンドの目的リストとして、<command>INSERT</command>や<command>UPDATE</command>の新しい列の値として、もしくはいくつかのコマンドの検索条件として様々な文脈の中で使われます。
評価式の結果は、テーブル式の結果（つまりテーブル）から区別するために、<firstterm>スカラ</firstterm>と呼ばれることもあります。
したがって、評価式は<firstterm>スカラ式</firstterm>（またはもっと簡単に<firstterm>式</firstterm>）とも呼ばれます。
式の構文によって、基本的な部分から算術、論理、集合などの演算を使って値の計算を行うことができます。
  </para>

  <para>
<!--
   A value expression is one of the following:
-->
評価式は下記のうちのいずれかです。

   <itemizedlist>
    <listitem>
     <para>
<!--
      A constant or literal value
-->
定数あるいはリテラル値
     </para>
    </listitem>

    <listitem>
     <para>
<!--
      A column reference
-->
列の参照
     </para>
    </listitem>

    <listitem>
     <para>
<!--
      A positional parameter reference, in the body of a function definition
      or prepared statement
-->
関数定義の本体やプリペアド文における、位置パラメータ参照
     </para>
    </listitem>

    <listitem>
     <para>
<!--
      A subscripted expression
-->
添字付きの式
     </para>
    </listitem>

    <listitem>
     <para>
<!--
      A field selection expression
-->
フィールド選択式
     </para>
    </listitem>

    <listitem>
     <para>
<!--
      An operator invocation
-->
演算子の呼び出し
     </para>
    </listitem>

    <listitem>
     <para>
<!--
      A function call
-->
関数呼び出し
     </para>
    </listitem>

    <listitem>
     <para>
<!--
      An aggregate expression
-->
集約式
     </para>
    </listitem>

    <listitem>
     <para>
<!--
      A window function call
-->
      ウィンドウ関数呼び出し
     </para>
    </listitem>

    <listitem>
     <para>
<!--
      A type cast
-->
型キャスト
     </para>
    </listitem>

    <listitem>
     <para>
<!--
      A collation expression
-->
照合順序(collation)式
     </para>
    </listitem>

    <listitem>
     <para>
<!--
      A scalar subquery
-->
スカラ副問い合わせ
     </para>
    </listitem>

    <listitem>
     <para>
<!--
      An array constructor
-->
配列コンストラクタ
     </para>
    </listitem>

    <listitem>
     <para>
<!--
      A row constructor
-->
行コンストラクタ
     </para>
    </listitem>

    <listitem>
     <para>
<!--
      Another value expression in parentheses (used to group
      subexpressions and override
      precedence<indexterm><primary>parenthesis</primary></indexterm>)
-->
      （副式をグループ化したり<indexterm><primary>括弧で囲まれた</primary></indexterm>優先順位を変更するのに使用される）括弧で囲まれた別の評価式
     </para>
    </listitem>
   </itemizedlist>
  </para>

  <para>
<!--
   In addition to this list, there are a number of constructs that can
   be classified as an expression but do not follow any general syntax
   rules.  These generally have the semantics of a function or
   operator and are explained in the appropriate location in <xref
   linkend="functions"/>.  An example is the <literal>IS NULL</literal>
   clause.
-->
これ以外にも、式として分類されるけれども一般的な構文規約には従わない、いくつかの構成要素があります。
これらは一般的に関数あるいは演算子の意味を持ちます。
<xref linkend="functions"/>の該当部分で説明されています。
例を挙げると<literal>IS NULL</literal>句があります。
  </para>

  <para>
<!--
   We have already discussed constants in <xref
   linkend="sql-syntax-constants"/>.  The following sections discuss
   the remaining options.
-->
<xref linkend="sql-syntax-constants"/>で既に定数については説明しました。
続く節では残りのオプションについて説明します。
  </para>

  <sect2 id="sql-expressions-column-refs">
<!--
   <title>Column References</title>
-->
   <title>列の参照</title>

   <indexterm>
    <primary>column reference</primary>
   </indexterm>
   <indexterm>
    <primary>列の参照</primary>
   </indexterm>

   <para>
<!--
    A column can be referenced in the form:
-->
列は、下記のような形式で参照できます。
<synopsis>
<replaceable>correlation</replaceable>.<replaceable>columnname</replaceable>
</synopsis>
   </para>

   <para>
<!--
    <replaceable>correlation</replaceable> is the name of a
    table (possibly qualified with a schema name), or an alias for a table
    defined by means of a <literal>FROM</literal> clause.
    The correlation name and separating dot can be omitted if the column name
    is unique across all the tables being used in the current query.  (See also <xref linkend="queries"/>.)
-->
<replaceable>correlation</replaceable>は、テーブル名（スキーマで修飾されている場合もあります）、あるいは<literal>FROM</literal>句で定義されたテーブルの別名です。
correlationの名前と区切り用のドットは、もし列名が現在の問い合わせで使われる全てのテーブルを通して一意である場合は省略できます。
（<xref linkend="queries"/>も参照してください。）
   </para>
  </sect2>

  <sect2 id="sql-expressions-parameters-positional">
<!--
   <title>Positional Parameters</title>
-->
   <title>位置パラメータ</title>

   <indexterm>
    <primary>parameter</primary>
    <secondary>syntax</secondary>
   </indexterm>
   <indexterm>
    <primary>パラメータ</primary>
    <secondary>の構文</secondary>
   </indexterm>

   <indexterm>
    <primary>$</primary>
   </indexterm>

   <para>
<!--
    A positional parameter reference is used to indicate a value
    that is supplied externally to an SQL statement.  Parameters are
    used in SQL function definitions and in prepared queries.  Some
    client libraries also support specifying data values separately
    from the SQL command string, in which case parameters are used to
    refer to the out-of-line data values.
    The form of a parameter reference is:
-->
位置パラメータ参照は、外部からSQL文に渡される値を示すために使用されます。
パラメータはSQL関数定義およびプリペアド問い合わせの中で使用されます。
また、クライアントライブラリの中には、SQLコマンド文字列とデータ値を分離して指定できる機能をサポートするものもあります。
この場合、パラメータは行外データ値を参照するために使用されます。
パラメータ参照の形式は以下のとおりです。
<synopsis>
$<replaceable>number</replaceable>
</synopsis>
   </para>

   <para>
<!--
    For example, consider the definition of a function,
    <function>dept</function>, as:
-->
例えば、関数 <function>dept</function> の定義が以下のようにされたとします。

<programlisting>
CREATE FUNCTION dept(text) RETURNS dept
    AS $$ SELECT * FROM dept WHERE name = $1 $$
    LANGUAGE SQL;
</programlisting>

<!--
    Here the <literal>$1</literal> references the value of the first
    function argument whenever the function is invoked.
-->
ここで<literal>$1</literal>は関数が呼び出される時に最初の関数引数の値を参照します。
   </para>
  </sect2>

  <sect2 id="sql-expressions-subscripts">
<!--
   <title>Subscripts</title>
-->
   <title>添字</title>

   <indexterm>
    <primary>subscript</primary>
   </indexterm>
   <indexterm>
    <primary>添字</primary>
   </indexterm>

   <para>
<!--
    If an expression yields a value of an array type, then a specific
    element of the array value can be extracted by writing
-->
式が配列型の値となる場合、配列値の特定要素は以下のように記述することで抽出できます。
<synopsis>
<replaceable>expression</replaceable>[<replaceable>subscript</replaceable>]
</synopsis>
<!--
    or multiple adjacent elements (an <quote>array slice</quote>) can be extracted
    by writing
-->
また、隣接する複数の要素（<quote>配列の一部分</quote>）は以下のように記述することで抽出できます。
<synopsis>
<replaceable>expression</replaceable>[<replaceable>lower_subscript</replaceable>:<replaceable>upper_subscript</replaceable>]
</synopsis>
<!--
    (Here, the brackets <literal>[ ]</literal> are meant to appear literally.)
    Each <replaceable>subscript</replaceable> is itself an expression,
    which will be rounded to the nearest integer value.
-->
（ここで大括弧<literal>[ ]</literal>は文字通りに記述してください（訳注：これはオプション部分を表す大括弧ではありません）。）
各<replaceable>subscript</replaceable>はそれ自体が式であり、最も近い整数値へと丸められます。
   </para>

   <para>
<!--
    In general the array <replaceable>expression</replaceable> must be
    parenthesized, but the parentheses can be omitted when the expression
    to be subscripted is just a column reference or positional parameter.
    Also, multiple subscripts can be concatenated when the original array
    is multidimensional.
    For example:
-->
一般的には、配列<replaceable>expression</replaceable>は括弧で括らなければなりませんが、添字を付けるそのexpressionが単なる列参照や位置パラメータであった場合、その括弧を省略できます。
また、元の配列が多次元の場合は複数の添字を連結できます。
以下に例を示します。

<programlisting>
mytable.arraycolumn[4]
mytable.two_d_column[17][34]
$1[10:42]
(arrayfunction(a,b))[42]
</programlisting>

<!--
    The parentheses in the last example are required.
    See <xref linkend="arrays"/> for more about arrays.
-->
最後の例では括弧が必要です。
配列の詳細は<xref linkend="arrays"/>を参照してください。
   </para>
  </sect2>

  <sect2 id="field-selection">
<!--
   <title>Field Selection</title>
-->
   <title>フィールド選択</title>

   <indexterm>
    <primary>field selection</primary>
   </indexterm>
   <indexterm>
    <primary>フィールド選択</primary>
   </indexterm>

   <para>
<!--
    If an expression yields a value of a composite type (row type), then a
    specific field of the row can be extracted by writing
-->
式が複合型（行型）の値を生成する場合、行の特定のフィールドは以下のように記述することで抽出できます。
<synopsis>
<replaceable>expression</replaceable>.<replaceable>fieldname</replaceable>
</synopsis>
   </para>

   <para>
<!--
    In general the row <replaceable>expression</replaceable> must be
    parenthesized, but the parentheses can be omitted when the expression
    to be selected from is just a table reference or positional parameter.
    For example:
-->
一般的には、行<replaceable>expression</replaceable>は括弧で括らなければなりません。
しかし、選択元となる式が単なるテーブル参照や位置パラメータの場合、括弧を省略できます。
以下に例を示します。

<programlisting>
mytable.mycolumn
$1.somecolumn
(rowfunction(a,b)).col3
</programlisting>

<!--
    (Thus, a qualified column reference is actually just a special case
    of the field selection syntax.)  An important special case is
    extracting a field from a table column that is of a composite type:
-->
（したがって、修飾された列参照は実際のところ、単なるこのフィールド選択構文の特殊な場合です。）
重要となる特殊な場合としては、複合型のテーブル列からフィールドを抽出するときです。

<programlisting>
(compositecol).somefield
(mytable.compositecol).somefield
</programlisting>

<!--
    The parentheses are required here to show that
    <structfield>compositecol</structfield> is a column name not a table name,
    or that <structname>mytable</structname> is a table name not a schema name
    in the second case.
-->
<structfield>compositecol</structfield>がテーブル名でなく列名であること、または2番目の場合の<structname>mytable</structname>がスキーマ名でなくテーブル名であることを示すため丸括弧が要求されます。
   </para>

   <para>
<!--
    You can ask for all fields of a composite value by
    writing <literal>.*</literal>:
-->
<literal>.*</literal>を記述することで、複合型の全ての値を問い合わせることが可能です。
<programlisting>
(compositecol).*
</programlisting>
<!--
    This notation behaves differently depending on context;
    see <xref linkend="rowtypes-usage"/> for details.
-->
この表記はコンテキストに依存して異なった振る舞いをします。詳細は<xref linkend="rowtypes-usage"/>を参照してください。
   </para>
  </sect2>

  <sect2 id="sql-expressions-operator-calls">
<!--
   <title>Operator Invocations</title>
-->
   <title>演算子の呼び出し</title>

   <indexterm>
    <primary>operator</primary>
    <secondary>invocation</secondary>
   </indexterm>
   <indexterm>
    <primary>演算子</primary>
    <secondary>呼び出し</secondary>
   </indexterm>

   <para>
<!--
    There are two possible syntaxes for an operator invocation:
-->
演算子の呼び出しには以下の2構文が可能です。
    <simplelist>
<!--
     <member><replaceable>expression</replaceable> <replaceable>operator</replaceable> <replaceable>expression</replaceable> (binary infix operator)</member>
     <member><replaceable>operator</replaceable> <replaceable>expression</replaceable> (unary prefix operator)</member>
-->
     <member><replaceable>expression</replaceable> <replaceable>operator</replaceable> <replaceable>expression</replaceable> （二項中置演算子）</member>
     <member><replaceable>operator</replaceable> <replaceable>expression</replaceable> （単項前置演算子）</member>
    </simplelist>
<!--
    where the <replaceable>operator</replaceable> token follows the syntax
    rules of <xref linkend="sql-syntax-operators"/>, or is one of the
    key words <token>AND</token>, <token>OR</token>, and
    <token>NOT</token>, or is a qualified operator name in the form:
-->
ここで<replaceable>operator</replaceable>トークンは、<xref linkend="sql-syntax-operators"/>構文規則に従うもの、もしくはキーワード<token>AND</token>、<token>OR</token>、<token>NOT</token>のいずれか、または以下の形式の修飾された演算子名です。
<synopsis>
<literal>OPERATOR(</literal><replaceable>schema</replaceable><literal>.</literal><replaceable>operatorname</replaceable><literal>)</literal>
</synopsis>
<!--
    Which particular operators exist and whether
    they are unary or binary depends on what operators have been
    defined by the system or the user.  <xref linkend="functions"/>
    describes the built-in operators.
-->
具体的にどんな演算子が存在し、それが単項か二項かどうかは、システムやユーザによってどんな演算子が定義されたかに依存します。
<xref linkend="functions"/>にて、組み込み演算子について説明します。
   </para>
  </sect2>

  <sect2 id="sql-expressions-function-calls">
<!--
   <title>Function Calls</title>
-->
   <title>関数呼び出し</title>

   <indexterm>
    <primary>function</primary>
    <secondary>invocation</secondary>
   </indexterm>
   <indexterm>
    <primary>関数</primary>
    <secondary>呼び出し</secondary>
   </indexterm>

   <para>
<!--
    The syntax for a function call is the name of a function
    (possibly qualified with a schema name), followed by its argument list
    enclosed in parentheses:
-->
関数呼び出しの構文は、関数名（スキーマ名で修飾されている場合があります）に続けてその引数を丸括弧で囲んで列挙したものです。

<synopsis>
<replaceable>function_name</replaceable> (<optional><replaceable>expression</replaceable> <optional>, <replaceable>expression</replaceable> ... </optional></optional> )
</synopsis>
   </para>

   <para>
<!--
    For example, the following computes the square root of 2:
-->
例えば、以下のものは2の平方根を計算します。
<programlisting>
sqrt(2)
</programlisting>
   </para>

   <para>
<!--
    The list of built-in functions is in <xref linkend="functions"/>.
    Other functions can be added by the user.
-->
組み込み関数の一覧は<xref linkend="functions"/>にあります。
他の関数はユーザが追加できます。
   </para>

   <para>
<!--
    When issuing queries in a database where some users mistrust other users,
    observe security precautions from <xref linkend="typeconv-func"/> when
    writing function calls.
-->
あるユーザが他のユーザを信用しないデータベースで問い合わせを発行する場合には、関数呼び出しを書く時に<xref linkend="typeconv-func"/>のセキュリティの事前の対策を守ってください。
   </para>

   <para>
<!--
    The arguments can optionally have names attached.
    See <xref linkend="sql-syntax-calling-funcs"/> for details.
-->
引数には名前を任意で付与できます。詳細は<xref linkend="sql-syntax-calling-funcs"/>を見てください。
   </para>

   <note>
    <para>
<!--
     A function that takes a single argument of composite type can
     optionally be called using field-selection syntax, and conversely
     field selection can be written in functional style.  That is, the
     notations <literal>col(table)</literal> and <literal>table.col</literal> are
     interchangeable.  This behavior is not SQL-standard but is provided
     in <productname>PostgreSQL</productname> because it allows use of functions to
     emulate <quote>computed fields</quote>.  For more information see
     <xref linkend="rowtypes-usage"/>.
-->
複合型の単一引数をとる関数はフィールド選択の構文を使っても呼び出すことができます。
反対にフィールド選択を関数形式で記述することもできます。
つまり、<literal>col(table)</literal>や<literal>table.col</literal>のどちらを使っても良いということです。
この動作は標準SQLにはありませんが、<productname>PostgreSQL</productname>では、これにより<quote>計算されたフィールド</quote>のエミュレートをする関数の利用が可能になるため、提供しています。
詳しくは<xref linkend="rowtypes-usage"/>を参照してください。
    </para>
   </note>
  </sect2>

  <sect2 id="syntax-aggregates">
<!--
   <title>Aggregate Expressions</title>
-->
   <title>集約式</title>

   <indexterm zone="syntax-aggregates">
    <primary>aggregate function</primary>
    <secondary>invocation</secondary>
   </indexterm>
   <indexterm zone="syntax-aggregates">
    <primary>集約関数</primary>
    <secondary>呼び出し</secondary>
   </indexterm>

   <indexterm zone="syntax-aggregates">
    <primary>ordered-set aggregate</primary>
   </indexterm>
   <indexterm zone="syntax-aggregates">
    <primary>順序集合集約</primary>
   </indexterm>

   <indexterm zone="syntax-aggregates">
    <primary>WITHIN GROUP</primary>
   </indexterm>

   <indexterm zone="syntax-aggregates">
    <primary>FILTER</primary>
   </indexterm>

   <para>
<!--
    An <firstterm>aggregate expression</firstterm> represents the
    application of an aggregate function across the rows selected by a
    query.  An aggregate function reduces multiple inputs to a single
    output value, such as the sum or average of the inputs.  The
    syntax of an aggregate expression is one of the following:
-->
<firstterm>集約式</firstterm>は、問い合わせによって選択される行に対して集約関数を適用することを表現します。
集約関数は、例えば入力の合計や平均などのように、複数の入力を単一の出力値にします。
集約式の構文は下記のうちのいずれかです。

<synopsis>
<replaceable>aggregate_name</replaceable> (<replaceable>expression</replaceable> [ , ... ] [ <replaceable>order_by_clause</replaceable> ] ) [ FILTER ( WHERE <replaceable>filter_clause</replaceable> ) ]
<replaceable>aggregate_name</replaceable> (ALL <replaceable>expression</replaceable> [ , ... ] [ <replaceable>order_by_clause</replaceable> ] ) [ FILTER ( WHERE <replaceable>filter_clause</replaceable> ) ]
<replaceable>aggregate_name</replaceable> (DISTINCT <replaceable>expression</replaceable> [ , ... ] [ <replaceable>order_by_clause</replaceable> ] ) [ FILTER ( WHERE <replaceable>filter_clause</replaceable> ) ]
<replaceable>aggregate_name</replaceable> ( * ) [ FILTER ( WHERE <replaceable>filter_clause</replaceable> ) ]
<replaceable>aggregate_name</replaceable> ( [ <replaceable>expression</replaceable> [ , ... ] ] ) WITHIN GROUP ( <replaceable>order_by_clause</replaceable> ) [ FILTER ( WHERE <replaceable>filter_clause</replaceable> ) ]
</synopsis>

<!--
    where <replaceable>aggregate_name</replaceable> is a previously
    defined aggregate (possibly qualified with a schema name) and
    <replaceable>expression</replaceable> is
    any value expression that does not itself contain an aggregate
    expression or a window function call.  The optional
    <replaceable>order_by_clause</replaceable> and
    <replaceable>filter_clause</replaceable> are described below.
-->
ここで、<replaceable>aggregate_name</replaceable>は事前に定義された集約（スキーマ名で修飾された場合もあります）、<replaceable>expression</replaceable>はそれ自体に集約式またはウィンドウ関数呼び出しを含まない任意の値評価式です。
省略可能な<replaceable>order_by_clause</replaceable>と<replaceable>filter_clause</replaceable>は後述します。
   </para>

   <para>
<!--
    The first form of aggregate expression invokes the aggregate
    once for each input row.
    The second form is the same as the first, since
    <literal>ALL</literal> is the default.
    The third form invokes the aggregate once for each distinct value
    of the expression (or distinct set of values, for multiple expressions)
    found in the input rows.
    The fourth form invokes the aggregate once for each input row; since no
    particular input value is specified, it is generally only useful
    for the <function>count(*)</function> aggregate function.
    The last form is used with <firstterm>ordered-set</firstterm> aggregate
    functions, which are described below.
-->
集約式の最初の構文は、それぞれの入力行に対して1回ずつ集約を呼び出します。
<literal>ALL</literal>はデフォルトなので、2つ目の形式は最初の形式と同じです。
3番目の形式は、入力行の中にある式の、全ての重複しない値（複数式では重複しない値集合）の集約を呼び出します。
4番目の形式はそれぞれの入力行に対して1回ずつ集約を呼び出します。具体的な入力値が指定されていないため、これは一般的に<function>count(*)</function>集約関数でのみ役に立ちます。
最後の形式は<firstterm>順序集合</firstterm>集約関数で使われるもので、順序集合集約関数については後述します。
   </para>

   <para>
<!--
    Most aggregate functions ignore null inputs, so that rows in which
    one or more of the expression(s) yield null are discarded.  This
    can be assumed to be true, unless otherwise specified, for all
    built-in aggregates.
-->
ほとんどの集約関数はNULL入力を無視するため、行内の1つ以上の式がNULLを返す行は破棄されます。
特記されていない限り、すべての組み込み集約がそのような動作になると想定して良いです。
   </para>

   <para>
<!--
    For example, <literal>count(*)</literal> yields the total number
    of input rows; <literal>count(f1)</literal> yields the number of
    input rows in which <literal>f1</literal> is non-null, since
    <function>count</function> ignores nulls; and
    <literal>count(distinct f1)</literal> yields the number of
    distinct non-null values of <literal>f1</literal>.
-->
例えば、<literal>count(*)</literal>は入力行の合計数を求めます。
<function>count</function>はNULLを無視しますので、<literal>count(f1)</literal>は<literal>f1</literal>が非NULLである入力行の数を求めます。
<literal>count(distinct f1)</literal>は<literal>f1</literal>の重複しない非NULL値の数を求めます。
   </para>

   <para>
<!--
    Ordinarily, the input rows are fed to the aggregate function in an
    unspecified order.  In many cases this does not matter; for example,
    <function>min</function> produces the same result no matter what order it
    receives the inputs in.  However, some aggregate functions
    (such as <function>array_agg</function> and <function>string_agg</function>) produce
    results that depend on the ordering of the input rows.  When using
    such an aggregate, the optional <replaceable>order_by_clause</replaceable> can be
    used to specify the desired ordering.  The <replaceable>order_by_clause</replaceable>
    has the same syntax as for a query-level <literal>ORDER BY</literal> clause, as
    described in <xref linkend="queries-order"/>, except that its expressions
    are always just expressions and cannot be output-column names or numbers.
    For example:
-->
通常、入力行は順序を指定されずに集約関数に与えられます。
多くの場合では問題になりません。たとえば<function>min</function>は入力順序に関係なく同一の結果を返します。
しかし一部の集約関数(<function>array_agg</function>および<function>string_agg</function>など)は入力行の順序に依存した結果を返します。
こうした集約関数を使用する際は、オプションの<replaceable>order_by_clause</replaceable>を使用して必要とする順序を指定できます。
<replaceable>order_by_clause</replaceable>は、<xref linkend="queries-order"/>で説明する問い合わせレベルの<literal>ORDER BY</literal>句と同じ構文を取りますが、その式は常に単なる式であり、出力列名や序数とすることはできません。
以下に例を示します。
<programlisting>
SELECT array_agg(a ORDER BY b DESC) FROM table;
</programlisting>
   </para>

   <para>
<!--
    When dealing with multiple-argument aggregate functions, note that the
    <literal>ORDER BY</literal> clause goes after all the aggregate arguments.
    For example, write this:
-->
複数の引数を取る集約関数を扱う場合、<literal>ORDER BY</literal>句はすべての集約引数の後に指定することに注意してください。
例えば、
<programlisting>
SELECT string_agg(a, ',' ORDER BY a) FROM table;
</programlisting>
<!--
    not this:
-->
であり、
<programlisting>
SELECT string_agg(a ORDER BY a, ',') FROM table;  -- incorrect
</programlisting>
ではありません。
<!--
    The latter is syntactically valid, but it represents a call of a
    single-argument aggregate function with two <literal>ORDER BY</literal> keys
    (the second one being rather useless since it's a constant).
-->
    後者は構文的には有効なものですが、2つの<literal>ORDER BY</literal>キーを持つ単一引数の集約関数の呼び出しを表しています（2つ目のキーは定数なので役には立ちません）。
   </para>

   <para>
<!--
    If <literal>DISTINCT</literal> is specified in addition to an
    <replaceable>order_by_clause</replaceable>, then all the <literal>ORDER BY</literal>
    expressions must match regular arguments of the aggregate; that is,
    you cannot sort on an expression that is not included in the
    <literal>DISTINCT</literal> list.
-->
<replaceable>order_by_clause</replaceable>に加え<literal>DISTINCT</literal>が指定された場合、すべての<literal>ORDER BY</literal>式が集約関数の通常の引数に一致しなければなりません。つまり、<literal>DISTINCT</literal>リストに含まれない式でソートすることはできません。
   </para>

   <note>
    <para>
<!--
     The ability to specify both <literal>DISTINCT</literal> and <literal>ORDER BY</literal>
     in an aggregate function is a <productname>PostgreSQL</productname> extension.
-->
集約関数において<literal>DISTINCT</literal>と<literal>ORDER BY</literal>の両方を指定できる機能は<productname>PostgreSQL</productname>の拡張です。
    </para>
   </note>

   <para>
<!--
    Placing <literal>ORDER BY</literal> within the aggregate's regular argument
    list, as described so far, is used when ordering the input rows for
    general-purpose and statistical aggregates, for which ordering is
    optional.  There is a
    subclass of aggregate functions called <firstterm>ordered-set
    aggregates</firstterm> for which an <replaceable>order_by_clause</replaceable>
    is <emphasis>required</emphasis>, usually because the aggregate's computation is
    only sensible in terms of a specific ordering of its input rows.
    Typical examples of ordered-set aggregates include rank and percentile
    calculations.  For an ordered-set aggregate,
    the <replaceable>order_by_clause</replaceable> is written
    inside <literal>WITHIN GROUP (...)</literal>, as shown in the final syntax
    alternative above.  The expressions in
    the <replaceable>order_by_clause</replaceable> are evaluated once per
    input row just like regular aggregate arguments, sorted as per
    the <replaceable>order_by_clause</replaceable>'s requirements, and fed
    to the aggregate function as input arguments.  (This is unlike the case
    for a non-<literal>WITHIN GROUP</literal> <replaceable>order_by_clause</replaceable>,
    which is not treated as argument(s) to the aggregate function.)  The
    argument expressions preceding <literal>WITHIN GROUP</literal>, if any, are
    called <firstterm>direct arguments</firstterm> to distinguish them from
    the <firstterm>aggregated arguments</firstterm> listed in
    the <replaceable>order_by_clause</replaceable>.  Unlike regular aggregate
    arguments, direct arguments are evaluated only once per aggregate call,
    not once per input row.  This means that they can contain variables only
    if those variables are grouped by <literal>GROUP BY</literal>; this restriction
    is the same as if the direct arguments were not inside an aggregate
    expression at all.  Direct arguments are typically used for things like
    percentile fractions, which only make sense as a single value per
    aggregation calculation.  The direct argument list can be empty; in this
    case, write just <literal>()</literal> not <literal>(*)</literal>.
    (<productname>PostgreSQL</productname> will actually accept either spelling, but
    only the first way conforms to the SQL standard.)
-->
上記のように集約の通常の引数リストに<literal>ORDER BY</literal>を置くことは、汎用的で統計的な集約への入力行を整列する時に使いますが、その整列は省略可能です。
たいていは集約の計算がその入力行の特定の順序に関してのみ意味を持つために、<replaceable>order_by_clause</replaceable>が<emphasis>必要な</emphasis><firstterm>順序集合集約</firstterm>と呼ばれる集約関数の副クラスがあります。
順序集合集約の典型的な例は順位や百分位数の計算を含みます。
順序集合集約では、<replaceable>order_by_clause</replaceable>は上の構文の最後に示したように<literal>WITHIN GROUP (...)</literal>の中に書かれます。
<replaceable>order_by_clause</replaceable>の式は、通常の集約の引数のように入力行1行につき一度評価され、<replaceable>order_by_clause</replaceable>の要求に従って整列され、集約関数に入力引数として渡されます。
（非<literal>WITHIN GROUP</literal> <replaceable>order_by_clause</replaceable>ではない場合はこれとは異なり、集約関数の引数としては扱われません。）
<literal>WITHIN GROUP</literal>の前に引数の式があれば、<replaceable>order_by_clause</replaceable>に書かれた<firstterm>集約引数</firstterm>と区別するために<firstterm>直接引数</firstterm>と呼ばれます。
通常の集約引数とは異なり、直接引数は集約の呼び出しの時に一度だけ評価され、入力行1行に一度ではありません。
これは、変数が<literal>GROUP BY</literal>によりグループ化された場合にのみ、その変数を含むことが可能であることを意味します。この制限は直接引数が集約式の中に全くない場合と同じです。
直接引数は、典型的には1度の集約計算で1つの値だけが意味がある百分位数のようなもので使われます。
直接引数のリストは空でも構いません。この場合、<literal>(*)</literal>ではなく<literal>()</literal>と書いてください。
（<productname>PostgreSQL</productname>は実際にどちらの綴りも受け付けますが、後者だけが標準SQLに準拠しています。）
   </para>

   <para>
    <indexterm>
     <primary>median</primary>
     <seealso>percentile</seealso>
    </indexterm>
    <indexterm>
     <primary>中央値(メジアン)</primary>
     <seealso>百分位数</seealso>
    </indexterm>
<!--
    An example of an ordered-set aggregate call is:
-->
順序集合集約の例は以下のとおりです。

<programlisting>
SELECT percentile_cont(0.5) WITHIN GROUP (ORDER BY income) FROM households;
 percentile_cont
-----------------
           50489
</programlisting>

<!--
   which obtains the 50th percentile, or median, value of
   the <structfield>income</structfield> column from table <structname>households</structname>.
   Here, <literal>0.5</literal> is a direct argument; it would make no sense
   for the percentile fraction to be a value varying across rows.
-->
これは、テーブル<structname>households</structname>から<structfield>income</structfield>列の50番目の百分位数、すなわち中央値を得ます。
ここで<literal>0.5</literal>は直接引数です。百分位数が行毎に変化する値であったら意味がありません。
   </para>

   <para>
<!--
    If <literal>FILTER</literal> is specified, then only the input
    rows for which the <replaceable>filter_clause</replaceable>
    evaluates to true are fed to the aggregate function; other rows
    are discarded.  For example:
-->
<literal>FILTER</literal>が指定されていれば、<replaceable>filter_clause</replaceable>が真と評価した入力行のみが集約関数に渡されます。それ以外の行は破棄されます。
例えば、
<programlisting>
SELECT
    count(*) AS unfiltered,
    count(*) FILTER (WHERE i &lt; 5) AS filtered
FROM generate_series(1,10) AS s(i);
 unfiltered | filtered
------------+----------
         10 |        4
(1 row)
</programlisting>
   </para>

   <para>
<!--
    The predefined aggregate functions are described in <xref
    linkend="functions-aggregate"/>.  Other aggregate functions can be added
    by the user.
-->
定義済みの集約関数は<xref linkend="functions-aggregate"/>で説明されています。
ユーザは他の集約関数を追加できます。
   </para>

   <para>
<!--
    An aggregate expression can only appear in the result list or
    <literal>HAVING</literal> clause of a <command>SELECT</command> command.
    It is forbidden in other clauses, such as <literal>WHERE</literal>,
    because those clauses are logically evaluated before the results
    of aggregates are formed.
-->
集約式は、<command>SELECT</command>コマンドの結果リストもしくは<literal>HAVING</literal>句内でのみ記述できます。
<literal>WHERE</literal>などの他の句では許されません。
これらの句は集約結果が形成される前に論理的に評価されるためです。
   </para>

   <para>
<!--
    When an aggregate expression appears in a subquery (see
    <xref linkend="sql-syntax-scalar-subqueries"/> and
    <xref linkend="functions-subquery"/>), the aggregate is normally
    evaluated over the rows of the subquery.  But an exception occurs
    if the aggregate's arguments (and <replaceable>filter_clause</replaceable>
    if any) contain only outer-level variables:
    the aggregate then belongs to the nearest such outer level, and is
    evaluated over the rows of that query.  The aggregate expression
    as a whole is then an outer reference for the subquery it appears in,
    and acts as a constant over any one evaluation of that subquery.
    The restriction about
    appearing only in the result list or <literal>HAVING</literal> clause
    applies with respect to the query level that the aggregate belongs to.
-->
集約式が副問い合わせ（<xref linkend="sql-syntax-scalar-subqueries"/>と<xref linkend="functions-subquery"/>を参照）内に現れた場合、通常、集約は副問い合わせの行全体に対して評価されます。
しかし、その集約の引数(と、もしあれば<replaceable>filter_clause</replaceable>)が上位レベルの変数のみを持つ場合は例外です。
その場合、集約は最も近い外側のレベルに属し、その問い合わせの行全体に対して評価されます。
全体として、その集約式は、その後、その集約を含む副問い合わせでは外部参照となり、その副問い合わせにおける評価に対しては定数として動作します。
結果リストもしくは<literal>HAVING</literal>句にのみ現れるという制約は、その集約が属する問い合わせレベルに関連して適用されます。
   </para>
  </sect2>

  <sect2 id="syntax-window-functions">
<!--
   <title>Window Function Calls</title>
-->
   <title>ウィンドウ関数呼び出し</title>

   <indexterm zone="syntax-window-functions">
    <primary>window function</primary>
    <secondary>invocation</secondary>
   </indexterm>
   <indexterm zone="syntax-window-functions">
    <primary>ウィンドウ関数</primary>
    <secondary>起動</secondary>
   </indexterm>

   <indexterm zone="syntax-window-functions">
    <primary>OVER clause</primary>
   </indexterm>
   <indexterm zone="syntax-window-functions">
    <primary>OVER句</primary>
   </indexterm>

   <para>
<!--
    A <firstterm>window function call</firstterm> represents the application
    of an aggregate-like function over some portion of the rows selected
    by a query.  Unlike non-window aggregate calls, this is not tied
    to grouping of the selected rows into a single output row &mdash; each
    row remains separate in the query output.  However the window function
    has access to all the rows that would be part of the current row's
    group according to the grouping specification (<literal>PARTITION BY</literal>
    list) of the window function call.
    The syntax of a window function call is one of the following:
-->
<firstterm>ウィンドウ関数呼び出し</firstterm>は、問い合わせにより選択された行のある部分に渡って集約のような機能を実現することを表します。
非ウィンドウ集約関数呼び出しと異なり、これは選択された行を1つの行にグループ化することに束縛されず、各行は別途問い合わせ出力に残ります。
しかしウィンドウ関数は、ウィンドウ関数呼び出しのグループ化指定（<literal>PARTITION BY</literal>リスト）に従った、現在の行のグループの一部となる行にすべてアクセスできます。
ウィンドウ関数呼び出しの構文は以下のいずれかです。

<synopsis>
<replaceable>function_name</replaceable> (<optional><replaceable>expression</replaceable> <optional>, <replaceable>expression</replaceable> ... </optional></optional>) [ FILTER ( WHERE <replaceable>filter_clause</replaceable> ) ] OVER <replaceable>window_name</replaceable>
<replaceable>function_name</replaceable> (<optional><replaceable>expression</replaceable> <optional>, <replaceable>expression</replaceable> ... </optional></optional>) [ FILTER ( WHERE <replaceable>filter_clause</replaceable> ) ] OVER ( <replaceable class="parameter">window_definition</replaceable> )
<replaceable>function_name</replaceable> ( * ) [ FILTER ( WHERE <replaceable>filter_clause</replaceable> ) ] OVER <replaceable>window_name</replaceable>
<replaceable>function_name</replaceable> ( * ) [ FILTER ( WHERE <replaceable>filter_clause</replaceable> ) ] OVER ( <replaceable class="parameter">window_definition</replaceable> )
</synopsis>
<!--
    where <replaceable class="parameter">window_definition</replaceable>
    has the syntax
-->
ここで、<replaceable class="parameter">window_definition</replaceable>は以下の構文になります。
<synopsis>
[ <replaceable class="parameter">existing_window_name</replaceable> ]
[ PARTITION BY <replaceable class="parameter">expression</replaceable> [, ...] ]
[ ORDER BY <replaceable class="parameter">expression</replaceable> [ ASC | DESC | USING <replaceable class="parameter">operator</replaceable> ] [ NULLS { FIRST | LAST } ] [, ...] ]
[ <replaceable class="parameter">frame_clause</replaceable> ]
</synopsis>
<!--
    The optional <replaceable class="parameter">frame_clause</replaceable>
    can be one of
-->
オプションの<replaceable class="parameter">frame_clause</replaceable>は次の中の１つです。
<synopsis>
{ RANGE | ROWS | GROUPS } <replaceable>frame_start</replaceable> [ <replaceable>frame_exclusion</replaceable> ]
{ RANGE | ROWS | GROUPS } BETWEEN <replaceable>frame_start</replaceable> AND <replaceable>frame_end</replaceable> [ <replaceable>frame_exclusion</replaceable> ]
</synopsis>
<!--
    where <replaceable>frame_start</replaceable>
    and <replaceable>frame_end</replaceable> can be one of
-->
ここで<replaceable>frame_start</replaceable>および<replaceable>frame_end</replaceable>は以下のいずれかです。
<synopsis>
UNBOUNDED PRECEDING
<replaceable>offset</replaceable> PRECEDING
CURRENT ROW
<replaceable>offset</replaceable> FOLLOWING
UNBOUNDED FOLLOWING
</synopsis>
<!--
    and <replaceable>frame_exclusion</replaceable> can be one of
-->
そして、<replaceable>frame_exclusion</replaceable>は以下のいずれかです。
<synopsis>
EXCLUDE CURRENT ROW
EXCLUDE GROUP
EXCLUDE TIES
EXCLUDE NO OTHERS
</synopsis>
   </para>

   <para>
<!--
    Here, <replaceable>expression</replaceable> represents any value
    expression that does not itself contain window function calls.
-->
ここで、<replaceable>expression</replaceable>はそれ自身のウィンドウ関数呼び出しを含まない任意の値式を表わします。
   </para>

   <para>
<!--
    <replaceable>window_name</replaceable> is a reference to a named window
    specification defined in the query's <literal>WINDOW</literal> clause.
    Alternatively, a full <replaceable>window_definition</replaceable> can
    be given within parentheses, using the same syntax as for defining a
    named window in the <literal>WINDOW</literal> clause; see the
    <xref linkend="sql-select"/> reference page for details.  It's worth
    pointing out that <literal>OVER wname</literal> is not exactly equivalent to
    <literal>OVER (wname ...)</literal>; the latter implies copying and modifying the
    window definition, and will be rejected if the referenced window
    specification includes a frame clause.
-->
<replaceable>window_name</replaceable>は、問い合わせの<literal>WINDOW</literal>句で定義された名前付きウィンドウ仕様への参照です。
あるいはまた、完全な<replaceable>window_definition</replaceable>を<literal>WINDOW</literal>句で定義された名前付きウィンドウと同じ構文を使って丸括弧の中に書くことができます。
詳細は<xref linkend="sql-select"/>リファレンスページを見てください。
<literal>OVER wname</literal>は<literal>OVER (wname ...)</literal>と厳密には等価でないことを指摘しておくのは価値のあることでしょう。
後者はウィンドウ定義をコピーしたり修正したりすることを示唆しており、参照されるウィンドウ仕様がフレーム句を含む場合には拒絶されます。
   </para>

   <para>
<!--
    The <literal>PARTITION BY</literal> clause groups the rows of the query into
    <firstterm>partitions</firstterm>, which are processed separately by the window
    function.  <literal>PARTITION BY</literal> works similarly to a query-level
    <literal>GROUP BY</literal> clause, except that its expressions are always just
    expressions and cannot be output-column names or numbers.
    Without <literal>PARTITION BY</literal>, all rows produced by the query are
    treated as a single partition.
    The <literal>ORDER BY</literal> clause determines the order in which the rows
    of a partition are processed by the window function.  It works similarly
    to a query-level <literal>ORDER BY</literal> clause, but likewise cannot use
    output-column names or numbers.  Without <literal>ORDER BY</literal>, rows are
    processed in an unspecified order.
-->
<literal>PARTITION BY</literal>句は問い合わせの行を<firstterm>パーティション</firstterm>に纏め、パーティションはウィンドウ関数により別々に処理されます。
<literal>PARTITION BY</literal>は、その式が常に式であって出力列名や番号ではないという点を除いて、問い合わせレベルの<literal>GROUP BY</literal>句と同様に動作します。
<literal>PARTITION BY</literal>がなければ、問い合わせで生じる行すべてが一つのパーティションとして扱われます。
<literal>ORDER BY</literal>句はパーティションの行がウィンドウ関数により処理される順序を決定します。
問い合わせレベルの<literal>ORDER BY</literal>句と同様に動作しますが、やはり出力列名や番号は使えません。
<literal>ORDER BY</literal>がなければ、行は不定の順序で処理されます。
   </para>

   <para>
<!--
    The <replaceable class="parameter">frame_clause</replaceable> specifies
    the set of rows constituting the <firstterm>window frame</firstterm>, which is a
    subset of the current partition, for those window functions that act on
    the frame instead of the whole partition.  The set of rows in the frame
    can vary depending on which row is the current row.  The frame can be
    specified in <literal>RANGE</literal>, <literal>ROWS</literal>
    or <literal>GROUPS</literal> mode; in each case, it runs from
    the <replaceable>frame_start</replaceable> to
    the <replaceable>frame_end</replaceable>.
    If <replaceable>frame_end</replaceable> is omitted, the end defaults
    to <literal>CURRENT ROW</literal>.
-->
<replaceable class="parameter">frame_clause</replaceable>は、パーティション全体ではなくフレーム上で作動するウィンドウ関数に対して、<firstterm>ウィンドウフレーム</firstterm>を構成する行の集合を指定します。
ウィンドウフレームは現在のパーティションの部分集合になります。
フレームの中の行の集合は、どの行が現在の行であるかによって変わります。
フレームは<literal>RANGE</literal>モード、<literal>ROWS</literal>モード、<literal>GROUPS</literal>でも指定できます。
どちらの場合でも<replaceable>frame_start</replaceable>から<replaceable>frame_end</replaceable>までです。
<replaceable>frame_end</replaceable>を省略した場合のデフォルトは<literal>CURRENT ROW</literal>です。
   </para>

   <para>
<!--
    A <replaceable>frame_start</replaceable> of <literal>UNBOUNDED PRECEDING</literal> means
    that the frame starts with the first row of the partition, and similarly
    a <replaceable>frame_end</replaceable> of <literal>UNBOUNDED FOLLOWING</literal> means
    that the frame ends with the last row of the partition.
-->
<replaceable>frame_start</replaceable>が<literal>UNBOUNDED PRECEDING</literal>ならばフレームがパーティションの最初の行から始まることを意味し、同様に、<replaceable>frame_end</replaceable>が<literal>UNBOUNDED FOLLOWING</literal>ならばフレームがパーティションの最後の行で終わることを意味します。
   </para>

   <para>
<!--
    In <literal>RANGE</literal> or <literal>GROUPS</literal> mode,
    a <replaceable>frame_start</replaceable> of
    <literal>CURRENT ROW</literal> means the frame starts with the current
    row's first <firstterm>peer</firstterm> row (a row that the
    window's <literal>ORDER BY</literal> clause sorts as equivalent to the
    current row), while a <replaceable>frame_end</replaceable> of
    <literal>CURRENT ROW</literal> means the frame ends with the current
    row's last peer row.
    In <literal>ROWS</literal> mode, <literal>CURRENT ROW</literal> simply
    means the current row.
-->
<literal>RANGE</literal>あるいは<literal>GROUPS</literal>モードでは、<replaceable>frame_start</replaceable>が<literal>CURRENT ROW</literal>ならば、フレームが現在行の最初の<firstterm>ピア</firstterm>行（ウィンドウの<literal>ORDER BY</literal>句が現在行と同じ順序とみなす行）から始まることを意味し、一方、<replaceable>frame_end</replaceable>が<literal>CURRENT ROW</literal>ならばフレームが現在行の最後の同等な<literal>ORDER BY</literal>ピア行で終わることを意味します。
<literal>ROWS</literal>モードでは、<literal>CURRENT ROW</literal>は単に現在行を意味します。
   </para>

   <para>
<!--
    In the <replaceable>offset</replaceable> <literal>PRECEDING</literal>
    and <replaceable>offset</replaceable> <literal>FOLLOWING</literal> frame
    options, the <replaceable>offset</replaceable> must be an expression not
    containing any variables, aggregate functions, or window functions.
    The meaning of the <replaceable>offset</replaceable> depends on the
    frame mode:
-->
<replaceable>offset</replaceable> <literal>PRECEDING</literal>と<replaceable>offset</replaceable> <literal>FOLLOWING</literal>フレームオプションでは、<replaceable>offset</replaceable>は一切の変数、集約関数、あるいはウィンドウ関数を含まない式でなければなりません。
<replaceable>offset</replaceable>の意味はフレームモードに依存します。
    <itemizedlist>
     <listitem>
      <para>
<!--
       In <literal>ROWS</literal> mode,
       the <replaceable>offset</replaceable> must yield a non-null,
       non-negative integer, and the option means that the frame starts or
       ends the specified number of rows before or after the current row.
-->
<literal>ROWS</literal>モードでは、<replaceable>offset</replaceable>の評価値は非NULL、非負の整数でなければならず、このオプションは現在行の前あるいは後の指定した数の行でフレームが開始あるいは終了することを意味します。
      </para>
     </listitem>
     <listitem>
      <para>
<!--
       In <literal>GROUPS</literal> mode,
       the <replaceable>offset</replaceable> again must yield a non-null,
       non-negative integer, and the option means that the frame starts or
       ends the specified number of <firstterm>peer groups</firstterm>
       before or after the current row's peer group, where a peer group is a
       set of rows that are equivalent in the <literal>ORDER BY</literal>
       ordering.  (There must be an <literal>ORDER BY</literal> clause
       in the window definition to use <literal>GROUPS</literal> mode.)
-->
<literal>GROUPS</literal>モードでも、<replaceable>offset</replaceable>の評価値は非NULL、非負の整数でなければならず、このオプションは現在行のピアグループ(peer group)の前あるいは後の指定した数の<firstterm>ピアグループ</firstterm>でフレームが開始あるいは終了することを意味します。
ここでピアグループは、<literal>ORDER BY</literal>による順序付け中で等しい行の集合です。
（ウィンドウ定義で<literal>GROUPS</literal>モードを使うには、<literal>ORDER BY</literal>句が存在しなければなりません。）
      </para>
     </listitem>
     <listitem>
      <para>
<!--
       In <literal>RANGE</literal> mode, these options require that
       the <literal>ORDER BY</literal> clause specify exactly one column.
       The <replaceable>offset</replaceable> specifies the maximum
       difference between the value of that column in the current row and
       its value in preceding or following rows of the frame.  The data type
       of the <replaceable>offset</replaceable> expression varies depending
       on the data type of the ordering column.  For numeric ordering
       columns it is typically of the same type as the ordering column,
       but for datetime ordering columns it is an <type>interval</type>.
       For example, if the ordering column is of type <type>date</type>
       or <type>timestamp</type>, one could write <literal>RANGE BETWEEN
       '1 day' PRECEDING AND '10 days' FOLLOWING</literal>.
       The <replaceable>offset</replaceable> is still required to be
       non-null and non-negative, though the meaning
       of <quote>non-negative</quote> depends on its data type.
-->
<literal>RANGE</literal>モードでは、<literal>ORDER BY</literal>句が正確に一つの列を指定することがこれらのオプションによって要求されます。
<replaceable>offset</replaceable>は現在行の列の値と、フレーム中の前あるいは後ろの行の値の最大の差を指定します。
<replaceable>offset</replaceable>式のデータ型は、順序付けをしている列のデータ型に依存して変わります。
数値型の順序付け列では、典型的には順序付け列と同じですが、日付時間の順序付け列では、<type>interval</type>になります。
たとえば、順序付け列の型が<type>date</type>あるいは<type>timestamp</type>なら、<literal>RANGE BETWEEN '1 day' PRECEDING AND '10 days' FOLLOWING</literal>と書くことができるでしょう。
ここでも<replaceable>offset</replaceable>は非NULLかつ非負である必要があります。
ただし、<quote>非負</quote>の意味はデータ型に依存します。
      </para>
     </listitem>
    </itemizedlist>
<!--
    In any case, the distance to the end of the frame is limited by the
    distance to the end of the partition, so that for rows near the partition
    ends the frame might contain fewer rows than elsewhere.
-->
どの場合でも、フレームの最後までの距離はパーティションの最後までの距離に制限されます。
ですからパーティションの最後近くの行では他の場合に比べてフレームには少ない行が含まれるかも知れません。
   </para>

   <para>
<!--
    Notice that in both <literal>ROWS</literal> and <literal>GROUPS</literal>
    mode, <literal>0 PRECEDING</literal> and <literal>0 FOLLOWING</literal>
    are equivalent to <literal>CURRENT ROW</literal>.  This normally holds
    in <literal>RANGE</literal> mode as well, for an appropriate
    data-type-specific meaning of <quote>zero</quote>.
-->
<literal>ROWS</literal>と<literal>GROUPS</literal>モードでは、<literal>0 PRECEDING</literal>と<literal>0 FOLLOWING</literal>は<literal>CURRENT ROW</literal>と同じであることに注意してください。
データ型固有の意味で<quote>0</quote>が適切ならば、通常<literal>RANGE</literal>においても同様です。
   </para>

   <para>
<!--
    The <replaceable>frame_exclusion</replaceable> option allows rows around
    the current row to be excluded from the frame, even if they would be
    included according to the frame start and frame end options.
    <literal>EXCLUDE CURRENT ROW</literal> excludes the current row from the
    frame.
    <literal>EXCLUDE GROUP</literal> excludes the current row and its
    ordering peers from the frame.
    <literal>EXCLUDE TIES</literal> excludes any peers of the current
    row from the frame, but not the current row itself.
    <literal>EXCLUDE NO OTHERS</literal> simply specifies explicitly the
    default behavior of not excluding the current row or its peers.
-->
フレームの開始、終了オプションで含まれることになる行であっても、<replaceable>frame_exclusion</replaceable>オプションで現在行周辺の行がフレームに含まれないようにできます。
<literal>EXCLUDE CURRENT ROW</literal>は、現在の行をフレームから除外します。
<literal>EXCLUDE GROUP</literal>は、現在行とその順序付ピアをフレームから除外します。
<literal>EXCLUDE TIES</literal>は、現在行そのものを除き、フレームにおける現在行のピアをフレームから除外します。
<literal>EXCLUDE NO OTHERS</literal>は、現在の行あるいはそのピアを除外しないというデフォルトの挙動を明示的に指定するだけです。
   </para>

   <para>
<!--
    The default framing option is <literal>RANGE UNBOUNDED PRECEDING</literal>,
    which is the same as <literal>RANGE BETWEEN UNBOUNDED PRECEDING AND
    CURRENT ROW</literal>.  With <literal>ORDER BY</literal>, this sets the frame to be
    all rows from the partition start up through the current row's last
    <literal>ORDER BY</literal> peer.  Without <literal>ORDER BY</literal>,
    this means all rows of the partition are included in the window frame,
    since all rows become peers of the current row.
-->
デフォルトのフレーム化オプションは<literal>RANGE UNBOUNDED PRECEDING</literal>で、<literal>RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW</literal>と同じです。
<literal>ORDER BY</literal>があると、フレームはパーティションの開始から現在行の最後の<literal>ORDER BY</literal>ピア行までのすべての行になります。
<literal>ORDER BY</literal>が無い場合は、すべての行が現在行のピアとなるので、パーティションのすべての行がウィンドウフレームに含まれることを意味することになります。
   </para>

   <para>
<!--
    Restrictions are that
    <replaceable>frame_start</replaceable> cannot be <literal>UNBOUNDED FOLLOWING</literal>,
    <replaceable>frame_end</replaceable> cannot be <literal>UNBOUNDED PRECEDING</literal>,
    and the <replaceable>frame_end</replaceable> choice cannot appear earlier in the
    above list of <replaceable>frame_start</replaceable>
    and <replaceable>frame_end</replaceable> options than
    the <replaceable>frame_start</replaceable> choice does &mdash; for example
    <literal>RANGE BETWEEN CURRENT ROW AND <replaceable>offset</replaceable>
    PRECEDING</literal> is not allowed.
    But, for example, <literal>ROWS BETWEEN 7 PRECEDING AND 8
    PRECEDING</literal> is allowed, even though it would never select any
    rows.
-->
制限は、<replaceable>frame_start</replaceable>を<literal>UNBOUNDED FOLLOWING</literal>とすることができない点、<replaceable>frame_end</replaceable>を<literal>UNBOUNDED PRECEDING</literal>とすることができない点、および、上記の<replaceable>frame_start</replaceable>と<replaceable>frame_end</replaceable>のオプションのリストで、<replaceable>frame_end</replaceable>の選択が<replaceable>frame_start</replaceable>の選択よりも先に現れるものであってはならない点です。
例えば、<literal>RANGE BETWEEN CURRENT ROW AND <replaceable>offset</replaceable> PRECEDING</literal>は許されません。
しかし、例えば、決してどの行も選択しないとしても、<literal>ROWS BETWEEN 7 PRECEDING AND 8 PRECEDING</literal>は許されます。
   </para>

   <para>
<!--
    If <literal>FILTER</literal> is specified, then only the input
    rows for which the <replaceable>filter_clause</replaceable>
    evaluates to true are fed to the window function; other rows
    are discarded.  Only window functions that are aggregates accept
    a <literal>FILTER</literal> clause.
-->
<literal>FILTER</literal>が指定されていれば、<replaceable>filter_clause</replaceable>が真と評価した入力行のみがウィンドウ関数に渡されます。それ以外の行は破棄されます。
集約ウィンドウ関数だけが<literal>FILTER</literal>句を受け付けます。
   </para>

   <para>
<!--
    The built-in window functions are described in <xref
    linkend="functions-window-table"/>.  Other window functions can be added by
    the user.  Also, any built-in or user-defined general-purpose or
    statistical aggregate can be used as a window function.  (Ordered-set
    and hypothetical-set aggregates cannot presently be used as window functions.)
-->
組み込みウィンドウ関数は<xref linkend="functions-window-table"/>に記載されています。その他のウィンドウ関数をユーザが追加できます。
また、全ての組み込み、またはユーザ定義の、汎用または統計集約関数もウィンドウ関数として使用できます。
（順序集合と仮想集合集約は現在のところウィンドウ関数として使用できません。）
   </para>

   <para>
<!--
    The syntaxes using <literal>*</literal> are used for calling parameter-less
    aggregate functions as window functions, for example
    <literal>count(*) OVER (PARTITION BY x ORDER BY y)</literal>.
    The asterisk (<literal>*</literal>) is customarily not used for
    window-specific functions.  Window-specific functions do not
    allow <literal>DISTINCT</literal> or <literal>ORDER BY</literal> to be used within the
    function argument list.
-->
<literal>*</literal>を使用した構文は、例えば<literal>count(*) OVER (PARTITION BY x ORDER BY y)</literal>のように、パラメータのない集約関数をウィンドウ関数として呼び出すために使用されます。
アスタリスク(<literal>*</literal>)は習慣的にウィンドウ固有の関数には使われません。
ウィンドウ固有の関数は、関数引数リストの中で<literal>DISTINCT</literal>や<literal>ORDER BY</literal>が使われることを許可しません。
   </para>

   <para>
<!--
    Window function calls are permitted only in the <literal>SELECT</literal>
    list and the <literal>ORDER BY</literal> clause of the query.
-->
ウィンドウ関数呼び出しは問い合わせの<literal>SELECT</literal>リストと<literal>ORDER BY</literal>句の中でのみ許可されます。
   </para>

   <para>
<!--
    More information about window functions can be found in
    <xref linkend="tutorial-window"/>,
    <xref linkend="functions-window"/>, and
    <xref linkend="queries-window"/>.
-->
さらなるウィンドウ関数についての情報は<xref linkend="tutorial-window"/>、<xref linkend="functions-window"/>、<xref linkend="queries-window"/>にあります。
   </para>
  </sect2>

  <sect2 id="sql-syntax-type-casts">
<!--
   <title>Type Casts</title>
-->
   <title>型キャスト</title>

   <indexterm>
    <primary>data type</primary>
    <secondary>type cast</secondary>
   </indexterm>
   <indexterm>
    <primary>データ型</primary>
    <secondary>型キャスト</secondary>
   </indexterm>

   <indexterm>
    <primary>type cast</primary>
   </indexterm>
   <indexterm>
    <primary>型キャスト</primary>
   </indexterm>

   <indexterm>
    <primary>::</primary>
   </indexterm>

   <para>
<!--
    A type cast specifies a conversion from one data type to another.
    <productname>PostgreSQL</productname> accepts two equivalent syntaxes
    for type casts:
-->
型キャストは、あるデータ型から他のデータ型への変換を指定します。
<productname>PostgreSQL</productname>は型キャストに2つの等価な構文を受け付けます。
<synopsis>
CAST ( <replaceable>expression</replaceable> AS <replaceable>type</replaceable> )
<replaceable>expression</replaceable>::<replaceable>type</replaceable>
</synopsis>
<!--
    The <literal>CAST</literal> syntax conforms to SQL; the syntax with
    <literal>::</literal> is historical <productname>PostgreSQL</productname>
    usage.
-->
<literal>CAST</literal>構文はSQLに準拠したものです。
<literal>::</literal>を使用する構文は、<productname>PostgreSQL</productname>で伝統的に使用されている方法です。
   </para>

   <para>
<!--
    When a cast is applied to a value expression of a known type, it
    represents a run-time type conversion.  The cast will succeed only
    if a suitable type conversion operation has been defined.  Notice that this
    is subtly different from the use of casts with constants, as shown in
    <xref linkend="sql-syntax-constants-generic"/>.  A cast applied to an
    unadorned string literal represents the initial assignment of a type
    to a literal constant value, and so it will succeed for any type
    (if the contents of the string literal are acceptable input syntax for the
    data type).
-->
キャストが既知の型の評価式に適用された場合、それは実行時型変換を表します。
このキャストは、適切な型変換操作が定義されている場合のみ成功します。
<xref linkend="sql-syntax-constants-generic"/>で示すように、これと定数のキャストの使用との微妙な違いに注意してください。
修飾されていない文字列リテラルに対するキャストは、リテラル定数値の初期に割り当てられる型を表します。
ですから、これは（文字列リテラル定数の内容がそのデータ型の入力構文で受け付けられるのであれば）全ての型で成功します。
   </para>

   <para>
<!--
    An explicit type cast can usually be omitted if there is no ambiguity as
    to the type that a value expression must produce (for example, when it is
    assigned to a table column); the system will automatically apply a
    type cast in such cases.  However, automatic casting is only done for
    casts that are marked <quote>OK to apply implicitly</quote>
    in the system catalogs.  Other casts must be invoked with
    explicit casting syntax.  This restriction is intended to prevent
    surprising conversions from being applied silently.
-->
評価式が生成しなければならない型に曖昧さがない場合（例えばテーブル列への代入時など）、明示的な型キャストは通常は省略できます。
その場合、システムは自動的に型キャストを適用します。
しかし、自動キャストは、システムカタログに<quote>暗黙的に適用しても問題なし</quote>と示されている場合にのみ実行されます。
その他のキャストは明示的なキャスト構文で呼び出す必要があります。
この制限は、知らないうちに変換が実行されてしまうことを防ぐためのものです。
   </para>

   <para>
<!--
    It is also possible to specify a type cast using a function-like
    syntax:
-->
また、関数のような構文を使用して型キャストを指定することもできます。
<synopsis>
<replaceable>typename</replaceable> ( <replaceable>expression</replaceable> )
</synopsis>
<!--
    However, this only works for types whose names are also valid as
    function names.  For example, <literal>double precision</literal>
    cannot be used this way, but the equivalent <literal>float8</literal>
    can.  Also, the names <literal>interval</literal>, <literal>time</literal>, and
    <literal>timestamp</literal> can only be used in this fashion if they are
    double-quoted, because of syntactic conflicts.  Therefore, the use of
    the function-like cast syntax leads to inconsistencies and should
    probably be avoided.
-->
しかし、これはその型の名前が関数の名前としても有効な場合にのみ動作します。
例えば、<literal>double precision</literal> はこの方式で使用できませんが、同等の<literal>float8</literal>は使用できます。
また、<literal>interval</literal>、<literal>time</literal>、<literal>timestamp</literal>という名前は、構文が衝突するため、二重引用符で括った場合にのみこの方式で使用できます。
このように、この関数のようなキャスト構文は一貫性がなくなりがちですので、おそらくアプリケーションで使用すべきではありません。
   </para>

   <note>
    <para>
<!--
     The function-like syntax is in fact just a function call.  When
     one of the two standard cast syntaxes is used to do a run-time
     conversion, it will internally invoke a registered function to
     perform the conversion.  By convention, these conversion functions
     have the same name as their output type, and thus the <quote>function-like
     syntax</quote> is nothing more than a direct invocation of the underlying
     conversion function.  Obviously, this is not something that a portable
     application should rely on.  For further details see
     <xref linkend="sql-createcast"/>.
-->
この関数のような構文は、実際には単なる関数呼び出しです。
2つの標準的なキャスト構文のうちの1つが実行時変換で使用されると、この構文は登録済みの関数を内部的に呼び出して変換を実行します。
慣習的に、これらの変換関数は自身の出力型と同じ名前を持ち、これにより、<quote>関数のような構文</quote>は背後にある変換用関数を直接呼び出す以上のことを行いません。
移植性を持つアプリケーションが依存すべきものでないことは明確です。
詳細については<xref linkend="sql-createcast"/>を参照してください。
    </para>
   </note>
  </sect2>

  <sect2 id="sql-syntax-collate-exprs">
<!--
   <title>Collation Expressions</title>
-->
   <title>照合順序式</title>

   <indexterm>
    <primary>COLLATE</primary>
   </indexterm>

   <para>
<!--
    The <literal>COLLATE</literal> clause overrides the collation of
    an expression.  It is appended to the expression it applies to:
-->
<literal>COLLATE</literal>句は式の照合順序規則を上書きします。
適用するため次のように式の後に追記します。
<synopsis>
<replaceable>expr</replaceable> COLLATE <replaceable>collation</replaceable>
</synopsis>
<!--
    where <replaceable>collation</replaceable> is a possibly
    schema-qualified identifier.  The <literal>COLLATE</literal>
    clause binds tighter than operators; parentheses can be used when
    necessary.
-->
ここで<replaceable>collation</replaceable>は識別子で、スキーマ修飾可能です。
<literal>COLLATE</literal>句は演算子よりも結合優先度が高いです。
必要に応じて括弧で囲うことができます。
   </para>

   <para>
<!--
    If no collation is explicitly specified, the database system
    either derives a collation from the columns involved in the
    expression, or it defaults to the default collation of the
    database if no column is involved in the expression.
-->
もし照合順序が何も指定されなければ、データベースシステムは式にある列から照合順序を取得します。もし列に関する照合順序が式になければ、データベースのデフォルトの照合順序を使います。
   </para>

   <para>
<!--
    The two common uses of the <literal>COLLATE</literal> clause are
    overriding the sort order in an <literal>ORDER BY</literal> clause, for
    example:
-->
<literal>COLLATE</literal>句の主な使われ方が2つあります。
1つは<literal>ORDER BY</literal>句での並べ替え順序を上書きするもので、例えば次のようにします。
<programlisting>
SELECT a, b, c FROM tbl WHERE ... ORDER BY a COLLATE "C";
</programlisting>
<!--
    and overriding the collation of a function or operator call that
    has locale-sensitive results, for example:
-->
もう一つは、計算結果がロケールに依存する関数や演算子の呼び出しについて、照合順序を上書きするもので、例えば次のようにします。
<programlisting>
SELECT * FROM tbl WHERE a &gt; 'foo' COLLATE "C";
</programlisting>
<!--
    Note that in the latter case the <literal>COLLATE</literal> clause is
    attached to an input argument of the operator we wish to affect.
    It doesn't matter which argument of the operator or function call the
    <literal>COLLATE</literal> clause is attached to, because the collation that is
    applied by the operator or function is derived by considering all
    arguments, and an explicit <literal>COLLATE</literal> clause will override the
    collations of all other arguments.  (Attaching non-matching
    <literal>COLLATE</literal> clauses to more than one argument, however, is an
    error.  For more details see <xref linkend="collation"/>.)
    Thus, this gives the same result as the previous example:
-->
後者の場合、<literal>COLLATE</literal>句が、処理対象と想定している入力演算子の引数に対して付与されることに注意してください。
演算子や関数の呼び出しのどの引数に対して<literal>COLLATE</literal>句が付与されるかは問題ではありません。演算子や関数により適用される照合順序は対象となる全ての引数を考慮して引き出され、そして明示的に指定された<literal>COLLATE</literal>句がその他の全ての引数に対しての照合順序を上書きするからです。
（しかし、複数の引数に対して一致しない<literal>COLLATE</literal>句の付与はエラーとなります。詳細は<xref linkend="collation"/>を参照してください。）
このため、前述の例と同じ結果を次のようにして取得できます。
<programlisting>
SELECT * FROM tbl WHERE a COLLATE "C" &gt; 'foo';
</programlisting>
<!--
    But this is an error:
-->
ただし、次の例はエラーになります。
<programlisting>
SELECT * FROM tbl WHERE (a &gt; 'foo') COLLATE "C";
</programlisting>
<!--
    because it attempts to apply a collation to the result of the
    <literal>&gt;</literal> operator, which is of the non-collatable data type
    <type>boolean</type>.
-->
<literal>&gt;</literal>演算子の結果に対して照合順序を適用しようとしますが、<literal>&gt;</literal>演算子は照合不可能なデータ型である<type>boolean</type>となるからです。
   </para>
  </sect2>

  <sect2 id="sql-syntax-scalar-subqueries">
<!--
   <title>Scalar Subqueries</title>
-->
   <title>スカラ副問い合わせ</title>

   <indexterm>
    <primary>subquery</primary>
   </indexterm>
   <indexterm>
    <primary>副問い合わせ</primary>
   </indexterm>

   <para>
<!--
    A scalar subquery is an ordinary
    <command>SELECT</command> query in parentheses that returns exactly one
    row with one column.  (See <xref linkend="queries"/> for information about writing queries.)
    The <command>SELECT</command> query is executed
    and the single returned value is used in the surrounding value expression.
    It is an error to use a query that
    returns more than one row or more than one column as a scalar subquery.
    (But if, during a particular execution, the subquery returns no rows,
    there is no error; the scalar result is taken to be null.)
    The subquery can refer to variables from the surrounding query,
    which will act as constants during any one evaluation of the subquery.
    See also <xref linkend="functions-subquery"/> for other expressions involving subqueries.
-->
スカラ副問い合わせは、正確に1行1列を返す、括弧内の通常の<command>SELECT</command>問い合わせです。
（問い合わせの記述方法については<xref linkend="queries"/>を参照してください。）
その<command>SELECT</command>問い合わせは実行され、返される単一の値はその値の前後の評価式で使用されます。
1行を超える行や1列を超える列がスカラ副問い合わせ用の問い合わせとして使用された場合はエラーになります。
（しかし、ある実行時に、副問い合わせが行を返さない場合はエラーになりません。
そのスカラ結果はNULLとして扱われます。）
副問い合わせは、その周りの問い合わせ内の値を参照できます。
その値は副問い合わせの評価時には定数として扱われます。
副問い合わせに関する他の式については<xref linkend="functions-subquery"/>も参照してください。
   </para>

   <para>
<!--
    For example, the following finds the largest city population in each
    state:
-->
例えば、以下は各州の最大都市の人口を検索します。
<programlisting>
SELECT name, (SELECT max(pop) FROM cities WHERE cities.state = states.name)
    FROM states;
</programlisting>
   </para>
  </sect2>

  <sect2 id="sql-syntax-array-constructors">
<!--
   <title>Array Constructors</title>
-->
   <title>配列コンストラクタ</title>

   <indexterm>
    <primary>array</primary>
    <secondary>constructor</secondary>
   </indexterm>
   <indexterm>
    <primary>配列</primary>
    <secondary>コンストラクタ</secondary>
   </indexterm>

   <indexterm>
    <primary>ARRAY</primary>
   </indexterm>

   <para>
<!--
    An array constructor is an expression that builds an
    array value using values for its member elements.  A simple array
    constructor
    consists of the key word <literal>ARRAY</literal>, a left square bracket
    <literal>[</literal>, a list of expressions (separated by commas) for the
    array element values, and finally a right square bracket <literal>]</literal>.
    For example:
-->
配列コンストラクタは、メンバ要素に対する値を用いて配列値を構築する式です。
単純な配列コンストラクタの構成は、<literal>ARRAY</literal>キーワード、左大括弧<literal>[</literal>、（カンマで区切った）配列要素値用の式のリストで、最後に右大括弧<literal>]</literal>です。
以下に例を示します。
<programlisting>
SELECT ARRAY[1,2,3+4];
  array
---------
 {1,2,7}
(1 row)
</programlisting>
<!--
    By default,
    the array element type is the common type of the member expressions,
    determined using the same rules as for <literal>UNION</literal> or
    <literal>CASE</literal> constructs (see <xref linkend="typeconv-union-case"/>).
    You can override this by explicitly casting the array constructor to the
    desired type, for example:
-->
デフォルトで配列要素型は、メンバ式の型と同じで、<literal>UNION</literal>や<literal>CASE</literal>構文と同じ規則を使用して決定されます（<xref linkend="typeconv-union-case"/>を参照してください）。
これを明示的に配列コンストラクタを希望する型にキャストすることで書き換えることができます。例をあげます。
<programlisting>
SELECT ARRAY[1,2,22.7]::integer[];
  array
----------
 {1,2,23}
(1 row)
</programlisting>
<!--
    This has the same effect as casting each expression to the array
    element type individually.
    For more on casting, see <xref linkend="sql-syntax-type-casts"/>.
-->
これはそれぞれの式を配列要素の型に個別にキャストするのと同じ効果があります。
キャストについてより多くは<xref linkend="sql-syntax-type-casts"/>を参照してください。
   </para>

   <para>
<!--
    Multidimensional array values can be built by nesting array
    constructors.
    In the inner constructors, the key word <literal>ARRAY</literal> can
    be omitted.  For example, these produce the same result:
-->
多次元配列値は、配列コンストラクタを入れ子にすることで構築できます。
内側のコンストラクタでは<literal>ARRAY</literal>キーワードは省略可能です。
例えば、以下は同じ結果になります。

<programlisting>
SELECT ARRAY[ARRAY[1,2], ARRAY[3,4]];
     array
---------------
 {{1,2},{3,4}}
(1 row)

SELECT ARRAY[[1,2],[3,4]];
     array
---------------
 {{1,2},{3,4}}
(1 row)
</programlisting>

<!--
    Since multidimensional arrays must be rectangular, inner constructors
    at the same level must produce sub-arrays of identical dimensions.
    Any cast applied to the outer <literal>ARRAY</literal> constructor propagates
    automatically to all the inner constructors.
-->
多次元配列は長方形配列でなければなりませんので、同一レベルの内部コンストラクタは同一次元の副配列を生成しなければなりません。外部<literal>ARRAY</literal>コンストラクタに適用される全てのキャストは自動的に全ての内部コンストラクタに伝播します。
  </para>

  <para>
<!--
    Multidimensional array constructor elements can be anything yielding
    an array of the proper kind, not only a sub-<literal>ARRAY</literal> construct.
    For example:
-->
多次元配列コンストラクタの要素は、副<literal>ARRAY</literal>構文だけでなく、適切な種類の配列を生成するものをとることができます。
以下に例を示します。
<programlisting>
CREATE TABLE arr(f1 int[], f2 int[]);

INSERT INTO arr VALUES (ARRAY[[1,2],[3,4]], ARRAY[[5,6],[7,8]]);

SELECT ARRAY[f1, f2, '{{9,10},{11,12}}'::int[]] FROM arr;
                     array
------------------------------------------------
 {{{1,2},{3,4}},{{5,6},{7,8}},{{9,10},{11,12}}}
(1 row)
</programlisting>
  </para>

  <para>
<!--
   You can construct an empty array, but since it's impossible to have an
   array with no type, you must explicitly cast your empty array to the
   desired type.  For example:
-->
空配列を構築できますが、型を所有しない配列を持つことは不可能なので、空配列を望まれる型に明示的にキャストしなければなりません。例をあげます。
<programlisting>
SELECT ARRAY[]::integer[];
 array
-------
 {}
(1 row)
</programlisting>
  </para>

  <para>
<!--
   It is also possible to construct an array from the results of a
   subquery.  In this form, the array constructor is written with the
   key word <literal>ARRAY</literal> followed by a parenthesized (not
   bracketed) subquery. For example:
-->
また、副問い合わせの結果から配列を構成することも可能です。
この形式の場合、配列コンストラクタは<literal>ARRAY</literal>キーワードの後に括弧（大括弧ではない）で括られた副問い合わせとして記述されます。
以下に例を示します。
<programlisting>
SELECT ARRAY(SELECT oid FROM pg_proc WHERE proname LIKE 'bytea%');
                              array
------------------------------------------------------------------
 {2011,1954,1948,1952,1951,1244,1950,2005,1949,1953,2006,31,2412}
(1 row)

SELECT ARRAY(SELECT ARRAY[i, i*2] FROM generate_series(1,5) AS a(i));
              array
----------------------------------
 {{1,2},{2,4},{3,6},{4,8},{5,10}}
(1 row)
</programlisting>
<!--
   The subquery must return a single column.
   If the subquery's output column is of a non-array type, the resulting
   one-dimensional array will have an element for each row in the
   subquery result, with an element type matching that of the
   subquery's output column.
   If the subquery's output column is of an array type, the result will be
   an array of the same type but one higher dimension; in this case all
   the subquery rows must yield arrays of identical dimensionality, else
   the result would not be rectangular.
-->
副問い合わせは単一の列を返さなければなりません。
副問い合わせの出力列が非配列型であれば、その結果である一次元配列は、副問い合わせの出力列と一致する型を要素型とした、副問い合わせの結果内の各行を要素として持ちます。
副問い合わせの出力列が配列型であれば、その結果は、同じ型で1つ次元の高い配列になります。この場合、副問い合わせの列はすべて同じ次元の配列とならなければなりません。そうでないと結果が長方形になりません。
  </para>

  <para>
<!--
   The subscripts of an array value built with <literal>ARRAY</literal>
   always begin with one.  For more information about arrays, see
   <xref linkend="arrays"/>.
-->
<literal>ARRAY</literal>で構築された配列値の添字は、常に1から始まります。
配列についての詳細は<xref linkend="arrays"/>を参照してください。
  </para>

  </sect2>

  <sect2 id="sql-syntax-row-constructors">
<!--
   <title>Row Constructors</title>
-->
   <title>行コンストラクタ</title>

   <indexterm>
    <primary>composite type</primary>
    <secondary>constructor</secondary>
   </indexterm>
   <indexterm>
    <primary>複合型</primary>
    <secondary>のコンストラクタ</secondary>
   </indexterm>

   <indexterm>
    <primary>row type</primary>
    <secondary>constructor</secondary>
   </indexterm>
   <indexterm>
    <primary>行型</primary>
    <secondary>のコンストラクタ</secondary>
   </indexterm>

   <indexterm>
    <primary>ROW</primary>
   </indexterm>

   <para>
<!--
    A row constructor is an expression that builds a row value (also
    called a composite value) using values
    for its member fields.  A row constructor consists of the key word
    <literal>ROW</literal>, a left parenthesis, zero or more
    expressions (separated by commas) for the row field values, and finally
    a right parenthesis.  For example:
-->
行コンストラクタは、そのメンバフィールドに対する値を用いて行値（複合値とも呼ばれます）を構築する式です。
行コンストラクタは、<literal>ROW</literal>キーワード、左括弧、行のフィールド値用の0個以上の式（カンマ区切り）、最後に右括弧からなります。
以下に例を示します。
<programlisting>
SELECT ROW(1,2.5,'this is a test');
</programlisting>
<!--
    The key word <literal>ROW</literal> is optional when there is more than one
    expression in the list.
-->
<literal>ROW</literal>キーワードは、2つ以上の式がリスト内にある場合は省略できます。
   </para>

   <para>
<!--
    A row constructor can include the syntax
    <replaceable>rowvalue</replaceable><literal>.*</literal>,
    which will be expanded to a list of the elements of the row value,
    just as occurs when the <literal>.*</literal> syntax is used at the top level
    of a <command>SELECT</command> list (see <xref linkend="rowtypes-usage"/>).
    For example, if table <literal>t</literal> has
    columns <literal>f1</literal> and <literal>f2</literal>, these are the same:
-->
行コンストラクタには<replaceable>rowvalue</replaceable><literal>.*</literal>構文を含めることができます。
これは、<command>SELECT</command>リストの最上位レベルで<literal>.*</literal>構文が使用された時とまったく同様に、行値の要素の列挙に展開されます（<xref linkend="rowtypes-usage"/>参照）。
たとえば、テーブル<literal>t</literal>が<literal>f1</literal>列と<literal>f2</literal>列を持つ場合、以下は同一です。
<programlisting>
SELECT ROW(t.*, 42) FROM t;
SELECT ROW(t.f1, t.f2, 42) FROM t;
</programlisting>
   </para>

   <note>
    <para>
<!--
     Before <productname>PostgreSQL</productname> 8.2, the
     <literal>.*</literal> syntax was not expanded in row constructors, so
     that writing <literal>ROW(t.*, 42)</literal> created a two-field row whose first
     field was another row value.  The new behavior is usually more useful.
     If you need the old behavior of nested row values, write the inner
     row value without <literal>.*</literal>, for instance
     <literal>ROW(t, 42)</literal>.
-->
<productname>PostgreSQL</productname> 8.2より前では、<literal>.*</literal>構文は行コンストラクタ内では展開されませんでした。
<literal>ROW(t.*, 42)</literal>と記述すると、1つ目のフィールドにもう一つの行値を持つ、2つのフィールドからなる行が作成されました。
たいていの場合、新しい動作はより使いやすくなっています。
入れ子状の行値という古い動作が必要であれば、内側の行値には<literal>.*</literal>を使用せずに、たとえば<literal>ROW(t, 42)</literal>と記述してください。
    </para>
   </note>

   <para>
<!--
    By default, the value created by a <literal>ROW</literal> expression is of
    an anonymous record type.  If necessary, it can be cast to a named
    composite type &mdash; either the row type of a table, or a composite type
    created with <command>CREATE TYPE AS</command>.  An explicit cast might be needed
    to avoid ambiguity.  For example:
-->
デフォルトでは、<literal>ROW</literal>式により作成される値は匿名レコード型になります。
必要に応じて、名前付きの複合型、つまりテーブルの行型あるいは<command>CREATE TYPE AS</command>で作成された複合型にキャストできます。
曖昧性を防止するために明示的なキャストが必要となることもあります。
以下に例を示します。
<programlisting>
CREATE TABLE mytable(f1 int, f2 float, f3 text);

CREATE FUNCTION getf1(mytable) RETURNS int AS 'SELECT $1.f1' LANGUAGE SQL;

<!--
&#45;- No cast needed since only one getf1() exists
-->
-- getf1()が1つしか存在しないためキャスト不要。
SELECT getf1(ROW(1,2.5,'this is a test'));
 getf1
-------
     1
(1 row)

CREATE TYPE myrowtype AS (f1 int, f2 text, f3 numeric);

CREATE FUNCTION getf1(myrowtype) RETURNS int AS 'SELECT $1.f1' LANGUAGE SQL;

<!--
&#45;- Now we need a cast to indicate which function to call:
-->
-- ここでは、どの関数を呼び出すのかを示すためにキャストが必要。
SELECT getf1(ROW(1,2.5,'this is a test'));
ERROR:  function getf1(record) is not unique

SELECT getf1(ROW(1,2.5,'this is a test')::mytable);
 getf1
-------
     1
(1 row)

SELECT getf1(CAST(ROW(11,'this is a test',2.5) AS myrowtype));
 getf1
-------
    11
(1 row)
</programlisting>
  </para>

  <para>
<!--
   Row constructors can be used to build composite values to be stored
   in a composite-type table column, or to be passed to a function that
   accepts a composite parameter.  Also,
   it is possible to compare two row values or test a row with
   <literal>IS NULL</literal> or <literal>IS NOT NULL</literal>, for example:
-->
行コンストラクタは、複合型のテーブル列に格納する複合型の値を構築するため、あるいは複合型のパラメータを受け付ける関数に渡すために使用できます。
また、以下の例のように、2つの行値を比較することも、<literal>IS NULL</literal>もしくは<literal>IS NOT NULL</literal>で行を検査することも可能です。
<programlisting>
SELECT ROW(1,2.5,'this is a test') = ROW(1, 3, 'not the same');

<!--
SELECT ROW(table.*) IS NULL FROM table;  &#45;- detect all-null rows
-->
SELECT ROW(table.*) IS NULL FROM table;  -- すべてがNULLの行を検出します。
</programlisting>
<!--
   For more detail see <xref linkend="functions-comparisons"/>.
   Row constructors can also be used in connection with subqueries,
   as discussed in <xref linkend="functions-subquery"/>.
-->
詳細は<xref linkend="functions-comparisons"/>を参照してください。
行コンストラクタは、<xref linkend="functions-subquery"/>で説明するように、副問い合わせと一緒に使用することもできます。
  </para>

  </sect2>

  <sect2 id="syntax-express-eval">
<!--
   <title>Expression Evaluation Rules</title>
-->
   <title>式の評価規則</title>

   <indexterm>
    <primary>expression</primary>
    <secondary>order of evaluation</secondary>
   </indexterm>
   <indexterm>
    <primary>式</primary>
    <secondary>の評価順</secondary>
   </indexterm>

   <para>
<!--
    The order of evaluation of subexpressions is not defined.  In
    particular, the inputs of an operator or function are not necessarily
    evaluated left-to-right or in any other fixed order.
-->
副式の評価の順序は定義されていません。
特に演算子や関数の入力は、必ずしも左から右などの決まった順序で評価されるわけではありません。
   </para>

   <para>
<!--
    Furthermore, if the result of an expression can be determined by
    evaluating only some parts of it, then other subexpressions
    might not be evaluated at all.  For instance, if one wrote:
-->
さらに、その式の一部を評価しただけで式の結果を決定できる場合には、他の副式がまったく評価されないこともあります。
例えば、
<programlisting>
SELECT true OR somefunc();
</programlisting>
<!--
    then <literal>somefunc()</literal> would (probably) not be called
    at all. The same would be the case if one wrote:
-->
では、（おそらく）<literal>somefunc()</literal>は呼び出されないでしょう。
以下の場合も同様です。
<programlisting>
SELECT somefunc() OR true;
</programlisting>
<!--
    Note that this is not the same as the left-to-right
    <quote>short-circuiting</quote> of Boolean operators that is found
    in some programming languages.
-->
これは一部のプログラミング言語に見られる、論理演算子での左から右への<quote>短絡評価</quote>とは異なることに注意してください。
   </para>

   <para>
<!--
    As a consequence, it is unwise to use functions with side effects
    as part of complex expressions.  It is particularly dangerous to
    rely on side effects or evaluation order in <literal>WHERE</literal> and <literal>HAVING</literal> clauses,
    since those clauses are extensively reprocessed as part of
    developing an execution plan.  Boolean
    expressions (<literal>AND</literal>/<literal>OR</literal>/<literal>NOT</literal> combinations) in those clauses can be reorganized
    in any manner allowed by the laws of Boolean algebra.
-->
そのため、副次作用がある関数を複雑な式の一部として使用することは推奨されません。
特に、<literal>WHERE</literal>句および<literal>HAVING</literal>句で副次作用や評価順に依存するのは危険です。
これらの句は、実行計画を作成する過程で頻繁に再処理されるからです。
これらの句のブール式（<literal>AND</literal>/<literal>OR</literal>/<literal>NOT</literal>の組み合わせ）は、ブール代数の規則で許されるあらゆる方式で再編成される可能性があります。
   </para>

   <para>
<!--
    When it is essential to force evaluation order, a <literal>CASE</literal>
    construct (see <xref linkend="functions-conditional"/>) can be
    used.  For example, this is an untrustworthy way of trying to
    avoid division by zero in a <literal>WHERE</literal> clause:
-->
評価の順序を強制することが重要であれば、<literal>CASE</literal>構文（<xref linkend="functions-conditional"/>を参照）を使用できます。
例えば、次の式は<literal>WHERE</literal>句で0除算を避ける方法としては信頼性の低いものです。
<programlisting>
SELECT ... WHERE x &gt; 0 AND y/x &gt; 1.5;
</programlisting>
<!--
    But this is safe:
-->
しかし、次のようにすれば安全です。
<programlisting>
SELECT ... WHERE CASE WHEN x &gt; 0 THEN y/x &gt; 1.5 ELSE false END;
</programlisting>
<!--
    A <literal>CASE</literal> construct used in this fashion will defeat optimization
    attempts, so it should only be done when necessary.  (In this particular
    example, it would be better to sidestep the problem by writing
    <literal>y &gt; 1.5*x</literal> instead.)
-->
このような方法で使用される<literal>CASE</literal>構文は最適化を妨げるものなので、必要な場合にのみ使用してください。
（特に、この例では、<literal>y &gt; 1.5*x</literal>と代わりに記述することが問題を回避するより優れた方法です。）
   </para>

   <para>
<!--
    <literal>CASE</literal> is not a cure-all for such issues, however.
    One limitation of the technique illustrated above is that it does not
    prevent early evaluation of constant subexpressions.
    As described in <xref linkend="xfunc-volatility"/>, functions and
    operators marked <literal>IMMUTABLE</literal> can be evaluated when
    the query is planned rather than when it is executed.  Thus for example
-->
しかしながら、<literal>CASE</literal>はそのような問題に対する万能薬ではありません。
上で示したような方法の限界の1つは、定数副式が早く評価されるのを防げないことです。
<xref linkend="xfunc-volatility"/>に記すように、<literal>IMMUTABLE</literal>と印をつけられた関数と演算子は、実行される時ではなく問い合わせが計画される時に評価されるかもしれません。
そのため、例えば
<programlisting>
SELECT CASE WHEN x &gt; 0 THEN x ELSE 1/0 END FROM tab;
</programlisting>
<!--
    is likely to result in a division-by-zero failure due to the planner
    trying to simplify the constant subexpression,
    even if every row in the table has <literal>x &gt; 0</literal> so that the
    <literal>ELSE</literal> arm would never be entered at run time.
-->
は、たとえテーブルのすべての行が<literal>x &gt; 0</literal>であり、実行時には<literal>ELSE</literal>節に決して入らないとしても、プランナが定数副式を単純化しようとするためにゼロによる除算での失敗という結果に終わるでしょう。
   </para>

   <para>
<!--
    While that particular example might seem silly, related cases that don't
    obviously involve constants can occur in queries executed within
    functions, since the values of function arguments and local variables
    can be inserted into queries as constants for planning purposes.
    Within <application>PL/pgSQL</application> functions, for example, using an
    <literal>IF</literal>-<literal>THEN</literal>-<literal>ELSE</literal> statement to protect
    a risky computation is much safer than just nesting it in a
    <literal>CASE</literal> expression.
-->
この特別な例は馬鹿げたものに見えるかもしれませんが、定数を含むことが明らかではない関連する場合が関数の中で実行される問い合わせで起こり得ます。関数の引数とローカル変数は計画作成の都合で定数として問い合わせに入れられることがあるからです。
例えば、<application>PL/pgSQL</application>関数の中では、<literal>IF</literal>-<literal>THEN</literal>-<literal>ELSE</literal>文を使って危険な計算を保護する方が<literal>CASE</literal>式の中で入れ子にするよりもずっと安全です。
   </para>

   <para>
<!--
    Another limitation of the same kind is that a <literal>CASE</literal> cannot
    prevent evaluation of an aggregate expression contained within it,
    because aggregate expressions are computed before other
    expressions in a <literal>SELECT</literal> list or <literal>HAVING</literal> clause
    are considered.  For example, the following query can cause a
    division-by-zero error despite seemingly having protected against it:
-->
同種の別の限界は、その中に含まれる集約式の評価を<literal>CASE</literal>が防げないことです。なぜなら、<literal>SELECT</literal>リストや<literal>HAVING</literal>句の別の式が考慮される前に、集約式が計算されるからです。
例えば、以下の問い合わせは対策を施しているように見えるにも関わらずゼロ除算エラーになり得ます。
<programlisting>
SELECT CASE WHEN min(employees) > 0
            THEN avg(expenses / employees)
       END
    FROM departments;
</programlisting>
<!--
    The <function>min()</function> and <function>avg()</function> aggregates are computed
    concurrently over all the input rows, so if any row
    has <structfield>employees</structfield> equal to zero, the division-by-zero error
    will occur before there is any opportunity to test the result of
    <function>min()</function>.  Instead, use a <literal>WHERE</literal>
    or <literal>FILTER</literal> clause to prevent problematic input rows from
    reaching an aggregate function in the first place.
-->
<function>min()</function>と<function>avg()</function>集約は入力行すべてに対して同時に計算されますので、もし<structfield>employees</structfield>がゼロになる行があれば、<function>min()</function>の結果が検査される機会の前にゼロ除算エラーが起こります。
代わりに、まずは問題のある入力行が集約関数に渡されないようにするために<literal>WHERE</literal>または<literal>FILTER</literal>句を使ってください。
   </para>
  </sect2>
 </sect1>

 <sect1 id="sql-syntax-calling-funcs">
<!--
  <title>Calling Functions</title>
-->
  <title>関数呼び出し</title>

   <indexterm zone="sql-syntax-calling-funcs">
    <primary>notation</primary>
    <secondary>functions</secondary>
   </indexterm>
   <indexterm zone="sql-syntax-calling-funcs">
    <primary>表記</primary>
    <secondary>関数</secondary>
   </indexterm>

   <para>
<!--
    <productname>PostgreSQL</productname> allows functions that have named
    parameters to be called using either <firstterm>positional</firstterm> or
    <firstterm>named</firstterm> notation.  Named notation is especially
    useful for functions that have a large number of parameters, since it
    makes the associations between parameters and actual arguments more
    explicit and reliable.
    In positional notation, a function call is written with
    its argument values in the same order as they are defined in the function
    declaration.  In named notation, the arguments are matched to the
    function parameters by name and can be written in any order.
    For each notation, also consider the effect of function argument types,
    documented in <xref linkend="typeconv-func"/>.
-->
<productname>PostgreSQL</productname>では名前付きパラメータを持つ関数について、<firstterm>位置</firstterm>表記と<firstterm>名前付け</firstterm>表記のいずれでも呼び出すことが可能です。
名前付け表記は、パラメータと引数の関連をより明確・確実にするので、多数のパラメータを持つ関数において特に有用です。
位置表記の関数呼び出しでは、関数宣言で定義されたのと同じ並び順で、引数を記述します。
名前付け表記では、引数と関数パラメータは名前で対応付けられ、引数はどのような並び順で書いても構いません。
それぞれの表記で、<xref linkend="typeconv-func"/>に書かれているように、関数の引数の型の効果も考慮してください。
   </para>

   <para>
<!--
    In either notation, parameters that have default values given in the
    function declaration need not be written in the call at all.  But this
    is particularly useful in named notation, since any combination of
    parameters can be omitted; while in positional notation parameters can
    only be omitted from right to left.
-->
どちらの表記でも、関数定義時にデフォルト値を与えられているパラメータについては、呼び出し時に記述される必要はありません。
しかしこれは、名前付け表記で特に有用です。
なぜなら、パラメータ群の任意の組み合わせを省略できるからです。
一方、位置表記のパラメータは右から左へ省略していくことしかできません。
   </para>

   <para>
<!--
    <productname>PostgreSQL</productname> also supports
    <firstterm>mixed</firstterm> notation, which combines positional and
    named notation.  In this case, positional parameters are written first
    and named parameters appear after them.
-->
<productname>PostgreSQL</productname>では、名前付け表記と位置表記の<firstterm>混在</firstterm>表記もサポートしています。この場合、位置表記のパラメータが最初に記述され、その後に名前付け表記のパラメータが記述されることになります。
   </para>

   <para>
<!--
    The following examples will illustrate the usage of all three
    notations, using the following function definition:
-->
本節の例では、次の関数定義を使って、3通りすべての表記方法について説明します。
<programlisting>
CREATE FUNCTION concat_lower_or_upper(a text, b text, uppercase boolean DEFAULT false)
RETURNS text
AS
$$
 SELECT CASE
        WHEN $3 THEN UPPER($1 || ' ' || $2)
        ELSE LOWER($1 || ' ' || $2)
        END;
$$
LANGUAGE SQL IMMUTABLE STRICT;
</programlisting>
<!--
    Function <function>concat_lower_or_upper</function> has two mandatory
    parameters, <literal>a</literal> and <literal>b</literal>.  Additionally
    there is one optional parameter <literal>uppercase</literal> which defaults
    to <literal>false</literal>.  The <literal>a</literal> and
    <literal>b</literal> inputs will be concatenated, and forced to either
    upper or lower case depending on the <literal>uppercase</literal>
    parameter.  The remaining details of this function
    definition are not important here (see <xref linkend="extend"/> for
    more information).
-->
<function>concat_lower_or_upper</function>関数は、<literal>a</literal>と<literal>b</literal>の指定必須となる2つのパラメータを持ちます。
加えて、<literal>uppercase</literal>というデフォルトが<literal>false</literal>となっている省略可能なパラメータを一つ持ちます。
<literal>a</literal>と<literal>b</literal>で入力された文字列が結合され、<literal>uppercase</literal>パラメータにより大文字か小文字に変換されます。
他のこの関数定義についての詳細は、ここでは重要ではありません（詳細は<xref linkend="extend"/>を参照してください）。
   </para>

   <sect2 id="sql-syntax-calling-funcs-positional">
<!--
    <title>Using Positional Notation</title>
-->
    <title>位置表記の使用</title>

    <indexterm>
     <primary>function</primary>
     <secondary>positional notation</secondary>
    </indexterm>
    <indexterm>
     <primary>関数</primary>
     <secondary>位置表記</secondary>
    </indexterm>

    <para>
<!--
     Positional notation is the traditional mechanism for passing arguments
     to functions in <productname>PostgreSQL</productname>.  An example is:
-->
位置表記は、<productname>PostgreSQL</productname>の引数を関数に渡す伝統的な仕組みです。
例を挙げます。
<screen>
SELECT concat_lower_or_upper('Hello', 'World', true);
 concat_lower_or_upper
-----------------------
 HELLO WORLD
(1 row)
</screen>
<!--
     All arguments are specified in order.  The result is upper case since
     <literal>uppercase</literal> is specified as <literal>true</literal>.
     Another example is:
-->
すべての引数を順番通りに指定します。<literal>uppercase</literal>が<literal>true</literal>と指定されていますので、結果は大文字です。
別の例を示します。
<screen>
SELECT concat_lower_or_upper('Hello', 'World');
 concat_lower_or_upper
-----------------------
 hello world
(1 row)
</screen>
<!--
     Here, the <literal>uppercase</literal> parameter is omitted, so it
     receives its default value of <literal>false</literal>, resulting in
     lower case output.  In positional notation, arguments can be omitted
     from right to left so long as they have defaults.
-->
ここでは<literal>uppercase</literal>パラメータが省略されていますので、そのデフォルト値である<literal>false</literal>を受け取ることとなり、結果は小文字になります。
位置表記では引数がデフォルト値を持つ限り右側から左の方向で、引数を省略できます。
    </para>
   </sect2>

   <sect2 id="sql-syntax-calling-funcs-named">
<!--
    <title>Using Named Notation</title>
-->
    <title>名前付け表記の使用</title>

    <indexterm>
     <primary>function</primary>
     <secondary>named notation</secondary>
    </indexterm>
    <indexterm>
     <primary>関数</primary>
     <secondary>名前付け表記</secondary>
    </indexterm>

    <para>
<!--
     In named notation, each argument's name is specified using
     <literal>=&gt;</literal> to separate it from the argument expression.
     For example:
-->
名前付け表記では、各引数の名前は<literal>=&gt;</literal>を使用し引数の式と分けて指定されます。
例を挙げます。
<screen>
SELECT concat_lower_or_upper(a =&gt; 'Hello', b =&gt; 'World');
 concat_lower_or_upper
-----------------------
 hello world
(1 row)
</screen>
<!--
     Again, the argument <literal>uppercase</literal> was omitted
     so it is set to <literal>false</literal> implicitly.  One advantage of
     using named notation is that the arguments may be specified in any
     order, for example:
-->
この場合も、<literal>uppercase</literal>引数が省略されていますので、暗黙的に<literal>false</literal>に設定されます。
名前付け表記使用の利点の1つとして、引数を任意の順序で指定できる点があります。
以下に例を示します。
<screen>
SELECT concat_lower_or_upper(a =&gt; 'Hello', b =&gt; 'World', uppercase =&gt; true);
 concat_lower_or_upper
-----------------------
 HELLO WORLD
(1 row)

SELECT concat_lower_or_upper(a =&gt; 'Hello', uppercase =&gt; true, b =&gt; 'World');
 concat_lower_or_upper
-----------------------
 HELLO WORLD
(1 row)
</screen>
    </para>

    <para>
<!--
      An older syntax based on ":=" is supported for backward compatibility:
-->
":="に基づく古い文法は後方互換性のためにサポートされます。
<screen>
SELECT concat_lower_or_upper(a := 'Hello', uppercase := true, b := 'World');
 concat_lower_or_upper
-----------------------
 HELLO WORLD
(1 row)
</screen>
    </para>
   </sect2>

  <sect2 id="sql-syntax-calling-funcs-mixed">
<!--
   <title>Using Mixed Notation</title>
-->
   <title>混在表記の利用</title>

   <indexterm>
    <primary>function</primary>
    <secondary>mixed notation</secondary>
   </indexterm>
   <indexterm>
     <primary>関数</primary>
     <secondary>混在表記</secondary>
   </indexterm>

   <para>
<!--
    The mixed notation combines positional and named notation. However, as
    already mentioned, named arguments cannot precede positional arguments.
    For example:
-->
混在表記は名前付け表記と位置表記を組み合わせたものです。
しかし既に述べたように、名前付けされた引数は位置づけされたパラメータより前に記述することはできません。
例を挙げます。
<screen>
SELECT concat_lower_or_upper('Hello', 'World', uppercase =&gt; true);
 concat_lower_or_upper
-----------------------
 HELLO WORLD
(1 row)
</screen>
<!--
    In the above query, the arguments <literal>a</literal> and
    <literal>b</literal> are specified positionally, while
    <literal>uppercase</literal> is specified by name.  In this example,
    that adds little except documentation.  With a more complex function
    having numerous parameters that have default values, named or mixed
    notation can save a great deal of writing and reduce chances for error.
-->
上記の問い合わせでは、<literal>a</literal>と<literal>b</literal>が位置で指定され、<literal>uppercase</literal>は名前で指定されています。
この例では文書化の目的以外ほとんど意味がありません。
デフォルト値が割り当てられた多くのパラメータを持つ、もっと複雑な関数では、名前付けもしくは混在表記により記述量を大きく減らすことができ、かつ、エラーが紛れ込む可能性を抑えることができます。
   </para>

   <note>
    <para>
<!--
     Named and mixed call notations currently cannot be used when calling an
     aggregate function (but they do work when an aggregate function is used
     as a window function).
-->
名前付けと混在呼び出し表記は集約関数の呼び出しでは現在使用できません（が、集約関数がウィンドウ関数として使われる場合には動作します）。
    </para>
   </note>
  </sect2>
 </sect1>

</chapter>
