<!--
doc/src/sgml/ref/alter_table.sgml
PostgreSQL documentation
-->

<refentry id="sql-altertable">
 <indexterm zone="sql-altertable">
  <primary>ALTER TABLE</primary>
 </indexterm>

 <refmeta>
  <refentrytitle>ALTER TABLE</refentrytitle>
  <manvolnum>7</manvolnum>
<!--
  <refmiscinfo>SQL - Language Statements</refmiscinfo>
-->
  <refmiscinfo>SQL - 言語</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>ALTER TABLE</refname>
<!--
  <refpurpose>change the definition of a table</refpurpose>
-->
  <refpurpose>テーブル定義を変更する</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>
ALTER TABLE [ IF EXISTS ] [ ONLY ] <replaceable class="parameter">name</replaceable> [ * ]
    <replaceable class="parameter">action</replaceable> [, ... ]
ALTER TABLE [ IF EXISTS ] [ ONLY ] <replaceable class="parameter">name</replaceable> [ * ]
    RENAME [ COLUMN ] <replaceable class="parameter">column_name</replaceable> TO <replaceable class="parameter">new_column_name</replaceable>
ALTER TABLE [ IF EXISTS ] [ ONLY ] <replaceable class="parameter">name</replaceable> [ * ]
    RENAME CONSTRAINT <replaceable class="parameter">constraint_name</replaceable> TO <replaceable class="parameter">new_constraint_name</replaceable>
ALTER TABLE [ IF EXISTS ] <replaceable class="parameter">name</replaceable>
    RENAME TO <replaceable class="parameter">new_name</replaceable>
ALTER TABLE [ IF EXISTS ] <replaceable class="parameter">name</replaceable>
    SET SCHEMA <replaceable class="parameter">new_schema</replaceable>
ALTER TABLE ALL IN TABLESPACE <replaceable class="parameter">name</replaceable> [ OWNED BY <replaceable class="parameter">role_name</replaceable> [, ... ] ]
    SET TABLESPACE <replaceable class="parameter">new_tablespace</replaceable> [ NOWAIT ]
ALTER TABLE [ IF EXISTS ] <replaceable class="parameter">name</replaceable>
    ATTACH PARTITION <replaceable class="parameter">partition_name</replaceable> { FOR VALUES <replaceable class="parameter">partition_bound_spec</replaceable> | DEFAULT }
ALTER TABLE [ IF EXISTS ] <replaceable class="parameter">name</replaceable>
    DETACH PARTITION <replaceable class="parameter">partition_name</replaceable> [ CONCURRENTLY | FINALIZE ]

<!--
<phrase>where <replaceable class="parameter">action</replaceable> is one of:</phrase>
-->
<phrase>ここで<replaceable class="parameter">action</replaceable>は以下のいずれかです。</phrase>

    ADD [ COLUMN ] [ IF NOT EXISTS ] <replaceable class="parameter">column_name</replaceable> <replaceable class="parameter">data_type</replaceable> [ COLLATE <replaceable class="parameter">collation</replaceable> ] [ <replaceable class="parameter">column_constraint</replaceable> [ ... ] ]
    DROP [ COLUMN ] [ IF EXISTS ] <replaceable class="parameter">column_name</replaceable> [ RESTRICT | CASCADE ]
    ALTER [ COLUMN ] <replaceable class="parameter">column_name</replaceable> [ SET DATA ] TYPE <replaceable class="parameter">data_type</replaceable> [ COLLATE <replaceable class="parameter">collation</replaceable> ] [ USING <replaceable class="parameter">expression</replaceable> ]
    ALTER [ COLUMN ] <replaceable class="parameter">column_name</replaceable> SET DEFAULT <replaceable class="parameter">expression</replaceable>
    ALTER [ COLUMN ] <replaceable class="parameter">column_name</replaceable> DROP DEFAULT
    ALTER [ COLUMN ] <replaceable class="parameter">column_name</replaceable> { SET | DROP } NOT NULL
    ALTER [ COLUMN ] <replaceable class="parameter">column_name</replaceable> SET EXPRESSION AS ( <replaceable class="parameter">expression</replaceable> )
    ALTER [ COLUMN ] <replaceable class="parameter">column_name</replaceable> DROP EXPRESSION [ IF EXISTS ]
    ALTER [ COLUMN ] <replaceable class="parameter">column_name</replaceable> ADD GENERATED { ALWAYS | BY DEFAULT } AS IDENTITY [ ( <replaceable>sequence_options</replaceable> ) ]
    ALTER [ COLUMN ] <replaceable class="parameter">column_name</replaceable> { SET GENERATED { ALWAYS | BY DEFAULT } | SET <replaceable>sequence_option</replaceable> | RESTART [ [ WITH ] <replaceable class="parameter">restart</replaceable> ] } [...]
    ALTER [ COLUMN ] <replaceable class="parameter">column_name</replaceable> DROP IDENTITY [ IF EXISTS ]
    ALTER [ COLUMN ] <replaceable class="parameter">column_name</replaceable> SET STATISTICS { <replaceable class="parameter">integer</replaceable> | DEFAULT }
    ALTER [ COLUMN ] <replaceable class="parameter">column_name</replaceable> SET ( <replaceable class="parameter">attribute_option</replaceable> = <replaceable class="parameter">value</replaceable> [, ... ] )
    ALTER [ COLUMN ] <replaceable class="parameter">column_name</replaceable> RESET ( <replaceable class="parameter">attribute_option</replaceable> [, ... ] )
    ALTER [ COLUMN ] <replaceable class="parameter">column_name</replaceable> SET STORAGE { PLAIN | EXTERNAL | EXTENDED | MAIN | DEFAULT }
    ALTER [ COLUMN ] <replaceable class="parameter">column_name</replaceable> SET COMPRESSION <replaceable class="parameter">compression_method</replaceable>
    ADD <replaceable class="parameter">table_constraint</replaceable> [ NOT VALID ]
    ADD <replaceable class="parameter">table_constraint_using_index</replaceable>
    ALTER CONSTRAINT <replaceable class="parameter">constraint_name</replaceable> [ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ] [ ENFORCED | NOT ENFORCED ]
    ALTER CONSTRAINT <replaceable class="parameter">constraint_name</replaceable> [ INHERIT | NO INHERIT ]
    VALIDATE CONSTRAINT <replaceable class="parameter">constraint_name</replaceable>
    DROP CONSTRAINT [ IF EXISTS ]  <replaceable class="parameter">constraint_name</replaceable> [ RESTRICT | CASCADE ]
    DISABLE TRIGGER [ <replaceable class="parameter">trigger_name</replaceable> | ALL | USER ]
    ENABLE TRIGGER [ <replaceable class="parameter">trigger_name</replaceable> | ALL | USER ]
    ENABLE REPLICA TRIGGER <replaceable class="parameter">trigger_name</replaceable>
    ENABLE ALWAYS TRIGGER <replaceable class="parameter">trigger_name</replaceable>
    DISABLE RULE <replaceable class="parameter">rewrite_rule_name</replaceable>
    ENABLE RULE <replaceable class="parameter">rewrite_rule_name</replaceable>
    ENABLE REPLICA RULE <replaceable class="parameter">rewrite_rule_name</replaceable>
    ENABLE ALWAYS RULE <replaceable class="parameter">rewrite_rule_name</replaceable>
    DISABLE ROW LEVEL SECURITY
    ENABLE ROW LEVEL SECURITY
    FORCE ROW LEVEL SECURITY
    NO FORCE ROW LEVEL SECURITY
    CLUSTER ON <replaceable class="parameter">index_name</replaceable>
    SET WITHOUT CLUSTER
    SET WITHOUT OIDS
    SET ACCESS METHOD { <replaceable class="parameter">new_access_method</replaceable> | DEFAULT }
    SET TABLESPACE <replaceable class="parameter">new_tablespace</replaceable>
    SET { LOGGED | UNLOGGED }
    SET ( <replaceable class="parameter">storage_parameter</replaceable> [= <replaceable class="parameter">value</replaceable>] [, ... ] )
    RESET ( <replaceable class="parameter">storage_parameter</replaceable> [, ... ] )
    INHERIT <replaceable class="parameter">parent_table</replaceable>
    NO INHERIT <replaceable class="parameter">parent_table</replaceable>
    OF <replaceable class="parameter">type_name</replaceable>
    NOT OF
    OWNER TO { <replaceable class="parameter">new_owner</replaceable> | CURRENT_ROLE | CURRENT_USER | SESSION_USER }
    REPLICA IDENTITY { DEFAULT | USING INDEX <replaceable class="parameter">index_name</replaceable> | FULL | NOTHING }

<!--
<phrase>and <replaceable class="parameter">partition_bound_spec</replaceable> is:</phrase>
-->
<phrase>また、<replaceable class="parameter">partition_bound_spec</replaceable>は以下の通りです。</phrase>

IN ( <replaceable class="parameter">partition_bound_expr</replaceable> [, ...] ) |
FROM ( { <replaceable class="parameter">partition_bound_expr</replaceable> | MINVALUE | MAXVALUE } [, ...] )
  TO ( { <replaceable class="parameter">partition_bound_expr</replaceable> | MINVALUE | MAXVALUE } [, ...] ) |
WITH ( MODULUS <replaceable class="parameter">numeric_literal</replaceable>, REMAINDER <replaceable class="parameter">numeric_literal</replaceable> )

<!--
<phrase>and <replaceable class="parameter">column_constraint</replaceable> is:</phrase>
-->
<phrase>また、<replaceable class="parameter">column_constraint</replaceable>は以下の通りです。</phrase>

[ CONSTRAINT <replaceable class="parameter">constraint_name</replaceable> ]
{ NOT NULL [ NO INHERIT ] |
  NULL |
  CHECK ( <replaceable class="parameter">expression</replaceable> ) [ NO INHERIT ] |
  DEFAULT <replaceable>default_expr</replaceable> |
  GENERATED ALWAYS AS ( <replaceable>generation_expr</replaceable> ) [ STORED | VIRTUAL ] |
  GENERATED { ALWAYS | BY DEFAULT } AS IDENTITY [ ( <replaceable>sequence_options</replaceable> ) ] |
  UNIQUE [ NULLS [ NOT ] DISTINCT ] <replaceable class="parameter">index_parameters</replaceable> |
  PRIMARY KEY <replaceable class="parameter">index_parameters</replaceable> |
  REFERENCES <replaceable class="parameter">reftable</replaceable> [ ( <replaceable class="parameter">refcolumn</replaceable> ) ] [ MATCH FULL | MATCH PARTIAL | MATCH SIMPLE ]
    [ ON DELETE <replaceable class="parameter">referential_action</replaceable> ] [ ON UPDATE <replaceable class="parameter">referential_action</replaceable> ] }
[ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ] [ ENFORCED | NOT ENFORCED ]

<!--
<phrase>and <replaceable class="parameter">table_constraint</replaceable> is:</phrase>
-->
<phrase>また、<replaceable class="parameter">table_constraint</replaceable>は以下の通りです。</phrase>

[ CONSTRAINT <replaceable class="parameter">constraint_name</replaceable> ]
{ CHECK ( <replaceable class="parameter">expression</replaceable> ) [ NO INHERIT ] |
  NOT NULL <replaceable class="parameter">column_name</replaceable> [ NO INHERIT ] |
  UNIQUE [ NULLS [ NOT ] DISTINCT ] ( <replaceable class="parameter">column_name</replaceable> [, ... ] [, <replaceable class="parameter">column_name</replaceable> WITHOUT OVERLAPS ] ) <replaceable class="parameter">index_parameters</replaceable> |
  PRIMARY KEY ( <replaceable class="parameter">column_name</replaceable> [, ... ] [, <replaceable class="parameter">column_name</replaceable> WITHOUT OVERLAPS ] ) <replaceable class="parameter">index_parameters</replaceable> |
  EXCLUDE [ USING <replaceable class="parameter">index_method</replaceable> ] ( <replaceable class="parameter">exclude_element</replaceable> WITH <replaceable class="parameter">operator</replaceable> [, ... ] ) <replaceable class="parameter">index_parameters</replaceable> [ WHERE ( <replaceable class="parameter">predicate</replaceable> ) ] |
  FOREIGN KEY ( <replaceable class="parameter">column_name</replaceable> [, ... ] [, PERIOD <replaceable class="parameter">column_name</replaceable> ] ) REFERENCES <replaceable class="parameter">reftable</replaceable> [ ( <replaceable class="parameter">refcolumn</replaceable> [, ... ]  [, PERIOD <replaceable class="parameter">refcolumn</replaceable> ] ) ]
    [ MATCH FULL | MATCH PARTIAL | MATCH SIMPLE ] [ ON DELETE <replaceable class="parameter">referential_action</replaceable> ] [ ON UPDATE <replaceable class="parameter">referential_action</replaceable> ] }
[ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ] [ ENFORCED | NOT ENFORCED ]

<!--
<phrase>and <replaceable class="parameter">table_constraint_using_index</replaceable> is:</phrase>
-->
<phrase>また<replaceable class="parameter">table_constraint_using_index</replaceable>は以下の通りです。</phrase>

    [ CONSTRAINT <replaceable class="parameter">constraint_name</replaceable> ]
    { UNIQUE | PRIMARY KEY } USING INDEX <replaceable class="parameter">index_name</replaceable>
    [ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]

<!--
<phrase><replaceable class="parameter">index_parameters</replaceable> in <literal>UNIQUE</literal>, <literal>PRIMARY KEY</literal>, and <literal>EXCLUDE</literal> constraints are:</phrase>
-->
<phrase><literal>UNIQUE</literal>、<literal>PRIMARY KEY</literal>、および、<literal>EXCLUDE</literal>制約での<replaceable class="parameter">index_parameters</replaceable>は以下の通りです。</phrase>

[ INCLUDE ( <replaceable class="parameter">column_name</replaceable> [, ... ] ) ]
[ WITH ( <replaceable class="parameter">storage_parameter</replaceable> [= <replaceable class="parameter">value</replaceable>] [, ... ] ) ]
[ USING INDEX TABLESPACE <replaceable class="parameter">tablespace_name</replaceable> ]

<!--
<phrase><replaceable class="parameter">exclude_element</replaceable> in an <literal>EXCLUDE</literal> constraint is:</phrase>
-->
<phrase><literal>EXCLUDE</literal>制約での<replaceable class="parameter">exclude_element</replaceable>は以下の通りです。</phrase>

{ <replaceable class="parameter">column_name</replaceable> | ( <replaceable class="parameter">expression</replaceable> ) } [ COLLATE <replaceable class="parameter">collation</replaceable> ] [ <replaceable class="parameter">opclass</replaceable> [ ( <replaceable class="parameter">opclass_parameter</replaceable> = <replaceable class="parameter">value</replaceable> [, ... ] ) ] ] [ ASC | DESC ] [ NULLS { FIRST | LAST } ]

<phrase><replaceable class="parameter">referential_action</replaceable> in a <literal>FOREIGN KEY</literal>/<literal>REFERENCES</literal> constraint is:</phrase>

{ NO ACTION | RESTRICT | CASCADE | SET NULL [ ( <replaceable class="parameter">column_name</replaceable> [, ... ] ) ] | SET DEFAULT [ ( <replaceable class="parameter">column_name</replaceable> [, ... ] ) ] }
</synopsis>
 </refsynopsisdiv>

 <refsect1>
<!--
  <title>Description</title>
-->
  <title>説明</title>

  <para>
<!--
   <command>ALTER TABLE</command> changes the definition of an existing table.
   There are several subforms described below. Note that the lock level required
   may differ for each subform. An <literal>ACCESS EXCLUSIVE</literal> lock is
   acquired unless explicitly noted. When multiple subcommands are given, the
   lock acquired will be the strictest one required by any subcommand.
-->
<command>ALTER TABLE</command>は既存のテーブルの定義を変更します。
以下のようにいくつかの副構文があります。
要求されるロックレベルはそれぞれの副構文によって異なることに注意してください。
特に記述がなければ<literal>ACCESS EXCLUSIVE</literal>ロックを取得します。
複数のサブコマンドが使われるときは、それらのサブコマンドが要求するうち、もっとも高いレベルのロックを取得します。

  <variablelist>
   <varlistentry id="sql-altertable-desc-add-column">
    <term><literal>ADD COLUMN [ IF NOT EXISTS ]</literal></term>
    <listitem>
     <para>
<!--
      This form adds a new column to the table, using the same syntax as
      <link linkend="sql-createtable"><command>CREATE TABLE</command></link>. If <literal>IF NOT EXISTS</literal>
      is specified and a column already exists with this name,
      no error is thrown.
-->
この構文を使用すると、<link linkend="sql-createtable"><command>CREATE TABLE</command></link>と同じ構文を使って新しい列をテーブルに追加できます。
<literal>IF NOT EXISTS</literal>が指定され、その名前の列が既に存在している場合は、エラーが発生しません。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="sql-altertable-desc-drop-column">
    <term><literal>DROP COLUMN [ IF EXISTS ]</literal></term>
    <listitem>
     <para>
<!--
      This form drops a column from a table.  Indexes and
      table constraints involving the column will be automatically
      dropped as well.
      Multivariate statistics referencing the dropped column will also be
      removed if the removal of the column would cause the statistics to
      contain data for only a single column.
      You will need to say <literal>CASCADE</literal> if anything outside the table
      depends on the column, for example, foreign key references or views.
      If <literal>IF EXISTS</literal> is specified and the column
      does not exist, no error is thrown. In this case a notice
      is issued instead.
-->
この構文を使用すると、テーブルから列を削除できます。
削除する列を含んでいるインデックスおよびテーブル制約も自動的に削除されます。
削除する列を参照する多変量統計がある場合、列の削除の結果、その統計が1つの列のデータしか含まないようになるなら、それも削除されます。
また、削除する列にテーブル以外が依存（例えば、外部キー制約、ビューなど）している場合、<literal>CASCADE</literal>を付ける必要があります。
<literal>IF EXISTS</literal>が指定されている場合、もしその列がなかったとしてもエラーにはなりません。
この場合は代わりに注意が出力されます。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="sql-altertable-desc-set-data-type">
    <term><literal>SET DATA TYPE</literal></term>
    <listitem>
     <para>
<!--
      This form changes the type of a column of a table. Indexes and
      simple table constraints involving the column will be automatically
      converted to use the new column type by reparsing the originally
      supplied expression.
      The optional <literal>COLLATE</literal> clause specifies a collation
      for the new column; if omitted, the collation is the default for the
      new column type.
      The optional <literal>USING</literal>
      clause specifies how to compute the new column value from the old;
      if omitted, the default conversion is the same as an assignment
      cast from old data type to new.  A  <literal>USING</literal>
      clause must be provided if there is no implicit or assignment
      cast from old to new type.
-->
この構文を使用すると、テーブルの列の型を変更できます。
その列を含むインデックスと簡単なテーブル制約は、元々与えられた式を再解析し、新しい型を使用するように自動的に変換されます。
<literal>COLLATE</literal>句を使うと、新しい列の照合順を指定できます。
省略時の照合順は新しい列の型のデフォルトになります。
<literal>USING</literal>句を使うと、古い列値をどのように新しい値に計算するかを指定できます。
省略された場合、デフォルトの変換は、古いデータ型から新しいデータ型への代入キャストと同じになります。
古いデータ型から新しいデータ型への暗黙キャストあるいは代入キャストがない場合、<literal>USING</literal>句を指定しなければなりません。
     </para>

     <para>
<!--
      When this form is used, the column's statistics are removed,
      so running <link linkend="sql-analyze"><command>ANALYZE</command></link>
      on the table afterwards is recommended.
      For a virtual generated column, <command>ANALYZE</command>
      is not necessary because such columns never have statistics.
-->
《マッチ度[52.901024]》この形式を使用すると、列の統計情報が削除されるので、後でテーブルに対して<link linkend="sql-analyze"><command>ANALYZE</command></link>を実行することをお勧めします。
《機械翻訳》このフォームが使用される場合、カラムの統計処理は削除されるため、後でテーブルに対して<link linkend="sql-analyze"><command>ANALYZE</command></link>を実行することをお薦めします。
仮想的に生成されたカラムでは、<command>ANALYZE</command>は必要ありません。
なぜなら、このような列は統計処理を持たないからです。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="sql-altertable-desc-set-drop-default">
    <term><literal>SET</literal>/<literal>DROP DEFAULT</literal></term>
    <listitem>
     <para>
<!--
      These forms set or remove the default value for a column (where
      removal is equivalent to setting the default value to NULL).  The new
      default value will only apply in subsequent <command>INSERT</command>
      or <command>UPDATE</command> commands; it does not cause rows already
      in the table to change.
-->
これらの構文を使用すると、列のデフォルト値を設定または削除できます（ここで、削除はデフォルト値をNULLに設定することと等価です）。
新しいデフォルト値は、変更後に行われる<command>INSERT</command>または<command>UPDATE</command>コマンドにのみ適用されます。
テーブル内の既存の行は変更されません。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="sql-altertable-desc-set-drop-not-null">
    <term><literal>SET</literal>/<literal>DROP NOT NULL</literal></term>
    <listitem>
     <para>
<!--
      These forms change whether a column is marked to allow null
      values or to reject null values.
-->
これらの構文は、列の値としてNULL値を認めるか拒絶するかを変更します。
     </para>

     <para>
<!--
      <literal>SET NOT NULL</literal> may only be applied to a column
      provided none of the records in the table contain a
      <literal>NULL</literal> value for the column.  Ordinarily this is
      checked during the <literal>ALTER TABLE</literal> by scanning the
      entire table, unless <literal>NOT VALID</literal> is specified;
      however, if a valid <literal>CHECK</literal> constraint exists
      (and is not dropped in the same command) which proves no
      <literal>NULL</literal> can exist, then the table scan is skipped.
      If a column has an invalid not-null constraint,
      <literal>SET NOT NULL</literal> validates it.
-->
《マッチ度[68.866328]》<literal>SET NOT NULL</literal>は、テーブルの項目でその列が<literal>NULL</literal>値であるものが1つもない場合にのみ、その列に設定可能です。
通常これは<literal>ALTER TABLE</literal>がテーブル全体をスキャンする際に確認されます。
しかしながら、<literal>NULL</literal>が存在できないことを示す有効な<literal>CHECK</literal>制約（同じコマンドで削除されない）が存在すれば、テーブルスキャンは省略されます。
《機械翻訳》<literal>SET NOT NULL</literal>は、カラムのレコードに<literal>NULL</literal>テーブルの値が含まれていない場合にのみ、そのカラムに適用できます。
通常、これは<literal>ALTER TABLE</literal>が指定されていない限り、テーブル全体をスキャンすることによって中にチェックされます。
ただし、有効な<literal>CHECK</literal>制約が存在し、同じコマンドで削除されていない場合は、<literal>NULL</literal>存在できないことが証明されるため、そのテーブルスキャンはスキップされたになります。
カラムに無効な非NULL制約がある場合は、<literal>SET NOT NULL</literal>それを検証します。
<literal>NOT VALID</literal>
     </para>

     <para>
<!--
      If this table is a partition, one cannot perform <literal>DROP NOT NULL</literal>
      on a column if it is marked <literal>NOT NULL</literal> in the parent
      table.  To drop the <literal>NOT NULL</literal> constraint from all the
      partitions, perform <literal>DROP NOT NULL</literal> on the parent
      table.  Even if there is no <literal>NOT NULL</literal> constraint on the
      parent, such a constraint can still be added to individual partitions,
      if desired; that is, the children can disallow nulls even if the parent
      allows them, but not the other way around.  It is also possible to drop
      the <literal>NOT NULL</literal> constraint from <literal>ONLY</literal>
      the parent table, which does not remove it from the children.
-->
《マッチ度[70.140845]》このテーブルがパーティションの場合、親テーブルで<literal>NOT NULL</literal>の印がつけられている列について<literal>DROP NOT NULL</literal>を実行することはできません。
すべてのパーティションから<literal>NOT NULL</literal>制約を削除するには、親テーブルで<literal>DROP NOT NULL</literal>を実行してください。
親テーブルに<literal>NOT NULL</literal>制約がない場合でも、望むなら各パーティションにそのような制約を追加することができます。
つまり、親テーブルがNULLを許していても子テーブルでNULLを禁止することができますが、その逆はできません。
《機械翻訳》このテーブルがパーティションである場合、<literal>NOT NULL</literal>マークされているカラムで親テーブルでを実行することはできません。
<literal>NOT NULL</literal>制約をすべてのパーティションから削除するには、<literal>DROP NOT NULL</literal>親テーブルでを実行します。
<literal>NOT NULL</literal>制約が親にない場合でも、そのような制約は必要に応じて個々のパーティションに追加できます。
つまり、親がNULLを許可している場合でも、子はNULLを許可しないことができますが、その逆はできません。
<literal>ONLY</literal>親テーブルから<literal>NOT NULL</literal>制約を削除しないを削除することもできます。
<literal>DROP NOT NULL</literal>
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="sql-altertable-desc-set-expression">
    <term><literal>SET EXPRESSION AS</literal></term>
    <listitem>
     <para>
<!--
      This form replaces the expression of a generated column.  Existing data
      in a stored generated column is rewritten and all the future changes
      will apply the new generation expression.
-->
《マッチ度[83.425414]》この構文は、生成列の式を置き換えます。
列の既存のデータは書き換えられ、以後の変更はすべて新しい生成式を適用します。
《機械翻訳》このフォームは、生成された式のカラムを置き換えます。
格納されている生成されたデータの既存のカラムは書き換えられ、その後のすべての変更は新しい生成された式に適用されます。
     </para>

     <para>
<!--
      When this form is used on a stored generated column, its statistics
      are removed, so running
      <link linkend="sql-analyze"><command>ANALYZE</command></link>
      on the table afterwards is recommended.
      For a virtual generated column, <command>ANALYZE</command>
      is not necessary because such columns never have statistics.
-->
《機械翻訳》このフォームが保管された生成カラムで使用される場合、その統計処理は削除されるため、後でテーブルに対して<link linkend="sql-analyze"><command>ANALYZE</command></link>を実行することをお薦めします。
仮想的に生成されたカラムの場合、<command>ANALYZE</command>は必要ありません。
これは、このような列には統計処理がないためです。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="sql-altertable-desc-drop-expression">
    <term><literal>DROP EXPRESSION [ IF EXISTS ]</literal></term>
    <listitem>
     <para>
<!--
      This form turns a stored generated column into a normal base column.
      Existing data in the columns is retained, but future changes will no
      longer apply the generation expression.
-->
この構文は、格納された生成列を通常の基本列に変換します。
列の既存のデータは保持されますが、以後の変更はもはや生成式を適用しません。
     </para>

     <para>
<!--
      This form is currently only supported for stored generated columns (not
      virtual ones).
-->
《機械翻訳》このフォームは現在、（仮想列ではなく）格納された生成列に対してのみサポートされています。
     </para>

     <para>
<!--
      If <literal>DROP EXPRESSION IF EXISTS</literal> is specified and the
      column is not a generated column, no error is thrown.  In this case a
      notice is issued instead.
-->
《マッチ度[84.049080]》<literal>DROP EXPRESSION IF EXISTS</literal>が指定され、その列が格納された生成列でない場合は、エラーを発生させません。
この場合、注意メッセージが発行されます。
《機械翻訳》<literal>DROP EXPRESSION IF EXISTS</literal>が指定され、そのカラムが生成されたカラムでない場合、エラーはスローされません。
このケースでは、代わりに通知が発行されます。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="sql-altertable-desc-generated-identity">
    <term><literal>ADD GENERATED { ALWAYS | BY DEFAULT } AS IDENTITY</literal></term>
    <term><literal>SET GENERATED { ALWAYS | BY DEFAULT }</literal></term>
    <term><literal>DROP IDENTITY [ IF EXISTS ]</literal></term>
    <listitem>
     <para>
<!--
      These forms change whether a column is an identity column or change the
      generation attribute of an existing identity column.
      See <link linkend="sql-createtable"><command>CREATE TABLE</command></link> for details.
      Like <literal>SET DEFAULT</literal>, these forms only affect the
      behavior of subsequent <command>INSERT</command>
      and <command>UPDATE</command> commands; they do not cause rows
      already in the table to change.
-->
この構文では、列が識別列であるかどうか、または既存の識別列の生成属性を変更することができます。
詳細は<link linkend="sql-createtable"><command>CREATE TABLE</command></link>を参照してください。
<literal>SET DEFAULT</literal>同様に、この構文は、変更後に行われる<command>INSERT</command>または<command>UPDATE</command>コマンドにのみ適用されます。
テーブル内の既存の行は変更されません。
     </para>

     <para>
<!--
      If <literal>DROP IDENTITY IF EXISTS</literal> is specified and the
      column is not an identity column, no error is thrown.  In this case a
      notice is issued instead.
-->
<literal>DROP IDENTITY IF EXISTS</literal>が指定され、その列が識別列でない場合は、エラーを発生させません。
この場合、注意メッセージが発行されます。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="sql-altertable-desc-set-sequence-option">
    <term><literal>SET <replaceable>sequence_option</replaceable></literal></term>
    <term><literal>RESTART</literal></term>
    <listitem>
     <para>
<!--
      These forms alter the sequence that underlies an existing identity
      column.  <replaceable>sequence_option</replaceable> is an option
      supported by <link linkend="sql-altersequence"><command>ALTER SEQUENCE</command></link> such
      as <literal>INCREMENT BY</literal>.
-->
この構文では、既存の識別列に紐付けられているシーケンスを変更します。
<replaceable>sequence_option</replaceable>は<literal>INCREMENT BY</literal>など<link linkend="sql-altersequence"><command>ALTER SEQUENCE</command></link>がサポートするオプションです。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="sql-altertable-desc-set-statistics">
    <term><literal>SET STATISTICS</literal></term>
    <listitem>
     <para>
<!--
      This form
      sets the per-column statistics-gathering target for subsequent
      <link linkend="sql-analyze"><command>ANALYZE</command></link> operations.
      The target can be set in the range 0 to 10000.  Set it
      to <literal>DEFAULT</literal> to revert to using the system default
      statistics target (<xref linkend="guc-default-statistics-target"/>).
      (Setting to a value of -1 is an obsolete way spelling to get the same
      outcome.)
      For more information on the use of statistics by the
      <productname>PostgreSQL</productname> query planner, refer to
      <xref linkend="planner-stats"/>.
-->
この構文は、以後の<link linkend="sql-analyze"><command>ANALYZE</command></link>操作において、列単位での統計情報収集目標値を設定します。
目標値として、0から10000までの範囲の値を設定可能です。
<literal>DEFAULT</literal>に設定すると、システムのデフォルト統計情報目標値（<xref linkend="guc-default-statistics-target"/>）を使用するように戻されます。
（値を -1 に設定する方法は、同じ結果を得るための古い方法です。）
<productname>PostgreSQL</productname>の問い合わせプランナによる統計情報の使用に関する詳細は、<xref linkend="planner-stats"/>を参照してください。
     </para>
     <para>
<!--
      <literal>SET STATISTICS</literal> acquires a
      <literal>SHARE UPDATE EXCLUSIVE</literal> lock.
-->
<literal>SET STATISTICS</literal>は<literal>SHARE UPDATE EXCLUSIVE</literal>ロックを取得します。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="sql-altertable-desc-set-attribute-option">
    <term><literal>SET ( <replaceable class="parameter">attribute_option</replaceable> = <replaceable class="parameter">value</replaceable> [, ... ] )</literal></term>
    <term><literal>RESET ( <replaceable class="parameter">attribute_option</replaceable> [, ... ] )</literal></term>
    <listitem>
     <para>
<!--
      This form sets or resets per-attribute options.  Currently, the only
      defined per-attribute options are <literal>n_distinct</literal> and
      <literal>n_distinct_inherited</literal>, which override the
      number-of-distinct-values estimates made by subsequent
      <link linkend="sql-analyze"><command>ANALYZE</command></link>
      operations.  <literal>n_distinct</literal> affects the statistics for the table
      itself, while <literal>n_distinct_inherited</literal> affects the statistics
      gathered for the table plus its inheritance children.  When set to a
      positive value, <command>ANALYZE</command> will assume that the column contains
      exactly the specified number of distinct nonnull values.  When set to a
      negative value, which must be greater
      than or equal to -1, <command>ANALYZE</command> will assume that the number of
      distinct nonnull values in the column is linear in the size of the
      table; the exact count is to be computed by multiplying the estimated
      table size by the absolute value of the given number.  For example,
      a value of -1 implies that all values in the column are distinct, while
      a value of -0.5 implies that each value appears twice on the average.
      This can be useful when the size of the table changes over time, since
      the multiplication by the number of rows in the table is not performed
      until query planning time.  Specify a value of 0 to revert to estimating
      the number of distinct values normally.  For more information on the use
      of statistics by the <productname>PostgreSQL</productname> query
      planner, refer to <xref linkend="planner-stats"/>.
-->
この構文は属性単位のオプションの設定または設定解除を行います。
現時点では属性単位のオプションで定義されているのは<literal>n_distinct</literal>および<literal>n_distinct_inherited</literal>のみです。
これらのオプションは、その後の<link linkend="sql-analyze"><command>ANALYZE</command></link>操作により生成される個別値数の推定値を上書きします。
<literal>n_distinct</literal>はテーブル自身の統計情報に影響を与え、<literal>n_distinct_inherited</literal>はテーブルとそれを継承した子テーブルから集めた統計情報に影響を与えます。
正の値の場合、<command>ANALYZE</command>は、その列には、正確に指定された個数の非NULLの個別値が存在するものとみなします。
負の値の場合、この値は-1以上でなければなりませんが、<command>ANALYZE</command>は、その列内の非NULLの個別値はテーブルのサイズに線形であるとみなし、推定テーブルサイズに指定した値の絶対値を乗じた値が個別値数であるとみなします。
たとえば、-1という値は、列内のすべての値に重複がないことを意味し、-0.5という値は個々の値は平均して2回現れることを意味します。
テーブルの行数との乗算は問い合わせ計画を作成するまで行われませんので、テーブルサイズが変わり続けるような場合にこれは有用かもしれません。
0という値を指定することで、個別値数の推定を通常に戻します。
<productname>PostgreSQL</productname>問い合わせプランナにおける統計情報の使用に関しては<xref linkend="planner-stats"/>を参照してください。
     </para>
     <para>
<!--
      Changing per-attribute options acquires a
      <literal>SHARE UPDATE EXCLUSIVE</literal> lock.
-->
属性単位のオプションの変更は<literal>SHARE UPDATE EXCLUSIVE</literal>ロックを取得します。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="sql-altertable-desc-set-storage">
    <term>
     <literal>SET STORAGE { PLAIN | EXTERNAL | EXTENDED | MAIN | DEFAULT }</literal>
     <indexterm>
      <primary>TOAST</primary>
      <secondary>per-column storage settings</secondary>
     </indexterm>
     <indexterm>
      <primary>TOAST</primary>
      <secondary>列ごとの保管設定</secondary>
     </indexterm>
    </term>
    <listitem>
     <para>
<!--
      This form sets the storage mode for a column. This controls whether this
      column is held inline or in a secondary <acronym>TOAST</acronym> table,
      and whether the data
      should be compressed or not. <literal>PLAIN</literal> must be used
      for fixed-length values such as <type>integer</type> and is
      inline, uncompressed. <literal>MAIN</literal> is for inline,
      compressible data. <literal>EXTERNAL</literal> is for external,
      uncompressed data, and <literal>EXTENDED</literal> is for external,
      compressed data.
      Writing <literal>DEFAULT</literal> sets the storage mode to the default
      mode for the column's data type.  <literal>EXTENDED</literal> is the
      default for most data types that support non-<literal>PLAIN</literal>
      storage.
      Use of <literal>EXTERNAL</literal> will make substring operations on
      very large <type>text</type> and <type>bytea</type> values run faster,
      at the penalty of increased storage space.
      Note that <literal>ALTER TABLE ... SET STORAGE</literal> doesn't itself
      change anything in the table; it just sets the strategy to be pursued
      during future table updates.
      See <xref linkend="storage-toast"/> for more information.
-->
この構文は、列の格納モードを設定します。
列をインラインで保持するか補助<acronym>TOAST</acronym>テーブルに保持するか、また、データを圧縮するかどうかを制御できます。
<literal>PLAIN</literal>は、<type>integer</type>のような固定長の値に対して使用します。インラインで保持され、圧縮されません。
<literal>MAIN</literal>は、インラインで保持されていて、圧縮可能なデータに使用します。
<literal>EXTERNAL</literal>は圧縮されていない外部データに使用します。
<literal>EXTENDED</literal>は圧縮された外部データに使用します。
<literal>DEFAULT</literal>と書くと、列のデータ型に対して格納モードをデフォルトのモードに設定します。
<literal>EXTENDED</literal>は、<literal>PLAIN</literal>以外の保管をサポートするほとんどのデータ型におけるデフォルトです。
<literal>EXTERNAL</literal>を使用すると、非常に長い<type>text</type>および<type>bytea</type>列に対する部分文字列操作の処理速度が向上しますが、必要な保管容量が増えるというデメリットがあります。
<literal>ALTER TABLE ... SET STORAGE</literal>自体はテーブルをまったく変更しないことに注意してください。
以後のテーブルの更新時に遂行する戦略を設定するだけです。
詳細は<xref linkend="storage-toast"/>を参照してください。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="sql-altertable-desc-set-compression">
    <term>
     <literal>SET COMPRESSION <replaceable class="parameter">compression_method</replaceable></literal>
    </term>
    <listitem>
     <para>
<!--
      This form sets the compression method for a column, determining how
      values inserted in future will be compressed (if the storage mode
      permits compression at all).
      This does not cause the table to be rewritten, so existing data may still
      be compressed with other compression methods.  If the table is restored
      with <application>pg_restore</application>, then all values are rewritten
      with the configured compression method.
      However, when data is inserted from another relation (for example,
      by <command>INSERT ... SELECT</command>), values from the source table are
      not necessarily detoasted, so any previously compressed data may retain
      its existing compression method, rather than being recompressed with the
      compression method of the target column.
      The supported compression
      methods are <literal>pglz</literal> and <literal>lz4</literal>.
      (<literal>lz4</literal> is available only if <option>&#45;-with-lz4</option>
      was used when building <productname>PostgreSQL</productname>.)  In
      addition, <replaceable class="parameter">compression_method</replaceable>
      can be <literal>default</literal>, which selects the default behavior of
      consulting the <xref linkend="guc-default-toast-compression"/> setting
      at the time of data insertion to determine the method to use.
-->
この構文を使用すると、列の圧縮方式を設定し、将来挿入される値がどのように圧縮されるかを決定できます（格納モードで圧縮が許可されている場合）。
これによってテーブルが書き換えられることはないため、既存のデータは他の圧縮方式で圧縮されたままの可能性があります。
テーブルを<application>pg_restore</application>でリストアした場合、すべての値は設定された圧縮方式で書き直されます。
しかし、データが別のリレーションから挿入された場合(例えば<command>INSERT ... SELECT</command>によって)、元となるテーブルからの値は必ずしも非TOAST化されるとは限らないため、以前に圧縮されたデータは、対象列の圧縮方式で再圧縮されるのではなく、既存の圧縮方式を保持する場合があります。
サポートされている圧縮方式は、<literal>pglz</literal>と<literal>lz4</literal>です。
（<literal>lz4</literal>は、<productname>PostgreSQL</productname>のビルド時に<option>--with-lz4</option>が使用された場合にのみ使用できます。）
さらに、<replaceable class="parameter">compression_method</replaceable>を<literal>default</literal>にすることができ、これにより、データ挿入時に<xref linkend="guc-default-toast-compression"/>設定を参照して、使用する方法を決定するデフォルトの動作が選択されます。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="sql-altertable-desc-add-table-constraint">
    <term><literal>ADD <replaceable class="parameter">table_constraint</replaceable> [ NOT VALID ]</literal></term>
    <listitem>
     <para>
<!--
      This form adds a new constraint to a table using the same constraint
      syntax as <link linkend="sql-createtable"><command>CREATE TABLE</command></link>, plus the option <literal>NOT
      VALID</literal>, which is currently only allowed for foreign-key,
      <literal>CHECK</literal>, and not-null constraints.
-->
《マッチ度[82.154882]》この構文は、<link linkend="sql-createtable"><command>CREATE TABLE</command></link>と同じ制約構文に加え、現時点では外部キー制約と検査制約でのみ許される<literal>NOT VALID</literal>オプションを使って新しい制約をテーブルに追加します。
《機械翻訳》このフォームは、<link linkend="sql-createtable"><command>CREATE TABLE</command></link>と同じ制約構文を使用してテーブルに新しい制約を追加します。
プラスオプション<literal>NOT VALID</literal>、これは現在、外部キー制約、<literal>CHECK</literal>、および非NULL制約でのみ許可されています。
     </para>

     <para>
<!--
      Normally, this form will cause a scan of the table to verify that all
      existing rows in the table satisfy the new constraint.  But if
      the <literal>NOT VALID</literal> option is used, this
      potentially-lengthy scan is skipped.  The constraint will still be
      applied against subsequent inserts or updates (that is, they'll fail
      unless there is a matching row in the referenced table, in the case
      of foreign keys, or they'll fail unless the new row matches the
      specified check condition).  But the
      database will not assume that the constraint holds for all rows in
      the table, until it is validated by using the <literal>VALIDATE
      CONSTRAINT</literal> option.
      See <xref linkend="sql-altertable-notes"/> below for more information
      about using the <literal>NOT VALID</literal> option.
-->
《マッチ度[88.715953]》通常この構文は、テーブルの既存の行が新しい制約を満たすか確認するため、テーブルのスキャンの原因となります。
しかし、<literal>NOT VALID</literal>オプションが使われていれば、時間がかかるかもしれないこのスキャンは省略されます。
それでも、制約はその後の挿入や更新に対して強制されます（つまり、外部キー制約の場合、被参照テーブルに一致する行が存在しない限り失敗します。指定された検査制約に一致する新しい行が存在しない限り失敗します）。
しかしデータベースは、<literal>VALIDATE CONSTRAINT</literal>オプションを使用して検証されるまで、テーブル内のすべての行で制約が保持されているとみなしません。
<literal>NOT VALID</literal>オプションを使うことに関する更なる情報は<xref linkend="sql-altertable-notes"/>以下を参照してください。
《機械翻訳》通常、このフォームは、テーブルのスキャンに、テーブル内の既存のすべての行が新しい制約を満たすことを確認させます。
しかし、<literal>NOT VALID</literal>オプションが使用される場合、この潜在的に長いスキャンはスキップされたです。
制約は、その後の挿入または更新にも適用されます（つまり、被参照テーブル内、外部キーのケース内にマッチング行がない限り失敗し、新しい行が指定されたチェック条件に一致しない限り失敗します）。
しかし、データベースは、<literal>VALIDATE CONSTRAINT</literal>オプションを使用して検証されるまで、テーブル内のすべての行に制約が保持されるとは想定しません。
<literal>NOT VALID</literal>オプションの使用の詳細については、後述の<xref linkend="sql-altertable-notes"/>を参照してください。
     </para>

     <para>
<!--
      Although most forms of <literal>ADD
      <replaceable class="parameter">table_constraint</replaceable></literal>
      require an <literal>ACCESS EXCLUSIVE</literal> lock, <literal>ADD
      FOREIGN KEY</literal> requires only a <literal>SHARE ROW
      EXCLUSIVE</literal> lock.  Note that <literal>ADD FOREIGN KEY</literal>
      also acquires a <literal>SHARE ROW EXCLUSIVE</literal> lock on the
      referenced table, in addition to the lock on the table on which the
      constraint is declared.
-->
<literal>ADD <replaceable class="parameter">table_constraint</replaceable></literal>のほとんどの構文では<literal>ACCESS EXCLUSIVE</literal>ロックが必要ですが、<literal>ADD FOREIGN KEY</literal>では<literal>SHARE ROW EXCLUSIVE</literal>ロックだけが必要です。
<literal>ADD FOREIGN KEY</literal>は、制約を宣言したテーブルでのロックに加えて、被参照テーブルの<literal>SHARE ROW EXCLUSIVE</literal>ロックも取得することに注意してください。
     </para>

     <para>
<!--
      Additional restrictions apply when unique or primary key constraints
      are added to partitioned tables; see <link linkend="sql-createtable"><command>CREATE TABLE</command></link>.
-->
《機械翻訳》ユニークまたは主キーの制約がテーブルパーティションに追加されると、追加の制限が適用されます。
<link linkend="sql-createtable"><command>CREATE TABLE</command></link>を参照してください。
     </para>

    </listitem>
   </varlistentry>

   <varlistentry id="sql-altertable-desc-add-table-constraint-using-index">
    <term><literal>ADD <replaceable class="parameter">table_constraint_using_index</replaceable></literal></term>
    <listitem>
     <para>
<!--
      This form adds a new <literal>PRIMARY KEY</literal> or <literal>UNIQUE</literal>
      constraint to a table based on an existing unique index.  All the
      columns of the index will be included in the constraint.
-->
この構文は、既存の一意性インデックスに基づき、テーブルに<literal>PRIMARY KEY</literal>または<literal>UNIQUE</literal>制約を新たに追加します。
インデックスのすべての列がこの制約に含まれます。
     </para>

     <para>
<!--
      The index cannot have expression columns nor be a partial index.
      Also, it must be a b-tree index with default sort ordering.  These
      restrictions ensure that the index is equivalent to one that would be
      built by a regular <literal>ADD PRIMARY KEY</literal> or <literal>ADD UNIQUE</literal>
      command.
-->
このインデックスは式列を持つことはできず、また部分インデックスであってはいけません。
またこれはデフォルトのソート順序を持つB-Treeインデックスでなければなりません。
これらの制限により、このインデックスが通常の<literal>ADD PRIMARY KEY</literal>または<literal>ADD UNIQUE</literal>コマンドにより構築されたインデックスと等価であることを確実にします。
     </para>

     <para>
<!--
      If <literal>PRIMARY KEY</literal> is specified, and the index's columns are not
      already marked <literal>NOT NULL</literal>, then this command will attempt to
      do <literal>ALTER COLUMN SET NOT NULL</literal> against each such column.
      That requires a full table scan to verify the column(s) contain no
      nulls.  In all other cases, this is a fast operation.
-->
<literal>PRIMARY KEY</literal>が指定され、インデックスの列が<literal>NOT NULL</literal>と印付けされていない場合、このコマンドはこうした列のそれぞれに対して<literal>ALTER COLUMN SET NOT NULL</literal>の実施を試みます。
これは列にNULLが含まれないことを検証するために完全なテーブルスキャンを必要とします。
この他の場合においては、これが高速な操作です。
     </para>

     <para>
<!--
      If a constraint name is provided then the index will be renamed to match
      the constraint name.  Otherwise the constraint will be named the same as
      the index.
-->
制約名が提供された場合、インデックスの名前は制約名に合うように変更されます。
提供されない場合は制約にはインデックスと同じ名前が付けられます。
     </para>

     <para>
<!--
      After this command is executed, the index is <quote>owned</quote> by the
      constraint, in the same way as if the index had been built by
      a regular <literal>ADD PRIMARY KEY</literal> or <literal>ADD UNIQUE</literal>
      command.  In particular, dropping the constraint will make the index
      disappear too.
-->
このコマンドの実行後、インデックスは、制約により<quote>所有</quote>され、それはインデックスが通常の<literal>ADD PRIMARY KEY</literal>または<literal>ADD UNIQUE</literal>により構築された場合と同様です。
特にこの制約を削除するとインデックスも消えてしまいます。
     </para>

     <para>
<!--
      This form is not currently supported on partitioned tables.
-->
この形式は今のところパーティションテーブルではサポートされません。
     </para>

     <note>
      <para>
<!--
       Adding a constraint using an existing index can be helpful in
       situations where a new constraint needs to be added without blocking
       table updates for a long time.  To do that, create the index using
       <command>CREATE UNIQUE INDEX CONCURRENTLY</command>, and then convert it to a
       constraint using this syntax.  See the example below.
-->
既存のインデックスを使用した制約の追加は、テーブル更新を長時間ブロックすることなく新しい制約を追加しなければならない場合に有用になる可能性があります。
このためには、<command>CREATE UNIQUE INDEX CONCURRENTLY</command>を用いてインデックスを作成し、この構文を使用して制約に変換してください。
後述の例を参照してください。
      </para>
     </note>
    </listitem>
   </varlistentry>

   <varlistentry id="sql-altertable-desc-alter-constraint">
    <term><literal>ALTER CONSTRAINT</literal></term>
    <listitem>
     <para>
<!--
      This form alters the attributes of a constraint that was previously
      created. Currently only foreign key constraints may be altered in
      this fashion, but see below.
-->
《マッチ度[73.456790]》この構文は以前に作成された制約の属性を変更します。
現在は外部キー制約のみを変更できます。
《機械翻訳》このフォームは、以前に作成された制約の属性を変更します。
現在、この方法で変更できるのは外部キー制約のみですが、以下を参照してください。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="sql-altertable-desc-alter-constraint-inherit">
    <term><literal>ALTER CONSTRAINT ... INHERIT</literal></term>
    <term><literal>ALTER CONSTRAINT ... NO INHERIT</literal></term>
    <listitem>
     <para>
<!--
      These forms modify a inheritable constraint so that it becomes not
      inheritable, or vice-versa. Only not-null constraints may be altered
      in this fashion at present.
      In addition to changing the inheritability status of the constraint,
      in the case where a non-inheritable constraint is being marked
      inheritable, if the table has children, an equivalent constraint
      will be added to them. If marking an inheritable constraint as
      non-inheritable on a table with children, then the corresponding
      constraint on children will be marked as no longer inherited,
      but not removed.
-->
《機械翻訳》これらの形式は、継承可能制約を形成して非継承可能NULLにするか、またはその逆にします。
非継承可能ステータスのみ、現在この方法で変更できます。
制約の継承可能性を変更することに加えて、非継承可能制約が継承可能としてマークされているケースでは、テーブルに子がある場合、同等の制約が追加されます。
マーキングが、子を持つ表で継承可能制約を非継承可能としてマークした場合、子の対応する制約は継承されないとしてマークされますが、削除はされません。
      </para>
     </listitem>
    </varlistentry>

   <varlistentry id="sql-altertable-desc-validate-constraint">
    <term><literal>VALIDATE CONSTRAINT</literal></term>
    <listitem>
     <para>
<!--
      This form validates a foreign key, check, or not-null constraint that was
      previously created as <literal>NOT VALID</literal>, by scanning the
      table to ensure there are no rows for which the constraint is not
      satisfied.  If the constraint was set to <literal>NOT ENFORCED</literal>, an error is thrown.
      Nothing happens if the constraint is already marked valid.
      (See <xref linkend="sql-altertable-notes"/> below for an explanation
      of the usefulness of this command.)
-->
《マッチ度[72.413793]》この構文は、以前に<literal>NOT VALID</literal>として作成された外部キー制約または検査制約を、これらの制約を満たさない行が存在しないことを確認するためにテーブルをスキャンして、検証します。
制約がすでに有効であると記録されている場合は何も起こりません。
(このコマンドの有用性の説明は<xref linkend="sql-altertable-notes"/>以下を参照してください。)
《機械翻訳》このフォームは、以前にとして作成された外部キー、チェックまたは非NULL制約を検証します<literal>NOT VALID</literal>テーブルを保証にスキャンすることで、制約が満たされない行はありません。
制約が<literal>NOT ENFORCED</literal>に設定されている場合、エラーがスローされます。
制約がすでに有効とマークされている場合は、何も起こりません。
(このコマンドの便利な点については、後述の<xref linkend="sql-altertable-notes"/>を参照してください。
     </para>
     <para>
<!--
      This command acquires a <literal>SHARE UPDATE EXCLUSIVE</literal> lock.
-->
このコマンドは<literal>SHARE UPDATE EXCLUSIVE</literal>ロックを取得します。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="sql-altertable-desc-drop-constraint">
    <term><literal>DROP CONSTRAINT [ IF EXISTS ]</literal></term>
    <listitem>
     <para>
<!--
      This form drops the specified constraint on a table, along with
      any index underlying the constraint.
      If <literal>IF EXISTS</literal> is specified and the constraint
      does not exist, no error is thrown. In this case a notice is issued instead.
-->
この構文はテーブル上の指定した制約を、制約の基となるインデックスと共に削除します。
<literal>IF EXISTS</literal>が指定された場合、その制約がなくてもエラーになりません。
この場合は代わりに注意が出力されます。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="sql-altertable-desc-disable-enable-trigger">
    <term><literal>DISABLE</literal>/<literal>ENABLE [ REPLICA | ALWAYS ] TRIGGER</literal></term>
    <listitem>
     <para>
<!--
      These forms configure the firing of trigger(s) belonging to the table.
      A disabled trigger is still known to the system, but is not executed
      when its triggering event occurs.  (For a deferred trigger, the enable
      status is checked when the event occurs, not when the trigger function
      is actually executed.)  One can disable or enable a single
      trigger specified by name, or all triggers on the table, or only
      user triggers (this option excludes internally generated constraint
      triggers, such as those that are used to implement foreign key
      constraints or deferrable uniqueness and exclusion constraints).
      Disabling or enabling internally generated constraint triggers
      requires superuser privileges; it should be done with caution since
      of course the integrity of the constraint cannot be guaranteed if the
      triggers are not executed.
-->
この構文を使用すると、テーブルに属するトリガの発行について設定できます。
無効にされたトリガはシステム上に存在し続けますが、トリガイベントが発生したとしても実行されません。
（遅延トリガの場合、有効無効状態の確認は、トリガ関数を実際に実行しようとする時ではなく、イベントの発生時に行われます。）
名前でトリガを1つ指定して有効または無効にすることもできますし、テーブル上のすべてのトリガを有効または無効にすることもできます。
また、ユーザトリガのみを有効または無効にすることも可能です
（このオプションは、外部キー制約、遅延可能な一意性および排他制約を実装するために使用される内部向けに生成される制約トリガを除外します。）
内部向けに生成される制約トリガを有効または無効にするにはスーパーユーザ権限が必要です。
トリガが実行されなかった場合は当然ながら制約の整合性が保証されませんので、制約トリガの無効化は注意して実行しなければなりません。
     </para>

     <para>
<!--
      The trigger firing mechanism is also affected by the configuration
      variable <xref linkend="guc-session-replication-role"/>. Simply enabled
      triggers (the default) will fire when the replication role is <quote>origin</quote>
      (the default) or <quote>local</quote>. Triggers configured as <literal>ENABLE
      REPLICA</literal> will only fire if the session is in <quote>replica</quote>
      mode, and triggers configured as <literal>ENABLE ALWAYS</literal> will
      fire regardless of the current replication role.
-->
トリガ発行機構は設定変数<xref linkend="guc-session-replication-role"/>の影響も受けます。
単に有効としたトリガ（デフォルト）では、レプリケーションロールが<quote>origin</quote>（デフォルト）または<quote>local</quote>の場合に発行されます。
<literal>ENABLE REPLICA</literal>と設定されたトリガでは、セッションが<quote>replica</quote>モードである場合のみ発行されます。
そして、<literal>ENABLE ALWAYS</literal>と設定されたトリガでは、現在のレプリケーションロールに関係なく発行されます。
     </para>

     <para>
<!--
      The effect of this mechanism is that in the default configuration,
      triggers do not fire on replicas.  This is useful because if a trigger
      is used on the origin to propagate data between tables, then the
      replication system will also replicate the propagated data; so the
      trigger should not fire a second time on the replica, because that would
      lead to duplication.  However, if a trigger is used for another purpose
      such as creating external alerts, then it might be appropriate to set it
      to <literal>ENABLE ALWAYS</literal> so that it is also fired on
      replicas.
-->
この仕組みの効果はデフォルト設定ではレプリカ上でトリガが発行しないことです。
トリガがオリジンでテーブル間でデータを伝播するのに使われている場合にレプリケーションシステムは伝播したデータもレプリケーションします。レプリカ上でトリガが再度発動すべきではありませんので、これは有用です。
しかしながら、トリガが外部的な警告を発するなどの他の意図で使われている場合、レプリカでもトリガが発行されるように<literal>ENABLE ALWAYS</literal>を設定するのが適切と言えます。
     </para>

     <para>
<!--
      When this command is applied to a partitioned table, the states of
      corresponding clone triggers in the partitions are updated too,
      unless <literal>ONLY</literal> is specified.
-->
このコマンドがパーティション化されたテーブルに適用されると、<literal>ONLY</literal>が指定されていない限り、パーティション内の対応するクローントリガの状態も更新されます。
     </para>

     <para>
<!--
      This command acquires a <literal>SHARE ROW EXCLUSIVE</literal> lock.
-->
このコマンドは<literal>SHARE ROW EXCLUSIVE</literal>ロックを取得します。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="sql-altertable-desc-disable-enable-rule">
    <term><literal>DISABLE</literal>/<literal>ENABLE [ REPLICA | ALWAYS ] RULE</literal></term>
    <listitem>
     <para>
<!--
      These forms configure the firing of rewrite rules belonging to the table.
      A disabled rule is still known to the system, but is not applied
      during query rewriting. The semantics are as for disabled/enabled
      triggers. This configuration is ignored for <literal>ON SELECT</literal> rules, which
      are always applied in order to keep views working even if the current
      session is in a non-default replication role.
-->
この構文を使用すると、テーブルに属する書き換えルールの実行について設定することができます。
ルールは無効にしてもシステムに残りますが、問い合わせ書き換え時に適用されません。
この意味はトリガの有効化、無効化と同じです。
この設定は<literal>ON SELECT</literal>ルールでは無視されます。
現在のセッションがデフォルト以外のレプリケーションモードであったとしても、ビュー操作を維持するために常に適用されます。
     </para>

     <para>
<!--
      The rule firing mechanism is also affected by the configuration variable
      <xref linkend="guc-session-replication-role"/>, analogous to triggers as
      described above.
-->
前述のトリガと同様に、ルール発行機構は設定変数<xref linkend="guc-session-replication-role"/>の影響を受けます。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="sql-altertable-desc-disable-enable-row-level-security">
    <term><literal>DISABLE</literal>/<literal>ENABLE ROW LEVEL SECURITY</literal></term>
    <listitem>
     <para>
<!--
      These forms control the application of row security policies belonging
      to the table.  If enabled and no policies exist for the table, then a
      default-deny policy is applied.  Note that policies can exist for a table
      even if row-level security is disabled.  In this case, the policies will
      <emphasis>not</emphasis> be applied and the policies will be ignored.
      See also
      <link linkend="sql-createpolicy"><command>CREATE POLICY</command></link>.
-->
これらの構文は、テーブルの行セキュリティポリシーの適用を制御します。
有効にされ、かつテーブルにポリシーが存在しない場合は、デフォルトの拒絶ポリシーが適用されます。
行単位セキュリティが無効になっている場合でも、テーブルのセキュリティが存在し得ることに注意してください。
この場合、ポリシーは適用<emphasis>されず</emphasis>、無視されます。
<link linkend="sql-createpolicy"><command>CREATE POLICY</command></link>も参照してください。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="sql-altertable-desc-force-row-level-security">
    <term><literal>NO FORCE</literal>/<literal>FORCE ROW LEVEL SECURITY</literal></term>
    <listitem>
     <para>
<!--
      These forms control the application of row security policies belonging
      to the table when the user is the table owner.  If enabled, row-level
      security policies will be applied when the user is the table owner.  If
      disabled (the default) then row-level security will not be applied when
      the user is the table owner.
      See also
      <link linkend="sql-createpolicy"><command>CREATE POLICY</command></link>.
-->
これらの構文は、ユーザがテーブルの所有者である場合について、テーブルの行セキュリティポリシーの適用を制御します。
有効の場合、ユーザがテーブルの所有者であれば、行セキュリティポリシーが適用されます。
無効（デフォルト）の場合、ユーザがテーブルの所有者であれば、行セキュリティポリシーは適用されません。
<link linkend="sql-createpolicy"><command>CREATE POLICY</command></link>も参照してください。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="sql-altertable-desc-cluster-on">
    <term><literal>CLUSTER ON</literal></term>
    <listitem>
     <para>
<!--
      This form selects the default index for future
      <link linkend="sql-cluster"><command>CLUSTER</command></link>
      operations.  It does not actually re-cluster the table.
-->
この構文は、以後の<link linkend="sql-cluster"><command>CLUSTER</command></link>操作用のデフォルトインデックスを選択します。
テーブルの再クラスタ化は実際には行いません。
     </para>
     <para>
<!--
      Changing cluster options acquires a <literal>SHARE UPDATE EXCLUSIVE</literal> lock.
-->
clusterオプションの変更は<literal>SHARE UPDATE EXCLUSIVE</literal>ロックを取得します。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="sql-altertable-desc-set-without-cluster">
    <term><literal>SET WITHOUT CLUSTER</literal></term>
    <listitem>
     <para>
<!--
      This form removes the most recently used
      <link linkend="sql-cluster"><command>CLUSTER</command></link>
      index specification from the table.  This affects
      future cluster operations that don't specify an index.
-->
この構文は、テーブルから、一番最後に適用された<link linkend="sql-cluster"><command>CLUSTER</command></link>インデックス指定を削除します。
以後のインデックスを指定しないクラスタ操作に影響を及ぼします。
     </para>
     <para>
<!--
      Changing cluster options acquires a <literal>SHARE UPDATE EXCLUSIVE</literal> lock.
-->
clusterオプションの変更は<literal>SHARE UPDATE EXCLUSIVE</literal>ロックを取得します。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="sql-altertable-desc-set-without-oids">
    <term><literal>SET WITHOUT OIDS</literal></term>
    <listitem>
     <para>
<!--
      Backward-compatible syntax for removing the <literal>oid</literal>
      system column.  As <literal>oid</literal> system columns cannot be
      added anymore, this never has an effect.
-->
システム列<literal>oid</literal>を削除する、後方互換のための構文です。
システム列<literal>oid</literal>は今では追加できませんので、これは効果がありません。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="sql-altertable-desc-set-access-method">
    <term><literal>SET ACCESS METHOD</literal></term>
    <listitem>
     <para>
<!--
      This form changes the access method of the table by rewriting it
      using the indicated access method; specifying
      <literal>DEFAULT</literal> selects the access method set as the
      <xref linkend="guc-default-table-access-method"/> configuration
      parameter.
      See <xref linkend="tableam"/> for more information.
-->
この構文は、指定のアクセスメソッドを使ってテーブルのアクセスメソッドを書き換えることにより変更します。<literal>DEFAULT</literal>を指定すると、<xref linkend="guc-default-table-access-method"/>設定パラメータとして設定されたアクセスメソッドが選ばれます。
詳細は<xref linkend="tableam"/>を参照してください。
     </para>
     <para>
<!--
      When applied to a partitioned table, there is no data to rewrite,
      but partitions created afterwards will default to the given access
      method unless overridden by a <literal>USING</literal> clause.
      Specifying <varname>DEFAULT</varname> removes a previous value,
      causing future partitions to default to
      <varname>default_table_access_method</varname>.
-->
パーティションテーブルに適用すると、書き換えるデータはありませんが、後で作成されるパーティションは<literal>USING</literal>句で上書きされない限り、指定されたアクセスメソッドがデフォルトになります。
<varname>DEFAULT</varname>を指定すると、以前の値が削除され、以降のパーティションは<varname>default_table_access_method</varname>がデフォルトになります。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="sql-altertable-desc-set-tablespace">
    <term><literal>SET TABLESPACE</literal></term>
    <listitem>
     <para>
<!--
      This form changes the table's tablespace to the specified tablespace and
      moves the data file(s) associated with the table to the new tablespace.
      Indexes on the table, if any, are not moved; but they can be moved
      separately with additional <literal>SET TABLESPACE</literal> commands.
      When applied to a partitioned table, nothing is moved, but any
      partitions created afterwards with
      <command>CREATE TABLE PARTITION OF</command> will use that tablespace,
      unless overridden by a <literal>TABLESPACE</literal> clause.
-->
この構文を使用すると、テーブルのテーブル空間を指定したテーブル空間に変更し、テーブルに関連するデータファイルを新しいテーブル空間に移動することができます。
テーブルにインデックスがあっても移動されません。
インデックスを移動するには、別途<literal>SET TABLESPACE</literal>コマンドを実行します。
パーティションテーブルに適用された場合には何も移動されませんが、以後<command>CREATE TABLE PARTITION OF</command>で作られるパーティションは、<literal>TABLESPACE</literal>句により上書きされない限り、そのテーブル空間を使うようになります。
     </para>

     <para>
<!--
      All tables in the current database in a tablespace can be moved by using
      the <literal>ALL IN TABLESPACE</literal> form, which will lock all tables
      to be moved first and then move each one.  This form also supports
      <literal>OWNED BY</literal>, which will only move tables owned by the
      roles specified.  If the <literal>NOWAIT</literal> option is specified
      then the command will fail if it is unable to acquire all of the locks
      required immediately.  Note that system catalogs are not moved by this
      command; use <command>ALTER DATABASE</command> or explicit
      <command>ALTER TABLE</command> invocations instead if desired.  The
      <literal>information_schema</literal> relations are not considered part
      of the system catalogs and will be moved.
      See also
      <link linkend="sql-createtablespace"><command>CREATE TABLESPACE</command></link>.
-->
<literal>ALL IN TABLESPACE</literal>構文を使うことで、テーブル空間内の現在のデータベースのすべてのテーブルを移動することができます。
この場合、移動されるすべてのテーブルがまずロックされ、それから一つずつ移動されます。
この構文は<literal>OWNED BY</literal>もサポートしており、これを使うと、指定のロールが所有しているテーブルだけを移動します。
<literal>NOWAIT</literal>を指定した場合、必要とするすべてのロックを即座に獲得できなければ、このコマンドは失敗します。
このコマンドではシステムカタログは移動されないことに注意し、必要なら代わりに<command>ALTER DATABASE</command>を使うか、あるいは<command>ALTER TABLE</command>で明示的に指定してください。
<literal>information_schema</literal>のリレーションはシステムカタログとはみなされないので、移動されます。
<link linkend="sql-createtablespace"><command>CREATE TABLESPACE</command></link>も参照してください。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="sql-altertable-desc-set-logged-unlogged">
    <term><literal>SET { LOGGED | UNLOGGED }</literal></term>
    <listitem>
     <para>
<!--
      This form changes the table from unlogged to logged or vice-versa
      (see <xref linkend="sql-createtable-unlogged"/>).  It cannot be applied
      to a temporary table.
-->
この構文は、テーブルをログを取らないテーブルからログを取るテーブルに変更、あるいはその逆を行います（<xref linkend="sql-createtable-unlogged"/>参照）。
これは一時テーブルに対して使うことはできません。
     </para>

     <para>
<!--
      This also changes the persistence of any sequences linked to the table
      (for identity or serial columns).  However, it is also possible to
      change the persistence of such sequences separately.
-->
これは、テーブルにリンクされたシーケンス(ID列またはシリアル列)の永続性も変更します。
一方、このようなシーケンスの永続性を個別に変更することもできます。
     </para>

     <para>
<!--
      This form is not supported for partitioned tables.
-->
《マッチ度[64.000000]》この形式は今のところパーティションテーブルではサポートされません。
《機械翻訳》このフォームはテーブルパーティションに対応していません。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="sql-altertable-desc-set-storage-parameter">
    <term><literal>SET ( <replaceable class="parameter">storage_parameter</replaceable> [= <replaceable class="parameter">value</replaceable>] [, ... ] )</literal></term>
    <listitem>
     <para>
<!--
      This form changes one or more storage parameters for the table.  See
      <xref linkend="sql-createtable-storage-parameters"/> in the
      <link linkend="sql-createtable"><command>CREATE TABLE</command></link> documentation
      for details on the available parameters.  Note that the table contents
      will not be modified immediately by this command; depending on the
      parameter you might need to rewrite the table to get the desired effects.
      That can be done with <link linkend="sql-vacuum"><command>VACUUM
      FULL</command></link>, <link linkend="sql-cluster"><command>CLUSTER</command></link> or one of the forms
      of <command>ALTER TABLE</command> that forces a table rewrite.
      For planner related parameters, changes will take effect from the next
      time the table is locked so currently executing queries will not be
      affected.
-->
この構文は、1つ以上のテーブルの格納パラメータを変更します。
設定可能なパラメータの詳細に関しては<link linkend="sql-createtable"><command>CREATE TABLE</command></link>文書の<xref linkend="sql-createtable-storage-parameters"/>を参照してください。
このコマンドによってテーブルの内容が即座に変更されない点に注意してください。
パラメータによりますが、期待する効果を得るためにテーブルを書き換える必要がある場合があります。
このためには、<link linkend="sql-vacuum"><command>VACUUM FULL</command></link>、<link linkend="sql-cluster"><command>CLUSTER</command></link>またはテーブルを強制的に書き換える<command>ALTER TABLE</command>の構文のいずれかを使用してください。
プランナに関連するパラメータについては、次にテーブルがロックされた時に変更が有効になるため、現在実行中の問い合わせは影響を受けません。
     </para>

     <para>
<!--
      <literal>SHARE UPDATE EXCLUSIVE</literal> lock will be taken for
      fillfactor, toast and autovacuum storage parameters, as well as the
      planner parameter <varname>parallel_workers</varname>.
-->
fillfactor、TOAST、およびautovacuumのストレージパラメータおよびプランナに関連するパラメータ<varname>parallel_workers</varname>については<literal>SHARE UPDATE EXCLUSIVE</literal>ロックが獲得されます。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="sql-altertable-desc-reset-storage-parameter">
    <term><literal>RESET ( <replaceable class="parameter">storage_parameter</replaceable> [, ... ] )</literal></term>
    <listitem>
     <para>
<!--
      This form resets one or more storage parameters to their
      defaults.  As with <literal>SET</literal>, a table rewrite might be
      needed to update the table entirely.
-->
この構文は、1つ以上の格納パラメータをデフォルト値に再設定します。
<literal>SET</literal>同様、テーブル全体を更新するためにテーブルの書き換えが必要になる場合があります。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="sql-altertable-desc-inherit">
    <term><literal>INHERIT <replaceable class="parameter">parent_table</replaceable></literal></term>
    <listitem>
     <para>
<!--
      This form adds the target table as a new child of the specified parent
      table.  Subsequently, queries against the parent will include records
      of the target table.  To be added as a child, the target table must
      already contain all the same columns as the parent (it could have
      additional columns, too).  The columns must have matching data types.
-->
《機械翻訳》このフォームは、指定したターゲットテーブルの新しい子として親テーブルを追加します。
その後、親に対する問い合わせを実行すると、ターゲットテーブルのレコードがincludeされます。
子として追加するには、ターゲットテーブルにすでに親と同じ列がすべて含まれている必要があります（列が追加される場合もあります）。
列にはマッチングデータタイプが必要です。
     </para>

     <para>
<!--
      In addition, all <literal>CHECK</literal> and <literal>NOT NULL</literal>
      constraints on the parent must also exist on the child, except those
      marked non-inheritable (that is, created with
      <literal>ALTER TABLE ... ADD CONSTRAINT ... NO INHERIT</literal>), which
      are ignored.  All child-table constraints matched must not be marked
      non-inheritable.  Currently
      <literal>UNIQUE</literal>, <literal>PRIMARY KEY</literal>, and
      <literal>FOREIGN KEY</literal> constraints are not considered, but
      this might change in the future.
-->
《マッチ度[70.712909]》また、親テーブルの<literal>CHECK</literal>制約すべてについても、一致する制約が子テーブルに存在しなければなりません。
ただし、親テーブルにおいて継承不可と印付けされている（つまり<literal>ALTER TABLE ... ADD CONSTRAINT ... NO INHERIT</literal>付きで作成された）制約は除きます（これらは無視されます）。
一致する子テーブルの制約はすべて継承不可であってはなりません。
現時点では<literal>UNIQUE</literal>、<literal>PRIMARY KEY</literal>、<literal>FOREIGN KEY</literal>制約は無視されますが、将来変更されるかもしれません。
《機械翻訳》さらに、親のすべての<literal>CHECK</literal>および<literal>NOT NULL</literal>制約は、無視される非継承可能とマークされたもの<literal>ALTER TABLE ... ADD CONSTRAINT ... NO INHERIT</literal>で作成されたものを除き、子にも存在する必要があります。
一致するすべての子-テーブル制約は、非継承可能とマークできません。
現在、<literal>UNIQUE</literal>、<literal>PRIMARY KEY</literal>および<literal>FOREIGN KEY</literal>制約は考慮されませんが、将来変更される可能性があります。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="sql-altertable-desc-no-inherit">
    <term><literal>NO INHERIT <replaceable class="parameter">parent_table</replaceable></literal></term>
    <listitem>
     <para>
<!--
      This form removes the target table from the list of children of the
      specified parent table.
      Queries against the parent table will no longer include records drawn
      from the target table.
-->
この構文は、指定した親テーブルの子テーブル群から対象のテーブルを削除します。
親テーブルへの問い合わせでは、対象としたテーブルからのデータが含まれなくなります。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="sql-altertable-desc-of">
    <term><literal>OF <replaceable class="parameter">type_name</replaceable></literal></term>
    <listitem>
     <para>
<!--
      This form links the table to a composite type as though <command>CREATE
      TABLE OF</command> had formed it.  The table's list of column names and types
      must precisely match that of the composite type.  The table must
      not inherit from any other table.  These restrictions ensure
      that <command>CREATE TABLE OF</command> would permit an equivalent table
      definition.
-->
この構文は、<command>CREATE TABLE OF</command>で形成されたかのように、テーブルと複合型とを関連付けします。
テーブルの列名とその型のリストは、複合型のものと正確に一致していなければなりません。
テーブルはどのテーブルも継承していてはいけません。
これらの制限により<command>CREATE TABLE OF</command>により作成できるテーブル定義と同等になります。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="sql-altertable-desc-not-of">
    <term><literal>NOT OF</literal></term>
    <listitem>
     <para>
<!--
      This form dissociates a typed table from its type.
-->
この構文は型と型付けされたテーブルの関連を取り除きます。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="sql-altertable-desc-owner-to">
    <term><literal>OWNER TO</literal></term>
    <listitem>
     <para>
<!--
      This form changes the owner of the table, sequence, view, materialized view,
      or foreign table to the specified user.
-->
この構文を使用すると、テーブル、シーケンス、ビュー、マテリアライズドビュー、または外部テーブルの所有者を、指定したユーザに変更できます。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="sql-altertable-replica-identity">
    <term><literal>REPLICA IDENTITY</literal></term>
    <listitem>
     <para>
<!--
      This form changes the information which is written to the write-ahead log
      to identify rows which are updated or deleted.
      In most cases, the old value of each column is only logged if it differs
      from the new value; however, if the old value is stored externally, it is
      always logged regardless of whether it changed.
      This option has no effect except when logical replication is in use.
-->
この形式は、先行書き込みログ（WAL）に書き込まれる情報を変更して、更新または削除された行を識別します。
ほとんどの場合、各列の古い値は、新しい値と異なる場合にのみログに記録されます。
ただし、古い値が外部に保存されている場合は、変更されたかどうかに関係なく、常にログに記録されます。
このオプションは、論理レプリケーションが使用されている場合を除いて何の効果もありません。
     <variablelist>
      <varlistentry id="sql-altertable-replica-identity-default">
       <term><literal>DEFAULT</literal></term>
       <listitem>
        <para>
<!--
         Records the old values of the columns of the primary key.
         This is the default for non-system tables.
         When there is no primary key, the behavior is the same as <literal>NOTHING</literal>.
-->
《機械翻訳》主キーの列の古い値を記録します。
これは、システム以外の表のデフォルトです。
主キーがない場合、動作は<literal>NOTHING</literal>.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry id="sql-altertable-replica-identity-using-index">
       <term><literal>USING INDEX <replaceable class="parameter">index_name</replaceable></literal></term>
       <listitem>
        <para>
<!--
         Records the old values of the columns covered by the named index,
         that must be unique, not partial, not deferrable, and include only
         columns marked <literal>NOT NULL</literal>. If this index is
         dropped, the behavior is the same as <literal>NOTHING</literal>.
-->
指定されたインデックスによってカバーされる列の古い値を記録します。
これは、一意であり、部分的ではなく、遅延可能でなく、<literal>NOT NULL</literal>とマークされた列のみを含む必要があります。
このインデックスが削除された場合、動作は<literal>NOTHING</literal>と同じです。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry id="sql-altertable-replica-identity-full">
       <term><literal>FULL</literal></term>
       <listitem>
        <para>
<!--
         Records the old values of all columns in the row.
-->
行のすべての列の古い値を記録します。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry id="sql-altertable-replica-identity-nothing">
       <term><literal>NOTHING</literal></term>
       <listitem>
        <para>
<!--
         Records no information about the old row. This is the default for
         system tables.
-->
古い行に関する情報は記録されません。
これは、システムテーブルのデフォルトです。
        </para>
       </listitem>
      </varlistentry>
     </variablelist></para>
    </listitem>
   </varlistentry>

   <varlistentry id="sql-altertable-desc-rename">
    <term><literal>RENAME</literal></term>
    <listitem>
     <para>
<!--
      The <literal>RENAME</literal> forms change the name of a table
      (or an index, sequence, view, materialized view, or foreign table), the
      name of an individual column in a table, or the name of a constraint of
      the table.  When renaming a constraint that has an underlying index,
      the index is renamed as well.
      There is no effect on the stored data.
-->
<literal>RENAME</literal>構文を使用すると、テーブル（もしくは、インデックス、シーケンス、ビュー、マテリアライズドビュー、外部テーブル）の名前、テーブルの個々の列名、テーブルの制約名を変更できます。
元となるインデックスを持つ制約名を変更するとき、インデックス名も同様に変更されます。
格納されているデータへの影響はありません。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="sql-altertable-desc-set-schema">
    <term><literal>SET SCHEMA</literal></term>
    <listitem>
     <para>
<!--
      This form moves the table into another schema.  Associated indexes,
      constraints, and sequences owned by table columns are moved as well.
-->
この構文を使用して、テーブルを別のスキーマに移動することができます。
関連するインデックスや制約、テーブル列により所有されるシーケンスも同様に移動されます。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="sql-altertable-attach-partition">
    <term><literal>ATTACH PARTITION <replaceable class="parameter">partition_name</replaceable> { FOR VALUES <replaceable class="parameter">partition_bound_spec</replaceable> | DEFAULT }</literal></term>
    <listitem>
     <para>
<!--
      This form attaches an existing table (which might itself be partitioned)
      as a partition of the target table. The table can be attached
      as a partition for specific values using <literal>FOR VALUES</literal>
      or as a default partition by using <literal>DEFAULT</literal>.
      For each index in the target table, a corresponding
      one will be created in the attached table; or, if an equivalent
      index already exists, it will be attached to the target table's index,
      as if <command>ALTER INDEX ATTACH PARTITION</command> had been executed.
      Note that if the existing table is a foreign table, it is currently not
      allowed to attach the table as a partition of the target table if there
      are <literal>UNIQUE</literal> indexes on the target table.  (See also
      <xref linkend="sql-createforeigntable"/>.)  For each user-defined
      row-level trigger that exists in the target table, a corresponding one
      is created in the attached table.
-->
この構文は、既存のテーブル（それ自体がパーティションテーブルのこともあります）を対象テーブルのパーティションとして追加します。
テーブルは、<literal>FOR VALUES</literal>を使って指定の値のパーティションとして、あるいは、<literal>DEFAULT</literal>を使ってデフォルトパーティションとして追加できます。
対象テーブルの各インデックスについて、対応するインデックスが付加されるテーブルに作られます。
また、同等のインデックスが既にある場合には、そのインデックスが、<command>ALTER INDEX ATTACH PARTITION</command>が実行された場合と同様に、対象テーブルのインデックスに付加されます。
既存のテーブルが外部テーブルの場合、今のところ対象テーブルに<literal>UNIQUE</literal>インデックスがあるときにはテーブルを対象テーブルのパーティションとして追加することはできない点に注意してください（<xref linkend="sql-createforeigntable"/>も参照してください）。
対象テーブルにある各ユーザ定義の行レベルのトリガに対しては、対応するものが付加されるテーブルに作られます。
     </para>

     <para>
<!--
      A partition using <literal>FOR VALUES</literal> uses same syntax for
      <replaceable class="parameter">partition_bound_spec</replaceable> as
      <link linkend="sql-createtable"><command>CREATE TABLE</command></link>.
      The partition bound specification
      must correspond to the partitioning strategy and partition key of the
      target table.  The table to be attached must have all the same columns
      as the target table and no more; moreover, the column types must also
      match.  Also, it must have all the <literal>NOT NULL</literal> and
      <literal>CHECK</literal> constraints of the target table, not marked
      <literal>NO INHERIT</literal>.  Currently
      <literal>FOREIGN KEY</literal> constraints are not considered.
      <literal>UNIQUE</literal> and <literal>PRIMARY KEY</literal> constraints
      from the parent table will be created in the partition, if they don't
      already exist.
-->
<literal>FOR VALUES</literal>を使ったパーティションは<replaceable class="parameter">partition_bound_spec</replaceable>で<link linkend="sql-createtable"><command>CREATE TABLE</command></link>と同じ構文を使います。
パーティション境界の指定は、対象テーブルのパーティション戦略とパーティションキーと対応していなければなりません。
付加されるテーブルは、対象と全て同じ列を持ち、それ以上の列は持たず、列の型も一致していなければなりません。
また、対象テーブルにある全ての<literal>NOT NULL</literal>および<literal>CHECK</literal>制約を持たなければならず、<literal>NO INHERIT</literal>と印付けされていてはなりません。
今のところ、<literal>FOREIGN KEY</literal>制約は考慮されません。
親テーブルの<literal>UNIQUE</literal>および<literal>PRIMARY KEY</literal>制約は、既に在るのでなければ、パーティションに作られます。
     </para>

     <para>
<!--
      If the new partition is a regular table, a full table scan is performed
      to check that existing rows in the table do not violate the partition
      constraint. It is possible to avoid this scan by adding a valid
      <literal>CHECK</literal> constraint to the table that allows only
      rows satisfying the desired partition constraint before running this
      command. The <literal>CHECK</literal> constraint will be used to
      determine that the table need not be scanned to validate the partition
      constraint. This does not work, however, if any of the partition keys
      is an expression and the partition does not accept
      <literal>NULL</literal> values. If attaching a list partition that will
      not accept <literal>NULL</literal> values, also add a
      <literal>NOT NULL</literal> constraint to the partition key column,
      unless it's an expression.
-->
新しいパーティションが通常のテーブルの場合、テーブルに存在する行がパーティションの制約に違反しないことを確認するため、テーブルの全件スキャンが行われます。
このコマンドを実行するより前に、望まれるパーティションの制約を満たす行だけしか許さないような有効な<literal>CHECK</literal>制約をテーブルに追加すれば、この全件スキャンを避けることができます。
<literal>CHECK</literal>制約は、パーティションの制約を確認するためにテーブルをスキャンする必要がないか決めるために使われます。
しかし、パーティションキーに式が一つでもあり、パーティションが<literal>NULL</literal>値を受け付けないときは、この仕組みは機能しません。
<literal>NULL</literal>値を受け付けないリストパーティションに追加するときも、それが式でないなら、パーティションキーの列に<literal>NOT NULL</literal>制約を追加してください。
     </para>

     <para>
<!--
      If the new partition is a foreign table, nothing is done to verify
      that all the rows in the foreign table obey the partition constraint.
      (See the discussion in <xref linkend="sql-createforeigntable"/> about
      constraints on the foreign table.)
-->
新しいパーティションが外部テーブルの場合、外部テーブルのすべての行がパーティションの制約に従うかどうかの確認は何も行われません。
（外部テーブルの制約については<xref linkend="sql-createforeigntable"/>の説明を参照してください。）
     </para>

     <para>
<!--
      When a table has a default partition, defining a new partition changes
      the partition constraint for the default partition. The default
      partition can't contain any rows that would need to be moved to the new
      partition, and will be scanned to verify that none are present. This
      scan, like the scan of the new partition, can be avoided if an
      appropriate <literal>CHECK</literal> constraint is present. Also like
      the scan of the new partition, it is always skipped when the default
      partition is a foreign table.
-->
テーブルがデフォルトパーティションを持っている場合、新たなパーティションの定義はデフォルトパーティションに対するパーティション制約を変更します。
デフォルトパーティションは新パーティションに移動すべきいかなる行を含むことができず、そのような行が無いことを確認するためスキャンが行われます。
このスキャンは、新パーティションのスキャンと同様に、適切な<literal>CHECK</literal>制約があれば回避できます。
やはり、新パーティションのスキャンと同様に、デフォルトパーティションが外部テーブルであるときは、このスキャンは常に省略されます。
     </para>

     <para>
<!--
      Attaching a partition acquires a
      <literal>SHARE UPDATE EXCLUSIVE</literal> lock on the parent table,
      in addition to the <literal>ACCESS EXCLUSIVE</literal> locks on the table
      being attached and on the default partition (if any).
-->
パーティションの追加は、追加されるテーブルと（もしあれば）デフォルトパーティションでの<literal>ACCESS EXCLUSIVE</literal>ロックに加えて、親テーブルで<literal>SHARE UPDATE EXCLUSIVE</literal>ロックを取得します。
     </para>

     <para>
<!--
      Further locks must also be held on all sub-partitions if the table being
      attached is itself a partitioned table.  Likewise if the default
      partition is itself a partitioned table.  The locking of the
      sub-partitions can be avoided by adding a <literal>CHECK</literal>
      constraint as described in
      <xref linkend="ddl-partitioning-declarative-maintenance"/>.
-->
追加されるテーブル自体がパーティションテーブルである場合は、すべてのサブパーティションでさらにロックを保持する必要があります。
デフォルトパーティション自体がパーティションテーブルである場合も同様です。
<xref linkend="ddl-partitioning-declarative-maintenance"/>で説明されているように、サブパーティションのロックは<literal>CHECK</literal>制約を追加することで回避できます。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="sql-altertable-detach-partition">
    <term><literal>DETACH PARTITION <replaceable class="parameter">partition_name</replaceable> [ CONCURRENTLY | FINALIZE ]</literal></term>

    <listitem>
     <para>
<!--
      This form detaches the specified partition of the target table.  The detached
      partition continues to exist as a standalone table, but no longer has any
      ties to the table from which it was detached.  Any indexes that were
      attached to the target table's indexes are detached.  Any triggers that
      were created as clones of those in the target table are removed.
      <literal>SHARE</literal> lock is obtained on any tables that reference
      this partitioned table in foreign key constraints.
-->
この構文は、指定したパーティションを対象のテーブルから切り離します。
切り離されたパーティションは単独のテーブルとして存在し続けますが、切り離される前のテーブルとの紐付けはなくなります。
対象テーブルのインデックスに付加されていた全てのインデックスも切り離されます。
対象テーブルのものの複製として作られたトリガは削除されます。
<literal>SHARE</literal>ロックは、外部キー制約でこのパーティションテーブルを参照するすべてのテーブルで取得されます。
     </para>
     <para>
<!--
      If <literal>CONCURRENTLY</literal> is specified, it runs using a reduced
      lock level to avoid blocking other sessions that might be accessing the
      partitioned table.  In this mode, two transactions are used internally.
      During the first transaction, a <literal>SHARE UPDATE EXCLUSIVE</literal>
      lock is taken on both parent table and partition, and the partition is
      marked as undergoing detach; at that point, the transaction is committed
      and all other transactions using the partitioned table are waited for.
      Once all those transactions have completed, the second transaction
      acquires <literal>SHARE UPDATE EXCLUSIVE</literal> on the partitioned
      table and <literal>ACCESS EXCLUSIVE</literal> on the partition,
      and the detach process completes.  A <literal>CHECK</literal> constraint
      that duplicates the partition constraint is added to the partition.
      <literal>CONCURRENTLY</literal> cannot be run in a transaction block and
      is not allowed if the partitioned table contains a default partition.
-->
<literal>CONCURRENTLY</literal>が指定されている場合、パーティションテーブルにアクセスしている可能性のある他のセッションをブロックしないように、ロックレベルを下げて実行します。
このモードでは、2つのトランザクションが内部で使用されます。
最初のトランザクションでは、<literal>SHARE UPDATE EXCLUSIVE</literal>ロックが親テーブルとパーティションの両方で取得され、パーティションはデタッチ中としてマークされます。
その時点で、トランザクションはコミットされ、パーティションテーブルを使用する他のすべてのトランザクションは待機されます。
これらのトランザクションがすべて完了すると、2番目のトランザクションがパーティションテーブルの<literal>SHARE UPDATE EXCLUSIVE</literal>を取得し、パーティションで<literal>ACCESS EXCLUSIVE</literal>を取得し、デタッチプロセスが完了します。
パーティション制約と重複する<literal>CHECK</literal>制約がパーティションに追加されます。
<literal>CONCURRENTLY</literal>はトランザクションブロック内で実行することはできず、パーティションテーブルにデフォルトパーティションが含まれる場合は許可されません。
     </para>
     <para>
<!--
      If <literal>FINALIZE</literal> is specified, a previous
      <literal>DETACH CONCURRENTLY</literal> invocation that was canceled or
      interrupted is completed.
      At most one partition in a partitioned table can be pending detach at
      a time.
-->
<literal>FINALIZE</literal>が指定されている場合、キャンセルまたは中断された以前の<literal>DETACH CONCURRENTLY</literal>の呼び出しは完了します。
パーティションテーブル内で多くても1つのパーティションが一度にデタッチを保留できます。
     </para>
    </listitem>
   </varlistentry>

  </variablelist>
  </para>

  <para>
<!--
   All the forms of <command>ALTER TABLE</command> that act on a single table,
   except <literal>RENAME</literal>, <literal>SET SCHEMA</literal>,
   <literal>ATTACH PARTITION</literal>, and
   <literal>DETACH PARTITION</literal> can be combined into
   a list of multiple alterations to be applied together.  For example, it
   is possible to add several columns and/or alter the type of several
   columns in a single command.  This is particularly useful with large
   tables, since only one pass over the table need be made.
-->
《マッチ度[91.035857]》<literal>RENAME</literal>、<literal>SET SCHEMA</literal>、<literal>ATTACH PARTITION</literal>、<literal>DETACH PARTITION</literal>は、複数の変更リストに結合して、まとめて処理することができますが、それらを除き、ALTER TABLEのすべての構文は１つだけのテーブルに対して作用します。
例えば、複数の列の追加、型の変更を単一のコマンドで実行することができます。
これは特に巨大なテーブルでは便利です。変更のために必要なテーブル全体のスキャンが1回で済むからです。
  </para>

  <para>
<!--
   You must own the table to use <command>ALTER TABLE</command>.
   To change the schema or tablespace of a table, you must also have
   <literal>CREATE</literal> privilege on the new schema or tablespace.
   To add the table as a new child of a parent table, you must own the parent
   table as well.  Also, to attach a table as a new partition of the table,
   you must own the table being attached.
   To alter the owner, you must be able to <literal>SET ROLE</literal> to the
   new owning role, and that role must have <literal>CREATE</literal>
   privilege on the table's schema.
   (These restrictions enforce that altering the owner
   doesn't do anything you couldn't do by dropping and recreating the table.
   However, a superuser can alter ownership of any table anyway.)
   To add a column or alter a column type or use the <literal>OF</literal>
   clause, you must also have <literal>USAGE</literal> privilege on the data
   type.
-->
<command>ALTER TABLE</command>コマンドを使用するには、変更するテーブルを所有している必要があります。
テーブルのスキーマあるいはテーブル空間を変更するには、新しいスキーマあるいはテーブル空間における<literal>CREATE</literal>権限も持っていなければなりません。
テーブルを親テーブルの新しい子テーブルとして追加するには、親テーブルも所有している必要があります。
またテーブルをテーブルのパーティションとして追加する場合、追加されるテーブルを所有している必要があります。
所有者を変更するには、新しい所有者ロールに対して<literal>SET ROLE</literal>ができなければなりません。また、そのロールはテーブルのスキーマにおいて<literal>CREATE</literal>権限を持たなければなりません。
（この制限により、テーブルの削除と再作成を行ってもできないことが、所有者の変更によってもできないようにしています。
ただし、スーパーユーザはすべてのテーブルの所有者を変更することができます。）
列の追加、列の型の変更、<literal>OF</literal>句の使用を行うためには、データ型に対する<literal>USAGE</literal>権限を持たなければなりません。
  </para>
 </refsect1>

 <refsect1>
<!--
  <title>Parameters</title>
-->
  <title>パラメータ</title>

    <variablelist>

     <varlistentry id="sql-altertable-parms-if-exists">
      <term><literal>IF EXISTS</literal></term>
      <listitem>
       <para>
<!--
        Do not throw an error if the table does not exist. A notice is issued
        in this case.
-->
テーブルが存在しない場合でもエラーとしません。
この場合は注意メッセージが発行されます。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="sql-altertable-parms-name">
      <term><replaceable class="parameter">name</replaceable></term>
      <listitem>
       <para>
<!--
        The name (optionally schema-qualified) of an existing table to
        alter. If <literal>ONLY</literal> is specified before the table name, only
        that table is altered. If <literal>ONLY</literal> is not specified, the table
        and all its descendant tables (if any) are altered.  Optionally,
        <literal>*</literal> can be specified after the table name to explicitly
        indicate that descendant tables are included.
-->
変更対象となる既存のテーブルの名前です（スキーマ修飾名も可）。
テーブル名の前に<literal>ONLY</literal>が指定された場合、そのテーブルのみが変更されます。
<literal>ONLY</literal>が指定されていない場合、そのテーブルおよび（もしあれば）そのテーブルを継承する全てのテーブルが更新されます。
オプションで、テーブル名の後に<literal>*</literal>を指定することで、明示的に継承するテーブルも含まれることを示すことができます。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="sql-altertable-parms-column-name">
      <term><replaceable class="parameter">column_name</replaceable></term>
      <listitem>
       <para>
<!--
        Name of a new or existing column.
-->
新規または既存の列の名前です。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="sql-altertable-parms-new-column-name">
      <term><replaceable class="parameter">new_column_name</replaceable></term>
      <listitem>
       <para>
<!--
        New name for an existing column.
-->
既存の列の新しい名前です。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="sql-altertable-parms-new-name">
      <term><replaceable class="parameter">new_name</replaceable></term>
      <listitem>
       <para>
<!--
        New name for the table.
-->
テーブルの新しい名前です。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="sql-altertable-parms-data-type">
      <term><replaceable class="parameter">data_type</replaceable></term>
      <listitem>
       <para>
<!--
        Data type of the new column, or new data type for an existing
        column.
-->
新しい列のデータ型、もしくは既存の列に対する新しいデータ型です。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="sql-altertable-parms-table-constraint">
      <term><replaceable class="parameter">table_constraint</replaceable></term>
      <listitem>
       <para>
<!--
        New table constraint for the table.
-->
テーブルの新しいテーブル制約です。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="sql-altertable-parms-constraint-name">
      <term><replaceable class="parameter">constraint_name</replaceable></term>
      <listitem>
       <para>
<!--
        Name of a new or existing constraint.
-->
新しい、あるいは既存の制約の名前です。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="sql-altertable-parms-cascade">
      <term><literal>CASCADE</literal></term>
      <listitem>
       <para>
<!--
        Automatically drop objects that depend on the dropped column
        or constraint (for example, views referencing the column),
        and in turn all objects that depend on those objects
        (see <xref linkend="ddl-depend"/>).
-->
削除された列や制約に依存しているオブジェクト（例えば、削除された列を参照しているビューなど）を自動的に削除し、さらにそれらのオブジェクトに依存するすべてのオブジェクトも削除します（<xref linkend="ddl-depend"/>参照）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="sql-altertable-parms-restrict">
      <term><literal>RESTRICT</literal></term>
      <listitem>
       <para>
<!--
        Refuse to drop the column or constraint if there are any dependent
        objects. This is the default behavior.
-->
依存しているオブジェクトがある場合、列または制約の削除要求を拒否します。
これがデフォルトの動作です。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="sql-altertable-parms-trigger-name">
      <term><replaceable class="parameter">trigger_name</replaceable></term>
      <listitem>
       <para>
<!--
        Name of a single trigger to disable or enable.
-->
有効または無効にする単一のトリガの名前です。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="sql-altertable-parms-all">
      <term><literal>ALL</literal></term>
      <listitem>
       <para>
<!--
        Disable or enable all triggers belonging to the table.
        (This requires superuser privilege if any of the triggers are
        internally generated constraint triggers, such as those that are used
        to implement foreign key constraints or deferrable uniqueness and
        exclusion constraints.)
-->
テーブルに属するすべてのトリガを有効または無効にします。
（外部キー制約、遅延可能な一意性および排他制約を実装するために使用される、内部向けに生成される制約トリガが含まれる場合、スーパーユーザ権限が必要です。）
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="sql-altertable-parms-user">
      <term><literal>USER</literal></term>
      <listitem>
       <para>
<!--
        Disable or enable all triggers belonging to the table except for
        internally generated constraint triggers, such as those that are used
        to implement foreign key constraints or deferrable uniqueness and
        exclusion constraints.
-->
外部キー制約、遅延可能な一意性および排他制約を実装するために使用される、内部向けに生成されるトリガを除く、テーブルに属するトリガすべてを有効または無効にします。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="sql-altertable-parms-index-name">
      <term><replaceable class="parameter">index_name</replaceable></term>
      <listitem>
       <para>
<!--
        The name of an existing index.
-->
既存のインデックスの名前です。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="sql-altertable-parms-storage-parameter">
      <term><replaceable class="parameter">storage_parameter</replaceable></term>
      <listitem>
       <para>
<!--
        The name of a table storage parameter.
-->
テーブルの格納パラメータの名前です。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="sql-altertable-parms-value">
      <term><replaceable class="parameter">value</replaceable></term>
      <listitem>
       <para>
<!--
        The new value for a table storage parameter.
        This might be a number or a word depending on the parameter.
-->
テーブルの格納パラメータの新しい値です。
パラメータによりこれは数値となることも文字列となることもあります。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="sql-altertable-parms-parent-table">
      <term><replaceable class="parameter">parent_table</replaceable></term>
      <listitem>
       <para>
<!--
        A parent table to associate or de-associate with this table.
-->
このテーブルに関連付ける、または、このテーブルから関連付けを取り除く親テーブルです。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="sql-altertable-parms-new-owner">
      <term><replaceable class="parameter">new_owner</replaceable></term>
      <listitem>
       <para>
<!--
        The user name of the new owner of the table.
-->
テーブルの新しい所有者のユーザ名です。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="sql-altertable-parms-new-access-method">
      <term><replaceable class="parameter">new_access_method</replaceable></term>
      <listitem>
       <para>
<!--
        The name of the access method to which the table will be converted.
-->
テーブルを変換する先のアクセスメソッドの名前です。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="sql-altertable-parms-new-tablespace">
      <term><replaceable class="parameter">new_tablespace</replaceable></term>
      <listitem>
       <para>
<!--
        The name of the tablespace to which the table will be moved.
-->
テーブルを移動する先のテーブル空間の名前です。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="sql-altertable-parms-new-schema">
      <term><replaceable class="parameter">new_schema</replaceable></term>
      <listitem>
       <para>
<!--
        The name of the schema to which the table will be moved.
-->
テーブルを移動する先のスキーマの名前です。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="sql-altertable-parms-partition-name">
      <term><replaceable class="parameter">partition_name</replaceable></term>
      <listitem>
       <para>
<!--
        The name of the table to attach as a new partition or to detach from this table.
-->
新しいパーティションとして追加する、またはテーブルから切り離すテーブルの名前です。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="sql-altertable-parms-partition-bound-spec">
      <term><replaceable class="parameter">partition_bound_spec</replaceable></term>
      <listitem>
       <para>
<!--
        The partition bound specification for a new partition.  Refer to
        <xref linkend="sql-createtable"/> for more details on the syntax of the same.
-->
新しいパーティションのパーティション境界の指定です。
その構文の詳細については<xref linkend="sql-createtable"/>を参照してください。
       </para>
      </listitem>
     </varlistentry>

    </variablelist>
 </refsect1>

<!--
 <refsect1 id="sql-altertable-notes" xreflabel="Notes">
-->
 <refsect1 id="sql-altertable-notes" xreflabel="注釈">
<!--
  <title>Notes</title>
-->
  <title>注釈</title>

   <para>
<!--
    The key word <literal>COLUMN</literal> is noise and can be omitted.
-->
<literal>COLUMN</literal>キーワードには意味がなく、省略可能です。
   </para>

   <para>
<!--
    When a column is added with <literal>ADD COLUMN</literal> and a
    non-volatile <literal>DEFAULT</literal> is specified, the default value is
    evaluated at the time of the statement and the result stored in the
    table's metadata, where it will be returned when any existing rows are
    accessed.  The value will be only applied when the table is rewritten,
    making the <command>ALTER TABLE</command> very fast even on large tables.
    If no column constraints are specified, NULL is used as the
    <literal>DEFAULT</literal>.  In neither case is a rewrite of the table
    required.
-->
《マッチ度[59.001783]》<literal>ADD COLUMN</literal>で列が追加され、非変動性の<literal>DEFAULT</literal>が指定されたときには、デフォルトは宣言時に評価されてテーブルのメタデータに格納された結果です。
この値は全ての既存行の列に使われます。
<literal>DEFAULT</literal>が指定されなかった場合にはNULLが使われます。
どちらの場合もテーブルを書き直す必要はありません。
《機械翻訳》カラムに<literal>ADD COLUMN</literal>を指定し、かつ不揮発性<literal>DEFAULT</literal>を指定すると、デフォルト値はステートメント時に評価され、結果はテーブルのメタデータに格納されます。
既存の行がアクセスされると結果が返されます。
値はテーブルが書き換えられた時にのみ適用され、ラージテーブルに対しても<command>ALTER TABLE</command>非常に高速になります。
カラム制約が指定されていない場合、NULLは<literal>DEFAULT</literal>として使用されます。
どちらのケースでもテーブルの書き換えは必要ありません。
   </para>

   <para>
<!--
    Adding a column with a volatile <literal>DEFAULT</literal>
    (e.g., <function>clock_timestamp()</function>), a stored generated column,
    an identity column, or a column with a domain data type that has
    constraints will cause the entire table and its indexes to be rewritten.
    Adding a virtual generated column never requires a rewrite.
-->
《機械翻訳》volatile<literal>カラム</literal>を持つデフォルト<function>clock_timestamp()</function>例:、stored generatedカラム、identityカラム、制約を持つドメインデータタイプを持つカラムを追加すると、テーブル全体とそのインデックスが書き換えられます。
virtual generatedカラムを追加しても、書き換えられることはありません。
   </para>

   <para>
<!--
    Changing the type of an existing column will normally cause the entire table
    and its indexes to be rewritten.
    As an exception, when changing the type of an existing column,
    if the <literal>USING</literal> clause does not change the column
    contents and the old type is either binary coercible to the new type
    or an unconstrained domain over the new type, a table rewrite is not
    needed.  However, indexes will still be rebuilt unless the system
    can verify that the new index would be logically equivalent to the
    existing one.  For example, if the collation for a column has been
    changed, an index rebuild is required because the new sort
    order might be different.  However, in the absence of a collation
    change, a column can be changed from <type>text</type> to
    <type>varchar</type> (or vice versa) without rebuilding the indexes
    because these data types sort identically.
-->
《マッチ度[64.821223]》変動性の<literal>DEFAULT</literal>句を持つ列を追加したり、既存の列の型を変更するには、テーブルとインデックス全体の書き換えが必要になります。
例外として、既存列の型を変更するとき、<literal>USING</literal>句が列の内容を変更せず、かつ、古い型が新しい型とバイナリ変換可能であるか新しい型全体に対する制約のないドメインである場合、テーブルの書き換えは必要ありません。
しかし、新しいインデックスが既存のものと論理的に等しいとシステムが確認できないのであれば、インデックスは常に再構築しなければなりません。
例えば、列の照合順序が変更された場合には、新しいソート順が異なるかもしれませんので、インデックスの再構築は常に必要です。
しかし、照合順序の変更がなければ、インデックスの再構築なしで列を<type>text</type>から<type>varchar</type>へ(またはその逆)と変更できます。データ型のソートが同一だからです。
テーブルが巨大な場合、テーブル、インデックスまたはその両方の再構築には非常に時間がかかる可能性があります。
また、一時的に2倍のディスク容量が必要とされます。
《機械翻訳》既存のタイプのカラムを変更すると、通常、テーブル全体とそのインデックスが書き換えられます。
例外として、既存のカラムのタイプを変更するときに、<literal>USING</literal>句がカラムの内容を変更せず、古いタイプが新しいタイプへのバイナリ強制互換か、新しいタイプへの制約のないドメインのいずれかである場合、テーブルの書き直しは必要ありません。
ただし、システムが新しいインデックスが既存のと論理的に同等であることを確認できない限り、インデックスは再構築されます。
例の場合、カラムの照合順序が変更された場合、新しいソートオーダーが異なる可能性があるため、インデックスの再構築が必要です。
ただし、照合順序の変更がない場合は、インデックスを再構築しなくてもカラムを<type>text</type>から<type>varchar</type>に（またはその逆）に変更できます。
これは、データの種類がと同じであるためです。
ソート
   </para>

   <para>
<!--
    Table and/or index
    rebuilds may take a significant amount of time for a large table,
    and will temporarily require as much as double the disk space.
-->
《機械翻訳》テーブルおよび/またはインデックスの復旧には、ラージテーブルではかなりの時間がかかる場合があり、一時的にはディスクスペースの2倍の時間が必要になります。
   </para>

   <para>
<!--
    Adding a <literal>CHECK</literal> or <literal>NOT NULL</literal>
    constraint requires scanning the table to verify that existing rows meet the
    constraint, but does not require a table rewrite.  If a <literal>CHECK</literal>
    constraint is added as <literal>NOT ENFORCED</literal>, no verification will
    be performed.
-->
《マッチ度[57.371795]》<literal>CHECK</literal>あるいは<literal>NOT NULL</literal>制約を追加する時は、既存の行が制約に従うかどうかを検証するためにテーブルのスキャンが必要になりますが、テーブルの書き換えは必要ありません。
《機械翻訳》<literal>CHECK</literal>または<literal>NOT NULL</literal>制約を追加するには、テーブルをスキャンして既存の行が制約を満たしていることを確認する必要がありますが、テーブルの書き換えは必要ありません。
<literal>CHECK</literal>制約が<literal>NOT ENFORCED</literal>として追加された場合、確認は実行されません。
   </para>

   <para>
<!--
    Similarly, when attaching a new partition it may be scanned to verify that
    existing rows meet the partition constraint.
-->
同様に、新しいパーティションを追加するときは、既存の行がパーティションの制約を満たすかどうかを確認するため、テーブルがスキャンされるかもしれません。
   </para>

   <para>
<!--
    The main reason for providing the option to specify multiple changes
    in a single <command>ALTER TABLE</command> is that multiple table scans or
    rewrites can thereby be combined into a single pass over the table.
-->
単一の<command>ALTER TABLE</command>内に複数の変更を指定できるオプションを提供する主な理由は、複数のテーブルスキャンや書き換えを1回のテーブルスキャンにまとめることができるようにすることです。
   </para>

   <para>
<!--
    Scanning a large table to verify new foreign-key, check, or not-null constraints
    can take a long time, and other updates to the table are locked out
    until the <command>ALTER TABLE ADD CONSTRAINT</command> command is
    committed.  The main purpose of the <literal>NOT VALID</literal>
    constraint option is to reduce the impact of adding a constraint on
    concurrent updates.  With <literal>NOT VALID</literal>,
    the <command>ADD CONSTRAINT</command> command does not scan the table
    and can be committed immediately.  After that, a <literal>VALIDATE
    CONSTRAINT</literal> command can be issued to verify that existing rows
    satisfy the constraint.  The validation step does not need to lock out
    concurrent updates, since it knows that other transactions will be
    enforcing the constraint for rows that they insert or update; only
    pre-existing rows need to be checked.  Hence, validation acquires only
    a <literal>SHARE UPDATE EXCLUSIVE</literal> lock on the table being
    altered.  (If the constraint is a foreign key then a <literal>ROW
    SHARE</literal> lock is also required on the table referenced by the
    constraint.)  In addition to improving concurrency, it can be useful to
    use <literal>NOT VALID</literal> and <literal>VALIDATE
    CONSTRAINT</literal> in cases where the table is known to contain
    pre-existing violations.  Once the constraint is in place, no new
    violations can be inserted, and the existing problems can be corrected
    at leisure until <literal>VALIDATE CONSTRAINT</literal> finally
    succeeds.
-->
《マッチ度[92.002688]》新しい外部キーや検査制約を検証するために大きなテーブルをスキャンするのは長い時間が掛かる可能性があり、<command>ALTER TABLE ADD CONSTRAINT</command>コマンドがコミットされるまで、そのテーブルのその他の更新は締め出されます。
<literal>NOT VALID</literal>制約オプションの主な目的は、同時実行中の更新に制約を追加する影響を減らすことです。
<literal>NOT VALID</literal>を付ければ、<command>ADD CONSTRAINT</command>コマンドはテーブルをスキャンせず、すぐにコミットされます。
その後で、<literal>VALIDATE CONSTRAINT</literal>コマンドを発行して、既存の行が制約を満たすか検証できます。
他のトランザクションが挿入したり更新したりする行に対しては制約が強制されていることは分かっていますので、この検証操作では同時実行中の更新を締め出す必要はありません。既に存在する行だけ確認する必要があります。
それゆえ、検証には変更するテーブルの<literal>SHARE UPDATE EXCLUSIVE</literal>ロックのみが必要です。
(制約が外部キーなら、制約が参照するテーブルの<literal>ROW SHARE</literal>ロックも必要です。)
同時実行性をさらに向上させるため、テーブルに既に制約違反が存在することを知っている場合に<literal>NOT VALID</literal>と<literal>VALIDATE CONSTRAINT</literal>を使うことは有用かもしれません。
一度制約が設定されれば、新しい違反は挿入されることはありませんし、既存の問題は、<literal>VALIDATE CONSTRAINT</literal>を最終的に成功するまで使って、余裕のある時に修正できます。
   </para>

   <para>
<!--
    The <literal>DROP COLUMN</literal> form does not physically remove
    the column, but simply makes it invisible to SQL operations.  Subsequent
    insert and update operations in the table will store a null value for the
    column. Thus, dropping a column is quick but it will not immediately
    reduce the on-disk size of your table, as the space occupied
    by the dropped column is not reclaimed.  The space will be
    reclaimed over time as existing rows are updated.
-->
<literal>DROP COLUMN</literal>構文は、列を物理的には削除せず、SQLの操作に対して不可視にします。
このコマンドを実行した後、テーブルに挿入または更新が行われると、削除した列にはNULLが格納されます。
したがって、列の削除は短時間で行えます。
しかし、削除された列が占めていた領域がまだ回収されていないため、テーブルのディスク上のサイズはすぐには小さくなりません。
この領域は、その後既存の行が更新されるにつれて回収されます。
   </para>

   <para>
<!--
    To force immediate reclamation of space occupied by a dropped column,
    you can execute one of the forms of <command>ALTER TABLE</command> that
    performs a rewrite of the whole table.  This results in reconstructing
    each row with the dropped column replaced by a null value.
-->
削除した列が占有していたスペースを即座に再利用できるようにするには、テーブル全体を書き換える構文の<command>ALTER TABLE</command>を使用することができます。
この結果、各行の削除される列がNULL値で再構成されます。
   </para>

   <para>
<!--
    The rewriting forms of <command>ALTER TABLE</command> are not MVCC-safe.
    After a table rewrite, the table will appear empty to concurrent
    transactions, if they are using a snapshot taken before the rewrite
    occurred.  See <xref linkend="mvcc-caveats"/> for more details.
-->
テーブルを書き換える構文の<command>ALTER TABLE</command>はMVCC的に安全ではありません。
同時実行中のトランザクションが、テーブル書き換えが発生する前に取得したスナップショットを使っている場合、テーブルの書き換え後はそのトランザクションにはテーブルが空であるように見えます。
詳しくは<xref linkend="mvcc-caveats"/>を参照して下さい。
   </para>

   <para>
<!--
    The <literal>USING</literal> option of <literal>SET DATA TYPE</literal> can actually
    specify any expression involving the old values of the row; that is, it
    can refer to other columns as well as the one being converted.  This allows
    very general conversions to be done with the <literal>SET DATA TYPE</literal>
    syntax.  Because of this flexibility, the <literal>USING</literal>
    expression is not applied to the column's default value (if any); the
    result might not be a constant expression as required for a default.
    This means that when there is no implicit or assignment cast from old to
    new type, <literal>SET DATA TYPE</literal> might fail to convert the default even
    though a <literal>USING</literal> clause is supplied.  In such cases,
    drop the default with <literal>DROP DEFAULT</literal>, perform the <literal>ALTER
    TYPE</literal>, and then use <literal>SET DEFAULT</literal> to add a suitable new
    default.  Similar considerations apply to indexes and constraints involving
    the column.
-->
<literal>SET DATA TYPE</literal>の<literal>USING</literal>オプションでは、その行の古い値を含め、どのような式でも指定できます。
つまり、変換対象の列と同様に、その他の列も参照することができます。
そのため、一般的な変換を<literal>SET DATA TYPE</literal>構文で行うことができます。
この柔軟性のため、<literal>USING</literal>式は列のデフォルト値には（仮に存在していても）適用されません。
結果が定数式にならない可能性があるためです（デフォルト値は定数式でなければいけません）。
したがって、古い型から新しい型への暗黙キャストや代入キャストが存在しない場合、<literal>USING</literal>句が指定されていても、<literal>SET DATA TYPE</literal>がデフォルト値の変換に失敗する可能性があります。
この場合は、<literal>DROP DEFAULT</literal>でデフォルト値を削除し、<literal>ALTER TYPE</literal>を実行した後で、<literal>SET DEFAULT</literal>を使用して再度適切なデフォルト値を指定してください。
変更対象の列を含むインデックスと制約も同様の配慮が必要です。
   </para>

   <para>
<!--
    If a table has any descendant tables, it is not permitted to add,
    rename, or change the type of a column in the parent table without doing
    the same to the descendants.  This ensures that the descendants always
    have columns matching the parent.  Similarly, a <literal>CHECK</literal>
    constraint cannot be renamed in the parent without also renaming it in
    all descendants, so that <literal>CHECK</literal> constraints also match
    between the parent and its descendants.  (That restriction does not apply
    to index-based constraints, however.)
    Also, because selecting from the parent also selects from its descendants,
    a constraint on the parent cannot be marked valid unless it is also marked
    valid for those descendants.  In all of these cases, <command>ALTER TABLE
    ONLY</command> will be rejected.
-->
そのテーブルを継承するテーブルがある場合、子テーブルに同じ処理を実行しなければ、親テーブルに対する列の追加、列の名前、列の型の変更を実行することはできません。
この制限により、子テーブルの列が常に親テーブルと一致していることが保証されます。
同様に、すべての子テーブルで<literal>CHECK</literal>制約の名前を変更し、それが親と子の間で一致するようにしなければ、親テーブルの<literal>CHECK</literal>制約の名前を変更することはできません。
（しかし、この制限はインデックスの基づく制約にはあらわれません。）
また、親テーブルからSELECTすると、その子テーブルからもSELECTすることになるため、親テーブルの制約は、それが子テーブルでも有効であると印を付けられるまで、有効であると印を付けられません。
これらのすべての場合において、<command>ALTER TABLE ONLY</command>は受け付けられません。
   </para>

   <para>
<!--
    A recursive <literal>DROP COLUMN</literal> operation will remove a
    descendant table's column only if the descendant does not inherit
    that column from any other parents and never had an independent
    definition of the column.  A nonrecursive <literal>DROP
    COLUMN</literal> (i.e., <command>ALTER TABLE ONLY ... DROP
    COLUMN</command>) never removes any descendant columns, but
    instead marks them as independently defined rather than inherited.
    A nonrecursive <literal>DROP COLUMN</literal> command will fail for a
    partitioned table, because all partitions of a table must have the same
    columns as the partitioning root.
-->
再帰的な<literal>DROP COLUMN</literal>操作では、子テーブルが他の親テーブルからその列を継承しておらず、かつ、その列について独立した定義を持っていない場合のみ、その子テーブルの列を削除します。
再帰的でない<literal>DROP COLUMN</literal>（つまり、<command>ALTER TABLE ONLY ... DROP COLUMN</command>）操作では、継承された列は削除されません。
削除する代わりに、その列は継承されておらず独立して定義されているという印を付けます。
再帰的でない<literal>DROP COLUMN</literal>コマンドは、パーティションテーブルでは失敗します。
テーブルのすべてのパーティションは、パーティションの最上位と同じ列を持っていなければならないからです。
   </para>

   <para>
<!--
    The actions for identity columns (<literal>ADD
    GENERATED</literal>, <literal>SET</literal> etc., <literal>DROP
    IDENTITY</literal>), as well as the actions
    <literal>CLUSTER</literal>, <literal>OWNER</literal>,
    and <literal>TABLESPACE</literal> never recurse to descendant tables;
    that is, they always act as though <literal>ONLY</literal> were specified.
    Actions affecting trigger states recurse to partitions of partitioned
    tables (unless <literal>ONLY</literal> is specified), but never to
    traditional-inheritance descendants.
    Adding a constraint recurses only for <literal>CHECK</literal> constraints
    that are not marked <literal>NO INHERIT</literal>.
-->
識別列についての操作（<literal>ADD GENERATED</literal>、<literal>SET</literal>、<literal>DROP IDENTITY</literal>など）および<literal>CLUSTER</literal>、<literal>OWNER</literal>および<literal>TABLESPACE</literal>の操作は子テーブルに再帰的に伝わりません。
つまり、常に<literal>ONLY</literal>が指定されているかのように動作します。
トリガの状態に影響を与える操作は、(<literal>ONLY</literal>が指定されていない限り)パーティション化されたテーブルのパーティションに再帰的に伝わりますが、従来の継承の子孫には再帰的に伝わりません。
制約の追加は、<literal>NO INHERIT</literal>印がない<literal>CHECK</literal>制約に関してのみ再帰的に伝わります。
   </para>

   <para>
<!--
    Changing any part of a system catalog table is not permitted.
-->
システムカタログテーブルについては、いかなる部分の変更も許可されていません。
   </para>

   <para>
<!--
    Refer to <xref linkend="sql-createtable"/> for a further description of valid
    parameters. <xref linkend="ddl"/> has further information on
    inheritance.
-->
有効なパラメータの詳しい説明は<xref linkend="sql-createtable"/>を参照してください。
<xref linkend="ddl"/>に、継承に関するさらに詳しい情報があります。
   </para>
 </refsect1>

 <refsect1>
<!--
  <title>Examples</title>
-->
  <title>例</title>

  <para>
<!--
   To add a column of type <type>varchar</type> to a table:
-->
<type>varchar</type>型の列をテーブルに追加します。
<programlisting>
ALTER TABLE distributors ADD COLUMN address varchar(30);
</programlisting>
<!--
   That will cause all existing rows in the table to be filled with null
   values for the new column.
-->
これはテーブルの既存の行すべてで、新しい列をNULL値で埋めることになります。
  </para>

  <para>
<!--
   To add a column with a non-null default:
-->
デフォルトが非NULLの列を追加します。
<programlisting>
ALTER TABLE measurements
  ADD COLUMN mtime timestamp with time zone DEFAULT now();
</programlisting>
<!--
   Existing rows will be filled with the current time as the value of the
   new column, and then new rows will receive the time of their insertion.
-->
既存の行では、新しい列の値として現在時刻が入ります。また、新しい行では挿入時刻を受け取ります。
  </para>

  <para>
<!--
   To add a column and fill it with a value different from the default to
   be used later:
-->
列を追加して、後で使われるデフォルトとは異なる値で埋めます。
<programlisting>
ALTER TABLE transactions
  ADD COLUMN status varchar(30) DEFAULT 'old',
  ALTER COLUMN status SET default 'current';
</programlisting>
<!--
   Existing rows will be filled with <literal>old</literal>, but then
   the default for subsequent commands will be <literal>current</literal>.
   The effects are the same as if the two sub-commands had been issued
   in separate <command>ALTER TABLE</command> commands.
-->
既存の行は<literal>old</literal>で埋められますが、後続のコマンドに対するデフォルトは<literal>current</literal>になります。
別々の<command>ALTER TABLE</command>コマンドで2つの副コマンドを発行する場合と、効果は同じです。
  </para>

  <para>
<!--
   To drop a column from a table:
-->
テーブルから列を削除します。
<programlisting>
ALTER TABLE distributors DROP COLUMN address RESTRICT;
</programlisting>
  </para>

  <para>
<!--
   To change the types of two existing columns in one operation:
-->
1つの操作で既存の2つの列の型を変更します。
<programlisting>
ALTER TABLE distributors
    ALTER COLUMN address TYPE varchar(80),
    ALTER COLUMN name TYPE varchar(100);
</programlisting>
  </para>

  <para>
<!--
   To change an integer column containing Unix timestamps to <type>timestamp
   with time zone</type> via a <literal>USING</literal> clause:
-->
<literal>USING</literal>句を使用して、Unixタイムスタンプを持つinteger型の列を<type>timestamp with time zone</type>に変更します。
<programlisting>
ALTER TABLE foo
    ALTER COLUMN foo_timestamp SET DATA TYPE timestamp with time zone
    USING
        timestamp with time zone 'epoch' + foo_timestamp * interval '1 second';
</programlisting>
  </para>

  <para>
<!--
   The same, when the column has a default expression that won't automatically
   cast to the new data type:
-->
上と同じことをします。
ただし、その列は、自動的に新しいデータ型にキャストされないデフォルト式を持つ場合についてです。
<programlisting>
ALTER TABLE foo
    ALTER COLUMN foo_timestamp DROP DEFAULT,
    ALTER COLUMN foo_timestamp TYPE timestamp with time zone
    USING
        timestamp with time zone 'epoch' + foo_timestamp * interval '1 second',
    ALTER COLUMN foo_timestamp SET DEFAULT now();
</programlisting>
  </para>

  <para>
<!--
   To rename an existing column:
-->
既存の列の名前を変更します。
<programlisting>
ALTER TABLE distributors RENAME COLUMN address TO city;
</programlisting>
  </para>

  <para>
<!--
   To rename an existing table:
-->
既存のテーブルの名前を変更します。
<programlisting>
ALTER TABLE distributors RENAME TO suppliers;
</programlisting>
  </para>

  <para>
<!--
   To rename an existing constraint:
-->
既存の制約の名前を変更します。
<programlisting>
ALTER TABLE distributors RENAME CONSTRAINT zipchk TO zip_check;
</programlisting>
  </para>

  <para>
<!--
   To add a not-null constraint to a column:
-->
列に非NULL制約を付与します。
<programlisting>
ALTER TABLE distributors ALTER COLUMN street SET NOT NULL;
</programlisting>
<!--
   To remove a not-null constraint from a column:
-->
列から非NULL制約を削除します。
<programlisting>
ALTER TABLE distributors ALTER COLUMN street DROP NOT NULL;
</programlisting>
  </para>

  <para>
<!--
   To add a check constraint to a table and all its children:
-->
テーブルとそのすべての子テーブルにCHECK制約を付与します。
<programlisting>
ALTER TABLE distributors ADD CONSTRAINT zipchk CHECK (char_length(zipcode) = 5);
</programlisting>
  </para>

  <para>
<!--
   To add a check constraint only to a table and not to its children:
-->
そのテーブルのみに適用され、その子テーブルには適用されない検査制約を追加します。
<programlisting>
ALTER TABLE distributors ADD CONSTRAINT zipchk CHECK (char_length(zipcode) = 5) NO INHERIT;
</programlisting>
<!--
   (The check constraint will not be inherited by future children, either.)
-->
（この検査制約はこの後作成される子テーブルにも継承されません。）
  </para>

  <para>
<!--
   To remove a check constraint from a table and all its children:
-->
テーブルとそのすべての子テーブルからCHECK制約を削除します。
<programlisting>
ALTER TABLE distributors DROP CONSTRAINT zipchk;
</programlisting>
  </para>

  <para>
<!--
   To remove a check constraint from one table only:
-->
1つのテーブルのみから検査制約を削除します。
<programlisting>
ALTER TABLE ONLY distributors DROP CONSTRAINT zipchk;
</programlisting>
<!--
   (The check constraint remains in place for any child tables.)
-->
（この検査制約はすべての子テーブルで残ったままです。）
  </para>

  <para>
<!--
   To add a foreign key constraint to a table:
-->
テーブルに外部キー制約を付与します。
<programlisting>
ALTER TABLE distributors ADD CONSTRAINT distfk FOREIGN KEY (address) REFERENCES addresses (address);
</programlisting>
  </para>

  <para>
<!--
   To add a foreign key constraint to a table with the least impact on other work:
-->
テーブルへの外部キー制約の追加で、他の作業への影響を最小限にするには、以下のようにします。
<programlisting>
ALTER TABLE distributors ADD CONSTRAINT distfk FOREIGN KEY (address) REFERENCES addresses (address) NOT VALID;
ALTER TABLE distributors VALIDATE CONSTRAINT distfk;
</programlisting>
  </para>

  <para>
<!--
   To add a (multicolumn) unique constraint to a table:
-->
テーブルに（複数列の）一意性制約を付与します。
<programlisting>
ALTER TABLE distributors ADD CONSTRAINT dist_id_zipcode_key UNIQUE (dist_id, zipcode);
</programlisting>
  </para>

  <para>
<!--
   To add an automatically named primary key constraint to a table, noting
   that a table can only ever have one primary key:
-->
自動的に命名される主キー制約をテーブルに付与します。
1つのテーブルが持てる主キーは1つだけであることに注意してください。
<programlisting>
ALTER TABLE distributors ADD PRIMARY KEY (dist_id);
</programlisting>
  </para>

  <para>
<!--
   To move a table to a different tablespace:
-->
テーブルを別のテーブル空間に移動します。
<programlisting>
ALTER TABLE distributors SET TABLESPACE fasttablespace;
</programlisting>
  </para>

  <para>
<!--
   To move a table to a different schema:
-->
テーブルを別のスキーマに移動します。
<programlisting>
ALTER TABLE myschema.distributors SET SCHEMA yourschema;
</programlisting>
  </para>

  <para>
<!--
   To recreate a primary key constraint, without blocking updates while the
   index is rebuilt:
-->
インデックスを再構築している間の更新をブロックすることなく、主キー制約を再作成します。
<programlisting>
CREATE UNIQUE INDEX CONCURRENTLY dist_id_temp_idx ON distributors (dist_id);
ALTER TABLE distributors DROP CONSTRAINT distributors_pkey,
    ADD CONSTRAINT distributors_pkey PRIMARY KEY USING INDEX dist_id_temp_idx;
</programlisting></para>

  <para>
<!--
   To attach a partition to a range-partitioned table:
-->
範囲パーティションテーブルにパーティションを追加します。
<programlisting>
ALTER TABLE measurement
    ATTACH PARTITION measurement_y2016m07 FOR VALUES FROM ('2016-07-01') TO ('2016-08-01');
</programlisting></para>

  <para>
<!--
   To attach a partition to a list-partitioned table:
-->
リストパーティションテーブルにパーティションを追加します。
<programlisting>
ALTER TABLE cities
    ATTACH PARTITION cities_ab FOR VALUES IN ('a', 'b');
</programlisting></para>

  <para>
<!--
   To attach a partition to a hash-partitioned table:
-->
ハッシュパーティションテーブルにパーティションを追加します。
<programlisting>
ALTER TABLE orders
    ATTACH PARTITION orders_p4 FOR VALUES WITH (MODULUS 4, REMAINDER 3);
</programlisting></para>

  <para>
<!--
   To attach a default partition to a partitioned table:
-->
パーティションテーブルにデフォルトパーティションを追加します。
<programlisting>
ALTER TABLE cities
    ATTACH PARTITION cities_partdef DEFAULT;
</programlisting></para>

  <para>
<!--
   To detach a partition from a partitioned table:
-->
パーティションテーブルからパーティションを切り離します。
<programlisting>
ALTER TABLE measurement
    DETACH PARTITION measurement_y2015m12;
</programlisting></para>

 </refsect1>

 <refsect1>
<!--
  <title>Compatibility</title>
-->
  <title>互換性</title>

  <para>
<!--
   The forms <literal>ADD [COLUMN]</literal>,
   <literal>DROP [COLUMN]</literal>, <literal>DROP IDENTITY</literal>, <literal>RESTART</literal>,
   <literal>SET DEFAULT</literal>, <literal>SET DATA TYPE</literal> (without <literal>USING</literal>),
   <literal>SET GENERATED</literal>, and <literal>SET <replaceable>sequence_option</replaceable></literal>
   conform with the SQL standard.
   The form <literal>ADD <replaceable>table_constraint</replaceable></literal>
   conforms with the SQL standard when the <literal>USING INDEX</literal> and
   <literal>NOT VALID</literal> clauses are omitted and the constraint type is
   one of <literal>CHECK</literal>, <literal>UNIQUE</literal>, <literal>PRIMARY KEY</literal>,
   or <literal>REFERENCES</literal>.
   The other forms are
   <productname>PostgreSQL</productname> extensions of the SQL standard.
   Also, the ability to specify more than one manipulation in a single
   <command>ALTER TABLE</command> command is an extension.
-->
《マッチ度[56.535600]》（<literal>USING INDEX</literal>がない）<literal>ADD</literal>、<literal>DROP [COLUMN]</literal>、<literal>DROP IDENTITY</literal>、<literal>RESTART</literal>、<literal>SET DEFAULT</literal>、（<literal>USING</literal>のない）<literal>SET DATA TYPE</literal>、<literal>SET GENERATED</literal>、<literal>SET <replaceable>sequence_option</replaceable></literal>構文は標準SQLに準拠しています。
他の構文は標準SQLに対する<productname>PostgreSQL</productname>の拡張です。
また、単一の<command>ALTER TABLE</command>コマンド内に複数の操作を指定する機能も<productname>PostgreSQL</productname>の拡張です。
《機械翻訳》形式<literal>ADD [COLUMN]</literal>,<literal>DROP [COLUMN]</literal>,<literal>DROP IDENTITY</literal>,<literal>RESTART</literal>,<literal>SET DEFAULT</literal>,<literal>SET DATA TYPE</literal> <literal>USING</literal>なし,<literal>SET GENERATED</literal>,<literal>SET <replaceable>sequence_option</replaceable></literal>は、標準SQLに準拠しています。
<literal>USING INDEX</literal>および<literal>NOT VALID</literal>節を省略し、フォームタイプ <literal>ADD <replaceable>table_constraint</replaceable></literal>が<literal>CHECK</literal>,<literal>UNIQUE</literal>,<literal>PRIMARY KEY</literal>,<literal>REFERENCES</literal>のいずれかである場合は、標準SQLに準拠しています。
他の形式は、標準SQLの<productname>PostgreSQL</productname>拡張です。
また、単一の<command>ALTER TABLE</command>コマンドで複数の操作を指定する機能も拡張です。
  </para>

  <para>
<!--
   <command>ALTER TABLE DROP COLUMN</command> can be used to drop the only
   column of a table, leaving a zero-column table.  This is an
   extension of SQL, which disallows zero-column tables.
-->
<command>ALTER TABLE DROP COLUMN</command>を使って、1つしか列がないテーブルから列を削除して、列がないテーブルを作成することができます。
これは<productname>PostgreSQL</productname>の拡張です。SQLでは、列を持たないテーブルは認められていません。
  </para>
 </refsect1>

 <refsect1>
<!--
  <title>See Also</title>
-->
  <title>関連項目</title>

  <simplelist type="inline">
   <member><xref linkend="sql-createtable"/></member>
  </simplelist>
 </refsect1>
</refentry>
