<!-- doc/src/sgml/sepgsql.sgml -->

<sect1 id="sepgsql" xreflabel="sepgsql">
 <title>sepgsql</title>

 <indexterm zone="sepgsql">
  <primary>sepgsql</primary>
 </indexterm>

 <para>
<!--
  <filename>sepgsql</> is a loadable module that supports label-based
  mandatory access control (MAC) based on <productname>SELinux</> security
  policy.
-->
<filename>sepgsql</>は、SELinuxのセキュリティポリシーに基づいた、ラベルベースの強制アクセス制御（MAC; Mandatory Access Control）機能を提供するモジュールです。
 </para>

 <warning>
   <para>
<!--
     The current implementation has significant limitations, and does not
     enforce mandatory access control for all actions.  See
     <xref linkend="sepgsql-limitations">.
-->
現在の実装にはいくつかの重要な制限事項があり、そのため、全ての操作に対して強制アクセス制御を適用するわけではありません。
詳細は <xref linkend="sepgsql-limitations"> をご覧ください。
   </para>
 </warning>

 <sect2 id="sepgsql-overview">
<!--
  <title>Overview</title>
-->
  <title>概要</title>

  <para>
<!--
   This module integrates with <productname>SELinux</> to provide an
   additional layer of security checking above and beyond what is normally
   provided by <productname>PostgreSQL</productname>.  From the perspective of
   <productname>SELinux</>, this module allows
   <productname>PostgreSQL</productname> to function as a user-space object
   manager.  Each table or function access initiated by a DML query will be
   checked against the system security policy.  This check is in addition to
   the usual SQL permissions checking performed by
   <productname>PostgreSQL</productname>.
-->
このモジュールは、<productname>PostgreSQL</productname>が標準で提供しているものに加えて、<productname>SELinux</>と統合されたアクセス制御のレイヤーを追加します。
<productname>SELinux</>の視点からは、このモジュールが<productname>PostgreSQL</>をユーザ空間オブジェクトマネージャとして機能することを可能にします。
すなわち、DMLクエリによる個々のテーブルや関数へのアクセスは、オペレーティングシステムのセキュリティポリシーによってチェックされます。
このチェックは、<productname>PostgreSQL</>による通常のSQLパーミッションチェックに対して追加的に実施されます。
  </para>

  <para>
<!--
   <productname>SELinux</productname> access control decisions are made using
   security labels, which are represented by strings such as
   <literal>system_u:object_r:sepgsql_table_t:s0</>.  Each access control
   decision involves two labels: the label of the subject attempting to
   perform the action, and the label of the object on which the operation is
   to be performed.  Since these labels can be applied to any sort of object,
   access control decisions for objects stored within the database can be
   (and, with this module, are) subjected to the same general criteria used
   for objects of any other type, such as files.  This design is intended to
   allow a centralized security policy to protect information assets
   independent of the particulars of how those assets are stored.
-->
<productname>SELinux</>におけるアクセス制御の意思決定は、<literal>system_u:object_r:sepgsql_table_t:s0</>のような書式を持ったセキュリティラベルと呼ばれる文字列を用いて行われます。
個々のアクセス制御の意思決定には、２種類のラベルが利用されます。
すなわち、ある操作を行おうとする主体（サブジェクト）のラベルと、その操作の対象となるオブジェクトのラベルです。
これらのラベルはあらゆる種類のオブジェクトに対して適用されるため、（このモジュールを用いる事で）データベースに格納されたオブジェクトに対するアクセス制御は、他の一般的なオブジェクト、例えばファイルに対するものと同一の基準に従って意思決定される事になります。
このデザインは、情報資産を格納する方法とは独立に、一元管理されたセキュリティポリシーによって情報資産を保護することを意図しています。
  </para>

  <para>
<!--
   The <xref linkend="sql-security-label"> statement allows assignment of
   a security label to a database object.
-->
<xref linkend="sql-security-label">を用いてデータベースオブジェクトにセキュリティラベルを設定することができます。
  </para>

 </sect2>
 <sect2 id="sepgsql-installation">
<!--
  <title>Installation</title>
-->
  <title>インストール</title>

  <para>
<!--
    <filename>sepgsql</> can only be used on <productname>Linux</productname>
    2.6.28 or higher with <productname>SELinux</productname> enabled.
    It is not available on any other platform.  You will also need
    <productname>libselinux</> 2.1.10 or higher and
    <productname>selinux-policy</> 3.9.13 or higher (although some
    distributions may backport the necessary rules into older policy
    versions).
-->
このモジュールは<productname>SELinux</>が有効な<productname>Linux</>カーネル 2.6.28 以上で動作します。
その他のプラットフォーム上では利用する事はできません。
加えて、（ディストリビューションによっては、必要なルールを古いバージョンのポリシーにバックポートしている可能性がありますが）<productname>libselinux</> 2.1.10以上、<productname>selinux-policy</> 3.9.13以上が必要です。
  </para>

  <para>
<!--
   The <command>sestatus</> command allows you to check the status of
   <productname>SELinux</productname>.  A typical display is:
-->
<command>sestatus</>コマンドを用いて<productname>SELinux</>の状態を確認することができます。典型的な出力例は以下の通りです。
<screen>
$ sestatus
SELinux status:                 enabled
SELinuxfs mount:                /selinux
Current mode:                   enforcing
Mode from config file:          enforcing
Policy version:                 24
Policy from config file:        targeted
</screen>
<!--
   If <productname>SELinux</> is disabled or not installed, you must set
   that product up first before installing this module.
-->
<productname>SELinux</>が無効化されている、あるいはインストールされていない場合、このモジュールのインストールの前に、<productname>SELinux</>のセットアップを行わねばなりません。
  </para>

  <para>
<!--
   To build this module, include the option <literal>&#045;-with-selinux</> in
   your PostgreSQL <literal>configure</> command.  Be sure that the
   <filename>libselinux-devel</> RPM is installed at build time.
-->
このモジュールをビルドするには、PostgreSQLの<literal>configure</literal>コマンドに<literal>--with-selinux</literal>オプションを追加してください。
これは、ビルド時に<filename>libselinux-devel</>パッケージがインストールされている事を確認します。
  </para>

  <para>
<!--
   To use this module, you must include <literal>sepgsql</>
   in the <xref linkend="guc-shared-preload-libraries"> parameter in
   <filename>postgresql.conf</>.  The module will not function correctly
   if loaded in any other manner.  Once the module is loaded, you
   function if loaded in any other manner.  Once the module is loaded, you
   should execute <filename>sepgsql.sql</filename> in each database.
   This will install functions needed for security label management, and
   assign initial security labels.
-->
このモジュールを利用するには、<filename>postgresql.conf</>の<xref linkend="guc-shared-preload-libraries">パラメータに <literal>sepgsql</>を含める必要があります。これ以外の方法でロードされた場合、このモジュールは正しく機能しません。
このモジュールのロード後、各データベースに対して<filename>sepgsql.sql</>を実行し、セキュリティラベル管理のための関数のインストールや、初期セキュリティラベルの設定を行うべきです。
  </para>

  <para>
<!--
   Here is an example showing how to initialize a fresh database cluster
   with <filename>sepgsql</> functions and security labels installed.
   Adjust the paths shown as appropriate for your installation:
-->
以下に<filename>sepgsql</>関数およびセキュリティラベルと共にデータベースクラスタを初期化する手順を示します。
インストール先に応じて、適宜パス名を読み替えるようにしてください。
  </para>

<screen>
$ export PGDATA=/path/to/data/directory
$ initdb
$ vi $PGDATA/postgresql.conf
<!--
  change
-->
    #shared_preload_libraries = ''                # (change requires restart)
<!--
  to
-->
  を
    shared_preload_libraries = 'sepgsql'          # (change requires restart)
  に変更
$ for DBNAME in template0 template1 postgres; do
    postgres --single -F -c exit_on_error=true $DBNAME \
      &lt;/usr/local/pgsql/share/contrib/sepgsql.sql &gt;/dev/null
  done
</screen>

  <para>
<!--
   Please note that you may see some or all of the following notifications
   depending on the particular versions you have of
   <productname>libselinux</> and <productname>selinux-policy</>:
-->
<productname>libselinux</>と<productname>selinux-policy</>のバージョンによっては以下のようなメッセージが出力される事があります。
<screen>
/etc/selinux/targeted/contexts/sepgsql_contexts:  line 33 has invalid object type db_blobs
/etc/selinux/targeted/contexts/sepgsql_contexts:  line 36 has invalid object type db_language
/etc/selinux/targeted/contexts/sepgsql_contexts:  line 37 has invalid object type db_language
/etc/selinux/targeted/contexts/sepgsql_contexts:  line 38 has invalid object type db_language
/etc/selinux/targeted/contexts/sepgsql_contexts:  line 39 has invalid object type db_language
/etc/selinux/targeted/contexts/sepgsql_contexts:  line 40 has invalid object type db_language
</screen>
<!--
   These messages are harmless and should be ignored.
-->
これらのメッセージは無害ですので無視してください。
  </para>

  <para>
<!--
   If the installation process completes without error, you can now start the
   server normally.
-->
インストール手順が正常に終了したら、通常通り、サーバを起動することができます。
  </para>
 </sect2>

 <sect2 id="sepgsql-regression">
<!--
  <title>Regression Tests</title>
-->
  <title>リグレッションテスト</title>

  <para>
<!--
   Due to the nature of <productname>SELinux</productname>, running the
   regression tests for <filename>sepgsql</> requires several extra
   configuration steps, some of which must be done as root.
   The regression tests will not be run by an ordinary
   <literal>make check</> or <literal>make installcheck</> command; you must
   set up the configuration and then invoke the test script manually.
   The tests must be run in the <filename>contrib/sepgsql</> directory
   of a configured PostgreSQL build tree.  Although they require a build tree,
   the tests are designed to be executed against an installed server,
   that is they are comparable to <literal>make installcheck</> not
   <literal>make check</>.
-->
<productname>SELinux</>の性質上、<filename>sepgsql</>のリグレッションテストを実行するには、いくつかの追加的な設定が必要で、そのうちの幾つかは<literal>root</>で実行する必要があります。
リグレッションテストは通常の<literal>make check</>や<literal>make installcheck</>コマンドで実行する事はできません。
必要な設定を行い、テスト用スクリプトを手動で実行する必要があります。
このテストはPostgreSQLビルドツリーの<filename>contrib/sepgsql</>ディレクトリで実行する必要があります。
しかしビルドツリーを必要とする一方、このテストはインストールされたサーバに対して実行する必要があります。
これは、<literal>make check</>ではなく、<literal>make installcheck</>によく似ています。
  </para>

  <para>
<!--
   First, set up <filename>sepgsql</filename> in a working database
   according to the instructions in <xref linkend="sepgsql-installation">.
   Note that the current operating system user must be able to connect to the
   database as superuser without password authentication.
-->
最初に、<xref linkend="sepgsql-installation">に従って<filename>sepgsql</>をデータベースにセットアップします。
使用するOS上のユーザは、認証無しでデータベース特権ユーザとして接続できる必要があることに留意してください。
  </para>

  <para>
<!--
   Second, build and install the policy package for the regression test.
   The <filename>sepgsql-regtest</> policy is a special purpose policy package
   which provides a set of rules to be allowed during the regression tests.
   It should be built from the policy source file
   <filename>sepgsql-regtest.te</>, which is done using
   <command>make</command> with a Makefile supplied by SELinux.
   You will need to locate the appropriate
   Makefile on your system; the path shown below is only an example.
   Once built, install this policy package using the
   <command>semodule</> command, which loads supplied policy packages
   into the kernel.  If the package is correctly installed,
   <literal><command>semodule</> -l</> should list <literal>sepgsql-regtest</literal> as an
   available policy package:
-->
次に、リグレッションテスト用のポリシーパッケージのビルドとインストールを行ってください。
<filename>sepgsql-regtest</>ポリシーはリグレッションテストの実行に必要な一連のルールを含む特別な目的のポリシーパッケージです。
ポリシーのソースファイルである<filename>sepgsql-regtest.te</>から、SELinuxの提供するMakefileを用いて<command>make</>コマンドでビルドする事ができます。
この時、インストール先システムにおいて、適切な<filename>Makefile</>の位置を指定する必要があります。以下の例で示されているパスは一例です。
ビルドが完了したら、<command>semodule</>を用いてこのポリシーパッケージをインストールする事ができます。このコマンドは、指定されたポリシーパッケージをリンクし、カーネル空間にロードする役割を果たします。
インストールが正常終了したら、<literal><command>semodule</> -l</>により有効なパッケージの一覧として<literal>sepgsql-regtest</>が表示されるはずです。
  </para>

<screen>
$ cd .../contrib/sepgsql
$ make -f /usr/share/selinux/devel/Makefile
$ sudo semodule -u sepgsql-regtest.pp
$ sudo semodule -l | grep sepgsql
sepgsql-regtest 1.07
</screen>

  <para>
<!--
   Third, turn on <literal>sepgsql_regression_test_mode</>.
   For security reasons, the rules in <filename>sepgsql-regtest</>
   are not enabled by default;
   the <literal>sepgsql_regression_test_mode</literal> parameter enables
   the rules needed to launch the regression tests.
   It can be turned on using the <command>setsebool</> command:
-->
次に、<literal>sepgsql_regression_test_mode</>を有効化してください。
安全のため、デフォルトでは<filename>sepgsql-regtest</>に含まれる全てのルールが有効化されている訳ではありません。
<literal>sepgsql_regression_test_mode</>パラメータはリグレッションテストを起動するために必要となる幾つかのルールを有効にします。
<command>setsebool</>コマンドによって有効化する事ができます。
  </para>

<screen>
$ sudo setsebool sepgsql_regression_test_mode on
$ getsebool sepgsql_regression_test_mode
sepgsql_regression_test_mode --> on
</screen>

  <para>
<!--
   Fourth, verify your shell is operating in the <literal>unconfined_t</>
   domain:
-->
次に、シェルが<literal>unconfined_t</>ドメインで動作している事を確認して下さい。
  </para>
<screen>
$ id -Z
unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023
</screen>

  <para>
<!--
   See <xref linkend="sepgsql-resources"> for details on adjusting your
   working domain, if necessary.
-->
利用者の動作ドメインを設定する方法について、必要であれば、詳細は<xref linkend="sepgsql-resources">をご覧ください。
  </para>

  <para>
<!--
   Finally, run the regression test script:
-->
最後に、リグレッションテストのスクリプトを実行します。
  </para>
<screen>
$ ./test_sepgsql
</screen>

  <para>
<!--
   This script will attempt to verify that you have done all the configuration
   steps correctly, and then it will run the regression tests for the
   <filename>sepgsql</> module.
-->
このスクリプトは全ての設定ステップが正常に行われていることを確認し、その後、<filename>sepgsql</>モジュールに対するリグレッションテストを実行します。
  </para>

  <para>
<!--
   After completing the tests, it's recommended you disable
   the <literal>sepgsql_regression_test_mode</literal> parameter:
-->
テストの実行後は<literal>sepgsql_regression_test_mode</>パラメータを無効化する事をお勧めします。
  </para>

<screen>
$ sudo setsebool sepgsql_regression_test_mode off
</screen>

  <para>
<!--
   You might prefer to remove the <filename>sepgsql-regtest</> policy
   entirely:
-->
<filename>sepgsql-regtest</>ポリシーをアンロードする際は、以下のコマンドを実行してください。
  </para>

<screen>
$ sudo semodule -r sepgsql-regtest
</screen>
 </sect2>

 <sect2 id="sepgsql-parameters">
<!--
  <title>GUC Parameters</title>
-->
  <title>GUCパラメータ</title>

  <variablelist>
   <varlistentry id="guc-sepgsql-permissive" xreflabel="sepgsql.permissive">
    <term>
     <varname>sepgsql.permissive</> (<type>boolean</type>)
     <indexterm>
<!--
      <primary><varname>sepgsql.permissive</> configuration parameter</primary>
-->
      <primary><varname>sepgsql.permissive</>設定パラメータ</primary>
     </indexterm>
    </term>
    <listitem>
     <para>
<!--
      This parameter enables <filename>sepgsql</> to function
      in permissive mode, regardless of the system setting.
      The default is off.
      This parameter can only be set in the <filename>postgresql.conf</>
      file or on the server command line.
-->
このパラメータにより、オペレーティングシステムの設定に関わらず、<filename>sepgsql</>をパーミッシブモードで動作させる事ができます。
デフォルトの設定値はoffです。
<filename>postgresql.conf</>内、およびサーバ起動時のコマンドラインでのみ、このパラメータを設定する事ができます。
     </para>

     <para>
<!--
      When this parameter is on, <filename>sepgsql</> functions
      in permissive mode, even if SELinux in general is working in enforcing
      mode.  This parameter is primarily useful for testing purposes.
-->
このパラメータがonの場合、たとえSELinuxがエンフォーシングモードで動作していたとしても、<productname>SE-PostgreSQL</>はパーミッシブモードで動作します。
このパラメータは主としてテストの目的に有用です。
     </para>
    </listitem>

   </varlistentry>
   <varlistentry id="guc-sepgsql-debug-audit" xreflabel="sepgsql.debug_audit">
    <term>
     <varname>sepgsql.debug_audit</> (<type>boolean</>)
     <indexterm>
<!--
      <primary><varname>sepgsql.debug_audit</> configuration parameter</>
-->
      <primary><varname>sepgsql.debug_audit</>設定パラメータ</>
     </indexterm>
    </term>
    <listitem>
     <para>
<!--
      This parameter enables the printing of audit messages regardless of
      the system policy settings.
      The default is off, which means that messages will be printed according
      to the system settings.
-->
このパラメータにより、セキュリティポリシーの設定とは無関係に監査ログを出力する事が可能になります。
デフォルト値はoff（セキュリティポリシーの設定に従う）です。
     </para>

     <para>
<!--
      The security policy of <productname>SELinux</> also has rules to
      control whether or not particular accesses are logged.
      By default, access violations are logged, but allowed
      accesses are not.
-->
<productname>SELinux</>のセキュリティポリシーには、特定のアクセスを監査ログに記録するか否かを制御するルールも存在します。
デフォルトでは、ポリシーに違反したアクセスを記録し、それ以外はログに記録されません。
     </para>

     <para>
<!--
      This parameter forces all possible logging to be turned on, regardless
      of the system policy.
-->
システムのポリシーとは無関係に、このパラメータは全ての監査ログの出力を強制します。
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </sect2>

 <sect2 id="sepgsql-features">
<!--
  <title>Features</title>
-->
  <title>機能</title>
  <sect3>
<!--
   <title>Controlled Object Classes</title>
-->
   <title>制御されるオブジェクトの種類</title>
   <para>
<!--
    The security model of <productname>SELinux</> describes all the access
    control rules as relationships between a subject entity (typically,
    a client of the database) and an object entity (such as a database
    object), each of which is
    identified by a security label.  If access to an unlabeled object is
    attempted, the object is treated as if it were assigned the label
    <literal>unlabeled_t</>.
-->
<productname>SELinux</>のセキュリティモデルでは、全てのアクセス制御ルールは動作主体（サブジェクト; 典型的にはデータベースクライアント）と対象オブジェクト間の関係として記述し、これらはセキュリティラベルによって識別されます。
ラベル付けされていないオブジェクトに対するアクセスが発生した場合、そのオブジェクトはあたかも<literal>unlabeled_t</>タイプが割り当てられているかのように振舞います。
   </para>

   <para>
<!--
    Currently, <filename>sepgsql</filename> allows security labels to be
    assigned to schemas, tables, columns, sequences, views, and functions.
    When <filename>sepgsql</filename> is in use, security labels are
    automatically assigned to supported database objects at creation time.
    This label is called a default security label, and is decided according
    to the system security policy, which takes as input the creator's label,
    the label assigned to the new object's parent object and optionally name
    of the constructed object.
-->
現在の<productname>sepgsql</>では、スキーマ、テーブル、カラム、シーケンス、ビューおよび関数に対するラベル付けがサポートされています。
<productname>sepgsql</>の利用時には、これらのデータベースオブジェクトに対して、その生成時に自動的にセキュリティラベルが割り当てられます。
このラベルはデフォルトセキュリティラベルと呼ばれ、作成者のラベル、親関係にあたるオブジェクトのラベル、そして場合によっては作成されたオブジェクトの名前に基づいて、システムのセキュリティポリシーが決定します。
   </para>

   <para>
<!--
    A new database object basically inherits the security label of the parent
    object, except when the security policy has special rules known as
    type-transition rules, in which case a different label may be applied.
    For schemas, the parent object is the current database; for tables,
    sequences, views, and functions, it is the containing schema; for columns,
    it is the containing table.
-->
新しいデータベースオブジェクトのラベルは、タイプ遷移と呼ばれる異なったラベルを設定するための特別なルールがセキュリティポリシーに設定されている場合を除き、親関係にあるオブジェクトのラベルを引き継ぎます。
スキーマの親オブジェクトはデータベースであり、テーブル、シーケンス、ビュー、および関数はその属するスキーマが、カラムはその属するテーブルが親オブジェクトという事になります。
   </para>
  </sect3>

  <sect3>
<!--
   <title>DML Permissions</title>
-->
   <title>DMLパーミッション</title>

   <para>
<!--
    For tables, <literal>db_table:select</>, <literal>db_table:insert</>,
    <literal>db_table:update</> or <literal>db_table:delete</> are
    checked for all the referenced target tables depending on the kind of
    statement; in addition, <literal>db_table:select</> is also checked for
    all the tables that contain columns referenced in the
    <literal>WHERE</> or <literal>RETURNING</> clause, as a data source
    for <literal>UPDATE</>, and so on.
-->
テーブルに対しては、構文の種類に応じて<literal>db_table:select</>、<literal>db_table:insert</>、<literal>db_table:update</>あるいは<literal>db_table:delete</>権限が全ての被参照テーブルに対してチェックされます。
加えて、<literal>WHERE</>句や<literal>RETURNING</>句で参照されるカラム、又は<literal>UPDATE</>の際のデータ元として利用されるカラムの属するテーブルに対して<literal>db_table:select</>権限もチェックされます。
   </para>

   <para>
<!--
    Column-level permissions will also be checked for each referenced column.
    <literal>db_column:select</> is checked on not only the columns being
    read using <literal>SELECT</>, but those being referenced in other DML
    statements; <literal>db_column:update</> or <literal>db_column:insert</>
    will also be checked for columns being modified by <literal>UPDATE</> or
    <literal>INSERT</>.
-->
参照された全てのカラムに対して列レベルの権限チェックが行われます。
<literal>SELECT</>構文で読み出されるカラムに対してだけでなく、他のDML構文で参照
されているカラムに対しても<literal>db_column:select</>権限がチェックされます。
また、<literal>UPDATE</>や<literal>INSERT</>によって操作の対象となっているカラム
に対しても、<literal>db_column:update</>や<literal>db_column:insert</>権限が
それぞれチェックされます。
   </para>

   <para>
<!--
    For example, consider:
-->
以下の例を見てください
<synopsis>
UPDATE t1 SET x = 2, y = md5sum(y) WHERE z = 100;
</synopsis>

<!--
    Here, <literal>db_column:update</> will be checked for
    <literal>t1.x</>, since it is being updated,
    <literal>db_column:{select update}</> will be checked for
    <literal>t1.y</>, since it is both updated and referenced, and
    <literal>db_column:select</> will be checked for <literal>t1.z</>, since
    it is only referenced.
    <literal>db_table:{select update}</> will also be checked
    at the table level.
-->
ここでは、更新される<literal>t1.x</>に対して<literal>db_column:update</>権限が、更新と同時に参照される<literal>t1.y</>に対しては<literal>db_column:{select update}</>権限が、そして参照されるだけの<literal>t1.z</>には<literal>db_column:select</>権限がチェックされます。
また、テーブルレベルでは<literal>db_table:{select update}</>権限がチェックされます。
   </para>

   <para>
<!--
    For sequences, <literal>db_sequence:get_value</> is checked when we
    reference a sequence object using <literal>SELECT</>; however, note that we
    do not currently check permissions on execution of corresponding functions
    such as <literal>lastval()</>.
-->
<literal>SELECT</>構文を用いてシーケンスを参照する場合、<literal>db_sequence:get_value</>がチェックされます。
しかし、現在のところ<literal>lastval()</>など関連する関数の実行時にはパーミッションチェックを行わない事に留意してください。
   </para>

   <para>
<!--
    For views, <literal>db_view:expand</> will be checked, then any other
    required permissions will be checked on the objects being
    expanded from the view, individually.
-->
ビューに対しては<literal>db_view:expand</>権限がチェックされ、次いで、ビューから展開されたオブジェクトに対するパーミッションが個別にチェックされます。
   </para>

   <para>
<!--
    For functions, <literal>db_procedure:{execute}</> will be checked when
    user tries to execute a function as a part of query, or using fast-path
    invocation. If this function is a trusted procedure, it also checks
    <literal>db_procedure:{entrypoint}</> permission to check whether it
    can perform as entry point of trusted procedure.
-->
利用者がクエリの一部として、あるいは近道インターフェースを用いた呼び出しによって
関数を実行しようとするとき、<literal>db_procedure:{execute}</>権限がチェックされ
ます。
関数がトラステッドプロシジャである場合、関数がトラステッドプロシジャのエントリー
ポイントとして振る舞う事ができるかどうかを検査するために<literal>db_procedure:{entrypoint}</>権限がチェックされます。
   </para>

   <para>
<!--
    In order to access any schema object, <literal>db_schema:search</>
    permission is required on the containing schema.  When an object is
    referenced without schema qualification, schemas on which this
    permission is not present will not be searched (just as if the user did
    not have <literal>USAGE</> privilege on the schema).  If an explicit schema
    qualification is present, an error will occur if the user does not have
    the requisite permission on the named schema.
-->
あらゆるスキーマオブジェクトにアクセスするためには、それらを含むスキーマに対する<literal>db_schema:search</>権限が必要です。
あるスキーマオブジェクトがスキーマ修飾無しに参照された場合、この権限を与えられていないスキーマは探索されません（あたかも利用者がスキーマに対する<literal>USAGE</>権限を有していないかのように振る舞います）。
明示的なスキーマ修飾があり、このスキーマに対して利用者が要求された権限を有していない場合、エラーが発生します。
   </para>

   <para>
<!--
    The client must be allowed to access all referenced tables and
    columns, even if they originated from views which were then expanded,
    so that we apply consistent access control rules independent of the manner
    in which the table contents are referenced.
-->
クライアントは全ての被参照テーブル・カラムに対して参照の権限を有している必要があります。それらがビューに由来し、展開されたものであっても同様です。これにより、テーブルの内容がどのような方法によって参照されるかに関係なく、一貫したアクセス制御ルールを適用する事ができます。
   </para>

   <para>
<!--
    The default database privilege system allows database superusers to
    modify system catalogs using DML commands, and reference or modify
    toast tables.  These operations are prohibited when
    <filename>sepgsql</> is enabled.
-->
データベーススーパーユーザに対して、標準のデータベース権限システムはDMLを用いたシステムカタログの更新と、TOASTテーブルの参照および更新を許していますが、<productname>sepgsql</>が有効なとき、これらの操作は禁止されます。
   </para>
  </sect3>

  <sect3>
<!--
   <title>DDL Permissions</title>
-->
   <title>DDLパーミッション</title>
   <para>
<!--
    <productname>SELinux</> defines several permissions to control common
    operations for each object type; such as creation, alter, drop and
    relabel of security label. In addition, several object types have
    special permissions to control their characteristic operations; such as
    addition or deletion of name entries within a particular schema.
-->
オブジェクトの作成、変更、削除やセキュリティラベルの変更など、<productname>SELinux</>は各オブジェクトに共通の操作を制御するためのパーミッションを何個か定義しています。
また、特定のスキーマに対する名前の追加や削除など、いくつかのオブジェクトにはそれ固有の操作を制御するための特別なパーミッションも定義されています。
   </para>
   <para>
<!--
    Creating a new database object requires <literal>create</> permission.
    <productname>SELinux</> will grant or deny this permission based on the
    client's security label and the proposed security label for the new
    object.  In some cases, additional privileges are required:
-->
新しいデータベースオブジェクトの作成には<literal>create</>権限が必要です。
<productname>SELinux</>は利用者のセキュリティラベルと新しいオブジェクトに付与される事になるセキュリティラベルの対に基づいて、この権限を許可、あるいは拒否します。
いくつかの場合では、追加的な権限チェックが行われます。
   </para>

   <itemizedlist>
    <listitem>
     <para>
<!--
      <xref linkend="sql-createdatabase"> additionally requires
      <literal>getattr</> permission for the source or template database.
-->
<xref linkend="sql-createdatabase">は、複製元またはテンプレートのデータベース
に対する<literal>getattr</>権限を要求します。
     </para>
    </listitem>
    <listitem>
     <para>
<!--
      Creating a schema object additionally requires <literal>add_name</>
      permission on the parent schema.
-->
スキーマオブジェクトの作成は、それを含むスキーマに対して<literal>add_name</>
権限を要求します。
     </para>
    </listitem>
    <listitem>
     <para>
<!--
      Creating a table additionally requires permission to create each
      individual table column, just as if each table column were a
      separate top-level object.
-->
テーブルの作成は同時に、それがあたかも独立したオブジェクトであるかのように、
個々のテーブル列を作成する権限を要求します。
     </para>
    </listitem>
    <listitem>
     <para>
<!--
      Creating a function marked as <literal>LEAKPROOF</> additionally
      requires <literal>install</> permission.  (This permission is also
      checked when <literal>LEAKPROOF</> is set for an existing function.)
-->
<literal>LEAKPROOF</>属性を持った関数の作成は<literal>install</>権限を要求します。（これはまた、既存の関数に<literal>LEAKPROOF</>属性を設定する時にも要求されます）
     </para>
    </listitem>
   </itemizedlist>

   <para>
<!--
    When <literal>DROP</> command is executed, <literal>drop</> will be
    checked on the object being removed.  Permissions will be also checked for
    objects dropped indirectly via <literal>CASCADE</>.  Deletion of objects
    contained within a particular schema (tables, views, sequences and
    procedures) additionally requires <literal>remove_name</> on the schema.
-->
<literal>DROP</>構文の実行時、削除されるオブジェクトに対して<literal>drop</>権限がチェックされます。
<literal>CASCADE</>により間接的に削除されるオブジェクトに対してもチェックは行われます。
特定のスキーマに含まれるオブジェクト（テーブル、ビュー、シーケンスや関数）の削除に際しては、スキーマに対する<literal>remove_name</>権限も併せてチェックされます。
   </para>

   <para>
<!--
    When <literal>ALTER</> command is executed, <literal>setattr</> will be
    checked on the object being modified for each object types, except for
    subsidiary objects such as the indexes or triggers of a table, where
    permissions are instead checked on the parent object.  In some cases,
    additional permissions are required:
-->
<literal>ALTER</>構文の実行時、テーブルに対するインデックスやトリガなど別オブジェクトに従属するもの（これらは代わりに親オブジェクトに対する権限がチェックされる）を除き、<literal>setattr</>がチェックされます。
いくつかの場合では、追加的な権限チェックが行われます。
   </para>

   <itemizedlist>
    <listitem>
     <para>
<!--
      Moving an object to a new schema additionally requires
      <literal>remove_name</> permission on the old schema and
      <literal>add_name</> permission on the new one.
-->
オブジェクトを新しいスキーマに移動させるには、古いスキーマに対して<literal>remove_name</>権限が、新しいスキーマに対して<literal>add_name</>権限が必要です。
     </para>
    </listitem>
    <listitem>
     <para>
<!--
      Setting the <literal>LEAKPROOF</> attribute on a function requires
      <literal>install</> permission.
-->
関数に対する<literal>LEAKPROOF</>属性の設定は<literal>install</>権限を要求します。
     </para>
    </listitem>
    <listitem>
     <para>
<!--
      Using <xref linkend="sql-security-label"> on an object additionally
      requires <literal>relabelfrom</> permission for the object in
      conjunction with its old security label and <literal>relabelto</>
      permission for the object in conjunction with its new security label.
      (In cases where multiple label providers are installed and the user
      tries to set a security label, but it is not managed by
      <productname>SELinux</>, only <literal>setattr</> should be checked here.
      This is currently not done due to implementation restrictions.)
-->
<xref linkend="sql-security-label">コマンドの実行時、ラベル付けされるオブジェクトの古いラベルに対して<literal>setattr</>権限と<literal>relabelfrom</>権限が、入力された新しいラベルに対して<literal>relabelto</>権限がチェックされます。
（複数のラベルプロバイダがインストールされており、利用者が<productname>SELinux</>の管理下にないラベルを設定しようとした場合、<literal>setattr</>権限だけがチェックされるべきです。しかし実装上の制約により、現在はこれをチェックしていません）
     </para>
    </listitem>
   </itemizedlist>

  </sect3>

  <sect3>
<!--
   <title>Trusted Procedures</title>
-->
   <title>トラステッド プロシジャ</title>
   <para>
<!--
    Trusted procedures are similar to security definer functions or setuid
    commands. <productname>SELinux</> provides a feature to allow trusted
    code to run using a security label different from that of the client,
    generally for the purpose of providing highly controlled access to
    sensitive data (e.g. rows might be omitted, or the precision of stored
    values might be reduced).  Whether or not a function acts as a trusted
    procedure is controlled by its security label and the operating system
    security policy.  For example:
-->
トラステッド・プロシジャはSECURITY DEFINER関数やSet-UIDコマンドに似ています。通常、機密データに対する高度にコントロールされたアクセス手段を提供する目的で、<productname>SELinux</>は利用者のものとは異なるセキュリティラベルで信頼済みのコードを実行するための機能を持っています。
関数がトラステッド・プロシジャとして振舞うかどうかは、関数のセキュリティラベルおよびオペレーティングシステムのセキュリティポリシーに従って決まります。
例えば：
   </para>

<screen>
postgres=# CREATE TABLE customer (
               cid     int primary key,
               cname   text,
               credit  text
           );
CREATE TABLE
postgres=# SECURITY LABEL ON COLUMN customer.credit
               IS 'system_u:object_r:sepgsql_secret_table_t:s0';
SECURITY LABEL
postgres=# CREATE FUNCTION show_credit(int) RETURNS text
             AS 'SELECT regexp_replace(credit, ''-[0-9]+$'', ''-xxxx'', ''g'')
                        FROM customer WHERE cid = $1'
           LANGUAGE sql;
CREATE FUNCTION
postgres=# SECURITY LABEL ON FUNCTION show_credit(int)
               IS 'system_u:object_r:sepgsql_trusted_proc_exec_t:s0';
SECURITY LABEL
</screen>

   <para>
<!--
    The above operations should be performed by an administrative user.
-->
これらの操作は管理権限を持つ利用者で行ってください。
   </para>

<screen>
postgres=# SELECT * FROM customer;
ERROR:  SELinux: security policy violation
postgres=# SELECT cid, cname, show_credit(cid) FROM customer;
 cid | cname  |     show_credit
-----+--------+---------------------
   1 | taro   | 1111-2222-3333-xxxx
   2 | hanako | 5555-6666-7777-xxxx
(2 rows)
</screen>

   <para>
<!--
    In this case, a regular user cannot reference <literal>customer.credit</>
    directly, but a trusted procedure <literal>show_credit</> allows him
    to print the credit card numbers of customers with some of the digits
    masked out.
-->
この場合、一般の利用者は<literal>customer.credit</>を直接参照することはできませんが、トラステッド・プロシジャである<literal>show_credit</>を用いる事で、一部の桁がマスクされた顧客のクレジットカード番号をプリントする事が可能になります。
   </para>
  </sect3>

  <sect3>
<!--
   <title>Dynamic Domain Transitions</title>
-->
   <title>動的ドメイン遷移</title>
   <para>
<!--
    It is possible to use SELinux's dynamic domain transition feature
    to switch the security label of the client process, the client domain,
    to a new context, if that is allowed by the security policy.
    The client domain needs the <literal>setcurrent</> permission and also
    <literal>dyntransition</> from the old to the new domain.
-->
セキュリティポリシーによって許可されている場合、SELinuxの動的ドメイン遷移機能を用いて、利用者のラベルを新しいものに切り替える事ができます。
利用者のドメインは<literal>setcurrent</>権限および、古いドメインから新しいドメインに遷移するための<literal>dyntransition</>権限を有している必要があります。
   </para>
   <para>
<!--
    Dynamic domain transitions should be considered carefully, because they
    allow users to switch their label, and therefore their privileges,
    at their option, rather than (as in the case of a trusted procedure)
    as mandated by the system.
    Thus, the <literal>dyntransition</literal> permission is only considered
    safe when used to switch to a domain with a smaller set of privileges than
    the original one. For example:
-->
利用者に自身のラベル、すなわち権限を切り替える事を可能にする動的ドメイン遷移は、システムによる自動切り替え（トラステッド・プロシージャの場合）に比べて慎重に取り扱う必要があります。
<literal>dyntransition</>権限は元々のドメインよりも小さな権限セットを持つドメインに切り替える場合にのみ安全であると考えられます。例えば、
   </para>
<screen>
regression=# select sepgsql_getcon();
                    sepgsql_getcon
-------------------------------------------------------
 unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023
(1 row)

regression=# SELECT sepgsql_setcon('unconfined_u:unconfined_r:unconfined_t:s0-s0:c1.c4');
 sepgsql_setcon 
----------------
 t
(1 row)

regression=# SELECT sepgsql_setcon('unconfined_u:unconfined_r:unconfined_t:s0-s0:c1.c1023');
ERROR:  SELinux: security policy violation
</screen>
   <para>
<!--
    In this example above we were allowed to switch from the larger MCS
    range <literal>c1.c1023</> to the smaller range <literal>c1.c4</>, but
    switching back was denied.
-->
上記の例では、広いMCSレンジ<literal>c0.c1023</>から狭いMCSレンジ<literal>c1.c4</>への遷移は許可されているものの、その逆は禁止されています。
   </para>
   <para>
<!--
    A combination of dynamic domain transition and trusted procedure
    enables an interesting use case that fits the typical process life-cycle
    of connection pooling software.
    Even if your connection pooling software is not allowed to run most
    of SQL commands, you can allow it to switch the security label
    of the client using the <literal>sepgsql_setcon()</literal> function
    from within a trusted procedure; that should take some
    credential to authorize the request to switch the client label.
    After that, this session will have the privileges of the target user,
    rather than the connection pooler.
    The connection pooler can later revert the security label change by
    again using <literal>sepgsql_setcon()</literal> with
    <literal>NULL</literal> argument, again invoked from within a trusted
    procedure with appropriate permissions checks.
    The point here is that only the trusted procedure actually has permission
    to change the effective security label, and only does so when given proper
    credentials.  Of course, for secure operation, the credential store
    (table, procedure definition, or whatever) must be protected from
    unauthorized access.
-->
動的ドメイン遷移とトラステッド・プロシジャの組み合わせは、典型的なコネクションプーラのライフサイクルに適合する興味深い利用法を提供します。
たとえコネクションプーリングソフトウェアが大半のSQLの実行を許可されていない場合でも、トラステッド・プロシジャの内側から<literal>sepgsql_setcon()</literal>関数を用いて利用者のセキュリティラベルを切り替える事ができます。（トラステッド・プロシジャは利用者のセキュリティラベルを切り替えるための認証情報を要求すべきです）
この後、現在のセッションはコネクションプーラの権限ではなく、対象となる利用者の権限で動作する事になります。
また、<literal>sepgsql_setcon()</literal>に<literal>NULL</literal>引数を与えて（適切な権限チェックを行う）トラステッド・プロシジャから再び呼び出す事で、コネクションプーラは後でセキュリティラベルを元に戻す事ができます。
ここでのポイントは、トラステッド・プロシジャだけが実際に有効なセキュリティラベルを変更する権限を持っており、正しい認証情報が与えられた場合にのみそれを実行するという事です。
言うまでもなく、安全な操作のためには、権限のないアクセスから認証情報を保持するテーブルや関数定義などを保護しなければなりません。
   </para>
  </sect3>

  <sect3>
<!--
   <title>Miscellaneous</title>
-->
   <title>その他</title>

   <para>
<!--
    We reject the <xref linkend="sql-load"> command across the board, because
    any module loaded could easily circumvent security policy enforcement.
-->
ロードされたモジュールは、セキュリティポリシーの適用を容易にバイパスできるため、<xref linkend="sql-load">コマンドの実行は全面的に禁止されています。
   </para>

  </sect3>
 </sect2>

 <sect2 id="sepgsql-functions">
<!--
  <title>Sepgsql Functions</title>
-->
  <title>sepgsql関数</title>
  <para>
<!--
   <xref linkend="sepgsql-functions-table"> shows the available functions.
-->
   <xref linkend="sepgsql-functions-table">に利用可能な関数を示します。
  </para>

  <table id="sepgsql-functions-table">
<!--
   <title>Sepgsql Functions</title>
-->
   <title>Sepgsql 関数</title>
   <tgroup cols="2">
    <tbody>
     <row>
      <entry><literal>sepgsql_getcon() returns text</literal></entry>
      <entry>
<!--
       Returns the client domain, the current security label of the client.
-->
利用者のドメイン、つまり、現在の利用者ラベルを返却します。
      </entry>
     </row>
     <row>
      <entry><literal>sepgsql_setcon(text) returns bool</literal></entry>
      <entry>
<!--
       Switches the client domain of the current session to the new domain,
       if allowed by the security policy.
       It also accepts <literal>NULL</literal> input as a request to transition
       to the client's original domain.
-->
セキュリティポリシーで許可されている場合、現在のセッションの利用者ドメインを新しいドメインへと切り替えます。
<literal>NULL</literal>を引数に取る事も可能で、その場合、元々の利用者ドメインへの遷移を意味します。
      </entry>
     </row>
     <row>
      <entry><literal>sepgsql_mcstrans_in(text) returns text</literal></entry>
<!--
      <entry>Translates the given qualifies MLS/MCS range into raw format if
      Translates the given qualifies MLS/MCS range into raw format if
      the mcstrans daemon is running.
-->
      <entry>
mcstransデーモンが動作している場合、入力されたMLS/MCSレンジを修飾フォーマットから直接フォーマットに変換します。
      </entry>
     </row>
     <row>
      <entry><literal>sepgsql_mcstrans_out(text) returns text</literal></entry>
<!--
      <entry>Translates the given raw MCS/MCS range into qualified format if
      the mcstrans daemon is running.
-->
      <entry>
mcstransデーモンが動作している場合、入力されたMLS/MCSレンジを直接フォーマットから修飾フォーマットに変換します。
      </entry>
     </row>
     <row>
      <entry><literal>sepgsql_restorecon(text) returns bool</literal></entry>
      <entry>
<!--
       Sets up initial security labels for all objects within the
       current database. The argument may be NULL, or the name of a specfile
       to be used as alternative of the system default.
-->
現在のデータベース内の全てのオブジェクトに対して初期ラベルを割り当てます。引数は<literal>NULL</literal>もしくはシステムの標準に代わる定義ファイルの名前です。
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect2>

 <sect2 id="sepgsql-limitations">
<!--
  <title>Limitations</title>
-->
  <title>制限事項</title>

  <variablelist>
   <varlistentry>
<!--
    <term>Data Definition Language (DDL) Permissions</term>
-->
    <term>Data Definition Language (DDL) パーミッション</term>
    <listitem>
     <para>
<!--
      Due to implementation restrictions, some DDL operations do not
      check permissions.
-->
実装上の制約により、いくつかのDDL操作はパーミッションをチェックしません。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--
    <term>Data Control Language (DCL) Permissions</term>
-->
    <term>Data Control Language (DCL) パーミッション</term>
    <listitem>
     <para>
<!--
      Due to implementation restrictions, DCL operations do not check
      permissions.
-->
実装上の制約により、DCL操作はパーミッションをチェックしません。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--
    <term>Row-level access control</term>
-->
    <term>Row-level access control</term>
    <listitem>
     <para>
<!--
      <productname>PostgreSQL</> does not support row-level access; therefore,
      <filename>sepgsql</filename> does not support it either.
-->
<productname>PostgreSQL</>は行レベルアクセス制御をサポートしていません。
したがって、<filename>sepgsql</filename>も同様です。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--
    <term>Covert channels</term>
-->
    <term>隠れチャネル</term>
    <listitem>
     <para>
<!--
      <filename>sepgsql</> does not try to hide the existence of
      a certain object, even if the user is not allowed to reference it.
      For example, we can infer the existence of an invisible object as
      a result of primary key conflicts, foreign key violations, and so on,
      even if we cannot obtain the contents of the object.  The existence
      of a top secret table cannot be hidden; we only hope to conceal its
      contents.
-->
たとえ利用者が参照を許可されていないオブジェクトであっても、<productname>sepgsql</>はその存在を隠すことを意図していません。
例えば、我々があるオブジェクトの内容を参照する事ができなくても、主キーの競合や外部キー違反、その他の方法によって不可視なオブジェクトが存在する事を推測できます。
"最高機密"テーブルの存在を隠すことは不可能であり、その内容を秘匿することだけを意図しています。
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </sect2>

 <sect2 id="sepgsql-resources">
<!--
  <title>External Resources</title>
-->
  <title>外部リソース</title>
  <variablelist>
   <varlistentry>
    <term><ulink url="http://wiki.postgresql.org/wiki/SEPostgreSQL">SE-PostgreSQL Introduction</ulink></term>
    <listitem>
     <para>
<!--
      This wiki page provides a brief overview, security design, architecture,
      administration and upcoming features.
-->
このwikiページでは、概要、セキュリティ・デザイン、アーキテクチャ、管理、および将来の機能について紹介しています。
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><ulink url="http://docs.fedoraproject.org/selinux-user-guide/">Fedora SELinux User Guide</ulink></term>
    <listitem>
     <para>
<!--
      This document provides a wide spectrum of knowledge to administer
      <productname>SELinux</> on your systems.
      It focuses primarily on Fedora, but is not limited to Fedora.
-->
このドキュメントは<productname>SELinux</>システム管理に対する広範な知識を提供しています。
主としてFedoraを対象としていますが、それに限ったものではありません。
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><ulink url="http://docs.fedoraproject.org/selinux-faq">Fedora SELinux FAQ</ulink></term>
    <listitem>
     <para>
<!--
      This document answers frequently asked questions about
      <productname>SELinux</productname>.
      It focuses primarily on Fedora, but is not limited to Fedora.
-->
このドキュメントは<productname>SELinux</>に関するよくある質問と回答(FAQ)です。
主としてFedoraを対象としていますが、それに限ったものではありません。
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </sect2>

 <sect2 id="sepgsql-author">
<!--
  <title>Author</title>
-->
  <title>著者</title>
  <para>
   KaiGai Kohei <email>kaigai@ak.jp.nec.com</email>
  </para>
 </sect2>
</sect1>
