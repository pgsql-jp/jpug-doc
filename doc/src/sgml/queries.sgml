<!-- doc/src/sgml/queries.sgml -->

<chapter id="queries">
<!--
 <title>Queries</title>
-->
 <title>問い合わせ</title>

 <indexterm zone="queries">
  <primary>query</primary>
 </indexterm>
 <indexterm zone="queries">
  <primary>問い合わせ</primary>
 </indexterm>

 <indexterm zone="queries">
  <primary>SELECT</primary>
 </indexterm>

 <para>
<!--
  The previous chapters explained how to create tables, how to fill
  them with data, and how to manipulate that data.  Now we finally
  discuss how to retrieve the data from the database.
-->
前章までで、テーブルを作成し、これにデータを挿入し、さらに挿入したデータを操作する方法について説明しました。
本章では、データベースからデータを取り出す方法について説明します。
 </para>


 <sect1 id="queries-overview">
<!--
  <title>Overview</title>
-->
  <title>概要</title>

  <para>
<!--
   The process of retrieving or the command to retrieve data from a
   database is called a <firstterm>query</firstterm>.  In SQL the
   <xref linkend="sql-select"/> command is
   used to specify queries.  The general syntax of the
   <command>SELECT</command> command is
-->
データベースからデータを取り出す処理、または、取り出すためのコマンドを<firstterm>問い合わせ</firstterm>と言います。
SQLでは、<xref linkend="sql-select"/>コマンドを、問い合わせを指定するために使います。
<command>SELECT</command>コマンドの一般的な構文は次の通りです。
<synopsis>
<optional>WITH <replaceable>with_queries</replaceable></optional> SELECT <replaceable>select_list</replaceable> FROM <replaceable>table_expression</replaceable> <optional><replaceable>sort_specification</replaceable></optional>
</synopsis>
<!--
   The following sections describe the details of the select list, the
   table expression, and the sort specification.  <literal>WITH</literal>
   queries are treated last since they are an advanced feature.
-->
以降の節では、選択リスト、テーブル式、並べ替えの仕様について詳細に説明します。
<literal>WITH</literal>問い合わせは、より進んだ機能のため最後で扱います。
  </para>

  <para>
<!--
   A simple kind of query has the form:
-->
単純な問い合わせの形式は次のようなものです。
<programlisting>
SELECT * FROM table1;
</programlisting>
<!--
  Assuming that there is a table called <literal>table1</literal>,
  this command would retrieve all rows and all user-defined columns from
  <literal>table1</literal>.  (The method of retrieval depends on the
  client application.  For example, the
  <application>psql</application> program will display an ASCII-art
  table on the screen, while client libraries will offer functions to
  extract individual values from the query result.)  The select list
  specification <literal>*</literal> means all columns that the table
  expression happens to provide.  A select list can also select a
  subset of the available columns or make calculations using the
  columns.  For example, if
  <literal>table1</literal> has columns named <literal>a</literal>,
  <literal>b</literal>, and <literal>c</literal> (and perhaps others) you can make
  the following query:
-->
<literal>table1</literal>というテーブルがあるとして、このコマンドは<literal>table1</literal>からすべてのユーザ定義の列を全行取り出します。
（検索する方法はクライアントアプリケーションに依存します。
クライアントライブラリは、問い合わせ結果から個々の値を抽出する機能を提供する一方、例えば<application>psql</application>プログラムでは、アスキーアートで表組を画面上に表示します。）
選択リストの指定における<literal>*</literal>は、テーブル式が持つすべての列を提供することを意味します。
選択リストでは、選択可能な列の一部を選択することも、選択可能な列を使用して計算することもできます。
例えば、<literal>table1</literal>に<literal>a</literal>、<literal>b</literal>、<literal>c</literal>という名前の列がある場合（他の列があっても構いません）、以下のような問い合わせができます。
<programlisting>
SELECT a, b + c FROM table1;
</programlisting>
<!--
  (assuming that <literal>b</literal> and <literal>c</literal> are of a numerical
  data type).
  See <xref linkend="queries-select-lists"/> for more details.
-->
（ここでは<literal>b</literal>および<literal>c</literal>は数値型のデータであると仮定しています。）
詳細については<xref linkend="queries-select-lists"/>を参照してください。
 </para>

 <para>
<!--
  <literal>FROM table1</literal> is a simple kind of
  table expression: it reads just one table.  In general, table
  expressions can be complex constructs of base tables, joins, and
  subqueries.  But you can also omit the table expression entirely and
  use the <command>SELECT</command> command as a calculator:
-->
<literal>FROM table1</literal>は、単純な形のテーブル式で、読み込むテーブルは1つだけです。
一般にテーブル式は基本テーブルや結合そして副問い合わせなどで複雑に構成されることがあります。
しかし、以下のように、テーブル式をすべて省略し、<command>SELECT</command>コマンドを電卓として使用することもできます。
<programlisting>
SELECT 3 * 4;
</programlisting>
<!--
  This is more useful if the expressions in the select list return
  varying results.  For example, you could call a function this way:
-->
選択リストの式が返す結果が変化する場合、これはさらに有用です。
例えば、関数を次のように呼び出すことができます。
<programlisting>
SELECT random();
</programlisting>
  </para>
 </sect1>


 <sect1 id="queries-table-expressions">
<!--
  <title>Table Expressions</title>
-->
  <title>テーブル式</title>

  <indexterm zone="queries-table-expressions">
   <primary>table expression</primary>
  </indexterm>
  <indexterm zone="queries-table-expressions">
   <primary>テーブル式</primary>
  </indexterm>

  <para>
<!--
   A <firstterm>table expression</firstterm> computes a table.  The
   table expression contains a <literal>FROM</literal> clause that is
   optionally followed by <literal>WHERE</literal>, <literal>GROUP BY</literal>, and
   <literal>HAVING</literal> clauses.  Trivial table expressions simply refer
   to a table on disk, a so-called base table, but more complex
   expressions can be used to modify or combine base tables in various
   ways.
-->
<firstterm>テーブル式</firstterm>はテーブルを計算するためのものです。
テーブル式には<literal>FROM</literal>句が含まれており、その後ろにオプションとして<literal>WHERE</literal>句、<literal>GROUP BY</literal>句、<literal>HAVING</literal>句を付けることができます。
単純なテーブル式は、単にディスク上のいわゆる基本テーブルと呼ばれるテーブルを参照するだけです。
しかし複雑な式では、様々な方法で基本テーブルを修正したり、結合させて使用することができます。
  </para>

  <para>
<!--
   The optional <literal>WHERE</literal>, <literal>GROUP BY</literal>, and
   <literal>HAVING</literal> clauses in the table expression specify a
   pipeline of successive transformations performed on the table
   derived in the <literal>FROM</literal> clause.  All these transformations
   produce a virtual table that provides the rows that are passed to
   the select list to compute the output rows of the query.
-->
テーブル式のオプション<literal>WHERE</literal>句、<literal>GROUP BY</literal>句、および<literal>HAVING</literal>句は、<literal>FROM</literal>句で派生したテーブル上に対して次々に変換を実行するパイプラインを指定します。
これらの変換によって仮想テーブルが1つ生成されます。
そしてこの仮想テーブルの行が選択リストに渡され、問い合わせの出力行が計算されます。
  </para>

  <sect2 id="queries-from">
<!--
   <title>The <literal>FROM</literal> Clause</title>
-->
   <title><literal>FROM</literal>句</title>

   <para>
<!--
    The <link linkend="sql-from"><literal>FROM</literal></link> clause derives a
    table from one or more other tables given in a comma-separated
    table reference list.
-->
<link linkend="sql-from"><literal>FROM</literal></link>句は、カンマで分けられたテーブル参照リストで与えられる1つ以上のテーブルから、1つのテーブルを派生します。
<synopsis>
FROM <replaceable>table_reference</replaceable> <optional>, <replaceable>table_reference</replaceable> <optional>, ...</optional></optional>
</synopsis>

<!--
    A table reference can be a table name (possibly schema-qualified),
    or a derived table such as a subquery, a <literal>JOIN</literal> construct, or
    complex combinations of these.  If more than one table reference is
    listed in the <literal>FROM</literal> clause, the tables are cross-joined
    (that is, the Cartesian product of their rows is formed; see below).
    The result of the <literal>FROM</literal> list is an intermediate virtual
    table that can then be subject to
    transformations by the <literal>WHERE</literal>, <literal>GROUP BY</literal>,
    and <literal>HAVING</literal> clauses and is finally the result of the
    overall table expression.
-->
テーブル参照は、テーブル名（スキーマで修飾することもできます）、あるいは、副問い合わせ、<literal>JOIN</literal>による結合、これらの複雑な組み合わせなどの派生テーブルとすることができます。
<literal>FROM</literal>句に複数のテーブル参照がある場合、クロス結合されます（テーブルの行のデカルト積が形成されます。下記を参照）。
<literal>FROM</literal>リストの結果は<literal>WHERE</literal>句、<literal>GROUP BY</literal>句、および<literal>HAVING</literal>句での変換対象となる中間的な仮想テーブルになり、最終的にはテーブル式全体の結果となります。
   </para>

   <indexterm>
    <primary>ONLY</primary>
   </indexterm>

   <para>
<!--
    When a table reference names a table that is the parent of a
    table inheritance hierarchy, the table reference produces rows of
    not only that table but all of its descendant tables, unless the
    key word <literal>ONLY</literal> precedes the table name.  However, the
    reference produces only the columns that appear in the named table
    &mdash; any columns added in subtables are ignored.
-->
テーブル参照で、テーブルの継承階層の親テーブルの名前を指定すると、テーブル名の前に<literal>ONLY</literal>キーワードがない場合は、テーブル参照はそのテーブルだけでなくその子テーブルに継承されたすべての行を生成します。
しかし、この参照は名前を指定したテーブルに現れる列のみを生成し、子テーブルで追加された列は無視されます。
   </para>

   <para>
<!--
    Instead of writing <literal>ONLY</literal> before the table name, you can write
    <literal>*</literal> after the table name to explicitly specify that descendant
    tables are included.  There is no real reason to use this syntax any more,
    because searching descendant tables is now always the default behavior.
    However, it is supported for compatibility with older releases.
-->
テーブル名の前に<literal>ONLY</literal>を記述する代わりに、テーブル名の後に<literal>*</literal>を記述して、子テーブルが含まれることを明示的に指定することができます。
子テーブルを検索するのが今は常にデフォルトの振る舞いですので、この文法を使う本当の理由はもうありません。
しかし、古いリリースとの互換性のためにサポートされています。
   </para>

   <sect3 id="queries-join">
<!--
    <title>Joined Tables</title>
-->
    <title>結合テーブル</title>

    <indexterm zone="queries-join">
     <primary>join</primary>
    </indexterm>
    <indexterm zone="queries-join">
     <primary>結合</primary>
    </indexterm>

    <para>
<!--
     A joined table is a table derived from two other (real or
     derived) tables according to the rules of the particular join
     type.  Inner, outer, and cross-joins are available.
     The general syntax of a joined table is
-->
結合テーブルは、2つの（実または派生）テーブルから、指定した結合種類の規則に従って派生したテーブルです。
内部結合、外部結合、およびクロス結合が使用可能です。
テーブル結合の一般的な構文は次のとおりです
<synopsis>
<replaceable>T1</replaceable> <replaceable>join_type</replaceable> <replaceable>T2</replaceable> <optional> <replaceable>join_condition</replaceable> </optional>
</synopsis>
<!--
     Joins of all types can be chained together, or nested: either or
     both <replaceable>T1</replaceable> and
     <replaceable>T2</replaceable> can be joined tables.  Parentheses
     can be used around <literal>JOIN</literal> clauses to control the join
     order.  In the absence of parentheses, <literal>JOIN</literal> clauses
     nest left-to-right.
-->
すべての結合は、互いに結び付けたり、あるいは入れ子にしたりすることができます。
<replaceable>T1</replaceable>と<replaceable>T2</replaceable>のどちらか、あるいは両方が、結合テーブルになることがあります。
括弧で<literal>JOIN</literal>句を括ることで結合の順序を制御することができます。
括弧がない場合、<literal>JOIN</literal>句は左から右に入れ子にします。
    </para>

    <variablelist>
<!--
     <title>Join Types</title>
-->
     <title>結合の種類</title>

     <varlistentry>
<!--
      <term>Cross join
-->
      <term>クロス結合
      <indexterm>
       <primary>join</primary>
       <secondary>cross</secondary>
      </indexterm>
      <indexterm>
       <primary>結合</primary>
       <secondary>クロス</secondary>
      </indexterm>

      <indexterm>
       <primary>cross join</primary>
      </indexterm>
      <indexterm>
       <primary>クロス結合</primary>
      </indexterm>
      </term>

      <listitem>
<synopsis>
<replaceable>T1</replaceable> CROSS JOIN <replaceable>T2</replaceable>
</synopsis>

       <para>
<!--
        For every possible combination of rows from
        <replaceable>T1</replaceable> and
        <replaceable>T2</replaceable> (i.e., a Cartesian product),
        the joined table will contain a
        row consisting of all columns in <replaceable>T1</replaceable>
        followed by all columns in <replaceable>T2</replaceable>.  If
        the tables have N and M rows respectively, the joined
        table will have N * M rows.
-->
<replaceable>T1</replaceable>および<replaceable>T2</replaceable>からのすべての可能な行の組み合わせ（つまりデカルト積）に対し、結合されたテーブルは<replaceable>T1</replaceable>のすべての列の後に<replaceable>T2</replaceable>のすべての列が続く行を含みます。
テーブルがそれぞれN行とM行で構成されているとすると、結合されたテーブルの行数は N * M 行となります。
       </para>

       <para>
<!--
        <literal>FROM <replaceable>T1</replaceable> CROSS JOIN
        <replaceable>T2</replaceable></literal> is equivalent to
        <literal>FROM <replaceable>T1</replaceable> INNER JOIN
        <replaceable>T2</replaceable> ON TRUE</literal> (see below).
        It is also equivalent to
        <literal>FROM <replaceable>T1</replaceable>,
        <replaceable>T2</replaceable></literal>.
-->
<literal>FROM <replaceable>T1</replaceable> CROSS JOIN <replaceable>T2</replaceable></literal> は <literal>FROM <replaceable>T1</replaceable> INNER JOIN <replaceable>T2</replaceable> ON TRUE</literal> と同じです（下記を参照）。
また <literal>FROM <replaceable>T1</replaceable>, <replaceable>T2</replaceable></literal> とも同じです。
        <note>
        <para>
<!--
         This latter equivalence does not hold exactly when more than two
         tables appear, because <literal>JOIN</literal> binds more tightly than
         comma.  For example
         <literal>FROM <replaceable>T1</replaceable> CROSS JOIN
         <replaceable>T2</replaceable> INNER JOIN <replaceable>T3</replaceable>
         ON <replaceable>condition</replaceable></literal>
         is not the same as
         <literal>FROM <replaceable>T1</replaceable>,
         <replaceable>T2</replaceable> INNER JOIN <replaceable>T3</replaceable>
         ON <replaceable>condition</replaceable></literal>
         because the <replaceable>condition</replaceable> can
         reference <replaceable>T1</replaceable> in the first case but not
         the second.
-->
３つ以上のテーブルが現れた場合、この後者の等価性は厳密には保たれてはいません。
なぜなら、<literal>JOIN</literal>はカンマより強固に結合するためです。
例えば
<literal>FROM <replaceable>T1</replaceable> CROSS JOIN
<replaceable>T2</replaceable> INNER JOIN <replaceable>T3</replaceable>
ON <replaceable>condition</replaceable></literal>
は
<literal>FROM <replaceable>T1</replaceable>,
<replaceable>T2</replaceable> INNER JOIN <replaceable>T3</replaceable>
ON <replaceable>condition</replaceable></literal>
と同じではありません。
なぜなら最初のケースでは<replaceable>condition</replaceable>が<replaceable>T1</replaceable>を参照できますが、2番目ではできないからです。
        </para>
        </note>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--
      <term>Qualified joins
-->
      <term>限定的な結合
      <indexterm>
       <primary>join</primary>
       <secondary>outer</secondary>
      </indexterm>
      <indexterm>
       <primary>結合</primary>
       <secondary>外部</secondary>
      </indexterm>

      <indexterm>
       <primary>outer join</primary>
      </indexterm>
      <indexterm>
       <primary>外部結合</primary>
      </indexterm>
      </term>

      <listitem>
<synopsis>
<replaceable>T1</replaceable> { <optional>INNER</optional> | { LEFT | RIGHT | FULL } <optional>OUTER</optional> } JOIN <replaceable>T2</replaceable> ON <replaceable>boolean_expression</replaceable>
<replaceable>T1</replaceable> { <optional>INNER</optional> | { LEFT | RIGHT | FULL } <optional>OUTER</optional> } JOIN <replaceable>T2</replaceable> USING ( <replaceable>join column list</replaceable> )
<replaceable>T1</replaceable> NATURAL { <optional>INNER</optional> | { LEFT | RIGHT | FULL } <optional>OUTER</optional> } JOIN <replaceable>T2</replaceable>
</synopsis>

       <para>
<!--
        The words <literal>INNER</literal> and
        <literal>OUTER</literal> are optional in all forms.
        <literal>INNER</literal> is the default;
        <literal>LEFT</literal>, <literal>RIGHT</literal>, and
        <literal>FULL</literal> imply an outer join.
-->
<literal>INNER</literal>や<literal>OUTER</literal>は省略可能です。
<literal>INNER</literal>がデフォルトとなります。
<literal>LEFT</literal>、<literal>RIGHT</literal>、<literal>FULL</literal>は外部結合を意味します。
       </para>

       <para>
<!--
        The <firstterm>join condition</firstterm> is specified in the
        <literal>ON</literal> or <literal>USING</literal> clause, or implicitly by
        the word <literal>NATURAL</literal>.  The join condition determines
        which rows from the two source tables are considered to
        <quote>match</quote>, as explained in detail below.
-->
<firstterm>結合条件</firstterm>は、<literal>ON</literal>句か<literal>USING</literal>句で指定するか、または<literal>NATURAL</literal>記述で暗黙的に指定します。
結合条件は、以下で詳しく説明するように、2つの元となるテーブルのどの行が<quote>一致するか</quote>を決めます。
       </para>

       <para>
<!--
        The possible types of qualified join are:
-->
限定的な結合には次のものがあります。

       <variablelist>
        <varlistentry>
<!--
         <term><literal>INNER JOIN</literal></term>
-->
         <term><literal>INNER JOIN</literal>（内部結合）</term>

         <listitem>
          <para>
<!--
           For each row R1 of T1, the joined table has a row for each
           row in T2 that satisfies the join condition with R1.
-->
T1の各行R1に対して、T2において行R1との結合条件を満たしている各行が、結合されたテーブルに含まれます。
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
<!--
         <term><literal>LEFT OUTER JOIN</literal>
-->
         <term><literal>LEFT OUTER JOIN</literal>（左外部結合）
         <indexterm>
          <primary>join</primary>
          <secondary>left</secondary>
         </indexterm>
         <indexterm>
          <primary>結合</primary>
          <secondary>左</secondary>
         </indexterm>

         <indexterm>
          <primary>left join</primary>
         </indexterm>
         <indexterm>
          <primary>左結合</primary>
         </indexterm>
         </term>

         <listitem>
          <para>
<!--
           First, an inner join is performed.  Then, for each row in
           T1 that does not satisfy the join condition with any row in
           T2, a joined row is added with null values in columns of
           T2.  Thus, the joined table always has at least
           one row for each row in T1.
-->
まず、内部結合が行われます。
その後、T2のどの行との結合条件も満たさないT1の各行については、T2の列をNULL値として結合行が追加されます。
したがって、連結されたテーブルは常にT1の行それぞれに少なくとも1つの行があります。
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
<!--
         <term><literal>RIGHT OUTER JOIN</literal>
-->
         <term><literal>RIGHT OUTER JOIN</literal>（右外部結合）
         <indexterm>
          <primary>join</primary>
          <secondary>right</secondary>
         </indexterm>
         <indexterm>
          <primary>結合</primary>
          <secondary>右</secondary>
         </indexterm>

         <indexterm>
          <primary>right join</primary>
         </indexterm>
         <indexterm>
          <primary>右結合</primary>
         </indexterm>
         </term>

         <listitem>
          <para>
<!--
           First, an inner join is performed.  Then, for each row in
           T2 that does not satisfy the join condition with any row in
           T1, a joined row is added with null values in columns of
           T1.  This is the converse of a left join: the result table
           will always have a row for each row in T2.
-->
まず、内部結合が行われます。
その後、T1のどの行の結合条件も満たさないT2の各行については、T1の列をNULL値として結合行が追加されます。
これは左結合の反対です。
結果のテーブルは、T2の行が常に入ります。
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
<!--
         <term><literal>FULL OUTER JOIN</literal></term>
-->
         <term><literal>FULL OUTER JOIN</literal>（完全外部結合）</term>

         <listitem>
          <para>
<!--
           First, an inner join is performed.  Then, for each row in
           T1 that does not satisfy the join condition with any row in
           T2, a joined row is added with null values in columns of
           T2.  Also, for each row of T2 that does not satisfy the
           join condition with any row in T1, a joined row with null
           values in the columns of T1 is added.
-->
まず、内部結合が行われます。
その後、T2のどの行の結合条件も満たさないT1の各行については、T2の列をNULL値として結合行が追加されます。
さらに、T1のどの行でも結合条件を満たさないT2の各行に対して、T1の列をNULL値として結合行が追加されます。
          </para>
         </listitem>
        </varlistentry>
       </variablelist>
       </para>

       <para>
<!--
        The <literal>ON</literal> clause is the most general kind of join
        condition: it takes a Boolean value expression of the same
        kind as is used in a <literal>WHERE</literal> clause.  A pair of rows
        from <replaceable>T1</replaceable> and <replaceable>T2</replaceable> match if the
        <literal>ON</literal> expression evaluates to true.
-->
<literal>ON</literal>句は最も汎用的な結合条件であり、<literal>WHERE</literal>句で使われるものと同じ論理値評価式となります。
<literal>ON</literal>式の評価が真となる場合、<replaceable>T1</replaceable>および<replaceable>T2</replaceable>の対応する行が一致します。
       </para>

       <para>
<!--
        The <literal>USING</literal> clause is a shorthand that allows you to take
        advantage of the specific situation where both sides of the join use
        the same name for the joining column(s).  It takes a
        comma-separated list of the shared column names
        and forms a join condition that includes an equality comparison
        for each one.  For example, joining <replaceable>T1</replaceable>
        and <replaceable>T2</replaceable> with <literal>USING (a, b)</literal> produces
        the join condition <literal>ON <replaceable>T1</replaceable>.a
        = <replaceable>T2</replaceable>.a AND <replaceable>T1</replaceable>.b
        = <replaceable>T2</replaceable>.b</literal>.
-->
<literal>USING</literal>句は、結合の両側で結合列に同じ名前を使っているという特別な状況の利点を活かすことができる省略形です。
それは、結合テーブルが共通で持つ列名をカンマで区切ったリストから、それぞれの列の等価性を結合条件として生成します。
例えば, <replaceable>T1</replaceable>と<replaceable>T2</replaceable>を<literal>USING (a, b)</literal>を使用して結合する場合は、<literal>ON <replaceable>T1</replaceable>.a = <replaceable>T2</replaceable>.a AND <replaceable>T1</replaceable>.b = <replaceable>T2</replaceable>.b</literal>という結合条件を生成します。
       </para>

       <para>
<!--
        Furthermore, the output of <literal>JOIN USING</literal> suppresses
        redundant columns: there is no need to print both of the matched
        columns, since they must have equal values.  While <literal>JOIN
        ON</literal> produces all columns from <replaceable>T1</replaceable> followed by all
        columns from <replaceable>T2</replaceable>, <literal>JOIN USING</literal> produces one
        output column for each of the listed column pairs (in the listed
        order), followed by any remaining columns from <replaceable>T1</replaceable>,
        followed by any remaining columns from <replaceable>T2</replaceable>.
-->
さらに、<literal>JOIN USING</literal>の出力は、冗長列を抑制します。マッチした列は両方が同じ値を待つので両方を出力する必要がありません。
<literal>JOIN ON</literal> は <replaceable>T1</replaceable> からのすべての列と、それに続く <replaceable>T2</replaceable> からのすべての列を生成します。
<literal>JOIN USING</literal>は指定された列のペアのそれぞれについて１つの出力（結合リストでの指定順）、続いて<replaceable>T1</replaceable>の残りの列、その後に<replaceable>T2</replaceable>の残りの列を出力します。
       </para>

       <para>
        <indexterm>
         <primary>join</primary>
         <secondary>natural</secondary>
        </indexterm>
       <indexterm>
         <primary>結合</primary>
         <secondary>自然</secondary>
        </indexterm>
        <indexterm>
         <primary>natural join</primary>
        </indexterm>
        <indexterm>
         <primary>自然結合</primary>
        </indexterm>
<!--
        Finally, <literal>NATURAL</literal> is a shorthand form of
        <literal>USING</literal>: it forms a <literal>USING</literal> list
        consisting of all column names that appear in both
        input tables.  As with <literal>USING</literal>, these columns appear
        only once in the output table.  If there are no common
        column names, <literal>NATURAL JOIN</literal> behaves like
        <literal>JOIN ... ON TRUE</literal>, producing a cross-product join.
-->
最後に、<literal>NATURAL</literal>は<literal>USING</literal>の略記形式で、２つの入力テーブルの両方に含まれているすべての列名で構成される<literal>USING</literal>リストを形成します。
<literal>USING</literal>と同様、これらの列は出力テーブルに一度だけ現れます。
共通する列が存在しない場合、<literal>NATURAL JOIN</literal>は<literal>JOIN ... ON TRUE</literal>と同様に動作し、クロス積結合を生成します。
       </para>

       <note>
        <para>
<!--
         <literal>USING</literal> is reasonably safe from column changes
         in the joined relations since only the listed columns
         are combined.  <literal>NATURAL</literal> is considerably more risky since
         any schema changes to either relation that cause a new matching
         column name to be present will cause the join to combine that new
         column as well.
-->
<literal>USING</literal>は、リストされている列のみ結合するのでリレーションの列の変更から適度に安全です。
<literal>NATURAL</literal>は、<literal>USING</literal>よりもかなり危険です。
いずれかのリレーションのスキーマ変更により新しくマッチする列名が作られると、結合にその新しい列も使われるようになってしまうからです。
        </para>
       </note>
      </listitem>
     </varlistentry>
    </variablelist>

    <para>
<!--
     To put this together, assume we have tables <literal>t1</literal>:
-->
まとめとして、 以下のテーブル<literal>t1</literal>
<programlisting>
 num | name
-----+------
   1 | a
   2 | b
   3 | c
</programlisting>
<!--
     and <literal>t2</literal>:
-->
および、テーブル<literal>t2</literal>
<programlisting>
 num | value
-----+-------
   1 | xxx
   3 | yyy
   5 | zzz
</programlisting>
<!--
     then we get the following results for the various joins:
-->
を想定すると、以下のように様々な結合に関する結果が得られます。
<screen>
<prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 CROSS JOIN t2;</userinput>
 num | name | num | value
-----+------+-----+-------
   1 | a    |   1 | xxx
   1 | a    |   3 | yyy
   1 | a    |   5 | zzz
   2 | b    |   1 | xxx
   2 | b    |   3 | yyy
   2 | b    |   5 | zzz
   3 | c    |   1 | xxx
   3 | c    |   3 | yyy
   3 | c    |   5 | zzz
(9 rows)

<prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 INNER JOIN t2 ON t1.num = t2.num;</userinput>
 num | name | num | value
-----+------+-----+-------
   1 | a    |   1 | xxx
   3 | c    |   3 | yyy
(2 rows)

<prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 INNER JOIN t2 USING (num);</userinput>
 num | name | value
-----+------+-------
   1 | a    | xxx
   3 | c    | yyy
(2 rows)

<prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 NATURAL INNER JOIN t2;</userinput>
 num | name | value
-----+------+-------
   1 | a    | xxx
   3 | c    | yyy
(2 rows)

<prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 LEFT JOIN t2 ON t1.num = t2.num;</userinput>
 num | name | num | value
-----+------+-----+-------
   1 | a    |   1 | xxx
   2 | b    |     |
   3 | c    |   3 | yyy
(3 rows)

<prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 LEFT JOIN t2 USING (num);</userinput>
 num | name | value
-----+------+-------
   1 | a    | xxx
   2 | b    |
   3 | c    | yyy
(3 rows)

<prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 RIGHT JOIN t2 ON t1.num = t2.num;</userinput>
 num | name | num | value
-----+------+-----+-------
   1 | a    |   1 | xxx
   3 | c    |   3 | yyy
     |      |   5 | zzz
(3 rows)

<prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 FULL JOIN t2 ON t1.num = t2.num;</userinput>
 num | name | num | value
-----+------+-----+-------
   1 | a    |   1 | xxx
   2 | b    |     |
   3 | c    |   3 | yyy
     |      |   5 | zzz
(4 rows)
</screen>
    </para>

    <para>
<!--
     The join condition specified with <literal>ON</literal> can also contain
     conditions that do not relate directly to the join.  This can
     prove useful for some queries but needs to be thought out
     carefully.  For example:
-->
<literal>ON</literal>で指定される結合条件には、結合に直接関係しない条件も含めることができます。
これは一部の問い合わせにおいては便利ですが、使用の際には注意が必要です。
例を示します。
<screen>
<prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 LEFT JOIN t2 ON t1.num = t2.num AND t2.value = 'xxx';</userinput>
 num | name | num | value
-----+------+-----+-------
   1 | a    |   1 | xxx
   2 | b    |     |
   3 | c    |     |
(3 rows)
</screen>
<!--
     Notice that placing the restriction in the <literal>WHERE</literal> clause
     produces a different result:
-->
<literal>WHERE</literal>句の中に制約を記述すると異なる結果になることに注意してください。
<screen>
<prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 LEFT JOIN t2 ON t1.num = t2.num WHERE t2.value = 'xxx';</userinput>
 num | name | num | value
-----+------+-----+-------
   1 | a    |   1 | xxx
(1 row)
</screen>
<!--
     This is because a restriction placed in the <literal>ON</literal>
     clause is processed <emphasis>before</emphasis> the join, while
     a restriction placed in the <literal>WHERE</literal> clause is processed
     <emphasis>after</emphasis> the join.
     That does not matter with inner joins, but it matters a lot with outer
     joins.
-->
この理由は<literal>ON</literal>句の中の制約は結合の<emphasis>前</emphasis>に処理され、一方<literal>WHERE</literal>句の中の制約は結合の<emphasis>後</emphasis>に処理されることによります。
これは内部結合には影響がありませんが、外部結合には大きな影響があります。
    </para>
   </sect3>

   <sect3 id="queries-table-aliases">
<!--
    <title>Table and Column Aliases</title>
-->
    <title>テーブルと列の別名</title>

    <indexterm zone="queries-table-aliases">
     <primary>alias</primary>
     <secondary>in the FROM clause</secondary>
    </indexterm>
    <indexterm zone="queries-table-aliases">
     <primary>別名</primary>
     <secondary>FROM句内の</secondary>
    </indexterm>

    <indexterm>
     <primary>label</primary>
     <see>alias</see>
    </indexterm>
    <indexterm>
     <primary>ラベル</primary>
     <see>別名</see>
    </indexterm>

    <para>
<!--
     A temporary name can be given to tables and complex table
     references to be used for references to the derived table in
     the rest of the query.  This is called a <firstterm>table
     alias</firstterm>.
-->
テーブルや複雑なテーブル参照に一時的な名前を付与し、問い合わせの以降の部分では、その名前を使ってテーブルや複雑なテーブル参照を利用することができます。
これを<firstterm>テーブルの別名</firstterm>と呼びます。
    </para>

    <para>
<!--
     To create a table alias, write
-->
テーブルの別名を作成するには以下のようにします。
<synopsis>
FROM <replaceable>table_reference</replaceable> AS <replaceable>alias</replaceable>
</synopsis>
<!--
     or
-->
もしくは
<synopsis>
FROM <replaceable>table_reference</replaceable> <replaceable>alias</replaceable>
</synopsis>
<!--
     The <literal>AS</literal> key word is optional noise.
     <replaceable>alias</replaceable> can be any identifier.
-->
<literal>AS</literal>キーワードはなくても構わないノイズです。
<replaceable>alias</replaceable>は任意の識別子になります。
    </para>

    <para>
<!--
     A typical application of table aliases is to assign short
     identifiers to long table names to keep the join clauses
     readable.  For example:
-->
テーブルの別名の一般的な適用法は、長いテーブル名に短縮した識別子を割り当てて結合句を読みやすくすることです。
例を示します。
<programlisting>
SELECT * FROM some_very_long_table_name s JOIN another_fairly_long_name a ON s.id = a.num;
</programlisting>
    </para>

    <para>
<!--
     The alias becomes the new name of the table reference so far as the
     current query is concerned &mdash; it is not allowed to refer to the
     table by the original name elsewhere in the query.  Thus, this is not
     valid:
-->
現在の問い合わせに関しては、別名がテーブル参照をする時の新しい名前になります。
問い合わせの他の場所で元々の名前でテーブルを参照することはできなくなります。
よって、次の例は有効ではありません。
<programlisting>
<!--
SELECT * FROM my_table AS m WHERE my_table.a &gt; 5;    &#045;&#045; wrong
-->
SELECT * FROM my_table AS m WHERE my_table.a &gt; 5;    -- 間違い
</programlisting>
    </para>

    <para>
<!--
     Table aliases are mainly for notational convenience, but it is
     necessary to use them when joining a table to itself, e.g.:
-->
テーブルの別名は主に表記を簡単にするためにあります。
しかし次のように、1つのテーブルが自分自身と結合する場合は、必須となります。
<programlisting>
SELECT * FROM people AS mother JOIN people AS child ON mother.id = child.mother_id;
</programlisting>
<!--
     Additionally, an alias is required if the table reference is a
     subquery (see <xref linkend="queries-subqueries"/>).
-->
さらに、テーブル参照が副問い合わせ（<xref linkend="queries-subqueries"/>を参照）の場合に別名が必要になります。
    </para>

    <para>
<!--
     Parentheses are used to resolve ambiguities.  In the following example,
     the first statement assigns the alias <literal>b</literal> to the second
     instance of <literal>my_table</literal>, but the second statement assigns the
     alias to the result of the join:
-->
括弧は曖昧さをなくすために使われます。
次の例では、最初の文で2つ目の<literal>my_table</literal>のインスタンスに<literal>b</literal>という別名を付与し、一方、2つ目の文では結合結果に対して別名を付与しています。
<programlisting>
SELECT * FROM my_table AS a CROSS JOIN my_table AS b ...
SELECT * FROM (my_table AS a CROSS JOIN my_table) AS b ...
</programlisting>
    </para>

    <para>
<!--
     Another form of table aliasing gives temporary names to the columns of
     the table, as well as the table itself:
-->
次のような形式でテーブル別名を付けて、テーブル自身と同様にテーブルの列に一時的な名前を付けることができます。
<synopsis>
FROM <replaceable>table_reference</replaceable> <optional>AS</optional> <replaceable>alias</replaceable> ( <replaceable>column1</replaceable> <optional>, <replaceable>column2</replaceable> <optional>, ...</optional></optional> )
</synopsis>
<!--
     If fewer column aliases are specified than the actual table has
     columns, the remaining columns are not renamed.  This syntax is
     especially useful for self-joins or subqueries.
-->
もし、実際のテーブルが持つ列よりも少ない数の列の別名が与えられる場合、残りの列は改名されません。
この構文は、自己結合あるいは副問い合わせで特に役立ちます。
    </para>

    <para>
<!--
     When an alias is applied to the output of a <literal>JOIN</literal>
     clause, the alias hides the original
     name(s) within the <literal>JOIN</literal>.  For example:
-->
別名が<literal>JOIN</literal>句の結果に適用される場合、別名は<literal>JOIN</literal>内で参照される元々の名を隠します。
以下に例を示します。
<programlisting>
SELECT a.* FROM my_table AS a JOIN your_table AS b ON ...
</programlisting>
<!--
     is valid SQL, but:
-->
は有効なSQLですが、
<programlisting>
SELECT a.* FROM (my_table AS a JOIN your_table AS b ON ...) AS c
</programlisting>
<!--
     is not valid; the table alias <literal>a</literal> is not visible
     outside the alias <literal>c</literal>.
-->
は有効ではありません。
テーブルの別名<literal>a</literal>は、別名<literal>c</literal>の外側では参照することができません。
    </para>
   </sect3>

   <sect3 id="queries-subqueries">
<!--
    <title>Subqueries</title>
-->
    <title>副問い合わせ</title>

    <indexterm zone="queries-subqueries">
     <primary>subquery</primary>
    </indexterm>
    <indexterm zone="queries-subqueries">
     <primary>副問い合わせ</primary>
    </indexterm>

    <para>
<!--
     Subqueries specifying a derived table must be enclosed in
     parentheses and <emphasis>must</emphasis> be assigned a table
     alias name (as in <xref linkend="queries-table-aliases"/>).  For
     example:
-->
派生テーブルを指定する副問い合わせは括弧で囲む必要があります。
また、（<xref linkend="queries-table-aliases"/>にあるように）<emphasis>必ず</emphasis>テーブル別名が割り当てられている必要があります。
例を示します。
<programlisting>
FROM (SELECT * FROM table1) AS alias_name
</programlisting>
    </para>

    <para>
<!--
     This example is equivalent to <literal>FROM table1 AS
     alias_name</literal>.  More interesting cases, which cannot be
     reduced to a plain join, arise when the subquery involves
     grouping or aggregation.
-->
この例は<literal>FROM table1 AS alias_name</literal>と同じです。
副問い合わせがグループ化や集約を含んでいる場合は、単純結合にまとめることはできない、より重要な例が発生します。
    </para>

    <para>
<!--
     A subquery can also be a <command>VALUES</command> list:
-->
また、副問い合わせを<command>VALUES</command>リストとすることもできます。
<programlisting>
FROM (VALUES ('anne', 'smith'), ('bob', 'jones'), ('joe', 'blow'))
     AS names(first, last)
</programlisting>
<!--
     Again, a table alias is required.  Assigning alias names to the columns
     of the <command>VALUES</command> list is optional, but is good practice.
     For more information see <xref linkend="queries-values"/>.
-->
繰り返しますが、テーブルの別名が必要です。
<command>VALUES</command>リストの列に別名を付与することは省略することもできますが、付与することを勧めます。
<xref linkend="queries-values"/>を参照してください。
    </para>
   </sect3>

   <sect3 id="queries-tablefunctions">
<!--
    <title>Table Functions</title>
-->
    <title>テーブル関数</title>

    <indexterm zone="queries-tablefunctions"><primary>table function</primary></indexterm>
    <indexterm zone="queries-tablefunctions"><primary>テーブル関数</primary></indexterm>

    <indexterm zone="queries-tablefunctions">
     <primary>function</primary>
     <secondary>in the FROM clause</secondary>
    </indexterm>
    <indexterm zone="queries-tablefunctions">
     <primary>関数</primary>
     <secondary>FROM句内の</secondary>
    </indexterm>

    <para>
<!--
     Table functions are functions that produce a set of rows, made up
     of either base data types (scalar types) or composite data types
     (table rows).  They are used like a table, view, or subquery in
     the <literal>FROM</literal> clause of a query. Columns returned by table
     functions can be included in <literal>SELECT</literal>,
     <literal>JOIN</literal>, or <literal>WHERE</literal> clauses in the same manner
     as columns of a table, view, or subquery.
-->
テーブル関数は、基本データ型（スカラ型）、もしくは複合データ型（テーブル行）からなる行の集合を生成する関数です。
これらは、問い合わせの<literal>FROM</literal>句内でテーブル、ビュー、副問い合わせのように使用されます。
テーブル関数から返される列は、テーブル、ビュー、副問い合わせの列と同様の手順で、<literal>SELECT</literal>、<literal>JOIN</literal>、<literal>WHERE</literal>の中に含めることができます。
    </para>

    <para>
<!--
     Table functions may also be combined using the <literal>ROWS FROM</literal>
     syntax, with the results returned in parallel columns; the number of
     result rows in this case is that of the largest function result, with
     smaller results padded with null values to match.
-->
テーブル関数は<literal>ROWS FROM</literal>構文を使用することで、それらの返却列を一緒に組み合わせることもできます。
このときの結果の行数は、行数が最大となる関数の結果と同じになり、少ない結果側は多い結果に合わせてnull値で埋められます。
    </para>

<synopsis>
<replaceable>function_call</replaceable> <optional>WITH ORDINALITY</optional> <optional><optional>AS</optional> <replaceable>table_alias</replaceable> <optional>(<replaceable>column_alias</replaceable> <optional>, ... </optional>)</optional></optional>
ROWS FROM( <replaceable>function_call</replaceable> <optional>, ... </optional> ) <optional>WITH ORDINALITY</optional> <optional><optional>AS</optional> <replaceable>table_alias</replaceable> <optional>(<replaceable>column_alias</replaceable> <optional>, ... </optional>)</optional></optional>
</synopsis>

    <para>
<!--
     If the <literal>WITH ORDINALITY</literal> clause is specified, an
     additional column of type <type>bigint</type> will be added to the
     function result columns.  This column numbers the rows of the function
     result set, starting from 1. (This is a generalization of the
     SQL-standard syntax for <literal>UNNEST ... WITH ORDINALITY</literal>.)
     By default, the ordinal column is called <literal>ordinality</literal>, but
     a different column name can be assigned to it using
     an <literal>AS</literal> clause.
-->
WITH ORDINALITY句が指定されている場合、関数の結果の列に<type>bigint</type>型の列が追加されます。
この列は関数の結果の行を1から数えます。
（これは標準SQLの構文<literal>UNNEST ... WITH ORDINALITY</literal>の一般化です。）
デフォルトでは、この序数(ordinal)の列は<literal>ordinality</literal>になります。しかし別の名前を<literal>AS</literal>句を使用して別名を割り当てることができます。
    </para>

    <para>
<!--
     The special table function <literal>UNNEST</literal> may be called with
     any number of array parameters, and it returns a corresponding number of
     columns, as if <literal>UNNEST</literal>
     (<xref linkend="functions-array"/>) had been called on each parameter
     separately and combined using the <literal>ROWS FROM</literal> construct.
-->
特別なテーブル関数<literal>UNNEST</literal>は、任意の数の配列パラメータで呼ぶことができます。
そしてそれは、対応する数の列を返し、あたかも<literal>UNNEST</literal>(<xref linkend="functions-array"/>)が各パラメータ毎に<literal>ROWS FROM</literal>構文を使用して結合されているかのようになります。
    </para>

<synopsis>
UNNEST( <replaceable>array_expression</replaceable> <optional>, ... </optional> ) <optional>WITH ORDINALITY</optional> <optional><optional>AS</optional> <replaceable>table_alias</replaceable> <optional>(<replaceable>column_alias</replaceable> <optional>, ... </optional>)</optional></optional>
</synopsis>

    <para>
<!--
     If no <replaceable>table_alias</replaceable> is specified, the function
     name is used as the table name; in the case of a <literal>ROWS FROM()</literal>
     construct, the first function's name is used.
-->
<replaceable>table_alias</replaceable>が指定されない場合、テーブル名として関数名が使用されます。
<literal>ROWS FROM()</literal>の場合は最初の関数名が使用されます。
    </para>

    <para>
<!--
     If column aliases are not supplied, then for a function returning a base
     data type, the column name is also the same as the function name.  For a
     function returning a composite type, the result columns get the names
     of the individual attributes of the type.
-->
列に別名が提供されない場合、基本データ型を返す関数に対しては、列名も関数名と同じになります。
複合型を返す関数の場合は、結果の列は型の個々の属性の名前を取得します。
    </para>

    <para>
<!--
     Some examples:
-->
以下に数例示します。
<programlisting>
CREATE TABLE foo (fooid int, foosubid int, fooname text);

CREATE FUNCTION getfoo(int) RETURNS SETOF foo AS $$
    SELECT * FROM foo WHERE fooid = $1;
$$ LANGUAGE SQL;

SELECT * FROM getfoo(1) AS t1;

SELECT * FROM foo
    WHERE foosubid IN (
                        SELECT foosubid
                        FROM getfoo(foo.fooid) z
                        WHERE z.fooid = foo.fooid
                      );

CREATE VIEW vw_getfoo AS SELECT * FROM getfoo(1);

SELECT * FROM vw_getfoo;
</programlisting>
    </para>

    <para>
<!--
     In some cases it is useful to define table functions that can
     return different column sets depending on how they are invoked.
     To support this, the table function can be declared as returning
     the pseudo-type <type>record</type> with no <literal>OUT</literal>
     parameters.  When such a function is used in
     a query, the expected row structure must be specified in the
     query itself, so that the system can know how to parse and plan
     the query.  This syntax looks like:
-->
呼び出し方法に応じて異なる列集合を返すテーブル関数を定義することが役に立つ場合があります。
これをサポートするために、テーブル関数は<literal>OUT</literal>パラメータを持たない<type>record</type>擬似型を返すものと宣言することができます。
こうした関数を問い合わせで使用する場合、システムがその問い合わせをどのように解析し計画を作成すればよいのかが判断できるように、想定した行構造を問い合わせ自身内に指定しなければなりません。
この構文は次のようになります。
    </para>

<synopsis>
<replaceable>function_call</replaceable> <optional>AS</optional> <replaceable>alias</replaceable> (<replaceable>column_definition</replaceable> <optional>, ... </optional>)
<replaceable>function_call</replaceable> AS <optional><replaceable>alias</replaceable></optional> (<replaceable>column_definition</replaceable> <optional>, ... </optional>)
ROWS FROM( ... <replaceable>function_call</replaceable> AS (<replaceable>column_definition</replaceable> <optional>, ... </optional>) <optional>, ... </optional> )
</synopsis>

    <para>
<!--
     When not using the <literal>ROWS FROM()</literal> syntax,
     the <replaceable>column_definition</replaceable> list replaces the column
     alias list that could otherwise be attached to the <literal>FROM</literal>
     item; the names in the column definitions serve as column aliases.
     When using the <literal>ROWS FROM()</literal> syntax,
     a <replaceable>column_definition</replaceable> list can be attached to
     each member function separately; or if there is only one member function
     and no <literal>WITH ORDINALITY</literal> clause,
     a <replaceable>column_definition</replaceable> list can be written in
     place of a column alias list following <literal>ROWS FROM()</literal>.
-->
<literal>ROWS FROM()</literal>構文を使用しない場合は、<replaceable>column_definition</replaceable>のリストが<literal>FROM</literal>項目に取り付けることができる列の別名の代わりとなります。
列の定義内の名前は、列の別名として機能します。
<literal>ROWS FROM()</literal>構文を使用する場合は、<replaceable>column_definition</replaceable>リストを個別に各メンバー関数に添付することができます。
またはメンバ関数が1つだけしかなく、かつ<literal>WITH ORDINALITY</literal>句がない場合は、<replaceable>column_definition</replaceable>リストを、<literal>ROWS FROM()</literal>の後ろの列別名のリストの場所に書くことができます。
    </para>

    <para>
<!--
     Consider this example:
-->
以下の例を考えます。

<programlisting>
SELECT *
    FROM dblink('dbname=mydb', 'SELECT proname, prosrc FROM pg_proc')
      AS t1(proname name, prosrc text)
    WHERE proname LIKE 'bytea%';
</programlisting>
<!--
     The <xref linkend="contrib-dblink-function"/> function
     (part of the <xref linkend="dblink"/> module) executes
     a remote query.  It is declared to return
     <type>record</type> since it might be used for any kind of query.
     The actual column set must be specified in the calling query so
     that the parser knows, for example, what <literal>*</literal> should
     expand to.
-->
<xref linkend="contrib-dblink-function"/>関数（<xref linkend="dblink"/>モジュールの一部）は遠隔問い合わせを実行します。
これは任意の問い合わせで使用できるように、<type>record</type>を返すものと宣言されています。
実際の列集合は、パーサが例えば<literal>*</literal>がどのように展開されるかを理解できるように、呼び出した問い合わせ内で指定されなければなりません。
    </para>

    <para>
<!--
     This example uses <literal>ROWS FROM</literal>:
-->
<literal>ROWS FROM</literal>を使用した例:
<programlisting>
SELECT *
FROM ROWS FROM
    (
        json_to_recordset('[{"a":40,"b":"foo"},{"a":"100","b":"bar"}]')
            AS (a INTEGER, b TEXT),
        generate_series(1, 3)
    ) AS x (p, q, s)
ORDER BY p;

  p  |  q  | s
-----+-----+---
  40 | foo | 1
 100 | bar | 2
     |     | 3
</programlisting>
<!--
     It joins two functions into a single <literal>FROM</literal>
     target.  <function>json_to_recordset()</function> is instructed
     to return two columns, the first <type>integer</type>
     and the second <type>text</type>.  The result of
     <function>generate_series()</function> is used directly.
     The <literal>ORDER BY</literal> clause sorts the column values
     as integers.
-->
2つの関数を結合して1つの<literal>FROM</literal>ターゲットにします。
<function>json_to_recordset()</function>は、2つの列(最初の<type>integer</type>と2番目の<type>text</type>)を返すように指示されます。
<function>generate_series()</function>の結果は直接使用されます。
<literal>ORDER BY</literal>句では、列値が整数として並べ替えられます。
    </para>
   </sect3>

   <sect3 id="queries-lateral">
<!--
    <title><literal>LATERAL</literal> Subqueries</title>
-->
    <title><literal>LATERAL</literal> 副問い合わせ</title>

    <indexterm zone="queries-lateral">
     <primary>LATERAL</primary>
     <secondary>in the FROM clause</secondary>
    </indexterm>
    <indexterm zone="queries-lateral">
     <primary>LATERAL</primary>
     <secondary>FROM句内の</secondary>
    </indexterm>

    <para>
<!--
     Subqueries appearing in <literal>FROM</literal> can be
     preceded by the key word <literal>LATERAL</literal>.  This allows them to
     reference columns provided by preceding <literal>FROM</literal> items.
     (Without <literal>LATERAL</literal>, each subquery is
     evaluated independently and so cannot cross-reference any other
     <literal>FROM</literal> item.)
-->
<literal>FROM</literal>に現れる副問い合わせの前にキーワード<literal>LATERAL</literal>を置くことができます。
こうすると、副問い合わせは先行する<literal>FROM</literal>項目によって提供される列を参照できます。
（<literal>LATERAL</literal>がない場合、それぞれの副問い合わせは個別に評価され、従ってその他の<literal>FROM</literal>項目を相互参照できません。）
    </para>

    <para>
<!--
     Table functions appearing in <literal>FROM</literal> can also be
     preceded by the key word <literal>LATERAL</literal>, but for functions the
     key word is optional; the function's arguments can contain references
     to columns provided by preceding <literal>FROM</literal> items in any case.
-->
<literal>FROM</literal>に現れるテーブル関数の前にもキーワード<literal>LATERAL</literal>を置くことが可能ですが、関数に対してこのキーワードは省略可能です。
どんな場合であっても、関数の引数は先行する <literal>FROM</literal>項目により提供される列の参照を含むことができます。
    </para>

    <para>
<!--
     A <literal>LATERAL</literal> item can appear at top level in the
     <literal>FROM</literal> list, or within a <literal>JOIN</literal> tree.  In the latter
     case it can also refer to any items that are on the left-hand side of a
     <literal>JOIN</literal> that it is on the right-hand side of.
-->
<literal>LATERAL</literal>項目は<literal>FROM</literal>リストの最上層、または<literal>JOIN</literal>木の中で表示することができます。
後者の場合、右側にある<literal>JOIN</literal>の左側のすべての項目を参照することが可能です。
    </para>

    <para>
<!--
     When a <literal>FROM</literal> item contains <literal>LATERAL</literal>
     cross-references, evaluation proceeds as follows: for each row of the
     <literal>FROM</literal> item providing the cross-referenced column(s), or
     set of rows of multiple <literal>FROM</literal> items providing the
     columns, the <literal>LATERAL</literal> item is evaluated using that
     row or row set's values of the columns.  The resulting row(s) are
     joined as usual with the rows they were computed from.  This is
     repeated for each row or set of rows from the column source table(s).
-->
<literal>FROM</literal>項目が<literal>LATERAL</literal>相互参照を含む場合の評価は以下のようになります。
相互参照される列（複数可）を提供する<literal>FROM</literal>項目のそれぞれの行、もしくは列を提供する複数の<literal>FROM</literal>項目の行一式に対し、<literal>LATERAL</literal>項目は列の行または複数行の一式の値により評価されます。
結果行（複数可）は通常のように演算された行と結合されます。
元となるテーブル（複数可）の列からそれぞれの行、または行の一式に対し反復されます。
    </para>

    <para>
<!--
     A trivial example of <literal>LATERAL</literal> is
-->
<literal>LATERAL</literal>の些細な例としては以下があげられます。
<programlisting>
SELECT * FROM foo, LATERAL (SELECT * FROM bar WHERE bar.id = foo.bar_id) ss;
</programlisting>
<!--
     This is not especially useful since it has exactly the same result as
     the more conventional
-->
上記は以下のより伝統的なやり方と全く同じ結果をもたらしますので特別に有用ではありません。
<programlisting>
SELECT * FROM foo, bar WHERE bar.id = foo.bar_id;
</programlisting>
<!--
     <literal>LATERAL</literal> is primarily useful when the cross-referenced
     column is necessary for computing the row(s) to be joined.  A common
     application is providing an argument value for a set-returning function.
     For example, supposing that <function>vertices(polygon)</function> returns the
     set of vertices of a polygon, we could identify close-together vertices
     of polygons stored in a table with:
-->
<literal>LATERAL</literal>は、結合される行を計算するために相互参照する列を必須とする場合、第一義的に有用です。
一般的な利用方法は、集合を返す関数に対して引数の値を提供することです。
例えば、<function>vertices(polygon)</function>が多角形の頂点の組みを返す関数だとして、以下のようにしてテーブルに格納されている多角形の互いに近接する頂点を特定できます。
<programlisting>
SELECT p1.id, p2.id, v1, v2
FROM polygons p1, polygons p2,
     LATERAL vertices(p1.poly) v1,
     LATERAL vertices(p2.poly) v2
WHERE (v1 &lt;-&gt; v2) &lt; 10 AND p1.id != p2.id;
</programlisting>
<!--
     This query could also be written
-->
この問い合わせは以下のようにも書くことができます。
<programlisting>
SELECT p1.id, p2.id, v1, v2
FROM polygons p1 CROSS JOIN LATERAL vertices(p1.poly) v1,
     polygons p2 CROSS JOIN LATERAL vertices(p2.poly) v2
WHERE (v1 &lt;-&gt; v2) &lt; 10 AND p1.id != p2.id;
</programlisting>
<!--
     or in several other equivalent formulations.  (As already mentioned,
     the <literal>LATERAL</literal> key word is unnecessary in this example, but
     we use it for clarity.)
-->
そのほか幾つかの同等の定式化が考えられます。
（既に言及したとおり、<literal>LATERAL</literal>キーワードはこの例に於いて必要ではありませんが、明確に示すために使用しました。）
    </para>

    <para>
<!--
     It is often particularly handy to <literal>LEFT JOIN</literal> to a
     <literal>LATERAL</literal> subquery, so that source rows will appear in
     the result even if the <literal>LATERAL</literal> subquery produces no
     rows for them.  For example, if <function>get_product_names()</function> returns
     the names of products made by a manufacturer, but some manufacturers in
     our table currently produce no products, we could find out which ones
     those are like this:
-->
<literal>LATERAL</literal>副問い合わせは<literal>LEFT JOIN</literal>の対象として、しばしば特に重宝します。
たとえ<literal>LATERAL</literal>副問い合わせがそこから行を生成しない場合に於いても元となった行が結果に現れるからです。
たとえば、<function>get_product_names()</function>が製造者により生産された製品名を返すとして、テーブル内のいくつかの製造者が現在製品を製造していない場合、それらは何であるかを以下のようにして見つけることができます。
<programlisting>
SELECT m.name
FROM manufacturers m LEFT JOIN LATERAL get_product_names(m.id) pname ON true
WHERE pname IS NULL;
</programlisting>
    </para>
   </sect3>
  </sect2>

  <sect2 id="queries-where">
<!--
   <title>The <literal>WHERE</literal> Clause</title>
-->
   <title><literal>WHERE</literal>句</title>

   <indexterm zone="queries-where">
    <primary>WHERE</primary>
   </indexterm>

   <para>
<!--
    The syntax of the <link linkend="sql-where"><literal>WHERE</literal></link>
    clause is
-->
<link linkend="sql-where"><literal>WHERE</literal></link>句の構文は以下の通りです。
<synopsis>
WHERE <replaceable>search_condition</replaceable>
</synopsis>
<!--
    where <replaceable>search_condition</replaceable> is any value
    expression (see <xref linkend="sql-expressions"/>) that
    returns a value of type <type>boolean</type>.
-->
ここで、<replaceable>search_condition</replaceable>には<type>boolean</type>型を返すどのような評価式（<xref linkend="sql-expressions"/>を参照）も指定できます。
   </para>

   <para>
<!--
    After the processing of the <literal>FROM</literal> clause is done, each
    row of the derived virtual table is checked against the search
    condition.  If the result of the condition is true, the row is
    kept in the output table, otherwise (i.e., if the result is
    false or null) it is discarded.  The search condition typically
    references at least one column of the table generated in the
    <literal>FROM</literal> clause; this is not required, but otherwise the
    <literal>WHERE</literal> clause will be fairly useless.
-->
<literal>FROM</literal>句の処理が終わった後、派生した仮想テーブルの各行は検索条件と照合されます。
条件の結果が真の場合、その行は出力されます。
そうでない（すなわち結果が偽またはNULLの）場合は、その行は捨てられます。
一般的に検索条件は、<literal>FROM</literal>句で生成されたテーブルの最低１列を参照します。
これは必須ではありませんが、そうしないと<literal>WHERE</literal>句はまったく意味がなくなります。
   </para>

   <note>
    <para>
<!--
     The join condition of an inner join can be written either in
     the <literal>WHERE</literal> clause or in the <literal>JOIN</literal> clause.
     For example, these table expressions are equivalent:
-->
内部結合の結合条件は、<literal>WHERE</literal>句でも<literal>JOIN</literal>句でも記述することができます。
例えば、以下のテーブル式は等価です。
<programlisting>
FROM a, b WHERE a.id = b.id AND b.val &gt; 5
</programlisting>
<!--
     and:
-->
および
<programlisting>
FROM a INNER JOIN b ON (a.id = b.id) WHERE b.val &gt; 5
</programlisting>
<!--
     or perhaps even:
-->
また、以下でも同じです。
<programlisting>
FROM a NATURAL JOIN b WHERE b.val &gt; 5
</programlisting>
<!--
     Which one of these you use is mainly a matter of style.  The
     <literal>JOIN</literal> syntax in the <literal>FROM</literal> clause is
     probably not as portable to other SQL database management systems,
     even though it is in the SQL standard.  For
     outer joins there is no choice:  they must be done in
     the <literal>FROM</literal> clause.  The <literal>ON</literal> or <literal>USING</literal>
     clause of an outer join is <emphasis>not</emphasis> equivalent to a
     <literal>WHERE</literal> condition, because it results in the addition
     of rows (for unmatched input rows) as well as the removal of rows
     in the final result.
-->
どれを使うかは、主にスタイルの問題です。
<literal>FROM</literal>句の<literal>JOIN</literal>構文はSQL標準であるにも関わらず、おそらく他のSQLデータベース管理システムへの移植性では劣るでしょう。
外部結合については、<literal>FROM</literal>句以外に選択の余地はありません。
外部結合の<literal>ON</literal>句または<literal>USING</literal>句は、<literal>WHERE</literal>条件とは等しく<emphasis>ありません</emphasis>。
なぜなら、最終結果での行を除去すると同様に、（一致しない入力行に対する）行の追加となるからです。
    </para>
   </note>

   <para>
<!--
    Here are some examples of <literal>WHERE</literal> clauses:
-->
<literal>WHERE</literal>句の例を以下に示します。
<programlisting>
SELECT ... FROM fdt WHERE c1 &gt; 5

SELECT ... FROM fdt WHERE c1 IN (1, 2, 3)

SELECT ... FROM fdt WHERE c1 IN (SELECT c1 FROM t2)

SELECT ... FROM fdt WHERE c1 IN (SELECT c3 FROM t2 WHERE c2 = fdt.c1 + 10)

SELECT ... FROM fdt WHERE c1 BETWEEN (SELECT c3 FROM t2 WHERE c2 = fdt.c1 + 10) AND 100

SELECT ... FROM fdt WHERE EXISTS (SELECT c1 FROM t2 WHERE c2 &gt; fdt.c1)
</programlisting>
<!--
    <literal>fdt</literal> is the table derived in the
    <literal>FROM</literal> clause. Rows that do not meet the search
    condition of the <literal>WHERE</literal> clause are eliminated from
    <literal>fdt</literal>. Notice the use of scalar subqueries as
    value expressions.  Just like any other query, the subqueries can
    employ complex table expressions.  Notice also how
    <literal>fdt</literal> is referenced in the subqueries.
    Qualifying <literal>c1</literal> as <literal>fdt.c1</literal> is only necessary
    if <literal>c1</literal> is also the name of a column in the derived
    input table of the subquery.  But qualifying the column name adds
    clarity even when it is not needed.  This example shows how the column
    naming scope of an outer query extends into its inner queries.
-->
<literal>fdt</literal>は<literal>FROM</literal>句で派生されたテーブルです。
<literal>WHERE</literal>句の検索条件を満たさなかった行は、<literal>fdt</literal>から削除されます。
評価式としてのスカラ副問い合わせの使い方に注目してください。
他の問い合わせのように、副問い合わせは複雑なテーブル式を使うことができます。
副問い合わせの中でどのように<literal>fdt</literal>が参照されるかにも注意してください。
<literal>c1</literal>を<literal>fdt.c1</literal>のように修飾することは、<literal>c1</literal>が副問い合わせの入力テーブルから派生した列名でもある時にだけ必要です。
列名の修飾は、必須の場合ではなくても、明確にするために役立ちます。
この例は、外側の問い合わせの列名の有効範囲を、どのようにして内側の問い合わせまで拡張するかを示します。
   </para>
  </sect2>


  <sect2 id="queries-group">
<!--
   <title>The <literal>GROUP BY</literal> and <literal>HAVING</literal> Clauses</title>
-->
   <title><literal>GROUP BY</literal>句と<literal>HAVING</literal>句</title>

   <indexterm zone="queries-group">
    <primary>GROUP BY</primary>
   </indexterm>

   <indexterm zone="queries-group">
    <primary>grouping</primary>
   </indexterm>
   <indexterm zone="queries-group">
    <primary>グループ化</primary>
   </indexterm>

   <para>
<!--
    After passing the <literal>WHERE</literal> filter, the derived input
    table might be subject to grouping, using the <literal>GROUP BY</literal>
    clause, and elimination of group rows using the <literal>HAVING</literal>
    clause.
-->
<literal>WHERE</literal>フィルタを通した後、派生された入力テーブルを<literal>GROUP BY</literal>句でグループ化し、また、<literal>HAVING</literal>句を使用して不要なグループを取り除くことができます。
   </para>

<synopsis>
SELECT <replaceable>select_list</replaceable>
    FROM ...
    <optional>WHERE ...</optional>
    GROUP BY <replaceable>grouping_column_reference</replaceable> <optional>, <replaceable>grouping_column_reference</replaceable></optional>...
</synopsis>

   <para>
<!--
    The <link linkend="sql-groupby"><literal>GROUP BY</literal></link> clause is
    used to group together those rows in a table that have the same
    values in all the columns listed. The order in which the columns
    are listed does not matter.  The effect is to combine each set
    of rows having common values into one group row that
    represents all rows in the group.  This is done to
    eliminate redundancy in the output and/or compute aggregates that
    apply to these groups.  For instance:
-->
<link linkend="sql-groupby"><literal>GROUP BY</literal></link>句は、列挙されたすべての列で同じ値を所有する行をまとめてグループ化するために使用されます。
列の列挙順は関係ありません。
これは共通する値を持つそれぞれの行の集合をグループ内のすべての行を代表する１つのグループ行にまとめるものです。
これは、出力の冗長度を排除したり、それぞれのグループに適用される集約計算を行うためのものです。
以下に例を示します。
<screen>
<prompt>=&gt;</prompt> <userinput>SELECT * FROM test1;</userinput>
 x | y
---+---
 a | 3
 c | 2
 b | 5
 a | 1
(4 rows)

<prompt>=&gt;</prompt> <userinput>SELECT x FROM test1 GROUP BY x;</userinput>
 x
---
 a
 b
 c
(3 rows)
</screen>
   </para>

   <para>
<!--
    In the second query, we could not have written <literal>SELECT *
    FROM test1 GROUP BY x</literal>, because there is no single value
    for the column <literal>y</literal> that could be associated with each
    group.  The grouped-by columns can be referenced in the select list since
    they have a single value in each group.
-->
2番目の問い合わせでは、<literal>SELECT * FROM test1 GROUP BY x</literal>と書くことはできません。
各グループに関連付けられる列<literal>y</literal>の単一の値がないからです。
<literal>GROUP BY</literal>で指定した列はグループごとに単一の値を持つので、選択リストで参照することができます。
   </para>

   <para>
<!--
    In general, if a table is grouped, columns that are not
    listed in <literal>GROUP BY</literal> cannot be referenced except in aggregate
    expressions.  An example with aggregate expressions is:
-->
一般的に、テーブルがグループ化されている場合、<literal>GROUP BY</literal>でリストされていない列は集約式を除いて参照することはできません。
集約式の例は以下の通りです。
<screen>
<prompt>=&gt;</prompt> <userinput>SELECT x, sum(y) FROM test1 GROUP BY x;</userinput>
 x | sum
---+-----
 a |   4
 b |   5
 c |   2
(3 rows)
</screen>
<!--
    Here <literal>sum</literal> is an aggregate function that
    computes a single value over the entire group.  More information
    about the available aggregate functions can be found in <xref
    linkend="functions-aggregate"/>.
-->
上記で<literal>sum()</literal> は、グループ全体について単一の値を計算する集約関数です。
使用可能な集約関数の詳細については、<xref linkend="functions-aggregate"/>を参照してください。
   </para>

   <tip>
    <para>
<!--
     Grouping without aggregate expressions effectively calculates the
     set of distinct values in a column.  This can also be achieved
     using the <literal>DISTINCT</literal> clause (see <xref
     linkend="queries-distinct"/>).
-->
集約式を使用しないグループ化は、列内の重複しない値の集合を効率良く計算します。
これは<literal>DISTINCT</literal>句（<xref linkend="queries-distinct"/>を参照）の使用で同じように達成することができます。
    </para>
   </tip>

   <para>
<!--
    Here is another example:  it calculates the total sales for each
    product (rather than the total sales of all products):
-->
別の例を示します。
これは各製品の総売上を計算します
（全製品の総売上ではありません）。
<programlisting>
SELECT product_id, p.name, (sum(s.units) * p.price) AS sales
    FROM products p LEFT JOIN sales s USING (product_id)
    GROUP BY product_id, p.name, p.price;
</programlisting>
<!--
    In this example, the columns <literal>product_id</literal>,
    <literal>p.name</literal>, and <literal>p.price</literal> must be
    in the <literal>GROUP BY</literal> clause since they are referenced in
    the query select list (but see below).  The column
    <literal>s.units</literal> does not have to be in the <literal>GROUP
    BY</literal> list since it is only used in an aggregate expression
    (<literal>sum(...)</literal>), which represents the sales
    of a product.  For each product, the query returns a summary row about
    all sales of the product.
-->
この例では、<literal>product_id</literal>列、<literal>p.name</literal>列、<literal>p.price</literal>列は必ず<literal>GROUP BY</literal>句で指定する必要があります。
なぜなら、これらは問い合わせ選択リストの中で使われているからです（ただし、以下を参照）。
<literal>s.units</literal>列は<literal>GROUP BY</literal>で指定する必要はありません。
これは、製品ごとの売上計算の集約式（<function>sum(...)</function>）の中だけで使われるためです。
この問い合わせは、各製品に対して製品の全販売に関する合計行が返されます。
   </para>

   <indexterm><primary>functional dependency</primary></indexterm>
   <indexterm><primary>関数依存</primary></indexterm>

   <para>
<!--
    If the products table is set up so that, say,
    <literal>product_id</literal> is the primary key, then it would be
    enough to group by <literal>product_id</literal> in the above example,
    since name and price would be <firstterm>functionally
    dependent</firstterm> on the product ID, and so there would be no
    ambiguity about which name and price value to return for each product
    ID group.
-->
productsテーブルが、例えば、<literal>product_id</literal>が主キーであるように設定されている場合、nameとprice列は製品ID（product_id）に<firstterm>関数依存</firstterm>しており、このため製品IDグループそれぞれに対してどのnameとpriceの値を返すかに関するあいまいさがありませんので、上の例では<literal>product_id</literal>でグループ化することで十分です。
   </para>

   <para>
<!--
    In strict SQL, <literal>GROUP BY</literal> can only group by columns of
    the source table but <productname>PostgreSQL</productname> extends
    this to also allow <literal>GROUP BY</literal> to group by columns in the
    select list.  Grouping by value expressions instead of simple
    column names is also allowed.
-->
厳密なSQLでは、<literal>GROUP BY</literal>は、元となるテーブルの列によってのみグループ化できますが、<productname>PostgreSQL</productname>では、選択リストの列によるグループ化もできるように拡張されています。
単純な列名の代わりに、評価式でグループ化することもできます。
   </para>

   <indexterm>
    <primary>HAVING</primary>
   </indexterm>

   <para>
<!--
    If a table has been grouped using <literal>GROUP BY</literal>,
    but only certain groups are of interest, the
    <literal>HAVING</literal> clause can be used, much like a
    <literal>WHERE</literal> clause, to eliminate groups from the result.
    The syntax is:
-->
<literal>GROUP BY</literal>を使ってグループ化されたテーブルで特定のグループのみ必要な場合、結果から不要なグループを除くのに、<literal>WHERE</literal>句のように<literal>HAVING</literal>句を使うことができます。
構文は以下の通りです。
<synopsis>
SELECT <replaceable>select_list</replaceable> FROM ... <optional>WHERE ...</optional> GROUP BY ... HAVING <replaceable>boolean_expression</replaceable>
</synopsis>
<!--
    Expressions in the <literal>HAVING</literal> clause can refer both to
    grouped expressions and to ungrouped expressions (which necessarily
    involve an aggregate function).
-->
<literal>HAVING</literal>句内の式は、グループ化された式とグループ化されてない式（この場合は集約関数が必要になります）の両方を参照することができます。
   </para>

   <para>
<!--
    Example:
-->
例を示します。
<screen>
<prompt>=&gt;</prompt> <userinput>SELECT x, sum(y) FROM test1 GROUP BY x HAVING sum(y) &gt; 3;</userinput>
 x | sum
---+-----
 a |   4
 b |   5
(2 rows)

<prompt>=&gt;</prompt> <userinput>SELECT x, sum(y) FROM test1 GROUP BY x HAVING x &lt; 'c';</userinput>
 x | sum
---+-----
 a |   4
 b |   5
(2 rows)
</screen>
   </para>

   <para>
<!--
    Again, a more realistic example:
-->
次に、より現実的な例を示します。
<programlisting>
SELECT product_id, p.name, (sum(s.units) * (p.price - p.cost)) AS profit
    FROM products p LEFT JOIN sales s USING (product_id)
    WHERE s.date &gt; CURRENT_DATE - INTERVAL '4 weeks'
    GROUP BY product_id, p.name, p.price, p.cost
    HAVING sum(p.price * s.units) &gt; 5000;
</programlisting>
<!--
    In the example above, the <literal>WHERE</literal> clause is selecting
    rows by a column that is not grouped (the expression is only true for
    sales during the last four weeks), while the <literal>HAVING</literal>
    clause restricts the output to groups with total gross sales over
    5000.  Note that the aggregate expressions do not necessarily need
    to be the same in all parts of the query.
-->
上の例で、<literal>WHERE</literal>句は、グループ化されていない列によって行を選択している（この式では最近の4週間の売上のみが真になります）のに対し、<literal>HAVING</literal>句は出力を売上高が5000を超えるグループに制限しています。
集約式が、問い合わせ内で常に同じである必要がないことに注意してください。
   </para>

   <para>
<!--
    If a query contains aggregate function calls, but no <literal>GROUP BY</literal>
    clause, grouping still occurs: the result is a single group row (or
    perhaps no rows at all, if the single row is then eliminated by
    <literal>HAVING</literal>).
    The same is true if it contains a <literal>HAVING</literal> clause, even
    without any aggregate function calls or <literal>GROUP BY</literal> clause.
-->
ある問い合わせが集約関数を含んでいるが<literal>GROUP BY</literal>句がない場合でも、グループ化は依然として行われます。
結果は単一グループ行（または<literal>HAVING</literal>で単一行が削除されれば、行が全くなくなるかもしれません）となります。
<literal>HAVING</literal>句を含んでいれば、集約関数呼び出しや<literal>GROUP BY</literal>句がまったく存在しなくても同じことが言えます。
   </para>
  </sect2>

  <sect2 id="queries-grouping-sets">
<!--
   <title><literal>GROUPING SETS</literal>, <literal>CUBE</literal>, and <literal>ROLLUP</literal></title>
-->
   <title><literal>GROUPING SETS</literal>、<literal>CUBE</literal>、<literal>ROLLUP</literal></title>

   <indexterm zone="queries-grouping-sets">
    <primary>GROUPING SETS</primary>
   </indexterm>
   <indexterm zone="queries-grouping-sets">
    <primary>CUBE</primary>
   </indexterm>
   <indexterm zone="queries-grouping-sets">
    <primary>ROLLUP</primary>
   </indexterm>

   <para>
<!--
    More complex grouping operations than those described above are possible
    using the concept of <firstterm>grouping sets</firstterm>.  The data selected by
    the <literal>FROM</literal> and <literal>WHERE</literal> clauses is grouped separately
    by each specified grouping set, aggregates computed for each group just as
    for simple <literal>GROUP BY</literal> clauses, and then the results returned.
    For example:
-->
上述のものよりも複雑なグループ化の操作は、<firstterm>グループ化セット</firstterm>の概念を用いることで可能です。
<literal>FROM</literal>句と<literal>WHERE</literal>句によって選択されたデータは、指定されたグループ化セットによってそれぞれグループ化され、単純な<literal>GROUP BY</literal>句と同じように集約計算され、その後結果が返されます。
例を示します。
<screen>
<prompt>=&gt;</prompt> <userinput>SELECT * FROM items_sold;</userinput>
 brand | size | sales
-------+------+-------
 Foo   | L    |  10
 Foo   | M    |  20
 Bar   | M    |  15
 Bar   | L    |  5
(4 rows)

<prompt>=&gt;</prompt> <userinput>SELECT brand, size, sum(sales) FROM items_sold GROUP BY GROUPING SETS ((brand), (size), ());</userinput>
 brand | size | sum
-------+------+-----
 Foo   |      |  30
 Bar   |      |  20
       | L    |  15
       | M    |  35
       |      |  50
(5 rows)
</screen>
   </para>

   <para>
<!--
    Each sublist of <literal>GROUPING SETS</literal> may specify zero or more columns
    or expressions and is interpreted the same way as though it were directly
    in the <literal>GROUP BY</literal> clause.  An empty grouping set means that all
    rows are aggregated down to a single group (which is output even if no
    input rows were present), as described above for the case of aggregate
    functions with no <literal>GROUP BY</literal> clause.
-->
<literal>GROUPING SETS</literal>の各サブリストはゼロ個以上の列または式を指定することが出来ます。
そして、それが直接<literal>GROUP BY</literal>句で指定したのと同じように解釈されます。
空のグループ化セットは、全行が一つのグループにまで集約されることを意味します（何も入力行が存在しない場合でも出力されます）。
これは、上述した<literal>GROUP BY</literal>句がない集約関数の場合と同様です。
   </para>

   <para>
<!--
    References to the grouping columns or expressions are replaced
    by null values in result rows for grouping sets in which those
    columns do not appear.  To distinguish which grouping a particular output
    row resulted from, see <xref linkend="functions-grouping-table"/>.
-->
グループ化している列または式の参照は、その列が現われないグループ化セットの結果行ではNULL値に置き換えられます。
特定の出力行が、どのグループ化から生じたかを識別するには<xref linkend="functions-grouping-table"/>を参照して下さい。
   </para>

   <para>
<!--
    A shorthand notation is provided for specifying two common types of grouping set.
    A clause of the form
-->
グループ化セットの中で一般的な２種類については、略記法での指定方法が提供されています。
<programlisting>
ROLLUP ( <replaceable>e1</replaceable>, <replaceable>e2</replaceable>, <replaceable>e3</replaceable>, ... )
</programlisting>
<!--
    represents the given list of expressions and all prefixes of the list including
    the empty list; thus it is equivalent to
-->
上の句は、式の指定されたリストと空のリストを含めたリストのすべてのプレフィックスを表します。
したがって、以下と同等です。
<programlisting>
GROUPING SETS (
    ( <replaceable>e1</replaceable>, <replaceable>e2</replaceable>, <replaceable>e3</replaceable>, ... ),
    ...
    ( <replaceable>e1</replaceable>, <replaceable>e2</replaceable> ),
    ( <replaceable>e1</replaceable> ),
    ( )
)
</programlisting>
<!--
    This is commonly used for analysis over hierarchical data; e.g., total
    salary by department, division, and company-wide total.
-->
これは一般に、階層データに対する分析のために使用されます。例えば、部署、部門、全社合計による総給与を出します。
   </para>

   <para>
<!--
    A clause of the form
-->
<programlisting>
CUBE ( <replaceable>e1</replaceable>, <replaceable>e2</replaceable>, ... )
</programlisting>
<!--
    represents the given list and all of its possible subsets (i.e., the power
    set).  Thus
-->
上の句は、与えられたリストとその可能な部分集合（サブセット）のすべて（すなわち、べき集合）を表します。
したがって
<programlisting>
CUBE ( a, b, c )
</programlisting>
<!--
    is equivalent to
-->
は以下と同等です。
<programlisting>
GROUPING SETS (
    ( a, b, c ),
    ( a, b    ),
    ( a,    c ),
    ( a       ),
    (    b, c ),
    (    b    ),
    (       c ),
    (         )
)
</programlisting>
   </para>

   <para>
<!--
    The individual elements of a <literal>CUBE</literal> or <literal>ROLLUP</literal>
    clause may be either individual expressions, or sublists of elements in
    parentheses.  In the latter case, the sublists are treated as single
    units for the purposes of generating the individual grouping sets.
    For example:
-->
<literal>CUBE</literal>句や<literal>ROLLUP</literal>句の各要素は、個々の式、または括弧で囲まれた要素のサブリスト、どちらかに出来ます。
後者の場合には、サブリストは個々のグループ化セットを生成する目的において一つの単位として扱われます。
例えば
<programlisting>
CUBE ( (a, b), (c, d) )
</programlisting>
<!--
    is equivalent to
-->
は以下と同等です。
<programlisting>
GROUPING SETS (
    ( a, b, c, d ),
    ( a, b       ),
    (       c, d ),
    (            )
)
</programlisting>
<!--
    and
-->
そして
<programlisting>
ROLLUP ( a, (b, c), d )
</programlisting>
<!--
    is equivalent to
-->
は以下と同等です。
<programlisting>
GROUPING SETS (
    ( a, b, c, d ),
    ( a, b, c    ),
    ( a          ),
    (            )
)
</programlisting>
   </para>

   <para>
<!--
    The <literal>CUBE</literal> and <literal>ROLLUP</literal> constructs can be used either
    directly in the <literal>GROUP BY</literal> clause, or nested inside a
    <literal>GROUPING SETS</literal> clause.  If one <literal>GROUPING SETS</literal> clause
    is nested inside another, the effect is the same as if all the elements of
    the inner clause had been written directly in the outer clause.
-->
<literal>CUBE</literal>と<literal>ROLLUP</literal>構文は、<literal>GROUP BY</literal>句の中で直接使用、または<literal>GROUPING SETS</literal>句の中で入れ子に出来ます。
<literal>GROUPING SETS</literal>句が別の内側に入れ子になっている場合、内側の句が外側の句に直接書かれている場合と効果は同じになります。
   </para>

   <para>
<!--
    If multiple grouping items are specified in a single <literal>GROUP BY</literal>
    clause, then the final list of grouping sets is the cross product of the
    individual items.  For example:
-->
複数の集約項目が<literal>GROUP BY</literal>句一つで指定されている場合、グループ化セットの最終的なリストは、個々の項目の外積（クロス積）です。
例えば
<programlisting>
GROUP BY a, CUBE (b, c), GROUPING SETS ((d), (e))
</programlisting>
<!--
    is equivalent to
-->
は以下と同等です。
<programlisting>
GROUP BY GROUPING SETS (
    (a, b, c, d), (a, b, c, e),
    (a, b, d),    (a, b, e),
    (a, c, d),    (a, c, e),
    (a, d),       (a, e)
)
</programlisting>
   </para>

  <note>
   <para>
<!--
    The construct <literal>(a, b)</literal> is normally recognized in expressions as
    a <link linkend="sql-syntax-row-constructors">row constructor</link>.
    Within the <literal>GROUP BY</literal> clause, this does not apply at the top
    levels of expressions, and <literal>(a, b)</literal> is parsed as a list of
    expressions as described above.  If for some reason you <emphasis>need</emphasis>
    a row constructor in a grouping expression, use <literal>ROW(a, b)</literal>.
-->
<literal>(a, b)</literal>という構文は通常<link linkend="sql-syntax-row-constructors">行コンストラクタ</link>として式に認識されます。
<literal>GROUP BY</literal>句の中では、トップレベルの式の場合これは適用されず、<literal>(a, b)</literal>は上記のような式のリストとして解析されます。
何らかの理由で、グループ化式の中で行コンストラクタが<emphasis>必要</emphasis>になった場合は、<literal>ROW(a, b)</literal>を使用して下さい。
   </para>
  </note>
  </sect2>

  <sect2 id="queries-window">
<!--
   <title>Window Function Processing</title>
-->
   <title>ウィンドウ関数処理</title>

   <indexterm zone="queries-window">
    <primary>window function</primary>
    <secondary>order of execution</secondary>
   </indexterm>
   <indexterm zone="queries-window">
    <primary>ウィンドウ関数</primary>
    <secondary>実行順</secondary>
   </indexterm>

   <para>
<!--
    If the query contains any window functions (see
    <xref linkend="tutorial-window"/>,
    <xref linkend="functions-window"/> and
    <xref linkend="syntax-window-functions"/>), these functions are evaluated
    after any grouping, aggregation, and <literal>HAVING</literal> filtering is
    performed.  That is, if the query uses any aggregates, <literal>GROUP
    BY</literal>, or <literal>HAVING</literal>, then the rows seen by the window functions
    are the group rows instead of the original table rows from
    <literal>FROM</literal>/<literal>WHERE</literal>.
-->
問い合わせがウィンドウ関数（<xref linkend="tutorial-window"/>、<xref linkend="functions-window"/>と<xref linkend="syntax-window-functions"/>を参照）を含んでいれば、これらの関数はグループ化、集約および<literal>HAVING</literal>条件検索が行われた後に評価されます。
つまり、問い合わせが何らかの集約、<literal>GROUP BY</literal>または<literal>HAVING</literal>を使用していれば、ウィンドウ関数により見える行は<literal>FROM</literal>/<literal>WHERE</literal>での本来のテーブル行ではなく、グループ行となります。
   </para>

   <para>
<!--
    When multiple window functions are used, all the window functions having
    syntactically equivalent <literal>PARTITION BY</literal> and <literal>ORDER BY</literal>
    clauses in their window definitions are guaranteed to be evaluated in a
    single pass over the data. Therefore they will see the same sort ordering,
    even if the <literal>ORDER BY</literal> does not uniquely determine an ordering.
    However, no guarantees are made about the evaluation of functions having
    different <literal>PARTITION BY</literal> or <literal>ORDER BY</literal> specifications.
    (In such cases a sort step is typically required between the passes of
    window function evaluations, and the sort is not guaranteed to preserve
    ordering of rows that its <literal>ORDER BY</literal> sees as equivalent.)
-->
複数のウィンドウ関数が使用された場合、そのウィンドウ定義にある構文的に同等である<literal>PARTITION BY</literal>および<literal>ORDER BY</literal>句を持つすべてのウィンドウ関数は、データ全体に渡って単一の実行手順により評価されることが保証されています。
したがって、<literal>ORDER BY</literal>が一意に順序付けを決定しなくても同一の並べ替え順序付けを見ることができます。
しかし、異なる<literal>PARTITION BY</literal>または<literal>ORDER BY</literal>仕様を持つ関数の評価については保証されません。
（このような場合、並べ替え手順がウィンドウ関数評価の諸手順間で一般的に必要となり、<literal>ORDER BY</literal>が等価と判断する行の順序付けを保存するような並べ替えは保証されません。）
   </para>

   <para>
<!--
    Currently, window functions always require presorted data, and so the
    query output will be ordered according to one or another of the window
    functions' <literal>PARTITION BY</literal>/<literal>ORDER BY</literal> clauses.
    It is not recommended to rely on this, however.  Use an explicit
    top-level <literal>ORDER BY</literal> clause if you want to be sure the
    results are sorted in a particular way.
-->
現時点では、ウィンドウ関数は常に事前に並べ替えられたデータを必要とするので、問い合わせ出力はウィンドウ関数の<literal>PARTITION BY</literal>/<literal>ORDER BY</literal>句のどれか１つに従って順序付けされます。
とはいえ、これに依存することは薦められません。
確実に結果が特定の方法で並べ替えられるようにしたいのであれば、明示的な最上階層の<literal>ORDER BY</literal>を使用します。
   </para>
  </sect2>
 </sect1>


 <sect1 id="queries-select-lists">
<!--
  <title>Select Lists</title>
-->
  <title>選択リスト</title>

  <indexterm>
   <primary>SELECT</primary>
   <secondary>select list</secondary>
  </indexterm>
  <indexterm>
   <primary>SELECT</primary>
   <secondary>選択リスト</secondary>
  </indexterm>

  <para>
<!--
   As shown in the previous section,
   the table expression in the <command>SELECT</command> command
   constructs an intermediate virtual table by possibly combining
   tables, views, eliminating rows, grouping, etc.  This table is
   finally passed on to processing by the <firstterm>select list</firstterm>.  The select
   list determines which <emphasis>columns</emphasis> of the
   intermediate table are actually output.
-->
前節で示したように、<command>SELECT</command>コマンド中のテーブル式は、テーブルやビューの結合、行の抽出、グループ化などにより中間の仮想テーブルを作ります。
このテーブルは最終的に<firstterm>選択リスト</firstterm>による処理に渡されます。
選択リストは、中間のテーブルのどの<emphasis>列</emphasis>を実際に出力するかを決めます。
  </para>

  <sect2 id="queries-select-list-items">
<!--
   <title>Select-List Items</title>
-->
   <title>選択リスト項目</title>

   <indexterm>
    <primary>*</primary>
   </indexterm>

   <para>
<!--
    The simplest kind of select list is <literal>*</literal> which
    emits all columns that the table expression produces.  Otherwise,
    a select list is a comma-separated list of value expressions (as
    defined in <xref linkend="sql-expressions"/>).  For instance, it
    could be a list of column names:
-->
テーブル式が生成するすべての列を出力する<literal>*</literal>が最も簡単な選択リストです。
そうでなければ、選択リストは、カンマで区切られた（<xref linkend="sql-expressions"/>で定義された）評価式のリストです。
例えば、以下のような列名のリストであっても構いません。
<programlisting>
SELECT a, b, c FROM ...
</programlisting>
<!--
     The columns names <literal>a</literal>, <literal>b</literal>, and <literal>c</literal>
     are either the actual names of the columns of tables referenced
     in the <literal>FROM</literal> clause, or the aliases given to them as
     explained in <xref linkend="queries-table-aliases"/>.  The name
     space available in the select list is the same as in the
     <literal>WHERE</literal> clause, unless grouping is used, in which case
     it is the same as in the <literal>HAVING</literal> clause.
-->
<literal>a</literal>、<literal>b</literal>、<literal>c</literal>という列名は、<literal>FROM</literal>句で参照されるテーブルの実際の列名か、あるいは<xref linkend="queries-table-aliases"/>で説明したような列名に対する別名です。
グループ化されていなければ、選択リストで使用可能な名前空間は<literal>WHERE</literal>句と同じです。
グループ化されている場合は、<literal>HAVING</literal>句と同じとなります。
   </para>

   <para>
<!--
    If more than one table has a column of the same name, the table
    name must also be given, as in:
-->
もし、2つ以上のテーブルで同じ名前の列がある場合は、次のように、テーブル名を必ず指定しなければいけません。
<programlisting>
SELECT tbl1.a, tbl2.a, tbl1.b FROM ...
</programlisting>
<!--
    When working with multiple tables, it can also be useful to ask for
    all the columns of a particular table:
-->
複数のテーブルを使用する場合、特定のテーブルのすべての列を求める方法も便利かもしれません。
<programlisting>
SELECT tbl1.*, tbl2.a FROM ...
</programlisting>
<!--
    See <xref linkend="rowtypes-usage"/> for more about
    the <replaceable>table_name</replaceable><literal>.*</literal> notation.
-->
<replaceable>table_name</replaceable><literal>.*</literal>という指定方法の詳細については、<xref linkend="rowtypes-usage"/>を参照してください。
   </para>

   <para>
<!--
    If an arbitrary value expression is used in the select list, it
    conceptually adds a new virtual column to the returned table.  The
    value expression is evaluated once for each result row, with
    the row's values substituted for any column references.  But the
    expressions in the select list do not have to reference any
    columns in the table expression of the <literal>FROM</literal> clause;
    they can be constant arithmetic expressions, for instance.
-->
任意の評価式が選択リストで使われる場合、返されるテーブルは、概念的には新たに仮想的な列を追加したものとなります。
評価式は、それぞれの結果行で、その列参照を置換した行の値としていったん評価されます。
しかし、選択リストの式は<literal>FROM</literal>句で指定されたテーブル式内の列を参照するものである必要はありません。例えば、定数算術式であっても構いません。
   </para>
  </sect2>

  <sect2 id="queries-column-labels">
<!--
   <title>Column Labels</title>
-->
   <title>列ラベル</title>

   <indexterm zone="queries-column-labels">
    <primary>alias</primary>
    <secondary>in the select list</secondary>
   </indexterm>
   <indexterm zone="queries-column-labels">
    <primary>別名</primary>
    <secondary>選択リスト内の</secondary>
   </indexterm>

   <para>
<!--
    The entries in the select list can be assigned names for subsequent
    processing, such as for use in an <literal>ORDER BY</literal> clause
    or for display by the client application.  For example:
-->
選択リスト中の項目は、<literal>ORDER BY</literal>句の中での参照、もしくはクライアントアプリケーションによる表示での使用など、それに続く処理のために名前を割り当てることができます。
例を示します。
<programlisting>
SELECT a AS value, b + c AS sum FROM ...
</programlisting>
   </para>

   <para>
<!--
    If no output column name is specified using <literal>AS</literal>,
    the system assigns a default column name.  For simple column references,
    this is the name of the referenced column.  For function
    calls, this is the name of the function.  For complex expressions,
    the system will generate a generic name.
-->
<literal>AS</literal>を使った出力列名の指定がない場合、システムはデフォルトの列名を割り当てます。
単純な列参照では参照された列名となります。
関数呼び出しでは関数名となります。
複雑な表現についてはシステムが汎用の名前を生成します。
   </para>

   <para>
<!--
    The <literal>AS</literal> keyword is optional, but only if the new column
    name does not match any
    <productname>PostgreSQL</productname> keyword (see <xref
    linkend="sql-keywords-appendix"/>).  To avoid an accidental match to
    a keyword, you can double-quote the column name.  For example,
    <literal>VALUE</literal> is a keyword, so this does not work:
-->
<literal>AS</literal>キーワードは省略することができますが、新規列名が<productname>PostgreSQL</productname>キーワード（<xref linkend="sql-keywords-appendix"/>を参照）のいかなるものとも一致しない場合のみです。
あるキーワードと予測外の一致を防ぐために、列名を二重引用符で囲むことができます。
例えば、<literal>VALUE</literal>はキーワードですのでうまく動作しません。
<programlisting>
SELECT a value, b + c AS sum FROM ...
</programlisting>
<!--
    but this does:
-->
しかしこれは動きます。
<programlisting>
SELECT a "value", b + c AS sum FROM ...
</programlisting>
<!--
    For protection against possible
    future keyword additions, it is recommended that you always either
    write <literal>AS</literal> or double-quote the output column name.
-->
将来のキーワードの追加に対する保護のため、<literal>AS</literal>を記述するか、出力列名を二重引用符で囲むかのどちらかを推奨します。
   </para>

   <note>
    <para>
<!--
     The naming of output columns here is different from that done in
     the <literal>FROM</literal> clause (see <xref
     linkend="queries-table-aliases"/>).  It is possible
     to rename the same column twice, but the name assigned in
     the select list is the one that will be passed on.
-->
ここでの出力列の名前の指定は、<literal>FROM</literal>句での名前の指定（<xref linkend="queries-table-aliases"/>を参照）とは異なります。
同じ列の名前を2度変更することができますが、渡されるのは選択リストの中で割り当てられたものです。
    </para>
   </note>
  </sect2>

  <sect2 id="queries-distinct">
   <title><literal>DISTINCT</literal></title>

   <indexterm zone="queries-distinct">
    <primary>DISTINCT</primary>
   </indexterm>

   <indexterm zone="queries-distinct">
    <primary>duplicates</primary>
   </indexterm>
   <indexterm zone="queries-distinct">
    <primary>重複</primary>
   </indexterm>

   <para>
<!--
    After the select list has been processed, the result table can
    optionally be subject to the elimination of duplicate rows.  The
    <literal>DISTINCT</literal> key word is written directly after
    <literal>SELECT</literal> to specify this:
-->
選択リストが処理された後、結果テーブルの重複行を削除の対象にすることもできます。
これを指定するためには、<literal>SELECT</literal>の直後に<literal>DISTINCT</literal>キーワードを記述します。
<synopsis>
SELECT DISTINCT <replaceable>select_list</replaceable> ...
</synopsis>
<!--
    (Instead of <literal>DISTINCT</literal> the key word <literal>ALL</literal>
    can be used to specify the default behavior of retaining all rows.)
-->
（<literal>DISTINCT</literal>の代わりに<literal>ALL</literal>キーワードを使用して、すべての行が保持されるというデフォルトの動作を指定することができます。）
   </para>

   <indexterm>
    <primary>null value</primary>
    <secondary sortas="DISTINCT">in DISTINCT</secondary>
   </indexterm>
   <indexterm>
    <primary>NULL値</primary>
    <secondary sortas="DISTINCT">DISTINCT内の</secondary>
   </indexterm>

   <para>
<!--
    Obviously, two rows are considered distinct if they differ in at
    least one column value.  Null values are considered equal in this
    comparison.
-->
少なくとも1つの列の値が異なる場合、もちろん、それら2行は異なるとみなされます。
NULL値同士は、この比較において等しいとみなされます。
   </para>

   <para>
<!--
    Alternatively, an arbitrary expression can determine what rows are
    to be considered distinct:
-->
また、任意の式を使用して、どの行が別であるかを決定することもできます。
<synopsis>
SELECT DISTINCT ON (<replaceable>expression</replaceable> <optional>, <replaceable>expression</replaceable> ...</optional>) <replaceable>select_list</replaceable> ...
</synopsis>
<!--
    Here <replaceable>expression</replaceable> is an arbitrary value
    expression that is evaluated for all rows.  A set of rows for
    which all the expressions are equal are considered duplicates, and
    only the first row of the set is kept in the output.  Note that
    the <quote>first row</quote> of a set is unpredictable unless the
    query is sorted on enough columns to guarantee a unique ordering
    of the rows arriving at the <literal>DISTINCT</literal> filter.
    (<literal>DISTINCT ON</literal> processing occurs after <literal>ORDER
    BY</literal> sorting.)
-->
ここで<replaceable>expression</replaceable>は、すべての行で評価される任意の評価式です。
すべての式が等しくなる行の集合は、重複しているとみなされ、集合の最初の行だけが出力内に保持されます。
<literal>DISTINCT</literal>フィルタに掛けられる行の順序の一意性を保証できるよう十分な数の列で問い合わせを並べ替えない限り、出力される集合の<quote>最初の行</quote>は予想不可能であることに注意してください。
（<literal>DISTINCT ON</literal>処理は、<literal>ORDER BY</literal>による並べ替えの後に行われます。）
   </para>

   <para>
<!--
    The <literal>DISTINCT ON</literal> clause is not part of the SQL standard
    and is sometimes considered bad style because of the potentially
    indeterminate nature of its results.  With judicious use of
    <literal>GROUP BY</literal> and subqueries in <literal>FROM</literal>, this
    construct can be avoided, but it is often the most convenient
    alternative.
-->
<literal>DISTINCT ON</literal>句は標準SQLではありません。
さらに、結果が不定となる可能性があるため、好ましくないスタイルとみなされることもあります。
<literal>GROUP BY</literal>と<literal>FROM</literal>中の副問い合わせをうまく使うことにより、この構文を使わずに済みますが、<literal>DISTINCT ON</literal>句はしばしば非常に便利な代案となります。
   </para>
  </sect2>
 </sect1>


 <sect1 id="queries-union">
<!--
  <title>Combining Queries</title>
-->
  <title>問い合わせの結合</title>

  <indexterm zone="queries-union">
   <primary>UNION</primary>
  </indexterm>
  <indexterm zone="queries-union">
   <primary>INTERSECT</primary>
  </indexterm>
  <indexterm zone="queries-union">
   <primary>EXCEPT</primary>
  </indexterm>
  <indexterm zone="queries-union">
   <primary>set union</primary>
  </indexterm>
  <indexterm zone="queries-union">
    <primary>集合和</primary>
  </indexterm>
  <indexterm zone="queries-union">
   <primary>set intersection</primary>
  </indexterm>
  <indexterm zone="queries-union">
   <primary>集合積</primary>
  </indexterm>
  <indexterm zone="queries-union">
   <primary>set difference</primary>
  </indexterm>
  <indexterm zone="queries-union">
   <primary>集合差</primary>
  </indexterm>
  <indexterm zone="queries-union">
   <primary>set operation</primary>
  </indexterm>
  <indexterm zone="queries-union">
   <primary>集合操作</primary>
  </indexterm>

  <para>
<!--
   The results of two queries can be combined using the set operations
   union, intersection, and difference.  The syntax is
-->
2つの問い合わせの結果は、和、積、差の集合演算を使って結合することができます。
構文は以下の通りです。
<synopsis>
<replaceable>query1</replaceable> UNION <optional>ALL</optional> <replaceable>query2</replaceable>
<replaceable>query1</replaceable> INTERSECT <optional>ALL</optional> <replaceable>query2</replaceable>
<replaceable>query1</replaceable> EXCEPT <optional>ALL</optional> <replaceable>query2</replaceable>
</synopsis>
<!--
   <replaceable>query1</replaceable> and
   <replaceable>query2</replaceable> are queries that can use any of
   the features discussed up to this point.  Set operations can also
   be nested and chained, for example
-->
<replaceable>query1</replaceable>と<replaceable>query2</replaceable>は、これまで説明した機能をすべて使用することができる問い合わせです。
集合演算は入れ子にしたり、繋げたりすることができます。
例えば、以下の文を見てみましょう。
<synopsis>
<replaceable>query1</replaceable> UNION <replaceable>query2</replaceable> UNION <replaceable>query3</replaceable>
</synopsis>
<!--
   which is executed as:
-->
上記の文は以下のように実行されます。
<synopsis>
(<replaceable>query1</replaceable> UNION <replaceable>query2</replaceable>) UNION <replaceable>query3</replaceable>
</synopsis>
  </para>

  <para>
<!--
   <literal>UNION</literal> effectively appends the result of
   <replaceable>query2</replaceable> to the result of
   <replaceable>query1</replaceable> (although there is no guarantee
   that this is the order in which the rows are actually returned).
   Furthermore, it eliminates duplicate rows from its result, in the same
   way as <literal>DISTINCT</literal>, unless <literal>UNION ALL</literal> is used.
-->
<literal>UNION</literal>は、<replaceable>query2</replaceable>の結果を<replaceable>query1</replaceable>の結果に付加します（しかし、この順序で実際に行が返される保証はありません）。
さらに、<literal>UNION ALL</literal>を指定しないと、<literal>DISTINCT</literal>と同様に、結果から重複している行を削除します。
  </para>

  <para>
<!--
   <literal>INTERSECT</literal> returns all rows that are both in the result
   of <replaceable>query1</replaceable> and in the result of
   <replaceable>query2</replaceable>.  Duplicate rows are eliminated
   unless <literal>INTERSECT ALL</literal> is used.
-->
<literal>INTERSECT</literal>は、<replaceable>query1</replaceable>の結果と<replaceable>query2</replaceable>の結果の両方に含まれているすべての行を返します。
<literal>INTERSECT ALL</literal>を使用しないと、重複している行は削除されます。
  </para>

  <para>
<!--
   <literal>EXCEPT</literal> returns all rows that are in the result of
   <replaceable>query1</replaceable> but not in the result of
   <replaceable>query2</replaceable>.  (This is sometimes called the
   <firstterm>difference</firstterm> between two queries.)  Again, duplicates
   are eliminated unless <literal>EXCEPT ALL</literal> is used.
-->
<literal>EXCEPT</literal>は、<replaceable>query1</replaceable>の結果には含まれているけれども、<replaceable>query2</replaceable>の結果には含まれていないすべての行を返します。
（これが2つの問い合わせの<firstterm>差</firstterm>であると言われることがあります。）
この場合も、<literal>EXCEPT ALL</literal> を使用しないと、重複している行は削除されます。
  </para>

  <para>
<!--
   In order to calculate the union, intersection, or difference of two
   queries, the two queries must be <quote>union compatible</quote>,
   which means that they return the same number of columns and
   the corresponding columns have compatible data types, as
   described in <xref linkend="typeconv-union-case"/>.
-->
2つの問い合わせの和、積、差を算出するために、そこの2つの問い合わせは<quote>union互換</quote>でなければいけません。
つまり、その問い合わせが同じ数の列を返し、対応する列は互換性のあるデータ型（<xref linkend="typeconv-union-case"/>を参照）でなければなりません。
  </para>
 </sect1>


 <sect1 id="queries-order">
<!--
  <title>Sorting Rows</title>
-->
  <title>行の並べ替え</title>

  <indexterm zone="queries-order">
   <primary>sorting</primary>
  </indexterm>
  <indexterm zone="queries-order">
   <primary>並べ替え</primary>
  </indexterm>

  <indexterm zone="queries-order">
   <primary>ORDER BY</primary>
  </indexterm>

  <para>
<!--
   After a query has produced an output table (after the select list
   has been processed) it can optionally be sorted.  If sorting is not
   chosen, the rows will be returned in an unspecified order.  The actual
   order in that case will depend on the scan and join plan types and
   the order on disk, but it must not be relied on.  A particular
   output ordering can only be guaranteed if the sort step is explicitly
   chosen.
-->
ある問い合わせが1つの出力テーブルを生成した後（選択リストの処理が完了した後）、並べ替えることができます。
並べ替えが選ばれなかった場合、行は無規則な順序で返されます。
そのような場合、実際の順序は、スキャンや結合計画の種類や、ディスク上に格納されている順序に依存します。
しかし、当てにしてはいけません。
明示的に並べ替え手続きを選択した場合にのみ、特定の出力順序は保証されます。
  </para>

  <para>
<!--
   The <literal>ORDER BY</literal> clause specifies the sort order:
-->
<literal>ORDER BY</literal>句は並べ替えの順番を指定します。
<synopsis>
SELECT <replaceable>select_list</replaceable>
    FROM <replaceable>table_expression</replaceable>
    ORDER BY <replaceable>sort_expression1</replaceable> <optional>ASC | DESC</optional> <optional>NULLS { FIRST | LAST }</optional>
             <optional>, <replaceable>sort_expression2</replaceable> <optional>ASC | DESC</optional> <optional>NULLS { FIRST | LAST }</optional> ...</optional>
</synopsis>
<!--
   The sort expression(s) can be any expression that would be valid in the
   query's select list.  An example is:
-->
並べ替え式(複数可)は問い合わせの選択リスト内で使用可能な任意の式を取ることができます。
以下に例を示します。
<programlisting>
SELECT a, b FROM table1 ORDER BY a + b, c;
</programlisting>
<!--
   When more than one expression is specified,
   the later values are used to sort rows that are equal according to the
   earlier values.  Each expression can be followed by an optional
   <literal>ASC</literal> or <literal>DESC</literal> keyword to set the sort direction to
   ascending or descending.  <literal>ASC</literal> order is the default.
   Ascending order puts smaller values first, where
   <quote>smaller</quote> is defined in terms of the
   <literal>&lt;</literal> operator.  Similarly, descending order is
   determined with the <literal>&gt;</literal> operator.
-->
複数の式が指定された場合、前の式の値が等しい行を並べ替える際に後の式の値が使用されます。
列指定の後にオプションで<literal>ASC</literal>もしくは<literal>DESC</literal>を付与することで、並べ替えの方向を昇順、降順にするかを設定することができます。
<literal>ASC</literal>順がデフォルトです。
昇順では、小さな値を先に出力します。
ここでの<quote>小さい</quote>とは、<literal>&lt;</literal>演算子によって決定されます。
同様に降順では<literal>&gt;</literal>演算子で決定されます。
    <footnote>
     <para>
<!--
      Actually, <productname>PostgreSQL</productname> uses the <firstterm>default B-tree
      operator class</firstterm> for the expression's data type to determine the sort
      ordering for <literal>ASC</literal> and <literal>DESC</literal>.  Conventionally,
      data types will be set up so that the <literal>&lt;</literal> and
      <literal>&gt;</literal> operators correspond to this sort ordering,
      but a user-defined data type's designer could choose to do something
      different.
-->
実際、<productname>PostgreSQL</productname>は、<literal>ASC</literal>と<literal>DESC</literal>の並べ替え順を決定するために、式のデータ型用の<firstterm>デフォルトのB-tree演算子クラス</firstterm>を使用します。
慣習的に、データ型は<literal>&lt;</literal>と<literal>&gt;</literal>演算子をこの並べ替え順になるように設定されます。
しかし、ユーザ定義データ型の設計者は異なるものを選択することができます。
     </para>
    </footnote>
  </para>

  <para>
<!--
   The <literal>NULLS FIRST</literal> and <literal>NULLS LAST</literal> options can be
   used to determine whether nulls appear before or after non-null values
   in the sort ordering.  By default, null values sort as if larger than any
   non-null value; that is, <literal>NULLS FIRST</literal> is the default for
   <literal>DESC</literal> order, and <literal>NULLS LAST</literal> otherwise.
-->
<literal>NULLS FIRST</literal>および<literal>NULLS LAST</literal>オプションを使用して、その並べ替え順においてNULL値を非NULL値の前にするか後にするかを決定することができます。
デフォルトでは、NULL値はあたかもすべての非NULL値よりも大きいとみなして並べ替えます。
と言うことは、<literal>NULLS FIRST</literal>は<literal>DESC</literal>順序付けのデフォルトで、そうでなければ<literal>NULLS LAST</literal>です。
  </para>

  <para>
<!--
   Note that the ordering options are considered independently for each
   sort column.  For example <literal>ORDER BY x, y DESC</literal> means
   <literal>ORDER BY x ASC, y DESC</literal>, which is not the same as
   <literal>ORDER BY x DESC, y DESC</literal>.
-->
この順序づけオプションは、並べ替えで使用される各列に個別に適用されることに注意してください。
例えば、<literal>ORDER BY x, y DESC</literal>は、<literal>ORDER BY x DESC, y DESC</literal>と同じではなく、<literal>ORDER BY x ASC, y DESC</literal>を意味します。
  </para>

  <para>
<!--
   A <replaceable>sort_expression</replaceable> can also be the column label or number
   of an output column, as in:
-->
<replaceable>sort_expression</replaceable>は以下のように列ラベルもしくは出力列の番号で指定することができます。
<programlisting>
SELECT a + b AS sum, c FROM table1 ORDER BY sum;
SELECT a, max(b) FROM table1 GROUP BY a ORDER BY 1;
</programlisting>
<!--
   both of which sort by the first output column.  Note that an output
   column name has to stand alone, that is, it cannot be used in an expression
   &mdash; for example, this is <emphasis>not</emphasis> correct:
-->
両方とも最初の出力列で並べ替えられます。
出力列名は単体でなければなりません。つまり式としては使用できないことに注意してください。
例えば以下は<emphasis>間違い</emphasis>です。
<programlisting>
<!--
SELECT a + b AS sum, c FROM table1 ORDER BY sum + c;          &#045;&#045; wrong
-->
SELECT a + b AS sum, c FROM table1 ORDER BY sum + c;          -- 間違い
</programlisting>
<!--
   This restriction is made to reduce ambiguity.  There is still
   ambiguity if an <literal>ORDER BY</literal> item is a simple name that
   could match either an output column name or a column from the table
   expression.  The output column is used in such cases.  This would
   only cause confusion if you use <literal>AS</literal> to rename an output
   column to match some other table column's name.
-->
これは曖昧さを減らすための制限です。
<literal>ORDER BY</literal>項目が単純な名前であっても、出力列名とテーブル式による列と同じ名前となる場合、曖昧さはまだ存在します。
この場合、出力列名が使用されます。
<literal>AS</literal>を使用して他のテーブル列の名前と同じ名前に出力列を変名した場合にのみ混乱が発生します。
  </para>

  <para>
<!--
   <literal>ORDER BY</literal> can be applied to the result of a
   <literal>UNION</literal>, <literal>INTERSECT</literal>, or <literal>EXCEPT</literal>
   combination, but in this case it is only permitted to sort by
   output column names or numbers, not by expressions.
-->
<literal>ORDER BY</literal>を、<literal>UNION</literal>、<literal>INTERSECT</literal>、<literal>EXCEPT</literal>組み合わせの結果に適用することができます。
しかしこの場合、出力列の名前または番号でのみ並べ替えることができ、式では並べ替えることができません。
  </para>
 </sect1>


 <sect1 id="queries-limit">
<!--
  <title><literal>LIMIT</literal> and <literal>OFFSET</literal></title>
-->
  <title><literal>LIMIT</literal>と<literal>OFFSET</literal></title>

  <indexterm zone="queries-limit">
   <primary>LIMIT</primary>
  </indexterm>

  <indexterm zone="queries-limit">
   <primary>OFFSET</primary>
  </indexterm>

  <para>
<!--
   <literal>LIMIT</literal> and <literal>OFFSET</literal> allow you to retrieve just
   a portion of the rows that are generated by the rest of the query:
-->
<literal>LIMIT</literal>および<literal>OFFSET</literal>を使うことで、問い合わせの実行で生成された行の一部だけを取り出すことができます。
<synopsis>
SELECT <replaceable>select_list</replaceable>
    FROM <replaceable>table_expression</replaceable>
    <optional> ORDER BY ... </optional>
    <optional> LIMIT { <replaceable>number</replaceable> | ALL } </optional> <optional> OFFSET <replaceable>number</replaceable> </optional>
</synopsis>
  </para>

  <para>
<!--
   If a limit count is given, no more than that many rows will be
   returned (but possibly fewer, if the query itself yields fewer rows).
   <literal>LIMIT ALL</literal> is the same as omitting the <literal>LIMIT</literal>
   clause, as is <literal>LIMIT</literal> with a NULL argument.
-->
限度(limit)数を指定すると、指定した行数より多くの行が返されることはありません（しかし、問い合わせの結果が指定した行数より少なければ、それより少なくなります）。
<literal>LIMIT ALL</literal>は、<literal>LIMIT</literal>句を省略した場合と同じです。<literal>LIMIT</literal>の引数がNULLの場合も同様です。
  </para>

  <para>
<!--
   <literal>OFFSET</literal> says to skip that many rows before beginning to
   return rows.  <literal>OFFSET 0</literal> is the same as omitting the
   <literal>OFFSET</literal> clause, as is <literal>OFFSET</literal> with a NULL argument.
-->
<literal>OFFSET</literal>は、行を返し始める前に飛ばす行数を指定します。
<literal>OFFSET 0</literal>は、<literal>OFFSET</literal>句を省略した場合と同じです。<literal>OFFSET</literal>の引数がNULLの場合も同様です。
  </para>

  <para>
<!--
   If both <literal>OFFSET</literal>
   and <literal>LIMIT</literal> appear, then <literal>OFFSET</literal> rows are
   skipped before starting to count the <literal>LIMIT</literal> rows that
   are returned.
-->
<literal>OFFSET</literal>および<literal>LIMIT</literal>の両者が指定された場合、<literal>OFFSET</literal>分の行を飛ばしてから、返される<literal>LIMIT</literal>行を数え始めます。
  </para>

  <para>
<!--
   When using <literal>LIMIT</literal>, it is important to use an
   <literal>ORDER BY</literal> clause that constrains the result rows into a
   unique order.  Otherwise you will get an unpredictable subset of
   the query's rows. You might be asking for the tenth through
   twentieth rows, but tenth through twentieth in what ordering? The
   ordering is unknown, unless you specified <literal>ORDER BY</literal>.
-->
<literal>LIMIT</literal>を使用する時は、結果の行を一意な順序に制御する<literal>ORDER BY</literal>句を使用することが重要です。
<literal>ORDER BY</literal>を使わなければ、問い合わせの行について予測不能な部分集合を得ることになるでしょう。
10番目から20番目の行を問い合わせることもあるでしょうが、どういう並び順での10番目から20番目の行でしょうか？
<literal>ORDER BY</literal>を指定しなければ、並び順はわかりません。
  </para>

  <para>
<!--
   The query optimizer takes <literal>LIMIT</literal> into account when
   generating query plans, so you are very likely to get different
   plans (yielding different row orders) depending on what you give
   for <literal>LIMIT</literal> and <literal>OFFSET</literal>.  Thus, using
   different <literal>LIMIT</literal>/<literal>OFFSET</literal> values to select
   different subsets of a query result <emphasis>will give
   inconsistent results</emphasis> unless you enforce a predictable
   result ordering with <literal>ORDER BY</literal>.  This is not a bug; it
   is an inherent consequence of the fact that SQL does not promise to
   deliver the results of a query in any particular order unless
   <literal>ORDER BY</literal> is used to constrain the order.
-->
問い合わせオプティマイザは、問い合わせ計画を生成する時に<literal>LIMIT</literal>を考慮します。
そのため、<literal>LIMIT</literal>と<literal>OFFSET</literal>に指定した値によって、異なった計画（得られる行の順序も異なります）が得られる可能性が高いです。
従って、1つの問い合わせ結果から異なる部分集合を選び出すために、異なる<literal>LIMIT</literal>/<literal>OFFSET</literal>の値を使用すると、<literal>ORDER BY</literal>で結果の順序を制御しなければ、<emphasis>一貫しない結果が生じるでしょう</emphasis>。
これは不具合ではありません。
<literal>ORDER BY</literal>を使って順序を制御しない限り、SQLは必ずしも特定の順序で問い合わせの結果を渡さないという特性の必然的な結果です。
  </para>

  <para>
<!--
   The rows skipped by an <literal>OFFSET</literal> clause still have to be
   computed inside the server; therefore a large <literal>OFFSET</literal>
   might be inefficient.
-->
<literal>OFFSET</literal>句で飛ばされる行を、実際にはサーバ内で計算しなければなりません。
そのため、大きな値の<literal>OFFSET</literal>は非効率的になることがあります。
  </para>
 </sect1>


 <sect1 id="queries-values">
<!--
  <title><literal>VALUES</literal> Lists</title>
-->
  <title><literal>VALUES</literal>リスト</title>

  <indexterm zone="queries-values">
   <primary>VALUES</primary>
  </indexterm>

  <para>
<!--
   <literal>VALUES</literal> provides a way to generate a <quote>constant table</quote>
   that can be used in a query without having to actually create and populate
   a table on-disk.  The syntax is
-->
<literal>VALUES</literal>は、<quote>定数テーブル</quote>を生成する方法を提供します。
それは実際にはディスク上に作成して配置することなく、問い合わせで使用することができます。
構文を以下に示します。
<synopsis>
VALUES ( <replaceable class="parameter">expression</replaceable> [, ...] ) [, ...]
</synopsis>
<!--
   Each parenthesized list of expressions generates a row in the table.
   The lists must all have the same number of elements (i.e., the number
   of columns in the table), and corresponding entries in each list must
   have compatible data types.  The actual data type assigned to each column
   of the result is determined using the same rules as for <literal>UNION</literal>
   (see <xref linkend="typeconv-union-case"/>).
-->
括弧で括られた式のリストがそれぞれ、テーブルの行を生成します。
リストは同一の要素数（つまり、テーブルの列数）を持たなければなりません。
また、各リストで対応する項目のデータ型に互換性がなければなりません。
最終的に各列に割り当てられる実際のデータ型は、<literal>UNION</literal>と同様の規則に従って決定されます。
（<xref linkend="typeconv-union-case"/>を参照してください。）
  </para>

  <para>
<!--
   As an example:
-->
以下に例を示します。
<programlisting>
VALUES (1, 'one'), (2, 'two'), (3, 'three');
</programlisting>

<!--
   will return a table of two columns and three rows.  It's effectively
   equivalent to:
-->
これは、2列3行のテーブルを返します。
実質的に、以下と同じです。
<programlisting>
SELECT 1 AS column1, 'one' AS column2
UNION ALL
SELECT 2, 'two'
UNION ALL
SELECT 3, 'three';
</programlisting>

<!--
   By default, <productname>PostgreSQL</productname> assigns the names
   <literal>column1</literal>, <literal>column2</literal>, etc. to the columns of a
   <literal>VALUES</literal> table.  The column names are not specified by the
   SQL standard and different database systems do it differently, so
   it's usually better to override the default names with a table alias
   list, like this:
-->
デフォルトでは、<productname>PostgreSQL</productname>は<literal>VALUES</literal>テーブルの各列に<literal>column1</literal>、<literal>column2</literal>といった名前をつけます。
標準SQLではこれらの列名は規定されていませんので、データベースシステムの種類によって異なる名前を付与しています。
そのため、通常はテーブル別名リストを使用して、以下のようにデフォルトの名前を上書きする方がよいでしょう。
<programlisting>
=&gt; SELECT * FROM (VALUES (1, 'one'), (2, 'two'), (3, 'three')) AS t (num,letter);
 num | letter
-----+--------
   1 | one
   2 | two
   3 | three
(3 rows)
</programlisting>
  </para>

  <para>
<!--
   Syntactically, <literal>VALUES</literal> followed by expression lists is
   treated as equivalent to:
-->
文法的には、<literal>VALUES</literal>の後に式のリストがあるものは、以下と同様に扱われます。
<synopsis>
SELECT <replaceable>select_list</replaceable> FROM <replaceable>table_expression</replaceable>
</synopsis>
<!--
   and can appear anywhere a <literal>SELECT</literal> can.  For example, you can
   use it as part of a <literal>UNION</literal>, or attach a
   <replaceable>sort_specification</replaceable> (<literal>ORDER BY</literal>,
   <literal>LIMIT</literal>, and/or <literal>OFFSET</literal>) to it.  <literal>VALUES</literal>
   is most commonly used as the data source in an <command>INSERT</command> command,
   and next most commonly as a subquery.
-->
そして、<literal>SELECT</literal>が記述できるところであれば、どこにでも記述することができます。
例えば、<literal>UNION</literal>の一部として使用することもできますし、<replaceable>sort_specification</replaceable> (<literal>ORDER BY</literal>、<literal>LIMIT</literal>、<literal>OFFSET</literal>)を付けることもできます。
<literal>VALUES</literal>は<command>INSERT</command>コマンドの元データとしてもっとも頻繁に使用されます。
次に使用頻度が高いのは副問い合わせとしての使用です。
  </para>

  <para>
<!--
   For more information see <xref linkend="sql-values"/>.
-->
詳しくは<xref linkend="sql-values"/>を参照してください。
  </para>

 </sect1>


 <sect1 id="queries-with">
<!--
  <title><literal>WITH</literal> Queries (Common Table Expressions)</title>
-->
  <title><literal>WITH</literal>問い合わせ（共通テーブル式）</title>

  <indexterm zone="queries-with">
   <primary>WITH</primary>
   <secondary>in SELECT</secondary>
  </indexterm>
  <indexterm zone="queries-with">
   <primary>WITH</primary>
   <secondary>SELECTにおける</secondary>
  </indexterm>

  <indexterm>
   <primary>common table expression</primary>
  </indexterm>
  <indexterm>
   <primary>共通テーブル式</primary>
   <see>WITH</see>
  </indexterm>

  <para>
<!--
   <literal>WITH</literal> provides a way to write auxiliary statements for use in a
   larger query.  These statements, which are often referred to as Common
   Table Expressions or <acronym>CTE</acronym>s, can be thought of as defining
   temporary tables that exist just for one query.  Each auxiliary statement
   in a <literal>WITH</literal> clause can be a <command>SELECT</command>,
   <command>INSERT</command>, <command>UPDATE</command>, or <command>DELETE</command>; and the
   <literal>WITH</literal> clause itself is attached to a primary statement that can
   also be a <command>SELECT</command>, <command>INSERT</command>, <command>UPDATE</command>, or
   <command>DELETE</command>.
-->
<literal>WITH</literal>は、より大規模な問い合わせで使用される補助文を記述する方法を提供します。
これらの文は共通テーブル式(Common Table Expressions)または<acronym>CTE</acronym>とよく呼ばれるものであり、１つの問い合わせのために存在する一時テーブルを定義すると考えることができます。
<literal>WITH</literal>句内の補助文はそれぞれ<command>SELECT</command>、<command>INSERT</command>、<command>UPDATE</command>または<command>DELETE</command>を取ることができます。
そして<literal>WITH</literal>句自身は、これも<command>SELECT</command>、<command>INSERT</command>、<command>UPDATE</command>または<command>DELETE</command>を取ることができる主文に付与されます。
  </para>

 <sect2 id="queries-with-select">
<!--
   <title><command>SELECT</command> in <literal>WITH</literal></title>
-->
   <title><literal>WITH</literal>内の<command>SELECT</command></title>

  <para>
<!--
   The basic value of <command>SELECT</command> in <literal>WITH</literal> is to
   break down complicated queries into simpler parts.  An example is:
-->
<literal>WITH</literal>内の<command>SELECT</command>の基本的な価値は、複雑な問い合わせをより単純な部品に分解することです。
以下に例を示します。

<programlisting>
WITH regional_sales AS (
    SELECT region, SUM(amount) AS total_sales
    FROM orders
    GROUP BY region
), top_regions AS (
    SELECT region
    FROM regional_sales
    WHERE total_sales &gt; (SELECT SUM(total_sales)/10 FROM regional_sales)
)
SELECT region,
       product,
       SUM(quantity) AS product_units,
       SUM(amount) AS product_sales
FROM orders
WHERE region IN (SELECT region FROM top_regions)
GROUP BY region, product;
</programlisting>

<!--
   which displays per-product sales totals in only the top sales regions.
   The <literal>WITH</literal> clause defines two auxiliary statements named
   <structname>regional_sales</structname> and <structname>top_regions</structname>,
   where the output of <structname>regional_sales</structname> is used in
   <structname>top_regions</structname> and the output of <structname>top_regions</structname>
   is used in the primary <command>SELECT</command> query.
   This example could have been written without <literal>WITH</literal>,
   but we'd have needed two levels of nested sub-<command>SELECT</command>s.  It's a bit
   easier to follow this way.
-->
これは販売トップの地域（region）のみから製品ごとの売上高を表示します。
<literal>WITH</literal>句は、<structname>regional_sales</structname>、<structname>top_regions</structname>という名前の２つの補助文を定義します。
ここで、<structname>regional_sales</structname>の出力は<structname>top_regions</structname>内で使用され、<structname>top_regions</structname>は<command>SELECT</command>主問い合わせで使用されます。
この例は <literal>WITH</literal>なしでも記述できますが、二階層の入れ子の副<command>SELECT</command>を必要とします。この方法に従うほうが多少扱いやすいです。
  </para>

  <para>
   <indexterm>
    <primary>RECURSIVE</primary>
    <secondary>in common table expressions</secondary>
   </indexterm>
   <indexterm>
    <primary>RECURSIVE</primary>
    <secondary>共通テーブル式内の</secondary>
   </indexterm>
<!--
   The optional <literal>RECURSIVE</literal> modifier changes <literal>WITH</literal>
   from a mere syntactic convenience into a feature that accomplishes
   things not otherwise possible in standard SQL.  Using
   <literal>RECURSIVE</literal>, a <literal>WITH</literal> query can refer to its own
   output.  A very simple example is this query to sum the integers from 1
   through 100:
-->
オプションの<literal>RECURSIVE</literal>修飾子は、<literal>WITH</literal>を、単に構文上の利便性の高めるだけでなく標準的なSQLでは不可能な機能を実現させます。
<literal>RECURSIVE</literal>を使用すれば、<literal>WITH</literal>問い合わせが行った自己の結果を参照できるようになります。1から100までの数を合計する非常に単純な問い合わせは以下のようなものです。

<programlisting>
WITH RECURSIVE t(n) AS (
    VALUES (1)
  UNION ALL
    SELECT n+1 FROM t WHERE n &lt; 100
)
SELECT sum(n) FROM t;
</programlisting>

<!--
   The general form of a recursive <literal>WITH</literal> query is always a
   <firstterm>non-recursive term</firstterm>, then <literal>UNION</literal> (or
   <literal>UNION ALL</literal>), then a
   <firstterm>recursive term</firstterm>, where only the recursive term can contain
   a reference to the query's own output.  Such a query is executed as
   follows:
-->
再帰的<literal>WITH</literal>問い合わせの汎用形式は常に、<firstterm>非再帰的表現（non-recursiveterm）</firstterm>、そして<literal>UNION</literal>（または<literal>UNION ALL</literal>）、そして<firstterm>再帰的表現（recursive term）</firstterm>です。
再帰的表現だけが、その問い合わせ自身の出力への参照を含むことができます。
このような問い合わせは以下のように実行されます。
  </para>

  <procedure>
<!--
   <title>Recursive Query Evaluation</title>
-->
   <title>再帰的問い合わせの評価</title>

   <step performance="required">
    <para>
<!--
     Evaluate the non-recursive term.  For <literal>UNION</literal> (but not
     <literal>UNION ALL</literal>), discard duplicate rows.  Include all remaining
     rows in the result of the recursive query, and also place them in a
     temporary <firstterm>working table</firstterm>.
-->
非再帰的表現を評価します。
<literal>UNION</literal>（ただし<literal>UNION ALL</literal>は除きます）では、重複行を廃棄します。
その再帰的問い合わせの結果の残っているすべての行を盛り込み、同時にそれらを一時<firstterm>作業テーブル</firstterm>に置きます。
    </para>
   </step>

   <step performance="required">
    <para>
<!--
     So long as the working table is not empty, repeat these steps:
-->
作業テーブルが空でないのであれば以下の手順を繰り返します。
    </para>
    <substeps>
     <step performance="required">
      <para>
<!--
       Evaluate the recursive term, substituting the current contents of
       the working table for the recursive self-reference.
       For <literal>UNION</literal> (but not <literal>UNION ALL</literal>), discard
       duplicate rows and rows that duplicate any previous result row.
       Include all remaining rows in the result of the recursive query, and
       also place them in a temporary <firstterm>intermediate table</firstterm>.
-->
再帰自己参照を作業テーブルの実行中の内容で置換し、再帰的表現を評価します。
<literal>UNION</literal>（ただし<literal>UNION ALL</literal>は除きます）に対し、重複行と前の結果行と重複する行を破棄します。
その再帰的問い合わせの結果の残っているすべての行を盛り込み、同時にそれらを一時<firstterm>中間テーブル</firstterm>に置きます。
      </para>
     </step>

     <step performance="required">
      <para>
<!--
       Replace the contents of the working table with the contents of the
       intermediate table, then empty the intermediate table.
-->
中間テーブルの内容で作業テーブルの内容を差し替え、中間テーブルを空にします。
      </para>
     </step>
    </substeps>
   </step>
  </procedure>

  <note>
   <para>
<!--
    Strictly speaking, this process is iteration not recursion, but
    <literal>RECURSIVE</literal> is the terminology chosen by the SQL standards
    committee.
-->
厳密には、この手順は反復(iteration)であって再帰(recursion)ではありませんが、<literal>RECURSIVE</literal>はSQL標準化委員会で選ばれた用語です。
   </para>
  </note>

  <para>
<!--
   In the example above, the working table has just a single row in each step,
   and it takes on the values from 1 through 100 in successive steps.  In
   the 100th step, there is no output because of the <literal>WHERE</literal>
   clause, and so the query terminates.
-->
上記の例で、作業テーブルはそれぞれの手順での単なる単一行で、引き続く作業で1から100までの値を獲得します。
100番目の作業で、<literal>WHERE</literal>句による出力が無くなり、問い合わせが終了します。
  </para>

  <para>
<!--
   Recursive queries are typically used to deal with hierarchical or
   tree-structured data.  A useful example is this query to find all the
   direct and indirect sub-parts of a product, given only a table that
   shows immediate inclusions:
-->
再帰的問い合わせは階層的、またはツリー構造データに対処するため一般的に使用されます。
実用的な例は、直接使用する部品を表すテーブル１つのみが与えられ、そこから製品すべての直接・間接部品を見つける次の問い合わせです。

<programlisting>
WITH RECURSIVE included_parts(sub_part, part, quantity) AS (
    SELECT sub_part, part, quantity FROM parts WHERE part = 'our_product'
  UNION ALL
    SELECT p.sub_part, p.part, p.quantity
    FROM included_parts pr, parts p
    WHERE p.part = pr.sub_part
)
SELECT sub_part, SUM(quantity) as total_quantity
FROM included_parts
GROUP BY sub_part
</programlisting>
  </para>

  <para>
<!--
   When working with recursive queries it is important to be sure that
   the recursive part of the query will eventually return no tuples,
   or else the query will loop indefinitely.  Sometimes, using
   <literal>UNION</literal> instead of <literal>UNION ALL</literal> can accomplish this
   by discarding rows that duplicate previous output rows.  However, often a
   cycle does not involve output rows that are completely duplicate: it may be
   necessary to check just one or a few fields to see if the same point has
   been reached before.  The standard method for handling such situations is
   to compute an array of the already-visited values.  For example, consider
   the following query that searches a table <structname>graph</structname> using a
   <structfield>link</structfield> field:
-->
再帰的問い合わせを扱う場合、問い合わせの再帰部分が最終的にはタプルを返さないようにすることが重要です。
そうしなければ、問い合わせが永久にループしてしまうからです。
<literal>UNION ALL</literal>の替わりに<literal>UNION</literal>を使用することで、重複する前回の出力行が廃棄され、これを実現できることもあるでしょう。
しかし、各周期が完全に重複している行を含まないこともよくあり、そのような場合は、1つまたは少数のフィールドを検査して、同じ場所に既に到達したかどうかを調べる必要があるかもしれません。
このような状態を取り扱う標準手法は、既に巡回された値の配列を計算することです。
例えば、<structfield>link</structfield>フィールドを使ってテーブル<structname>graph</structname>を検索する以下の問い合わせを考えて見ます。

<programlisting>
WITH RECURSIVE search_graph(id, link, data, depth) AS (
    SELECT g.id, g.link, g.data, 1
    FROM graph g
  UNION ALL
    SELECT g.id, g.link, g.data, sg.depth + 1
    FROM graph g, search_graph sg
    WHERE g.id = sg.link
)
SELECT * FROM search_graph;
</programlisting>

<!--
   This query will loop if the <structfield>link</structfield> relationships contain
   cycles.  Because we require a <quote>depth</quote> output, just changing
   <literal>UNION ALL</literal> to <literal>UNION</literal> would not eliminate the looping.
   Instead we need to recognize whether we have reached the same row again
   while following a particular path of links.  We add two columns
   <structfield>path</structfield> and <structfield>cycle</structfield> to the loop-prone query:
-->
この問い合わせは<structfield>link</structfield>関係が循環を含んでいればループします。
<quote>depth</quote>出力を要求しているので、<literal>UNION ALL</literal>を<literal>UNION</literal>に変えるだけでは、ループを取り除くことができません。
その代わり、linkの特定の経路をたどっている間に、同じ行に到達したかどうかを認識する必要があります。
このループしやすい問い合わせに、<structfield>path</structfield>と<structfield>cycle</structfield>の２列を加えます。

<programlisting>
WITH RECURSIVE search_graph(id, link, data, depth, path, cycle) AS (
    SELECT g.id, g.link, g.data, 1,
      ARRAY[g.id],
      false
    FROM graph g
  UNION ALL
    SELECT g.id, g.link, g.data, sg.depth + 1,
      path || g.id,
      g.id = ANY(path)
    FROM graph g, search_graph sg
    WHERE g.id = sg.link AND NOT cycle
)
SELECT * FROM search_graph;
</programlisting>

<!--
   Aside from preventing cycles, the array value is often useful in its own
   right as representing the <quote>path</quote> taken to reach any particular row.
-->
巡回防止の他に、特定行に到達する際に選ばれた<quote>path</quote> それ自体を表示するため、配列値はしばしば利用価値があります。
  </para>

  <para>
<!--
   In the general case where more than one field needs to be checked to
   recognize a cycle, use an array of rows.  For example, if we needed to
   compare fields <structfield>f1</structfield> and <structfield>f2</structfield>:
-->
循環を認識するために検査するために必要なフィールドが複数存在する一般的な状況では、行の配列を使用します。
例えば、フィールド<structfield>f1</structfield>と<structfield>f2</structfield>を比較する必要があるときは次のようにします。

<programlisting>
WITH RECURSIVE search_graph(id, link, data, depth, path, cycle) AS (
    SELECT g.id, g.link, g.data, 1,
      ARRAY[ROW(g.f1, g.f2)],
      false
    FROM graph g
  UNION ALL
    SELECT g.id, g.link, g.data, sg.depth + 1,
      path || ROW(g.f1, g.f2),
      ROW(g.f1, g.f2) = ANY(path)
    FROM graph g, search_graph sg
    WHERE g.id = sg.link AND NOT cycle
)
SELECT * FROM search_graph;
</programlisting>
  </para>

  <tip>
   <para>
<!--
    Omit the <literal>ROW()</literal> syntax in the common case where only one field
    needs to be checked to recognize a cycle.  This allows a simple array
    rather than a composite-type array to be used, gaining efficiency.
-->
循環を認識するために検査するために必要なフィールドが１つだけである一般的な場合では、<literal>ROW()</literal>構文を削除します。
これで、複合型配列ではなく単純配列で済むので、効率も上がります。
   </para>
  </tip>

  <tip>
   <para>
<!--
    The recursive query evaluation algorithm produces its output in
    breadth-first search order.  You can display the results in depth-first
    search order by making the outer query <literal>ORDER BY</literal> a
    <quote>path</quote> column constructed in this way.
-->
再帰的問い合わせ評価アルゴリズムは、幅優先探索順でその出力を作成します。
このようにして作られた<quote>path</quote>列を外側問い合わせで<literal>ORDER BY</literal>すれば、深さ優先探索順の結果の表示が可能です。
   </para>
  </tip>

  <para>
<!--
   A helpful trick for testing queries
   when you are not certain if they might loop is to place a <literal>LIMIT</literal>
   in the parent query.  For example, this query would loop forever without
   the <literal>LIMIT</literal>:
-->
ループするかどうか確信が持てない問い合わせをテストする有益な秘訣として、親問い合わせに<literal>LIMIT</literal>を配置します。
例えば、以下の問い合わせは<literal>LIMIT</literal>がないと永久にループします。

<programlisting>
WITH RECURSIVE t(n) AS (
    SELECT 1
  UNION ALL
    SELECT n+1 FROM t
)
SELECT n FROM t LIMIT 100;
</programlisting>

<!--
   This works because <productname>PostgreSQL</productname>'s implementation
   evaluates only as many rows of a <literal>WITH</literal> query as are actually
   fetched by the parent query.  Using this trick in production is not
   recommended, because other systems might work differently.  Also, it
   usually won't work if you make the outer query sort the recursive query's
   results or join them to some other table, because in such cases the
   outer query will usually try to fetch all of the <literal>WITH</literal> query's
   output anyway.
-->
これが動作するのは、<productname>PostgreSQL</productname>の実装が、実際に親問い合わせで取り出されるのと同じ数の<literal>WITH</literal>問い合わせの行のみを評価するからです。
この秘訣を実稼動環境で使用することは勧められません。
他のシステムでは異なった動作をする可能性があるからです。
同時に、もし外部問い合わせを再帰的問い合わせの結果を並べ替えたり、またはそれらを他のテーブルと結合するような書き方をした場合、動作しません。
このような場合、外部問い合わせは通常、<literal>WITH</literal>問い合わせの出力をとにかくすべて取り込もうとするからです。
  </para>

  <para>
<!--
   A useful property of <literal>WITH</literal> queries is that they are
   normally evaluated only once per execution of the parent query, even if
   they are referred to more than once by the parent query or
   sibling <literal>WITH</literal> queries.
   Thus, expensive calculations that are needed in multiple places can be
   placed within a <literal>WITH</literal> query to avoid redundant work.  Another
   possible application is to prevent unwanted multiple evaluations of
   functions with side-effects.
   However, the other side of this coin is that the optimizer is not able to
   push restrictions from the parent query down into a multiply-referenced
   <literal>WITH</literal> query, since that might affect all uses of the
   <literal>WITH</literal> query's output when it should affect only one.
   The multiply-referenced <literal>WITH</literal> query will be
   evaluated as written, without suppression of rows that the parent query
   might discard afterwards.  (But, as mentioned above, evaluation might stop
   early if the reference(s) to the query demand only a limited number of
   rows.)
-->
有用な<literal>WITH</literal>問い合わせの特性は、親問い合わせ、もしくは兄弟<literal>WITH</literal>問い合わせによりたとえ１回以上参照されるとしても、通常は親問い合わせ実行で１回だけ評価されることです。
したがって、複数の場所で必要な高価な計算は、冗長作業を防止するため<literal>WITH</literal>問い合わせの中に配置することができます。
他にありうる適用としては、望まれない副作用のある関数の多重評価を避けることです。
しかし、反対の見方をすれば、オプティマイザが親クエリから複数参照される<literal>WITH</literal>問い合わせに制約を押し下げることができないということになります。
これは、<literal>WITH</literal>問い合わせの出力が1つのみに影響する場合、その出力のすべての使用に影響する可能性があるためです。
複数参照される<literal>WITH</literal>問い合わせは、親問い合わせが後で破棄するであろう行を抑制せずに、書かれた通りに評価されます。
（しかし、上で述べたように、問い合わせの参照が限定された数の行のみを要求する場合、評価は早期に停止します。）
  </para>

  <para>
<!--
   However, if a <literal>WITH</literal> query is non-recursive and
   side-effect-free (that is, it is a <literal>SELECT</literal> containing
   no volatile functions) then it can be folded into the parent query,
   allowing joint optimization of the two query levels.  By default, this
   happens if the parent query references the <literal>WITH</literal> query
   just once, but not if it references the <literal>WITH</literal> query
   more than once.  You can override that decision by
   specifying <literal>MATERIALIZED</literal> to force separate calculation
   of the <literal>WITH</literal> query, or by specifying <literal>NOT
   MATERIALIZED</literal> to force it to be merged into the parent query.
   The latter choice risks duplicate computation of
   the <literal>WITH</literal> query, but it can still give a net savings if
   each usage of the <literal>WITH</literal> query needs only a small part
   of the <literal>WITH</literal> query's full output.
-->
しかし、<literal>WITH</literal>問い合わせが非再帰で副作用がない（つまり、揮発性（volatile）の関数を含まない<literal>SELECT</literal>である）場合は、親問い合わせに組み込むことができ、2つの問い合わせレベルを同時に最適化できます。
デフォルトでは、親問い合わせが<literal>WITH</literal>問い合わせを1回だけ参照する場合にこれが発生しますが、<literal>WITH</literal>問い合わせを2回以上参照する場合には発生しません。
この決定を上書きするには、<literal>MATERIALIZED</literal>を指定して<literal>WITH</literal>問い合わせの個別の計算を強制するか、<literal>NOT MATERIALIZED</literal>を指定して親問い合わせにマージするようにします。
後者を選択すると、<literal>WITH</literal>問い合わせの計算が重複する危険性がありますが、<literal>WITH</literal>問い合わせを使用するたびに<literal>WITH</literal>問い合わせのごく一部しか必要としない場合は、全体の節約になります。
  </para>

  <para>
<!--
   A simple example of these rules is
-->
これらのルールの簡単な例を次に示します。
<programlisting>
WITH w AS (
    SELECT * FROM big_table
)
SELECT * FROM w WHERE key = 123;
</programlisting>
<!--
   This <literal>WITH</literal> query will be folded, producing the same
   execution plan as
-->
この<literal>WITH</literal>問い合わせは組み込まれ、次のものと同じ実行計画を生成します。
<programlisting>
SELECT * FROM big_table WHERE key = 123;
</programlisting>
<!--
   In particular, if there's an index on <structfield>key</structfield>,
   it will probably be used to fetch just the rows having <literal>key =
   123</literal>.  On the other hand, in
-->
特に、<structfield>key</structfield>インデックスがある場合、<literal>key = 123</literal>を持つ行のみをフェッチするために使用される可能性があります。
一方で、
<programlisting>
WITH w AS (
    SELECT * FROM big_table
)
SELECT * FROM w AS w1 JOIN w AS w2 ON w1.key = w2.ref
WHERE w2.key = 123;
</programlisting>
<!--
   the <literal>WITH</literal> query will be materialized, producing a
   temporary copy of <structname>big_table</structname> that is then
   joined with itself &mdash; without benefit of any index.  This query
   will be executed much more efficiently if written as
-->
この<literal>WITH</literal>問い合わせでは実体化され、<structname>big_table</structname>の一時的なコピーが生成されます。このコピーはインデックスのメリットなしに、それ自体に結合されます。
この問い合わせは次のように記述すると、より効率的に実行されます。
<programlisting>
WITH w AS NOT MATERIALIZED (
    SELECT * FROM big_table
)
SELECT * FROM w AS w1 JOIN w AS w2 ON w1.key = w2.ref
WHERE w2.key = 123;
</programlisting>
<!--
   so that the parent query's restrictions can be applied directly
   to scans of <structname>big_table</structname>.
-->
親の問い合わせの制限を<structname>big_table</structname>のスキャンに直接適用することが出来ます。
  </para>

  <para>
<!--
   An example where <literal>NOT MATERIALIZED</literal> could be
   undesirable is
-->
<literal>NOT MATERIALIZED</literal>が望ましくない例を次に示します。
<programlisting>
WITH w AS (
    SELECT key, very_expensive_function(val) as f FROM some_table
)
SELECT * FROM w AS w1 JOIN w AS w2 ON w1.f = w2.f;
</programlisting>
<!--
   Here, materialization of the <literal>WITH</literal> query ensures
   that <function>very_expensive_function</function> is evaluated only
   once per table row, not twice.
-->
ここで、<literal>WITH</literal>問い合わせを生成すると、<function>very_expensive_function</function>がテーブルの行毎に１回のみ評価され、２回は評価されないことが保証されます。
  </para>

  <para>
<!--
   The examples above only show <literal>WITH</literal> being used with
   <command>SELECT</command>, but it can be attached in the same way to
   <command>INSERT</command>, <command>UPDATE</command>, or <command>DELETE</command>.
   In each case it effectively provides temporary table(s) that can
   be referred to in the main command.
-->
上の例では<command>SELECT</command>を使用する<literal>WITH</literal>のみを示しています。
しかし、同じ方法で<command>INSERT</command>、<command>UPDATE</command>、または<command>DELETE</command>に対して付与することができます。
それぞれの場合において、これは主コマンド内で参照可能な一時テーブルを実質的に提供します。
  </para>
 </sect2>

 <sect2 id="queries-with-modifying">
<!--
   <title>Data-Modifying Statements in <literal>WITH</literal></title>
-->
   <title><literal>WITH</literal>内のデータ変更文</title>

   <para>
<!--
    You can use data-modifying statements (<command>INSERT</command>,
    <command>UPDATE</command>, or <command>DELETE</command>) in <literal>WITH</literal>.  This
    allows you to perform several different operations in the same query.
    An example is:
-->
<literal>WITH</literal>内でデータ変更文（<command>INSERT</command>、<command>UPDATE</command>、<command>DELETE</command>）を使用することができます。
これにより同じ問い合わせ内で複数の異なる操作を行うことができます。

<programlisting>
WITH moved_rows AS (
    DELETE FROM products
    WHERE
        "date" &gt;= '2010-10-01' AND
        "date" &lt; '2010-11-01'
    RETURNING *
)
INSERT INTO products_log
SELECT * FROM moved_rows;
</programlisting>

<!--
    This query effectively moves rows from <structname>products</structname> to
    <structname>products_log</structname>.  The <command>DELETE</command> in <literal>WITH</literal>
    deletes the specified rows from <structname>products</structname>, returning their
    contents by means of its <literal>RETURNING</literal> clause; and then the
    primary query reads that output and inserts it into
    <structname>products_log</structname>.
-->
この問い合わせは実質、<structname>products</structname>から<structname>products_log</structname>に行を移動します。
<literal>WITH</literal>内の<command>DELETE</command>は<structname>products</structname>から指定した行を削除し、その<literal>RETURNING</literal>句により削除した内容を返します。
その後、主問い合わせはその出力を読み取り、それを<structname>products_log</structname>に挿入します。
   </para>

   <para>
<!--
    A fine point of the above example is that the <literal>WITH</literal> clause is
    attached to the <command>INSERT</command>, not the sub-<command>SELECT</command> within
    the <command>INSERT</command>.  This is necessary because data-modifying
    statements are only allowed in <literal>WITH</literal> clauses that are attached
    to the top-level statement.  However, normal <literal>WITH</literal> visibility
    rules apply, so it is possible to refer to the <literal>WITH</literal>
    statement's output from the sub-<command>SELECT</command>.
-->
上の例の見事なところは、<literal>WITH</literal>句が<command>INSERT</command>内の副<command>SELECT</command>ではなく、<command>INSERT</command>に付与されていることです。
これは、データ更新文は最上位レベルの文に付与される<literal>WITH</literal>句内でのみ許されているため必要です。
しかし、通常の<literal>WITH</literal>の可視性規則が適用されますので、副<command>SELECT</command>から<literal>WITH</literal>文の出力を参照することができます。
   </para>

   <para>
<!--
    Data-modifying statements in <literal>WITH</literal> usually have
    <literal>RETURNING</literal> clauses (see <xref linkend="dml-returning"/>),
    as shown in the example above.
    It is the output of the <literal>RETURNING</literal> clause, <emphasis>not</emphasis> the
    target table of the data-modifying statement, that forms the temporary
    table that can be referred to by the rest of the query.  If a
    data-modifying statement in <literal>WITH</literal> lacks a <literal>RETURNING</literal>
    clause, then it forms no temporary table and cannot be referred to in
    the rest of the query.  Such a statement will be executed nonetheless.
    A not-particularly-useful example is:
-->
上の例で示したように、<literal>WITH</literal>内のデータ変更文は通常<literal>RETURNING</literal>句（<xref linkend="dml-returning"/>を参照）を持ちます。
問い合わせの残りの部分で参照することができる一時テーブルを形成するのは、<literal>RETURNING</literal>句の出力の出力であって、データ変更文の対象テーブルでは<emphasis>ありません</emphasis>。
<literal>WITH</literal>内のデータ変更文が<literal>RETURNING</literal>句を持たない場合、一時テーブルを形成しませんので、問い合わせの残りの部分で参照することができません。
これにもかかわらずこうした文は実行されます。
特別有用でもない例を以下に示します。

<programlisting>
WITH t AS (
    DELETE FROM foo
)
DELETE FROM bar;
</programlisting>

<!--
    This example would remove all rows from tables <structname>foo</structname> and
    <structname>bar</structname>.  The number of affected rows reported to the client
    would only include rows removed from <structname>bar</structname>.
-->
この例は<structname>foo</structname>テーブルと<structname>bar</structname>テーブルからすべての行を削除します。
クライアントに報告される影響を受けた行数には<structname>bar</structname>から削除された行のみが含まれます。
   </para>

   <para>
<!--
    Recursive self-references in data-modifying statements are not
    allowed.  In some cases it is possible to work around this limitation by
    referring to the output of a recursive <literal>WITH</literal>, for example:
-->
データ変更文内の再帰的な自己参照は許されません。
一部の場合において、再帰的な<literal>WITH</literal>の出力を参照することで、この制限を回避することができます。
以下に例を示します。

<programlisting>
WITH RECURSIVE included_parts(sub_part, part) AS (
    SELECT sub_part, part FROM parts WHERE part = 'our_product'
  UNION ALL
    SELECT p.sub_part, p.part
    FROM included_parts pr, parts p
    WHERE p.part = pr.sub_part
)
DELETE FROM parts
  WHERE part IN (SELECT part FROM included_parts);
</programlisting>

<!--
    This query would remove all direct and indirect subparts of a product.
-->
この問い合わせはある製品の直接的な部品と間接的な部品をすべて削除します。
   </para>

   <para>
<!--
    Data-modifying statements in <literal>WITH</literal> are executed exactly once,
    and always to completion, independently of whether the primary query
    reads all (or indeed any) of their output.  Notice that this is different
    from the rule for <command>SELECT</command> in <literal>WITH</literal>: as stated in the
    previous section, execution of a <command>SELECT</command> is carried only as far
    as the primary query demands its output.
-->
<literal>WITH</literal>内のデータ変更文は正確に１回のみ実行され、主問い合わせがその出力をすべて（実際にはいずれか）を呼び出したかどうかに関係なく、常に完了します。
これが、前節で説明した主問い合わせがその出力を要求した時のみに<command>SELECT</command>の実行が行われるという<literal>WITH</literal>内の<command>SELECT</command>についての規則と異なることに注意してください。
   </para>

   <para>
<!--
    The sub-statements in <literal>WITH</literal> are executed concurrently with
    each other and with the main query.  Therefore, when using data-modifying
    statements in <literal>WITH</literal>, the order in which the specified updates
    actually happen is unpredictable.  All the statements are executed with
    the same <firstterm>snapshot</firstterm> (see <xref linkend="mvcc"/>), so they
    cannot <quote>see</quote> one another's effects on the target tables.  This
    alleviates the effects of the unpredictability of the actual order of row
    updates, and means that <literal>RETURNING</literal> data is the only way to
    communicate changes between different <literal>WITH</literal> sub-statements and
    the main query.  An example of this is that in
-->
<literal>WITH</literal>内の副文はそれぞれと主問い合わせで同時に実行されます。
したがって<literal>WITH</literal>内のデータ変更文を使用する時、指定したデータ変更文が実際に実行される順序は予測できません。
すべての文は同じ<firstterm>スナップショット</firstterm>（<xref linkend="mvcc"/>参照）を用いて実行されます。
このため互いが対象テーブルに行った影響を<quote>見る</quote>ことはできません。これは、行の更新に関する実際の順序が予測できないという影響を軽減し、<literal>RETURNING</literal>データが別の<literal>WITH</literal>副文と主問い合わせとの間で変更を伝える唯一の手段であることを意味します。
この例を以下に示します。

<programlisting>
WITH t AS (
    UPDATE products SET price = price * 1.05
    RETURNING *
)
SELECT * FROM products;
</programlisting>

<!--
    the outer <command>SELECT</command> would return the original prices before the
    action of the <command>UPDATE</command>, while in
-->
外側の<command>SELECT</command>は<command>UPDATE</command>の動作前の元々の価格を返します。

<programlisting>
WITH t AS (
    UPDATE products SET price = price * 1.05
    RETURNING *
)
SELECT * FROM t;
</programlisting>

<!--
    the outer <command>SELECT</command> would return the updated data.
-->
一方こちらでは外側の<command>SELECT</command>は更新されたデータを返します。
   </para>

   <para>
<!--
    Trying to update the same row twice in a single statement is not
    supported.  Only one of the modifications takes place, but it is not easy
    (and sometimes not possible) to reliably predict which one.  This also
    applies to deleting a row that was already updated in the same statement:
    only the update is performed.  Therefore you should generally avoid trying
    to modify a single row twice in a single statement.  In particular avoid
    writing <literal>WITH</literal> sub-statements that could affect the same rows
    changed by the main statement or a sibling sub-statement.  The effects
    of such a statement will not be predictable.
-->
単一の文で同じ行を２回更新しようとすることはサポートされていません。
変更のうちの１つだけが行われますが、どれが実行されるかを確実に予測することは簡単ではありません（場合によっては不可能です）。
これはまた、同じ文内ですでに更新された行を削除する場合でも当てはまり、更新のみが実行されます。
したがって一般的には単一の文で１つの行を２回変更しようと試みることを避けなければなりません。
具体的には主文または同レベルの副文で変更される行と同じ行に影響を与える<literal>WITH</literal>副文を記述することは避けてください。
こうした文の影響は予測することはできません。
   </para>

   <para>
<!--
    At present, any table used as the target of a data-modifying statement in
    <literal>WITH</literal> must not have a conditional rule, nor an <literal>ALSO</literal>
    rule, nor an <literal>INSTEAD</literal> rule that expands to multiple statements.
-->
現状、<literal>WITH</literal>内のデータ変更文の対象として使用されるテーブルはすべて、複数の文に展開される条件付きルール、<literal>ALSO</literal>ルール、<literal>INSTEAD</literal>ルールを持ってはなりません。
   </para>

  </sect2>

 </sect1>

</chapter>
