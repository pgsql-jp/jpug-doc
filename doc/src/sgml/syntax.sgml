<!-- doc/src/sgml/syntax.sgml -->

<chapter id="sql-syntax">
<!--
 <title>SQL Syntax</title>
-->
 <title>SQLの構文</title>

 <indexterm zone="sql-syntax">
<!--
  <primary>syntax</primary>
-->
  <primary>構文</primary>
  <secondary>SQL</secondary>
 </indexterm>

 <para>
<!--
  This chapter describes the syntax of SQL.  It forms the foundation
  for understanding the following chapters which will go into detail
  about how SQL commands are applied to define and modify data.
-->
本章ではSQLの構文について説明します。
本章の内容は、データの定義や変更のためにSQLコマンドを適用する方法について詳しく説明する以後の章を理解する上での基礎となります。
 </para>

 <para>
<!--
  We also advise users who are already familiar with SQL to read this
  chapter carefully because it contains several rules and concepts that
  are implemented inconsistently among SQL databases or that are
  specific to <productname>PostgreSQL</productname>.
-->
この章はSQLデータベース間で異なって実装されたり、または<productname>PostgreSQL</productname>に固有な幾つかの規則と概念を含んでいるので、SQLについて熟知しているユーザも本章を注意深く読むことをお勧めします。
 </para>

 <sect1 id="sql-syntax-lexical">
<!--
  <title>Lexical Structure</title>
-->
  <title>語彙の構成</title>

  <indexterm>
<!--
   <primary>token</primary>
-->
   <primary>トークン</primary>
  </indexterm>

  <para>
<!--
   SQL input consists of a sequence of
   <firstterm>commands</firstterm>.  A command is composed of a
   sequence of <firstterm>tokens</firstterm>, terminated by a
   semicolon (<quote>;</quote>).  The end of the input stream also
   terminates a command.  Which tokens are valid depends on the syntax
   of the particular command.
-->
SQLの入力は、ひと続きの<firstterm>コマンド</firstterm>からなります。
コマンドは<firstterm>トークン</firstterm>が繋がったもので構成され、最後はセミコロン（<quote>;</quote>）で終わります。
入力ストリームの終了もやはりコマンドを終わらせます。
どのトークンが有効かは特定のコマンドの構文によります。
  </para>

  <para>
<!--
   A token can be a <firstterm>key word</firstterm>, an
   <firstterm>identifier</firstterm>, a <firstterm>quoted
   identifier</firstterm>, a <firstterm>literal</firstterm> (or
   constant), or a special character symbol.  Tokens are normally
   separated by whitespace (space, tab, newline), but need not be if
   there is no ambiguity (which is generally only the case if a
   special character is adjacent to some other token type).
-->
トークンは<firstterm>キーワード</firstterm>、<firstterm>識別子</firstterm>、<firstterm>引用符で囲まれた識別子</firstterm>、<firstterm>リテラル</firstterm>（もしくは定数）、特別な文字シンボルです。
トークンは通常空白（スペース、タブ、改行）で区切られますが、曖昧さがなければ（一般的には特別な文字が他のトークン型と隣接している場合のみ）必要ありません。
  </para>

   <para>
<!--
    For example, the following is (syntactically) valid SQL input:
-->
例えば、以下のものは（構文的に）正しいSQLの入力です。
<programlisting>
SELECT * FROM MY_TABLE;
UPDATE MY_TABLE SET A = 5;
INSERT INTO MY_TABLE VALUES (3, 'hi there');
</programlisting>
<!--
    This is a sequence of three commands, one per line (although this
    is not required; more than one command can be on a line, and
    commands can usefully be split across lines).
-->
この例は1行に1つのコマンドを記述した、3つのコマンドが連続しています（必ずしも1つのコマンドを1行で書く必要はありません。 1行に複数のコマンドを入力することも可能ですし、1つのコマンドを複数行に分けて記述することも可能です）。
   </para>

  <para>
<!--
   Additionally, <firstterm>comments</firstterm> can occur in SQL
   input.  They are not tokens, they are effectively equivalent to
   whitespace.
-->
さらに、入力されたSQLに<firstterm>コメント</firstterm>が付いていても構いません。
コメントはトークンではなく、その効果は空白と同じです。
  </para>

  <para>
<!--
   The SQL syntax is not very consistent regarding what tokens
   identify commands and which are operands or parameters.  The first
   few tokens are generally the command name, so in the above example
   we would usually speak of a <quote>SELECT</quote>, an
   <quote>UPDATE</quote>, and an <quote>INSERT</quote> command.  But
   for instance the <command>UPDATE</command> command always requires
   a <token>SET</token> token to appear in a certain position, and
   this particular variation of <command>INSERT</command> also
   requires a <token>VALUES</token> in order to be complete.  The
   precise syntax rules for each command are described in <xref linkend="reference">.
-->
SQL構文は、どのトークンがコマンドを識別し、どれがオペランドでどれがパラメータかに関してはさほど首尾一貫していません。
最初のいくつかのトークンは一般にコマンド名です。 
したがって、上記の例において<quote>SELECT</quote>、<quote>UPDATE</quote>、<quote>INSERT</quote>コマンドについて通常説明することになります。
しかし、例えば<command>UPDATE</command>コマンドでは、<token>SET</token>トークンが特定の位置に常に記述されなければなりませんし、この例で使われている<command>INSERT</command>コマンドを完結するためには<token>VALUES</token>トークンが必要です。
それぞれのコマンドの正確な構文規則は<xref linkend="reference">で説明されています。
  </para>

  <sect2 id="sql-syntax-identifiers">
<!--
   <title>Identifiers and Key Words</title>
-->
   <title>識別子とキーワード</title>

   <indexterm zone="sql-syntax-identifiers">
<!--
    <primary>identifier</primary>
    <secondary>syntax of</secondary>
-->
    <primary>識別子</primary>
    <secondary>の構文</secondary>
   </indexterm>

   <indexterm zone="sql-syntax-identifiers">
<!--
    <primary>name</primary>
    <secondary>syntax of</secondary>
-->
    <primary>名前</primary>
    <secondary>の構文</secondary>
   </indexterm>

   <indexterm zone="sql-syntax-identifiers">
<!--
    <primary>key word</primary>
    <secondary>syntax of</secondary>
-->
    <primary>キーワード</primary>
    <secondary>の構文</secondary>
   </indexterm>

   <para>
<!--
    Tokens such as <token>SELECT</token>, <token>UPDATE</token>, or
    <token>VALUES</token> in the example above are examples of
    <firstterm>key words</firstterm>, that is, words that have a fixed
    meaning in the SQL language.  The tokens <token>MY_TABLE</token>
    and <token>A</token> are examples of
    <firstterm>identifiers</firstterm>.  They identify names of
    tables, columns, or other database objects, depending on the
    command they are used in.  Therefore they are sometimes simply
    called <quote>names</quote>.  Key words and identifiers have the
    same lexical structure, meaning that one cannot know whether a
    token is an identifier or a key word without knowing the language.
    A complete list of key words can be found in <xref
    linkend="sql-keywords-appendix">.
-->
上記の例に出てくる<token>SELECT</token>、<token>UPDATE</token>、もしくは<token>VALUES</token>のようなトークンは、<firstterm>キーワード</firstterm>の一例です。
キーワードとは、SQL言語で決まった意味を持っている単語です。
<token>MY_TABLE</token>トークンや<token>A</token>トークンは<firstterm>識別子</firstterm>の一例です。
これらは、使われるコマンドによって、テーブル、列、他のデータベースオブジェクトの名前を識別します。
したがって、単に<quote>名前</quote>と呼ばれることもあります。
キーワードと識別子は同じ語彙の構造を持つため、言語を知らなくてはトークンが識別子なのかキーワードなのかわからないということになります。
全てのキーワードのリストは<xref linkend="sql-keywords-appendix">にあります。
   </para>

   <para>
<!--
    SQL identifiers and key words must begin with a letter
    (<literal>a</literal>-<literal>z</literal>, but also letters with
    diacritical marks and non-Latin letters) or an underscore
    (<literal>_</literal>).  Subsequent characters in an identifier or
    key word can be letters, underscores, digits
    (<literal>0</literal>-<literal>9</literal>), or dollar signs
    (<literal>$</>).  Note that dollar signs are not allowed in identifiers
    according to the letter of the SQL standard, so their use might render
    applications less portable.
    The SQL standard will not define a key word that contains
    digits or starts or ends with an underscore, so identifiers of this
    form are safe against possible conflict with future extensions of the
    standard.
-->
SQL識別子とキーワードは、文字（<literal>a</literal>〜<literal>z</literal>および発音区別符号付き文字と非Latin文字)、アンダースコア（<literal>_</literal>）で始まらなければいけません。
識別子またはキーワードの中で続く文字は、文字、アンダースコア、数字（<literal>0</literal>〜<literal>9</literal>）あるいはドル記号(<literal>$</>)を使用することができます。
標準SQLの記述に従うと、ドル記号は識別子内では使用できないことに注意してください。
ですから、これを使用するとアプリケーションの移植性は低くなる可能性があります。
標準SQLでは、数字を含む、あるいはアンダースコアで始まったり終わったりするキーワードは定義されていません。
したがって、この形式の識別子は標準の今後の拡張と競合する可能性がないという意味で安全と言えます。
   </para>

   <para>
<!--
    <indexterm><primary>identifier</primary><secondary>length</secondary></indexterm>
-->
    <indexterm><primary>識別子</primary><secondary>長さ</secondary></indexterm>
<!--
    The system uses no more than <symbol>NAMEDATALEN</symbol>-1
    bytes of an identifier; longer names can be written in
    commands, but they will be truncated.  By default,
    <symbol>NAMEDATALEN</symbol> is 64 so the maximum identifier
    length is 63 bytes. If this limit is problematic, it can be raised by
    changing the <symbol>NAMEDATALEN</symbol> constant in
    <filename>src/include/pg_config_manual.h</filename>.
-->
システムは<symbol>NAMEDATALEN</symbol>-1バイトより長い識別子の文字数を使いません。 
より長い名前をコマンドで書くことはできますが、短く切られてしまいます。  
デフォルトでは<symbol>NAMEDATALEN</symbol>は64なので、識別子は最長で63バイトです。
この制限が問題になる場合は、<filename>src/include/pg_config_manual.h</filename>内の<symbol>NAMEDATALEN</symbol>定数の値を変更して増やすことができます。
   </para>

   <para>
    <indexterm>
<!--
     <primary>case sensitivity</primary>
     <secondary>of SQL commands</secondary>
-->
     <primary>大文字小文字の区別</primary>
     <secondary>SQLコマンドの</secondary>
    </indexterm>
<!--
    Key words and unquoted identifiers are case insensitive.  Therefore:
-->
キーワードと引用符付きでない(クォートされていない)識別子は大文字と小文字を区別しません。
したがって、
<programlisting>
UPDATE MY_TABLE SET A = 5;
</programlisting>
<!--
    can equivalently be written as:
-->
は、以下の文と同じ意味になります。
<programlisting>
uPDaTE my_TabLE SeT a = 5;
</programlisting>
<!--
    A convention often used is to write key words in upper
    case and names in lower case, e.g.:
-->
慣習的には、キーワードを大文字で、名前を小文字で書きます。 
例えば下記のようになります。
<programlisting>
UPDATE my_table SET a = 5;
</programlisting>
   </para>

   <para>
    <indexterm>
<!--
     <primary>quotation marks</primary>
     <secondary>and identifiers</secondary>
-->
     <primary>引用符</primary>
     <secondary>および識別子</secondary>
    </indexterm>
<!--
    There is a second kind of identifier:  the <firstterm>delimited
    identifier</firstterm> or <firstterm>quoted
    identifier</firstterm>.  It is formed by enclosing an arbitrary
    sequence of characters in double-quotes
    (<literal>"</literal>). <!&#045;&#045; " font-lock mania &#045;&#045;> A delimited
    identifier is always an identifier, never a key word.  So
    <literal>"select"</literal> could be used to refer to a column or
    table named <quote>select</quote>, whereas an unquoted
    <literal>select</literal> would be taken as a key word and
    would therefore provoke a parse error when used where a table or
    column name is expected.  The example can be written with quoted
    identifiers like this:
-->
識別子には副次的な種類もあります。
<firstterm>区切り識別子</firstterm>あるいは<firstterm>引用符付き識別子</firstterm>です。
任意の文字の連なりを二重引用符（<literal>"</literal>）で囲んだものです。<!-- " フォントロック狂 -->
区切り識別子は常に識別子であって、キーワードではありません。
ですから、<literal>"select"</literal>は<quote>select</quote>という名前の列あるいはテーブルを問い合わせるために使えますが、引用符の付かない<literal>select</literal>はキーワードとして理解されるので、テーブルもしくは列名が期待される部分では解析エラーを起こします。
引用符付き識別子は下記の例のように書くことができます。
<programlisting>
UPDATE "my_table" SET "a" = 5;
</programlisting>
   </para>

   <para>
<!--
    Quoted identifiers can contain any character, except the character
    with code zero.  (To include a double quote, write two double quotes.)
    This allows constructing table or column names that would
    otherwise not be possible, such as ones containing spaces or
    ampersands.  The length limitation still applies.
-->
引用符付き識別子は、文字コード0以外であればどのような文字でも使えます
（二重引用符を含めたい場合は、二重引用符を2つ入力します）。
この決まりがあることによって、普段使えない空白やアンパサンド（&amp;）を含むテーブル名や列名を作ることが可能です。
この場合においても長さの制限は適用されます。
   </para>

   <indexterm>
<!--
     <primary>Unicode escape</primary>
     <secondary>in identifiers</secondary>
-->
     <primary>Unicodeエスケープ</primary>
     <secondary>識別子中</secondary>
   </indexterm>

   <para>
<!--
    A variant of quoted
    identifiers allows including escaped Unicode characters identified
    by their code points.  This variant starts
    with <literal>U&amp;</literal> (upper or lower case U followed by
    ampersand) immediately before the opening double quote, without
    any spaces in between, for example <literal>U&amp;"foo"</literal>.
    (Note that this creates an ambiguity with the
    operator <literal>&amp;</literal>.  Use spaces around the operator to
    avoid this problem.)  Inside the quotes, Unicode characters can be
    specified in escaped form by writing a backslash followed by the
    four-digit hexadecimal code point number or alternatively a
    backslash followed by a plus sign followed by a six-digit
    hexadecimal code point number.  For example, the
    identifier <literal>"data"</literal> could be written as
-->
引用符付き識別子の変異体はそれらのコード番号で識別されるエスケープされたUnicode文字を含むことができます。
この変異体は、二重引用符開始の直前に<literal>U&amp;</literal>（後にアンパサンドが付いた大文字・小文字のU）で始まります。
例えば、<literal>U&amp;"foo"</literal>となります。
（これにより演算子<literal>&amp;</literal>との不明確性が生じることに注意してください。
この問題を回避するには空白を演算子の前後に入れます。）
引用符の中で、Unicode文字はバックスラッシュとそれに続く４桁１６進数の文字コード番号で、またはもう１つの方法として、バックスラッシュに続いてプラス符号、そして続いた６桁１６進数の文字コード番号によりエスケープ形式で指定されます。
例えば、識別子<literal>"data"</literal>は次のように書かれます。
<programlisting>
U&amp;"d\0061t\+000061"
</programlisting>
<!--
    The following less trivial example writes the Russian
    word <quote>slon</quote> (elephant) in Cyrillic letters:
-->
次のより一般的でない例はロシア語の<quote>slon</quote>（象）をキリル語で書いたものです。
<programlisting>
U&amp;"\0441\043B\043E\043D"
</programlisting>
   </para>

   <para>
<!--
    If a different escape character than backslash is desired, it can
    be specified using
    the <literal>UESCAPE</literal><indexterm><primary>UESCAPE</primary></indexterm>
    clause after the string, for example:
-->
バックスラッシュではない異なるエスケープ文字を使用したい場合、文字列の後に<literal>UESCAPE</literal><indexterm><primary>UESCAPE</primary></indexterm>句を使用して指定することが可能です。例をあげます。
<programlisting>
U&amp;"d!0061t!+000061" UESCAPE '!'
</programlisting>
<!--
    The escape character can be any single character other than a
    hexadecimal digit, the plus sign, a single quote, a double quote,
    or a whitespace character.  Note that the escape character is
    written in single quotes, not double quotes.
-->
エスケープ文字には、16進表記用の文字、プラス記号、単一引用符、二重引用符、空白文字以外の任意の単一文字を使用することができます。
エスケープ文字には二重引用符ではなく単一引用符で記述していることに注意してください。
   </para>

   <para>
<!--
    To include the escape character in the identifier literally, write
    it twice.
-->
識別子内にエスケープ文字をそのまま含めるためには、それを２つ記述してください。
   </para>

   <para>
<!--
    The Unicode escape syntax works only when the server encoding is
    <literal>UTF8</>.  When other server encodings are used, only code
    points in the ASCII range (up to <literal>\007F</literal>) can be
    specified.  Both the 4-digit and the 6-digit form can be used to
    specify UTF-16 surrogate pairs to compose characters with code
    points larger than U+FFFF, although the availability of the
    6-digit form technically makes this unnecessary.  (Surrogate
    pairs are not stored directly, but combined into a single
    code point that is then encoded in UTF-8.)
-->
Unicodeエスケープ構文はサーバの符号化方式が<literal>UTF8</>の場合のみ有効です。
他のサーバ符号化方式が用いられている場合、ASCII範囲（<literal>\007F</literal>まで）のコードポイントのみ指定できます。
技術的には6桁形式の機能によりこれは不要になりますが、4桁または6桁の形式は、U+FFFFより大きなコードポイントを持つ文字を構成するUTF-16サロゲートペアを指定するために使用することができます。
（サロゲートペアは直接格納されませんが、UTF-8に符号化される場合には一つのコードポイントに結合されます。）
   </para>

   <para>
<!--
    Quoting an identifier also makes it case-sensitive, whereas
    unquoted names are always folded to lower case.  For example, the
    identifiers <literal>FOO</literal>, <literal>foo</literal>, and
    <literal>"foo"</literal> are considered the same by
    <productname>PostgreSQL</productname>, but
    <literal>"Foo"</literal> and <literal>"FOO"</literal> are
    different from these three and each other.  (The folding of
    unquoted names to lower case in <productname>PostgreSQL</> is
    incompatible with the SQL standard, which says that unquoted names
    should be folded to upper case.  Thus, <literal>foo</literal>
    should be equivalent to <literal>"FOO"</literal> not
    <literal>"foo"</literal> according to the standard.  If you want
    to write portable applications you are advised to always quote a
    particular name or never quote it.)
-->
引用符が付かない名前は常に小文字に解釈されますが、識別子を引用符で囲むことによって大文字と小文字が区別されるようになります。
例えば、識別子<literal>FOO</literal>、<literal>foo</literal>、<literal>"foo"</literal>は<productname>PostgreSQL</productname>によれば同じものとして解釈されますが、<literal>"Foo"</literal>と<literal>"FOO"</literal>は、これら3つとも、またお互いに違ったものとして解釈されます
（<productname>PostgreSQL</productname>が引用符の付かない名前を小文字として解釈することは標準SQLと互換性がありません。標準SQLでは引用符の付かない名前は大文字に解釈されるべきだとされています。
したがって標準SQLによれば、<literal>foo</literal>は<literal>"FOO"</literal>と同じであるべきで、<literal>"foo"</literal>とは異なるはずなのです。
もし移植可能なアプリケーションを書きたいならば、特定の名前は常に引用符で囲むか、あるいはまったく囲まないかのいずれかに統一することをお勧めします）。
   </para>
  </sect2>


  <sect2 id="sql-syntax-constants">
<!--
   <title>Constants</title>
-->
   <title>定数</title>

   <indexterm zone="sql-syntax-constants">
<!--
    <primary>constant</primary>
-->
    <primary>定数</primary>
   </indexterm>

   <para>
<!--
    There are three kinds of <firstterm>implicitly-typed
    constants</firstterm> in <productname>PostgreSQL</productname>:
    strings, bit strings, and numbers.
    Constants can also be specified with explicit types, which can
    enable more accurate representation and more efficient handling by
    the system. These alternatives are discussed in the following
    subsections.
-->
<productname>PostgreSQL</productname>には、3つの<firstterm>暗黙に型付けされる定数</firstterm>があります。 
文字列、ビット文字列、そして数字です。
定数は明示的な型で指定することもでき、その場合はシステムによる、より正確な表現と効率の良い操作が可能になります。
こうした他の方法については後ほど説明します。
   </para>

   <sect3 id="sql-syntax-strings">
<!--
    <title>String Constants</title>
-->
    <title>文字列定数</title>

    <indexterm zone="sql-syntax-strings">
<!--
     <primary>character string</primary>
     <secondary>constant</secondary>
-->
     <primary>文字列</primary>
     <secondary>定数</secondary>
    </indexterm>

    <para>
     <indexterm>
<!--
      <primary>quotation marks</primary>
      <secondary>escaping</secondary>
-->
      <primary>引用符</primary>
      <secondary>エスケープ</secondary>
     </indexterm>
<!--
     A string constant in SQL is an arbitrary sequence of characters
     bounded by single quotes (<literal>'</literal>), for example
     <literal>'This is a string'</literal>.  To include
     a single-quote character within a string constant,
     write two adjacent single quotes, e.g.,
     <literal>'Dianne''s horse'</literal>.
     Note that this is <emphasis>not</> the same as a double-quote
     character (<literal>"</>). 
-->
     <!-- 原文中のコメント font-lock sanity: " -->
SQLにおける文字列定数は、単一引用符（<literal>'</literal>）で括られた任意の文字の並びです。
例えば、<literal>'This is a string'</literal>です。
文字列定数内の単一引用符の記述方法は、2つ続けて単一引用符を記述することです。
例えば、<literal>'Dianne''s horse'</literal>です。
二重引用符(<literal>"</>)とは同一では<emphasis>ない</>点に注意してください。<!-- font-lock sanity: " -->
    </para>

    <para>
<!--
     Two string constants that are only separated by whitespace
     <emphasis>with at least one newline</emphasis> are concatenated
     and effectively treated as if the string had been written as one
     constant.  For example:
-->
2つの文字列定数が、<emphasis>少なくとも1つの改行</emphasis>を含んだ空白で区切られている場合は、2つの定数は連結され、実質的に1つの定数として書かれたように処理されます。
例を示します。
<programlisting>
SELECT 'foo'
'bar';
</programlisting>
<!--
     is equivalent to:
-->
は、
<programlisting>
SELECT 'foobar';
</programlisting>
<!--
     but:
-->
と同じです。しかし、
<programlisting>
SELECT 'foo'      'bar';
</programlisting>
<!--
     is not valid syntax.  (This slightly bizarre behavior is specified
     by <acronym>SQL</acronym>; <productname>PostgreSQL</productname> is
     following the standard.)
-->
は有効な構文ではありません
（このちょっとした奇妙な振舞いは<acronym>SQL</acronym>で決められているもので、<productname>PostgreSQL</productname>ではこの標準に従っています）。
    </para>
   </sect3>

   <sect3 id="sql-syntax-strings-escape">
<!--
    <title>String Constants with C-style Escapes</title>
-->
    <title>C形式エスケープでの文字列定数</title>

     <indexterm zone="sql-syntax-strings-escape">
<!--
      <primary>escape string syntax</primary>
-->
      <primary>エスケープ文字列構文</primary>
     </indexterm>
     <indexterm zone="sql-syntax-strings-escape">
<!--
      <primary>backslash escapes</primary>
-->
      <primary>バックスラッシュエスケープ</primary>
     </indexterm>

    <para>
<!--
     <productname>PostgreSQL</productname> also accepts <quote>escape</>
     string constants, which are an extension to the SQL standard.
     An escape string constant is specified by writing the letter
     <literal>E</literal> (upper or lower case) just before the opening single
     quote, e.g., <literal>E'foo'</>.  (When continuing an escape string
     constant across lines, write <literal>E</> only before the first opening
     quote.)
     Within an escape string, a backslash character (<literal>\</>) begins a
     C-like <firstterm>backslash escape</> sequence, in which the combination
     of backslash and following character(s) represent a special byte
     value, as shown in <xref linkend="sql-backslash-table">.
-->
<productname>PostgreSQL</productname>では、また、<quote>エスケープ</>文字定数を受け付けます。
これは標準SQLの拡張です。
エスケープ文字定数は、開始単一引用符の直前に<literal>E</literal>(大文字でも小文字でもかまいません)を記述することで指定されます。
例えば<literal>E'foo'</>です。
（複数行に渡るエスケープ文字定数では、最初の開始引用符の前にのみ<literal>E</>を記述してください。）
エスケープ文字列の中では、バックスラッシュ文字（<literal>\</>）によりC言語のような<firstterm>バックスラッシュ</>シーケンスが開始し、その中でバックスラッシュとそれに続く文字の組み合わせが（<xref linkend="sql-backslash-table">で示したように）特別なバイト値を表現します。
    </para>

     <table id="sql-backslash-table">
<!--
      <title>Backslash Escape Sequences</title>
-->
      <title>バックスラッシュエスケープシーケンス</title>
      <tgroup cols="2">
      <thead>
       <row>
<!--
        <entry>Backslash Escape Sequence</>
        <entry>Interpretation</entry>
-->
        <entry>バックスラッシュエスケープシーケンス</>
        <entry>解釈</entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry><literal>\b</literal></entry>
<!--
        <entry>backspace</entry>
-->
        <entry>後退</entry>
       </row>
       <row>
        <entry><literal>\f</literal></entry>
<!--
        <entry>form feed</entry>
-->
        <entry>改ページ</entry>
       </row>
       <row>
        <entry><literal>\n</literal></entry>
<!--
        <entry>newline</entry>
-->
        <entry>改行</entry>
       </row>
       <row>
        <entry><literal>\r</literal></entry>
<!--
        <entry>carriage return</entry>
-->
        <entry>復帰</entry>
       </row>
       <row>
        <entry><literal>\t</literal></entry>
<!--
        <entry>tab</entry>
-->
        <entry>タブ</entry>
       </row>
       <row>
        <entry>
         <literal>\<replaceable>o</replaceable></literal>,
         <literal>\<replaceable>oo</replaceable></literal>,
         <literal>\<replaceable>ooo</replaceable></literal>
         (<replaceable>o</replaceable> = 0 - 7)
        </entry>
<!--
        <entry>octal byte value</entry>
-->
        <entry>８進数バイト値</entry>
       </row>
       <row>
        <entry>
         <literal>\x<replaceable>h</replaceable></literal>,
         <literal>\x<replaceable>hh</replaceable></literal>
         (<replaceable>h</replaceable> = 0 - 9, A - F)
        </entry>
<!--
        <entry>hexadecimal byte value</entry>
-->
        <entry>１６進数バイト値</entry>
       </row>
       <row>
        <entry>
         <literal>\u<replaceable>xxxx</replaceable></literal>,
         <literal>\U<replaceable>xxxxxxxx</replaceable></literal>
         (<replaceable>x</replaceable> = 0 - 9, A - F)
        </entry>
<!--
        <entry>16 or 32-bit hexadecimal Unicode character value</entry>
-->
        <entry>16もしくは32ビットの16進数 Unicode 文字値</entry>
       </row>
      </tbody>
      </tgroup>
     </table>

    <para>
<!--
     Any other
     character following a backslash is taken literally. Thus, to
     include a backslash character, write two backslashes (<literal>\\</>).
     Also, a single quote can be included in an escape string by writing
     <literal>\'</literal>, in addition to the normal way of <literal>''</>.
-->
バックスラッシュの後のそのほかの全ての文字はそのまま扱われます。
従って、バックスラッシュ文字を含ませるときは２つのバックスラッシュ（<literal>\\</>）を記載します。
同時に、エスケープ文字列の中の１つの単一引用符は、通常の方法の<literal>''</>に加え、<literal>\'</literal>として含むことができます。
    </para>

    <para>
<!--
     It is your responsibility that the byte sequences you create,
     especially when using the octal or hexadecimal escapes, compose
     valid characters in the server character set encoding.  When the
     server encoding is UTF-8, then the Unicode escapes or the
     alternative Unicode escape syntax, explained
     in <xref linkend="sql-syntax-strings-uescape">, should be used
     instead.  (The alternative would be doing the UTF-8 encoding by
     hand and writing out the bytes, which would be very cumbersome.)
-->
特に10進数や16進数エスケープを用いて作成されるバイトシーケンスが、サーバ文字セット符号化方式において有効な文字で構成されていることはコードを書く人の責任です。
サーバ符号化方式がUTF-8の場合、Unicodeエスケープか、<xref linkend="sql-syntax-strings-uescape">で説明したもう一方のUnicodeエスケープ構文を代わりとして使用すべきです。
（代案は手作業でUTF-8符号化を行い、書き出さなくてはならないのでとても厄介です。）
    </para>

    <para>
<!--
     The Unicode escape syntax works fully only when the server
     encoding is <literal>UTF8</>.  When other server encodings are
     used, only code points in the ASCII range (up
     to <literal>\u007F</>) can be specified.  Both the 4-digit and
     the 8-digit form can be used to specify UTF-16 surrogate pairs to
     compose characters with code points larger than U+FFFF, although
     the availability of the 8-digit form technically makes this
     unnecessary.  (When surrogate pairs are used when the server
     encoding is <literal>UTF8</>, they are first combined into a
     single code point that is then encoded in UTF-8.)
-->
Unicodeエスケープ構文は、サーバの符号化方式が<literal>UTF8</>である場合のみ、完全に動作します。
他のサーバ符号化方式が使用されている場合、ASCII範囲（<literal>\u007F</>まで）のコードポイントのみを指定することができます。
技術的には8桁形式の機能によりこれは不要になりますが、4桁または8桁の形式は、U+FFFFより大きなコードポイントを持つ文字を構成するUTF-16サロゲートペアを指定するために使用することができます。
（サーバの符号化方式が<literal>UTF8</>の場合にサロゲートペアが使用される時、まず単一のコードポイントに組み合わされ、その後にUTF-8に符号化されます。）
    </para>

    <caution>
    <para>
<!--
     If the configuration parameter
     <xref linkend="guc-standard-conforming-strings"> is <literal>off</>,
     then <productname>PostgreSQL</productname> recognizes backslash escapes
     in both regular and escape string constants.  However, as of
     <productname>PostgreSQL</> 9.1, the default is <literal>on</>, meaning
     that backslash escapes are recognized only in escape string constants.
     This behavior is more standards-compliant, but might break applications
     which rely on the historical behavior, where backslash escapes
     were always recognized.  As a workaround, you can set this parameter
     to <literal>off</>, but it is better to migrate away from using backslash
     escapes.  If you need to use a backslash escape to represent a special
     character, write the string constant with an <literal>E</>.
-->
設定パラメータ<xref linkend="guc-standard-conforming-strings">が <literal>off</>の場合、<productname>PostgreSQL</productname>はバックスラッシュエスケープを通常の文字定数とエスケープ文字定数の両方で認識します。
しかし、<productname>PostgreSQL</>9.1からデフォルトは<literal>on</>になりました。これはバックスラッシュエスケープはエスケープ文字列でのみ認識されるということになります。
この振る舞いはSQL標準仕様に即していますが、バックスラッシュエスケープを常に認識するという歴史的な動作に依存しているアプリケーションは動作しなくなるでしょう。
回避策として、このパラメータを<literal>off</>にすることはできますが、バックスラッシュエスケープの使用を避けるよう移植するのが良いでしょう。
特殊文字を表現するためにバックスラッシュを使用する必要がある場合、<literal>E</>をつけて文字列定数を記述してください。
    </para>

    <para>
<!--
     In addition to <varname>standard_conforming_strings</>, the configuration
     parameters <xref linkend="guc-escape-string-warning"> and
     <xref linkend="guc-backslash-quote"> govern treatment of backslashes
     in string constants.
-->
<varname>standard_conforming_strings</>の他に、設定パラメータ<xref linkend="guc-escape-string-warning">および<xref linkend="guc-backslash-quote">が文字定数内のバックスラッシュの動作を決定します。
    </para>
    </caution>

    <para>
<!--
     The character with the code zero cannot be in a string constant.
-->
コードゼロの文字は文字列定数の中に入れられません。
    </para>
   </sect3>

   <sect3 id="sql-syntax-strings-uescape">
<!--
    <title>String Constants with Unicode Escapes</title>
-->
    <title>Unicodeエスケープがある文字列定数</title>

    <indexterm  zone="sql-syntax-strings-uescape">
<!--
     <primary>Unicode escape</primary>
     <secondary>in string constants</secondary>
-->
     <primary>Unicodeエスケープ</primary>
     <secondary>文字列定数中</secondary>
    </indexterm>

    <para>
<!--
     <productname>PostgreSQL</productname> also supports another type
     of escape syntax for strings that allows specifying arbitrary
     Unicode characters by code point.  A Unicode escape string
     constant starts with <literal>U&amp;</literal> (upper or lower case
     letter U followed by ampersand) immediately before the opening
     quote, without any spaces in between, for
     example <literal>U&amp;'foo'</literal>.  (Note that this creates an
     ambiguity with the operator <literal>&amp;</literal>.  Use spaces
     around the operator to avoid this problem.)  Inside the quotes,
     Unicode characters can be specified in escaped form by writing a
     backslash followed by the four-digit hexadecimal code point
     number or alternatively a backslash followed by a plus sign
     followed by a six-digit hexadecimal code point number.  For
     example, the string <literal>'data'</literal> could be written as
-->
<productname>PostgreSQL</productname>は同時に、文字コード番号で任意のUnicode文字を指定可能な別の文字列に対するエスケープ構文を提供します。
Unicodeエスケープ文字列定数は、開始引用符の直前に<literal>U&amp;</literal>（後にアンパサンドが付いた大文字・小文字のU）で始まります。
例えば、<literal>U&amp;'foo'</literal>となります。
（これにより演算子<literal>&amp;</literal>との不明確性が生じることに注意してください。
この問題を回避するには空白を演算子の前後に入れます。）
引用符の中で、Unicode文字はバックスラッシュとそれに続く４桁１６進数の文字コード番号で、またはもう１つの方法として、バックスラッシュに続いてプラス符号、そして続いた６桁１６進数の文字コード番号によりエスケープ形式で指定されます。
例えば、文字列<literal>'data'</literal>は次のように書かれます。
<programlisting>
U&amp;'d\0061t\+000061'
</programlisting>
<!--
     The following less trivial example writes the Russian
     word <quote>slon</quote> (elephant) in Cyrillic letters:
-->
次のより一般的でない例はロシア語の<quote>slon</quote>（象）をキリル文字で書いたものです。
<programlisting>
U&amp;'\0441\043B\043E\043D'
</programlisting>
    </para>

    <para>
<!--
     If a different escape character than backslash is desired, it can
     be specified using
     the <literal>UESCAPE</literal><indexterm><primary>UESCAPE</primary></indexterm>
     clause after the string, for example:
-->
バックスラッシュではない異なるエスケープ文字を使用したい場合、文字列の後に<literal>UESCAPE</literal><indexterm><primary>UESCAPE</primary></indexterm>句を使用して指定することが可能です。例をあげます。
<programlisting>
U&amp;'d!0061t!+000061' UESCAPE '!'
</programlisting>
<!--
     The escape character can be any single character other than a
     hexadecimal digit, the plus sign, a single quote, a double quote,
     or a whitespace character.
-->
エスケープ文字には、16進表記用の文字、プラス記号、単一引用符、二重引用符、空白文字以外の任意の単一文字を使用することができます。
    </para>

    <para>
<!--
     The Unicode escape syntax works only when the server encoding is
     <literal>UTF8</>.  When other server encodings are used, only
     code points in the ASCII range (up to <literal>\007F</literal>)
     can be specified.  Both the 4-digit and the 6-digit form can be
     used to specify UTF-16 surrogate pairs to compose characters with
     code points larger than U+FFFF, although the availability of the
     6-digit form technically makes this unnecessary.  (When surrogate
     pairs are used when the server encoding is <literal>UTF8</>, they
     are first combined into a single code point that is then encoded
     in UTF-8.)
-->
Unicodeエスケープ構文はサーバの符号化方式が<literal>UTF8</>の場合のみ有効です。
他のサーバ符号化方式が用いられている場合、ASCII範囲（<literal>\007F</literal>まで）のコードポイントのみ指定できます。
技術的には6桁形式の機能によりこれは不要になりますが、4桁または6桁の形式は、U+FFFFより大きなコードポイントを持つ文字を構成するUTF-16サロゲートペアを指定するために使用することができます。
（サーバの符号化方式が<literal>UTF8</>の場合にサロゲートペアが使用される時、まず単一のコードポイントに組み合わされ、その後にUTF-8に符号化されます。）
    </para>

    <para>
<!--
     Also, the Unicode escape syntax for string constants only works
     when the configuration
     parameter <xref linkend="guc-standard-conforming-strings"> is
     turned on.  This is because otherwise this syntax could confuse
     clients that parse the SQL statements to the point that it could
     lead to SQL injections and similar security issues.  If the
     parameter is set to off, this syntax will be rejected with an
     error message.
-->
同様に、文字列定数に対するユニコードエスケープ構文は設定パラメータ<xref linkend="guc-standard-conforming-strings">が有効なときのみ動作します。
そうでないとこの構文は、SQLインジェクションと、類似したセキュリティ問題に繋がる時点までSQL文を構文解釈するクライアントを惑わすことになるからです。
パラメータがoffに設定されていれば、この構文はエラーメッセージとともに拒絶されます。
    </para>

    <para>
<!--
     To include the escape character in the string literally, write it
     twice.
-->
文字列の中に、文字どおりにエスケープ文字を包括するにはエスケープ文字を２回書きます。
    </para>
   </sect3>

   <sect3 id="sql-syntax-dollar-quoting">
<!--
    <title>Dollar-quoted String Constants</title>
-->
    <title>ドル記号で引用符付けされた文字列定数</title>

     <indexterm>
<!--
      <primary>dollar quoting</primary>
-->
      <primary>ドル引用符付け</primary>
     </indexterm>

    <para>
<!--
     While the standard syntax for specifying string constants is usually
     convenient, it can be difficult to understand when the desired string
     contains many single quotes or backslashes, since each of those must
     be doubled. To allow more readable queries in such situations,
     <productname>PostgreSQL</productname> provides another way, called
     <quote>dollar quoting</quote>, to write string constants.
     A dollar-quoted string constant
     consists of a dollar sign (<literal>$</literal>), an optional
     <quote>tag</quote> of zero or more characters, another dollar
     sign, an arbitrary sequence of characters that makes up the
     string content, a dollar sign, the same tag that began this
     dollar quote, and a dollar sign. For example, here are two
     different ways to specify the string <quote>Dianne's horse</>
     using dollar quoting:
-->
SQLにおける文字列定数の指定構文はたいていの場合便利ですが、対象とする文字列内に多くの単一引用符やバックスラッシュがあると、それらを全て二重にしなければなりませんので理解しづらくなります。
こうした状況においても問い合わせの可読性をより高めるために<productname>PostgreSQL</productname>は、<quote>ドル引用符付け</quote>という他の文字列定数の指定方法を提供します。
ドル引用符付けされた文字列定数は、ドル記号（<literal>$</literal>）、省略可能な0個以上の文字からなる<quote>タグ</quote>、ドル記号、文字列定数を構成する任意の文字の並び、ドル記号、この引用符付けの始めに指定したものと同じタグ、ドル記号から構成されます。
例えば、<quote>Dianne's horse</>という文字列をドル引用符付けを使用して指定する方法には、以下の2つがあります。
<programlisting>
$$Dianne's horse$$
$SomeTag$Dianne's horse$SomeTag$
</programlisting>
<!--
     Notice that inside the dollar-quoted string, single quotes can be
     used without needing to be escaped.  Indeed, no characters inside
     a dollar-quoted string are ever escaped: the string content is always
     written literally.  Backslashes are not special, and neither are
     dollar signs, unless they are part of a sequence matching the opening
     tag.
-->
ドル引用符付けされた文字列は既にエスケープされていますので、文字列定数は全てそのまま記述することができます。
その並びが開始タグに一致しない限り、バックスラッシュもドル記号も特別なものではありません。
    </para>

    <para>
<!--
     It is possible to nest dollar-quoted string constants by choosing
     different tags at each nesting level.  This is most commonly used in
     writing function definitions.  For example:
-->
各入れ子レベルに異なるタグを付けることで、ドル引用符付けされた文字列を入れ子にすることができます。
これは、関数定義を作成する時に非常によく使用されます。
以下に例を示します。
<programlisting>
$function$
BEGIN
    RETURN ($1 ~ $q$[\t\r\n\v\\]$q$);
END;
$function$
</programlisting>
<!--
     Here, the sequence <literal>$q$[\t\r\n\v\\]$q$</> represents a
     dollar-quoted literal string <literal>[\t\r\n\v\\]</>, which will
     be recognized when the function body is executed by
     <productname>PostgreSQL</>.  But since the sequence does not match
     the outer dollar quoting delimiter <literal>$function$</>, it is
     just some more characters within the constant so far as the outer
     string is concerned.
-->
ここで、<literal>$q$[\t\r\n\v\\]$q$</>は、ドル引用符付けされた<literal>[\t\r\n\v\\]</>リテラル文字列を表し、<productname>PostgreSQL</>がこの関数本体を実行する時に認識されます。
しかし、この並びは、外側のドル引用符用の区切り文字<literal>$function$</>に一致しませんので、外側の文字列を対象としている場合は単なる文字の並びとなります。
    </para>

    <para>
<!--
     The tag, if any, of a dollar-quoted string follows the same rules
     as an unquoted identifier, except that it cannot contain a dollar sign.
     Tags are case sensitive, so <literal>$tag$String content$tag$</literal>
     is correct, but <literal>$TAG$String content$tag$</literal> is not.
-->
もしあれば、ドル引用符付けされた文字列のタグは、引用符付けされていない識別子と同じ規則に従います。
ただし、タグにはドル記号を含めることはできません。
タグは大文字小文字を区別します。
したがって、<literal>$tag$String content$tag$</literal>は正しいのですが、<literal>$TAG$String content$tag$</literal>は間違いです。
    </para>

    <para>
<!--
     A dollar-quoted string that follows a keyword or identifier must
     be separated from it by whitespace; otherwise the dollar quoting
     delimiter would be taken as part of the preceding identifier.
-->
キーワードや識別子の後にドル引用符付けされた文字列を続ける場合は、空白でそれを区切らなければなりません。
さもないと、ドル引用符の区切り文字は、直前の識別子の一部として解釈されます。
    </para>

    <para>
<!--
     Dollar quoting is not part of the SQL standard, but it is often a more
     convenient way to write complicated string literals than the
     standard-compliant single quote syntax.  It is particularly useful when
     representing string constants inside other constants, as is often needed
     in procedural function definitions.  With single-quote syntax, each
     backslash in the above example would have to be written as four
     backslashes, which would be reduced to two backslashes in parsing the
     original string constant, and then to one when the inner string constant
     is re-parsed during function execution.
-->
ドル引用符付けは、標準SQLで定義されていません。
しかし、複雑な文字列リテラルを記述する場合は標準準拠の単一引用符構文よりも便利なことがよくあります。
特に、他の定数の内部に文字列定数を記述するような場合は役に立ちます。
こうした状況は手続き関数の定義でよく必要とされます。
単一引用符構文では、上の例のバックスラッシュはそれぞれ、4個のバックスラッシュで記述しなければなりません。
この4つのバックスラッシュは、元の文字列定数を解析する際に2つに減少され、そして、関数を実行する際に内部の文字列定数が再解析され1つに減少します。
    </para>
   </sect3>

   <sect3 id="sql-syntax-bit-strings">
<!--
    <title>Bit-string Constants</title>
-->
    <title>ビット文字列定数</title>

    <indexterm zone="sql-syntax-bit-strings">
<!--
     <primary>bit string</primary>
     <secondary>constant</secondary>
-->
     <primary>ビット文字列</primary>
     <secondary>定数</secondary>
    </indexterm>

    <para>
<!--
     Bit-string constants look like regular string constants with a
     <literal>B</literal> (upper or lower case) immediately before the
     opening quote (no intervening whitespace), e.g.,
     <literal>B'1001'</literal>.  The only characters allowed within
     bit-string constants are <literal>0</literal> and
     <literal>1</literal>.
-->
ビット文字列定数は<literal>B</literal>（大文字もしくは小文字）が引用符の始まりの前に付いている（間に空白はありません）通常の文字列定数のように見えます。 
例えば<literal>B'1001'</literal>のようになります。
ビット文字列定数の中で許可される文字は<literal>0</literal>と<literal>1</literal>のみです。
    </para>

    <para>
<!--
     Alternatively, bit-string constants can be specified in hexadecimal
     notation, using a leading <literal>X</literal> (upper or lower case),
     e.g., <literal>X'1FF'</literal>.  This notation is equivalent to
     a bit-string constant with four binary digits for each hexadecimal digit.
-->
その他にも、ビット文字列定数は<literal>X'1FF'</literal>といった具合に、先頭に<literal>X</literal>（大文字または小文字）を使用して16進表記で指定することもできます。
この表記は、各16進数値をそれぞれ4つの2進数値に置き換えたビット文字列定数と同等です。
    </para>

    <para>
<!--
     Both forms of bit-string constant can be continued
     across lines in the same way as regular string constants.
     Dollar quoting cannot be used in a bit-string constant.
-->
どちらの形式のビット文字列定数でも、通常の文字列定数と同じように複数行にわたって続けて書くことができます。
ドル引用符付けはビット文字列定数では使用できません。
    </para>
   </sect3>

   <sect3 id="sql-syntax-constants-numeric">
<!--
    <title>Numeric Constants</title>
-->
    <title>数値定数</title>

    <indexterm>
<!--
     <primary>number</primary>
     <secondary>constant</secondary>
-->
     <primary>数値</primary>
     <secondary>定数</secondary>
    </indexterm>

    <para>
<!--
     Numeric constants are accepted in these general forms:
-->
数値定数は下記の一般的な形で受け付けられます。
<synopsis>
<replaceable>digits</replaceable>
<replaceable>digits</replaceable>.<optional><replaceable>digits</replaceable></optional><optional>e<optional>+-</optional><replaceable>digits</replaceable></optional>
<optional><replaceable>digits</replaceable></optional>.<replaceable>digits</replaceable><optional>e<optional>+-</optional><replaceable>digits</replaceable></optional>
<replaceable>digits</replaceable>e<optional>+-</optional><replaceable>digits</replaceable>
</synopsis>
<!--
     where <replaceable>digits</replaceable> is one or more decimal
     digits (0 through 9).  At least one digit must be before or after the
     decimal point, if one is used.  At least one digit must follow the
     exponent marker (<literal>e</literal>), if one is present.
     There cannot be any spaces or other characters embedded in the
     constant.  Note that any leading plus or minus sign is not actually
     considered part of the constant; it is an operator applied to the
     constant.
-->
ここで<replaceable>digits</replaceable>は1つ以上の10進数字（0〜9）です。
小数点を使用する場合は、少なくとも1つの数字が小数点の前か後になくてはなりません。
指数記号<literal>e</literal>の付く形式を使う場合には<literal>e</literal>の後に少なくとも1つの数字がなければいけません。 
空白や他の文字は、定数の中に埋め込むことはできません。
プラスまたはマイナスの符号を先頭につけても、定数の一部とはみなされないことに注意してください。
これらの符号は定数に適用される演算子とみなされます。
    </para>

    <para>
<!--
     These are some examples of valid numeric constants:
-->
下記は有効な数値定数のいくつかの例です。
<literallayout>
42
3.5
4.
.001
5e2
1.925e-3
</literallayout>
    </para>

    <para>
     <indexterm><primary>integer</primary></indexterm>
     <indexterm><primary>bigint</primary></indexterm>
     <indexterm><primary>numeric</primary></indexterm>
<!--
     A numeric constant that contains neither a decimal point nor an
     exponent is initially presumed to be type <type>integer</> if its
     value fits in type <type>integer</> (32 bits); otherwise it is
     presumed to be type <type>bigint</> if its
     value fits in type <type>bigint</> (64 bits); otherwise it is
     taken to be type <type>numeric</>.  Constants that contain decimal
     points and/or exponents are always initially presumed to be type
     <type>numeric</>.
-->
小数点も指数も含まない数値定数の場合、まずその値が<type>integer</>型（32ビット）に適合すれば<type>integer</>型であるとみなされます。
そうでない場合、<type>bigint</>型（64ビット）で適合すれば<type>bigint</>型とみなされます。
どちらでもない場合は、<type>numeric</>型とみなされます。
定数が小数点または指数あるいはその両方を含む場合は、常に最初に<type>numeric</>型であるとみなされます。
    </para>

    <para>
<!--
     The initially assigned data type of a numeric constant is just a
     starting point for the type resolution algorithms.  In most cases
     the constant will be automatically coerced to the most
     appropriate type depending on context.  When necessary, you can
     force a numeric value to be interpreted as a specific data type
     by casting it.<indexterm><primary>type cast</primary></indexterm>
     For example, you can force a numeric value to be treated as type
     <type>real</> (<type>float4</>) by writing:
-->
数値定数に最初に割り振られるデータ型は、型解決アルゴリズムの開始点に過ぎません。
ほとんどの場合、定数には文脈に基づいて自動的に正しい型が割り振られます。
必要であれば、特定のデータ型をキャストして、数値がそのデータ型として解釈されるように強制することができます。
<indexterm><primary>型キャスト</primary></indexterm>
例えば、以下のようにして数値を<type>real</>型（<type>float4</>）として処理することができます。

<programlisting>
<!--
REAL '1.23'  &#045;&#045; string style
1.23::REAL   &#045;&#045; PostgreSQL (historical) style
-->
REAL '1.23'  -- 文字列書式
1.23::REAL   -- （歴史的な）PostgreSQL書式
</programlisting>

<!--
     These are actually just special cases of the general casting
     notations discussed next.
-->
実のところ、これらは以下で説明する一般的なキャスト記法の特別な場合です。
    </para>
   </sect3>

   <sect3 id="sql-syntax-constants-generic">
<!--
    <title>Constants of Other Types</title>
-->
    <title>他の型の定数</title>

    <indexterm>
<!--
     <primary>data type</primary>
     <secondary>constant</secondary>
-->
     <primary>データ型</primary>
     <secondary>定数</secondary>
    </indexterm>

    <para>
<!--
     A constant of an <emphasis>arbitrary</emphasis> type can be
     entered using any one of the following notations:
-->
<emphasis>任意の</emphasis>型の定数は下記の表記のいずれかを使って入力することができます。
<synopsis>
<replaceable>type</replaceable> '<replaceable>string</replaceable>'
'<replaceable>string</replaceable>'::<replaceable>type</replaceable>
CAST ( '<replaceable>string</replaceable>' AS <replaceable>type</replaceable> )
</synopsis>
<!--
     The string constant's text is passed to the input conversion
     routine for the type called <replaceable>type</replaceable>. The
     result is a constant of the indicated type.  The explicit type
     cast can be omitted if there is no ambiguity as to the type the
     constant must be (for example, when it is assigned directly to a
     table column), in which case it is automatically coerced.
-->
文字列定数のテキストは<replaceable>type</replaceable>と呼ばれる型の入力変換ルーチンへと渡されます。
結果は指示された型の定数です。
明示的な型キャストは、定数がどの型でなければならないかについて曖昧な点がなければ（例えば定数が直接テーブル列に代入されている場合）省略しても構いません。
その場合自動的に型強制されます。
    </para>

    <para>
<!--
     The string constant can be written using either regular SQL
     notation or dollar-quoting.
-->
文字列定数は通常のSQL記法でもドル引用符付けでも記述することができます。
    </para>

    <para>
<!--
     It is also possible to specify a type coercion using a function-like
     syntax:
-->
     関数のような構文を使って型強制を指定することも可能です。
<synopsis>
<replaceable>typename</replaceable> ( '<replaceable>string</replaceable>' )
</synopsis>
<!--
     but not all type names can be used in this way; see <xref
     linkend="sql-syntax-type-casts"> for details.
-->
しかし、全ての型の名前でこの方法は使用できるというわけではありません。 
詳細は<xref linkend="sql-syntax-type-casts">を参照してください。
    </para>

    <para>
<!--
     The <literal>::</literal>, <literal>CAST()</literal>, and
     function-call syntaxes can also be used to specify run-time type
     conversions of arbitrary expressions, as discussed in <xref
     linkend="sql-syntax-type-casts">.  To avoid syntactic ambiguity, the
     <literal><replaceable>type</> '<replaceable>string</>'</literal>
     syntax can only be used to specify the type of a simple literal constant.
     Another restriction on the
     <literal><replaceable>type</> '<replaceable>string</>'</literal>
     syntax is that it does not work for array types; use <literal>::</literal>
     or <literal>CAST()</literal> to specify the type of an array constant.
-->
<literal>::</literal>、<literal>CAST()</literal>や関数呼び出し構文も、<xref linkend="sql-syntax-type-casts">で説明する通り、任意の式の実行時の型変換を指定するために使うことができます。
しかし、構文的なあいまいさをなくすために、<literal><replaceable>type</replaceable> '<replaceable>string</replaceable>'</literal>という形式は単なるリテラル定数を指定する場合にのみ使うことができます。
この他<literal><replaceable>type</replaceable> '<replaceable>string</replaceable>'</literal>構文には、配列型では動作しないという制限があります。
配列型の定数を指定する場合は<literal>::</literal>か<literal>CAST()</literal>を使用してください。
    </para>

    <para>
<!--
     The <literal>CAST()</> syntax conforms to SQL.  The
     <literal><replaceable>type</> '<replaceable>string</>'</literal>
     syntax is a generalization of the standard: SQL specifies this syntax only
     for a few data types, but <productname>PostgreSQL</productname> allows it
     for all types.  The syntax with
     <literal>::</literal> is historical <productname>PostgreSQL</productname>
     usage, as is the function-call syntax.
-->
<literal>CAST()</>構文はSQLに従っています。
<literal><replaceable>type</> '<replaceable>string</>'</literal>構文は、標準を一般化したものです。
SQLでは、この構文を数個のデータ型でのみ規定しています。
しかし、<productname>PostgreSQL</productname>ではすべての型で使用することができます。
<literal>::</literal>付きの構文は、関数呼び出し構文と同様に歴史的に<productname>PostgreSQL</productname>で使用されてきました。
    </para>
   </sect3>
  </sect2>

  <sect2 id="sql-syntax-operators">
<!--
   <title>Operators</title>
-->
   <title>演算子</title>

   <indexterm zone="sql-syntax-operators">
<!--
    <primary>operator</primary>
    <secondary>syntax</secondary>
-->
    <primary>演算子</primary>
    <secondary>構文</secondary>
   </indexterm>

   <para>
<!--
    An operator name is a sequence of up to <symbol>NAMEDATALEN</symbol>-1
    (63 by default) characters from the following list:
-->
演算子は<symbol>NAMEDATALEN</symbol>-1（デフォルトは63）までの長さの、以下に示すリストに含まれる文字の並びです。
<literallayout>
+ - * / &lt; &gt; = ~ ! @ # % ^ &amp; | ` ?
</literallayout>

<!--
    There are a few restrictions on operator names, however:
-->
しかし、演算子の名前にはいくつかの制約があります。
    <itemizedlist>
     <listitem>
      <para>
<!--
       <literal>&#045;-</literal> and <literal>/*</literal> cannot appear
       anywhere in an operator name, since they will be taken as the
       start of a comment.
-->
<literal>--</literal>と<literal>/*</literal>は演算子名の中に使うことができません。
なぜならこれらはコメントの始まりと解釈されるからです。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       A multiple-character operator name cannot end in <literal>+</> or <literal>-</>,
       unless the name also contains at least one of these characters:
-->
複数文字の演算子名は、その名前が少なくとも下記の文字の1つ以上を含まない限り、<literal>+</>や<literal>-</>で終わることができません。
<literallayout>
~ ! @ # % ^ &amp; | ` ?
</literallayout>
<!--
       For example, <literal>@-</literal> is an allowed operator name,
       but <literal>*-</literal> is not.  This restriction allows
       <productname>PostgreSQL</productname> to parse SQL-compliant
       queries without requiring spaces between tokens.
-->
例えば、<literal>@-</literal>は演算子名として認められていますが、<literal>*-</literal>は認められていません。
この制限により<productname>PostgreSQL</productname>は、SQLに準拠する問い合わせをトークン同士の間に空白を要求せず、解析することができます。
      </para>
     </listitem>
    </itemizedlist>
   </para>

   <para>
<!--
    When working with non-SQL-standard operator names, you will usually
    need to separate adjacent operators with spaces to avoid ambiguity.
    For example, if you have defined a left unary operator named <literal>@</literal>,
    you cannot write <literal>X*@Y</literal>; you must write
    <literal>X* @Y</literal> to ensure that
    <productname>PostgreSQL</productname> reads it as two operator names
    not one.
-->
非SQL標準の演算子名を使う場合、通常は曖昧さを回避するために、隣り合った演算子を空白で区切る必要があります。
例えば<literal>@</literal>という左単項演算子を定義した場合、<literal>X*@Y</literal>とは書けません。
<productname>PostgreSQL</productname>がこれを確実に1つではなく2つの演算子名として解釈できるように、<literal>X* @Y</literal>と書く必要があります。
   </para>
  </sect2>

  <sect2 id="sql-syntax-special-chars">
<!--
   <title>Special Characters</title>
-->
   <title>特殊文字</title>

  <para>
<!--
   Some characters that are not alphanumeric have a special meaning
   that is different from being an operator.  Details on the usage can
   be found at the location where the respective syntax element is
   described.  This section only exists to advise the existence and
   summarize the purposes of these characters.
-->
英数字ではないいくつかの文字は、演算子であることとは異なる特殊な意味を持っています。
使用法の詳細はそれぞれの構文要素についてのところで説明します。
本節では、単にその存在を知らせ、これらの文字の目的をまとめるに留めます。

   <itemizedlist>
    <listitem>
     <para>
<!--
      A dollar sign (<literal>$</literal>) followed by digits is used
      to represent a positional parameter in the body of a function
      definition or a prepared statement.  In other contexts the
      dollar sign can be part of an identifier or a dollar-quoted string
      constant.
-->
直後に数字が続くドル記号（<literal>$</literal>）は、関数定義の本体またはプリペアド文中の位置パラメータを表すために使われます。
他の文脈ではドル記号は演算子名の一部であるかもしれませんし、ドル引用符付けされた文字列定数の一部であるかもしれません。
     </para>
    </listitem>

    <listitem>
     <para>
<!--
      Parentheses (<literal>()</literal>) have their usual meaning to
      group expressions and enforce precedence.  In some cases
      parentheses are required as part of the fixed syntax of a
      particular SQL command.
-->
括弧（<literal>()</literal>）は、通常通り式をまとめ優先するという意味を持ちます。
場合によっては括弧は、特定のSQLコマンドの固定構文の一部として要求されることがあります。
     </para>
    </listitem>

    <listitem>
     <para>
<!--
      Brackets (<literal>[]</literal>) are used to select the elements
      of an array.  See <xref linkend="arrays"> for more information
      on arrays.
-->
大括弧（<literal>[]</literal>）は、配列要素を選択するために使われます。
配列に関する詳しい情報は<xref linkend="arrays">を参照してください。
     </para>
    </listitem>

    <listitem>
     <para>
<!--
      Commas (<literal>,</literal>) are used in some syntactical
      constructs to separate the elements of a list.
-->
カンマ（<literal>,</literal>）は、リストの要素を区切るために構文的構成体で使われることがあります。
     </para>
    </listitem>

    <listitem>
     <para>
<!--
      The semicolon (<literal>;</literal>) terminates an SQL command.
      It cannot appear anywhere within a command, except within a
      string constant or quoted identifier.
-->
セミコロン（<literal>;</literal>）は、SQLコマンドの終わりを意味します。
文字列定数または引用符付き識別子以外では、コマンドの途中では使うことができません。
     </para>
    </listitem>

    <listitem>
     <para>
<!--
      The colon (<literal>:</literal>) is used to select
      <quote>slices</quote> from arrays. (See <xref
      linkend="arrays">.)  In certain SQL dialects (such as Embedded
      SQL), the colon is used to prefix variable names.
-->
コロン（<literal>:</literal>）は、配列から<quote>一部分</quote>を取り出すために使われます
(<xref linkend="arrays">を参照してください）。
いくつかのSQL方言（埋め込みSQLなど）では、コロンは変数名の接頭辞として使われます。
     </para>
    </listitem>

    <listitem>
     <para>
<!--
      The asterisk (<literal>*</literal>) is used in some contexts to denote
      all the fields of a table row or composite value.  It also
      has a special meaning when used as the argument of an
      aggregate function, namely that the aggregate does not require
      any explicit parameter.
-->
アスタリスク（<literal>*</literal>）は、いくつかの文脈において、テーブル行や複合型の全てのフィールドを表現するために使用されます。
また、集約関数の引数として使われる場合も特殊な、つまり、その集約が明示的なパラメータをまったく必要としないという意味を持ちます。
     </para>
    </listitem>

    <listitem>
     <para>
<!--
      The period (<literal>.</literal>) is used in numeric
      constants, and to separate schema, table, and column names.
-->
ピリオド（<literal>.</literal>）は数値定数の中で使われます。
また、スキーマ、テーブル、列名を区切るためにも使われます。
     </para>
    </listitem>
   </itemizedlist>

   </para>
  </sect2>

  <sect2 id="sql-syntax-comments">
<!--
   <title>Comments</title>
-->
   <title>コメント</title>

   <indexterm zone="sql-syntax-comments">
<!--
    <primary>comment</primary>
    <secondary sortas="SQL">in SQL</secondary>
-->
    <primary>コメント</primary>
    <secondary>SQL内の</secondary>
   </indexterm>

   <para>
<!--
    A comment is a sequence of characters beginning with
    double dashes and extending to the end of the line, e.g.:
-->
コメントは二重ハイフンで始まる文字の並びで、行の終わりまで続きます。
例えば以下のようになります。
<programlisting>
<!--
&#045;&#045; This is a standard SQL comment
-->
-- これは標準SQLのコメントです
</programlisting>
   </para>

   <para>
<!--
    Alternatively, C-style block comments can be used:
-->
他にも、C言語様式のブロックコメントも使用できます。
<programlisting>
<!--
/* multiline comment
 * with nesting: /* nested block comment */
-->
/* ネストされた複数行にわたる
 * コメント /* ネストされたブロックコメント */
 */
</programlisting>
<!--
    where the comment begins with <literal>/*</literal> and extends to
    the matching occurrence of <literal>*/</literal>. These block
    comments nest, as specified in the SQL standard but unlike C, so that one can
    comment out larger blocks of code that might contain existing block
    comments.
-->
コメントは<literal>/*</literal>で始まり、対応する<literal>*/</literal>で終わります。
これらのブロックコメントはC言語とは異なり、標準SQLで規定されているように入れ子にすることができます。
したがって、既存のブロックコメントを含む可能性のある大きなコードのブロックをコメントアウトすることができます。
   </para>

   <para>
<!--
    A comment is removed from the input stream before further syntax
    analysis and is effectively replaced by whitespace.
-->
コメントは、その後の構文解析が行われる前に入力ストリームから取り去られ、空白によって適切に置き換えられます。
   </para>
  </sect2>

  <sect2 id="sql-precedence">
<!--
   <title>Operator Precedence</title>
-->
   <title>演算子の優先順位</title>

   <indexterm zone="sql-precedence">
<!--
    <primary>operator</primary>
    <secondary>precedence</secondary>
-->
    <primary>演算子</primary>
    <secondary>優先順位</secondary>
   </indexterm>

   <para>
<!--
    <xref linkend="sql-precedence-table"> shows the precedence and
    associativity of the operators in <productname>PostgreSQL</>.
    Most operators have the same precedence and are left-associative.
    The precedence and associativity of the operators is hard-wired
    into the parser.  This can lead to non-intuitive behavior; for
    example the Boolean operators <literal>&lt;</> and
    <literal>&gt;</> have a different precedence than the Boolean
    operators <literal>&lt;=</> and <literal>&gt;=</>.  Also, you will
    sometimes need to add parentheses when using combinations of
    binary and unary operators.  For instance:
-->
<xref linkend="sql-precedence-table">は、<productname>PostgreSQL</>の演算子の優先順位と結合性を示しています。
ほとんどの演算子は同じ優先順位を持ち、左結合します。
演算子の優先順位と結合性はパーサに組み込まれています。
これは非直感的な動作を導く可能性があります。 
例えば、ブーリアン演算子<literal>&lt;</>と<literal>&gt;</>は、ブーリアン演算子<literal>&lt;=</>と<literal>&gt;=</>とは違った優先順位を持ちます。
さらに、二項演算子と単項演算子を組み合わせて使う場合は括弧を加える必要がある場合があります。
例えば下記のような場合です。
<programlisting>
SELECT 5 ! - 6;
</programlisting>
<!--
   will be parsed as:
-->
は、
<programlisting>
SELECT 5 ! (- 6);
</programlisting>
<!--
    because the parser has no idea &mdash; until it is too late
    &mdash; that <token>!</token> is defined as a postfix operator,
    not an infix one.  To get the desired behavior in this case, you
    must write:
-->
と解析されます。
なぜならば、パーサは<token>!</token>が中置ではなく接尾演算子として定義されていることに最後まで気が付かないためです。
この場合、求める結果を得るためには下記のように書く必要があります。
<programlisting>
SELECT (5 !) - 6;
</programlisting>
<!--
    This is the price one pays for extensibility.
-->
これが拡張性を求める故の代償です。
   </para>

   <table id="sql-precedence-table">
<!--
    <title>Operator Precedence (decreasing)</title>
-->
    <title>演算子の優先順位（強いものから）</title>

    <tgroup cols="3">
     <thead>
      <row>
<!--
       <entry>Operator/Element</entry>
       <entry>Associativity</entry>
       <entry>Description</entry>
-->
       <entry>演算子/要素</entry>
       <entry>結合性</entry>
       <entry>説明</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry><token>.</token></entry>
<!--
       <entry>left</entry>
       <entry>table/column name separator</entry>
-->
       <entry>左</entry>
       <entry>テーブル/列名の区切り文字</entry>
      </row>

      <row>
       <entry><token>::</token></entry>
<!--
       <entry>left</entry>
       <entry><productname>PostgreSQL</productname>-style typecast</entry>
-->
       <entry>左</entry>
       <entry><productname>PostgreSQL</productname>方式の型キャスト</entry>
      </row>

      <row>
       <entry><token>[</token> <token>]</token></entry>
<!--
       <entry>left</entry>
       <entry>array element selection</entry>
-->
       <entry>左</entry>
       <entry>配列要素選択</entry>
      </row>

      <row>
       <entry><token>+</token> <token>-</token></entry>
<!--
       <entry>right</entry>
       <entry>unary plus, unary minus</entry>
-->
       <entry>右</entry>
       <entry>単項加算、単項減算</entry>
      </row>

      <row>
       <entry><token>^</token></entry>
<!--
       <entry>left</entry>
       <entry>exponentiation</entry>
-->
       <entry>左</entry>
       <entry>累乗</entry>
      </row>

      <row>
       <entry><token>*</token> <token>/</token> <token>%</token></entry>
<!--
       <entry>left</entry>
       <entry>multiplication, division, modulo</entry>
-->
       <entry>左</entry>
       <entry>掛け算、割り算、剰余</entry>
      </row>

      <row>
       <entry><token>+</token> <token>-</token></entry>
<!--
       <entry>left</entry>
       <entry>addition, subtraction</entry>
-->
       <entry>左</entry>
       <entry>加算、減算</entry>
      </row>

      <row>
       <entry><token>IS</token></entry>
       <entry></entry>
<!--
       <entry><literal>IS TRUE</>, <literal>IS FALSE</>, <literal>IS NULL</>, etc</entry>
-->
       <entry><literal>IS TRUE</>, <literal>IS FALSE</>, <literal>IS NULL</>, その他</entry>
      </row>

      <row>
       <entry><token>ISNULL</token></entry>
       <entry></entry>
<!--
       <entry>test for null</entry>
-->
       <entry>NULLかどうかを試す</entry>
      </row>

      <row>
       <entry><token>NOTNULL</token></entry>
       <entry></entry>
<!--
       <entry>test for not null</entry>
-->
       <entry>非NULLかどうかを試す</entry>
      </row>

      <row>
<!--
       <entry>(any other)</entry>
-->
       <entry>（その他）</entry>
<!--
       <entry>left</entry>
       <entry>all other native and user-defined operators</entry>
-->
       <entry>左</entry>
       <entry>その他全ての組み込み、あるいはユーザ定義の演算子</entry>
      </row>

      <row>
       <entry><token>IN</token></entry>
       <entry></entry>
<!--
       <entry>set membership</entry>
-->
       <entry>メンバシップを設定する</entry>
      </row>

      <row>
       <entry><token>BETWEEN</token></entry>
       <entry></entry>
<!--
       <entry>range containment</entry>
-->
       <entry>範囲内に含有</entry>
      </row>

      <row>
       <entry><token>OVERLAPS</token></entry>
       <entry></entry>
<!--
       <entry>time interval overlap</entry>
-->
       <entry>時間間隔の重複</entry>
      </row>

      <row>
       <entry><token>LIKE</token> <token>ILIKE</token> <token>SIMILAR</token></entry>
       <entry></entry>
<!--
       <entry>string pattern matching</entry>
-->
       <entry>文字列パターンの一致</entry>
      </row>

      <row>
       <entry><token>&lt;</token> <token>&gt;</token></entry>
       <entry></entry>
<!--
       <entry>less than, greater than</entry>
-->
       <entry>小なり、大なり</entry>
      </row>

      <row>
       <entry><token>=</token></entry>
<!--
       <entry>right</entry>
       <entry>equality, assignment</entry>
-->
       <entry>右</entry>
       <entry>等しい、代入</entry>
      </row>

      <row>
       <entry><token>NOT</token></entry>
<!--
       <entry>right</entry>
       <entry>logical negation</entry>
-->
       <entry>右</entry>
       <entry>論理否定</entry>
      </row>

      <row>
       <entry><token>AND</token></entry>
<!--
       <entry>left</entry>
       <entry>logical conjunction</entry>
-->
       <entry>左</entry>
       <entry>論理積</entry>
      </row>

      <row>
       <entry><token>OR</token></entry>
<!--
       <entry>left</entry>
       <entry>logical disjunction</entry>
-->
       <entry>左</entry>
       <entry>論理和</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
<!--
    Note that the operator precedence rules also apply to user-defined
    operators that have the same names as the built-in operators
    mentioned above.  For example, if you define a
    <quote>+</quote> operator for some custom data type it will have
    the same precedence as the built-in <quote>+</quote> operator, no
    matter what yours does.
-->
演算子優先順位の規則は、上記で触れた組み込み演算子と同じ名前を持つユーザ定義演算子にも当てはまります。
例えばもし<quote>+</quote>演算子をある独自のデータ型に定義すると、新しい演算子が何をするかにかかわらず、<quote>+</quote>組み込み演算子と同じ優先順位を持つようになります。
   </para>

   <para>
<!--
    When a schema-qualified operator name is used in the
    <literal>OPERATOR</> syntax, as for example in:
-->
次の例のように、<literal>OPERATOR</>構文でスキーマで修飾された演算子名を使用する場合、
<programlisting>
SELECT 3 OPERATOR(pg_catalog.+) 4;
</programlisting>
<!--
    the <literal>OPERATOR</> construct is taken to have the default precedence
    shown in <xref linkend="sql-precedence-table"> for <quote>any other</> operator.  This is true no matter
    which specific operator appears inside <literal>OPERATOR()</>.
-->
<literal>OPERATOR</>構文は、<xref linkend="sql-precedence-table">の<quote>その他</>演算子で示されているデフォルトの優先順位を持つとみなされます。
これは、<literal>OPERATOR()</>にどの特定の演算子が入る場合でも変わりません。
   </para>
  </sect2>
 </sect1>

 <sect1 id="sql-expressions">
<!--
  <title>Value Expressions</title>
-->
  <title>評価式</title>

  <indexterm zone="sql-expressions">
<!--
   <primary>expression</primary>
   <secondary>syntax</secondary>
-->
   <primary>式</primary>
   <secondary>の構文</secondary>
  </indexterm>

  <indexterm zone="sql-expressions">
<!--
   <primary>value expression</primary>
-->
   <primary>評価式</primary>
  </indexterm>

  <indexterm>
<!--
   <primary>scalar</primary>
   <see>expression</see>
-->
   <primary>スカラ</primary>
   <see>式</see>
  </indexterm>

  <para>
<!--
   Value expressions are used in a variety of contexts, such
   as in the target list of the <command>SELECT</command> command, as
   new column values in <command>INSERT</command> or
   <command>UPDATE</command>, or in search conditions in a number of
   commands.  The result of a value expression is sometimes called a
   <firstterm>scalar</firstterm>, to distinguish it from the result of
   a table expression (which is a table).  Value expressions are
   therefore also called <firstterm>scalar expressions</firstterm> (or
   even simply <firstterm>expressions</firstterm>).  The expression
   syntax allows the calculation of values from primitive parts using
   arithmetic, logical, set, and other operations.
-->
評価式は、例えば<command>SELECT</command>コマンドの目的リストとして、<command>INSERT</command>や<command>UPDATE</command>の新しい列の値として、もしくはいくつかのコマンドの検索条件として様々な文脈の中で使われます。
評価式の結果は、テーブル式の結果（つまりテーブル）から区別するために、<firstterm>スカラ</firstterm>と呼ばれることもあります。
したがって、評価式は<firstterm>スカラ式</firstterm>（またはもっと簡単に<firstterm>式</firstterm>）とも呼ばれます。
式の構文によって、基本的な部分から算術、論理、集合などの演算を使って値の計算を行うことができます。
  </para>

  <para>
<!--
   A value expression is one of the following:
-->
評価式は下記のうちのいずれかです。

   <itemizedlist>
    <listitem>
     <para>
<!--
      A constant or literal value
-->
定数あるいはリテラル値
     </para>
    </listitem>

    <listitem>
     <para>
<!--
      A column reference
-->
列の参照
     </para>
    </listitem>

    <listitem>
     <para>
<!--
      A positional parameter reference, in the body of a function definition
      or prepared statement
-->
関数宣言の本体やプリペアド文における、位置パラメータ参照
     </para>
    </listitem>

    <listitem>
     <para>
<!--
      A subscripted expression
-->
添字付きの式
     </para>
    </listitem>

    <listitem>
     <para>
<!--
      A field selection expression
-->
フィールド選択式
     </para>
    </listitem>

    <listitem>
     <para>
<!--
      An operator invocation
-->
演算子の呼び出し
     </para>
    </listitem>

    <listitem>
     <para>
<!--
      A function call
-->
関数呼び出し
     </para>
    </listitem>

    <listitem>
     <para>
<!--
      An aggregate expression
-->
集約式
     </para>
    </listitem>

    <listitem>
     <para>
<!--
      A window function call
-->
      ウィンドウ関数呼び出し
     </para>
    </listitem>

    <listitem>
     <para>
<!--
      A type cast
-->
型キャスト
     </para>
    </listitem>

    <listitem>
     <para>
<!--
      A collation expression
-->
照合順序(collation)式
     </para>
    </listitem>

    <listitem>
     <para>
<!--
      A scalar subquery
-->
スカラ副問い合わせ
     </para>
    </listitem>

    <listitem>
     <para>
<!--
      An array constructor
-->
配列コンストラクタ
     </para>
    </listitem>

    <listitem>
     <para>
<!--
      A row constructor
-->
行コンストラクタ
     </para>
    </listitem>

    <listitem>
     <para>
<!--
      Another value expression in parentheses (used to group
      subexpressions and override
      precedence<indexterm><primary>parenthesis</></>)
-->
      （副式をグループ化したり<indexterm><primary>括弧で囲まれた</></>優先順位を変更するのに使用される）括弧で囲まれた別の評価式
     </para>
    </listitem>
   </itemizedlist>
  </para>

  <para>
<!--
   In addition to this list, there are a number of constructs that can
   be classified as an expression but do not follow any general syntax
   rules.  These generally have the semantics of a function or
   operator and are explained in the appropriate location in <xref
   linkend="functions">.  An example is the <literal>IS NULL</literal>
   clause.
-->
これ以外にも、式として分類されるけれども一般的な構文規約には従わない、いくつかの構成要素があります。
これらは一般的に関数あるいは演算子の意味を持ちます。
<xref linkend="functions">の該当部分で説明されています。
例を挙げると<literal>IS NULL</literal>句があります。
  </para>

  <para>
<!--
   We have already discussed constants in <xref
   linkend="sql-syntax-constants">.  The following sections discuss
   the remaining options.
-->
<xref linkend="sql-syntax-constants">で既に定数については説明しました。
続く節では残りのオプションについて説明します。
  </para>

  <sect2 id="sql-expressions-column-refs">
<!--
   <title>Column References</title>
-->
   <title>列の参照</title>

   <indexterm>
<!--
    <primary>column reference</primary>
-->
    <primary>列の参照</primary>
   </indexterm>

   <para>
<!--
    A column can be referenced in the form:
-->
列は、下記のような形式で参照することができます。
<synopsis>
<replaceable>correlation</replaceable>.<replaceable>columnname</replaceable>
</synopsis>
   </para>

   <para>
<!--
    <replaceable>correlation</replaceable> is the name of a
    table (possibly qualified with a schema name), or an alias for a table
    defined by means of a <literal>FROM</literal> clause.
    The correlation name and separating dot can be omitted if the column name
    is unique across all the tables being used in the current query.  (See also <xref linkend="queries">.)
-->
<replaceable>correlation</replaceable>は、テーブル名（スキーマで修飾されている場合もあります）、あるいは<literal>FROM</literal>句で定義されたテーブルの別名です。
相関名と区切り用のドットは、もし列名が現在の問い合わせで使われる全てのテーブルを通して一意である場合は省略することができます。
（<xref linkend="queries">も参照してください）。
   </para>
  </sect2>

  <sect2 id="sql-expressions-parameters-positional">
<!--
   <title>Positional Parameters</title>
-->
   <title>位置パラメータ</title>

   <indexterm>
<!--
    <primary>parameter</primary>
    <secondary>syntax</secondary>
-->
    <primary>パラメータ</primary>
    <secondary>の構文</secondary>
   </indexterm>

   <indexterm>
    <primary>$</primary>
   </indexterm>

   <para>
<!--
    A positional parameter reference is used to indicate a value
    that is supplied externally to an SQL statement.  Parameters are
    used in SQL function definitions and in prepared queries.  Some
    client libraries also support specifying data values separately
    from the SQL command string, in which case parameters are used to
    refer to the out-of-line data values.
    The form of a parameter reference is:
-->
位置パラメータ参照は、外部からSQL文に渡される値を示すために使用されます。
パラメータはSQL関数定義およびプリペアド問い合わせの中で使用されます。
また、クライアントライブラリの中には、SQLコマンド文字列とデータ値を分離して指定できる機能をサポートするものもあります。
この場合、パラメータは行外データ値を参照するために使用されます。
パラメータ参照の形式は以下の通りです。
<synopsis>
$<replaceable>number</replaceable>
</synopsis>
   </para>

   <para>
<!--
    For example, consider the definition of a function,
    <function>dept</function>, as:
-->
例えば、関数 <function>dept</function> の定義が以下のようにされたとします。

<programlisting>
CREATE FUNCTION dept(text) RETURNS dept
    AS $$ SELECT * FROM dept WHERE name = $1 $$
    LANGUAGE SQL;
</programlisting>

<!--
    Here the <literal>$1</literal> references the value of the first
    function argument whenever the function is invoked.
-->
ここで<literal>$1</literal>は関数が呼び出される時に最初の関数引数の値を参照します。
   </para>
  </sect2>

  <sect2 id="sql-expressions-subscripts">
<!--
   <title>Subscripts</title>
-->
   <title>添字</title>

   <indexterm>
<!--
    <primary>subscript</primary>
-->
    <primary>添字</primary>
   </indexterm>

   <para>
<!--
    If an expression yields a value of an array type, then a specific
    element of the array value can be extracted by writing
-->
配列の値を与える式の場合、特定の配列要素の値は以下のように記述することで展開されます。
<synopsis>
<replaceable>expression</replaceable>[<replaceable>subscript</replaceable>]
</synopsis>
<!--
    or multiple adjacent elements (an <quote>array slice</>) can be extracted
    by writing
-->
また、複数の要素をまたがる（<quote>配列の一部分</>）場合は以下のように記述することで展開されます。
<synopsis>
<replaceable>expression</replaceable>[<replaceable>lower_subscript</replaceable>:<replaceable>upper_subscript</replaceable>]
</synopsis>
<!--
    (Here, the brackets <literal>[ ]</literal> are meant to appear literally.)
    Each <replaceable>subscript</replaceable> is itself an expression,
    which must yield an integer value.
-->
（ここで大括弧<literal>[ ]</literal>はリテラルとして現れています。）
各<replaceable>subscript</replaceable>は自身が式であり、整数値を生成しなければなりません。
   </para>

   <para>
<!--
    In general the array <replaceable>expression</replaceable> must be
    parenthesized, but the parentheses can be omitted when the expression
    to be subscripted is just a column reference or positional parameter.
    Also, multiple subscripts can be concatenated when the original array
    is multidimensional.
    For example:
-->
一般的には、配列<replaceable>expression</replaceable>は括弧で括らなければなりませんが、添字が付いた式が単なる列参照や位置パラメータであった場合、その括弧を省略することができます。
以下に例を示します。

<programlisting>
mytable.arraycolumn[4]
mytable.two_d_column[17][34]
$1[10:42]
(arrayfunction(a,b))[42]
</programlisting>

<!--
    The parentheses in the last example are required.
    See <xref linkend="arrays"> for more about arrays.
-->
最後の例では括弧が必要です。
配列の詳細は<xref linkend="arrays">を参照してください。
   </para>
  </sect2>

  <sect2 id="field-selection">
<!--
   <title>Field Selection</title>
-->
   <title>フィールド選択</title>

   <indexterm>
<!--
    <primary>field selection</primary>
-->
    <primary>フィールド選択</primary>
   </indexterm>

   <para>
<!--
    If an expression yields a value of a composite type (row type), then a
    specific field of the row can be extracted by writing
-->
式が複合型（行型）の値を生成する場合、行の特定のフィールドは以下のように記述することで展開できます。
<synopsis>
<replaceable>expression</replaceable>.<replaceable>fieldname</replaceable>
</synopsis>
   </para>

   <para>
<!--
    In general the row <replaceable>expression</replaceable> must be
    parenthesized, but the parentheses can be omitted when the expression
    to be selected from is just a table reference or positional parameter.
    For example:
-->
一般的には、行<replaceable>expression</replaceable>は括弧で括らなければなりません。
しかし、選択元となる式が単なるテーブル参照や位置パラメータの場合、括弧を省略することができます。
以下に例を示します。

<programlisting>
mytable.mycolumn
$1.somecolumn
(rowfunction(a,b)).col3
</programlisting>

<!--
    (Thus, a qualified column reference is actually just a special case
    of the field selection syntax.)  An important special case is
    extracting a field from a table column that is of a composite type:
-->
   （したがって、修飾された列参照は実際のところ、単なるこのフィールド選択構文の特殊な場合です。）重要となる特殊な場合としては、複合型のテーブル列からフィールドを抽出するときです。

<programlisting>
(compositecol).somefield
(mytable.compositecol).somefield
</programlisting>

<!--
    The parentheses are required here to show that
    <structfield>compositecol</> is a column name not a table name,
    or that <structname>mytable</> is a table name not a schema name
    in the second case.
-->
    <structfield>compositecol</>がテーブル名でなく列名であること、または２番目の場合の<structname>mytable</>がスキーマ名でなくテーブル名であることを示すため丸括弧が要求されます。
   </para>

   <para>
<!--
    In a select list (see <xref linkend="queries-select-lists">), you
    can ask for all fields of a composite value by
    writing <literal>.*</literal>:
-->
SELECT列のリスト(<xref linkend="queries-select-lists">参照)に<literal>.*</literal>を記述することで、複合型の全ての値を問い合わせることが可能です。
<programlisting>
(compositecol).*
</programlisting>
   </para>
  </sect2>

  <sect2 id="sql-expressions-operator-calls">
<!--
   <title>Operator Invocations</title>
-->
   <title>演算子の呼び出し</title>

   <indexterm>
<!--
    <primary>operator</primary>
    <secondary>invocation</secondary>
-->
    <primary>演算子</primary>
    <secondary>呼び出し</secondary>
   </indexterm>

   <para>
<!--
    There are three possible syntaxes for an operator invocation:
-->
演算子の呼び出しには以下の3構文が可能です。
    <simplelist>
<!--
     <member><replaceable>expression</replaceable> <replaceable>operator</replaceable> <replaceable>expression</replaceable> (binary infix operator)</member>
     <member><replaceable>operator</replaceable> <replaceable>expression</replaceable> (unary prefix operator)</member>
     <member><replaceable>expression</replaceable> <replaceable>operator</replaceable> (unary postfix operator)</member>
-->
     <member><replaceable>expression</replaceable> <replaceable>operator</replaceable> <replaceable>expression</replaceable> （二項中置演算子）</member>
     <member><replaceable>operator</replaceable> <replaceable>expression</replaceable> （単項前置演算子）</member>
     <member><replaceable>expression</replaceable> <replaceable>operator</replaceable> （単項後置演算子）</member>
    </simplelist>
<!--
    where the <replaceable>operator</replaceable> token follows the syntax
    rules of <xref linkend="sql-syntax-operators">, or is one of the
    key words <token>AND</token>, <token>OR</token>, and
    <token>NOT</token>, or is a qualified operator name in the form:
-->
ここで<replaceable>operator</replaceable>トークンは、<xref linkend="sql-syntax-operators">構文規則に従うもの、もしくはキーワード<token>AND</token>、<token>OR</token>、<token>NOT</token>のいずれか、または以下の形式の修飾された演算子名です。
<synopsis>
<literal>OPERATOR(</><replaceable>schema</><literal>.</><replaceable>operatorname</><literal>)</>
</synopsis>
<!--
    Which particular operators exist and whether
    they are unary or binary depends on what operators have been
    defined by the system or the user.  <xref linkend="functions">
    describes the built-in operators.
-->
具体的にどんな演算子が存在し、それが単項か二項かどうかは、システムやユーザによってどんな演算子が定義されたかに依存します。
<xref linkend="functions">にて、組み込み演算子について説明します。
   </para>
  </sect2>

  <sect2 id="sql-expressions-function-calls">
<!--
   <title>Function Calls</title>
-->
   <title>関数呼び出し</title>

   <indexterm>
<!--
    <primary>function</primary>
    <secondary>invocation</secondary>
-->
    <primary>関数</primary>
    <secondary>呼び出し</secondary>
   </indexterm>

   <para>
<!--
    The syntax for a function call is the name of a function
    (possibly qualified with a schema name), followed by its argument list
    enclosed in parentheses:
-->
関数呼び出しの構文は、関数名（スキーマ名で修飾されている場合があります）に続けてその引数を丸括弧で囲んで列挙したものです。

<synopsis>
<replaceable>function_name</replaceable> (<optional><replaceable>expression</replaceable> <optional>, <replaceable>expression</replaceable> ... </optional></optional> )
</synopsis>
   </para>

   <para>
<!--
    For example, the following computes the square root of 2:
-->
例えば、以下のものは2の平方根を計算します。
<programlisting>
sqrt(2)
</programlisting>
   </para>

   <para>
<!--
    The list of built-in functions is in <xref linkend="functions">.
    Other functions can be added by the user.
-->
組み込み関数の一覧は<xref linkend="functions">にあります。
他の関数はユーザが追加できます。
   </para>

   <para>
<!--
    The arguments can optionally have names attached.
    See <xref linkend="sql-syntax-calling-funcs"> for details.
-->
引数には名前を任意で付与することができます。詳細は<xref linkend="sql-syntax-calling-funcs">を見て下さい。
   </para>

   <note>
    <para>
<!--
     A function that takes a single argument of composite type can
     optionally be called using field-selection syntax, and conversely
     field selection can be written in functional style.  That is, the
     notations <literal>col(table)</> and <literal>table.col</> are
     interchangeable.  This behavior is not SQL-standard but is provided
     in <productname>PostgreSQL</> because it allows use of functions to
     emulate <quote>computed fields</>.  For more information see
     <xref linkend="xfunc-sql-composite-functions">.
-->
複合型の単一引数をとる関数はフィールド選択構文をオプショナルに使って呼び出すことができます。反対に関数形式でフィールド選択を記述することもできます。この記述方法は<literal>col(table)</>や<literal>table.col</>となり、どちらを使っても変わりありません。<productname>PostgreSQL</>では<quote>計算された領域</>のエミュレートをする関数の利用が可能なため、これはSQL標準の振る舞いではなく<productname>PostgreSQL</>独自機能となります。詳しくは<xref linkend="xfunc-sql-composite-functions">を参照してください。
    </para>
   </note>
  </sect2>

  <sect2 id="syntax-aggregates">
<!--
   <title>Aggregate Expressions</title>
-->
   <title>集約式</title>

   <indexterm zone="syntax-aggregates">
<!--
    <primary>aggregate function</primary>
    <secondary>invocation</secondary>
-->
    <primary>集約関数</primary>
    <secondary>呼び出し</secondary>
   </indexterm>

   <indexterm zone="syntax-aggregates">
<!--
    <primary>ordered-set aggregate</primary>
-->
    <primary>順序集合集約</primary>
   </indexterm>

   <indexterm zone="syntax-aggregates">
    <primary>WITHIN GROUP</primary>
   </indexterm>

   <indexterm zone="syntax-aggregates">
    <primary>FILTER</primary>
   </indexterm>

   <para>
<!--
    An <firstterm>aggregate expression</firstterm> represents the
    application of an aggregate function across the rows selected by a
    query.  An aggregate function reduces multiple inputs to a single
    output value, such as the sum or average of the inputs.  The
    syntax of an aggregate expression is one of the following:
-->
<firstterm>集約式</firstterm>は、問い合わせによって選択される行に対して集約関数が適用されることを意味します。
集約関数は、例えば入力の合計や平均などのように、複数の入力を単一の出力値にします。
集約式の構文は下記のうちのいずれかです。

<synopsis>
<replaceable>aggregate_name</replaceable> (<replaceable>expression</replaceable> [ , ... ] [ <replaceable>order_by_clause</replaceable> ] ) [ FILTER ( WHERE <replaceable>filter_clause</replaceable> ) ]
<replaceable>aggregate_name</replaceable> (ALL <replaceable>expression</replaceable> [ , ... ] [ <replaceable>order_by_clause</replaceable> ] ) [ FILTER ( WHERE <replaceable>filter_clause</replaceable> ) ]
<replaceable>aggregate_name</replaceable> (DISTINCT <replaceable>expression</replaceable> [ , ... ] [ <replaceable>order_by_clause</replaceable> ] ) [ FILTER ( WHERE <replaceable>filter_clause</replaceable> ) ]
<replaceable>aggregate_name</replaceable> ( * ) [ FILTER ( WHERE <replaceable>filter_clause</replaceable> ) ]
<replaceable>aggregate_name</replaceable> ( [ <replaceable>expression</replaceable> [ , ... ] ] ) WITHIN GROUP ( <replaceable>order_by_clause</replaceable> ) [ FILTER ( WHERE <replaceable>filter_clause</replaceable> ) ]
</synopsis>

<!--
    where <replaceable>aggregate_name</replaceable> is a previously
    defined aggregate (possibly qualified with a schema name) and
    <replaceable>expression</replaceable> is
    any value expression that does not itself contain an aggregate
    expression or a window function call.  The optional
    <replaceable>order_by_clause</replaceable> and
    <replaceable>filter_clause</replaceable> are described below.
-->
ここで、<replaceable>aggregate_name</replaceable>は事前に定義された集約（スキーマ名で修飾された場合もあります）、<replaceable>expression</replaceable>はそれ自体に集約式またはウィンドウ関数呼び出しを含まない任意の値評価式です。
省略可能な<replaceable>order_by_clause</replaceable>と<replaceable>filter_clause</replaceable>は後述します。
   </para>

   <para>
<!--
    The first form of aggregate expression invokes the aggregate
    once for each input row.
    The second form is the same as the first, since
    <literal>ALL</literal> is the default.
    The third form invokes the aggregate once for each distinct value
    of the expression (or distinct set of values, for multiple expressions)
    found in the input rows.
    The fourth form invokes the aggregate once for each input row; since no
    particular input value is specified, it is generally only useful
    for the <function>count(*)</function> aggregate function.
    The last form is used with <firstterm>ordered-set</> aggregate
    functions, which are described below.
-->
集約式の最初の構文は、それぞれの入力行に対して1回ずつ集計を呼び出します。
<literal>ALL</literal>はデフォルトなので、2つ目の形式は最初の形式と同じです。
3番目の形式は、入力行の中にある式の、全ての重複しない値（複数式では重複しない値集合）の集約を呼び出します。
4番目の形式はそれぞれの入力行に対して1回ずつ集約を呼び出します。具体的な入力値が指定されていないため、これは一般的に<function>count(*)</function>集約関数でのみ役に立ちます。
最後の形式は<firstterm>順序集合</>集約関数で使われるもので、順序集合集約関数については後述します。
   </para>

   <para>
<!--
    Most aggregate functions ignore null inputs, so that rows in which
    one or more of the expression(s) yield null are discarded.  This
    can be assumed to be true, unless otherwise specified, for all
    built-in aggregates.
-->
１つ以上の式がNULLを返した場合にその行を破棄するように、ほとんどの集約関数はNULL入力を無視します。これは、特記されていない限り、すべての組込み集約で正しいと仮定することができます。
   </para>

   <para>
<!--
    For example, <literal>count(*)</literal> yields the total number
    of input rows; <literal>count(f1)</literal> yields the number of
    input rows in which <literal>f1</literal> is non-null, since
    <function>count</> ignores nulls; and
    <literal>count(distinct f1)</literal> yields the number of
    distinct non-null values of <literal>f1</literal>.
-->
例えば、<literal>count(*)</literal>は入力行の合計数を求めます。
<function>count</>はNULLを無視しますので、<literal>count(f1)</literal>は<literal>f1</literal>が非NULLである入力行の数を求めます。
<literal>count(distinct f1)</literal>は<literal>f1</literal>の重複しない非NULL値の数を求めます。
   </para>

   <para>
<!--
    Ordinarily, the input rows are fed to the aggregate function in an
    unspecified order.  In many cases this does not matter; for example,
    <function>min</> produces the same result no matter what order it
    receives the inputs in.  However, some aggregate functions
    (such as <function>array_agg</> and <function>string_agg</>) produce
    results that depend on the ordering of the input rows.  When using
    such an aggregate, the optional <replaceable>order_by_clause</> can be
    used to specify the desired ordering.  The <replaceable>order_by_clause</>
    has the same syntax as for a query-level <literal>ORDER BY</> clause, as
    described in <xref linkend="queries-order">, except that its expressions
    are always just expressions and cannot be output-column names or numbers.
    For example:
-->
通常、入力行は順序を指定されずに集計関数に与えられます。多くの場合では問題になりません。たとえば<function>min</>は入力順序に関係なく同一の結果を返します。しかし一部の集約関数(<function>array_agg</>および<function>string_agg</>など)は入力行の順序に依存した結果を返します。こうした集約関数を使用する際は、省略可能な<replaceable>order_by_clause</>を使用して必要とする順序を指定できます。<replaceable>order_by_clause</>は、<xref linkend="queries-order">で説明する問い合わせレベルの<literal>ORDER BY</>句と同じ構文を取りますが、その式は常に単なる式であり、出力列名や序数とすることはできません。
以下に例を示します。
<programlisting>
SELECT array_agg(a ORDER BY b DESC) FROM table;
</programlisting>
   </para>

   <para>
<!--
    When dealing with multiple-argument aggregate functions, note that the
    <literal>ORDER BY</> clause goes after all the aggregate arguments.
    For example, write this:
-->
複数の引数を取る集約関数を扱う場合、<literal>ORDER BY</>句はすべての集約引数の後に指定することに注意してください。
例えば、
<programlisting>
SELECT string_agg(a, ',' ORDER BY a) FROM table;
</programlisting>
<!--
    not this:
-->
であり、
<programlisting>
SELECT string_agg(a ORDER BY a, ',') FROM table;  -- incorrect
</programlisting>
ではありません。
<!--
    The latter is syntactically valid, but it represents a call of a
    single-argument aggregate function with two <literal>ORDER BY</> keys
    (the second one being rather useless since it's a constant).
-->
    後者は構文的には有効なものですが、2つの<literal>ORDER BY</>キーを持つ単一引数の集約関数の呼び出しを表しています。(2つ目のキーは定数なので役には立ちません。)
   </para>

   <para>
<!--
    If <literal>DISTINCT</> is specified in addition to an
    <replaceable>order_by_clause</>, then all the <literal>ORDER BY</>
    expressions must match regular arguments of the aggregate; that is,
    you cannot sort on an expression that is not included in the
    <literal>DISTINCT</> list.
-->
<replaceable>order_by_clause</>に加え<literal>DISTINCT</>が指定された場合、すべての<literal>ORDER BY</>式が集約関数の通常の引数に一致しなければなりません。つまり、<literal>DISTINCT</>リストに含まれない式でソートすることはできません。
   </para>

   <note>
    <para>
<!--
     The ability to specify both <literal>DISTINCT</> and <literal>ORDER BY</>
     in an aggregate function is a <productname>PostgreSQL</> extension.
-->
集計関数における<literal>DISTINCT</>と<literal>ORDER BY</>の指定機能はPostgreSQL独自の拡張です。
    </para>
   </note>

   <para>
<!--
    Placing <literal>ORDER BY</> within the aggregate's regular argument
    list, as described so far, is used when ordering the input rows for
    a <quote>normal</> aggregate for which ordering is optional.  There is a
    subclass of aggregate functions called <firstterm>ordered-set
    aggregates</> for which an <replaceable>order_by_clause</replaceable>
    is <emphasis>required</>, usually because the aggregate's computation is
    only sensible in terms of a specific ordering of its input rows.
    Typical examples of ordered-set aggregates include rank and percentile
    calculations.  For an ordered-set aggregate,
    the <replaceable>order_by_clause</replaceable> is written
    inside <literal>WITHIN GROUP (...)</>, as shown in the final syntax
    alternative above.  The expressions in
    the <replaceable>order_by_clause</replaceable> are evaluated once per
    input row just like normal aggregate arguments, sorted as per
    the <replaceable>order_by_clause</replaceable>'s requirements, and fed
    to the aggregate function as input arguments.  (This is unlike the case
    for a non-<literal>WITHIN GROUP</> <replaceable>order_by_clause</>,
    which is not treated as argument(s) to the aggregate function.)  The
    argument expressions preceding <literal>WITHIN GROUP</>, if any, are
    called <firstterm>direct arguments</> to distinguish them from
    the <firstterm>aggregated arguments</> listed in
    the <replaceable>order_by_clause</replaceable>.  Unlike normal aggregate
    arguments, direct arguments are evaluated only once per aggregate call,
    not once per input row.  This means that they can contain variables only
    if those variables are grouped by <literal>GROUP BY</>; this restriction
    is the same as if the direct arguments were not inside an aggregate
    expression at all.  Direct arguments are typically used for things like
    percentile fractions, which only make sense as a single value per
    aggregation calculation.  The direct argument list can be empty; in this
    case, write just <literal>()</> not <literal>(*)</>.
    (<productname>PostgreSQL</> will actually accept either spelling, but
    only the first way conforms to the SQL standard.)
    An example of an ordered-set aggregate call is:
-->
上記のように集約の通常の引数リストに<literal>ORDER BY</>を置くことは、その順序が省略可能な<quote>通常の</>集約への入力行を整列する時に使います。
たいていは集約の計算がその入力行の特定の順序に関してのみ敏感なために、<replaceable>order_by_clause</replaceable>が<emphasis>必要な</><firstterm>順序集合集約</>と呼ばれる集約関数の副クラスがあります。
順序集合集約の典型的な例は順位や百分位数の計算を含みます。
順序集合集約では、<replaceable>order_by_clause</replaceable>は上の構文の最後に示したように<literal>WITHIN GROUP (...)</>の中に書かれます。
<replaceable>order_by_clause</replaceable>の式は、通常の集約の引数のように入力行1行につき一度評価され、<replaceable>order_by_clause</replaceable>の要求に従って整列され、集約関数に入力引数として渡されます。
(これは非<literal>WITHIN GROUP</> <replaceable>order_by_clause</>の場合とは異なり、ます。その場合には集約関数の引数としては扱いません。)
<literal>WITHIN GROUP</>の前に引数の式があれば、<replaceable>order_by_clause</replaceable>に書かれた<firstterm>集約引数</>と区別するために<firstterm>直接引数</>と呼ばれます。
通常の集約引数とは異なり、直接引数は集約の呼び出しの時に一度だけ評価され、入力行1行に一度ではありません。
これは、変数が<literal>GROUP BY</>によりグループ化された場合にのみ、その変数を含むことが可能であることを意味します。この制限は直接引数が集約式の中に全くない場合と同じです。
直接引数は、典型的には1度の集約計算で1つの値だけが意味がある百分位数のようなもので使われます。
直接引数のリストは空でも構いません。この場合、<literal>(*)</>ではなく<literal>()</>と書いてください。
(<productname>PostgreSQL</>は実際にどちらの綴りも受け付けますが、後者だけが標準SQLに準拠しています。)
順序集合集約の例は以下の通りです。

<programlisting>
SELECT percentile_disc(0.5) WITHIN GROUP (ORDER BY income) FROM households;
 percentile_disc
-----------------
           50489
</programlisting>

<!--
   which obtains the 50th percentile, or median, value of
   the <structfield>income</> column from table <structname>households</>.
   Here, <literal>0.5</> is a direct argument; it would make no sense
   for the percentile fraction to be a value varying across rows.
-->
これは、テーブル<structname>households</>から<structfield>income</>列の50番目の百分位数、すなわち中央値を得ます。
ここで<literal>0.5</>は直接引数です。百分位数が行毎に変化する値であったら意味がありません。
   </para>

   <para>
<!--
    If <literal>FILTER</literal> is specified, then only the input
    rows for which the <replaceable>filter_clause</replaceable>
    evaluates to true are fed to the aggregate function; other rows
    are discarded.  For example:
-->
<literal>FILTER</literal>が指定されていれば、<replaceable>filter_clause</replaceable>が真と評価した入力行のみがウィンドウ関数に渡されます。それ以外の行は破棄されます。
例えば、
<programlisting>
SELECT
    count(*) AS unfiltered,
    count(*) FILTER (WHERE i < 5) AS filtered
FROM generate_series(1,10) AS s(i);
 unfiltered | filtered
------------+----------
         10 |        4
(1 row)
</programlisting>
   </para>

   <para>
<!--
    The predefined aggregate functions are described in <xref
    linkend="functions-aggregate">.  Other aggregate functions can be added
    by the user.
-->
定義済みの集約関数は<xref linkend="functions-aggregate">で説明されています。
ユーザは他の集約関数を追加することができます。 
   </para>

   <para>
<!--
    An aggregate expression can only appear in the result list or
    <literal>HAVING</> clause of a <command>SELECT</> command.
    It is forbidden in other clauses, such as <literal>WHERE</>,
    because those clauses are logically evaluated before the results
    of aggregates are formed.
-->
集約式は、<command>SELECT</>コマンドの結果リストもしくは<literal>HAVING</>句内でのみ記述することができます。
<literal>WHERE</>などの他の句では許されません。
これらの句は理論上集計結果が形成される前に評価されるためです。
   </para>

   <para>
<!--
    When an aggregate expression appears in a subquery (see
    <xref linkend="sql-syntax-scalar-subqueries"> and
    <xref linkend="functions-subquery">), the aggregate is normally
    evaluated over the rows of the subquery.  But an exception occurs
    if the aggregate's arguments (and <replaceable>filter_clause</replaceable>
    if any) contain only outer-level variables:
    the aggregate then belongs to the nearest such outer level, and is
    evaluated over the rows of that query.  The aggregate expression
    as a whole is then an outer reference for the subquery it appears in,
    and acts as a constant over any one evaluation of that subquery.
    The restriction about
    appearing only in the result list or <literal>HAVING</> clause
    applies with respect to the query level that the aggregate belongs to.
-->
集約式が副問い合わせ（<xref linkend="sql-syntax-scalar-subqueries">と<xref linkend="functions-subquery">を参照）内に現れた場合、通常、集約は副問い合わせの行全体に対して評価されます。
しかし、その集約の引数(と、もしあれば<replaceable>filter_clause</replaceable>)が上位レベルの変数のみを持つ場合は例外です。
その場合、集約は最も近い外側のレベルに属し、その問い合わせの行全体に対して評価されます。
全体として、その集約式は、その後、その集約を含む副問い合わせでは外部参照となり、その副問い合わせにおける評価に対しては定数として動作します。
結果リストもしくは<literal>HAVING</>句にのみ現れるという制約は、その集約が属する問い合わせレベルに関連して適用されます。
   </para>
  </sect2>

  <sect2 id="syntax-window-functions">
<!--
   <title>Window Function Calls</title>
-->
   <title>ウィンドウ関数呼び出し</title>

   <indexterm zone="syntax-window-functions">
<!--
    <primary>window function</primary>
    <secondary>invocation</secondary>
-->
    <primary>ウィンドウ関数</primary>
    <secondary>起動</secondary>
   </indexterm>

   <indexterm zone="syntax-window-functions">
<!--
    <primary>OVER clause</primary>
-->
    <primary>OVER句</primary>
   </indexterm>

   <para>
<!--
    A <firstterm>window function call</firstterm> represents the application
    of an aggregate-like function over some portion of the rows selected
    by a query.  Unlike regular aggregate function calls, this is not tied
    to grouping of the selected rows into a single output row &mdash; each
    row remains separate in the query output.  However the window function
    is able to scan all the rows that would be part of the current row's
    group according to the grouping specification (<literal>PARTITION BY</>
    list) of the window function call.
    The syntax of a window function call is one of the following:
-->
<firstterm>ウィンドウ関数呼び出し</firstterm>は、問い合わせにより選択された行のある部分に渡って集約のような機能を実現することを表します。
通常の集約関数呼び出しと異なり、これは選択された行を1つの行にグループ化することに束縛されず、各行は別途問い合わせ出力に残ります。
しかしウィンドウ関数は、ウィンドウ関数呼び出しのグループ化指定（<literal>PARTITION BY</>リスト）に従った、現在の行のグループの一部となる行をすべてスキャンすることができます。
ウィンドウ関数呼び出しの構文は以下のいずれかです。

<synopsis>
<replaceable>function_name</replaceable> (<optional><replaceable>expression</replaceable> <optional>, <replaceable>expression</replaceable> ... </optional></optional>) [ FILTER ( WHERE <replaceable>filter_clause</replaceable> ) ] OVER <replaceable>window_name</replaceable>
<replaceable>function_name</replaceable> (<optional><replaceable>expression</replaceable> <optional>, <replaceable>expression</replaceable> ... </optional></optional>) [ FILTER ( WHERE <replaceable>filter_clause</replaceable> ) ] OVER ( <replaceable class="parameter">window_definition</replaceable> )
<replaceable>function_name</replaceable> ( * ) [ FILTER ( WHERE <replaceable>filter_clause</replaceable> ) ] OVER <replaceable>window_name</replaceable>
<replaceable>function_name</replaceable> ( * ) [ FILTER ( WHERE <replaceable>filter_clause</replaceable> ) ] OVER ( <replaceable class="parameter">window_definition</replaceable> )
</synopsis>
<!--
    where <replaceable class="parameter">window_definition</replaceable>
    has the syntax
-->
ここで、<replaceable class="parameter">window_definition</replaceable>は以下の構文になります。
<synopsis>
[ <replaceable class="parameter">existing_window_name</replaceable> ]
[ PARTITION BY <replaceable class="parameter">expression</replaceable> [, ...] ]
[ ORDER BY <replaceable class="parameter">expression</replaceable> [ ASC | DESC | USING <replaceable class="parameter">operator</replaceable> ] [ NULLS { FIRST | LAST } ] [, ...] ]
[ <replaceable class="parameter">frame_clause</replaceable> ]
</synopsis>
<!--
    and the optional <replaceable class="parameter">frame_clause</replaceable>
    can be one of
-->
オプションの<replaceable class="parameter">frame_clause</replaceable>は次の中の１つです。
<synopsis>
[ RANGE | ROWS ] <replaceable>frame_start</>
[ RANGE | ROWS ] BETWEEN <replaceable>frame_start</> AND <replaceable>frame_end</>
</synopsis>
<!--
    where <replaceable>frame_start</> and <replaceable>frame_end</> can be
    one of
-->
ここで<replaceable>frame_start</>および<replaceable>frame_end</>は以下のいずれかです。
<synopsis>
UNBOUNDED PRECEDING
<replaceable>value</replaceable> PRECEDING
CURRENT ROW
<replaceable>value</replaceable> FOLLOWING
UNBOUNDED FOLLOWING
</synopsis>
   </para>

   <para>
<!--
    Here, <replaceable>expression</replaceable> represents any value
    expression that does not itself contain window function calls.
-->
ここで、<replaceable>expression</replaceable>はそれ自身ウィンドウ関数呼び出しを含まないいかなる値式を表わします。
   </para>

   <para>
<!--
    <replaceable>window_name</replaceable> is a reference to a named window
    specification defined in the query's <literal>WINDOW</literal> clause.
    Alternatively, a full <replaceable>window_definition</replaceable> can
    be given within parentheses, using the same syntax as for defining a
    named window in the <literal>WINDOW</literal> clause; see the
    <xref linkend="sql-select"> reference page for details.  It's worth
    pointing out that <literal>OVER wname</> is not exactly equivalent to
    <literal>OVER (wname)</>; the latter implies copying and modifying the
    window definition, and will be rejected if the referenced window
    specification includes a frame clause.
-->
<replaceable>window_name</replaceable>は、問い合わせの<literal>WINDOW</literal>句で定義された名前付きウィンドウ仕様への参照です。
あるいはまた、完全な<replaceable>window_definition</replaceable>を<literal>WINDOW</literal>句で定義された名前付きウィンドウと同じ構文を使って丸括弧の中に書くことができます。
詳細は<xref linkend="sql-select">マニュアルページを見てください。
<literal>OVER wname</>は<literal>OVER (wname)</>とは厳密には等価ではないことを指摘しておくのは価値のあることでしょう。
後者はウィンドウ定義をコピーしたり修正したりすることを示唆しており、参照されるウィンドウ仕様がフレーム句を含む場合には拒絶されます。
   </para>

   <para>
<!--
    The <literal>PARTITION BY</> option groups the rows of the query into
    <firstterm>partitions</>, which are processed separately by the window
    function.  <literal>PARTITION BY</> works similarly to a query-level
    <literal>GROUP BY</> clause, except that its expressions are always just
    expressions and cannot be output-column names or numbers.
    Without <literal>PARTITION BY</>, all rows produced by the query are
    treated as a single partition.
    The <literal>ORDER BY</> option determines the order in which the rows
    of a partition are processed by the window function.  It works similarly
    to a query-level <literal>ORDER BY</> clause, but likewise cannot use
    output-column names or numbers.  Without <literal>ORDER BY</>, rows are
    processed in an unspecified order.
-->
<literal>PARTITION BY</>オプションは問い合わせの行を<firstterm>パーティション</>に纏め、パーティションはウィンドウ関数により別々に処理されます。
<literal>PARTITION BY</>は、その式が常に式であって出力列名や数値ではないという点を除いて、問い合わせレベルの<literal>GROUP BY</>句と同様に動作します。
<literal>PARTITION BY</>がなければ、問い合わせで生じる行すべてが一つのパーティションとして扱われます。
<literal>ORDER BY</>オプションはパーティションの行がウィンドウ関数により処理される順序を決定します。
問い合わせレベルの<literal>ORDER BY</>句と同様に動作しますが、やはり出力列名や数値は使えません。
<literal>ORDER BY</>がなければ、行は順序を指定されずに処理されます。
   </para>

   <para>
<!--
    The <replaceable class="parameter">frame_clause</replaceable> specifies
    the set of rows constituting the <firstterm>window frame</>, which is a
    subset of the current partition, for those window functions that act on
    the frame instead of the whole partition.  The frame can be specified in
    either <literal>RANGE</> or <literal>ROWS</> mode; in either case, it
    runs from the <replaceable>frame_start</> to the
    <replaceable>frame_end</>.  If <replaceable>frame_end</> is omitted,
    it defaults to <literal>CURRENT ROW</>.
-->
<replaceable class="parameter">frame_clause</replaceable>は、パーティション全体の代わりにそのフレーム上で作動するウィンドウ関数に対して、<firstterm>ウィンドウフレーム</>を構成する行の集合を指定します。
フレームは<literal>RANGE</>モードでも<literal>ROWS</>モードでも指定できます。
どちらの場合でも<replaceable>frame_start</>から<replaceable>frame_end</>までです。
<replaceable>frame_end</>を省略した場合のデフォルトは<literal>CURRENT ROW</>です。
   </para>

   <para>
<!--
    A <replaceable>frame_start</> of <literal>UNBOUNDED PRECEDING</> means
    that the frame starts with the first row of the partition, and similarly
    a <replaceable>frame_end</> of <literal>UNBOUNDED FOLLOWING</> means
    that the frame ends with the last row of the partition.
-->
<literal>UNBOUNDED PRECEDING</>の<replaceable>frame_start</>はフレームがパーティションの最初の行から始まること意味し、同様に、<literal>UNBOUNDED FOLLOWING</>の<replaceable>frame_end</>をフレームがパーティションの最後の行で終わること意味します。
   </para>

   <para>
<!--
    In <literal>RANGE</> mode, a <replaceable>frame_start</> of
    <literal>CURRENT ROW</> means the frame starts with the current row's
    first <firstterm>peer</> row (a row that <literal>ORDER BY</> considers
    equivalent to the current row), while a <replaceable>frame_end</> of
    <literal>CURRENT ROW</> means the frame ends with the last equivalent
    <literal>ORDER BY</> peer.  In <literal>ROWS</> mode, <literal>CURRENT ROW</> simply means
    peer.  In <literal>ROWS</> mode, <literal>CURRENT ROW</> simply means
    the current row.
-->
<literal>RANGE</>モードでは、<literal>CURRENT ROW</>の<replaceable>frame_start</>はフレームが現在行の最初の<firstterm>同等な</>行（<literal>ORDER BY</>が現在行と等しいとみなす行）から始まることを意味し、一方、<literal>CURRENT ROW</>の<replaceable>frame_end</>はフレームが現在行の最後の同等な<literal>ORDER BY</>行で終わることを意味します。
<literal>ROWS</>モードでは、<literal>CURRENT ROW</>は単に現在行を意味します。
   </para>

   <para>
<!--
    The <replaceable>value</> <literal>PRECEDING</> and
    <replaceable>value</> <literal>FOLLOWING</> cases are currently only
    allowed in <literal>ROWS</> mode.  They indicate that the frame starts
    or ends the specified number of rows before or after the current row.
    <replaceable>value</replaceable> must be an integer expression not
    containing any variables, aggregate functions, or window functions.
    The value must not be null or negative; but it can be zero, which
    just selects the current row.
-->
<replaceable>value</> <literal>PRECEDING</>と<replaceable>value</> <literal>FOLLOWING</>の形式は、現在のところ<literal>ROWS</>モードでのみ許可されています。
これは、フレームの開始もしくは終了点となる現在行の前や後に、指定数の行があることを意味します。
<replaceable>value</replaceable>は一切の変数、集計関数、あるいはウィンドウ関数を含まない整数式でなければなりません。
またNULLや負数も許可されませんが、現在行を選択することになる0は指定可能です。
   </para>

   <para>
<!--
    The default framing option is <literal>RANGE UNBOUNDED PRECEDING</>,
    which is the same as <literal>RANGE BETWEEN UNBOUNDED PRECEDING AND
    CURRENT ROW</>.  With <literal>ORDER BY</>, this sets the frame to be
    all rows from the partition start up through the current row's last
    <literal>ORDER BY</> peer.  Without <literal>ORDER BY</>, all rows of the partition are
    included in the window frame, since all rows become peers of the current
    row.
-->
デフォルトのフレーム化オプションは<literal>RANGE UNBOUNDED PRECEDING</>で、<literal>RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW</>と同じです。
これはパーティションの開始から<literal>ORDER BY</>による順序付けに沿った現在行と同等となる最後の<literal>ORDER BY</>行までのフレームをセットします。
<literal>ORDER BY</>が無い場合は、すべての行が現在行と同等となりますのでパーティションのすべての行がウィンドウフレームに含まれます。
   </para>

   <para>
<!--
    Restrictions are that
    <replaceable>frame_start</> cannot be <literal>UNBOUNDED FOLLOWING</>,
    <replaceable>frame_end</> cannot be <literal>UNBOUNDED PRECEDING</>,
    and the <replaceable>frame_end</> choice cannot appear earlier in the
    above list than the <replaceable>frame_start</> choice &mdash; for example
    <literal>RANGE BETWEEN CURRENT ROW AND <replaceable>value</>
    PRECEDING</literal> is not allowed.
-->
制限は、<replaceable>frame_start</>を<literal>UNBOUNDED FOLLOWING</>とすることができない点、<replaceable>frame_end</>を<literal>UNBOUNDED PRECEDING</>とすることができない点、および<replaceable>frame_end</>の選択は上のリストの中で<replaceable>frame_start</>の選択より先に記述することができない点です。例えば、<literal>RANGE BETWEEN CURRENT ROW AND <replaceable>value</> PRECEDING</literal>は許されません。
   </para>

   <para>
<!--
    If <literal>FILTER</literal> is specified, then only the input
    rows for which the <replaceable>filter_clause</replaceable>
    evaluates to true are fed to the window function; other rows
    are discarded.  Only window functions that are aggregates accept
    a <literal>FILTER</literal> clause.
-->
<literal>FILTER</literal>が指定されていれば、<replaceable>filter_clause</replaceable>が真と評価した入力行のみがウィンドウ関数に渡されます。それ以外の行は破棄されます。
集約ウィンドウ関数だけが<literal>FILTER</literal>句を受け付けます。
   </para>

   <para>
<!--
    The built-in window functions are described in <xref
    linkend="functions-window-table">.  Other window functions can be added by
    the user.  Also, any built-in or user-defined normal aggregate function
    can be used as a window function.  Ordered-set aggregates presently
    cannot be used as window functions, however.
-->
組み込みウィンドウ関数は<xref linkend="functions-window-table">に記載されています。その他のウィンドウ関数をユーザが追加することが可能です。
また、全ての組み込み、またはユーザ定義の通常の集約関数もウィンドウ関数として使用できます。
しかしながら、順序集合集約は現在のところウィンドウ関数として使用できません。
   </para>

   <para>
<!--
    The syntaxes using <literal>*</> are used for calling parameter-less
    aggregate functions as window functions, for example
    <literal>count(*) OVER (PARTITION BY x ORDER BY y)</>.
    The asterisk (<literal>*</>) is customarily not used for non-aggregate window functions.
    Aggregate window functions, unlike normal aggregate functions, do not
    allow <literal>DISTINCT</> or <literal>ORDER BY</> to be used within the
    function argument list.
-->
<literal>*</>を使用した構文は、例えば<literal>count(*) OVER (PARTITION BY x ORDER BY y)</>のように、ウィンドウ関数として呼び出しパラメータのない集約関数を使用します。
アスタリスク(<literal>*</>)は習慣的に非集約ウィンドウ関数には使われません。通常の集約関数と異なり、集約ウィンドウ関数は、関数引数リストの中で<literal>DISTINCT</>や<literal>ORDER BY</>が使われることを許可しません。
   </para>

   <para>
<!--
    Window function calls are permitted only in the <literal>SELECT</literal>
    list and the <literal>ORDER BY</> clause of the query.
-->
ウィンドウ関数呼び出しは問い合わせの<literal>SELECT</literal>リストと<literal>ORDER BY</>句の中でのみ許可されます。
   </para>

   <para>
<!--
    More information about window functions can be found in
    <xref linkend="tutorial-window">,
    <xref linkend="functions-window">, and
    <xref linkend="queries-window">.
-->
更なるウィンドウ関数についての情報は<xref linkend="tutorial-window">、<xref linkend="functions-window">、<xref linkend="queries-window">にあります。
   </para>
  </sect2>

  <sect2 id="sql-syntax-type-casts">
<!--
   <title>Type Casts</title>
-->
   <title>型キャスト</title>

   <indexterm>
<!--
    <primary>data type</primary>
    <secondary>type cast</secondary>
-->
    <primary>データ型</primary>
    <secondary>型キャスト</secondary>
   </indexterm>

   <indexterm>
<!--
    <primary>type cast</primary>
-->
    <primary>型キャスト</primary>
   </indexterm>

   <indexterm>
    <primary>::</primary>
   </indexterm>

   <para>
<!--
    A type cast specifies a conversion from one data type to another.
    <productname>PostgreSQL</productname> accepts two equivalent syntaxes
    for type casts:
-->
型キャストは、あるデータ型から他のデータ型への変換を指定します。
<productname>PostgreSQL</productname>は型キャストに2つの等価な構文を受け付けます。
<synopsis>
CAST ( <replaceable>expression</replaceable> AS <replaceable>type</replaceable> )
<replaceable>expression</replaceable>::<replaceable>type</replaceable>
</synopsis>
<!--
    The <literal>CAST</> syntax conforms to SQL; the syntax with
    <literal>::</literal> is historical <productname>PostgreSQL</productname>
    usage.
-->
<literal>CAST</>構文はSQLに準拠したものです。
<literal>::</literal>を使用する構文は、<productname>PostgreSQL</productname>で伝統的に使用されている方法です。
   </para>

   <para>
<!--
    When a cast is applied to a value expression of a known type, it
    represents a run-time type conversion.  The cast will succeed only
    if a suitable type conversion operation has been defined.  Notice that this
    is subtly different from the use of casts with constants, as shown in
    <xref linkend="sql-syntax-constants-generic">.  A cast applied to an
    unadorned string literal represents the initial assignment of a type
    to a literal constant value, and so it will succeed for any type
    (if the contents of the string literal are acceptable input syntax for the
    data type).
-->
キャストが既知の型の評価式に適用された場合、それは実行時型変換を表します。
このキャストは、適切な型変換操作が定義されている場合のみ成功します。
<xref linkend="sql-syntax-constants-generic">で示すように、これと定数のキャストの使用との微妙な違いに注意してください。
修飾されていない文字列リテラルに対するキャストは、リテラル定数値の初期に割り当てられる型を表します。
ですから、これは（文字列リテラル定数の内容がそのデータ型の入力構文で受け付けられるのであれば）全ての型で成功します。
   </para>

   <para>
<!--
    An explicit type cast can usually be omitted if there is no ambiguity as
    to the type that a value expression must produce (for example, when it is
    assigned to a table column); the system will automatically apply a
    type cast in such cases.  However, automatic casting is only done for
    casts that are marked <quote>OK to apply implicitly</>
    in the system catalogs.  Other casts must be invoked with
    explicit casting syntax.  This restriction is intended to prevent
    surprising conversions from being applied silently.
-->
通常（例えばテーブル列への代入時など）、評価式が生成しなければならない型に曖昧さがない場合、明示的な型キャストは省略することができます。
その場合、システムは自動的に型キャストを適用します。
しかし、自動キャストは、システムカタログに<quote>暗黙的に適用しても問題なし</>と示されている場合にのみ実行されます。
その他のキャストは明示的なキャスト構文で呼び出す必要があります。
この制限は、知らないうちに変換が実行されてしまうことを防ぐためのものです。
   </para>

   <para>
<!--
    It is also possible to specify a type cast using a function-like
    syntax:
-->
また、関数のような構文を使用して型キャストを指定することもできます。
<synopsis>
<replaceable>typename</replaceable> ( <replaceable>expression</replaceable> )
</synopsis>
<!--
    However, this only works for types whose names are also valid as
    function names.  For example, <literal>double precision</literal>
    cannot be used this way, but the equivalent <literal>float8</literal>
    can.  Also, the names <literal>interval</>, <literal>time</>, and
    <literal>timestamp</> can only be used in this fashion if they are
    double-quoted, because of syntactic conflicts.  Therefore, the use of
    the function-like cast syntax leads to inconsistencies and should
    probably be avoided.
-->
しかし、これはその型の名前が関数の名前としても有効な場合にのみ動作します。
例えば、<literal>double precision</literal> はこの方式で使用できませんが、同等の<literal>float8</literal>は使用できます。
また、<literal>interval</>、<literal>time</>、<literal>timestamp</>という名前は、構文が衝突するため、二重引用符で括った場合にのみこの方式で使用できます。
このように、この関数のようなキャスト構文は一貫性がなくなりがちですので、おそらくアプリケーションでは使用すべきではありません
   </para>

   <note>
    <para>
<!--
     The function-like syntax is in fact just a function call.  When
     one of the two standard cast syntaxes is used to do a run-time
     conversion, it will internally invoke a registered function to
     perform the conversion.  By convention, these conversion functions
     have the same name as their output type, and thus the <quote>function-like
     syntax</> is nothing more than a direct invocation of the underlying
     conversion function.  Obviously, this is not something that a portable
     application should rely on.  For further details see
     <xref linkend="sql-createcast">.
-->
この関数のような構文は、実際には単なる関数呼び出しです。
2つの標準的なキャスト構文のうちの1つが実行時変換で使用されると、この構文は登録済みの関数を内部的に呼び出して変換を実行します。
慣習的に、これらの変換関数は自身の出力型と同じ名前を持ち、これにより、<quote>関数のような構文</>は背後にある変換用関数を直接呼び出す以上のことを行いません。
移植性を持つアプリケーションが依存すべきものでないことは明確です。
詳細については<xref linkend="sql-createcast">を参照してください。
    </para>
   </note>
  </sect2>

  <sect2 id="sql-syntax-collate-exprs">
<!--
   <title>Collation Expressions</title>
-->
   <title>照合順序式</title>

   <indexterm>
    <primary>COLLATE</primary>
   </indexterm>

   <para>
<!--
    The <literal>COLLATE</literal> clause overrides the collation of
    an expression.  It is appended to the expression it applies to:
-->
<literal>COLLATE</literal>句は式の照合順序規則を上書きします。適用するため次の様に式に加えます。
<synopsis>
<replaceable>expr</replaceable> COLLATE <replaceable>collation</replaceable>
</synopsis>
<!--
    where <replaceable>collation</replaceable> is a possibly
    schema-qualified identifier.  The <literal>COLLATE</literal>
    clause binds tighter than operators; parentheses can be used when
    necessary.
-->    
<replaceable>collation</replaceable>はおそらくスキーマ部を含む識別子です。<literal>COLLATE</literal>句は演算子よりも優先度が低いため、必要に応じて括弧で囲います。
   </para>

   <para>
<!--
    If no collation is explicitly specified, the database system
    either derives a collation from the columns involved in the
    expression, or it defaults to the default collation of the
    database if no column is involved in the expression.
-->
もし照合順序が何も指定されなければ、データベースシステムは式にある列から照合順序を取得します。もし列に関する照合順序が式になければ、データベースのデフォルトの照合順序を使います。
   </para>

   <para>
<!--
    The two common uses of the <literal>COLLATE</literal> clause are
    overriding the sort order in an <literal>ORDER BY</> clause, for
    example:
-->
例として、よく使われる<literal>COLLATE</literal>句による並び替え順序の上書きを挙げます。<literal>ORDER BY</>句を使う場合には、
<programlisting>
SELECT a, b, c FROM tbl WHERE ... ORDER BY a COLLATE "C";
</programlisting>
<!--
    and overriding the collation of a function or operator call that
    has locale-sensitive results, for example:
-->
とします。ロケール依存を伴った関数や演算子の呼び出しに対しての上書き方法例は
<programlisting>
SELECT * FROM tbl WHERE a &gt; 'foo' COLLATE "C";
</programlisting>
<!--
    Note that in the latter case the <literal>COLLATE</> clause is
    attached to an input argument of the operator we wish to affect.
    It doesn't matter which argument of the operator or function call the
    <literal>COLLATE</> clause is attached to, because the collation that is
    applied by the operator or function is derived by considering all
    arguments, and an explicit <literal>COLLATE</> clause will override the
    collations of all other arguments.  (Attaching non-matching
    <literal>COLLATE</> clauses to more than one argument, however, is an
    error.  For more details see <xref linkend="collation">.)
    Thus, this gives the same result as the previous example:
-->
とします。後者の場合、<literal>COLLATE</>句が、処理対象と想定している入力演算子の引数に対して付与されることに注意してください。演算子や関数の呼び出しのどの引数に対して<literal>COLLATE</>句が付与されるかは問題ではありません。演算子や関数により適用される照合順序は対象となる全ての引数を考慮して引き出され、そして明示的に指定された<literal>COLLATE</>句がその他の全ての引数に対しての照合順序を上書きするからです。(しかし、複数の引数に対して一致しない<literal>COLLATE</>句の付与はエラーとなります。詳細は<xref linkend="collation">を参照してください)。このため、前述の例と同じ結果を次の様にして取得することができます。
<programlisting>
SELECT * FROM tbl WHERE a COLLATE "C" &gt; 'foo';
</programlisting>
<!--
    But this is an error:
-->
ただし、これはエラーになります。正しくは次の様にします。
<programlisting>
SELECT * FROM tbl WHERE (a &gt; 'foo') COLLATE "C";
</programlisting>
<!--
    because it attempts to apply a collation to the result of the
    <literal>&gt;</> operator, which is of the non-collatable data type
    <type>boolean</>.
-->
なぜなら、照合順序を与えることができない<type>boolean</>型となる<literal>&gt;</>演算子の結果に対して。照合順序が適用されようとするからです。
   </para>
  </sect2>

  <sect2 id="sql-syntax-scalar-subqueries">
<!--
   <title>Scalar Subqueries</title>
-->
   <title>スカラ副問い合わせ</title>

   <indexterm>
<!--
    <primary>subquery</primary>
-->
    <primary>副問い合わせ</primary>
   </indexterm>

   <para>
<!--
    A scalar subquery is an ordinary
    <command>SELECT</command> query in parentheses that returns exactly one
    row with one column.  (See <xref linkend="queries"> for information about writing queries.)
    The <command>SELECT</command> query is executed
    and the single returned value is used in the surrounding value expression.
    It is an error to use a query that
    returns more than one row or more than one column as a scalar subquery.
    (But if, during a particular execution, the subquery returns no rows,
    there is no error; the scalar result is taken to be null.)
    The subquery can refer to variables from the surrounding query,
    which will act as constants during any one evaluation of the subquery.
    See also <xref linkend="functions-subquery"> for other expressions involving subqueries.
-->
スカラ副問い合わせは、正確に1行1列を返す、括弧内の通常の<command>SELECT</command>問い合わせです
（問い合わせの記述方法については<xref linkend="queries">を参照してください）。
その<command>SELECT</command>問い合わせは実行され、返される単一の値はその値の前後の評価式で使用されます。 
1行を超える行や1列を超える列がスカラ副問い合わせ用の問い合わせとして使用された場合はエラーになります
（しかし、ある実行時に、副問い合わせが行を返さない場合はエラーとはなりません。
そのスカラ結果はNULLとして扱われます）。
副問い合わせは、その周りの問い合わせ内の値を参照することができます。
その値は副問い合わせの評価時には定数として扱われます。
副問い合わせに関する他の式については<xref linkend="functions-subquery">も参照してください。
   </para>

   <para>
<!--
    For example, the following finds the largest city population in each
    state:
-->
例えば、以下は各州で最も人口の多い都市を検索します。
<programlisting>
SELECT name, (SELECT max(pop) FROM cities WHERE cities.state = states.name)
    FROM states;
</programlisting>
   </para>
  </sect2>

  <sect2 id="sql-syntax-array-constructors">
<!--
   <title>Array Constructors</title>
-->
   <title>配列コンストラクタ</title>

   <indexterm>
<!--
    <primary>array</primary>
    <secondary>constructor</secondary>
-->
    <primary>配列</primary>
    <secondary>コンストラクタ</secondary>
   </indexterm>

   <indexterm>
    <primary>ARRAY</primary>
   </indexterm>

   <para>
<!--
    An array constructor is an expression that builds an
    array value using values for its member elements.  A simple array
    constructor
    consists of the key word <literal>ARRAY</literal>, a left square bracket
    <literal>[</>, a list of expressions (separated by commas) for the
    array element values, and finally a right square bracket <literal>]</>.
    For example:
-->
配列コンストラクタは、メンバー要素に対する値を用いて配列値を構築する式です。
単純な配列コンストラクタの構成は、<literal>ARRAY</literal>キーワード、左大括弧<literal>[</>、（カンマで区切った）配列要素値用の式のリストで、最後に右大括弧<literal>]</>です。
以下に例を示します。
<programlisting>
SELECT ARRAY[1,2,3+4];
  array
---------
 {1,2,7}
(1 row)
</programlisting>
<!--
    By default,
    the array element type is the common type of the member expressions,
    determined using the same rules as for <literal>UNION</> or
    <literal>CASE</> constructs (see <xref linkend="typeconv-union-case">).
    You can override this by explicitly casting the array constructor to the
    desired type, for example:
    -->
    デフォルトで配列要素型は、メンバ式の型と同じで、<literal>UNION</>や<literal>CASE</>構文と同じ規則を使用して決定されます
（<xref linkend="typeconv-union-case">を参照してください）。これを明示的に配列コンストラクタを希望する型にキャストすることで書き換えることができます。例をあげます。
<programlisting>
SELECT ARRAY[1,2,22.7]::integer[];
  array
----------
 {1,2,23}
(1 row)
</programlisting>
<!--
    This has the same effect as casting each expression to the array
    element type individually.
    For more on casting, see <xref linkend="sql-syntax-type-casts">.
-->
これはそれぞれの式を配列型に個別にキャストするのと同じ効果があります。
キャストについてより多くは<xref linkend="sql-syntax-type-casts">を参照してください。
   </para>

   <para>
<!--
    Multidimensional array values can be built by nesting array
    constructors.
    In the inner constructors, the key word <literal>ARRAY</literal> can
    be omitted.  For example, these produce the same result:
-->
多次元配列値は、配列コンストラクタを入れ子にすることで構築できます。
内側のコンストラクタでは<literal>ARRAY</literal>キーワードは省略可能です。
例えば、以下は同じ結果になります。

<programlisting>
SELECT ARRAY[ARRAY[1,2], ARRAY[3,4]];
     array
---------------
 {{1,2},{3,4}}
(1 row)

SELECT ARRAY[[1,2],[3,4]];
     array
---------------
 {{1,2},{3,4}}
(1 row)
</programlisting>

<!--
    Since multidimensional arrays must be rectangular, inner constructors
    at the same level must produce sub-arrays of identical dimensions.
    Any cast applied to the outer <literal>ARRAY</> constructor propagates
    automatically to all the inner constructors.
-->
多次元配列は四角形配列でなければなりませんので、同一レベルの内部コンストラクタは同一次元の副配列を生成しなければなりません。外部<literal>ARRAY</>コンストラクタに適用される全てのキャストは自動的に全ての内部コンストラクタに伝播します。
  </para>

  <para>
<!--
    Multidimensional array constructor elements can be anything yielding
    an array of the proper kind, not only a sub-<literal>ARRAY</> construct.
    For example:
-->
多次元配列コンストラクタの要素は、副<literal>ARRAY</>構文だけでなく、適切な種類の配列を生成するものをとることができます。
以下に例を示します。
<programlisting>
CREATE TABLE arr(f1 int[], f2 int[]);

INSERT INTO arr VALUES (ARRAY[[1,2],[3,4]], ARRAY[[5,6],[7,8]]);

SELECT ARRAY[f1, f2, '{{9,10},{11,12}}'::int[]] FROM arr;
                     array
------------------------------------------------
 {{{1,2},{3,4}},{{5,6},{7,8}},{{9,10},{11,12}}}
(1 row)
</programlisting>
  </para>

  <para>
<!--
   You can construct an empty array, but since it's impossible to have an
   array with no type, you must explicitly cast your empty array to the
   desired type.  For example:
-->
空配列を構築できますが、型を所有しない配列を持つことは不可能なので、空配列を望まれる型に明示的にキャストしなければなりません。例をあげます。
<programlisting>
SELECT ARRAY[]::integer[];
 array
-------
 {}
(1 row)
</programlisting>
  </para>

  <para>
<!--
   It is also possible to construct an array from the results of a
   subquery.  In this form, the array constructor is written with the
   key word <literal>ARRAY</literal> followed by a parenthesized (not
   bracketed) subquery. For example:
-->
また、副問い合わせの結果から配列を構成することも可能です。
この形式の場合、配列コンストラクタは<literal>ARRAY</literal>キーワードの後に括弧（大括弧ではない）で括られた副問い合わせとして記述されます。
以下に例を示します。
<programlisting>
SELECT ARRAY(SELECT oid FROM pg_proc WHERE proname LIKE 'bytea%');
                                 array
-----------------------------------------------------------------------
 {2011,1954,1948,1952,1951,1244,1950,2005,1949,1953,2006,31,2412,2413}
(1 row)
</programlisting>
<!--
   The subquery must return a single column. The resulting
   one-dimensional array will have an element for each row in the
   subquery result, with an element type matching that of the
   subquery's output column.
-->
副問い合わせは単一の列を返さなければなりません。
その結果である一次元配列は、副問い合わせの出力列と一致する型を要素型とした、副問い合わせの結果内の各行を要素として持ちます。
  </para>

  <para>
<!--
   The subscripts of an array value built with <literal>ARRAY</literal>
   always begin with one.  For more information about arrays, see
   <xref linkend="arrays">.
-->
<literal>ARRAY</literal>で構築された配列値の添字は、常に1から始まります。
配列についての詳細は<xref linkend="arrays">を参照してください。
  </para>

  </sect2>

  <sect2 id="sql-syntax-row-constructors">
<!--
   <title>Row Constructors</title>
-->
   <title>行コンストラクタ</title>

   <indexterm>
<!--
    <primary>composite type</primary>
    <secondary>constructor</secondary>
-->
    <primary>複合型</primary>
    <secondary>のコンストラクタ</secondary>
   </indexterm>

   <indexterm>
<!--
    <primary>row type</primary>
    <secondary>constructor</secondary>
-->
    <primary>行型</primary>
    <secondary>のコンストラクタ</secondary>
   </indexterm>

   <indexterm>
    <primary>ROW</primary>
   </indexterm>

   <para>
<!--
    A row constructor is an expression that builds a row value (also
    called a composite value) using values
    for its member fields.  A row constructor consists of the key word
    <literal>ROW</literal>, a left parenthesis, zero or more
    expressions (separated by commas) for the row field values, and finally
    a right parenthesis.  For example:
-->
行コンストラクタは、そのメンバフィールドに対する値を用いて行値（複合値とも呼ばれます）を構築する式です。
行コンストラクタは、<literal>ROW</literal>キーワード、左括弧、行のフィールド値用の0個以上の式（カンマ区切り）、最後に右括弧からなります。
以下に例を示します。
<programlisting>
SELECT ROW(1,2.5,'this is a test');
</programlisting>
<!--
    The key word <literal>ROW</> is optional when there is more than one
    expression in the list.
-->
<literal>ROW</>キーワードは、1つ以上の式がリスト内にある場合は省略することができます。
   </para>

   <para>
<!--
    A row constructor can include the syntax
    <replaceable>rowvalue</replaceable><literal>.*</literal>,
    which will be expanded to a list of the elements of the row value,
    just as occurs when the <literal>.*</> syntax is used at the top level
    of a <command>SELECT</> list.  For example, if table <literal>t</> has
    columns <literal>f1</> and <literal>f2</>, these are the same:
-->
行コンストラクタには<replaceable>rowvalue</replaceable><literal>.*</literal>構文を含めることができます。
これは、<command>SELECT</>リストの最上位レベルで<literal>.*</>構文が使用された時とまったく同様に、行値の要素の列挙に展開されます。
たとえば、テーブル<literal>t</>が<literal>f1</>列と<literal>f2</>列を持つ場合、以下は同一です。
<programlisting>
SELECT ROW(t.*, 42) FROM t;
SELECT ROW(t.f1, t.f2, 42) FROM t;
</programlisting>
   </para>

   <note>
    <para>
<!--
     Before <productname>PostgreSQL</productname> 8.2, the
     <literal>.*</literal> syntax was not expanded, so that writing
     <literal>ROW(t.*, 42)</> created a two-field row whose first field
     was another row value.  The new behavior is usually more useful.
     If you need the old behavior of nested row values, write the inner
     row value without <literal>.*</literal>, for instance
     <literal>ROW(t, 42)</>.
-->
<productname>PostgreSQL</productname> 8.2より前では、<literal>.*</literal>構文は展開されませんでした。
<literal>ROW(t.*, 42)</>と記述すると、1つ目のフィールドに別の行値を持つ、2つのフィールドからなる行が作成されました。
たいていの場合、新しい動作はより使いやすくなっています。
入れ子状の行値という古い動作が必要であれば、<literal>.*</literal>を使用せずに、たとえば<literal>ROW(t, 42)</>といった、内部行値を記述してください。
    </para>
   </note>

   <para>
<!--
    By default, the value created by a <literal>ROW</> expression is of
    an anonymous record type.  If necessary, it can be cast to a named
    composite type &mdash; either the row type of a table, or a composite type
    created with <command>CREATE TYPE AS</>.  An explicit cast might be needed
    to avoid ambiguity.  For example:
-->
デフォルトでは、<literal>ROW</>式により作成される値は匿名レコード型になります。
必要に応じて、名前付きの複合型、テーブルの行型、もしくは<command>CREATE TYPE AS</>で作成された複合型にキャストすることができます。
明示的なキャストは曖昧性を防止するために必要となることもあります。
以下に例を示します。
<programlisting>
CREATE TABLE mytable(f1 int, f2 float, f3 text);

CREATE FUNCTION getf1(mytable) RETURNS int AS 'SELECT $1.f1' LANGUAGE SQL;

<!--
&#045;&#045; No cast needed since only one getf1() exists
-->
-- getf1()が1つしか存在しないためキャスト不要。
SELECT getf1(ROW(1,2.5,'this is a test'));
 getf1
-------
     1
(1 row)

CREATE TYPE myrowtype AS (f1 int, f2 text, f3 numeric);

CREATE FUNCTION getf1(myrowtype) RETURNS int AS 'SELECT $1.f1' LANGUAGE SQL;

<!--
&#045;&#045; Now we need a cast to indicate which function to call:
-->
-- ここでは、どの関数を呼び出すのかを示すためにキャストが必要。
SELECT getf1(ROW(1,2.5,'this is a test'));
ERROR:  function getf1(record) is not unique

SELECT getf1(ROW(1,2.5,'this is a test')::mytable);
 getf1
-------
     1
(1 row)

SELECT getf1(CAST(ROW(11,'this is a test',2.5) AS myrowtype));
 getf1
-------
    11
(1 row)
</programlisting>
  </para>

  <para>
<!--
   Row constructors can be used to build composite values to be stored
   in a composite-type table column, or to be passed to a function that
   accepts a composite parameter.  Also,
   it is possible to compare two row values or test a row with
   <literal>IS NULL</> or <literal>IS NOT NULL</>, for example:
-->
行コンストラクタは、複合型のテーブル列に格納する複合型の値を構築するため、あるいは複合型のパラメータを受け付ける関数に渡すために使用することができます。
また、以下の例のように、2つの行値を比較することも、<literal>IS NULL</>もしくは<literal>IS NOT NULL</>で行を検査することも可能です。
<programlisting>
SELECT ROW(1,2.5,'this is a test') = ROW(1, 3, 'not the same');
<!--
SELECT ROW(table.*) IS NULL FROM table;  &#045;&#045; detect all-null rows
-->
SELECT ROW(table.*) IS NULL FROM table;  -- すべてがNULLの行を検出します。
</programlisting>
<!--
   For more detail see <xref linkend="functions-comparisons">.
   Row constructors can also be used in connection with subqueries,
   as discussed in <xref linkend="functions-subquery">.
-->
詳細は<xref linkend="functions-comparisons">を参照してください。
行コンストラクタは、<xref linkend="functions-subquery">で説明した、副問い合わせと一緒に使用することもできます。
  </para>

  </sect2>

  <sect2 id="syntax-express-eval">
<!--
   <title>Expression Evaluation Rules</title>
-->
   <title>式の評価規則</title>

   <indexterm>
<!--
    <primary>expression</primary>
    <secondary>order of evaluation</secondary>
-->
    <primary>式</primary>
    <secondary>の評価順</secondary>
   </indexterm>

   <para>
<!--
    The order of evaluation of subexpressions is not defined.  In
    particular, the inputs of an operator or function are not necessarily
    evaluated left-to-right or in any other fixed order.
-->
副式の評価の順序は定義されていません。
特に演算子や関数の入力は、必ずしも左から右などの決まった順序で評価されるわけではありません。
   </para>

   <para>
<!--
    Furthermore, if the result of an expression can be determined by
    evaluating only some parts of it, then other subexpressions
    might not be evaluated at all.  For instance, if one wrote:
-->
さらに、その式の一部を評価しただけで式の結果を判断できる場合には、他の副式がまったく評価されないこともあります。  
例えば、
<programlisting>
SELECT true OR somefunc();
</programlisting>
<!--
    then <literal>somefunc()</literal> would (probably) not be called
    at all. The same would be the case if one wrote:
-->
では、（おそらく）<literal>somefunc()</literal>は呼び出されないでしょう。
以下の場合も同様です。
<programlisting>
SELECT somefunc() OR true;
</programlisting>
<!--
    Note that this is not the same as the left-to-right
    <quote>short-circuiting</quote> of Boolean operators that is found
    in some programming languages.
-->
これは一部のプログラミング言語に見られる、ブーリアン演算子での左から右への<quote>ショートサーキット</quote>とは異なることに注意してください。
   </para>

   <para>
<!--
    As a consequence, it is unwise to use functions with side effects
    as part of complex expressions.  It is particularly dangerous to
    rely on side effects or evaluation order in <literal>WHERE</> and <literal>HAVING</> clauses,
    since those clauses are extensively reprocessed as part of
    developing an execution plan.  Boolean
    expressions (<literal>AND</>/<literal>OR</>/<literal>NOT</> combinations) in those clauses can be reorganized
    in any manner allowed by the laws of Boolean algebra.
-->
そのため、副次作用がある関数を複雑な式の一部として使用することは推奨されません。
特に、<literal>WHERE</>句および<literal>HAVING</>句で副次作用や評価順に依存するのは危険です。
これらの句は、実行計画を作成する過程で頻繁に再処理されるからです。
これらの句のブール式（<literal>AND</>/<literal>OR</>/<literal>NOT</>の組み合わせ）は、ブール代数の規則で許されるあらゆる方式で再編成される可能性があります。
   </para>

   <para>
<!--
    When it is essential to force evaluation order, a <literal>CASE</>
    construct (see <xref linkend="functions-conditional">) can be
    used.  For example, this is an untrustworthy way of trying to
    avoid division by zero in a <literal>WHERE</> clause:
-->
評価の順序を強制することが重要であれば、<literal>CASE</>構文（<xref linkend="functions-conditional">を参照）を使用できます。
例えば、次の式は<literal>WHERE</>句で0除算を避ける方法としては信頼性の低いものです。
<programlisting>
SELECT ... WHERE x &gt; 0 AND y/x &gt; 1.5;
</programlisting>
<!--
    But this is safe:
-->
しかし、次のようにすれば安全です。
<programlisting>
SELECT ... WHERE CASE WHEN x &gt; 0 THEN y/x &gt; 1.5 ELSE false END;
</programlisting>
<!--
    A <literal>CASE</> construct used in this fashion will defeat optimization
    attempts, so it should only be done when necessary.  (In this particular
    example, it would be better to sidestep the problem by writing
    <literal>y &gt; 1.5*x</> instead.)
-->
このような方法で使用される<literal>CASE</>構文は最適化を妨げるものなので、必要な場合にのみ使用してください。
（特に、この例では、<literal>y &gt; 1.5*x</>と代わりに記述することが問題を回避するより優れた方法です。）
   </para>

   <para>
<!--
    A limitation of this technique is that a <literal>CASE</> cannot
    prevent evaluation of an aggregate expression contained within it,
    because aggregate expressions are computed before <quote>scalar</>
    expressions in a <literal>SELECT</> list or <literal>HAVING</> clause
    are considered.  For example, the following query can cause a
    division-by-zero error despite seemingly having protected against it:
-->
この手法の限界は、その中に含まれる集約式の評価を<literal>CASE</>が防げないことです。なぜなら、<literal>SELECT</>リストや<literal>HAVING</>句の<quote>スカラ</>式が考慮される前に、集約式が計算されるからです。
例えば、以下の問い合わせは対策を施しているように見えるにも関わらずゼロ除算エラーになり得ます。
<programlisting>
SELECT CASE WHEN min(employees) > 0
            THEN avg(expenses / employees)
       END
    FROM departments;
</programlisting>
<!--
    The <function>min()</> and <function>avg()</> aggregates are computed
    concurrently over all the input rows, so if any row
    has <structfield>employees</> equal to zero, the division-by-zero error
    will occur before there is any opportunity to test the result of
    <function>min()</>.  Instead, use a <literal>WHERE</>
    or <literal>FILTER</> clause to prevent problematic input rows from
    reaching an aggregate function in the first place.
-->
<function>min()</>と<function>avg()</>集約は入力行すべてに対して同時に計算されますので、もし<structfield>employees</>がゼロになる行があれば、<function>min()</>の結果が検査される機会の前にゼロ除算エラーが起こります。
代わりに、まずは問題のある入力行が集約関数に渡されないようにするために<literal>WHERE</>または<literal>FILTER</>句を使ってください。
   </para>
  </sect2>
 </sect1>

 <sect1 id="sql-syntax-calling-funcs">
<!--
  <title>Calling Functions</title>
-->
  <title>関数呼び出し</title>

   <indexterm zone="sql-syntax-calling-funcs">
<!--
    <primary>notation</primary>
    <secondary>functions</secondary>
-->
    <primary>表記</primary>
    <secondary>関数</secondary>
   </indexterm>

   <para>
<!--
    <productname>PostgreSQL</productname> allows functions that have named
    parameters to be called using either <firstterm>positional</firstterm> or
    <firstterm>named</firstterm> notation.  Named notation is especially
    useful for functions that have a large number of parameters, since it
    makes the associations between parameters and actual arguments more
    explicit and reliable.
    In positional notation, a function call is written with
    its argument values in the same order as they are defined in the function
    declaration.  In named notation, the arguments are matched to the
    function parameters by name and can be written in any order.
-->
<productname>PostgreSQL</productname>は<firstterm>位置</firstterm>と<firstterm>名前付け</firstterm>表記による名前付けパラメータを関数に持たせることが可能です。
特に名前付け表記は、多数のパラメータを持つ関数においてパラメータと引数の関連をより明確・確実にするのに有用です。
位置表記では、関数定義の際に定義されたものと同じ並び順の引数が、関数呼び出しに記述されることになります。
名前付け表記では、引数と関数パラメータの名前を一致させることになり、引数はどのような並び順でも構いません。
   </para>

   <para>
<!--
    In either notation, parameters that have default values given in the
    function declaration need not be written in the call at all.  But this
    is particularly useful in named notation, since any combination of
    parameters can be omitted; while in positional notation parameters can
    only be omitted from right to left.
-->
どちらの表記でも、パラメータが関数定義時にデフォルト値を与えられていれば呼び出し時に記述される必要はありません。
これは、名前付け表記では、パラメータ群の任意の組み合わせを省略することができるので、特殊なケースでは有用です。
一方、位置表記のパラメータは右から左へ省略していくことしかできません。
   </para>

   <para>
<!--
    <productname>PostgreSQL</productname> also supports
    <firstterm>mixed</firstterm> notation, which combines positional and
    named notation.  In this case, positional parameters are written first
    and named parameters appear after them.
-->
<productname>PostgreSQL</productname>では、名前付け表記と位置表記の<firstterm>混在</firstterm>表記もサポートしています。この場合、位置表記のパラメータが最初に記述され、その後に名前付け表記のパラメータが記述されることになります。
   </para>

   <para>
<!--
    The following examples will illustrate the usage of all three
    notations, using the following function definition:
-->
下記は3つの表記方法を使った関数定義の例です。
<programlisting>
CREATE FUNCTION concat_lower_or_upper(a text, b text, uppercase boolean DEFAULT false)
RETURNS text
AS
$$
 SELECT CASE
        WHEN $3 THEN UPPER($1 || ' ' || $2)
        ELSE LOWER($1 || ' ' || $2)
        END;
$$
LANGUAGE SQL IMMUTABLE STRICT;
</programlisting>
<!--
    Function <function>concat_lower_or_upper</function> has two mandatory
    parameters, <literal>a</literal> and <literal>b</literal>.  Additionally
    there is one optional parameter <literal>uppercase</literal> which defaults
    to <literal>false</literal>.  The <literal>a</literal> and
    <literal>b</literal> inputs will be concatenated, and forced to either
    upper or lower case depending on the <literal>uppercase</literal>
    parameter.  The remaining details of this function
    definition are not important here (see <xref linkend="extend"> for
    more information).
-->
<function>concat_lower_or_upper</function>関数は、<literal>a</literal>と<literal>b</literal>の指定必須となる2つのパラメータを持ちます。加えて、<literal>uppercase</literal>というデフォルトが<literal>false</literal>となっているオプショナルなパラメータを一つ持ちます。<literal>a</literal>と<literal>b</literal>で入力された文字列が結合され、<literal>uppercase</literal>パラメータにより大文字か小文字に変換されます。他のこの関数定義についての詳細は、ここでは重要ではありません。( 詳細は<xref linkend="extend">を参照して下さい。)
   </para>

   <sect2 id="sql-syntax-calling-funcs-positional">
<!--
    <title>Using Positional Notation</title>
-->
    <title>位置表記の使用</title>

    <indexterm>
<!--
     <primary>function</primary>
     <secondary>positional notation</secondary>
-->
     <primary>関数</primary>
     <secondary>位置表記</secondary>
    </indexterm>

    <para>
<!--
     Positional notation is the traditional mechanism for passing arguments
     to functions in <productname>PostgreSQL</productname>.  An example is:
-->
位置表記は、<productname>PostgreSQL</productname>の引数を関数に渡す伝統的な仕組みです。例を挙げます。
<screen>
SELECT concat_lower_or_upper('Hello', 'World', true);
 concat_lower_or_upper 
-----------------------
 HELLO WORLD
(1 row)
</screen>
<!--
     All arguments are specified in order.  The result is upper case since
     <literal>uppercase</literal> is specified as <literal>true</literal>.
     Another example is:
-->
すべての引数を順番通りに指定します。<literal>uppercase</literal>が<literal>true</literal>と指定されていますので、結果は大文字です。別の例を示します。
<screen>
SELECT concat_lower_or_upper('Hello', 'World');
 concat_lower_or_upper 
-----------------------
 hello world
(1 row)
</screen>
<!--
     Here, the <literal>uppercase</literal> parameter is omitted, so it
     receives its default value of <literal>false</literal>, resulting in
     lower case output.  In positional notation, arguments can be omitted
     from right to left so long as they have defaults.
-->
ここでは<literal>uppercase</literal>パラメータが省略されていますので、そのデフォルト値である<literal>false</literal>を受け取ることとなり、結果は小文字になります。位置表記では引数がデフォルト値を持つ限り右側から左の方向で、引数を省略することができます。
    </para>
   </sect2>

   <sect2 id="sql-syntax-calling-funcs-named">
<!--
    <title>Using Named Notation</title>
-->
    <title>名前付け表記の使用</title>

    <indexterm>
<!--
     <primary>function</primary>
     <secondary>named notation</secondary>
-->
     <primary>関数</primary>
     <secondary>名前付け表記</secondary>
    </indexterm>

    <para>
<!--
     In named notation, each argument's name is specified using
     <literal>:=</literal> to separate it from the argument expression.
     For example:
-->
名前付け表記では、各引数の名前は<literal>:=</literal>を使用し引数の表現と分けて指定されます。例を挙げます。
<screen>
SELECT concat_lower_or_upper(a := 'Hello', b := 'World');
 concat_lower_or_upper 
-----------------------
 hello world
(1 row)
</screen>
<!--
     Again, the argument <literal>uppercase</literal> was omitted
     so it is set to <literal>false</literal> implicitly.  One advantage of
     using named notation is that the arguments may be specified in any
     order, for example:
-->
繰り返しになりますが、<literal>uppercase</literal>引数が省略されていますので、暗黙的に<literal>false</literal>に設定されます。名前付け表記の使用の利点の１つとして、引数を任意の順序で指定できる点があります。以下に例を示します。
<screen>
SELECT concat_lower_or_upper(a := 'Hello', b := 'World', uppercase := true);
 concat_lower_or_upper 
-----------------------
 HELLO WORLD
(1 row)

SELECT concat_lower_or_upper(a := 'Hello', uppercase := true, b := 'World');
 concat_lower_or_upper 
-----------------------
 HELLO WORLD
(1 row)
</screen>
    </para>
   </sect2>

  <sect2 id="sql-syntax-calling-funcs-mixed">
<!--
   <title>Using Mixed Notation</title>
-->
   <title>混在表記の利用</title>

   <indexterm>
<!--
    <primary>function</primary>
    <secondary>mixed notation</secondary>
-->
     <primary>関数</primary>
     <secondary>混在表記</secondary>
   </indexterm>

   <para>
<!--
    The mixed notation combines positional and named notation. However, as
    already mentioned, named arguments cannot precede positional arguments.
    For example:
-->
混在表記は名前付け表記と位置表記を組み合わせたものです。しかし既に述べたように、名前付けされた引数は位置づけされたパラメータの前に記述することはできません。例を挙げます。
<screen>
SELECT concat_lower_or_upper('Hello', 'World', uppercase := true);
 concat_lower_or_upper 
-----------------------
 HELLO WORLD
(1 row)
</screen>
<!--
    In the above query, the arguments <literal>a</literal> and
    <literal>b</literal> are specified positionally, while
    <literal>uppercase</> is specified by name.  In this example,
    that adds little except documentation.  With a more complex function
    having numerous parameters that have default values, named or mixed
    notation can save a great deal of writing and reduce chances for error.
-->
上記の問い合わせでは、<literal>a</literal>と<literal>b</literal>が位置で指定され、<literal>uppercase</>は名前で指定されています。この例では文書化の目的以外ほとんど意味がありません。デフォルト値が割り当てられた多くのパラメータを持つ、もっと複雑な関数では、名前付けもしくは混在表記により記述量を大きく減らすことができ、かつ、エラーが紛れ込む可能性を抑えることができます。
   </para>

   <note>
    <para>
<!--
     Named and mixed call notations currently cannot be used when calling an
     aggregate function (but they do work when an aggregate function is used
     as a window function).
-->
名前付けと混在呼び出し表記は集約関数の呼び出しでは現在使用できません（が、集約関数がウィンドウ関数として使われる場合には動作します）。
    </para>
   </note>
  </sect2>
 </sect1>

</chapter>
