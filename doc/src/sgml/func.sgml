<!-- doc/src/sgml/func.sgml -->

 <chapter id="functions">
<!--
  <title>Functions and Operators</title>
-->
  <title>関数と演算子</title>

  <indexterm zone="functions">
<!--
   <primary>function</primary>
-->
  <primary>関数</primary>
  </indexterm>

  <indexterm zone="functions">
<!--
   <primary>operator</primary>
-->
   <primary>演算子</primary>
  </indexterm>

  <para>
<!--
   <productname>PostgreSQL</productname> provides a large number of
   functions and operators for the built-in data types.  Users can also
   define their own functions and operators, as described in
   <xref linkend="server-programming">.  The
   <application>psql</application> commands <command>\df</command> and
   <command>\do</command> can be used to list all
   available functions and operators, respectively.
-->
<productname>PostgreSQL</productname>は組み込みデータ型に対して数多くの関数と演算子を用意しています。
また、<xref linkend="server-programming">で解説しているように、ユーザは独自の関数と演算子を定義することもできます。
<application>psql</application>の<command>\df</command>コマンドと<command>\do</command>コマンドはそれぞれ全ての使用可能な関数と演算子をリストするのに使用されます。
  </para>

  <para>
<!--
   If you are concerned about portability then note that most of
   the functions and operators described in this chapter, with the
   exception of the most trivial arithmetic and comparison operators
   and some explicitly marked functions, are not specified by the
   <acronym>SQL</acronym> standard. Some of this extended functionality
   is present in other <acronym>SQL</acronym> database management
   systems, and in many cases this functionality is compatible and
   consistent between the various implementations.  This chapter is also
   not exhaustive;  additional functions appear in relevant sections of
   the manual.
-->
もし移植性が気になるのであれば、本章で説明する大多数の関数と演算子は、ほとんどの基本的算術演算子、比較演算子およびいくつかの明示的に印を付けた関数を除いて、標準<acronym>SQL</acronym>で規定されていない点に注意してください。
この拡張機能のいくつかは、他の<acronym>SQL</acronym>データベース管理システムにも備わっており、多くの場合この機能には各種実装間で互換性と整合性があります。
同時に、本節は完全なものではありません。追加の関数はマニュアルの関連のある節に出てきます。
  </para>


  <sect1 id="functions-logical">
<!--
   <title>Logical Operators</title>
-->
   <title>論理演算子</title>

   <indexterm zone="functions-logical">
<!--
    <primary>operator</primary>
    <secondary>logical</secondary>
-->
    <primary>演算子</primary>
    <secondary>論理</secondary>
   </indexterm>

   <indexterm>
<!--
    <primary>Boolean</primary>
    <secondary>operators</secondary>
    <see>operators, logical</see>
-->
    <primary>論理値</primary>
    <secondary>演算子</secondary>
    <see>演算子、論理</see>
   </indexterm>

   <para>
<!--
    The usual logical operators are available:
-->
    通常の論理演算子が使用できます。

    <indexterm>
<!--
     <primary>AND (operator)</primary>
-->
     <primary>AND（演算子）</primary>
    </indexterm>

    <indexterm>
<!--
     <primary>OR (operator)</primary>
-->
     <primary>OR（演算子）</primary>
    </indexterm>

    <indexterm>
<!--
     <primary>NOT (operator)</primary>
-->
     <primary>NOT（演算子）</primary>
    </indexterm>

    <indexterm>
<!--
     <primary>conjunction</primary>
-->
     <primary>論理積</primary>
    </indexterm>

    <indexterm>
<!--
     <primary>disjunction</primary>
-->
     <primary>論理和</primary>
    </indexterm>

    <indexterm>
<!--
     <primary>negation</primary>
-->
     <primary>否定</primary>
    </indexterm>

    <simplelist>
     <member><literal>AND</></member>
     <member><literal>OR</></member>
     <member><literal>NOT</></member>
    </simplelist>

<!--
    <acronym>SQL</acronym> uses a three-valued logic system with true,
    false, and <literal>null</>, which represents <quote>unknown</quote>.
    Observe the following truth tables:
-->
<acronym>SQL</acronym>はtrue、false、そして<quote>不明</quote>を意味する<literal>NULL値</>の3値のロジックシステムを使用します。
以下の真理値表を参照してください。

    <informaltable>
     <tgroup cols="4">
      <thead>
       <row>
        <entry><replaceable>a</replaceable></entry>
        <entry><replaceable>b</replaceable></entry>
        <entry><replaceable>a</replaceable> AND <replaceable>b</replaceable></entry>
        <entry><replaceable>a</replaceable> OR <replaceable>b</replaceable></entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry>TRUE</entry>
        <entry>TRUE</entry>
        <entry>TRUE</entry>
        <entry>TRUE</entry>
       </row>

       <row>
        <entry>TRUE</entry>
        <entry>FALSE</entry>
        <entry>FALSE</entry>
        <entry>TRUE</entry>
       </row>

       <row>
        <entry>TRUE</entry>
        <entry>NULL</entry>
        <entry>NULL</entry>
        <entry>TRUE</entry>
       </row>

       <row>
        <entry>FALSE</entry>
        <entry>FALSE</entry>
        <entry>FALSE</entry>
        <entry>FALSE</entry>
       </row>

       <row>
        <entry>FALSE</entry>
        <entry>NULL</entry>
        <entry>FALSE</entry>
        <entry>NULL</entry>
       </row>

       <row>
        <entry>NULL</entry>
        <entry>NULL</entry>
        <entry>NULL</entry>
        <entry>NULL</entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>

    <informaltable>
     <tgroup cols="2">
      <thead>
       <row>
        <entry><replaceable>a</replaceable></entry>
        <entry>NOT <replaceable>a</replaceable></entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry>TRUE</entry>
        <entry>FALSE</entry>
       </row>

       <row>
        <entry>FALSE</entry>
        <entry>TRUE</entry>
       </row>

       <row>
        <entry>NULL</entry>
        <entry>NULL</entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>
   </para>

   <para>
<!--
    The operators <literal>AND</literal> and <literal>OR</literal> are
    commutative, that is, you can switch the left and right operand
    without affecting the result.  But see <xref
    linkend="syntax-express-eval"> for more information about the
    order of evaluation of subexpressions.
-->
<literal>AND</literal>演算子と<literal>OR</literal>演算子は可換です。
つまり、結果に影響を与えることなく左右のオペランドを交換することができます。
しかし、副式の評価順についてのより詳細は<xref linkend="syntax-express-eval">を参照してください。
   </para>
  </sect1>

  <sect1 id="functions-comparison">
<!--
   <title>Comparison Operators</title>
-->
   <title>比較演算子</title>

   <indexterm zone="functions-comparison">
<!--
    <primary>comparison</primary>
    <secondary>operators</secondary>
-->
    <primary>比較</primary>
    <secondary>演算子</secondary>
   </indexterm>

   <para>
<!--
    The usual comparison operators are available, shown in <xref
    linkend="functions-comparison-table">.
-->
<xref linkend="functions-comparison-table">に示す、通常の比較演算子は使用可能です。
   </para>

   <table id="functions-comparison-table">
<!--
    <title>Comparison Operators</title>
-->
    <title>比較演算子</title>
    <tgroup cols="2">
     <thead>
      <row>
<!--
       <entry>Operator</entry>
       <entry>Description</entry>
-->
       <entry>演算子</entry>
       <entry>説明</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry> <literal>&lt;</literal> </entry>
<!--
       <entry>less than</entry>
-->
       <entry>小なり</entry>
      </row>

      <row>
       <entry> <literal>&gt;</literal> </entry>
<!--
       <entry>greater than</entry>
-->
       <entry>大なり</entry>
      </row>

      <row>
       <entry> <literal>&lt;=</literal> </entry>
<!--
       <entry>less than or equal to</entry>
-->
       <entry>等しいかそれ以下</entry>
      </row>

      <row>
       <entry> <literal>&gt;=</literal> </entry>
<!--
       <entry>greater than or equal to</entry>
-->
       <entry>等しいかそれ以上</entry>
      </row>

      <row>
       <entry> <literal>=</literal> </entry>
<!--
       <entry>equal</entry>
-->
       <entry>等しい</entry>
      </row>

      <row>
<!--
       <entry> <literal>&lt;&gt;</literal> or <literal>!=</literal> </entry>
-->
       <entry> <literal>&lt;&gt;</literal> または <literal>!=</literal> </entry>
<!--
       <entry>not equal</entry>
-->
       <entry>等しくない</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <note>
    <para>
<!--
     The <literal>!=</literal> operator is converted to
     <literal>&lt;&gt;</literal> in the parser stage.  It is not
     possible to implement <literal>!=</literal> and
     <literal>&lt;&gt;</literal> operators that do different things.
-->
<literal>!=</literal>演算子は構文解析で<literal>&lt;&gt;</literal>に変換されます。
<literal>!=</literal>演算子と<literal>&lt;&gt;</literal>演算子に異なる処理を行わせる実装はできません。
    </para>
   </note>

   <para>
<!--
    Comparison operators are available for all relevant data types.
    All comparison operators are binary operators that
    return values of type <type>boolean</type>; expressions like
    <literal>1 &lt; 2 &lt; 3</literal> are not valid (because there is
    no <literal>&lt;</literal> operator to compare a Boolean value with
    <literal>3</literal>).
-->
比較演算子は関連性のある全てのデータ型で使用できます。
全ての比較演算子は二項演算子で、<type>boolean</type>データ型を返します。<literal>1 &lt; 2 &lt; 3</literal>のような式は（ブール値と<literal>3</literal>を比較する<literal>&lt;</literal>演算子がないので）無効です。
   </para>

   <para>
    <indexterm>
     <primary>BETWEEN</primary>
    </indexterm>
<!--
    In addition to the comparison operators, the special
    <token>BETWEEN</token> construct is available:
-->
比較演算子に加えて特殊な<token>BETWEEN</token>構文が使えます。
<synopsis>
<replaceable>a</replaceable> BETWEEN <replaceable>x</replaceable> AND <replaceable>y</replaceable>
</synopsis>
<!--
    is equivalent to
-->
は
<synopsis>
<replaceable>a</replaceable> &gt;= <replaceable>x</replaceable> AND <replaceable>a</replaceable> &lt;= <replaceable>y</replaceable>
</synopsis>
と同じです。
<!--
    Notice that <token>BETWEEN</token> treats the endpoint values as included
    in the range.
    <literal>NOT BETWEEN</literal> does the opposite comparison:
-->
<token>BETWEEN</token>は範囲内に含まれるとして終点値を扱うことに注意してください。
<literal>NOT BETWEEN</literal>はその反対の比較をします（指定した値は包括しません）。
<synopsis>
<replaceable>a</replaceable> NOT BETWEEN <replaceable>x</replaceable> AND <replaceable>y</replaceable>
</synopsis>
<!--
    is equivalent to
-->
は
<synopsis>
<replaceable>a</replaceable> &lt; <replaceable>x</replaceable> OR <replaceable>a</replaceable> &gt; <replaceable>y</replaceable>
</synopsis>
と同一です。
    <indexterm>
     <primary>BETWEEN SYMMETRIC</primary>
    </indexterm>
<!--
    <literal>BETWEEN SYMMETRIC</> is the same as <literal>BETWEEN</>
    except there is no requirement that the argument to the left of
    <literal>AND</> be less than or equal to the argument on the right.
    If it is not, those two arguments are automatically swapped, so that
    a nonempty range is always implied.
-->
<literal>BETWEEN SYMMETRIC</>は、<literal>AND</>の左側の引数が右側の引数より小さいか、もしくは等しいという必要性が無い点を除き<literal>BETWEEN</>と同じです。
この条件を満たしていない場合、2つの引数は自動的に置き換えられますので、常に空ではない範囲となります。
   </para>

   <para>
    <indexterm>
     <primary>IS NULL</primary>
    </indexterm>
    <indexterm>
     <primary>IS NOT NULL</primary>
    </indexterm>
    <indexterm>
     <primary>ISNULL</primary>
    </indexterm>
    <indexterm>
     <primary>NOTNULL</primary>
    </indexterm>
<!--
    To check whether a value is or is not null, use the constructs:
-->
値がNULLかNULLでないかを検証するには次の構文を使います。
<synopsis>
<replaceable>expression</replaceable> IS NULL
<replaceable>expression</replaceable> IS NOT NULL
</synopsis>
<!--
    or the equivalent, but nonstandard, constructs:
-->
あるいは、これと同等の、非標準の構文も使えます。
<synopsis>
<replaceable>expression</replaceable> ISNULL
<replaceable>expression</replaceable> NOTNULL
</synopsis>
<!--
    <indexterm><primary>null value</primary><secondary>comparing</secondary></indexterm>
-->
    <indexterm><primary>NULL値</primary><secondary>比較</secondary></indexterm>
   </para>

   <para>
<!--
    Do <emphasis>not</emphasis> write
    <literal><replaceable>expression</replaceable> = NULL</literal>
    because <literal>NULL</> is not <quote>equal to</quote>
    <literal>NULL</>.  (The null value represents an unknown value,
    and it is not known whether two unknown values are equal.) This
    behavior conforms to the SQL standard.
-->
<literal>NULL</>と<literal>NULL</>とは<quote>等しい</quote>関係にはありませんので、<literal><replaceable>expression</replaceable> = NULL</literal>と記述しては<emphasis>いけません</emphasis>
（NULL値は不明の値を表しているため、不明な値同士が同じかどうかは識別できません）。
これは標準SQLに従った動作です。
   </para>

  <tip>
   <para>
<!--
    Some applications might expect that
    <literal><replaceable>expression</replaceable> = NULL</literal>
    returns true if <replaceable>expression</replaceable> evaluates to
    the null value.  It is highly recommended that these applications
    be modified to comply with the SQL standard. However, if that
    cannot be done the <xref linkend="guc-transform-null-equals">
    configuration variable is available. If it is enabled,
    <productname>PostgreSQL</productname> will convert <literal>x =
    NULL</literal> clauses to <literal>x IS NULL</literal>.
-->
アプリケーションによっては、<literal><replaceable>expression</replaceable> = NULL</literal>が、<replaceable>expression</replaceable>がNULL値と評価されるのであれば真を返すことを期待することがあります。
こうしたアプリケーションは標準SQLに従うように改修することを強く推奨します。
しかし、それができなければ<xref linkend="guc-transform-null-equals">を使用することで対応することができます。
これを有効にした場合、<productname>PostgreSQL</productname>は<literal>x = NULL</literal>句を<literal>x IS NULL</literal>に変換します。
   </para>
  </tip>

  <note>
   <para>
<!--
    If the <replaceable>expression</replaceable> is row-valued, then
    <literal>IS NULL</> is true when the row expression itself is null
    or when all the row's fields are null, while
    <literal>IS NOT NULL</> is true when the row expression itself is non-null
    and all the row's fields are non-null.  Because of this behavior,
    <literal>IS NULL</> and <literal>IS NOT NULL</> do not always return
    inverse results for row-valued expressions, i.e., a row-valued
    expression that contains both NULL and non-null values will return false
    for both tests.
    This definition conforms to the SQL standard, and is a change from the
    inconsistent behavior exhibited by <productname>PostgreSQL</productname>
    versions prior to 8.2.
-->
<replaceable>expression</replaceable>が行値の場合、行式自体がNULLまたは、行のフィールドすべてがNULLの場合に<literal>IS NULL</>は真となります。一方<literal>IS NOT NULL</>は、行式自体が非NULLまたは、行のフィールドすべてが非NULLの場合に真となります。
この動作により、<literal>IS NULL</>および<literal>IS NOT NULL</>は行値評価式に対し常に反対の結果を返しません。つまりNULLと非NULLの値の両方を含む行値式はどちらの試験でも偽を返します。
この定義は標準SQLに従ったもので、8.2より前のバージョンの<productname>PostgreSQL</productname>における一貫性のない動作から変更されました。
   </para>
  </note>

   <para>
    <indexterm>
     <primary>IS DISTINCT FROM</primary>
    </indexterm>
    <indexterm>
     <primary>IS NOT DISTINCT FROM</primary>
    </indexterm>
<!--
    Ordinary comparison operators yield null (signifying <quote>unknown</>),
    not true or false, when either input is null.  For example,
    <literal>7 = NULL</> yields null, as does <literal>7 &lt;&gt; NULL</>.  When
    this behavior is not suitable, use the
    <literal>IS <optional> NOT </> DISTINCT FROM</literal> constructs:
-->
入力のどちらかが真または偽ではなくNULLの場合、通常の比較演算子は（<quote>不明</>を意味する）nullを生成します。
例えば<literal>7 = NULL</>はnullになります。<literal>7 &lt;&gt; NULL</>も同様です。
この動作が適切でない場合は、<literal>IS <optional> NOT </> DISTINCT FROM</literal>構文を使用してください。
<synopsis>
<replaceable>expression</replaceable> IS DISTINCT FROM <replaceable>expression</replaceable>
<replaceable>expression</replaceable> IS NOT DISTINCT FROM <replaceable>expression</replaceable>
</synopsis>
<!--
    For non-null inputs, <literal>IS DISTINCT FROM</literal> is
    the same as the <literal>&lt;&gt;</> operator.  However, if both
    inputs are null it returns false, and if only one input is
    null it returns true.  Similarly, <literal>IS NOT DISTINCT
    FROM</literal> is identical to <literal>=</literal> for non-null
    inputs, but it returns true when both inputs are null, and false when only
    one input is null. Thus, these constructs effectively act as though null
    were a normal data value, rather than <quote>unknown</>.
-->
非NULLの入力では、<literal>IS DISTINCT FROM</literal>は<literal>&lt;&gt;</>演算子と同じです。
しかし、入力がどちらもNULLの場合、これは偽を返し、片方の入力のみがNULLの場合は真を返します。
同様に、<literal>IS NOT DISTINCT FROM</literal>は非NULL入力では<literal>=</literal>と同じですが、両方の入力がNULLであれば真を、片方のみがNULLの場合は偽を返します。
このように、これらの構文はNULLを<quote>不明な値</>ではなく、通常の値かのように動作します。
   </para>

   <para>
    <indexterm>
     <primary>IS TRUE</primary>
    </indexterm>
    <indexterm>
     <primary>IS NOT TRUE</primary>
    </indexterm>
    <indexterm>
     <primary>IS FALSE</primary>
    </indexterm>
    <indexterm>
     <primary>IS NOT FALSE</primary>
    </indexterm>
    <indexterm>
     <primary>IS UNKNOWN</primary>
    </indexterm>
    <indexterm>
     <primary>IS NOT UNKNOWN</primary>
    </indexterm>
<!--
    Boolean values can also be tested using the constructs
-->
論理値も次の構文で検証できます。
<synopsis>
<replaceable>expression</replaceable> IS TRUE
<replaceable>expression</replaceable> IS NOT TRUE
<replaceable>expression</replaceable> IS FALSE
<replaceable>expression</replaceable> IS NOT FALSE
<replaceable>expression</replaceable> IS UNKNOWN
<replaceable>expression</replaceable> IS NOT UNKNOWN
</synopsis>
<!--
    These will always return true or false, never a null value, even when the
    operand is null.
    A null input is treated as the logical value <quote>unknown</>.
    Notice that <literal>IS UNKNOWN</> and <literal>IS NOT UNKNOWN</> are
    effectively the same as <literal>IS NULL</literal> and
    <literal>IS NOT NULL</literal>, respectively, except that the input
    expression must be of Boolean type.
-->
これらは、常に真か偽を返し、演算項目がNULLであってもNULL値を返すことはありません。
NULL値が入力されると、<quote>不明</>という論理値として扱われます。
<literal>IS UNKNOWN</>と<literal>IS NOT UNKNOWN</>が、入力式が論理値型でなければならないという点を除き、それぞれ実質的に<literal>IS NULL</literal>と<literal>IS NOT NULL</literal>と同じであることに注意してください。
   </para>

<!-- IS OF does not conform to the ISO SQL behavior, so it is undocumented here
   <para>
    <indexterm>
     <primary>IS OF</primary>
    </indexterm>
    <indexterm>
     <primary>IS NOT OF</primary>
    </indexterm>
    It is possible to check the data type of an expression using the
    constructs
<synopsis>
<replaceable>expression</replaceable> IS OF (typename, ...)
<replaceable>expression</replaceable> IS NOT OF (typename, ...)
</synopsis>
    They return a boolean value based on whether the expression's data
    type is one of the listed data types.
   </para>
-->

  </sect1>

  <sect1 id="functions-math">
<!--
   <title>Mathematical Functions and Operators</title>
-->
   <title>算術関数と演算子</title>

   <para>
<!--
    Mathematical operators are provided for many
    <productname>PostgreSQL</productname> types. For types without
    standard mathematical conventions
    (e.g., date/time types) we
    describe the actual behavior in subsequent sections.
-->
<productname>PostgreSQL</productname>の数多くの型に対する算術演算子が用意されています。
標準算術表現法に従わない型（例えば、日付/時刻データ型）については、後続する節で実際の動作を説明します。
   </para>

   <para>
<!--
    <xref linkend="functions-math-op-table"> shows the available mathematical operators.
-->
<xref linkend="functions-math-op-table">は使用可能な算術演算子を示しています。
   </para>

   <table id="functions-math-op-table">
<!--
    <title>Mathematical Operators</title>
-->
    <title>算術演算子</title>

    <tgroup cols="4">
     <thead>
      <row>
<!--
       <entry>Operator</entry>
       <entry>Description</entry>
       <entry>Example</entry>
       <entry>Result</entry>
-->
       <entry>演算子名</entry>
       <entry>説明</entry>
       <entry>例</entry>
       <entry>結果</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry> <literal>+</literal> </entry>
<!--
       <entry>addition</entry>
-->
       <entry>和</entry>
       <entry><literal>2 + 3</literal></entry>
       <entry><literal>5</literal></entry>
      </row>

      <row>
       <entry> <literal>-</literal> </entry>
<!--
       <entry>subtraction</entry>
-->
       <entry>差</entry>
       <entry><literal>2 - 3</literal></entry>
       <entry><literal>-1</literal></entry>
      </row>

      <row>
       <entry> <literal>*</literal> </entry>
<!--
       <entry>multiplication</entry>
-->
       <entry>積</entry>
       <entry><literal>2 * 3</literal></entry>
       <entry><literal>6</literal></entry>
      </row>

      <row>
       <entry> <literal>/</literal> </entry>
<!--
       <entry>division (integer division truncates the result)</entry>
-->
       <entry>商（整数の割り算では余りを切り捨て）</entry>
       <entry><literal>4 / 2</literal></entry>
       <entry><literal>2</literal></entry>
      </row>

      <row>
       <entry> <literal>%</literal> </entry>
<!--
       <entry>modulo (remainder)</entry>
-->
       <entry>剰余（余り）</entry>
       <entry><literal>5 % 4</literal></entry>
       <entry><literal>1</literal></entry>
      </row>

      <row>
       <entry> <literal>^</literal> </entry>
<!--
       <entry>exponentiation</entry>
-->
       <entry>累乗</entry>
       <entry><literal>2.0 ^ 3.0</literal></entry>
       <entry><literal>8</literal></entry>
      </row>

      <row>
       <entry> <literal>|/</literal> </entry>
<!--
       <entry>square root</entry>
-->
       <entry>平方根</entry>
       <entry><literal>|/ 25.0</literal></entry>
       <entry><literal>5</literal></entry>
      </row>

      <row>
       <entry> <literal>||/</literal> </entry>
<!--
       <entry>cube root</entry>
-->
       <entry>立方根</entry>
       <entry><literal>||/ 27.0</literal></entry>
       <entry><literal>3</literal></entry>
      </row>

      <row>
       <entry> <literal>!</literal> </entry>
<!--
       <entry>factorial</entry>
-->
       <entry>階乗</entry>
       <entry><literal>5 !</literal></entry>
       <entry><literal>120</literal></entry>
      </row>

      <row>
       <entry> <literal>!!</literal> </entry>
<!--
       <entry>factorial (prefix operator)</entry>
-->
       <entry>階乗（前置演算子）</entry>
       <entry><literal>!! 5</literal></entry>
       <entry><literal>120</literal></entry>
      </row>

      <row>
       <entry> <literal>@</literal> </entry>
<!--
       <entry>absolute value</entry>
-->
       <entry>絶対値</entry>
       <entry><literal>@ -5.0</literal></entry>
       <entry><literal>5</literal></entry>
      </row>

      <row>
       <entry> <literal>&amp;</literal> </entry>
<!--
       <entry>bitwise AND</entry>
-->
       <entry>バイナリのAND</entry>
       <entry><literal>91 &amp; 15</literal></entry>
       <entry><literal>11</literal></entry>
      </row>

      <row>
       <entry> <literal>|</literal> </entry>
<!--
       <entry>bitwise OR</entry>
-->
       <entry>バイナリのOR</entry>
       <entry><literal>32 | 3</literal></entry>
       <entry><literal>35</literal></entry>
      </row>

      <row>
       <entry> <literal>#</literal> </entry>
<!--
       <entry>bitwise XOR</entry>
-->
       <entry>バイナリのXOR</entry>
       <entry><literal>17 # 5</literal></entry>
       <entry><literal>20</literal></entry>
      </row>

      <row>
       <entry> <literal>~</literal> </entry>
<!--
       <entry>bitwise NOT</entry>
-->
       <entry>バイナリのNOT</entry>
       <entry><literal>~1</literal></entry>
       <entry><literal>-2</literal></entry>
      </row>

      <row>
       <entry> <literal>&lt;&lt;</literal> </entry>
<!--
       <entry>bitwise shift left</entry>
-->
       <entry>バイナリの左シフト</entry>
       <entry><literal>1 &lt;&lt; 4</literal></entry>
       <entry><literal>16</literal></entry>
      </row>

      <row>
       <entry> <literal>&gt;&gt;</literal> </entry>
<!--
       <entry>bitwise shift right</entry>
-->
       <entry>バイナリの右シフト</entry>
       <entry><literal>8 &gt;&gt; 2</literal></entry>
       <entry><literal>2</literal></entry>
      </row>

     </tbody>
    </tgroup>
   </table>

   <para>
<!--
    The bitwise operators work only on integral data types, whereas
    the others are available for all numeric data types.  The bitwise
    operators are also available for the bit
    string types <type>bit</type> and <type>bit varying</type>, as
    shown in <xref linkend="functions-bit-string-op-table">.
-->
バイナリ演算子は内部データ型のみに使用できます。一方他の演算子は全ての数値データ型に使用できます。
また、バイナリ演算子は<xref linkend="functions-bit-string-op-table">に示すように、<type>bit</type>、<type>bit varying</type>ビット文字列型に対しても使用することができます。
   </para>

  <para>
<!--
   <xref linkend="functions-math-func-table"> shows the available
   mathematical functions.  In the table, <literal>dp</literal>
   indicates <type>double precision</type>.  Many of these functions
   are provided in multiple forms with different argument types.
   Except where noted, any given form of a function returns the same
   data type as its argument.
   The functions working with <type>double precision</type> data are mostly
   implemented on top of the host system's C library; accuracy and behavior in
   boundary cases can therefore vary depending on the host system.
-->
<xref linkend="functions-math-func-table">に使用可能な算術関数を示します。
この表内の<literal>dp</literal>は、<type>double precision</type>を意味します。
これら関数の多くは、異なる引数型を持つ複数の形で提供されています。
特別な場合を除き、ある任意形式の関数はその引数と同じデータ型を返します。
<type>double precision</type>データに対する関数のほとんどはホストシステムのCライブラリの上層に実装されています。このため、境界近くの場合の精度と振舞いはホストシステムに依存して変わります。
  </para>

   <table id="functions-math-func-table">
<!--
    <title>Mathematical Functions</title>
-->
    <title>算術関数</title>
    <tgroup cols="5">
     <thead>
      <row>
<!--
       <entry>Function</entry>
       <entry>Return Type</entry>
       <entry>Description</entry>
       <entry>Example</entry>
       <entry>Result</entry>
-->
       <entry>関数</entry>
       <entry>戻り値型</entry>
       <entry>説明</entry>
       <entry>例</entry>
       <entry>結果</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry>
        <indexterm>
         <primary>abs</primary>
        </indexterm>
        <literal><function>abs(<replaceable>x</replaceable>)</function></literal>
       </entry>
<!--
       <entry>(same as input)</entry>
-->
       <entry>（入力と同じ）</entry>
<!--
       <entry>absolute value</entry>
-->
       <entry>絶対値</entry>
       <entry><literal>abs(-17.4)</literal></entry>
       <entry><literal>17.4</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>cbrt</primary>
        </indexterm>
        <literal><function>cbrt(<type>dp</type>)</function></literal>
       </entry>
       <entry><type>dp</type></entry>
<!--
       <entry>cube root</entry>
-->
       <entry>立方根</entry>
       <entry><literal>cbrt(27.0)</literal></entry>
       <entry><literal>3</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>ceil</primary>
        </indexterm>
        <literal><function>ceil(<type>dp</type> or <type>numeric</type>)</function></literal>
       </entry>
<!--
       <entry>(same as input)</entry>
-->
       <entry>（入力型と同一）</entry>
<!--
       <entry>smallest integer not less than argument</entry>
-->
       <entry>引数より小さくない最小の整数</entry>
       <entry><literal>ceil(-42.8)</literal></entry>
       <entry><literal>-42</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>ceiling</primary>
        </indexterm>
        <literal><function>ceiling(<type>dp</type> or <type>numeric</type>)</function></literal>
       </entry>
<!--
       <entry>(same as input)</entry>
-->
       <entry>（入力型と同一）</entry>
<!--
       <entry>smallest integer not less than argument (alias for <function>ceil</function>)</entry>
-->
       <entry>引数より小さくない最小の整数（<function>ceil</function>の別名）</entry>
       <entry><literal>ceiling(-95.3)</literal></entry>
       <entry><literal>-95</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>degrees</primary>
        </indexterm>
        <literal><function>degrees(<type>dp</type>)</function></literal>
       </entry>
       <entry><type>dp</type></entry>
<!--
       <entry>radians to degrees</entry>
-->
       <entry>ラジアンに対応する度</entry>
       <entry><literal>degrees(0.5)</literal></entry>
       <entry><literal>28.6478897565412</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>div</primary>
        </indexterm>
        <literal><function>div(<parameter>y</parameter> <type>numeric</>,
         <parameter>x</parameter> <type>numeric</>)</function></literal>
       </entry>
       <entry><type>numeric</></entry>
<!--
       <entry>integer quotient of <parameter>y</parameter>/<parameter>x</parameter></entry>
-->
       <entry><parameter>y</parameter>/<parameter>x</parameter>の整数商</entry>
       <entry><literal>div(9,4)</literal></entry>
       <entry><literal>2</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>exp</primary>
        </indexterm>
        <literal><function>exp(<type>dp</type> or <type>numeric</type>)</function></literal>
       </entry>
<!--
       <entry>(same as input)</entry>
-->
       <entry>（入力型と同一）</entry>
<!--
       <entry>exponential</entry>
-->
       <entry>指数</entry>
       <entry><literal>exp(1.0)</literal></entry>
       <entry><literal>2.71828182845905</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>floor</primary>
        </indexterm>
        <literal><function>floor(<type>dp</type> or <type>numeric</type>)</function></literal>
       </entry>
<!--
       <entry>(same as input)</entry>
-->
       <entry>（入力型と同一）</entry>
<!--
       <entry>largest integer not greater than argument</entry>
-->
       <entry>引数より大きくない最大の整数</entry>
       <entry><literal>floor(-42.8)</literal></entry>
       <entry><literal>-43</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>ln</primary>
        </indexterm>
        <literal><function>ln(<type>dp</type> or <type>numeric</type>)</function></literal>
       </entry>
<!--
       <entry>(same as input)</entry>
-->
       <entry>（入力型と同一）</entry>
<!--
       <entry>natural logarithm</entry>
-->
       <entry>自然対数</entry>
       <entry><literal>ln(2.0)</literal></entry>
       <entry><literal>0.693147180559945</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>log</primary>
        </indexterm>
        <literal><function>log(<type>dp</type> or <type>numeric</type>)</function></literal>
       </entry>
<!--
       <entry>(same as input)</entry>
-->
       <entry>（入力型と同一）</entry>
<!--
       <entry>base 10 logarithm</entry>
-->
       <entry>10を底とした対数（常用対数）</entry>
       <entry><literal>log(100.0)</literal></entry>
       <entry><literal>2</literal></entry>
      </row>

      <row>
       <entry><literal><function>log(<parameter>b</parameter> <type>numeric</type>,
        <parameter>x</parameter> <type>numeric</type>)</function></literal></entry>
       <entry><type>numeric</type></entry>
<!--
       <entry>logarithm to base <parameter>b</parameter></entry>
-->
       <entry><parameter>b</parameter>を底とした対数</entry>
       <entry><literal>log(2.0, 64.0)</literal></entry>
       <entry><literal>6.0000000000</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>mod</primary>
        </indexterm>
        <literal><function>mod(<parameter>y</parameter>,
         <parameter>x</parameter>)</function></literal>
       </entry>
<!--
       <entry>(same as argument types)</entry>
-->
       <entry>（引数の型と同一）</entry>
<!--
       <entry>remainder of <parameter>y</parameter>/<parameter>x</parameter></entry>
-->
       <entry><parameter>y</parameter>/<parameter>x</parameter>の剰余</entry>
       <entry><literal>mod(9,4)</literal></entry>
       <entry><literal>1</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>pi</primary>
        </indexterm>
        <literal><function>pi()</function></literal>
       </entry>
       <entry><type>dp</type></entry>
<!--
       <entry><quote>&pi;</quote> constant</entry>
-->
       <entry><quote>円周率（π）</quote>定数</entry>
       <entry><literal>pi()</literal></entry>
       <entry><literal>3.14159265358979</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>power</primary>
        </indexterm>
        <literal><function>power(<parameter>a</parameter> <type>dp</type>,
        <parameter>b</parameter> <type>dp</type>)</function></literal>
       </entry>
       <entry><type>dp</type></entry>
<!--
       <entry><parameter>a</> raised to the power of <parameter>b</parameter></entry>
-->
       <entry><parameter>a</>の<parameter>b</parameter>乗</entry>
       <entry><literal>power(9.0, 3.0)</literal></entry>
       <entry><literal>729</literal></entry>
      </row>

      <row>
       <entry><literal><function>power(<parameter>a</parameter> <type>numeric</type>,
        <parameter>b</parameter> <type>numeric</type>)</function></literal></entry>
       <entry><type>numeric</type></entry>
<!--
       <entry><parameter>a</> raised to the power of <parameter>b</parameter></entry>
-->
       <entry><parameter>a</>の<parameter>b</parameter>乗</entry>
       <entry><literal>power(9.0, 3.0)</literal></entry>
       <entry><literal>729</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>radians</primary>
        </indexterm>
        <literal><function>radians(<type>dp</type>)</function></literal>
       </entry>
       <entry><type>dp</type></entry>
<!--
       <entry>degrees to radians</entry>
-->
       <entry>度に対応するラジアン</entry>
       <entry><literal>radians(45.0)</literal></entry>
       <entry><literal>0.785398163397448</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>round</primary>
        </indexterm>
        <literal><function>round(<type>dp</type> or <type>numeric</type>)</function></literal>
       </entry>
<!--
       <entry>(same as input)</entry>
-->
       <entry>（入力型と同一）</entry>
<!--
       <entry>round to nearest integer</entry>
-->
       <entry>四捨五入</entry>
       <entry><literal>round(42.4)</literal></entry>
       <entry><literal>42</literal></entry>
      </row>

      <row>
       <entry><literal><function>round(<parameter>v</parameter> <type>numeric</type>, <parameter>s</parameter> <type>int</type>)</function></literal></entry>
       <entry><type>numeric</type></entry>
<!--
       <entry>round to <parameter>s</parameter> decimal places</entry>
-->
       <entry>小数点<parameter>s</parameter>の位まで四捨五入して切捨て</entry>
       <entry><literal>round(42.4382, 2)</literal></entry>
       <entry><literal>42.44</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>sign</primary>
        </indexterm>
        <literal><function>sign(<type>dp</type> or <type>numeric</type>)</function></literal>
       </entry>
<!--
       <entry>(same as input)</entry>
-->
       <entry>（入力型と同一）</entry>
<!--
       <entry>sign of the argument (-1, 0, +1)</entry>
-->
       <entry>引数の符号（-1、0、+1）</entry>
       <entry><literal>sign(-8.4)</literal></entry>
       <entry><literal>-1</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>sqrt</primary>
        </indexterm>
        <literal><function>sqrt(<type>dp</type> or <type>numeric</type>)</function></literal>
       </entry>
<!--
       <entry>(same as input)</entry>
-->
       <entry>（入力型と同一）</entry>
<!--
       <entry>square root</entry>
-->
       <entry>平方根</entry>
       <entry><literal>sqrt(2.0)</literal></entry>
       <entry><literal>1.4142135623731</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>trunc</primary>
        </indexterm>
        <literal><function>trunc(<type>dp</type> or <type>numeric</type>)</function></literal>
       </entry>
<!--
       <entry>(same as input)</entry>
-->
       <entry>（入力型と同一）</entry>
<!--
       <entry>truncate toward zero</entry>
-->
       <entry>切り捨て</entry>
       <entry><literal>trunc(42.8)</literal></entry>
       <entry><literal>42</literal></entry>
      </row>

      <row>
       <entry><literal><function>trunc(<parameter>v</parameter> <type>numeric</type>, <parameter>s</parameter> <type>int</type>)</function></literal></entry>
       <entry><type>numeric</type></entry>
<!--
       <entry>truncate to <parameter>s</parameter> decimal places</entry>
-->
       <entry><parameter>s</parameter>の桁で切り捨て</entry>
       <entry><literal>trunc(42.4382, 2)</literal></entry>
       <entry><literal>42.43</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>width_bucket</primary>
        </indexterm>
        <literal><function>width_bucket(<parameter>op</parameter> <type>numeric</type>, <parameter>b1</parameter> <type>numeric</type>, <parameter>b2</parameter> <type>numeric</type>, <parameter>count</parameter> <type>int</type>)</function></literal>
       </entry>
       <entry><type>int</type></entry>
<!--
       <entry>return the bucket to which <parameter>operand</> would
       be assigned in an equidepth histogram with <parameter>count</>
       buckets, in the range <parameter>b1</> to <parameter>b2</></entry>
-->
       <entry><parameter>operand</>が割り当てられる、<parameter>b1</>から<parameter>b2</>までのバケット数<parameter>count</>の等深度ヒストグラムのバケットを返す</entry>
       <entry><literal>width_bucket(5.35, 0.024, 10.06, 5)</literal></entry>
       <entry><literal>3</literal></entry>
      </row>

      <row>
       <entry><literal><function>width_bucket(<parameter>op</parameter> <type>dp</type>, <parameter>b1</parameter> <type>dp</type>, <parameter>b2</parameter> <type>dp</type>, <parameter>count</parameter> <type>int</type>)</function></literal></entry>
       <entry><type>int</type></entry>
<!--
       <entry>return the bucket to which <parameter>operand</> would
       be assigned in an equidepth histogram with <parameter>count</>
       buckets, in the range <parameter>b1</> to <parameter>b2</></entry>
-->
       <entry>
       <parameter>operand</>が割り当てられる、<parameter>b1</>から<parameter>b2</>までのバケット数<parameter>count</>の等深度ヒストグラムのバケットを返す
       </entry>
       <entry><literal>width_bucket(5.35, 0.024, 10.06, 5)</literal></entry>
       <entry><literal>3</literal></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <para>
<!--
    <xref linkend="functions-math-random-table"> shows functions for
    generating random numbers.
-->
<xref linkend="functions-math-random-table">に乱数を生成する関数を示します。
  </para>

   <table id="functions-math-random-table">
<!--
    <title>Random Functions</title>
-->
    <title>乱数関数</title>

    <tgroup cols="3">
     <thead>
      <row>
<!--
       <entry>Function</entry>
       <entry>Return Type</entry>
       <entry>Description</entry>
-->
       <entry>関数</entry>
       <entry>戻り値型</entry>
       <entry>説明</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>
        <indexterm>
         <primary>random</primary>
        </indexterm>
        <literal><function>random()</function></literal>
       </entry>
       <entry><type>dp</type></entry>
<!--
       <entry>random value in the range 0.0 &lt;= x &lt; 1.0</entry>
-->
       <entry>0.0 &lt;= x &lt; 1.0の範囲の乱数値</entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>setseed</primary>
        </indexterm>
        <literal><function>setseed(<type>dp</type>)</function></literal>
       </entry>
       <entry><type>void</type></entry>
<!--
       <entry>set seed for subsequent <literal>random()</literal> calls (value between -1.0 and
       1.0, inclusive)</entry>
-->
       <entry>今後の<literal>random()</literal>呼び出しで使用されるシード(種)の設定（-1.0から1.0までの境界を含む値）</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <para>
<!--
   The characteristics of the values returned by
   <literal><function>random()</function></literal> depend
   on the system implementation. It is not suitable for cryptographic
   applications; see <xref linkend="pgcrypto"> module for an alternative.
-->
<literal><function>random()</function></literal>が返す値の特徴はシステムの実装に依存します。
暗号への利用は適していません。代わりに<xref linkend="pgcrypto">モジュールを参照してください。
   </para>

  <para>
<!--
   Finally, <xref linkend="functions-math-trig-table"> shows the
   available trigonometric functions.  All trigonometric functions
   take arguments and return values of type <type>double
   precision</type>. Trigonometric functions arguments are expressed
   in radians. Inverse functions return values are expressed in
   radians.  See unit transformation functions
   <literal><function>radians()</function></literal> and
   <literal><function>degrees()</function></literal> above.
-->
最後に、使用可能な三角関数を<xref linkend="functions-math-trig-table">に示します。
全ての三角関数は<type>double precision</type>データ型の引数と戻り値を取ります。
三角関数の引数はラジアンで表されます。
逆関数の返り値はラジアンで表されます。
上記の<literal><function>radians</function>()</literal>と<literal><function>degrees</function>()</literal>といった単位変換関数を参照して下さい。
  </para>

   <table id="functions-math-trig-table">
<!--
    <title>Trigonometric Functions</title>
-->
    <title>三角関数</title>

    <tgroup cols="2">
     <thead>
      <row>
<!--
       <entry>Function</entry>
       <entry>Description</entry>
-->
       <entry>関数</entry>
       <entry>説明</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry>
        <indexterm>
         <primary>acos</primary>
        </indexterm><literal><function>acos(<replaceable>x</replaceable>)</function></literal>
       </entry>
<!--
       <entry>inverse cosine</entry>
-->
       <entry>逆余弦関数</entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>asin</primary>
        </indexterm>
        <literal><function>asin(<replaceable>x</replaceable>)</function></literal>
       </entry>
<!--
       <entry>inverse sine</entry>
-->
       <entry>逆正弦関数</entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>atan</primary>
        </indexterm>
        <literal><function>atan(<replaceable>x</replaceable>)</function></literal>
       </entry>
<!--
       <entry>inverse tangent</entry>
-->
       <entry>逆正接関数</entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>atan2</primary>
        </indexterm>
        <literal><function>atan2(<replaceable>y</replaceable>,
        <replaceable>x</replaceable>)</function></literal>
       </entry>
<!--
       <entry>inverse tangent of
        <literal><replaceable>y</replaceable>/<replaceable>x</replaceable></literal></entry>
-->
       <entry>
        <literal><replaceable>y</replaceable>/<replaceable>x</replaceable></literal>の逆正接関数
       </entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>cos</primary>
        </indexterm>
        <literal><function>cos(<replaceable>x</replaceable>)</function></literal>
       </entry>
<!--
       <entry>cosine</entry>
-->
       <entry>余弦関数</entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>cot</primary>
        </indexterm>
        <literal><function>cot(<replaceable>x</replaceable>)</function></literal>
       </entry>
<!--
       <entry>cotangent</entry>
-->
       <entry>余接関数</entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>sin</primary>
        </indexterm>
        <literal><function>sin(<replaceable>x</replaceable>)</function></literal>
       </entry>
<!--
       <entry>sine</entry>
-->
       <entry>正弦関数</entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>tan</primary>
        </indexterm>
        <literal><function>tan(<replaceable>x</replaceable>)</function></literal>
       </entry>
<!--
       <entry>tangent</entry>
-->
       <entry>正接関数</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  </sect1>


  <sect1 id="functions-string">
<!--
   <title>String Functions and Operators</title>
-->
   <title>文字列関数と演算子</title>

   <para>
<!--
    This section describes functions and operators for examining and
    manipulating string values.  Strings in this context include values
    of the types <type>character</type>, <type>character varying</type>,
    and <type>text</type>.  Unless otherwise noted, all
    of the functions listed below work on all of these types, but be
    wary of potential effects of automatic space-padding when using the
    <type>character</type> type.  Some functions also exist
    natively for the bit-string types.
-->
本節では文字列の値の調査や操作のための関数と演算子について説明します。
ここでの文字列とは<type>character</type>データ型、<type>character varying</type>データ型、および<type>text</type>データ型の値を含みます。
補足説明のない限り、下記に挙げている全ての関数はこれら全てのデータ型に対して使用できますが、<type>character</type>データ型を使用した場合、自動的に空白文字がパッドされるという潜在的作用がありますので注意してください。
バイナリ列データ型に対してもともとから存在するいくつかの関数もあります。
   </para>

   <para>
<!--
    <acronym>SQL</acronym> defines some string functions that use
    key words, rather than commas, to separate
    arguments.  Details are in
    <xref linkend="functions-string-sql">.
    <productname>PostgreSQL</> also provides versions of these functions
    that use the regular function invocation syntax
    (see <xref linkend="functions-string-other">).
-->
<acronym>SQL</acronym>では引数の区切りにカンマではなくキーワードを使用する文字列関数をいくつか定義しています。
詳細については<xref linkend="functions-string-sql">を参照してください。
また<productname>PostgreSQL</>は、これらの関数に対して通常の関数呼び出し構文を使用するバージョンを提供します（<xref linkend="functions-string-other">を参照してください）。
   </para>

   <note>
    <para>
<!--
     Before <productname>PostgreSQL</productname> 8.3, these functions would
     silently accept values of several non-string data types as well, due to
     the presence of implicit coercions from those data types to
     <type>text</>.  Those coercions have been removed because they frequently
     caused surprising behaviors.  However, the string concatenation operator
     (<literal>||</>) still accepts non-string input, so long as at least one
     input is of a string type, as shown in <xref
     linkend="functions-string-sql">.  For other cases, insert an explicit
     coercion to <type>text</> if you need to duplicate the previous behavior.
-->
<productname>PostgreSQL</productname> 8.3以前において、これらの関数はいくつかの非文字列データ型の値を警告なしに受け付けたのは、それらデータ型を暗黙的に<type>text</>型に型変換していたことによります。
この強制的な変換は、頻繁に予期しない動作の原因となったので削除されました。
しかし、文字列連結演算子（<literal>||</>）は<xref linkend="functions-string-sql">で示されるように、少なくともひとつの入力が文字列型であれば、依然として非文字列入力を受け付けます。
その他の場合、以前と同じ動作を期待するのなら、<type>text</>への明示的な変換を行ってください。
    </para>
   </note>

   <table id="functions-string-sql">
<!--
    <title><acronym>SQL</acronym> String Functions and Operators</title>
-->
    <title><acronym>SQL</acronym>文字列関数と演算子</title>
    <tgroup cols="5">
     <thead>
      <row>
<!--
       <entry>Function</entry>
       <entry>Return Type</entry>
       <entry>Description</entry>
       <entry>Example</entry>
       <entry>Result</entry>
-->
       <entry>関数</entry>
       <entry>戻り値型</entry>
       <entry>説明</entry>
       <entry>例</entry>
       <entry>結果</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry><literal><parameter>string</parameter> <literal>||</literal>
        <parameter>string</parameter></literal></entry>
       <entry> <type>text</type> </entry>
       <entry>
<!--
        String concatenation
-->
        文字列結合
        <indexterm>
<!--
         <primary>character string</primary>
         <secondary>concatenation</secondary>
-->
         <primary>文字列</primary>
         <secondary>結合</secondary>
        </indexterm>
       </entry>
       <entry><literal>'Post' || 'greSQL'</literal></entry>
       <entry><literal>PostgreSQL</literal></entry>
      </row>

      <row>
       <entry>
<!--
        <literal><parameter>string</parameter> <literal>||</literal>
        <parameter>non-string</parameter></literal>
        or
        <literal><parameter>non-string</parameter> <literal>||</literal>
        <parameter>string</parameter></literal>
-->
        <literal><parameter>文字列</parameter> <literal>||</literal>
        <parameter>非文字列</parameter></literal>
        または、
        <literal><parameter>非文字列</parameter> <literal>||</literal>
        <parameter>文字列</parameter></literal>
       </entry>
       <entry> <type>text</type> </entry>
       <entry>
<!--
        String concatenation with one non-string input
-->
        ひとつの非文字列のある入力の文字列結合
       </entry>
       <entry><literal>'Value: ' || 42</literal></entry>
       <entry><literal>Value: 42</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>bit_length</primary>
        </indexterm>
        <literal><function>bit_length(<parameter>string</parameter>)</function></literal>
       </entry>
       <entry><type>int</type></entry>
<!--
       <entry>Number of bits in string</entry>
-->
       <entry>文字列中のビット数</entry>
       <entry><literal>bit_length('jose')</literal></entry>
       <entry><literal>32</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>char_length</primary>
        </indexterm>
<!--
        <literal><function>char_length(<parameter>string</parameter>)</function></literal> or <literal><function>character_length(<parameter>string</parameter>)</function></literal>
-->
        <literal><function>char_length(<parameter>string</parameter>)</function></literal> または <literal><function>character_length(<parameter>string</parameter>)</function></literal>
       </entry>
       <entry><type>int</type></entry>
       <entry>
<!--
        Number of characters in string
-->
        文字列中の文字数
        <indexterm>
<!--
         <primary>character string</primary>
         <secondary>length</secondary>
-->
         <primary>文字列</primary>
         <secondary>長さ</secondary>
        </indexterm>
        <indexterm>
<!--
         <primary>length</primary>
         <secondary sortas="character string">of a character string</secondary>
         <see>character string, length</see>
-->
         <primary>長さ</primary>
         <secondary sortas="character string">文字列の</secondary>
         <see>文字列、長さ</see>
        </indexterm>
       </entry>
       <entry><literal>char_length('jose')</literal></entry>
       <entry><literal>4</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>lower</primary>
        </indexterm>
        <literal><function>lower(<parameter>string</parameter>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
<!--
       <entry>Convert string to lower case</entry>
-->
       <entry>文字列を小文字に変換</entry>
       <entry><literal>lower('TOM')</literal></entry>
       <entry><literal>tom</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>octet_length</primary>
        </indexterm>
        <literal><function>octet_length(<parameter>string</parameter>)</function></literal>
       </entry>
       <entry><type>int</type></entry>
<!--
       <entry>Number of bytes in string</entry>
-->
       <entry>文字列中のバイト数</entry>
       <entry><literal>octet_length('jose')</literal></entry>
       <entry><literal>4</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>overlay</primary>
        </indexterm>
        <literal><function>overlay(<parameter>string</parameter> placing <parameter>string</parameter> from <type>int</type> <optional>for <type>int</type></optional>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
<!--
        Replace substring
-->
        部分文字列の置換
       </entry>
       <entry><literal>overlay('Txxxxas' placing 'hom' from 2 for 4)</literal></entry>
       <entry><literal>Thomas</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>position</primary>
        </indexterm>
        <literal><function>position(<parameter>substring</parameter> in <parameter>string</parameter>)</function></literal>
       </entry>
       <entry><type>int</type></entry>
<!--
       <entry>Location of specified substring</entry>
-->
       <entry>指定した部分文字列の場所</entry>
       <entry><literal>position('om' in 'Thomas')</literal></entry>
       <entry><literal>3</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>substring</primary>
        </indexterm>
        <literal><function>substring(<parameter>string</parameter> <optional>from <type>int</type></optional> <optional>for <type>int</type></optional>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
<!--
        Extract substring
-->
        部分文字列の取り出し
       </entry>
       <entry><literal>substring('Thomas' from 2 for 3)</literal></entry>
       <entry><literal>hom</literal></entry>
      </row>

      <row>
       <entry><literal><function>substring(<parameter>string</parameter> from <replaceable>pattern</replaceable>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>
<!--
        Extract substring matching POSIX regular expression. See
        <xref linkend="functions-matching"> for more information on pattern
        matching.
-->
POSIX正規表現に一致する副文字列を取り出します。
パターンマッチに関してより詳細は、<xref linkend="functions-matching">を参照してください。
       </entry>
       <entry><literal>substring('Thomas' from '...$')</literal></entry>
       <entry><literal>mas</literal></entry>
      </row>

      <row>
       <entry><literal><function>substring(<parameter>string</parameter> from <replaceable>pattern</replaceable> for <replaceable>escape</replaceable>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>
<!--
        Extract substring matching <acronym>SQL</acronym> regular expression.
        See <xref linkend="functions-matching"> for more information on
        pattern matching.
-->
<acronym>SQL</acronym>正規表現に一致する部分文字列を取り出します。
パターンマッチに関してより詳細は、<xref linkend="functions-matching">を参照してください。
       </entry>
       <entry><literal>substring('Thomas' from '%#"o_a#"_' for '#')</literal></entry>
       <entry><literal>oma</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>trim</primary>
        </indexterm>
        <literal><function>trim(<optional>leading | trailing | both</optional>
        <optional><parameter>characters</parameter></optional> from
        <parameter>string</parameter>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
<!--
        Remove the longest string containing only the
        <parameter>characters</parameter> (a space by default) from the
        start/end/both ends of the <parameter>string</parameter>
-->
<parameter>characters</parameter>（デフォルトでは空白）で指定された文字のみを含む最も長い文字列を、<parameter>string</parameter>の先頭、末尾、そしてその両方から削除します。
       </entry>
       <entry><literal>trim(both 'x' from 'xTomxx')</literal></entry>
       <entry><literal>Tom</literal></entry>
      </row>

      <row>
       <entry>
        <literal><function>trim(<optional>leading | trailing
        | both</optional> <optional>from</optional>
        <parameter>string</parameter>
        <optional><parameter>, characters</parameter></optional>
        )</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
<!--
        Non-standard version of <function>trim()</>
-->
        <function>trim()</>の非標準版
       </entry>
       <entry><literal>trim(both from 'xTomxx', 'x')</literal></entry>
       <entry><literal>Tom</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>upper</primary>
        </indexterm>
        <literal><function>upper(<parameter>string</parameter>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
<!--
       <entry>Convert string to upper case</entry>
-->
       <entry>文字列を大文字に変換</entry>
       <entry><literal>upper('tom')</literal></entry>
       <entry><literal>TOM</literal></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
<!--
    Additional string manipulation functions are available and are
    listed in <xref linkend="functions-string-other">.  Some of them are used internally to implement the
    <acronym>SQL</acronym>-standard string functions listed in <xref linkend="functions-string-sql">.
-->
この他、<xref linkend="functions-string-other">に列挙する文字列操作関数が使えます。
そのいくつかは、<xref linkend="functions-string-sql">で一覧した標準<acronym>SQL</acronym>の文字列関数を実装するため、内部的に使用されます。
   </para>

   <table id="functions-string-other">
<!--
    <title>Other String Functions</title>
-->
    <title>その他の文字列関数</title>
    <tgroup cols="5">
     <thead>
      <row>
<!--
       <entry>Function</entry>
       <entry>Return Type</entry>
       <entry>Description</entry>
       <entry>Example</entry>
       <entry>Result</entry>
-->
       <entry>関数</entry>
       <entry>戻り値型</entry>
       <entry>説明</entry>
       <entry>例</entry>
       <entry>結果</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry>
        <indexterm>
         <primary>ascii</primary>
        </indexterm>
        <literal><function>ascii(<parameter>string</parameter>)</function></literal>
       </entry>
       <entry><type>int</type></entry>
       <entry>
<!--
        <acronym>ASCII</acronym> code of the first character of the
        argument.  For <acronym>UTF8</acronym> returns the Unicode code
        point of the character.  For other multibyte encodings, the
        argument must be an <acronym>ASCII</acronym> character.
-->
引数の最初の文字の<acronym>ASCII</acronym>コード。
<acronym>UTF8</acronym>に対しては文字のUnicodeコードポイントを返します。
その他のマルチバイト符号化方式の場合、引数は<acronym>ASCII</acronym>文字でなくてはなりません。
       </entry>
       <entry><literal>ascii('x')</literal></entry>
       <entry><literal>120</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>btrim</primary>
        </indexterm>
        <literal><function>btrim(<parameter>string</parameter> <type>text</type>
        <optional>, <parameter>characters</parameter> <type>text</type></optional>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
<!--
        Remove the longest string consisting only of characters
        in <parameter>characters</parameter> (a space by default)
        from the start and end of <parameter>string</parameter>
-->
<parameter>characters</parameter>（デフォルトは空白文字）で指定された文字のみを有する最長の文字列を、<parameter>string</parameter>の先頭と末尾から削除します。
       </entry>
       <entry><literal>btrim('xyxtrimyyx', 'xy')</literal></entry>
       <entry><literal>trim</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>chr</primary>
        </indexterm>
        <literal><function>chr(<type>int</type>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
<!--
        Character with the given code. For <acronym>UTF8</acronym> the
        argument is treated as a Unicode code point. For other multibyte
        encodings the argument must designate an
        <acronym>ASCII</acronym> character.  The NULL (0) character is not
        allowed because text data types cannot store such bytes.
-->
与えられたコードの文字。<acronym>UTF8</acronym>では引数はUnicodeコードポイントとして扱われます。
その他のマルチバイト符号化方式で引数は<acronym>ASCII</acronym>文字である必要があります。
NULL (0)文字はテキストデータ型がそのようなバイトを格納することができないので許可されません。
       </entry>
       <entry><literal>chr(65)</literal></entry>
       <entry><literal>A</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>concat</primary>
        </indexterm>
        <literal><function>concat(<parameter>str</parameter> <type>"any"</type>
         [, <parameter>str</parameter> <type>"any"</type> [, ...] ])</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
<!--
        Concatenate the text representations of all the arguments.
        NULL arguments are ignored.
-->
        すべての引数のテキスト表現の結合。ただしNULLは無視される。
       </entry>
       <entry><literal>concat('abcde', 2, NULL, 22)</literal></entry>
       <entry><literal>abcde222</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>concat_ws</primary>
        </indexterm>
        <literal><function>concat_ws(<parameter>sep</parameter> <type>text</type>,
        <parameter>str</parameter> <type>"any"</type>
        [, <parameter>str</parameter> <type>"any"</type> [, ...] ])</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
<!--
        Concatenate all but the first argument with separators. The first
        argument is used as the separator string. NULL arguments are ignored.
-->
第一引数を区切り文字とし、残りのすべての引数を結合する。
最初の引数は区切り文字列として使われる。
NULLは無視される。
       </entry>
       <entry><literal>concat_ws(',', 'abcde', 2, NULL, 22)</literal></entry>
       <entry><literal>abcde,2,22</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>convert</primary>
        </indexterm>
        <literal><function>convert(<parameter>string</parameter> <type>bytea</type>,
        <parameter>src_encoding</parameter> <type>name</type>,
        <parameter>dest_encoding</parameter> <type>name</type>)</function></literal>
       </entry>
       <entry><type>bytea</type></entry>
       <entry>
<!--
        Convert string to <parameter>dest_encoding</parameter>.  The
        original encoding is specified by
        <parameter>src_encoding</parameter>. The
        <parameter>string</parameter> must be valid in this encoding.
        Conversions can be defined by <command>CREATE CONVERSION</command>.
        Also there are some predefined conversions. See <xref
        linkend="conversion-names"> for available conversions.
-->
文字列を<parameter>dest_encoding</parameter>に変換します。
元の符号化方式は<parameter>src_encoding</parameter>で指定されます。
<parameter>string</parameter>はこの符号化方式で有効でなければなりません。
変換は<command>CREATE CONVERSION</command>で定義されます。
また、あらかじめ定義された変換もあります。
有効な変換については<xref linkend="conversion-names">を参照してください。
       </entry>
       <entry><literal>convert('text_in_utf8', 'UTF8', 'LATIN1')</literal></entry>
<!--
       <entry><literal>text_in_utf8</literal> represented in Latin-1
       encoding (ISO 8859-1)</entry>
-->
       <entry>Latin-1（ISO 8859-1）符号化方式の<literal>text_in_utf8</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>convert_from</primary>
        </indexterm>
        <literal><function>convert_from(<parameter>string</parameter> <type>bytea</type>,
        <parameter>src_encoding</parameter> <type>name</type>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
<!--
        Convert string to the database encoding.  The original encoding
        is specified by <parameter>src_encoding</parameter>. The
        <parameter>string</parameter> must be valid in this encoding.
-->
データベースの符号化方式に文字列を変換します。
元の符号化方式は<parameter>src_encoding</parameter>で指定されます。
<parameter>string</parameter>はこの符号化方式で有効なものでなければなりません。
       </entry>
       <entry><literal>convert_from('text_in_utf8', 'UTF8')</literal></entry>
<!--
       <entry><literal>text_in_utf8</literal> represented in the current database encoding</entry>
-->
       <entry>現在のデータベース符号化方式の<literal>text_in_utf8</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>convert_to</primary>
        </indexterm>
        <literal><function>convert_to(<parameter>string</parameter> <type>text</type>,
        <parameter>dest_encoding</parameter> <type>name</type>)</function></literal>
       </entry>
       <entry><type>bytea</type></entry>
       <entry>
<!--
        Convert string to <parameter>dest_encoding</parameter>.
-->
        文字列を<parameter>dest_encoding</parameter>に変換します。
       </entry>
       <entry><literal>convert_to('some text', 'UTF8')</literal></entry>
<!--
       <entry><literal>some text</literal> represented in the UTF8 encoding</entry>
-->
       <entry>UTF8符号化方式の<literal>some text</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>decode</primary>
        </indexterm>
        <literal><function>decode(<parameter>string</parameter> <type>text</type>,
        <parameter>format</parameter> <type>text</type>)</function></literal>
       </entry>
       <entry><type>bytea</type></entry>
       <entry>
<!--
        Decode binary data from textual representation in <parameter>string</>.
        Options for <parameter>format</> are same as in <function>encode</>.
-->
<parameter>string</parameter>からバイナリデータを復号します。
オプションの<parameter>format</>は<function>encode()</>と同じです。
       </entry>
       <entry><literal>decode('MTIzAAE=', 'base64')</literal></entry>
       <entry><literal>\x3132330001</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>encode</primary>
        </indexterm>
        <literal><function>encode(<parameter>data</parameter> <type>bytea</type>,
        <parameter>format</parameter> <type>text</type>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
<!--
        Encode binary data into a textual representation.  Supported
        formats are: <literal>base64</>, <literal>hex</>, <literal>escape</>.
        <literal>escape</> converts zero bytes and high-bit-set bytes to
        octal sequences (<literal>\</><replaceable>nnn</>) and
        doubles backslashes.
-->
バイナリデータをテキスト表現形式に符号化します。
サポートされている形式は、<literal>base64</>、<literal>hex</>、<literal>escape</>です。
<literal>escape</>は0バイトと最上位ビットがセットされているバイトを8進数のシーケンス(<literal>\</><replaceable>nnn</>)に変換し 、バックスラッシュを二重化します。
       </entry>
       <entry><literal>encode(E'123\\000\\001', 'base64')</literal></entry>
       <entry><literal>MTIzAAE=</literal></entry>
      </row>

      <row>
       <entry id="format">
        <indexterm>
         <primary>format</primary>
        </indexterm>
        <literal><function>format</function>(<parameter>formatstr</parameter> <type>text</type>
        [, <parameter>formatarg</parameter> <type>"any"</type> [, ...] ])</literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
<!--
         Format arguments according to a format string.
         This function is similar to the C function <function>sprintf</>.
         See <xref linkend="functions-string-format">.
-->
引数の書式をフォーマット文字列に従って整えます。
この関数はC言語関数の<function>sprintf</>と似ています。
<xref linkend="functions-string-format">を参照してください。
       </entry>
       <entry><literal>format('Hello %s, %1$s', 'World')</literal></entry>
       <entry><literal>Hello World, World</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>initcap</primary>
        </indexterm>
        <literal><function>initcap(<parameter>string</parameter>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
<!--
        Convert the first letter of each word to upper case and the
        rest to lower case. Words are sequences of alphanumeric
        characters separated by non-alphanumeric characters.
-->
それぞれの単語の第一文字を大文字にし、残りは小文字のまま残します。
ここで単語とは、英数字以外の文字で区切られた、英数字からなる文字の並びのことです。
       </entry>
       <entry><literal>initcap('hi THOMAS')</literal></entry>
       <entry><literal>Hi Thomas</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>left</primary>
        </indexterm>
        <literal><function>left(<parameter>str</parameter> <type>text</type>,
        <parameter>n</parameter> <type>int</type>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
<!--
        Return first <replaceable>n</> characters in the string. When <replaceable>n</>
        is negative, return all but last |<replaceable>n</>| characters.
-->
文字列の先頭から<replaceable>n</>文字を返します。
<replaceable>n</>が負数の場合、|<replaceable>n</>|の数だけ文字列の末尾から切り取った文字列を返します。
       </entry>
       <entry><literal>left('abcde', 2)</literal></entry>
       <entry><literal>ab</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>length</primary>
        </indexterm>
        <literal><function>length(<parameter>string</parameter>)</function></literal>
       </entry>
       <entry><type>int</type></entry>
       <entry>
<!--
        Number of characters in <parameter>string</parameter>
-->
        <parameter>string</parameter>内の文字数
       </entry>
       <entry><literal>length('jose')</literal></entry>
       <entry><literal>4</literal></entry>
      </row>

      <row>
       <entry><literal><function>length(<parameter>string</parameter> <type>bytea</type>,
        <parameter>encoding</parameter> <type>name</type> )</function></literal></entry>
       <entry><type>int</type></entry>
       <entry>
<!--
        Number of characters in <parameter>string</parameter> in the given
        <parameter>encoding</parameter>. The <parameter>string</parameter>
        must be valid in this encoding.
-->
与えられた<parameter>encoding</parameter>での<parameter>string</parameter>内の文字数。
<parameter>string</parameter>はこの符号化方式で有効でなければなりません。
       </entry>
       <entry><literal>length('jose', 'UTF8')</literal></entry>
       <entry><literal>4</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>lpad</primary>
        </indexterm>
        <literal><function>lpad(<parameter>string</parameter> <type>text</type>,
        <parameter>length</parameter> <type>int</type>
        <optional>, <parameter>fill</parameter> <type>text</type></optional>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
<!--
        Fill up the <parameter>string</parameter> to length
        <parameter>length</parameter> by prepending the characters
        <parameter>fill</parameter> (a space by default).  If the
        <parameter>string</parameter> is already longer than
        <parameter>length</parameter> then it is truncated (on the
        right).
-->
文字<parameter>fill</parameter>（デフォルトは空白文字）を文字列の前に追加して、<parameter>string</parameter>を<parameter>length</parameter>の長さにします。
<parameter>string</parameter>が既に<parameter>length</parameter>の長さを超えている場合は（右側が）切り捨てられます。
       </entry>
       <entry><literal>lpad('hi', 5, 'xy')</literal></entry>
       <entry><literal>xyxhi</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>ltrim</primary>
        </indexterm>
        <literal><function>ltrim(<parameter>string</parameter> <type>text</type>
        <optional>, <parameter>characters</parameter> <type>text</type></optional>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
<!--
        Remove the longest string containing only characters from
        <parameter>characters</parameter> (a space by default) from the start of
        <parameter>string</parameter>
-->
<parameter>string</parameter>の最初から、<parameter>characters</parameter>（デフォルトはスペース）で指定された文字だけを有する最長の文字列を削除します。
       </entry>
       <entry><literal>ltrim('zzzytrim', 'xyz')</literal></entry>
       <entry><literal>trim</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>md5</primary>
        </indexterm>
        <literal><function>md5(<parameter>string</parameter>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
<!--
        Calculates the MD5 hash of <parameter>string</parameter>,
        returning the result in hexadecimal
-->
<parameter>string</parameter>のMD5ハッシュを計算し、16進数で結果を返します。
       </entry>
       <entry><literal>md5('abc')</literal></entry>
       <entry><literal>900150983cd24fb0 d6963f7d28e17f72</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>pg_client_encoding</primary>
        </indexterm>
        <literal><function>pg_client_encoding()</function></literal>
       </entry>
       <entry><type>name</type></entry>
       <entry>
<!--
        Current client encoding name
-->
        現在のクライアントの符号化方式の名前。
       </entry>
       <entry><literal>pg_client_encoding()</literal></entry>
       <entry><literal>SQL_ASCII</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>quote_ident</primary>
        </indexterm>
        <literal><function>quote_ident(<parameter>string</parameter> <type>text</type>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
<!--
        Return the given string suitably quoted to be used as an identifier
        in an <acronym>SQL</acronym> statement string.
        Quotes are added only if necessary (i.e., if the string contains
        non-identifier characters or would be case-folded).
        Embedded quotes are properly doubled.
        See also <xref linkend="plpgsql-quote-literal-example">.
-->
与えられた文字列を、<acronym>SQL</acronym>問い合わせ文字列で識別子として使用できるように、適切な引用符を付けて返します。
引用符は、必要な場合（すなわち、文字列に識別子として使用できない文字が含まれる場合や、大文字変換される場合）にのみ追加されます。埋め込まれた引用符は、適切に二重化されます。
<xref linkend="plpgsql-quote-literal-example">も参照してください。
       </entry>
       <entry><literal>quote_ident('Foo bar')</literal></entry>
       <entry><literal>"Foo bar"</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>quote_literal</primary>
        </indexterm>
        <literal><function>quote_literal(<parameter>string</parameter> <type>text</type>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
<!--
        Return the given string suitably quoted to be used as a string literal
        in an <acronym>SQL</acronym> statement string.
        Embedded single-quotes and backslashes are properly doubled.
        Note that <function>quote_literal</function> returns null on null
        input; if the argument might be null,
        <function>quote_nullable</function> is often more suitable.
        See also <xref linkend="plpgsql-quote-literal-example">.
-->
与えられた文字列を、<acronym>SQL</acronym>問い合わせ文字列で文字リテラルとして使用できるように、適切な引用符を付けて返します。
埋め込まれた単一引用符およびバックスラッシュは、適切に二重化されます。
<function>quote_literal</function>はNULL入力に対してNULLを返すことに注意してください。引数がNULLとなる可能性がある場合、より<function>quote_nullable</function>の方がしばしば適しています。
<xref linkend="plpgsql-quote-literal-example">も参照してください。
       </entry>
       <entry><literal>quote_literal(E'O\'Reilly')</literal></entry>
       <entry><literal>'O''Reilly'</literal></entry>
      </row>

      <row>
       <entry><literal><function>quote_literal(<parameter>value</parameter> <type>anyelement</type>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>
<!--
        Coerce the given value to text and then quote it as a literal.
        Embedded single-quotes and backslashes are properly doubled.
-->
与えられた値をテキストに強制し、そしてリテラルとして引用符付けします。
組み込まれた一重引用符とバックスラッシュは適切に二重化されます。
       </entry>
       <entry><literal>quote_literal(42.5)</literal></entry>
       <entry><literal>'42.5'</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>quote_nullable</primary>
        </indexterm>
        <literal><function>quote_nullable(<parameter>string</parameter> <type>text</type>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
<!--
        Return the given string suitably quoted to be used as a string literal
        in an <acronym>SQL</acronym> statement string; or, if the argument
        is null, return <literal>NULL</>.
        Embedded single-quotes and backslashes are properly doubled.
        See also <xref linkend="plpgsql-quote-literal-example">.
-->
与えられた文字列を、<acronym>SQL</acronym>問い合わせ文字列で文字リテラルとして使用できるように、適切な引用符を付けて返します。
また、引数がNULLの場合、<literal>NULL</>を返します。
埋め込まれた単一引用符およびバックスラッシュは適切に二重化されます。
<xref linkend="plpgsql-quote-literal-example">も参照してください。
       </entry>
       <entry><literal>quote_nullable(NULL)</literal></entry>
       <entry><literal>NULL</literal></entry>
      </row>

      <row>
       <entry><literal><function>quote_nullable(<parameter>value</parameter> <type>anyelement</type>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>
<!--
        Coerce the given value to text and then quote it as a literal;
        or, if the argument is null, return <literal>NULL</>.
        Embedded single-quotes and backslashes are properly doubled.
-->
与えられた値をテキストに強制し、そしてリテラルとして引用符付けします。そうでないと、引数がNULLの場合は<literal>NULL</>を返します。
埋め込まれた単一引用符とバックスラッシュは適切に二重化されます。
       </entry>
       <entry><literal>quote_nullable(42.5)</literal></entry>
       <entry><literal>'42.5'</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>regexp_matches</primary>
        </indexterm>
        <literal><function>regexp_matches(<parameter>string</parameter> <type>text</type>, <parameter>pattern</parameter> <type>text</type> [, <parameter>flags</parameter> <type>text</type>])</function></literal>
       </entry>
       <entry><type>setof text[]</type></entry>
       <entry>
<!--
        Return all captured substrings resulting from matching a POSIX regular
        expression against the <parameter>string</parameter>. See
        <xref linkend="functions-posix-regexp"> for more information.
-->
<parameter>string</parameter>に対してPOSIX正規表現でマッチし、捕捉されたすべての部分文字列を返します。
より詳細は<xref linkend="functions-posix-regexp">を参照してください。
       </entry>
       <entry><literal>regexp_matches('foobarbequebaz', '(bar)(beque)')</literal></entry>
       <entry><literal>{bar,beque}</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>regexp_replace</primary>
        </indexterm>
        <literal><function>regexp_replace(<parameter>string</parameter> <type>text</type>, <parameter>pattern</parameter> <type>text</type>, <parameter>replacement</parameter> <type>text</type> [, <parameter>flags</parameter> <type>text</type>])</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
<!--
        Replace substring(s) matching a POSIX regular expression. See
        <xref linkend="functions-posix-regexp"> for more information.
-->
POSIX正規表現に一致する部分文字列を置換します。
より詳細は<xref linkend="functions-posix-regexp">を参照してください。
       </entry>
       <entry><literal>regexp_replace('Thomas', '.[mN]a.', 'M')</literal></entry>
       <entry><literal>ThM</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>regexp_split_to_array</primary>
        </indexterm>
        <literal><function>regexp_split_to_array(<parameter>string</parameter> <type>text</type>, <parameter>pattern</parameter> <type>text</type> [, <parameter>flags</parameter> <type>text</type> ])</function></literal>
       </entry>
       <entry><type>text[]</type></entry>
       <entry>
<!--
        Split <parameter>string</parameter> using a POSIX regular expression as
        the delimiter.  See <xref linkend="functions-posix-regexp"> for more
        information.
-->
POSIX正規表現を区切り文字に使って<parameter>string</parameter>を分割します。
詳しくは<xref linkend="functions-posix-regexp">を参照ください。
       </entry>
       <entry><literal>regexp_split_to_array('hello world', E'\\s+')</literal></entry>
       <entry><literal>{hello,world}</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>regexp_split_to_table</primary>
        </indexterm>
        <literal><function>regexp_split_to_table(<parameter>string</parameter> <type>text</type>, <parameter>pattern</parameter> <type>text</type> [, <parameter>flags</parameter> <type>text</type>])</function></literal>
       </entry>
       <entry><type>setof text</type></entry>
       <entry>
<!--
        Split <parameter>string</parameter> using a POSIX regular expression as
        the delimiter.  See <xref linkend="functions-posix-regexp"> for more
        information.
-->
POSIX正規表現を区切り文字に使って<parameter>string</parameter>を分割します。
詳しくは<xref linkend="functions-posix-regexp">を参照ください。
       </entry>
       <entry><literal>regexp_split_to_table('hello world', E'\\s+')</literal></entry>
       <entry><literal>hello</literal><para><literal>world</literal></para> (2 rows)</entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>repeat</primary>
        </indexterm>
        <literal><function>repeat(<parameter>string</parameter> <type>text</type>, <parameter>number</parameter> <type>int</type>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
<!--
       <entry>Repeat <parameter>string</parameter> the specified
       <parameter>number</parameter> of times</entry>
-->
       <entry>指定された<parameter>number</parameter>の数だけ<parameter>string</parameter>を繰り返します。</entry>
       <entry><literal>repeat('Pg', 4)</literal></entry>
       <entry><literal>PgPgPgPg</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>replace</primary>
        </indexterm>
        <literal><function>replace(<parameter>string</parameter> <type>text</type>,
        <parameter>from</parameter> <type>text</type>,
        <parameter>to</parameter> <type>text</type>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
<!--
       <entry>Replace all occurrences in <parameter>string</parameter> of substring
        <parameter>from</parameter> with substring <parameter>to</parameter>
-->
       <entry><parameter>string</parameter>に出現する全ての<parameter>from</parameter>部分文字列を<parameter>to</parameter>部分文字列に置換します。
       </entry>
       <entry><literal>replace('abcdefabcdef', 'cd', 'XX')</literal></entry>
       <entry><literal>abXXefabXXef</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>reverse</primary>
        </indexterm>
        <literal><function>reverse(<parameter>str</parameter>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
<!--
        Return reversed string.
-->
        逆順にした文字列を返します。
       </entry>
       <entry><literal>reverse('abcde')</literal></entry>
       <entry><literal>edcba</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>right</primary>
        </indexterm>
        <literal><function>right(<parameter>str</parameter> <type>text</type>,
         <parameter>n</parameter> <type>int</type>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
<!--
        Return last <replaceable>n</> characters in the string. When <replaceable>n</>
        is negative, return all but first |<replaceable>n</>| characters.
-->
文字列の末尾から<replaceable>n</>文字を返します。
<replaceable>n</>が負数の場合は、|<replaceable>n</>|の数だけ文字列の末尾から切り取った文字列を返します。
       </entry>
       <entry><literal>right('abcde', 2)</literal></entry>
       <entry><literal>de</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>rpad</primary>
        </indexterm>
        <literal><function>rpad(<parameter>string</parameter> <type>text</type>,
        <parameter>length</parameter> <type>int</type>
        <optional>, <parameter>fill</parameter> <type>text</type></optional>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
<!--
        Fill up the <parameter>string</parameter> to length
        <parameter>length</parameter> by appending the characters
        <parameter>fill</parameter> (a space by default).  If the
        <parameter>string</parameter> is already longer than
        <parameter>length</parameter> then it is truncated.
-->
文字<parameter>fill</parameter>（デフォルトはスペース）を文字列に追加して、<parameter>string</parameter>を<parameter>length</parameter>の長さにします。
<parameter>string</parameter>が既に<parameter>length</parameter>の長さを超えている場合は切り捨てられます。
       </entry>
       <entry><literal>rpad('hi', 5, 'xy')</literal></entry>
       <entry><literal>hixyx</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>rtrim</primary>
        </indexterm>
        <literal><function>rtrim(<parameter>string</parameter> <type>text</type>
         <optional>, <parameter>characters</parameter> <type>text</type></optional>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
<!--
        Remove the longest string containing only characters from
        <parameter>characters</parameter> (a space by default) from the end of
        <parameter>string</parameter>
-->
<parameter>string</parameter>の末尾から、<parameter>characters</parameter>（デフォルトはスペース）で指定された文字のみを有する最長の文字列を削除します。
       </entry>
       <entry><literal>rtrim('trimxxxx', 'x')</literal></entry>
       <entry><literal>trim</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>split_part</primary>
        </indexterm>
        <literal><function>split_part(<parameter>string</parameter> <type>text</type>,
        <parameter>delimiter</parameter> <type>text</type>,
        <parameter>field</parameter> <type>int</type>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
<!--
       <entry>Split <parameter>string</parameter> on <parameter>delimiter</parameter>
        and return the given field (counting from one)
-->
       <entry><parameter>string</parameter>を<parameter>delimiter</parameter>で分割し、その結果から（1から始まるように数える）指定したフィールドを返します。
       </entry>
       <entry><literal>split_part('abc~@~def~@~ghi', '~@~', 2)</literal></entry>
       <entry><literal>def</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>strpos</primary>
        </indexterm>
        <literal><function>strpos(<parameter>string</parameter>, <parameter>substring</parameter>)</function></literal>
       </entry>
       <entry><type>int</type></entry>
       <entry>
<!--
        Location of specified substring (same as
        <literal>position(<parameter>substring</parameter> in
         <parameter>string</parameter>)</literal>, but note the reversed
        argument order)
-->
指定した部分文字列の位置を特定します（<literal>position(<parameter>substring</parameter> in <parameter>string</parameter>)</literal> と同じですが、引数の順序が逆になっていることに注意してください）。
       </entry>
       <entry><literal>strpos('high', 'ig')</literal></entry>
       <entry><literal>2</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>substr</primary>
        </indexterm>
        <literal><function>substr(<parameter>string</parameter>, <parameter>from</parameter> <optional>, <parameter>count</parameter></optional>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
<!--
        Extract substring (same as
        <literal>substring(<parameter>string</parameter> from <parameter>from</parameter> for <parameter>count</parameter>)</literal>)
-->
指定した部分文字列を取り出します（<literal>substring(<parameter>string</parameter> from <parameter>from</parameter> for <parameter>count</parameter>)</literal>と同じです）。
       </entry>
       <entry><literal>substr('alphabet', 3, 2)</literal></entry>
       <entry><literal>ph</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>to_ascii</primary>
        </indexterm>
        <literal><function>to_ascii(<parameter>string</parameter> <type>text</type>
        <optional>, <parameter>encoding</parameter> <type>text</type></optional>)</function></literal>
       </entry>
       <entry><type>text</type></entry>

       <entry>
<!--
       Convert <parameter>string</parameter> to <acronym>ASCII</acronym> from another encoding
       (only supports conversion from  <literal>LATIN1</>, <literal>LATIN2</>, <literal>LATIN9</>,
       and <literal>WIN1250</> encodings)
-->
<parameter>string</parameter>を他の符号化方式から<acronym>ASCII</acronym>に変換します（<literal>LATIN1</>、<literal>LATIN2</>、<literal>LATIN9</>、<literal>WIN1250</>符号化方式からの変換のみをサポートします。）
       </entry>

       <entry><literal>to_ascii('Karel')</literal></entry>
       <entry><literal>Karel</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>to_hex</primary>
        </indexterm>
        <literal><function>to_hex(<parameter>number</parameter> <type>int</type>
        or <type>bigint</type>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
<!--
       <entry>Convert <parameter>number</parameter> to its equivalent hexadecimal
        representation
-->
       <entry><parameter>number</parameter>を、同等の16進数表現に変換します。
       </entry>
       <entry><literal>to_hex(2147483647)</literal></entry>
       <entry><literal>7fffffff</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>translate</primary>
        </indexterm>
        <literal><function>translate(<parameter>string</parameter> <type>text</type>,
        <parameter>from</parameter> <type>text</type>,
        <parameter>to</parameter> <type>text</type>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
<!--
        Any character in <parameter>string</parameter> that matches a
        character in the <parameter>from</parameter> set is replaced by
        the corresponding character in the <parameter>to</parameter>
        set. If <parameter>from</parameter> is longer than
        <parameter>to</parameter>, occurrences of the extra characters in
        <parameter>from</parameter> are removed.
-->
<parameter>from</parameter>集合で指定された文字と一致する<parameter>string</parameter>にある全ての文字は、それに対応する<parameter>to</parameter>で指定された文字に置き換えられます。
もし<parameter>from</parameter>が<parameter>to</parameter>より長い場合、<parameter>from</parameter>で指定される余分な文字に一致するものは削除されます。
       </entry>
       <entry><literal>translate('12345', '143', 'ax')</literal></entry>
       <entry><literal>a2x5</literal></entry>
      </row>

     </tbody>
    </tgroup>
   </table>

   <para>
<!--
    The <function>concat</function>, <function>concat_ws</function> and
    <function>format</function> functions are variadic, so it is possible to
    pass the values to be concatenated or formatted as an array marked with
    the <literal>VARIADIC</literal> keyword (see <xref
    linkend="xfunc-sql-variadic-functions">).  The array's elements are
    treated as if they were separate ordinary arguments to the function.
    If the variadic array argument is NULL, <function>concat</function>
    and <function>concat_ws</function> return NULL, but
    <function>format</function> treats a NULL as a zero-element array.
-->
<function>concat</function>、<function>concat_ws</function>および<function>format</function>関数はVariadicです。従って、キーワード<literal>VARIADIC</literal>で標しをつけられた配列のように、値を連結またはフォーマットした形で受け渡すことが可能です（<xref linkend="xfunc-sql-variadic-functions">を参照してください）。
配列の要素は関数に対して分割された通常の引数のように扱われます。
もしvariadic配列引数がNULLであれば、<function>concat</function>および<function>concat_ws</function>はNULLを返しますが、<function>format</function>はNULLを要素を持たない配列と扱います。
   </para>

   <para>
<!--
   See also the aggregate function <function>string_agg</function> in
   <xref linkend="functions-aggregate">.
-->
<xref linkend="functions-aggregate">内の<function>string_agg</function>集約関数も参照してください。
   </para>

   <table id="conversion-names">
<!--
    <title>Built-in Conversions</title>
-->
    <title>組み込みの変換</title>
    <tgroup cols="3">
     <thead>
      <row>
<!--
       <entry>Conversion Name
-->
       <entry>変換名
        <footnote>
         <para>
<!--
          The conversion names follow a standard naming scheme: The
          official name of the source encoding with all
          non-alphanumeric characters replaced by underscores, followed
          by <literal>_to_</literal>, followed by the similarly processed
          destination encoding name. Therefore, the names might deviate
          from the customary encoding names.
-->
変換名は、標準命名体系に従っています。変換元符号化方式の公式名の内、英数字以外の文字をアンダースコアで置き換え、その後に<literal>_to_</literal>を付け、そして変換先符号化方式名を同様に処理したものを続けたものです。
したがって、これらの名称は慣習的なコード名とは異なる可能性があります。
         </para>
        </footnote>
       </entry>
<!--
       <entry>Source Encoding</entry>
       <entry>Destination Encoding</entry>
-->
       <entry>変換前の符号化方式</entry>
       <entry>変換後の符号化方式</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry><literal>ascii_to_mic</literal></entry>
       <entry><literal>SQL_ASCII</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>ascii_to_utf8</literal></entry>
       <entry><literal>SQL_ASCII</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>big5_to_euc_tw</literal></entry>
       <entry><literal>BIG5</literal></entry>
       <entry><literal>EUC_TW</literal></entry>
      </row>

      <row>
       <entry><literal>big5_to_mic</literal></entry>
       <entry><literal>BIG5</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>big5_to_utf8</literal></entry>
       <entry><literal>BIG5</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>euc_cn_to_mic</literal></entry>
       <entry><literal>EUC_CN</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>euc_cn_to_utf8</literal></entry>
       <entry><literal>EUC_CN</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>euc_jp_to_mic</literal></entry>
       <entry><literal>EUC_JP</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>euc_jp_to_sjis</literal></entry>
       <entry><literal>EUC_JP</literal></entry>
       <entry><literal>SJIS</literal></entry>
      </row>

      <row>
       <entry><literal>euc_jp_to_utf8</literal></entry>
       <entry><literal>EUC_JP</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>euc_kr_to_mic</literal></entry>
       <entry><literal>EUC_KR</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>euc_kr_to_utf8</literal></entry>
       <entry><literal>EUC_KR</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>euc_tw_to_big5</literal></entry>
       <entry><literal>EUC_TW</literal></entry>
       <entry><literal>BIG5</literal></entry>
      </row>

      <row>
       <entry><literal>euc_tw_to_mic</literal></entry>
       <entry><literal>EUC_TW</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>euc_tw_to_utf8</literal></entry>
       <entry><literal>EUC_TW</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>gb18030_to_utf8</literal></entry>
       <entry><literal>GB18030</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>gbk_to_utf8</literal></entry>
       <entry><literal>GBK</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_10_to_utf8</literal></entry>
       <entry><literal>LATIN6</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_13_to_utf8</literal></entry>
       <entry><literal>LATIN7</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_14_to_utf8</literal></entry>
       <entry><literal>LATIN8</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_15_to_utf8</literal></entry>
       <entry><literal>LATIN9</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_16_to_utf8</literal></entry>
       <entry><literal>LATIN10</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_1_to_mic</literal></entry>
       <entry><literal>LATIN1</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_1_to_utf8</literal></entry>
       <entry><literal>LATIN1</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_2_to_mic</literal></entry>
       <entry><literal>LATIN2</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_2_to_utf8</literal></entry>
       <entry><literal>LATIN2</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_2_to_windows_1250</literal></entry>
       <entry><literal>LATIN2</literal></entry>
       <entry><literal>WIN1250</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_3_to_mic</literal></entry>
       <entry><literal>LATIN3</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_3_to_utf8</literal></entry>
       <entry><literal>LATIN3</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_4_to_mic</literal></entry>
       <entry><literal>LATIN4</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_4_to_utf8</literal></entry>
       <entry><literal>LATIN4</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_5_to_koi8_r</literal></entry>
       <entry><literal>ISO_8859_5</literal></entry>
       <entry><literal>KOI8R</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_5_to_mic</literal></entry>
       <entry><literal>ISO_8859_5</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_5_to_utf8</literal></entry>
       <entry><literal>ISO_8859_5</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_5_to_windows_1251</literal></entry>
       <entry><literal>ISO_8859_5</literal></entry>
       <entry><literal>WIN1251</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_5_to_windows_866</literal></entry>
       <entry><literal>ISO_8859_5</literal></entry>
       <entry><literal>WIN866</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_6_to_utf8</literal></entry>
       <entry><literal>ISO_8859_6</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_7_to_utf8</literal></entry>
       <entry><literal>ISO_8859_7</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_8_to_utf8</literal></entry>
       <entry><literal>ISO_8859_8</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_9_to_utf8</literal></entry>
       <entry><literal>LATIN5</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>johab_to_utf8</literal></entry>
       <entry><literal>JOHAB</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>koi8_r_to_iso_8859_5</literal></entry>
       <entry><literal>KOI8R</literal></entry>
       <entry><literal>ISO_8859_5</literal></entry>
      </row>

      <row>
       <entry><literal>koi8_r_to_mic</literal></entry>
       <entry><literal>KOI8R</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>koi8_r_to_utf8</literal></entry>
       <entry><literal>KOI8R</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>koi8_r_to_windows_1251</literal></entry>
       <entry><literal>KOI8R</literal></entry>
       <entry><literal>WIN1251</literal></entry>
      </row>

      <row>
       <entry><literal>koi8_r_to_windows_866</literal></entry>
       <entry><literal>KOI8R</literal></entry>
       <entry><literal>WIN866</literal></entry>
      </row>

      <row>
       <entry><literal>koi8_u_to_utf8</literal></entry>
       <entry><literal>KOI8U</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_ascii</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>SQL_ASCII</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_big5</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>BIG5</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_euc_cn</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>EUC_CN</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_euc_jp</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>EUC_JP</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_euc_kr</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>EUC_KR</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_euc_tw</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>EUC_TW</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_iso_8859_1</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>LATIN1</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_iso_8859_2</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>LATIN2</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_iso_8859_3</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>LATIN3</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_iso_8859_4</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>LATIN4</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_iso_8859_5</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>ISO_8859_5</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_koi8_r</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>KOI8R</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_sjis</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>SJIS</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_windows_1250</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>WIN1250</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_windows_1251</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>WIN1251</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_windows_866</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>WIN866</literal></entry>
      </row>

      <row>
       <entry><literal>sjis_to_euc_jp</literal></entry>
       <entry><literal>SJIS</literal></entry>
       <entry><literal>EUC_JP</literal></entry>
      </row>

      <row>
       <entry><literal>sjis_to_mic</literal></entry>
       <entry><literal>SJIS</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>sjis_to_utf8</literal></entry>
       <entry><literal>SJIS</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>tcvn_to_utf8</literal></entry>
       <entry><literal>WIN1258</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>uhc_to_utf8</literal></entry>
       <entry><literal>UHC</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_ascii</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>SQL_ASCII</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_big5</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>BIG5</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_euc_cn</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>EUC_CN</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_euc_jp</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>EUC_JP</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_euc_kr</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>EUC_KR</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_euc_tw</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>EUC_TW</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_gb18030</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>GB18030</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_gbk</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>GBK</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_iso_8859_1</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>LATIN1</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_iso_8859_10</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>LATIN6</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_iso_8859_13</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>LATIN7</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_iso_8859_14</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>LATIN8</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_iso_8859_15</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>LATIN9</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_iso_8859_16</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>LATIN10</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_iso_8859_2</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>LATIN2</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_iso_8859_3</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>LATIN3</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_iso_8859_4</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>LATIN4</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_iso_8859_5</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>ISO_8859_5</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_iso_8859_6</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>ISO_8859_6</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_iso_8859_7</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>ISO_8859_7</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_iso_8859_8</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>ISO_8859_8</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_iso_8859_9</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>LATIN5</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_johab</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>JOHAB</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_koi8_r</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>KOI8R</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_koi8_u</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>KOI8U</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_sjis</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>SJIS</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_tcvn</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>WIN1258</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_uhc</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>UHC</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_windows_1250</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>WIN1250</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_windows_1251</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>WIN1251</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_windows_1252</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>WIN1252</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_windows_1253</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>WIN1253</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_windows_1254</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>WIN1254</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_windows_1255</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>WIN1255</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_windows_1256</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>WIN1256</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_windows_1257</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>WIN1257</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_windows_866</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>WIN866</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_windows_874</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>WIN874</literal></entry>
      </row>

      <row>
       <entry><literal>windows_1250_to_iso_8859_2</literal></entry>
       <entry><literal>WIN1250</literal></entry>
       <entry><literal>LATIN2</literal></entry>
      </row>

      <row>
       <entry><literal>windows_1250_to_mic</literal></entry>
       <entry><literal>WIN1250</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>windows_1250_to_utf8</literal></entry>
       <entry><literal>WIN1250</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>windows_1251_to_iso_8859_5</literal></entry>
       <entry><literal>WIN1251</literal></entry>
       <entry><literal>ISO_8859_5</literal></entry>
      </row>

      <row>
       <entry><literal>windows_1251_to_koi8_r</literal></entry>
       <entry><literal>WIN1251</literal></entry>
       <entry><literal>KOI8R</literal></entry>
      </row>

      <row>
       <entry><literal>windows_1251_to_mic</literal></entry>
       <entry><literal>WIN1251</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>windows_1251_to_utf8</literal></entry>
       <entry><literal>WIN1251</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>windows_1251_to_windows_866</literal></entry>
       <entry><literal>WIN1251</literal></entry>
       <entry><literal>WIN866</literal></entry>
      </row>

      <row>
       <entry><literal>windows_1252_to_utf8</literal></entry>
       <entry><literal>WIN1252</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>windows_1256_to_utf8</literal></entry>
       <entry><literal>WIN1256</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>windows_866_to_iso_8859_5</literal></entry>
       <entry><literal>WIN866</literal></entry>
       <entry><literal>ISO_8859_5</literal></entry>
      </row>

      <row>
       <entry><literal>windows_866_to_koi8_r</literal></entry>
       <entry><literal>WIN866</literal></entry>
       <entry><literal>KOI8R</literal></entry>
      </row>

      <row>
       <entry><literal>windows_866_to_mic</literal></entry>
       <entry><literal>WIN866</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>windows_866_to_utf8</literal></entry>
       <entry><literal>WIN866</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>windows_866_to_windows_1251</literal></entry>
       <entry><literal>WIN866</literal></entry>
       <entry><literal>WIN</literal></entry>
      </row>

      <row>
       <entry><literal>windows_874_to_utf8</literal></entry>
       <entry><literal>WIN874</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>euc_jis_2004_to_utf8</literal></entry>
       <entry><literal>EUC_JIS_2004</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_euc_jis_2004</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>EUC_JIS_2004</literal></entry>
      </row>

      <row>
       <entry><literal>shift_jis_2004_to_utf8</literal></entry>
       <entry><literal>SHIFT_JIS_2004</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_shift_jis_2004</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>SHIFT_JIS_2004</literal></entry>
      </row>

      <row>
       <entry><literal>euc_jis_2004_to_shift_jis_2004</literal></entry>
       <entry><literal>EUC_JIS_2004</literal></entry>
       <entry><literal>SHIFT_JIS_2004</literal></entry>
      </row>

      <row>
       <entry><literal>shift_jis_2004_to_euc_jis_2004</literal></entry>
       <entry><literal>SHIFT_JIS_2004</literal></entry>
       <entry><literal>EUC_JIS_2004</literal></entry>
      </row>

     </tbody>
    </tgroup>
   </table>

   <sect2 id="functions-string-format">
    <title><function>format</function></title>

    <indexterm>
     <primary>format</primary>
    </indexterm>

    <para>
<!--
     The function <function>format</> produces output formatted according to
     a format string, in a style similar to the C function
     <function>sprintf</>.
-->
関数<function>format</>は、C関数の<function>sprintf</>同様の形式で、format文字列に従ってフォーマットされた出力を生成します。
    </para>

    <para>
<synopsis>
<function>format</>(<parameter>formatstr</> <type>text</> [, <parameter>formatarg</> <type>"any"</> [, ...] ])
</synopsis>
<!--
     <replaceable>formatstr</> is a format string that specifies how the
     result should be formatted.  Text in the format string is copied
     directly to the result, except where <firstterm>format specifiers</> are
     used.  Format specifiers act as placeholders in the string, defining how
     subsequent function arguments should be formatted and inserted into the
     result.  Each <replaceable>formatarg</> argument is converted to text
     according to the usual output rules for its data type, and then formatted
     and inserted into the result string according to the format specifier(s).
-->
<replaceable>formatstr</>は結果がどのようにフォーマットされるかを指定するformat文字列です。
<firstterm>format specifiers</>が使用されている以外、format文字列のテキストは結果に直接コピーされます。
引き続く関数の引数がどのようにフォーマットされなければならないか、そして結果に挿入されるべきかを定義して、format指示子は文字列の中で代替物のように振舞います。
それぞれの<replaceable>formatarg</>引数はそのデータ型に対する通常の出力規定に従ってテキストに変換され、その後format指示子に従いフォーマットされ、結果文字列に挿入されます。
    </para>

    <para>
<!--
     Format specifiers are introduced by a <literal>%</> character and have
     the form
-->
format指示子は<literal>%</>文字で導入され、以下の形式です。
<synopsis>
%[<replaceable>position</>][<replaceable>flags</>][<replaceable>width</>]<replaceable>type</>
</synopsis>
<!--
     where the component fields are:
-->
ここで要素フィールドとは以下になっています。

     <variablelist>
      <varlistentry>
<!--
       <term><replaceable>position</replaceable> (optional)</term>
-->
       <term><replaceable>position</replaceable> (任意)</term>
       <listitem>
        <para>
<!--
         A string of the form <literal><replaceable>n</>$</> where
         <replaceable>n</> is the index of the argument to print.
         Index 1 means the first argument after
         <replaceable>formatstr</>.  If the <replaceable>position</> is
         omitted, the default is to use the next argument in sequence.
-->
形式<literal><replaceable>n</>$</>の文字列で、<replaceable>n</>は出力する引数のインデックスです。
インデックス１は<replaceable>formatstr</>の後の最初の引数です。
<replaceable>position</>が省略されると、一連の中の次の引数がデフォルトとして使用されます。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
<!--
       <term><replaceable>flags</replaceable> (optional)</term>
-->
       <term><replaceable>flags</replaceable> (任意)</term>
       <listitem>
        <para>
<!--
         Additional options controlling how the format specifier's output is
         formatted.  Currently the only supported flag is a minus sign
         (<literal>-</>) which will cause the format specifier's output to be
         left-justified.  This has no effect unless the <replaceable>width</>
         field is also specified.
-->
format指示子の出力がフォーマットされるかを制御する追加の任意の要素です。
現在、サポートされているflagはマイナス記号(<literal>-</>)のみで、format指示子の出力が左詰めになるようにします。
これは<replaceable>width</>フィールドが同時に指定されていない場合効果はありません。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
<!--
       <term><replaceable>width</replaceable> (optional)</term>
-->
       <term><replaceable>width</replaceable> (任意)</term>
       <listitem>
        <para>
<!--
         Specifies the <emphasis>minimum</> number of characters to use to
         display the format specifier's output.  The output is padded on the
         left or right (depending on the <literal>-</> flag) with spaces as
         needed to fill the width.  A too-small width does not cause
         truncation of the output, but is simply ignored.  The width may be
         specified using any of the following: a positive integer; an
         asterisk (<literal>*</>) to use the next function argument as the
         width; or a string of the form <literal>*<replaceable>n</>$</> to
         use the <replaceable>n</>th function argument as the width.
-->
format指示子の出力を表示する<emphasis>minimum</>文字数を指定します。
出力は（<literal>-</> flagによって）幅を満たすのに必要な空白が左または右に埋め込まれます。
余りにも小さな幅は出力の切り取りに効果を及ぼさず、単に無視されます。
幅は次のいずれかでも指定できます。それらは、正の整数、幅としての次の関数引数として使用する星印 (<literal>*</>)、または<replaceable>n</>thの関数引数を幅として使用するform  <literal>*<replaceable>n</>$</> 文字列です。
        </para>

        <para>
<!--
         If the width comes from a function argument, that argument is
         consumed before the argument that is used for the format specifier's
         value.  If the width argument is negative, the result is left
         aligned (as if the <literal>-</> flag had been specified) within a
         field of length <function>abs</>(<replaceable>width</replaceable>).
-->
幅が関数引数に起因される場合、その引数はformat指示子の値に使用される引数より先に消費されます。
幅の引数が負の場合、フィールド長<function>abs</>(<replaceable>width</replaceable>)の範囲内で結果は（あたかも<literal>-</> flagが指定されたように）左詰めになります。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
<!--
       <term><replaceable>type</replaceable> (required)</term>
-->
       <term><replaceable>type</replaceable> (必須)</term>
       <listitem>
        <para>
<!--
         The type of format conversion to use to produce the format
         specifier's output.  The following types are supported:
-->
format指示子の出力を生成するのに使用されるフォーマット変換の型。
以下の型がサポートされています。
         <itemizedlist>
          <listitem>
           <para>
<!--
            <literal>s</literal> formats the argument value as a simple
            string.  A null value is treated as an empty string.
-->
<literal>s</literal>は引数の値を単純文字列にフォーマットします。
NULL値は空文字列として扱われます。
           </para>
          </listitem>
          <listitem>
           <para>
<!--
            <literal>I</literal> treats the argument value as an SQL
            identifier, double-quoting it if necessary.
            It is an error for the value to be null.
-->
<literal>I</literal>は、必要とされれば二重括弧で括られたSQL識別子として引数値を取り扱います。
NULL値はエラーです。
           </para>
          </listitem>
          <listitem>
           <para>
<!--
            <literal>L</literal> quotes the argument value as an SQL literal.
            A null value is displayed as the string <literal>NULL</>, without
            quotes.
-->
<literal>L</literal>は引数値をSQLリテラルとして引用します。
NULL値は引用符無しで<literal>NULL</>文字列として表示されます。
           </para>
          </listitem>
         </itemizedlist>
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>

    <para>
<!--
     In addition to the format specifiers described above, the special sequence
     <literal>%%</> may be used to output a literal <literal>%</> character.
-->
上記で説明したformat指示子に加え、特別の並びの<literal>%%</>がリテラル<literal>%</>文字を出力するために使用することもできます。
    </para>

    <para>
<!--
     Here are some examples of the basic format conversions:
-->
基本的なformat変換の例を幾つか下記に紹介します。

<screen>
SELECT format('Hello %s', 'World');
<lineannotation>Result: </lineannotation><computeroutput>Hello World</computeroutput>

SELECT format('Testing %s, %s, %s, %%', 'one', 'two', 'three');
<lineannotation>Result: </><computeroutput>Testing one, two, three, %</>

SELECT format('INSERT INTO %I VALUES(%L)', 'Foo bar', E'O\'Reilly');
<lineannotation>Result: </lineannotation><computeroutput>INSERT INTO "Foo bar" VALUES('O''Reilly')</computeroutput>

SELECT format('INSERT INTO %I VALUES(%L)', 'locations', E'C:\\Program Files');
<lineannotation>Result: </lineannotation><computeroutput>INSERT INTO locations VALUES(E'C:\\Program Files')</computeroutput>
</screen>
    </para>

    <para>
<!--
     Here are examples using <replaceable>width</replaceable> fields
     and the <literal>-</> flag:
-->
<replaceable>width</replaceable>フィールドと<literal>-</> flagを使用した例は以下のようです。

<screen>
SELECT format('|%10s|', 'foo');
<lineannotation>Result: </><computeroutput>|       foo|</>

SELECT format('|%-10s|', 'foo');
<lineannotation>Result: </><computeroutput>|foo       |</>

SELECT format('|%*s|', 10, 'foo');
<lineannotation>Result: </><computeroutput>|       foo|</>

SELECT format('|%*s|', -10, 'foo');
<lineannotation>Result: </><computeroutput>|foo       |</>

SELECT format('|%-*s|', 10, 'foo');
<lineannotation>Result: </><computeroutput>|foo       |</>

SELECT format('|%-*s|', -10, 'foo');
<lineannotation>Result: </><computeroutput>|foo       |</>
</screen>
    </para>

    <para>
<!--
     These examples show use of <replaceable>position</> fields:
-->
以下の例は<replaceable>position</>フィールドの使い方を示しています。

<screen>
SELECT format('Testing %3$s, %2$s, %1$s', 'one', 'two', 'three');
<lineannotation>Result: </><computeroutput>Testing three, two, one</>

SELECT format('|%*2$s|', 'foo', 10, 'bar');
<lineannotation>Result: </><computeroutput>|       bar|</>

SELECT format('|%1$*2$s|', 'foo', 10, 'bar');
<lineannotation>Result: </><computeroutput>|       foo|</>
</screen>
    </para>

    <para>
<!--
     Unlike the standard C function <function>sprintf</>,
     <productname>PostgreSQL</>'s <function>format</> function allows format
     specifiers with and without <replaceable>position</> fields to be mixed
     in the same format string.  A format specifier without a
     <replaceable>position</> field always uses the next argument after the
     last argument consumed.
     In addition, the <function>format</> function does not require all
     function arguments to be used in the format string.
     For example:
-->
標準C関数<function>sprintf</>とは違って、<productname>PostgreSQL</>の <function>format</>関数はformat指示子に対し、同一のformat文字列の中で<replaceable>position</>フィールドがあっても無くっても問題としません。
<replaceable>position</>フィールドが無いformat指示子は常に最終の引数が消費された後に次の引数を使用します。
さらに、<function>format</>関数はformat文字列で使用されるべき全ての関数引数を要求しません。
例を示します。

<screen>
SELECT format('Testing %3$s, %2$s, %s', 'one', 'two', 'three');
<lineannotation>Result: </><computeroutput>Testing three, two, three</>
</screen>
    </para>

    <para>
<!--
     The <literal>%I</> and <literal>%L</> format specifiers are particularly
     useful for safely constructing dynamic SQL statements.  See
     <xref linkend="plpgsql-quote-literal-example">.
-->
<literal>%I</> および <literal>%L</>のformat指示子は特に動的SQL命令を構築する場合に便利です。
<xref linkend="plpgsql-quote-literal-example">を参照してください。
    </para>
   </sect2>

  </sect1>


  <sect1 id="functions-binarystring">
<!--
   <title>Binary String Functions and Operators</title>
-->
   <title>バイナリ文字列関数と演算子</title>

   <indexterm zone="functions-binarystring">
<!--
    <primary>binary data</primary>
    <secondary>functions</secondary>
-->
    <primary>バイナリデータ</primary>
    <secondary>関数</secondary>
   </indexterm>

   <para>
<!--
    This section describes functions and operators for examining and
    manipulating values of type <type>bytea</type>.
-->
本節では<type>bytea</type>型の値を調べたり操作するための関数と演算子について説明します。
   </para>

   <para>
<!--
    <acronym>SQL</acronym> defines some string functions that use
    key words, rather than commas, to separate
    arguments.  Details are in
    <xref linkend="functions-binarystring-sql">.
    <productname>PostgreSQL</> also provides versions of these functions
    that use the regular function invocation syntax
    (see <xref linkend="functions-binarystring-other">).
-->
<acronym>SQL</acronym>では、引数の区切りにカンマではなくキーワードを使う文字列関数を、いくつか定義しています。
詳細は<xref linkend="functions-binarystring-sql">を参照してください。
また<productname>PostgreSQL</>は、これらの関数に対して通常の関数呼び出し構文を使用するバージョンを提供します（<xref linkend="functions-string-other">を参照してください）。
   </para>

   <note>
<!--
    <para>
     The sample results shown on this page assume that the server parameter
     <link linkend="guc-bytea-output"><varname>bytea_output</></link> is set
     to <literal>escape</literal> (the traditional PostgreSQL format).
    </para>
-->
    <para>
このページで示されるサンプル結果は、サーバパラメータである<link linkend="guc-bytea-output"><varname>bytea_output</></link>が<literal>escape</literal>に設定されていることを想定しています(この設定はPostgreSQLの伝統的な形式です)。
    </para>
   </note>

   <table id="functions-binarystring-sql">
<!--
    <title><acronym>SQL</acronym> Binary String Functions and Operators</title>
-->
    <title><acronym>SQL</acronym>バイナリ文字列関数と演算子</title>
    <tgroup cols="5">
     <thead>
      <row>
<!--
       <entry>Function</entry>
       <entry>Return Type</entry>
       <entry>Description</entry>
       <entry>Example</entry>
       <entry>Result</entry>
-->
       <entry>関数</entry>
       <entry>戻り値型</entry>
       <entry>説明</entry>
       <entry>例</entry>
       <entry>結果</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry><literal><parameter>string</parameter> <literal>||</literal>
        <parameter>string</parameter></literal></entry>
       <entry> <type>bytea</type> </entry>
       <entry>
<!--
        String concatenation
-->
        文字列結合
        <indexterm>
<!--
         <primary>binary string</primary>
         <secondary>concatenation</secondary>
-->
         <primary>バイナリ文字列</primary>
         <secondary>結合</secondary>
        </indexterm>
       </entry>
       <entry><literal>E'\\\\Post'::bytea || E'\\047gres\\000'::bytea</literal></entry>
       <entry><literal>\\Post'gres\000</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>octet_length</primary>
        </indexterm>
        <literal><function>octet_length(<parameter>string</parameter>)</function></literal>
       </entry>
       <entry><type>int</type></entry>
<!--
       <entry>Number of bytes in binary string</entry>
-->
       <entry>バイナリ文字列中のバイト数</entry>
       <entry><literal>octet_length(E'jo\\000se'::bytea)</literal></entry>
       <entry><literal>5</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>overlay</primary>
        </indexterm>
        <literal><function>overlay(<parameter>string</parameter> placing <parameter>string</parameter> from <type>int</type> <optional>for <type>int</type></optional>)</function></literal>
       </entry>
       <entry><type>bytea</type></entry>
       <entry>
<!--
        Replace substring
-->
        部分文字列の置換
       </entry>
       <entry><literal>overlay(E'Th\\000omas'::bytea placing E'\\002\\003'::bytea from 2 for 3)</literal></entry>
       <entry><literal>T\\002\\003mas</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>position</primary>
        </indexterm>
        <literal><function>position(<parameter>substring</parameter> in <parameter>string</parameter>)</function></literal>
       </entry>
       <entry><type>int</type></entry>
<!--
       <entry>Location of specified substring</entry>
-->
       <entry>指定した部分文字列の位置</entry>
      <entry><literal>position(E'\\000om'::bytea in E'Th\\000omas'::bytea)</literal></entry>
       <entry><literal>3</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>substring</primary>
        </indexterm>
        <literal><function>substring(<parameter>string</parameter> <optional>from <type>int</type></optional> <optional>for <type>int</type></optional>)</function></literal>
       </entry>
       <entry><type>bytea</type></entry>
       <entry>
<!--
        Extract substring
-->
        部分文字列の抽出
       </entry>
       <entry><literal>substring(E'Th\\000omas'::bytea from 2 for 3)</literal></entry>
       <entry><literal>h\000o</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>trim</primary>
        </indexterm>
        <literal><function>trim(<optional>both</optional>
        <parameter>bytes</parameter> from
        <parameter>string</parameter>)</function></literal>
       </entry>
       <entry><type>bytea</type></entry>
       <entry>
<!--
        Remove the longest string containing only the bytes in
        <parameter>bytes</parameter> from the start
        and end of <parameter>string</parameter>
-->
文字列<parameter>string</parameter>の先頭から末尾<parameter>bytes</parameter>のバイトのみを含む最長の文字列を削除します。
       </entry>
       <entry><literal>trim(E'\\000'::bytea from E'\\000Tom\\000'::bytea)</literal></entry>
       <entry><literal>Tom</literal></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
<!--
    Additional binary string manipulation functions are available and
    are listed in <xref linkend="functions-binarystring-other">.  Some
    of them are used internally to implement the
    <acronym>SQL</acronym>-standard string functions listed in <xref
    linkend="functions-binarystring-sql">.
-->
この他、<xref linkend="functions-binarystring-other">に列挙するバイナリ列操作関数が使えます。
そのいくつかは、<xref linkend="functions-binarystring-sql">で説明した標準<acronym>SQL</acronym>の文字列関数を実装するために内部的に使用されています。
   </para>

   <table id="functions-binarystring-other">
<!--
    <title>Other Binary String Functions</title>
-->
    <title>その他のバイナリ文字列関数</title>
    <tgroup cols="5">
     <thead>
      <row>
<!--
       <entry>Function</entry>
       <entry>Return Type</entry>
       <entry>Description</entry>
       <entry>Example</entry>
       <entry>Result</entry>
-->
       <entry>関数</entry>
       <entry>戻り値型</entry>
       <entry>説明</entry>
       <entry>例</entry>
       <entry>結果</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry>
        <indexterm>
         <primary>btrim</primary>
        </indexterm>
        <literal><function>btrim(<parameter>string</parameter>
        <type>bytea</type>, <parameter>bytes</parameter> <type>bytea</type>)</function></literal>
       </entry>
       <entry><type>bytea</type></entry>
       <entry>
<!--
        Remove the longest string consisting only of bytes
        in <parameter>bytes</parameter> from the start and end of
        <parameter>string</parameter>
-->
<parameter>bytes</parameter>で指定されたバイトのみを有する最長の文字列を<parameter>string</parameter>の先頭と末尾から削除します。
      </entry>
      <entry><literal>btrim(E'\\000trim\\000'::bytea, E'\\000'::bytea)</literal></entry>
      <entry><literal>trim</literal></entry>
     </row>

     <row>
      <entry>
        <indexterm>
         <primary>decode</primary>
        </indexterm>
       <literal><function>decode(<parameter>string</parameter> <type>text</type>,
       <parameter>format</parameter> <type>text</type>)</function></literal>
      </entry>
      <entry><type>bytea</type></entry>
      <entry>
<!--
       Decode binary data from textual representation in <parameter>string</>.
       Options for <parameter>format</> are same as in <function>encode</>.
-->
<parameter>string</>で表現されているテキストデータをバイナリデータに復号化します。
<parameter>format</>のオプションは<function>encode</>と同じです。
      </entry>
      <entry><literal>decode(E'123\\000456', 'escape')</literal></entry>
      <entry><literal>123\000456</literal></entry>
     </row>

     <row>
      <entry>
        <indexterm>
         <primary>encode</primary>
        </indexterm>
       <literal><function>encode(<parameter>data</parameter> <type>bytea</type>,
       <parameter>format</parameter> <type>text</type>)</function></literal>
      </entry>
      <entry><type>text</type></entry>
      <entry>
<!--
       Encode binary data into a textual representation.  Supported
       formats are: <literal>base64</>, <literal>hex</>, <literal>escape</>.
       <literal>escape</> converts zero bytes and high-bit-set bytes to
       octal sequences (<literal>\</><replaceable>nnn</>) and
       doubles backslashes.
-->
バイナリデータをテキスト表現形式に符号化します。
サポートされている形式は、<literal>base64</>、<literal>hex</>、<literal>escape</>です。
<literal>escape</>は0バイトと最上位ビットがセットされているバイトを8進数のシーケンス(<literal>\</><replaceable>nnn</>)に変換し 、バックスラッシュを二重化します。
      </entry>
      <entry><literal>encode(E'123\\000456'::bytea, 'escape')</literal></entry>
      <entry><literal>123\000456</literal></entry>
     </row>

      <row>
       <entry>
        <indexterm>
         <primary>get_bit</primary>
        </indexterm>
        <literal><function>get_bit(<parameter>string</parameter>, <parameter>offset</parameter>)</function></literal>
       </entry>
       <entry><type>int</type></entry>
       <entry>
<!--
        Extract bit from string
-->
        文字列から1ビット抽出します。
       </entry>
       <entry><literal>get_bit(E'Th\\000omas'::bytea, 45)</literal></entry>
       <entry><literal>1</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>get_byte</primary>
        </indexterm>
        <literal><function>get_byte(<parameter>string</parameter>, <parameter>offset</parameter>)</function></literal>
       </entry>
       <entry><type>int</type></entry>
       <entry>
<!--
        Extract byte from string
-->
        文字列から1バイト抽出します。
       </entry>
       <entry><literal>get_byte(E'Th\\000omas'::bytea, 4)</literal></entry>
       <entry><literal>109</literal></entry>
      </row>

     <row>
      <entry>
       <indexterm>
        <primary>length</primary>
       </indexterm>
       <literal><function>length(<parameter>string</parameter>)</function></literal>
      </entry>
      <entry><type>int</type></entry>
      <entry>
<!--
       Length of binary string
-->
       バイナリ文字列の長さ
       <indexterm>
<!--
        <primary>binary string</primary>
        <secondary>length</secondary>
-->
        <primary>バイナリ文字列</primary>
        <secondary>長さ</secondary>
       </indexterm>
       <indexterm>
<!--
        <primary>length</primary>
        <secondary sortas="binary string">of a binary string</secondary>
        <see>binary strings, length</see>
-->
        <primary>長さ</primary>
        <secondary sortas="binary string">バイナリ文字列の</secondary>
        <see>バイナリ文字列、長さ</see>
       </indexterm>
      </entry>
      <entry><literal>length(E'jo\\000se'::bytea)</literal></entry>
      <entry><literal>5</literal></entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>md5</primary>
       </indexterm>
       <literal><function>md5(<parameter>string</parameter>)</function></literal>
      </entry>
      <entry><type>text</type></entry>
      <entry>
<!--
       Calculates the MD5 hash of <parameter>string</parameter>,
       returning the result in hexadecimal
-->
       <parameter>string</parameter>のMD5のハッシュを計算し、結果を16進数で返します。
      </entry>
      <entry><literal>md5(E'Th\\000omas'::bytea)</literal></entry>
      <entry><literal>8ab2d3c9689aaf18 b4958c334c82d8b1</literal></entry>
     </row>

      <row>
       <entry>
        <indexterm>
         <primary>set_bit</primary>
        </indexterm>
        <literal><function>set_bit(<parameter>string</parameter>,
        <parameter>offset</parameter>, <parameter>newvalue</>)</function></literal>
       </entry>
       <entry><type>bytea</type></entry>
       <entry>
<!--
        Set bit in string
-->
        文字列内のビットを設定します。
       </entry>
       <entry><literal>set_bit(E'Th\\000omas'::bytea, 45, 0)</literal></entry>
       <entry><literal>Th\000omAs</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>set_byte</primary>
        </indexterm>
        <literal><function>set_byte(<parameter>string</parameter>,
        <parameter>offset</parameter>, <parameter>newvalue</>)</function></literal>
       </entry>
       <entry><type>bytea</type></entry>
       <entry>
<!--
        Set byte in string
-->
        文字列内の1バイトを設定します。
       </entry>
       <entry><literal>set_byte(E'Th\\000omas'::bytea, 4, 64)</literal></entry>
       <entry><literal>Th\000o@as</literal></entry>
      </row>
    </tbody>
   </tgroup>
  </table>

  <para>
<!--
   <function>get_byte</> and <function>set_byte</> number the first byte
   of a binary string as byte 0.
   <function>get_bit</> and <function>set_bit</> number bits from the
   right within each byte; for example bit 0 is the least significant bit of
   the first byte, and bit 15 is the most significant bit of the second byte.
-->
<function>get_byte</>と<function>set_byte</>はバイナリ列の先頭バイトを0バイトとして数えます。
<function>get_bit</>と<function>set_bit</>は各バイト内を右からビットを数えます。例えばビット0は先頭バイトの最下位ビットとなり、ビット15は第二バイトの最上位ビットとなります。
  </para>

  <para>
<!--
   See also the aggregate function <function>string_agg</function> in
   <xref linkend="functions-aggregate"> and the large object functions
   in <xref linkend="lo-funcs">.
-->
<xref linkend="functions-aggregate">における<function>string_agg</function>集約関数や<xref linkend="lo-funcs">のラージオブジェクト関数も参照してください。
  </para>
 </sect1>


  <sect1 id="functions-bitstring">
<!--
   <title>Bit String Functions and Operators</title>
-->
   <title>ビット文字列関数と演算子</title>

   <indexterm zone="functions-bitstring">
<!--
    <primary>bit strings</primary>
    <secondary>functions</secondary>
-->
    <primary>ビット文字列</primary>
    <secondary>関数</secondary>
   </indexterm>

   <para>
<!--
    This section describes functions and operators for examining and
    manipulating bit strings, that is values of the types
    <type>bit</type> and <type>bit varying</type>.  Aside from the
    usual comparison operators, the operators
    shown in <xref linkend="functions-bit-string-op-table"> can be used.
    Bit string operands of <literal>&amp;</literal>, <literal>|</literal>,
    and <literal>#</literal> must be of equal length.  When bit
    shifting, the original length of the string is preserved, as shown
    in the examples.
-->
本節では、ビット文字列の検査と操作を行う関数と演算子について説明します。ビット文字列とは、<type>bit</type>型と<type>bit varying</type>型の値のことです。
通常の比較演算子に加え、<xref linkend="functions-bit-string-op-table">に示す演算子も使用可能です。
<literal>&amp;</literal>、<literal>|</literal>、<literal>#</literal>のビット文字列オペランドは同一長でなければなりません。
ビットシフト処理の際、例に示す通り元の長さは保持されます。
   </para>

   <table id="functions-bit-string-op-table">
<!--
    <title>Bit String Operators</title>
-->
    <title>ビット文字列演算子</title>

    <tgroup cols="4">
     <thead>
      <row>
<!--
       <entry>Operator</entry>
       <entry>Description</entry>
       <entry>Example</entry>
       <entry>Result</entry>
-->
       <entry>演算子</entry>
       <entry>説明</entry>
       <entry>例</entry>
       <entry>結果</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry> <literal>||</literal> </entry>
<!--
       <entry>concatenation</entry>
-->
       <entry>結合</entry>
       <entry><literal>B'10001' || B'011'</literal></entry>
       <entry><literal>10001011</literal></entry>
      </row>

      <row>
       <entry> <literal>&amp;</literal> </entry>
<!--
       <entry>bitwise AND</entry>
-->
       <entry>ビットのAND</entry>
       <entry><literal>B'10001' &amp; B'01101'</literal></entry>
       <entry><literal>00001</literal></entry>
      </row>

      <row>
       <entry> <literal>|</literal> </entry>
<!--
       <entry>bitwise OR</entry>
-->
       <entry>ビットのOR</entry>
       <entry><literal>B'10001' | B'01101'</literal></entry>
       <entry><literal>11101</literal></entry>
      </row>

      <row>
       <entry> <literal>#</literal> </entry>
<!--
       <entry>bitwise XOR</entry>
-->
       <entry>ビットのXOR</entry>
       <entry><literal>B'10001' # B'01101'</literal></entry>
       <entry><literal>11100</literal></entry>
      </row>

      <row>
       <entry> <literal>~</literal> </entry>
<!--
       <entry>bitwise NOT</entry>
-->
       <entry>ビットのNOT</entry>
       <entry><literal>~ B'10001'</literal></entry>
       <entry><literal>01110</literal></entry>
      </row>

      <row>
       <entry> <literal>&lt;&lt;</literal> </entry>
<!--
       <entry>bitwise shift left</entry>
-->
       <entry>ビットの左シフト</entry>
       <entry><literal>B'10001' &lt;&lt; 3</literal></entry>
       <entry><literal>01000</literal></entry>
      </row>

      <row>
       <entry> <literal>&gt;&gt;</literal> </entry>
<!--
       <entry>bitwise shift right</entry>
-->
       <entry>ビットの右シフト</entry>
       <entry><literal>B'10001' &gt;&gt; 2</literal></entry>
       <entry><literal>00100</literal></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
<!--
    The following <acronym>SQL</acronym>-standard functions work on bit
    strings as well as character strings:
    <literal><function>length</function></literal>,
    <literal><function>bit_length</function></literal>,
    <literal><function>octet_length</function></literal>,
    <literal><function>position</function></literal>,
    <literal><function>substring</function></literal>,
    <literal><function>overlay</function></literal>.
-->
次の標準<acronym>SQL</acronym>関数は文字列同様にビット文字列で動作します。
    <literal><function>length</function></literal>、
    <literal><function>bit_length</function></literal>、
    <literal><function>octet_length</function></literal>、
    <literal><function>position</function></literal>、
    <literal><function>substring</function></literal>、
    <literal><function>overlay</function></literal>。
   </para>

   <para>
<!--
    The following functions work on bit strings as well as binary
    strings:
    <literal><function>get_bit</function></literal>,
    <literal><function>set_bit</function></literal>.
-->
次の関数はバイナリ同様にビット文字列で動作します。
    <literal><function>get_bit</function></literal>、
    <literal><function>set_bit</function></literal>。
<!--
    When working with a bit string, these functions number the first
    (leftmost) bit of the string as bit 0.
-->
ビット文字列に処理を行った場合、これらの関数は文字列の最初(一番左)のビットを0として数えます。
   </para>

   <para>
<!--
    In addition, it is possible to cast integral values to and from type
    <type>bit</>.
    Some examples:
-->
さらに、<type>bit</>型から整数値にキャストすることも整数から<type>bit</>型にキャストすることも可能です。
以下に例を示します。
<programlisting>
44::bit(10)                    <lineannotation>0000101100</lineannotation>
44::bit(3)                     <lineannotation>100</lineannotation>
cast(-44 as bit(12))           <lineannotation>111111010100</lineannotation>
'1110'::bit(4)::integer        <lineannotation>14</lineannotation>
</programlisting>
<!--
    Note that casting to just <quote>bit</> means casting to
    <literal>bit(1)</>, and so will deliver only the least significant
    bit of the integer.
-->
単に<quote>bit</>にキャストすることは<literal>bit(1)</>にキャストすることを意味することに注意してください。つまり、単に整数の最下位ビットのみが渡されることになります。
   </para>

    <note>
     <para>
<!--
      Casting an integer to <type>bit(n)</> copies the rightmost
      <literal>n</> bits.  Casting an integer to a bit string width wider
      than the integer itself will sign-extend on the left.
-->
整数を<type>bit(n)</>にキャストすると、整数の最下位ビットから<literal>n</>ビット分複写されます。
整数からビット数が元の整数より多いビット文字列にキャストする際、符号ビットでその左部分を拡張します。
     </para>
    </note>

  </sect1>


 <sect1 id="functions-matching">
<!--
  <title>Pattern Matching</title>
-->
  <title>パターンマッチ</title>

  <indexterm zone="functions-matching">
<!--
   <primary>pattern matching</primary>
-->
   <primary>パターンマッチ</primary>
  </indexterm>

   <para>
<!--
    There are three separate approaches to pattern matching provided
    by <productname>PostgreSQL</productname>: the traditional
    <acronym>SQL</acronym> <function>LIKE</function> operator, the
    more recent <function>SIMILAR TO</function> operator (added in
    SQL:1999), and <acronym>POSIX</acronym>-style regular
    expressions.  Aside from the basic <quote>does this string match
    this pattern?</> operators, functions are available to extract
    or replace matching substrings and to split a string at matching
    locations.
-->
<productname>PostgreSQL</productname>には、パターンマッチを行うに際して3つの異なった手法があります。伝統的な<acronym>SQL</acronym>の<function>LIKE</function>演算子、これより新しい<function>SIMILAR TO</function>演算子（SQL:1999で追加されました）、および<acronym>POSIX</acronym>様式の正規表現です。
基本の<quote>この文字列はこのパターンに一致するか？</>を別としても、一致した部分文字列を取り出したり置換したり、そして一致部分で文字列を分割する関数が用意されています。
   </para>

   <tip>
    <para>
<!--
     If you have pattern matching needs that go beyond this,
     consider writing a user-defined function in Perl or Tcl.
-->
上記の手法では検索できないようなパターンマッチが必要な場合は、PerlもしくはTclでユーザ定義関数を作成することを検討してください。
    </para>
   </tip>

  <sect2 id="functions-like">
   <title><function>LIKE</function></title>

   <indexterm>
    <primary>LIKE</primary>
   </indexterm>

<synopsis>
<replaceable>string</replaceable> LIKE <replaceable>pattern</replaceable> <optional>ESCAPE <replaceable>escape-character</replaceable></optional>
<replaceable>string</replaceable> NOT LIKE <replaceable>pattern</replaceable> <optional>ESCAPE <replaceable>escape-character</replaceable></optional>
</synopsis>

    <para>
<!--
     The <function>LIKE</function> expression returns true if the
     <replaceable>string</replaceable> matches the supplied
     <replaceable>pattern</replaceable>.  (As
     expected, the <function>NOT LIKE</function> expression returns
     false if <function>LIKE</function> returns true, and vice versa.
     An equivalent expression is
     <literal>NOT (<replaceable>string</replaceable> LIKE
      <replaceable>pattern</replaceable>)</literal>.)
-->
<function>LIKE</function>式は供給された<replaceable>pattern</replaceable>に<replaceable>string</replaceable>が一致すれば真を返します。
（想像される通り、<function>NOT LIKE</function>式は<function>LIKE</function>式が真を返す場合には偽を返し、その逆もまた同じです。
同等の式として<literal>NOT (<replaceable>string</replaceable> LIKE <replaceable>pattern</replaceable>)</literal>とも表現できます。）
    </para>

    <para>
<!--
     If <replaceable>pattern</replaceable> does not contain percent
     signs or underscores, then the pattern only represents the string
     itself; in that case <function>LIKE</function> acts like the
     equals operator.  An underscore (<literal>_</literal>) in
     <replaceable>pattern</replaceable> stands for (matches) any single
     character; a percent sign (<literal>%</literal>) matches any sequence
     of zero or more characters.
-->
<replaceable>pattern</replaceable>がパーセント記号もしくはアンダースコアを含んでいない場合patternは自身の文字列そのものです。この場合<function>LIKE</function>式は等号演算子のように振舞います。
<replaceable>pattern</replaceable>の中にあるアンダースコア（<literal>_</literal>）は任意の一文字との一致を意味し、パーセント記号（<literal>%</literal>）は0文字以上の並びとの一致を意味します。
    </para>

   <para>
<!--
    Some examples:
-->
例：
<programlisting>
'abc' LIKE 'abc'    <lineannotation>true</lineannotation>
'abc' LIKE 'a%'     <lineannotation>true</lineannotation>
'abc' LIKE '_b_'    <lineannotation>true</lineannotation>
'abc' LIKE 'c'      <lineannotation>false</lineannotation>
</programlisting>
   </para>

   <para>
<!--
    <function>LIKE</function> pattern matching always covers the entire
    string.  Therefore, if it's desired to match a sequence anywhere within
    a string, the pattern must start and end with a percent sign.
-->
<function>LIKE</function>によるパターン一致は常に文字列全体に対して行われます。
従って、文字列内の任意位置における並びと一致させたい場合には、パーセント記号を先頭と末尾に付ける必要があります。
   </para>

   <para>
<!--
    To match a literal underscore or percent sign without matching
    other characters, the respective character in
    <replaceable>pattern</replaceable> must be
    preceded by the escape character.  The default escape
    character is the backslash but a different one can be selected by
    using the <literal>ESCAPE</literal> clause.  To match the escape
    character itself, write two escape characters.
-->
他の文字の一致に使用するのではなく、アンダースコアやパーセント記号そのものを一致させたい場合には、<replaceable>pattern</replaceable>の中のそれぞれのアンダースコアとパーセント記号の前にエスケープ文字を付けなければなりません。
デフォルトのエスケープ文字はバックスラッシュですが、<literal>ESCAPE</literal>句で他の文字を指定することができます。エスケープ文字そのものを一致させるにはエスケープ文字を2つ書きます。
   </para>

   <note>
    <para>
<!--
     If you have <xref linkend="guc-standard-conforming-strings"> turned off,
     any backslashes you write in literal string constants will need to be
     doubled.  See <xref linkend="sql-syntax-strings"> for more information.
-->
もし<xref linkend="guc-standard-conforming-strings">パラメータをoffにしていた場合、リテラル文字列定数に記述するバックスラッシュは2倍必要となります。
詳細は<xref linkend="sql-syntax-strings">を参照してください。
    </para>
   </note>

   <para>
<!--
    It's also possible to select no escape character by writing
    <literal>ESCAPE ''</literal>.  This effectively disables the
    escape mechanism, which makes it impossible to turn off the
    special meaning of underscore and percent signs in the pattern.
-->
同時に<literal>ESCAPE ''</literal>と記述することでエスケープ文字を選択しないことも可能です。
これにより、事実上エスケープ機構が働かなくなります。つまり、パターン内のアンダースコアおよびパーセント記号の特別な意味を解除することはできなくなります。
   </para>

   <para>
<!--
    The key word <token>ILIKE</token> can be used instead of
    <token>LIKE</token> to make the match case-insensitive according
    to the active locale.  This is not in the <acronym>SQL</acronym> standard but is a
    <productname>PostgreSQL</productname> extension.
-->
現在のロケールに従って大文字小文字を区別しない一致を行うのであれば、<token>LIKE</token>の代わりに<token>ILIKE</token>キーワードを使うことができます。
これは標準<acronym>SQL</acronym>ではなく、<productname>PostgreSQL</productname>の拡張です。
   </para>

   <para>
<!--
    The operator <literal>~~</literal> is equivalent to
    <function>LIKE</function>, and <literal>~~*</literal> corresponds to
    <function>ILIKE</function>.  There are also
    <literal>!~~</literal> and <literal>!~~*</literal> operators that
    represent <function>NOT LIKE</function> and <function>NOT
    ILIKE</function>, respectively.  All of these operators are
    <productname>PostgreSQL</productname>-specific.
-->
<literal>~~</literal>演算子は<function>LIKE</function>式と等価で、<literal>~~*</literal>は<function>ILIKE</function>に対応します。
また<function>NOT LIKE</function>および<function>NOT ILIKE</function>を表す<literal>!~~</literal>および<literal>!~~*</literal>演算子があります。
これら全ての演算子は<productname>PostgreSQL</productname>固有のものです。
   </para>
  </sect2>


  <sect2 id="functions-similarto-regexp">
<!--
   <title><function>SIMILAR TO</function> Regular Expressions</title>
-->
   <title><function>SIMILAR TO</function>正規表現</title>

   <indexterm>
<!--
    <primary>regular expression</primary>
-->
    <primary>正規表現</primary>
    <!-- 原文コメント <seealso>pattern matching</seealso> breaks index build -->
   </indexterm>

   <indexterm>
    <primary>SIMILAR TO</primary>
   </indexterm>
   <indexterm>
    <primary>substring</primary>
   </indexterm>

<synopsis>
<replaceable>string</replaceable> SIMILAR TO <replaceable>pattern</replaceable> <optional>ESCAPE <replaceable>escape-character</replaceable></optional>
<replaceable>string</replaceable> NOT SIMILAR TO <replaceable>pattern</replaceable> <optional>ESCAPE <replaceable>escape-character</replaceable></optional>
</synopsis>

   <para>
<!--
    The <function>SIMILAR TO</function> operator returns true or
    false depending on whether its pattern matches the given string.
    It is similar to <function>LIKE</function>, except that it
    interprets the pattern using the SQL standard's definition of a
    regular expression.  SQL regular expressions are a curious cross
    between <function>LIKE</function> notation and common regular
    expression notation.
-->
<function>SIMILAR TO</function>演算子は、そのパターンが与えられた文字列に一致するかどうかにより、真もしくは偽を返します。
これは、標準SQLの正規表現定義を使用してパターンを解釈するという点以外は、<function>LIKE</function>に類似しています。
SQLの正規表現は、<function>LIKE</function>表記と一般的な正規表現の表記とを混ぜ合わせたようなものになっています。
   </para>

   <para>
<!--
    Like <function>LIKE</function>, the <function>SIMILAR TO</function>
    operator succeeds only if its pattern matches the entire string;
    this is unlike common regular expression behavior where the pattern
    can match any part of the string.
    Also like
    <function>LIKE</function>, <function>SIMILAR TO</function> uses
    <literal>_</> and <literal>%</> as wildcard characters denoting
    any single character and any string, respectively (these are
    comparable to <literal>.</> and <literal>.*</> in POSIX regular
    expressions).
-->
<function>LIKE</function>と同様、<function>SIMILAR TO</function>演算子は、そのパターンが文字列全体に一致した場合のみ処理を行います。これは、パターンが文字列の一部分であっても一致する、一般的な正規表現の動作とは異なっています。
また、<function>LIKE</function>と同様、<function>SIMILAR TO</function>では、<literal>%</>および<literal>_</>を、それぞれ任意の文字列および任意の単一文字を意味するワイルドカード文字として使用します（これらは、POSIX正規表現での<literal>.*</>および<literal>.</>に相当します）。
   </para>

   <para>
<!--
    In addition to these facilities borrowed from <function>LIKE</function>,
    <function>SIMILAR TO</function> supports these pattern-matching
    metacharacters borrowed from POSIX regular expressions:
-->
<function>LIKE</function>から取り入れた上記の機能に加え、<function>SIMILAR TO</function>では、以下のようにPOSIX正規表現から取り入れたパターンマッチメタ文字もサポートしています。

   <itemizedlist>
    <listitem>
     <para>
<!--
      <literal>|</literal> denotes alternation (either of two alternatives).
-->
<literal>|</literal>は、二者択一（2つの選択肢のうちいずれか）を意味します。
     </para>
    </listitem>
    <listitem>
     <para>
<!--
      <literal>*</literal> denotes repetition of the previous item zero
      or more times.
-->
<literal>*</literal>は、直前の項目の0回以上複数の繰り返しを意味します。
     </para>
    </listitem>
    <listitem>
     <para>
<!--
      <literal>+</literal> denotes repetition of the previous item one
      or more times.
-->
<literal>+</literal>は、直前の項目の1回以上複数の繰り返しを意味します。
     </para>
    </listitem>
    <listitem>
     <para>
<!--
      <literal>?</literal> denotes repetition of the previous item zero
      or one time.
-->
<literal>?</literal>は、直前の項目の0回もしくは1回の繰り返しを意味します。
     </para>
    </listitem>
    <listitem>
     <para>
<!--
      <literal>{</><replaceable>m</><literal>}</literal> denotes repetition
      of the previous item exactly <replaceable>m</> times.
-->
<literal>{</><replaceable>m</><literal>}</literal>は、直前の項目の正確な<replaceable>m</>回の繰り返しを意味します。
     </para>
    </listitem>
    <listitem>
     <para>
<!--
      <literal>{</><replaceable>m</><literal>,}</literal> denotes repetition
      of the previous item <replaceable>m</> or more times.
-->
      <literal>{</><replaceable>m</><literal>,}</literal>は、直前の項目の<replaceable>m</>回以上の繰り返しを意味します。
     </para>
    </listitem>
    <listitem>
     <para>
<!--
      <literal>{</><replaceable>m</><literal>,</><replaceable>n</><literal>}</>
      denotes repetition of the previous item at least <replaceable>m</> and
      not more than <replaceable>n</> times.
-->
<literal>{</><replaceable>m</><literal>,</><replaceable>n</><literal>}</>は、直前の項目の<replaceable>m</>回以上かつ<replaceable>n</>回以下の繰り返しを意味します。
     </para>
    </listitem>
    <listitem>
     <para>
<!--
      Parentheses <literal>()</literal> can be used to group items into
      a single logical item.
-->
丸括弧<literal>()</literal>は、項目を1つの論理項目にグループ化することができます。 
     </para>
    </listitem>
    <listitem>
     <para>
<!--
      A bracket expression <literal>[...]</literal> specifies a character
      class, just as in POSIX regular expressions.
-->
大括弧式<literal>[...]</literal>は、POSIX正規表現と同様に文字クラスを指定します。
     </para>
    </listitem>
   </itemizedlist>

<!--
    Notice that the period (<literal>.</>) is not a metacharacter
    for <function>SIMILAR TO</>.
-->
<function>SIMILAR TO</>ではピリオド（<literal>.</>）はメタ文字ではないことに注意してください。
   </para>

   <para>
<!--
    As with <function>LIKE</>, a backslash disables the special meaning
    of any of these metacharacters; or a different escape character can
    be specified with <literal>ESCAPE</>.
-->
<function>LIKE</>と同様、バックスラッシュは全てのメタ文字の特殊な意味を無効にします。
また、異なるエスケープ文字を<literal>ESCAPE</>で指定することが可能です。
   </para>

   <para>
<!--
    Some examples:
-->
例：
<programlisting>
'abc' SIMILAR TO 'abc'      <lineannotation>true</lineannotation>
'abc' SIMILAR TO 'a'        <lineannotation>false</lineannotation>
'abc' SIMILAR TO '%(b|d)%'  <lineannotation>true</lineannotation>
'abc' SIMILAR TO '(b|c)%'   <lineannotation>false</lineannotation>
</programlisting>
   </para>

   <para>
<!--
    The <function>substring</> function with three parameters,
    <function>substring(<replaceable>string</replaceable> from
    <replaceable>pattern</replaceable> for
    <replaceable>escape-character</replaceable>)</function>, provides
    extraction of a substring that matches an SQL
    regular expression pattern.  As with <literal>SIMILAR TO</>, the
    specified pattern must match the entire data string, or else the
    function fails and returns null.  To indicate the part of the
    pattern that should be returned on success, the pattern must contain
    two occurrences of the escape character followed by a double quote
    (<literal>"</>). <!&#045;- 原文コメント " font-lock sanity &#045;->
    The text matching the portion of the pattern
    between these markers is returned.
-->
3つのパラメータを持つ<function>substring</>関数、<function>substring(<parameter>string</parameter> from <replaceable>pattern</replaceable> for <replaceable>escape-character</replaceable>)</function>を使用して、SQL正規表現パターンに一致する部分文字列を取り出すことができます。
<literal>SIMILAR TO</>と同様、指定したパターンがデータ文字列全体に一致する必要があります。一致しない場合、関数は終了し、NULLを返します。一致した場合に返されるべきパターンの一部を示すために、エスケープ文字の後に二重引用符（<literal>"</>）を繋げたものを2つパターンに含める必要があります。<!-- " font-lock sanity -->
これらの印で括られたパターンの一部に一致するテキストが返されます。
   </para>

   <para>
<!--
    Some examples, with <literal>#&quot;</> delimiting the return string:
-->
例：<literal>#&quot;</>を使用して返される文字列を区切ります。
<programlisting>
substring('foobar' from '%#"o_b#"%' for '#')   <lineannotation>oob</lineannotation>
substring('foobar' from '#"o_b#"%' for '#')    <lineannotation>NULL</lineannotation>
</programlisting>
   </para>
  </sect2>

  <sect2 id="functions-posix-regexp">
<!--
   <title><acronym>POSIX</acronym> Regular Expressions</title>
-->
   <title><acronym>POSIX</acronym>正規表現</title>

   <indexterm zone="functions-posix-regexp">
<!--
    <primary>regular expression</primary>
    <seealso>pattern matching</seealso>
-->
    <primary>正規表現</primary>
    <seealso>パターンマッチ</seealso>
   </indexterm>
   <indexterm>
    <primary>substring</primary>
   </indexterm>
   <indexterm>
    <primary>regexp_replace</primary>
   </indexterm>
   <indexterm>
    <primary>regexp_matches</primary>
   </indexterm>
   <indexterm>
    <primary>regexp_split_to_table</primary>
   </indexterm>
   <indexterm>
    <primary>regexp_split_to_array</primary>
   </indexterm>

   <para>
<!--
    <xref linkend="functions-posix-table"> lists the available
    operators for pattern matching using POSIX regular expressions.
-->
<xref linkend="functions-posix-table">に、POSIX正規表現を使ったパターン一致に使用可能な演算子を列挙します。
   </para>

   <table id="functions-posix-table">
<!--
    <title>Regular Expression Match Operators</title>
-->
    <title>正規表現マッチ演算子</title>

    <tgroup cols="3">
     <thead>
      <row>
<!--
       <entry>Operator</entry>
       <entry>Description</entry>
       <entry>Example</entry>
-->
       <entry>演算子</entry>
       <entry>説明</entry>
       <entry>例</entry>
      </row>
     </thead>

      <tbody>
       <row>
        <entry> <literal>~</literal> </entry>
<!--
        <entry>Matches regular expression, case sensitive</entry>
-->
        <entry>正規表現に一致、大文字小文字の区別あり</entry>
        <entry><literal>'thomas' ~ '.*thomas.*'</literal></entry>
       </row>

       <row>
        <entry> <literal>~*</literal> </entry>
<!--
        <entry>Matches regular expression, case insensitive</entry>
-->
        <entry>正規表現に一致、大文字小文字の区別なし</entry>
        <entry><literal>'thomas' ~* '.*Thomas.*'</literal></entry>
       </row>

       <row>
        <entry> <literal>!~</literal> </entry>
<!--
        <entry>Does not match regular expression, case sensitive</entry>
-->
        <entry>正規表現に一致しない、大文字小文字の区別あり</entry>
        <entry><literal>'thomas' !~ '.*Thomas.*'</literal></entry>
       </row>

       <row>
        <entry> <literal>!~*</literal> </entry>
<!--
        <entry>Does not match regular expression, case insensitive</entry>
-->
        <entry>正規表現に一致しない、大文字小文字の区別なし</entry>
        <entry><literal>'thomas' !~* '.*vadim.*'</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

    <para>
<!--
     <acronym>POSIX</acronym> regular expressions provide a more
     powerful means for pattern matching than the <function>LIKE</function> and
     <function>SIMILAR TO</> operators.
     Many Unix tools such as <command>egrep</command>,
     <command>sed</command>, or <command>awk</command> use a pattern
     matching language that is similar to the one described here.
-->
<acronym>POSIX</acronym>正規表現は、パターンマッチという意味合いでは、<function>LIKE</function>および<function>SIMILAR TO</>演算子よりもさらに強力です。
<command>egrep</command>、<command>sed</command>、あるいは<command>awk</command>のような多くのUnixツールはここで解説しているのと類似したパターンマッチ言語を使用しています。
    </para>

    <para>
<!--
     A regular expression is a character sequence that is an
     abbreviated definition of a set of strings (a <firstterm>regular
     set</firstterm>).  A string is said to match a regular expression
     if it is a member of the regular set described by the regular
     expression.  As with <function>LIKE</function>, pattern characters
     match string characters exactly unless they are special characters
     in the regular expression language &mdash; but regular expressions use
     different special characters than <function>LIKE</function> does.
     Unlike <function>LIKE</function> patterns, a
     regular expression is allowed to match anywhere within a string, unless
     the regular expression is explicitly anchored to the beginning or
     end of the string.
-->
正規表現とは文字列の集合（<firstterm>正規集合</firstterm>）の簡略された定義である文字が連なっているものです。
ある文字列が正規表現で記述された正規集合の要素になっていれば、その文字列は正規表現に一致していると呼ばれます。
<function>LIKE</function>と同様、正規表現言語で特殊文字とされているもの以外、パターン文字は文字列と完全に一致されます。とは言っても、正規表現は<function>LIKE</function>関数が使用するのとは異なる特殊文字を使用します。
<function>LIKE</function>関数のパターンと違って正規表現は、明示的に正規表現が文字列の最初または最後からと位置指定されていない限り文字列内のどの位置でも一致を行えます。
    </para>

    <para>
<!--
     Some examples:
-->
例：
<programlisting>
'abc' ~ 'abc'    <lineannotation>true</lineannotation>
'abc' ~ '^a'     <lineannotation>true</lineannotation>
'abc' ~ '(b|d)'  <lineannotation>true</lineannotation>
'abc' ~ '^(b|c)' <lineannotation>false</lineannotation>
</programlisting>
    </para>

    <para>
<!--
     The <acronym>POSIX</acronym> pattern language is described in much
     greater detail below.
-->
<acronym>POSIX</acronym>パターン言語について以下により詳しく説明します。
    </para>

    <para>
<!--
     The <function>substring</> function with two parameters,
     <function>substring(<replaceable>string</replaceable> from
     <replaceable>pattern</replaceable>)</function>, provides extraction of a
     substring
     that matches a POSIX regular expression pattern.  It returns null if
     there is no match, otherwise the portion of the text that matched the
     pattern.  But if the pattern contains any parentheses, the portion
     of the text that matched the first parenthesized subexpression (the
     one whose left parenthesis comes first) is
     returned.  You can put parentheses around the whole expression
     if you want to use parentheses within it without triggering this
     exception.  If you need parentheses in the pattern before the
     subexpression you want to extract, see the non-capturing parentheses
     described below.
-->
2つのパラメータを持つ<function>substring</>関数、<function>substring(<parameter>string</parameter> from <replaceable>pattern</replaceable>)</function>を使用して、POSIX正規表現パターンに一致する部分文字列を取り出すことができます。
この関数は、一致するものがない場合にはNULLを返し、ある場合はパターンにマッチしたテキストの一部を返します。
しかし、任意の丸括弧を持つパターンの場合、最初の丸括弧内部分正規表現（左丸括弧が最初に来るもの）に一致するテキストの一部が返されます。
この例外を起こさずにパターン中に丸括弧を使用したいのであれば、常に正規表現全体を丸括弧で囲むことができます。
パターン内の抽出対象の部分文字列より前に丸括弧が必要な場合、後述の捕捉されない丸括弧を参照してください。
    </para>

   <para>
<!--
    Some examples:
-->
例：
<programlisting>
substring('foobar' from 'o.b')     <lineannotation>oob</lineannotation>
substring('foobar' from 'o(.)b')   <lineannotation>o</lineannotation>
</programlisting>
   </para>

    <para>
<!--
     The <function>regexp_replace</> function provides substitution of
     new text for substrings that match POSIX regular expression patterns.
     It has the syntax
     <function>regexp_replace</function>(<replaceable>source</>,
     <replaceable>pattern</>, <replaceable>replacement</>
     <optional>, <replaceable>flags</> </optional>).
     The <replaceable>source</> string is returned unchanged if
     there is no match to the <replaceable>pattern</>.  If there is a
     match, the <replaceable>source</> string is returned with the
     <replaceable>replacement</> string substituted for the matching
     substring.  The <replaceable>replacement</> string can contain
     <literal>\</><replaceable>n</>, where <replaceable>n</> is 1
     through 9, to indicate that the source substring matching the
     <replaceable>n</>'th parenthesized subexpression of the pattern should be
     inserted, and it can contain <literal>\&amp;</> to indicate that the
     substring matching the entire pattern should be inserted.  Write
     <literal>\\</> if you need to put a literal backslash in the replacement
     text.
     The <replaceable>flags</> parameter is an optional text
     string containing zero or more single-letter flags that change the
     function's behavior.  Flag <literal>i</> specifies case-insensitive
     matching, while flag <literal>g</> specifies replacement of each matching
     substring rather than only the first one.  Supported flags (though
     not <literal>g</>) are
     described in <xref linkend="posix-embedded-options-table">.
-->
<function>regexp_replace</>関数は、POSIX正規表現パターンに一致する部分文字列を新規テキストと置換します。
構文は、<function>regexp_replace</function>（<replaceable>source</>、<replaceable>pattern</>、<replaceable>replacement</> <optional>、<replaceable>flags</> </optional>）です。
<replaceable>pattern</>にマッチしない場合は、<replaceable>source</>文字列がそのまま返されます。
一致すると、マッチ部分文字列を<replaceable>replacement</>文字列で置換した<replaceable>source</>文字列が返されます。
<replaceable>replacement</>は<literal>\</><replaceable>n</>を含むことができます。
ここで<replaceable>n</>は、<replaceable>n</>番目に丸括弧で括られたパターンの部分表現に一致する元の部分文字列を示す、1から9までの数です。
<literal>\&amp;</>が含まれた場合、パターン全体と一致する部分文字列が挿入されることを示します。
置換テキスト内にバックスラッシュそのものを挿入する必要がある時は<literal>\\</>と記述します。
<replaceable>flags</>パラメータは、関数の動作を変更するゼロもしくはそれ以上の1文字フラグを含むオプションのテキスト文字列です。フラグ<literal>i</>は大文字小文字を区別しない一致を指定する一方、フラグ<literal>g</>は、最初に一致したもののみではなく、それぞれ一致した部分文字列の置換を指定します。
有効なフラグは(<literal>g</>はそうではありませんが)<xref linkend="posix-embedded-options-table">に記述されています。
    </para>

   <para>
<!--
    Some examples:
-->
    例：
<programlisting>
regexp_replace('foobarbaz', 'b..', 'X')
                                   <lineannotation>fooXbaz</lineannotation>
regexp_replace('foobarbaz', 'b..', 'X', 'g')
                                   <lineannotation>fooXX</lineannotation>
regexp_replace('foobarbaz', 'b(..)', E'X\\1Y', 'g')
                                   <lineannotation>fooXarYXazY</lineannotation>
</programlisting>
   </para>

    <para>
<!--
     The <function>regexp_matches</> function returns a text array of
     all of the captured substrings resulting from matching a POSIX
     regular expression pattern.  It has the syntax
     <function>regexp_matches</function>(<replaceable>string</>, <replaceable>pattern</>
     <optional>, <replaceable>flags</> </optional>).
     The function can return no rows, one row, or multiple rows (see
     the <literal>g</> flag below).  If the <replaceable>pattern</>
     does not match, the function returns no rows.  If the pattern
     contains no parenthesized subexpressions, then each row
     returned is a single-element text array containing the substring
     matching the whole pattern.  If the pattern contains parenthesized
     subexpressions, the function returns a text array whose
     <replaceable>n</>'th element is the substring matching the
     <replaceable>n</>'th parenthesized subexpression of the pattern
     (not counting <quote>non-capturing</> parentheses; see below for
     details).
     The <replaceable>flags</> parameter is an optional text
     string containing zero or more single-letter flags that change the
     function's behavior.  Flag <literal>g</> causes the function to find
     each match in the string, not only the first one, and return a row for
     each such match.  Supported flags (though
     not <literal>g</>)
     are described in <xref linkend="posix-embedded-options-table">.
-->
<function>regexp_matches</>関数はPOSIX正規表現パターンマッチの結果捕捉された全ての部分文字列のテキスト配列を返します。
<function>regexp_matches</function>(<replaceable>string</>, <replaceable>pattern</> <optional>, <replaceable>flags</> </optional>)の構文になります。
この関数は何も行を返さない、1行を返す、複数行を返すといったことができます。下記の<literal>g</>フラグを参照して下さい。
もし<replaceable>pattern</>に対して一致しない場合、関数は行を返しません。
もし、パターンが丸括弧に括られた部分文字列を含まない場合、結果はパターン全体に一致する部分文字列を含む単一要素のテキスト配列となります。
もし、パターンが丸括弧に括られた部分文字列を含む場合、関数はパターンの<replaceable>n</>番目に丸括弧で括られた部分文字列に一致する、<replaceable>n</>番目の要素が部分文字列であるテキスト配列を返します（<quote>捕捉されない</>丸括弧は数えません。詳細は下を見てください。）。
<replaceable>flags</>パラメータは、関数の動作を変更するゼロもしくは複数の単一文字フラグを含むオプションのテキスト文字列です。
フラグ<literal>g</>は関数に、最初のマッチだけでなく文字列の中で全てのマッチを検出させ、それら一致の行を返させます。
有効なフラグは(<literal>g</>はそうではありませんが)<xref linkend="posix-embedded-options-table">に記載されています。
    </para>

   <para>
<!--
    Some examples:
-->
例：
<programlisting>
SELECT regexp_matches('foobarbequebaz', '(bar)(beque)');
 regexp_matches 
----------------
 {bar,beque}
(1 row)

SELECT regexp_matches('foobarbequebazilbarfbonk', '(b[^b]+)(b[^b]+)', 'g');
 regexp_matches 
----------------
 {bar,beque}
 {bazil,barf}
(2 rows)

SELECT regexp_matches('foobarbequebaz', 'barbeque');
 regexp_matches 
----------------
 {barbeque}
(1 row)
</programlisting>
   </para>

   <para>
<!--
    It is possible to force <function>regexp_matches()</> to always
    return one row by using a sub-select;  this is particularly useful
    in a <literal>SELECT</> target list when you want all rows
    returned, even non-matching ones:
-->
副問い合わせを使用することで、<function>regexp_matches()</>が常に1行しか返さないように強制することが可能です。
これは、<literal>SELECT</>対象のリストに対し、マッチするものが無い場合であっても全ての行を返したい場合に特に有用です。
<programlisting>
SELECT col1, (SELECT regexp_matches(col2, '(bar)(beque)')) FROM tab;
</programlisting>
   </para>

    <para>
<!--
     The <function>regexp_split_to_table</> function splits a string using a POSIX
     regular expression pattern as a delimiter.  It has the syntax
     <function>regexp_split_to_table</function>(<replaceable>string</>, <replaceable>pattern</>
     <optional>, <replaceable>flags</> </optional>).
     If there is no match to the <replaceable>pattern</>, the function returns the
     <replaceable>string</>.  If there is at least one match, for each match it returns
     the text from the end of the last match (or the beginning of the string)
     to the beginning of the match.  When there are no more matches, it
     returns the text from the end of the last match to the end of the string.
     The <replaceable>flags</> parameter is an optional text string containing
     zero or more single-letter flags that change the function's behavior.
     <function>regexp_split_to_table</function> supports the flags described in
     <xref linkend="posix-embedded-options-table">.
-->
<function>regexp_split_to_table</>関数はPOSIX正規表現パターンを区切り文字として使用し、文字列を分割します。<function>regexp_split_to_table</function>(<replaceable>string</>, <replaceable>pattern</> <optional>, <replaceable>flags</> </optional>)の構文になります。
<replaceable>pattern</>に一致しない場合、関数は<replaceable>string</>を返します。
少なくともひとつの一致があれば、それぞれの一致に対して関数は最後のマッチの終わり（あるいは文字列の始め）から最初のマッチまでのテキストを返します。
もはやマッチしなくなると最後のマッチの終わりから文字列の最後までテキストを返します。
<replaceable>flags</>パラメータは、関数の動作を変更するゼロもしくは複数の単一文字フラグを含むオプションのテキスト文字列です。
<function>regexp_split_to_table</function>は<xref linkend="posix-embedded-options-table">で記載されているフラグをサポートします。
    </para>

    <para>
<!--
     The <function>regexp_split_to_array</> function behaves the same as
     <function>regexp_split_to_table</>, except that <function>regexp_split_to_array</>
     returns its result as an array of <type>text</>.  It has the syntax
     <function>regexp_split_to_array</function>(<replaceable>string</>, <replaceable>pattern</>
     <optional>, <replaceable>flags</> </optional>).
     The parameters are the same as for <function>regexp_split_to_table</>.
-->
<function>regexp_split_to_array</>関数は、<function>regexp_split_to_array</>がその結果を<type>text</>配列で返すことを除いて、<function>regexp_split_to_table</>と同じ動作をします。
<function>regexp_split_to_array</function>(<replaceable>string</>, <replaceable>pattern</> <optional>, <replaceable>flags</> </optional>)の構文になります。
    </para>

   <para>
<!--
    Some examples:
-->
例：
<programlisting>

SELECT foo FROM regexp_split_to_table('the quick brown fox jumps over the lazy dog', E'\\s+') AS foo;
  foo   
-------
 the    
 quick  
 brown  
 fox    
 jumps 
 over   
 the    
 lazy   
 dog    
(9 rows)

SELECT regexp_split_to_array('the quick brown fox jumps over the lazy dog', E'\\s+');
              regexp_split_to_array             
-----------------------------------------------
 {the,quick,brown,fox,jumps,over,the,lazy,dog}
(1 row)

SELECT foo FROM regexp_split_to_table('the quick brown fox', E'\\s*') AS foo;
 foo 
-----
 t         
 h         
 e         
 q         
 u         
 i         
 c         
 k         
 b         
 r         
 o         
 w         
 n         
 f         
 o         
 x         
(16 rows)
</programlisting>
   </para>

   <para>
<!--
    As the last example demonstrates, the regexp split functions ignore
    zero-length matches that occur at the start or end of the string
    or immediately after a previous match.  This is contrary to the strict
    definition of regexp matching that is implemented by
    <function>regexp_matches</>, but is usually the most convenient behavior
    in practice.  Other software systems such as Perl use similar definitions.
-->
最後の例が明らかにしているように、regexp分割関数は文字列の最初あるいは終わり、もしくは前のマッチの直後に発生する長さを持たないマッチを無視します。
<function>regexp_matches</>で実装されたregexpマッチの厳格な定義にこれは相容れませんが、実務上は最も使い勝手の良い動作です。
Perlのような他のソフトウェアシステムも似たような定義を使用します。
   </para>

<!-- derived from the re_syntax.n man page -->

   <sect3 id="posix-syntax-details">
<!--
    <title>Regular Expression Details</title>
-->
    <title>正規表現の詳細</title>

   <para>
<!--
    <productname>PostgreSQL</productname>'s regular expressions are implemented
    using a software package written by Henry Spencer.  Much of
    the description of regular expressions below is copied verbatim from his
    manual.
-->
<productname>PostgreSQL</productname>の正規表現はHenry Spencerにより書かれたソフトウェアパッケージを使用して実装されています。
以下に説明する正規表現の多くの部分は同氏のマニュアルから一字一句複製したものです。
   </para>

   <para>
<!--
    Regular expressions (<acronym>RE</acronym>s), as defined in
    <acronym>POSIX</acronym> 1003.2, come in two forms:
    <firstterm>extended</> <acronym>RE</acronym>s or <acronym>ERE</>s
    (roughly those of <command>egrep</command>), and
    <firstterm>basic</> <acronym>RE</acronym>s or <acronym>BRE</>s
    (roughly those of <command>ed</command>).
    <productname>PostgreSQL</productname> supports both forms, and
    also implements some extensions
    that are not in the POSIX standard, but have become widely used
    due to their availability in programming languages such as Perl and Tcl.
    <acronym>RE</acronym>s using these non-POSIX extensions are called
    <firstterm>advanced</> <acronym>RE</acronym>s or <acronym>ARE</>s
    in this documentation.  AREs are almost an exact superset of EREs,
    but BREs have several notational incompatibilities (as well as being
    much more limited).
    We first describe the ARE and ERE forms, noting features that apply
    only to AREs, and then describe how BREs differ.
-->
<acronym>POSIX</acronym> 1003.2の定義によると、正規表現（<acronym>RE</acronym>）には2つの形式があるとされます。<firstterm>拡張</><acronym>RE</acronym>もしくは<acronym>ERE</>（大まかにいって<command>egrep</command>に代表されるもの）、および<firstterm>基本</><acronym>RE</acronym>もしくは<acronym>BRE</>（大まかにいって<command>ed</command>に代表されるもの）です。
<productname>PostgreSQL</productname>は両方の形式をサポートし、さらに、POSIX標準にはないけれどもPerlやTclなどのプログラミング言語で利用できることから広く使用されるようになった、いくつかの拡張もサポートしています。
本書では、非POSIX拡張を使用した<acronym>RE</acronym>を<firstterm>高度な</><acronym>RE</acronym>もしくは<acronym>ARE</>と呼びます。AREはEREの正確な上位セットですが、BREとは複数の記法上の非互換な点があります（さらに非常に多くの制限が課されています）。
まず、AREとERE形式について説明し、そして、AREにのみ適用される機能の注意を、さらにBREとの違いについて説明します。
   </para>

   <note>
    <para>
<!--
     <productname>PostgreSQL</> always initially presumes that a regular
     expression follows the ARE rules.  However, the more limited ERE or
     BRE rules can be chosen by prepending an <firstterm>embedded option</>
     to the RE pattern, as described in <xref linkend="posix-metasyntax">.
     This can be useful for compatibility with applications that expect
     exactly the <acronym>POSIX</acronym> 1003.2 rules.
-->
<productname>PostgreSQL</>は常に、まず正規表現はARE規則に従うと推測します。
しかし、REパターンの前に、<xref linkend="posix-metasyntax">に記載されているような<firstterm>埋め込みオプション</>を追加することにより、より限られたERE、あるいはBRE規則を選択することができます。
これは、<acronym>POSIX</acronym>1003.2の規則を正確に期待しているアプリケーションとの互換性に関して有用です。
    </para>
   </note>

   <para>
<!--
    A regular expression is defined as one or more
    <firstterm>branches</firstterm>, separated by
    <literal>|</literal>.  It matches anything that matches one of the
    branches.
-->
正規表現は<literal>|</literal>で区切られた、1つまたは複数の<firstterm>ブランチ</firstterm>として定義されます。
ブランチのいずれか1つに一致すれば一致したことになります。
   </para>

   <para>
<!--
    A branch is zero or more <firstterm>quantified atoms</> or
    <firstterm>constraints</>, concatenated.
    It matches a match for the first, followed by a match for the second, etc;
    an empty branch matches the empty string.
-->
ブランチはゼロ個以上の<firstterm>量化アトム</firstterm>もしくは<firstterm>制約</>の連結です。
最初のものにマッチに、次に第２番目のものにマッチを、というふうに一致します。なお、空のブランチは空文字列に一致します。
   </para>

   <para>
<!--
    A quantified atom is an <firstterm>atom</> possibly followed
    by a single <firstterm>quantifier</>.
    Without a quantifier, it matches a match for the atom.
    With a quantifier, it can match some number of matches of the atom.
    An <firstterm>atom</firstterm> can be any of the possibilities
    shown in <xref linkend="posix-atoms-table">.
    The possible quantifiers and their meanings are shown in
    <xref linkend="posix-quantifiers-table">.
-->
量化アトムとは、単一の<firstterm>量指定子</>が後ろに付く<firstterm>アトム</>のことです。
量指定子がないと、アトムに一致するものが一致したことになります。
量指定子がある場合、アトムとの一致が何回あるかで一致したことになります。
<firstterm>アトム</firstterm>は、<xref linkend="posix-atoms-table">に示したもののいずれかを取ることができます。
  <xref linkend="posix-quantifiers-table">に設定可能な量指定子とその意味を示します。
   </para>

   <para>
<!--
    A <firstterm>constraint</> matches an empty string, but matches only when
    specific conditions are met.  A constraint can be used where an atom
    could be used, except it cannot be followed by a quantifier.
    The simple constraints are shown in
    <xref linkend="posix-constraints-table">;
    some more constraints are described later.
-->
<firstterm>制約</>は空文字に、特定の条件に合う場合のみに一致します。
アトムを使用できるところには制約を使用することができます。ただしその後に量指定子を付けることはできません。
単純な制約を<xref linkend="posix-constraints-table">に示します。後で他のいくつかの制約を説明します。
   </para>


   <table id="posix-atoms-table">
<!--
    <title>Regular Expression Atoms</title>
-->
    <title>正規表現のアトム</title>

    <tgroup cols="2">
     <thead>
      <row>
<!--
       <entry>Atom</entry>
       <entry>Description</entry>
-->
       <entry>アトム</entry>
       <entry>説明</entry>
      </row>
     </thead>

      <tbody>
       <row>
       <entry> <literal>(</><replaceable>re</><literal>)</> </entry>
<!--
       <entry> (where <replaceable>re</> is any regular expression)
       matches a match for
       <replaceable>re</>, with the match noted for possible reporting </entry>
-->
       
       <entry>（ここで<replaceable>re</> は任意の正規表現で、）<replaceable>re</>とのマッチに適合するもです。 マッチは可能である報告用と意味づけられます。</entry>
       </row>

       <row>
       <entry> <literal>(?:</><replaceable>re</><literal>)</> </entry>
<!--
       <entry> as above, but the match is not noted for reporting
       (a <quote>non-capturing</> set of parentheses)
       (AREs only) </entry>
-->
       <entry>上と同じ。ただし、一致は報告用と意味づけられません。（<quote>捕捉されない</>括弧の集合）（AREのみ）</entry>
       </row>

       <row>
       <entry> <literal>.</> </entry>
<!--
       <entry> matches any single character </entry>
-->
       <entry>任意の1文字に一致します。</entry>
       </row>

       <row>
       <entry> <literal>[</><replaceable>chars</><literal>]</> </entry>
<!--
       <entry> a <firstterm>bracket expression</>,
       matching any one of the <replaceable>chars</> (see
       <xref linkend="posix-bracket-expressions"> for more detail) </entry>
-->
       <entry> 
        <firstterm>ブラケット式</>。
        <replaceable>chars</>のいずれか1つに一致します
       （詳細は<xref linkend="posix-bracket-expressions">を参照してください）。
       </entry>
       </row>

       <row>
       <entry> <literal>\</><replaceable>k</> </entry>
<!--
       <entry> (where <replaceable>k</> is a non-alphanumeric character)
       matches that character taken as an ordinary character,
       e.g., <literal>\\</> matches a backslash character </entry>
-->
       <entry>（ここで<replaceable>k</>は英数字以外です。）普通の文字として指定した文字に一致します。例えば、<literal>\\</>はバックスラッシュ文字です。</entry>
       </row>

       <row>
       <entry> <literal>\</><replaceable>c</> </entry>
<!--
       <entry> where <replaceable>c</> is alphanumeric
       (possibly followed by other characters)
       is an <firstterm>escape</>, see <xref linkend="posix-escape-sequences">
       (AREs only; in EREs and BREs, this matches <replaceable>c</>) </entry>
-->
       <entry>ここで<replaceable>c</>は英数字です
       （おそらく他の文字が後に続きます）。
       <firstterm>エスケープ</>です。
       <xref linkend="posix-escape-sequences">を参照してください
       （AREのみ、EREとBREではこれは<replaceable>c</>に一致します）。
       </entry>
       </row>

       <row>
       <entry> <literal>{</> </entry>
<!--
       <entry> when followed by a character other than a digit,
       matches the left-brace character <literal>{</>;
       when followed by a digit, it is the beginning of a
       <replaceable>bound</> (see below) </entry>
-->
       <entry>直後に数字以外がある場合、左中括弧<literal>{</>に一致します。
直後に数字が続く場合、<replaceable>bound</>（後述）の始まりです。</entry>
       </row>

       <row>
       <entry> <replaceable>x</> </entry>
<!--
       <entry> where <replaceable>x</> is a single character with no other
       significance, matches that character </entry>
-->
       <entry>ここで<replaceable>x</>は他に意味を持たない1文字です。
<replaceable>x</>に一致します。</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
<!--
    An RE cannot end with a backslash (<literal>\</>).
-->
REはバックスラッシュ<literal>\</>を終端とすることはできません。
   </para>

   <note>
    <para>
<!--
     If you have <xref linkend="guc-standard-conforming-strings"> turned off,
     any backslashes you write in literal string constants will need to be
     doubled.  See <xref linkend="sql-syntax-strings"> for more information.
-->
もし<xref linkend="guc-standard-conforming-strings">パラメータをoffにしていた場合、リテラル文字列定数に記述するバックスラッシュは2倍必要となります。
  詳細は<xref linkend="sql-syntax-strings">を参照してください。
    </para>
   </note>

   <table id="posix-quantifiers-table">
<!--
    <title>Regular Expression Quantifiers</title>
-->
    <title>正規表現量指定子</title>

    <tgroup cols="2">
     <thead>
      <row>
<!--
       <entry>Quantifier</entry>
       <entry>Matches</entry>
-->
       <entry>量指定子</entry>
       <entry>マッチ</entry>
      </row>
     </thead>

      <tbody>
       <row>
       <entry> <literal>*</> </entry>
<!--
       <entry> a sequence of 0 or more matches of the atom </entry>
-->
       <entry>アトムの0個以上複数の並びに一致</entry>
       </row>

       <row>
       <entry> <literal>+</> </entry>
<!--
       <entry> a sequence of 1 or more matches of the atom </entry>
-->
       <entry>アトムの1個以上複数の並びに一致</entry>
       </row>

       <row>
       <entry> <literal>?</> </entry>
<!--
       <entry> a sequence of 0 or 1 matches of the atom </entry>
-->
       <entry>アトムの0個または1個の並びに一致</entry>
       </row>

       <row>
       <entry> <literal>{</><replaceable>m</><literal>}</> </entry>
<!--
       <entry> a sequence of exactly <replaceable>m</> matches of the atom </entry>
-->
       <entry>アトムの正確に<replaceable>m</>個の並びに一致</entry>
       </row>

       <row>
       <entry> <literal>{</><replaceable>m</><literal>,}</> </entry>
<!--
       <entry> a sequence of <replaceable>m</> or more matches of the atom </entry>
-->
       <entry>アトムの<replaceable>m</>個以上の並びに一致</entry>
       </row>

       <row>
       <entry>
       <literal>{</><replaceable>m</><literal>,</><replaceable>n</><literal>}</> </entry>
<!--
       <entry> a sequence of <replaceable>m</> through <replaceable>n</>
       (inclusive) matches of the atom; <replaceable>m</> cannot exceed
       <replaceable>n</> </entry>
-->
       <entry> アトムの<replaceable>m</>個以上<replaceable>n</>以下の並びに一致。
<replaceable>m</>は<replaceable>n</>を超えることはできません。</entry>
       </row>

       <row>
       <entry> <literal>*?</> </entry>
<!--
       <entry> non-greedy version of <literal>*</> </entry>
-->
       <entry><literal>*</>の最短マッチを行うバージョン</entry>
       </row>

       <row>
       <entry> <literal>+?</> </entry>
<!--
       <entry> non-greedy version of <literal>+</> </entry>
-->
       <entry><literal>+</>の最短マッチを行うバージョン</entry>
       
       </row>

       <row>
       <entry> <literal>??</> </entry>
<!--
       <entry> non-greedy version of <literal>?</> </entry>
-->
       <entry><literal>?</>の最短マッチを行うバージョン</entry>
       </row>

       <row>
       <entry> <literal>{</><replaceable>m</><literal>}?</> </entry>
<!--
       <entry> non-greedy version of <literal>{</><replaceable>m</><literal>}</> </entry>
-->
       <entry><literal>{</><replaceable>m</><literal>}</>の最短マッチを行うバージョン</entry>
       </row>

       <row>
       <entry> <literal>{</><replaceable>m</><literal>,}?</> </entry>
<!--
       <entry> non-greedy version of <literal>{</><replaceable>m</><literal>,}</> </entry>
-->
       <entry><literal>{</><replaceable>m</><literal>,}</>の最短マッチを行うバージョン</entry>
       </row>

       <row>
       <entry>
       <literal>{</><replaceable>m</><literal>,</><replaceable>n</><literal>}?</> </entry>
<!--
       <entry> non-greedy version of <literal>{</><replaceable>m</><literal>,</><replaceable>n</><literal>}</> </entry>
-->
       <entry><literal>{</><replaceable>m</><literal>,</><replaceable>n</><literal>}</>の最短マッチを行うバージョン</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
<!--
    The forms using <literal>{</><replaceable>...</><literal>}</>
    are known as <firstterm>bounds</>.
    The numbers <replaceable>m</> and <replaceable>n</> within a bound are
    unsigned decimal integers with permissible values from 0 to 255 inclusive.
-->
<literal>{</><replaceable>...</><literal>}</>を使用する形式は<firstterm>バウンド</>として知られています。
バウンド内の<replaceable>m</>と<replaceable>n</>という数は符号なし10進整数であり、0以上255以下の値を取ることができます。
   </para>

    <para>
<!--
     <firstterm>Non-greedy</> quantifiers (available in AREs only) match the
     same possibilities as their corresponding normal (<firstterm>greedy</>)
     counterparts, but prefer the smallest number rather than the largest
     number of matches.
     See <xref linkend="posix-matching-rules"> for more detail.
-->
<firstterm>最短マッチを行う</>量指定子（AREのみで使用可能）は、対応する通常の（<firstterm>欲張りの</>）ものと同じものに一致しますが、最大のマッチではなく最小のマッチを取ります。
詳細は<xref linkend="posix-matching-rules">を参照してください。
   </para>

   <note>
    <para>
<!--
     A quantifier cannot immediately follow another quantifier, e.g.,
     <literal>**</> is invalid.
     A quantifier cannot
     begin an expression or subexpression or follow
     <literal>^</literal> or <literal>|</literal>.
-->
量指定子の直後に量指定子を続けることはできません。例えば<literal>**</>は無効です。
量指定子から式や副式を始めることはできず、また、<literal>^</literal>や<literal>|</literal>の直後に付けることもできません。
    </para>
   </note>

   <table id="posix-constraints-table">
<!--
    <title>Regular Expression Constraints</title>
-->
    <title>正規表現制約</title>

    <tgroup cols="2">
     <thead>
      <row>
<!--
       <entry>Constraint</entry>
       <entry>Description</entry>
-->
       <entry>制約</entry>
       <entry>説明</entry>
      </row>
     </thead>

      <tbody>
       <row>
       <entry> <literal>^</> </entry>
<!--
       <entry> matches at the beginning of the string </entry>
-->
       <entry>文字列の先頭に一致</entry>
       </row>

       <row>
       <entry> <literal>$</> </entry>
<!--
       <entry> matches at the end of the string </entry>
-->
       <entry>文字列の末尾に一致</entry>
       </row>

       <row>
       <entry> <literal>(?=</><replaceable>re</><literal>)</> </entry>
<!--
       <entry> <firstterm>positive lookahead</> matches at any point
       where a substring matching <replaceable>re</> begins
       (AREs only) </entry>
-->
       <entry><firstterm>先行肯定検索</>は、<replaceable>re</>に一致する部分文字列から始まる任意の場所に一致します（AREのみ）。</entry>
       </row>

       <row>
       <entry> <literal>(?!</><replaceable>re</><literal>)</> </entry>
<!--
       <entry> <firstterm>negative lookahead</> matches at any point
       where no substring matching <replaceable>re</> begins
       (AREs only) </entry>
-->
       <entry><firstterm>先行否定検索</>は、<replaceable>re</>に一致しない部分文字列から始まる任意の場所に一致します（AREのみ）。</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
<!--
    Lookahead constraints cannot contain <firstterm>back references</>
    (see <xref linkend="posix-escape-sequences">),
    and all parentheses within them are considered non-capturing.
-->
先行検索制約には<firstterm>後方参照</>（<xref linkend="posix-escape-sequences">を参照）を含めることはできません。また、その中の括弧は全て取り込むものではないとみなされます。
   </para>
   </sect3>

   <sect3 id="posix-bracket-expressions">
<!--
    <title>Bracket Expressions</title>
-->
    <title>ブラケット式</title>

   <para>
<!--
    A <firstterm>bracket expression</firstterm> is a list of
    characters enclosed in <literal>[]</literal>.  It normally matches
    any single character from the list (but see below).  If the list
    begins with <literal>^</literal>, it matches any single character
    <emphasis>not</> from the rest of the list.
    If two characters
    in the list are separated by <literal>-</literal>, this is
    shorthand for the full range of characters between those two
    (inclusive) in the collating sequence,
    e.g., <literal>[0-9]</literal> in <acronym>ASCII</acronym> matches
    any decimal digit.  It is illegal for two ranges to share an
    endpoint, e.g.,  <literal>a-c-e</literal>.  Ranges are very
    collating-sequence-dependent, so portable programs should avoid
    relying on them.
-->
<firstterm>ブラケット式</firstterm>とは、<literal>[]</literal>内の文字のリストです。
通常これはそのリスト内の任意の1文字に一致します（しかし、以降を参照してください）。
リストが<literal>^</literal>から始まる場合、そのリストの残りには<emphasis>ない</>任意の1文字に一致します。
リスト内の2文字が<literal>-</literal>で区切られていた場合、これは2つ（を含む）の間にある文字範囲全体を表す省略形となります。例えば、<acronym>ASCII</acronym>における<literal>[0-9]</literal>は全ての数字に一致します。
例えば<literal>a-c-e</literal>といった、終端を共有する2つの範囲は不正です。
範囲は並びの照合順に非常に依存しています。ですので、移植予定のプログラムではこれに依存してはなりません。
   </para>

   <para>
<!--
    To include a literal <literal>]</literal> in the list, make it the
    first character (after <literal>^</literal>, if that is used).  To
    include a literal <literal>-</literal>, make it the first or last
    character, or the second endpoint of a range.  To use a literal
    <literal>-</literal> as the first endpoint of a range, enclose it
    in <literal>[.</literal> and <literal>.]</literal> to make it a
    collating element (see below).  With the exception of these characters,
    some combinations using <literal>[</literal>
    (see next paragraphs), and escapes (AREs only), all other special
    characters lose their special significance within a bracket expression.
    In particular, <literal>\</literal> is not special when following
    ERE or BRE rules, though it is special (as introducing an escape)
    in AREs.
-->
このリストに<literal>]</literal>そのものを含めるには、それを先頭文字（もしそれが使用されれば<literal>^</literal>の後）にしてください。
<literal>-</literal>そのものを含めるには、それを先頭もしくは末尾の文字とするか、範囲の2番目の終端としてください。
<literal>-</literal>を範囲の最初の終端で使用するには、<literal>[.</literal>と<literal>.]</literal>でそれを囲み、照合要素（後述）にしてください。
これら文字と、<literal>[</literal>（次段落を参照）のなんらかの組み合わせ、およびエスケープ（AREのみ）を例外として、他の全ての特殊文字はブラケット式内では特殊な意味を持ちません。
特に、<literal>\</literal>はEREとBRE規則に従う場合は特別でなくなります。しかし、AREでは（エスケープの始まりとして）特別な意味を持ちます。
   </para>

   <para>
<!--
    Within a bracket expression, a collating element (a character, a
    multiple-character sequence that collates as if it were a single
    character, or a collating-sequence name for either) enclosed in
    <literal>[.</literal> and <literal>.]</literal> stands for the
    sequence of characters of that collating element.  The sequence is
    treated as a single element of the bracket expression's list.  This
    allows a bracket
    expression containing a multiple-character collating element to
    match more than one character, e.g., if the collating sequence
    includes a <literal>ch</literal> collating element, then the RE
    <literal>[[.ch.]]*c</literal> matches the first five characters of
    <literal>chchcc</literal>.
-->
ブラケット式内に、照合要素（文字、単一文字であるかのように照合する複数文字の並び、もしくはそれぞれの照合並びの名前）が<literal>[.</literal>と<literal>.]</literal>の間にあると、その照合要素の文字の並びを意味します。
この並びはブラケット式のリストの一要素として取り扱われます。
このことにより、ブラケット式は要素を照合する複数文字を含むブラケット式を1文字以上に一致させることができます。例えば、照合並びが<literal>ch</literal>照合要素を含む場合、正規表現<literal>[[.ch.]]*c</literal>は<literal>chchcc</literal>という文字の最初の5文字に一致します。
   </para>

   <note>
    <para>
<!--
     <productname>PostgreSQL</> currently does not support multi-character collating
     elements. This information describes possible future behavior.
-->
今のところ、<productname>PostgreSQL</>は複数文字照合要素をサポートしません。
この情報は将来の振舞いの可能性を説明したものです。
    </para>
   </note>

   <para>
<!--
    Within a bracket expression, a collating element enclosed in
    <literal>[=</literal> and <literal>=]</literal> is an <firstterm>equivalence
    class</>, standing for the sequences of characters of all collating
    elements equivalent to that one, including itself.  (If there are
    no other equivalent collating elements, the treatment is as if the
    enclosing delimiters were <literal>[.</literal> and
    <literal>.]</literal>.)  For example, if <literal>o</literal> and
    <literal>^</literal> are the members of an equivalence class, then
    <literal>[[=o=]]</literal>, <literal>[[=^=]]</literal>, and
    <literal>[o^]</literal> are all synonymous.  An equivalence class
    cannot be an endpoint of a range.
-->
ブラケット式内の<literal>[=</literal>と<literal>=]</literal>の間に照合要素は<firstterm>同値クラス</>です。全ての照合要素の文字の並びが自身を含むものと等価であることを示します。
（他に等価な照合要素がある場合、<literal>[.</literal>と<literal>.]</literal>で囲まれたかのように扱われます。）
例えば、<literal>[[=o=]]</literal>、<literal>[[=^=]]</literal>および<literal>[o^]</literal>が全て同意語であれば、<literal>o</literal>と<literal>^</literal>は同値クラスのメンバです。
同値クラスは範囲の終端にはなりません。
   </para>

   <para>
<!--
    Within a bracket expression, the name of a character class
    enclosed in <literal>[:</literal> and <literal>:]</literal> stands
    for the list of all characters belonging to that class.  Standard
    character class names are: <literal>alnum</literal>,
    <literal>alpha</literal>, <literal>blank</literal>,
    <literal>cntrl</literal>, <literal>digit</literal>,
    <literal>graph</literal>, <literal>lower</literal>,
    <literal>print</literal>, <literal>punct</literal>,
    <literal>space</literal>, <literal>upper</literal>,
    <literal>xdigit</literal>.  These stand for the character classes
    defined in
    <citerefentry><refentrytitle>ctype</refentrytitle><manvolnum>3</manvolnum></citerefentry>.
    A locale can provide others.  A character class cannot be used as
    an endpoint of a range.
-->
ブラケット式内では、<literal>[:</literal>と<literal>:]</literal>の間にある文字クラスの名称は、そのクラスに属する全ての文字のリストを意味します。
標準文字クラス名は、<literal>alnum</literal>、<literal>alpha</literal>、<literal>blank</literal>、<literal>cntrl</literal>、<literal>digit</literal>、<literal>graph</literal>、<literal>lower</literal>、<literal>print</literal>、<literal>punct</literal>、<literal>space</literal>、<literal>upper</literal>、<literal>xdigit</literal>です。
これらは<citerefentry><refentrytitle>ctype</refentrytitle><manvolnum>3</manvolnum></citerefentry>で定義された文字クラスを意味します。
ロケールは別のものを提供可能です。
文字クラスは範囲の終端では使用することができません。
   </para>

   <para>
<!--
    There are two special cases of bracket expressions:  the bracket
    expressions <literal>[[:&lt;:]]</literal> and
    <literal>[[:&gt;:]]</literal> are constraints,
    matching empty strings at the beginning
    and end of a word respectively.  A word is defined as a sequence
    of word characters that is neither preceded nor followed by word
    characters.  A word character is an <literal>alnum</> character (as
    defined by
    <citerefentry><refentrytitle>ctype</refentrytitle><manvolnum>3</manvolnum></citerefentry>)
    or an underscore.  This is an extension, compatible with but not
    specified by <acronym>POSIX</acronym> 1003.2, and should be used with
    caution in software intended to be portable to other systems.
    The constraint escapes described below are usually preferable; they
    are no more standard, but are easier to type.
-->
ブラケット式には2つの特殊な場合があります。<literal>[[:&lt;:]]</literal>と<literal>[[:&gt;:]]</literal>というブラケット式は、先頭と終端の単語がそれぞれ空文字であることに一致する制約です。
単語は、単語文字が前後に付かない単語文字の並びとして定義されます。
単語文字とは（<citerefentry><refentrytitle>ctype</refentrytitle><manvolnum>3</manvolnum></citerefentry>で定義されている）1つの<literal>alnum</>文字またはアンダースコアです。
これは、<acronym>POSIX</acronym> 1003.2との互換性はありますが、そこでは定義されていない式です。ですので、他システムへ移植予定のソフトウェアでの使用には注意が必要です。
通常後述の制約エスケープの方がよく使われます。これはもはや標準ではありませんが、入力しやすいものです。
   </para>
   </sect3>

   <sect3 id="posix-escape-sequences">
<!--
    <title>Regular Expression Escapes</title>
-->
    <title>正規表現エスケープ</title>

   <para>
<!--
    <firstterm>Escapes</> are special sequences beginning with <literal>\</>
    followed by an alphanumeric character. Escapes come in several varieties:
    character entry, class shorthands, constraint escapes, and back references.
    A <literal>\</> followed by an alphanumeric character but not constituting
    a valid escape is illegal in AREs.
    In EREs, there are no escapes: outside a bracket expression,
    a <literal>\</> followed by an alphanumeric character merely stands for
    that character as an ordinary character, and inside a bracket expression,
    <literal>\</> is an ordinary character.
    (The latter is the one actual incompatibility between EREs and AREs.)
-->
<firstterm>エスケープ</>とは、<literal>\</>から始まり英数字がその後に続く特殊な並びです。
エスケープには、文字エントリ、クラス省略、制約エスケープ、後方参照といった様々な変種があります。
<literal>\</>の後に英数字が続くけれども、有効なエスケープを構成しない並びはAREでは不正です。
EREにはエスケープはありません。ブラケット式の外側では、<literal>\</>の後に英数字が続く並びは単に普通の文字としてその文字を意味します。ブラケット式の内側では、<literal>\</>は普通の文字です。
（後者はEREとARE間の非互換性の1つです。）
   </para>

   <para>
<!--
    <firstterm>Character-entry escapes</> exist to make it easier to specify
    non-printing and other inconvenient characters in REs.  They are
    shown in <xref linkend="posix-character-entry-escapes-table">.
-->
<firstterm>文字エントリエスケープ</>は非印字文字やRE内でその他の不便な文字の指定を簡略化するために存在します。
これらを<xref linkend="posix-character-entry-escapes-table">に示します。
   </para>

   <para>
<!--
    <firstterm>Class-shorthand escapes</> provide shorthands for certain
    commonly-used character classes.  They are
    shown in <xref linkend="posix-class-shorthand-escapes-table">.
-->
<firstterm>クラス省略エスケープ</>は、あるよく使用される文字クラスの省略形を提供します。
これらを<xref linkend="posix-class-shorthand-escapes-table">に示します。
   </para>

   <para>
<!--
    A <firstterm>constraint escape</> is a constraint,
    matching the empty string if specific conditions are met,
    written as an escape.  They are
    shown in <xref linkend="posix-constraint-escapes-table">.
-->
<firstterm>制約エスケープ</>は、指定した条件に合う場合に空文字に一致する制約をエスケープとして表したものです。
これらを<xref linkend="posix-constraint-escapes-table">に示します。
   </para>

   <para>
<!--
    A <firstterm>back reference</> (<literal>\</><replaceable>n</>) matches the
    same string matched by the previous parenthesized subexpression specified
    by the number <replaceable>n</>
    (see <xref linkend="posix-constraint-backref-table">).  For example,
    <literal>([bc])\1</> matches <literal>bb</> or <literal>cc</>
    but not <literal>bc</> or <literal>cb</>.
    The subexpression must entirely precede the back reference in the RE.
    Subexpressions are numbered in the order of their leading parentheses.
    Non-capturing parentheses do not define subexpressions.
-->
<firstterm>後方参照</>（<literal>\</><replaceable>n</>）は、直前に括弧で囲まれた副式によって一致された、<replaceable>n</>番目の同一文字列に一致します（<xref linkend="posix-constraint-backref-table">を参照してください）。
  例えば、<literal>([bc])\1</>は<literal>bb</>もしくは<literal>cc</>に一致しますが、<literal>bc</>や<literal>cb</>には一致しません。REでは副式全体は後方参照の前になければなりません。
副式は開括弧の順番で番号付けされます。
取り込まない括弧は副式を定義しません。
   </para>

   <note>
    <para>
<!--
     Keep in mind that an escape's leading <literal>\</> will need to be
     doubled when entering the pattern as an SQL string constant.  For example:
-->
エスケープの先頭の<literal>\</>をSQL文字定数としてパターンに入力する時には二重にしなければならないことを忘れないでください。
以下に例を示します。
<programlisting>
'123' ~ E'^\\d{3}' <lineannotation>true</lineannotation>
</programlisting>
    </para>
   </note>

   <table id="posix-character-entry-escapes-table">
<!--
    <title>Regular Expression Character-entry Escapes</title>
-->
    <title>正規表現文字エントリエスケープ</title>

    <tgroup cols="2">
     <thead>
      <row>
<!--
       <entry>Escape</entry>
       <entry>Description</entry>
-->
       <entry>エスケープ</entry>
       <entry>説明</entry>
      </row>
     </thead>

      <tbody>
       <row>
       <entry> <literal>\a</> </entry>
<!--
       <entry> alert (bell) character, as in C </entry>
-->
       <entry>C言語と同じ警報（ベル）文字</entry>
       </row>

       <row>
       <entry> <literal>\b</> </entry>
<!--
       <entry> backspace, as in C </entry>
-->
       <entry>C言語と同じバックスペース</entry>
       </row>

       <row>
       <entry> <literal>\B</> </entry>
<!--
       <entry> synonym for backslash (<literal>\</>) to help reduce the need for backslash
       doubling </entry>
-->
       <entry> バックスラッシュの必要な二重化回数を減らすためのバックスラッシュ（<literal>\</>）の同義語</entry>
       </row>

       <row>
       <entry> <literal>\c</><replaceable>X</> </entry>
<!--
       <entry> (where <replaceable>X</> is any character) the character whose
       low-order 5 bits are the same as those of
       <replaceable>X</>, and whose other bits are all zero </entry>
-->
       <entry>（ここで<replaceable>X</>は任意の文字で）その下位5ビットが<replaceable>X</>と同一、その他のビットが0となる文字 </entry>
       </row>

       <row>
       <entry> <literal>\e</> </entry>
<!--
       <entry> the character whose collating-sequence name
       is <literal>ESC</>,
       or failing that, the character with octal value 033 </entry>
-->
       <entry>照合順名が<literal>ESC</>となる文字、それに失敗したら、033という8進数値を持つ文字。</entry>
       </row>

       <row>
       <entry> <literal>\f</> </entry>
<!--
       <entry> form feed, as in C </entry>
-->
       <entry>C言語と同じ改ページ</entry>
       </row>

       <row>
       <entry> <literal>\n</> </entry>
<!--
       <entry> newline, as in C </entry>
-->
       <entry>C言語と同じ改行</entry>
       </row>

       <row>
       <entry> <literal>\r</> </entry>
<!--
       <entry> carriage return, as in C </entry>
-->
       <entry>C言語と同じ復帰</entry>
       </row>

       <row>
       <entry> <literal>\t</> </entry>
<!--
       <entry> horizontal tab, as in C </entry>
-->
       <entry>C言語と同じ水平タブ</entry>
       </row>

       <row>
       <entry> <literal>\u</><replaceable>wxyz</> </entry>
<!--
       <entry> (where <replaceable>wxyz</> is exactly four hexadecimal digits)
       the UTF16 (Unicode, 16-bit) character <literal>U+</><replaceable>wxyz</>
       in the local byte ordering </entry>
-->
       <entry>（ここで<replaceable>wxyz</>は正確に4桁の16進数で）使用マシンのバイト順序付けで表した、<literal>U+</><replaceable>wxyz</>というUTF16（16ビット、Unicode）文字</entry>
       </row>

       <row>
       <entry> <literal>\U</><replaceable>stuvwxyz</> </entry>
<!--
       <entry> (where <replaceable>stuvwxyz</> is exactly eight hexadecimal
       digits)
       reserved for a hypothetical Unicode extension to 32 bits
-->
       <entry>（ここで<replaceable>stuvwxyz</>は正確に8桁の16進数です。）32ビットにUnicodeが拡張されるという仮説のために確保
       </entry>
       </row>

       <row>
       <entry> <literal>\v</> </entry>
<!--
       <entry> vertical tab, as in C </entry>
-->
       <entry>C言語と同じ垂直タブ</entry>
       </row>

       <row>
       <entry> <literal>\x</><replaceable>hhh</> </entry>
<!--
       <entry> (where <replaceable>hhh</> is any sequence of hexadecimal
       digits)
       the character whose hexadecimal value is
       <literal>0x</><replaceable>hhh</>
       (a single character no matter how many hexadecimal digits are used)
-->
       <entry>（ここで<replaceable>hhh</>は任意の16進数の並びで）その文字の16進数値が<literal>0x</><replaceable>hhh</>となる文字（使用される16進数の桁数にかかわらず単一の文字）
       </entry>
       </row>

       <row>
       <entry> <literal>\0</> </entry>
<!--
       <entry> the character whose value is <literal>0</> (the null byte)</entry>
-->
       <entry>その値が<literal>0</>（NULLバイト）となる文字</entry>
       </row>

       <row>
       <entry> <literal>\</><replaceable>xy</> </entry>
<!--
       <entry> (where <replaceable>xy</> is exactly two octal digits,
       and is not a <firstterm>back reference</>)
       the character whose octal value is
       <literal>0</><replaceable>xy</> </entry>
-->
       <entry>（ここで<replaceable>xy</>は正確に2桁の8進数で、<firstterm>後方参照</>ではない）その値が<literal>0</><replaceable>xy</>となる文字</entry>
       </row>

       <row>
       <entry> <literal>\</><replaceable>xyz</> </entry>
<!--
       <entry> (where <replaceable>xyz</> is exactly three octal digits,
       and is not a <firstterm>back reference</>)
       the character whose octal value is
       <literal>0</><replaceable>xyz</> </entry>
-->
       <entry>（ここで<replaceable>xyz</>は正確に3桁の8進数で、<firstterm>後方参照</>ではない）その値が<literal>0</><replaceable>xyz</>となる文字</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
<!--
    Hexadecimal digits are <literal>0</>-<literal>9</>,
    <literal>a</>-<literal>f</>, and <literal>A</>-<literal>F</>.
    Octal digits are <literal>0</>-<literal>7</>.
-->
16進数の桁とは<literal>0</>-<literal>9</>、<literal>a</>-<literal>f</>、<literal>A</>-<literal>F</>です。
8進数の桁とは<literal>0</>-<literal>7</>です。
   </para>

   <para>
<!--
    The character-entry escapes are always taken as ordinary characters.
    For example, <literal>\135</> is <literal>]</> in ASCII, but
    <literal>\135</> does not terminate a bracket expression.
-->
この文字エントリエスケープは常に普通の文字と解釈されます。
例えば、<literal>\135</>はASCIIの<literal>]</>となり、<literal>\135</>はブラケット式の終端にはなりません。
   </para>

   <table id="posix-class-shorthand-escapes-table">
<!--
    <title>Regular Expression Class-shorthand Escapes</title>
-->
    <title>正規表現クラス省略エスケープ</title>

    <tgroup cols="2">
     <thead>
      <row>
<!--
       <entry>Escape</entry>
       <entry>Description</entry>
-->
       <entry>エスケープ</entry>
       <entry>説明</entry>
      </row>
     </thead>

      <tbody>
       <row>
       <entry> <literal>\d</> </entry>
       <entry> <literal>[[:digit:]]</> </entry>
       </row>

       <row>
       <entry> <literal>\s</> </entry>
       <entry> <literal>[[:space:]]</> </entry>
       </row>

       <row>
       <entry> <literal>\w</> </entry>
       <entry> <literal>[[:alnum:]_]</>
<!--
       (note underscore is included) </entry>
-->
       （アンダースコアが含まれることに注意）</entry>
       </row>

       <row>
       <entry> <literal>\D</> </entry>
       <entry> <literal>[^[:digit:]]</> </entry>
       </row>

       <row>
       <entry> <literal>\S</> </entry>
       <entry> <literal>[^[:space:]]</> </entry>
       </row>

       <row>
       <entry> <literal>\W</> </entry>
       <entry> <literal>[^[:alnum:]_]</>
<!--
       (note underscore is included) </entry>
-->
       （アンダースコアが含まれることに注意）</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
<!--
    Within bracket expressions, <literal>\d</>, <literal>\s</>,
    and <literal>\w</> lose their outer brackets,
    and <literal>\D</>, <literal>\S</>, and <literal>\W</> are illegal.
    (So, for example, <literal>[a-c\d]</> is equivalent to
    <literal>[a-c[:digit:]]</>.
    Also, <literal>[a-c\D]</>, which is equivalent to
    <literal>[a-c^[:digit:]]</>, is illegal.)
-->
ブラケット式内では、<literal>\d</>、<literal>\s</>、および<literal>\w</>はその外側の大括弧を失い、<literal>\D</>、<literal>\S</>および<literal>\W</>は不正です。
（ですから、例えば<literal>[a-c\d]</>は<literal>[a-c[:digit:]]</>と同じになります。また、<literal>[a-c\D]</>は<literal>[a-c^[:digit:]]</>と同じになり、不正です。）
   </para>

   <table id="posix-constraint-escapes-table">
<!--
    <title>Regular Expression Constraint Escapes</title>
-->
    <title>正規表現制約エスケープ</title>

    <tgroup cols="2">
     <thead>
      <row>
<!--
       <entry>Escape</entry>
       <entry>Description</entry>
-->
       <entry>エスケープ</entry>
       <entry>説明</entry>
      </row>
     </thead>

      <tbody>
       <row>
       <entry> <literal>\A</> </entry>
<!--
       <entry> matches only at the beginning of the string
       (see <xref linkend="posix-matching-rules"> for how this differs from
       <literal>^</>) </entry>
-->
       <entry>文字列の先頭にのみ一致します（<literal>^</>との違いについては<xref linkend="posix-matching-rules">を参照してください）。</entry> 
       </row>

       <row>
       <entry> <literal>\m</> </entry>
<!--
       <entry> matches only at the beginning of a word </entry>
-->
       <entry> 単語の先頭にのみ一致します。 </entry>
       </row>

       <row>
       <entry> <literal>\M</> </entry>
<!--
       <entry> matches only at the end of a word </entry>
-->
       <entry> 単語の末尾にのみ一致します。 </entry>
       </row>

       <row>
       <entry> <literal>\y</> </entry>
<!--
       <entry> matches only at the beginning or end of a word </entry>
-->
       <entry> 単語の先頭もしくは末尾にのみ一致します。</entry>
       </row>

       <row>
       <entry> <literal>\Y</> </entry>
<!--
       <entry> matches only at a point that is not the beginning or end of a
       word </entry>
-->
       <entry>単語の先頭もしくは末尾以外の場所にのみ一致します。</entry>
       </row>

       <row>
       <entry> <literal>\Z</> </entry>
<!--
       <entry> matches only at the end of the string
       (see <xref linkend="posix-matching-rules"> for how this differs from
       <literal>$</>) </entry>
-->
       <entry>文字列の末尾にのみ一致します（<literal>$</>との違いについては<xref linkend="posix-matching-rules">を参照してください）。</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
<!--
    A word is defined as in the specification of
    <literal>[[:&lt;:]]</> and <literal>[[:&gt;:]]</> above.
    Constraint escapes are illegal within bracket expressions.
-->
    単語は前述の<literal>[[:&lt;:]]</>と<literal>[[:&gt;:]]</>の規定通りに定義されます。ブラケット式内では制約エスケープは不正です。
   </para>

   <table id="posix-constraint-backref-table">
<!--
    <title>Regular Expression Back References</title>
-->
    <title>正規表現後方参照</title>

    <tgroup cols="2">
     <thead>
      <row>
<!--
       <entry>Escape</entry>
       <entry>Description</entry>
-->
       <entry>エスケープ</entry>
       <entry>説明</entry>
      </row>
     </thead>

      <tbody>
       <row>
       <entry> <literal>\</><replaceable>m</> </entry>
<!--
       <entry> (where <replaceable>m</> is a nonzero digit)
       a back reference to the <replaceable>m</>'th subexpression </entry>
-->
       <entry>（ここで<replaceable>m</>は非ゼロの数です。）副式の<replaceable>m</>番目への後方参照</entry>
       </row>

       <row>
       <entry> <literal>\</><replaceable>mnn</> </entry>
<!--
       <entry> (where <replaceable>m</> is a nonzero digit, and
       <replaceable>nn</> is some more digits, and the decimal value
       <replaceable>mnn</> is not greater than the number of closing capturing
       parentheses seen so far)
       a back reference to the <replaceable>mnn</>'th subexpression </entry>
-->
       <entry>（ここで<replaceable>m</>は非ゼロの数です。<replaceable>nn</>でさらに桁を指定します。<replaceable>mnn</>10進数値は取り込み括弧の数よりも多くてはなりません。）副式の<replaceable>mnn</>番目への後方参照</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <note>
    <para>
<!--
     There is an inherent ambiguity between octal character-entry
     escapes and back references, which is resolved by the following heuristics,
     as hinted at above.
     A leading zero always indicates an octal escape.
     A single non-zero digit, not followed by another digit,
     is always taken as a back reference.
     A multi-digit sequence not starting with a zero is taken as a back
     reference if it comes after a suitable subexpression
     (i.e., the number is in the legal range for a back reference),
     and otherwise is taken as octal.
-->
8進数の文字エントリエスケープと後方参照の間には曖昧性があります。上でヒントとして示したようにこれは以下の発見的手法で解決されます。
先頭の0は常に8進数エスケープを示します。
その後に数字が続かない単一の非ゼロ数字は常に後方参照として解釈されます。
ゼロから始まらない複数数字の並びは、適切な副式の後にあれば（つまり、その番号が後方参照用の範囲内にあれば）後方参照として解釈されます。さもなくば、8進数として解釈されます。
    </para>
   </note>
   </sect3>

   <sect3 id="posix-metasyntax">
<!--
    <title>Regular Expression Metasyntax</title>
-->
    <title>正規表現メタ構文</title>

   <para>
<!--
    In addition to the main syntax described above, there are some special
    forms and miscellaneous syntactic facilities available.
-->
上述の主構文の他に、特殊な形式や雑多な構文的な機能が使用可能です。
   </para>

   <para>
<!--
    An RE can begin with one of two special <firstterm>director</> prefixes.
    If an RE begins with <literal>***:</>,
    the rest of the RE is taken as an ARE.  (This normally has no effect in
    <productname>PostgreSQL</>, since REs are assumed to be AREs;
    but it does have an effect if ERE or BRE mode had been specified by
    the <replaceable>flags</> parameter to a regex function.)
    If an RE begins with <literal>***=</>,
    the rest of the RE is taken to be a literal string,
    with all characters considered ordinary characters.
-->
REは、2つの特殊な<firstterm>決定子</>前置詞のどちらかから始まります。
REが<literal>***:</>から始まるものであれば、REの残りはAREと解釈されます。
(<productname>PostgreSQL</>はREをAREとして推測するため、通常は影響を受けません。ただし、正規表現関数に対して<replaceable>flags</>パラメータを指定されたEREやBREモードでは影響を受けます。)
REが<literal>***=</>から始まるものであれば、REの残りは、全ての文字を普通の文字とみなしたリテラル文字列と解釈されます。
   </para>

   <para>
<!--
    An ARE can begin with <firstterm>embedded options</>:
    a sequence <literal>(?</><replaceable>xyz</><literal>)</>
    (where <replaceable>xyz</> is one or more alphabetic characters)
    specifies options affecting the rest of the RE.
    These options override any previously determined options &mdash;
    in particular, they can override the case-sensitivity behavior implied by
    a regex operator, or the <replaceable>flags</> parameter to a regex
    function.
    The available option letters are
    shown in <xref linkend="posix-embedded-options-table">.
    Note that these same option letters are used in the <replaceable>flags</>
    parameters of regex functions.
-->
AREは<firstterm>埋め込みオプション</>から始められます。<literal>(?</><replaceable>xyz</><literal>)</>という並びで残りのREに影響するオプションを指定します（ここで<replaceable>xyz</>は1つ以上の英字です）。
このオプションは、事前に決定されたオプションを上書きします。&mdash 特に、正規表現演算子、もしくは正規表現関数に与えられた<replaceable>flags</>パラメータにより示される大文字小文字の区別を上書きします。
使用可能なオプション文字を<xref linkend="posix-embedded-options-table">に示します。
これらの同じオプション文字が、正規表現関数の<replaceable>flags</>パラメータで使用されることに注意して下さい。
   </para>

   <table id="posix-embedded-options-table">
<!--
    <title>ARE Embedded-option Letters</title>
-->
    <title>ARE埋め込みオプション文字</title>

    <tgroup cols="2">
     <thead>
      <row>
<!--
       <entry>Option</entry>
       <entry>Description</entry>
-->
       <entry>オプション</entry>
       <entry>説明</entry>
      </row>
     </thead>

      <tbody>
       <row>
       <entry> <literal>b</> </entry>
<!--
       <entry> rest of RE is a BRE </entry>
-->
       <entry> 残りのREはBRE </entry>
       </row>

       <row>
       <entry> <literal>c</> </entry>
<!--
       <entry> case-sensitive matching (overrides operator type) </entry>
-->
       <entry> 大文字小文字を区別する一致（演算子で規定される大文字小文字の区別よりこの指定が優先されます）。 </entry>
       </row>

       <row>
       <entry> <literal>e</> </entry>
<!--
       <entry> rest of RE is an ERE </entry>
-->
       <entry> 残りのREはERE </entry>
       </row>

       <row>
       <entry> <literal>i</> </entry>
<!--
       <entry> case-insensitive matching (see
       <xref linkend="posix-matching-rules">) (overrides operator type) </entry>
-->
       <entry> 大文字小文字を区別しない一致（<xref linkend="posix-matching-rules">を参照）（演算子で規定される大文字小文字の区別よりこの指定が優先されます）。 </entry>
       </row>

       <row>
       <entry> <literal>m</> </entry>
<!--
       <entry> historical synonym for <literal>n</> </entry>
-->
       <entry> <literal>n</>の歴史的な同義語 </entry>
       </row>

       <row>
       <entry> <literal>n</> </entry>
<!--
       <entry> newline-sensitive matching (see
       <xref linkend="posix-matching-rules">) </entry>
-->
       <entry> 改行を区別する一致（<xref linkend="posix-matching-rules">を参照）</entry>
       </row>

       <row>
       <entry> <literal>p</> </entry>
<!--
       <entry> partial newline-sensitive matching (see
       <xref linkend="posix-matching-rules">) </entry>
-->
       <entry> 部分的な改行を区別する一致（<xref linkend="posix-matching-rules">を参照）</entry>
       </row>

       <row>
       <entry> <literal>q</> </entry>
<!--
       <entry> rest of RE is a literal (<quote>quoted</>) string, all ordinary
       characters </entry>
-->
       <entry> 残りのREはリテラル（<quote>引用符付けされた</>）文字列、全て普通の文字</entry>
       </row>

       <row>
       <entry> <literal>s</> </entry>
<!--
       <entry> non-newline-sensitive matching (default) </entry>
-->
       <entry> 改行を区別しないマッチ（デフォルト）</entry>
       </row>

       <row>
       <entry> <literal>t</> </entry>
<!--
       <entry> tight syntax (default; see below) </entry>
-->
       <entry> 厳しめの構文（デフォルト、後述） </entry>
       </row>

       <row>
       <entry> <literal>w</> </entry>
<!--
       <entry> inverse partial newline-sensitive (<quote>weird</>) matching
       (see <xref linkend="posix-matching-rules">) </entry>
-->
       <entry> 部分的な改行区別の逆（<quote>ワイアード</>）マッチ（<xref linkend="posix-matching-rules">を参照）</entry>
       </row>

       <row>
       <entry> <literal>x</> </entry>
<!--
       <entry> expanded syntax (see below) </entry>
-->
       <entry> 拡張構文（後述） </entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
<!--
    Embedded options take effect at the <literal>)</> terminating the sequence.
    They can appear only at the start of an ARE (after the
    <literal>***:</> director if any).
-->
埋め込みオプションはその並びの終端<literal>)</>で有効になります。
AREの先頭（もし<literal>***:</>決定子があればその後）でのみ利用可能です。
   </para>

   <para>
<!--
    In addition to the usual (<firstterm>tight</>) RE syntax, in which all
    characters are significant, there is an <firstterm>expanded</> syntax,
    available by specifying the embedded <literal>x</> option.
    In the expanded syntax,
    white-space characters in the RE are ignored, as are
    all characters between a <literal>#</>
    and the following newline (or the end of the RE).  This
    permits paragraphing and commenting a complex RE.
    There are three exceptions to that basic rule:
-->
全ての文字が意味を持つ、通常の（<firstterm>厳しめの</>）RE構文に加え、<literal>x</>埋め込みオプションを指定することで利用できる<firstterm>拡張</>構文があります。
拡張構文では、RE内の空白文字は無視され、<literal>#</>とその後の改行（もしくはREの終端）の間の全ての文字も同様です。
これにより、段落付けや複雑なREのコメント付けが可能になります。
基本規則に対して3つの例外があります。

    <itemizedlist>
     <listitem>
      <para>
<!--
       a white-space character or <literal>#</> preceded by <literal>\</> is
       retained
-->
直前に<literal>\</>が付いた空白文字もしくは<literal>#</>は保持されます。
      </para>
     </listitem>
     <listitem>
      <para>
<!--
       white space or <literal>#</> within a bracket expression is retained
-->
ブラケット式内の空白文字もしくは<literal>#</>は保持されます。
      </para>
     </listitem>
     <listitem>
      <para>
<!--
       white space and comments cannot appear within multi-character symbols,
       such as <literal>(?:</>
-->
<literal>(?:</>などの複数文字シンボルでは、空白文字とコメントは不正です。
      </para>
     </listitem>
    </itemizedlist>

<!--
    For this purpose, white-space characters are blank, tab, newline, and
    any character that belongs to the <replaceable>space</> character class.
-->
ここでの空白文字とは、空白、タブ、改行、<replaceable>スペース</>文字クラスに属する文字です。
   </para>

   <para>
<!--
    Finally, in an ARE, outside bracket expressions, the sequence
    <literal>(?#</><replaceable>ttt</><literal>)</>
    (where <replaceable>ttt</> is any text not containing a <literal>)</>)
    is a comment, completely ignored.
    Again, this is not allowed between the characters of
    multi-character symbols, like <literal>(?:</>.
    Such comments are more a historical artifact than a useful facility,
    and their use is deprecated; use the expanded syntax instead.
-->
最後に、AREのブラケット式の外側では、<literal>(?#</><replaceable>ttt</><literal>)</>という並びはコメントになります（ここで<replaceable>ttt</>は<literal>)</>を含まない任意のテキストです）。
繰り返しになりますが、これは<literal>(?:</>などの複数文字シンボルの文字間では使用できません。
こうしたコメントは実用性というより歴史的所産です。そのため、この使用は勧めません。代わりに拡張構文を使用してください。
   </para>

   <para>
<!--
    <emphasis>None</> of these metasyntax extensions is available if
    an initial <literal>***=</> director
    has specified that the user's input be treated as a literal string
    rather than as an RE.
-->
初めに<literal>***=</>決定子が指定され、ユーザの入力がREではなくリテラルとして扱われる場合、これらのメタ構文拡張は使用<emphasis>できません</>。
   </para>
   </sect3>

   <sect3 id="posix-matching-rules">
<!--
    <title>Regular Expression Matching Rules</title>
-->
    <title>正規表現マッチ規則</title>

   <para>
<!--
    In the event that an RE could match more than one substring of a given
    string, the RE matches the one starting earliest in the string.
    If the RE could match more than one substring starting at that point,
    either the longest possible match or the shortest possible match will
    be taken, depending on whether the RE is <firstterm>greedy</> or
    <firstterm>non-greedy</>.
-->
REが文字列の中の1つ以上の部分文字列と一致する場合において、REは最初にマッチが始まった部分文字列と一致します。
その位置からまた1つ以上の部分文字列とマッチした際は、正規表現は<firstterm>最短マッチを行わない（欲張り型）</>か<firstterm>最短マッチを行う（非欲張り型）</>かによって、最長一致もしくは最短一致の文字列のどちらかに一致します
   </para>

   <para>
<!--
    Whether an RE is greedy or not is determined by the following rules:
-->
REが最長マッチかどうかは以下の規則によって決まります。
    <itemizedlist>
     <listitem>
      <para>
<!--
       Most atoms, and all constraints, have no greediness attribute (because
       they cannot match variable amounts of text anyway).
-->
ほとんどのアトムおよび全ての式は欲張り属性を持ちません（これらは変動する量のテキストにまったく一致しないからです）。
      </para>
     </listitem>
     <listitem>
      <para>
<!--
       Adding parentheses around an RE does not change its greediness.
-->
REを括弧で括ることは欲張りかどうかを変更しません。
      </para>
     </listitem>
     <listitem>
      <para>
<!--
       A quantified atom with a fixed-repetition quantifier
       (<literal>{</><replaceable>m</><literal>}</>
       or
       <literal>{</><replaceable>m</><literal>}?</>)
       has the same greediness (possibly none) as the atom itself.
-->
<literal>{</><replaceable>m</><literal>}</>もしくは<literal>{</><replaceable>m</><literal>}?</>といった固定繰り返し数の量指定子を持つ量指定付きアトムは、アトム自身と同一の欲張りさを持ちます（まったく持たない可能性もあります）。
      </para>
     </listitem>
     <listitem>
      <para>
<!--
       A quantified atom with other normal quantifiers (including
       <literal>{</><replaceable>m</><literal>,</><replaceable>n</><literal>}</>
       with <replaceable>m</> equal to <replaceable>n</>)
       is greedy (prefers longest match).
-->
他の通常の量指定子（<literal>{</><replaceable>m</><literal>,</><replaceable>n</><literal>}</>、<replaceable>m</>と<replaceable>n</>が等しい場合も含みます）を持つ量指定付きアトムは欲張り型です（最長マッチを使用します）。
      </para>
     </listitem>
     <listitem>
      <para>
<!--
       A quantified atom with a non-greedy quantifier (including
       <literal>{</><replaceable>m</><literal>,</><replaceable>n</><literal>}?</>
       with <replaceable>m</> equal to <replaceable>n</>)
       is non-greedy (prefers shortest match).
-->
他の非欲張り型量指定子（<literal>{</><replaceable>m</><literal>,</><replaceable>n</><literal>}?</>、<replaceable>m</>と<replaceable>n</>が等しい場合も含みます）を持つ量指定付きアトムは非欲張り型です（最短マッチを使用します）。
      </para>
     </listitem>
     <listitem>
      <para>
<!--
       A branch &mdash; that is, an RE that has no top-level
       <literal>|</> operator &mdash; has the same greediness as the first
       quantified atom in it that has a greediness attribute.
-->
最上位レベルの<literal>|</>演算子を持たないREであるブランチは、最初の欲張り属性を持つ量指定付きアトムと同一の欲張り属性を持ちます。
      </para>
     </listitem>
     <listitem>
      <para>
<!--
       An RE consisting of two or more branches connected by the
       <literal>|</> operator is always greedy.
-->
<literal>|</>演算子で接続された2つ以上のブランチからなるREは常に欲張り型です。
      </para>
     </listitem>
    </itemizedlist>
   </para>

   <para>
<!--
    The above rules associate greediness attributes not only with individual
    quantified atoms, but with branches and entire REs that contain quantified
    atoms.  What that means is that the matching is done in such a way that
    the branch, or whole RE, matches the longest or shortest possible
    substring <emphasis>as a whole</>.  Once the length of the entire match
    is determined, the part of it that matches any particular subexpression
    is determined on the basis of the greediness attribute of that
    subexpression, with subexpressions starting earlier in the RE taking
    priority over ones starting later.
-->
上の規則は、個々の量指定付きアトムだけではなく、量指定付きアトムを複数含むブランチやRE全体の欲張り属性に関連します。
つまり、ブランチやRE全体が<emphasis>全体として</>最長または最短の部分文字列に一致するという方法でマッチ処理が行われます。
全体のマッチの長さが決まると、特定の部分式に一致する部分がその部分式の欲張り属性によって決まります。この時、RE内でより前にある部分式が後にある部分式よりも高い優先度を持ちます。
   </para>

   <para>
<!--
    An example of what this means:
-->
この意味の例を示します。
<screen>
SELECT SUBSTRING('XY1234Z', 'Y*([0-9]{1,3})');
<lineannotation>Result: </lineannotation><computeroutput>123</computeroutput>
SELECT SUBSTRING('XY1234Z', 'Y*?([0-9]{1,3})');
<lineannotation>Result: </lineannotation><computeroutput>1</computeroutput>
</screen>
<!--
    In the first case, the RE as a whole is greedy because <literal>Y*</>
    is greedy.  It can match beginning at the <literal>Y</>, and it matches
    the longest possible string starting there, i.e., <literal>Y123</>.
    The output is the parenthesized part of that, or <literal>123</>.
    In the second case, the RE as a whole is non-greedy because <literal>Y*?</>
    is non-greedy.  It can match beginning at the <literal>Y</>, and it matches
    the shortest possible string starting there, i.e., <literal>Y1</>.
    The subexpression <literal>[0-9]{1,3}</> is greedy but it cannot change
    the decision as to the overall match length; so it is forced to match
    just <literal>1</>.
-->
最初の例では、<literal>Y*</>が欲張り型であるため、REは全体として欲張り型です。
マッチは<literal>Y</>の位置から始まり、そこから可能な限り最長の文字列に一致します。つまり<literal>Y123</>となります。
出力は括弧で括られた部分、つまり<literal>123</>となります。
2番目の例では、<literal>Y*?</>が非欲張り型のため、REは全体として非欲張り型です。
マッチは<literal>Y</>の位置から始まり、そこから可能な限り最短の文字列に一致します。つまり<literal>Y1</>となります。
部分式<literal>[0-9]{1,3}</>は欲張り型ですが、決定された一致する全体の長さを変更することはできません。したがって、強制的に<literal>1</>に一致することになります。
   </para>

   <para>
<!--
    In short, when an RE contains both greedy and non-greedy subexpressions,
    the total match length is either as long as possible or as short as
    possible, according to the attribute assigned to the whole RE.  The
    attributes assigned to the subexpressions only affect how much of that
    match they are allowed to <quote>eat</> relative to each other.
-->
まとめると、REが欲張り型部分式と非欲張り型部分式の両方を持つ場合、全体のマッチ長はRE全体に割り当てられる属性に応じて、最長マッチ長か最短マッチ長のどちらかになります。
部分式に割り当てられた属性は、部分式の中でどれだけの量をその部分式の中で<quote>消費</>できるかのみに影響します。
   </para>

   <para>
<!--
    The quantifiers <literal>{1,1}</> and <literal>{1,1}?</>
    can be used to force greediness or non-greediness, respectively,
    on a subexpression or a whole RE.
-->
<literal>{1,1}</>および<literal>{1,1}?</>量指定子を副式もしくはRE全体に使用して、それぞれ、欲張りか欲張りでないかを強制することが可能です。
   </para>

   <para>
<!--
    Match lengths are measured in characters, not collating elements.
    An empty string is considered longer than no match at all.
    For example:
    <literal>bb*</>
    matches the three middle characters of <literal>abbbc</>;
    <literal>(week|wee)(night|knights)</>
    matches all ten characters of <literal>weeknights</>;
    when <literal>(.*).*</>
    is matched against <literal>abc</> the parenthesized subexpression
    matches all three characters; and when
    <literal>(a*)*</> is matched against <literal>bc</>
    both the whole RE and the parenthesized
    subexpression match an empty string.
-->
マッチの長さは照合要素ではなく文字列で測られます。
空文字列はまったく一致する要素がない文字列よりも長いと考えられます。
例えば、<literal>bb*</literal>は<literal>abbbc</literal>の真中の3文字と一致し、<literal>(week|wee)(night|knights)</literal>は<literal>weeknights</literal>の全ての10文字と一致し、<literal>abc</literal>に対して<literal>(.*).*</literal>が一致されると、括弧内の部分正規表現は3つの文字全てに一致し、<literal>bc</literal>に対して<literal>(a*)*</literal>が一致されると、全体のREと括弧内の正規表現は空文字列に一致します。
   </para>

   <para>
<!--
    If case-independent matching is specified,
    the effect is much as if all case distinctions had vanished from the
    alphabet.
    When an alphabetic that exists in multiple cases appears as an
    ordinary character outside a bracket expression, it is effectively
    transformed into a bracket expression containing both cases,
    e.g., <literal>x</> becomes <literal>[xX]</>.
    When it appears inside a bracket expression, all case counterparts
    of it are added to the bracket expression, e.g.,
    <literal>[x]</> becomes <literal>[xX]</>
    and <literal>[^x]</> becomes <literal>[^xX]</>.
-->
もし大文字小文字を区別しない一致が指定されると、アルファベット文字の大文字小文字の区別がまったくなくなったのと同じ効果を与えます。
ブラケット式の外側にアルファベットの大文字小文字が混ざった通常の文字が出てきた場合、例えば、<literal>x</literal>が<literal>[xX]</literal>となるように大文字小文字ともにブラケット式に実質的に転換されます。
ブラケット式の中に現れた時は、（例えば）<literal>[x]</literal>が<literal>[xX]</literal>となり、また<literal>[^x]</literal>が<literal>[^xX]</literal>となるように、全ての大文字小文字それぞれの対がブラケット式に追加されます。
   </para>

   <para>
<!--
    If newline-sensitive matching is specified, <literal>.</>
    and bracket expressions using <literal>^</>
    will never match the newline character
    (so that matches will never cross newlines unless the RE
    explicitly arranges it)
    and <literal>^</> and <literal>$</>
    will match the empty string after and before a newline
    respectively, in addition to matching at beginning and end of string
    respectively.
    But the ARE escapes <literal>\A</> and <literal>\Z</>
    continue to match beginning or end of string <emphasis>only</>.
-->
改行を区別するマッチが指定されると、<literal>.</>と<literal>^</>を使用するブラケット式は（REが明示的に調整されていたとしてもマッチが改行をまたがらないようにするために）改行文字に一致しなくなります。また、<literal>^</>と<literal>$</>はそれぞれ改行直後と直前の空文字列に一致し、さらに、それぞれ文字列の先頭と末尾に一致します。
しかし、AREエスケープの<literal>\A</>と<literal>\Z</>は、継続して、文字列の先頭と末尾<emphasis>のみ</>に一致します。
   </para>

   <para>
<!--
    If partial newline-sensitive matching is specified,
    this affects <literal>.</> and bracket expressions
    as with newline-sensitive matching, but not <literal>^</>
    and <literal>$</>.
-->
部分的に改行を区別するマッチが指定されると、<literal>.</>とブラケット式は改行を区別する一致を行うようになりますが、<literal>^</>と<literal>$</>は変更されません。
   </para>

   <para>
<!--
    If inverse partial newline-sensitive matching is specified,
    this affects <literal>^</> and <literal>$</>
    as with newline-sensitive matching, but not <literal>.</>
    and bracket expressions.
    This isn't very useful but is provided for symmetry.
-->
部分的に改行を区別する逆マッチが指定されると、<literal>^</>と<literal>$</>は改行を区別する一致を行うようになりますが、<literal>.</>とブラケット式は変更されません。
これはあまり有用ではありません。対称性のために提供されています。
   </para>
   </sect3>

   <sect3 id="posix-limits-compatibility">
<!--
    <title>Limits and Compatibility</title>
-->
    <title>制限と互換性</title>

   <para>
<!--
    No particular limit is imposed on the length of REs in this
    implementation.  However,
    programs intended to be highly portable should not employ REs longer
    than 256 bytes,
    as a POSIX-compliant implementation can refuse to accept such REs.
-->
本実装ではREの長さに関する制限はありません。
しかし、移植性を高めたいプログラムでは、256バイトを超えるREを使用すべきではありません。POSIX互換の実装ではそうしたREでは混乱する可能性があります。
   </para>

   <para>
<!--
    The only feature of AREs that is actually incompatible with
    POSIX EREs is that <literal>\</> does not lose its special
    significance inside bracket expressions.
    All other ARE features use syntax which is illegal or has
    undefined or unspecified effects in POSIX EREs;
    the <literal>***</> syntax of directors likewise is outside the POSIX
    syntax for both BREs and EREs.
-->
AREの機能のうち、POSIX EREと実質的な非互換性があるのは、<literal>\</>がブラケット式の内側で特殊な意味を失わないという点のみです。
他の全てのARE機能は、POSIX EREでは不正、未定義、未指定な効果となる構文を使用しています。決定子の<literal>***</>構文などはBREおよびEREのPOSIX構文にはありません。
   </para>

   <para>
<!--
    Many of the ARE extensions are borrowed from Perl, but some have
    been changed to clean them up, and a few Perl extensions are not present.
    Incompatibilities of note include <literal>\b</>, <literal>\B</>,
    the lack of special treatment for a trailing newline,
    the addition of complemented bracket expressions to the things
    affected by newline-sensitive matching,
    the restrictions on parentheses and back references in lookahead
    constraints, and the longest/shortest-match (rather than first-match)
    matching semantics.
-->
多くのARE拡張はPerlから拝借したものです。しかし、いくつかは整理され、Perlの拡張のいくつかは存在しません。注意すべき非互換性には、<literal>\b</>、<literal>\B</>、改行の取り扱いに関する特殊な措置の欠落、改行を区別する一致に影響する点について補足したブラケット式の追加、括弧と先行検索制約内の後方参照についての制限、最長/最短（最初に一致するではなく）マッチのセマンティックがあります。
   </para>

   <para>
<!--
    Two significant incompatibilities exist between AREs and the ERE syntax
    recognized by pre-7.4 releases of <productname>PostgreSQL</>:
-->
<productname>PostgreSQL</>リリース7.4より前で認知された、AREとERE構文間で大きな非互換が2つあります。

    <itemizedlist>
     <listitem>
      <para>
<!--
       In AREs, <literal>\</> followed by an alphanumeric character is either
       an escape or an error, while in previous releases, it was just another
       way of writing the alphanumeric.
       This should not be much of a problem because there was no reason to
       write such a sequence in earlier releases.
-->
AREでは、<literal>\</>の後に英数字が続くものはエスケープもしくはエラーとなります。以前のリリースでは、これは単に、英数字を記述する他の方法でした。
これは、大きな問題にはならないはずです。以前のリリースではこうした並びを記述する理由がないからです。
      </para>
     </listitem>
     <listitem>
      <para>
<!--
       In AREs, <literal>\</> remains a special character within
       <literal>[]</>, so a literal <literal>\</> within a bracket
       expression must be written <literal>\\</>.
-->
AREでは、<literal>\</>は<literal>[]</>内でも特別な文字です。したがって、ブラケット式では<literal>\</>を<literal>\\</>と記述しなければなりません。
      </para>
     </listitem>
    </itemizedlist>
   </para>
   </sect3>

   <sect3 id="posix-basic-regexes">
<!--
    <title>Basic Regular Expressions</title>
-->
    <title>基本正規表現</title>

   <para>
<!--
    BREs differ from EREs in several respects.
    In BREs, <literal>|</>, <literal>+</>, and <literal>?</>
    are ordinary characters and there is no equivalent
    for their functionality.
    The delimiters for bounds are
    <literal>\{</> and <literal>\}</>,
    with <literal>{</> and <literal>}</>
    by themselves ordinary characters.
    The parentheses for nested subexpressions are
    <literal>\(</> and <literal>\)</>,
    with <literal>(</> and <literal>)</> by themselves ordinary characters.
    <literal>^</> is an ordinary character except at the beginning of the
    RE or the beginning of a parenthesized subexpression,
    <literal>$</> is an ordinary character except at the end of the
    RE or the end of a parenthesized subexpression,
    and <literal>*</> is an ordinary character if it appears at the beginning
    of the RE or the beginning of a parenthesized subexpression
    (after a possible leading <literal>^</>).
    Finally, single-digit back references are available, and
    <literal>\&lt;</> and <literal>\&gt;</>
    are synonyms for
    <literal>[[:&lt;:]]</> and <literal>[[:&gt;:]]</>
    respectively; no other escapes are available in BREs.
-->
BREはEREといくつかの面において異なります。
BREにおいては、<literal>|</>、<literal>+</>、<literal>?</>は普通の文字であり、それらの機能と等価なものはありません。
バウンドの区切りは<literal>\{</>と<literal>\}</>であり、<literal>{</>と<literal>}</>自身は普通の文字です。
副式を入れ子にするための括弧は<literal>\(</>と<literal>\)</>であり、<literal>(</>と<literal>)</>自身は普通の文字です。
<literal>^</>は、REの先頭にある場合や括弧内の副式の先頭の場合を除き、普通の文字です。
<literal>$</>は、REの末尾にある場合や括弧内の副式の末尾の場合を除き、普通の文字です。
また、<literal>*</>はREの先頭にある場合や括弧内の副式の先頭にある場合には普通の文字になります（その前に<literal>^</>が付いている可能性もあります）。
最後に、1桁の後方参照を使用することができ、また、BREにおいては、<literal>\&lt;</>と<literal>\&gt;</>はそれぞれ<literal>[[:&lt;:]]</>と<literal>[[:&gt;:]]</>と同義です。
   </para>
   </sect3>

<!-- end re_syntax.n man page -->

  </sect2>
 </sect1>


  <sect1 id="functions-formatting">
<!--
   <title>Data Type Formatting Functions</title>
-->
   <title>データ型書式設定関数</title>

   <indexterm>
<!--
    <primary>formatting</primary>
-->
    <primary>書式設定</primary>
   </indexterm>

   <para>
<!--
    The <productname>PostgreSQL</productname> formatting functions
    provide a powerful set of tools for converting various data types
    (date/time, integer, floating point, numeric) to formatted strings
    and for converting from formatted strings to specific data types.
    <xref linkend="functions-formatting-table"> lists them.
    These functions all follow a common calling convention: the first
    argument is the value to be formatted and the second argument is a
    template that defines the output or input format.
-->
<productname>PostgreSQL</productname>の書式設定関数は多彩なデータ型（日付/時刻データ型、整数データ型、浮動小数点数データ型、数値データ型）を整形された文字列に変換したり、整形された文字列を特定のデータ型に変換する強力なツールの一式を提供しています。
<xref linkend="functions-formatting-table">にこれらを列挙しています。
これら関数は共通の呼び出し規約を踏襲しています。最初の引数は整形される値で2番目の引数は入力書式または出力書式を定義するテンプレートです。
   </para>
   <para>
<!--
    A single-argument <function>to_timestamp</function> function is also
    available;  it accepts a
    <type>double precision</type> argument and converts from Unix epoch
    (seconds since 1970-01-01 00:00:00+00) to
    <type>timestamp with time zone</type>.
    (<type>Integer</type> Unix epochs are implicitly cast to
    <type>double precision</type>.)
-->
単一引数の<function>to_timestamp</function>関数も利用可能です。
これは<type>double precision</type>型の引数を取り、Unix時刻（1970-01-01 00:00:00+00からの秒数）から<type>timestamp with time zone</type>に変換します。
（<type>Integer</type>型のUnix時刻は暗黙的に<type>double precision</type>にキャストされます。）
   </para>

    <table id="functions-formatting-table">
<!--
     <title>Formatting Functions</title>
-->
     <title>書式設定関数</title>
     <tgroup cols="4">
      <thead>
       <row>
<!--
        <entry>Function</entry>
        <entry>Return Type</entry>
        <entry>Description</entry>
        <entry>Example</entry>
-->
        <entry>関数</entry>
        <entry>戻り値</entry>
        <entry>説明</entry>
        <entry>例</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>
         <indexterm>
          <primary>to_char</primary>
         </indexterm>
         <literal><function>to_char(<type>timestamp</type>, <type>text</type>)</function></literal>
        </entry>
        <entry><type>text</type></entry>
<!--
        <entry>convert time stamp to string</entry>
-->
        <entry>タイムスタンプを文字列に変換</entry>
        <entry><literal>to_char(current_timestamp, 'HH12:MI:SS')</literal></entry>
       </row>
       <row>
        <entry><literal><function>to_char(<type>interval</type>, <type>text</type>)</function></literal></entry>
        <entry><type>text</type></entry>
<!--
        <entry>convert interval to string</entry>
-->
        <entry>時間間隔を文字列に変換</entry>
        <entry><literal>to_char(interval '15h&nbsp;2m&nbsp;12s', 'HH24:MI:SS')</literal></entry>
       </row>
       <row>
        <entry><literal><function>to_char(<type>int</type>, <type>text</type>)</function></literal></entry>
        <entry><type>text</type></entry>
<!--
        <entry>convert integer to string</entry>
-->
        <entry>整数を文字列に変換</entry>
        <entry><literal>to_char(125, '999')</literal></entry>
       </row>
       <row>
        <entry><literal><function>to_char</function>(<type>double precision</type>,
        <type>text</type>)</literal></entry>
        <entry><type>text</type></entry>
<!--
        <entry>convert real/double precision to string</entry>
-->
        <entry>実数、倍精度数を文字列に変換</entry>
        <entry><literal>to_char(125.8::real, '999D9')</literal></entry>
       </row>
       <row>
        <entry><literal><function>to_char(<type>numeric</type>, <type>text</type>)</function></literal></entry>
        <entry><type>text</type></entry>
<!--
        <entry>convert numeric to string</entry>
-->
        <entry>数値を文字列に変換</entry>
        <entry><literal>to_char(-125.8, '999D99S')</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>to_date</primary>
         </indexterm>
         <literal><function>to_date(<type>text</type>, <type>text</type>)</function></literal>
        </entry>
        <entry><type>date</type></entry>
<!--
        <entry>convert string to date</entry>
-->
        <entry>文字列を日付に変換</entry>
        <entry><literal>to_date('05&nbsp;Dec&nbsp;2000', 'DD&nbsp;Mon&nbsp;YYYY')</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>to_number</primary>
         </indexterm>
         <literal><function>to_number(<type>text</type>, <type>text</type>)</function></literal>
        </entry>
        <entry><type>numeric</type></entry>
<!--
        <entry>convert string to numeric</entry>
-->
        <entry>文字列を数値に変換します</entry>
        <entry><literal>to_number('12,454.8-', '99G999D9S')</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>to_timestamp</primary>
         </indexterm>
         <literal><function>to_timestamp(<type>text</type>, <type>text</type>)</function></literal>
        </entry>
        <entry><type>timestamp with time zone</type></entry>
<!--
        <entry>convert string to time stamp</entry>
-->
        <entry>文字列をタイムスタンプに変換</entry>
        <entry><literal>to_timestamp('05&nbsp;Dec&nbsp;2000', 'DD&nbsp;Mon&nbsp;YYYY')</literal></entry>
       </row>
       <row>
        <entry><literal><function>to_timestamp(<type>double precision</type>)</function></literal></entry>
        <entry><type>timestamp with time zone</type></entry>
<!--
        <entry>convert Unix epoch to time stamp</entry>
-->
        <entry>Unix時刻をタイムスタンプに変換</entry>
        <entry><literal>to_timestamp(1284352323)</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
<!--
    In a <function>to_char</> output template string, there are certain
    patterns that are recognized and replaced with appropriately-formatted
    data based on the given value.  Any text that is not a template pattern is
    simply copied verbatim.  Similarly, in an input template string (for the
    other functions), template patterns identify the values to be supplied by
    the input data string.
-->
（<function>to_char</>用）出力テンプレート文字列には、値に基づいて認識され、適切に整形されたデータで置き換えられるパターンがあります。
テンプレートパターンではない全てのテキストは単にそのままコピーされます。
同様に、（その他の関数に対し）入力テンプレート文字列では、テンプレートパターンは入力されたデータ文字列で供給される値を特定します。
   </para>

  <para>
<!--
   <xref linkend="functions-formatting-datetime-table"> shows the
   template patterns available for formatting date and time values.
-->
<xref linkend="functions-formatting-datetime-table">に、日付/時刻型の値の書式に使用可能なテンプレートパターンを示します。
  </para>

    <table id="functions-formatting-datetime-table">
<!--
     <title>Template Patterns for Date/Time Formatting</title>
-->
     <title>日付/時刻型の書式テンプレートパターン</title>
     <tgroup cols="2">
      <thead>
       <row>
<!--
        <entry>Pattern</entry>
        <entry>Description</entry>
-->
        <entry>パターン</entry>
        <entry>説明</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><literal>HH</literal></entry>
<!--
        <entry>hour of day (01-12)</entry>
-->
        <entry>時（01〜12）</entry>
       </row>
       <row>
        <entry><literal>HH12</literal></entry>
<!--
        <entry>hour of day (01-12)</entry>
-->
        <entry>時（01〜12）</entry>
       </row>
       <row>
        <entry><literal>HH24</literal></entry>
<!--
        <entry>hour of day (00-23)</entry>
-->
        <entry>時（00〜23）</entry>
       </row>
       <row>
        <entry><literal>MI</literal></entry>
<!--
        <entry>minute (00-59)</entry>
-->
        <entry>分（00〜59）</entry>
       </row>
       <row>
        <entry><literal>SS</literal></entry>
<!--
        <entry>second (00-59)</entry>
-->
        <entry>秒（00〜59）</entry>
       </row>
       <row>
        <entry><literal>MS</literal></entry>
<!--
        <entry>millisecond (000-999)</entry>
-->
        <entry>ミリ秒（000〜999）</entry>
       </row>
       <row>
        <entry><literal>US</literal></entry>
<!--
        <entry>microsecond (000000-999999)</entry>
-->
        <entry>マイクロ秒（000000〜999999）</entry>
       </row>
       <row>
        <entry><literal>SSSS</literal></entry>
<!--
        <entry>seconds past midnight (0-86399)</entry>
-->
        <entry>深夜0時からの秒数（0〜86399）</entry>
       </row>
       <row>
<!--
        <entry><literal>AM</literal>, <literal>am</literal>,
        <literal>PM</literal> or <literal>pm</literal></entry>
-->
        <entry><literal>AM</literal>、<literal>am</literal>、
        <literal>PM</literal>、または<literal>pm</literal></entry>
<!--
        <entry>meridiem indicator (without periods)</entry>
-->
        <entry>午前/午後の指定（ピリオドなし）</entry>
       </row>
       <row>
<!--
        <entry><literal>A.M.</literal>, <literal>a.m.</literal>,
        <literal>P.M.</literal> or <literal>p.m.</literal></entry>
-->
        <entry><literal>A.M.</literal>、<literal>a.m.</literal>、
        <literal>P.M.</literal>、または<literal>p.m.</literal></entry>
<!--
        <entry>meridiem indicator (with periods)</entry>
-->
        <entry>午前/午後の指定（ピリオド付き）</entry>
       </row>
       <row>
        <entry><literal>Y,YYY</literal></entry>
<!--
        <entry>year (4 and more digits) with comma</entry>
-->
        <entry>句読点（コンマ）付き年（4桁以上）</entry>
       </row>
       <row>
        <entry><literal>YYYY</literal></entry>
<!--
        <entry>year (4 and more digits)</entry>
-->
        <entry>年（4桁以上）</entry>
       </row>
       <row>
        <entry><literal>YYY</literal></entry>
<!--
        <entry>last 3 digits of year</entry>
-->
        <entry>年の下3桁</entry>
       </row>
       <row>
        <entry><literal>YY</literal></entry>
<!--
        <entry>last 2 digits of year</entry>
-->
        <entry>年の下2桁</entry>
       </row>
       <row>
        <entry><literal>Y</literal></entry>
<!--
        <entry>last digit of year</entry>
-->
        <entry>年の下1桁</entry>
       </row>
       <row>
        <entry><literal>IYYY</literal></entry>
<!--
        <entry>ISO year (4 and more digits)</entry>
-->
        <entry>ISO年（4以上の桁）</entry>
       </row>
       <row>
        <entry><literal>IYY</literal></entry>
<!--
        <entry>last 3 digits of ISO year</entry>
-->
        <entry>ISO年の下3桁</entry>
       </row>
       <row>
        <entry><literal>IY</literal></entry>
<!--
        <entry>last 2 digits of ISO year</entry>
-->
        <entry>ISO年の下2桁</entry>
       </row>
       <row>
        <entry><literal>I</literal></entry>
<!--
        <entry>last digit of ISO year</entry>
-->
        <entry>ISO年の下1桁</entry>
       </row>
       <row>
<!--
        <entry><literal>BC</literal>, <literal>bc</literal>,
        <literal>AD</literal> or <literal>ad</literal></entry>
-->
        <entry><literal>BC</literal>、<literal>bc</literal>、
        <literal>AD</literal>、または<literal>ad</literal></entry>
<!--
        <entry>era indicator (without periods)</entry>
-->
        <entry>紀元前後の指定（ピリオドなし）</entry>
       </row>
       <row>
<!--
        <entry><literal>B.C.</literal>, <literal>b.c.</literal>,
        <literal>A.D.</literal> or <literal>a.d.</literal></entry>
-->
        <entry><literal>B.C.</literal>、<literal>b.c.</literal>、
        <literal>A.D.</literal>、または<literal>a.d.</literal></entry>
<!--
        <entry>era indicator (with periods)</entry>
-->
        <entry>紀元前後の指定（ピリオド付き）</entry>
       </row>
       <row>
        <entry><literal>MONTH</literal></entry>
<!--
        <entry>full upper case month name (blank-padded to 9 chars)</entry>
-->
        <entry>大文字での完全な月名（9文字になるように空白でパッド）</entry>
       </row>
       <row>
        <entry><literal>Month</literal></entry>
<!--
        <entry>full capitalized month name (blank-padded to 9 chars)</entry>
-->
        <entry>大文字で書き始める完全な月名（9文字になるように空白でパッド）</entry>
       </row>
       <row>
        <entry><literal>month</literal></entry>
<!--
        <entry>full lower case month name (blank-padded to 9 chars)</entry>
-->
        <entry>小文字での完全な月名（9文字になるように空白でパッド）</entry>
       </row>
       <row>
        <entry><literal>MON</literal></entry>
<!--
        <entry>abbreviated upper case month name (3 chars in English, localized lengths vary)</entry>
-->
        <entry>大文字での短縮形の月名（英語では3文字、現地語化された場合は可変長）</entry>
       </row>
       <row>
        <entry><literal>Mon</literal></entry>
<!--
        <entry>abbreviated capitalized month name (3 chars in English, localized lengths vary)</entry>
-->
        <entry>大文字で書き始める短縮形の月名（英語では3文字。現地語化された場合は可変長）</entry>
       </row>
       <row>
        <entry><literal>mon</literal></entry>
<!--
        <entry>abbreviated lower case month name (3 chars in English, localized lengths vary)</entry>
-->
        <entry>小文字での短縮形の月名（英語では3文字。現地語化された場合は可変長）</entry>
       </row>
       <row>
        <entry><literal>MM</literal></entry>
<!--
        <entry>month number (01-12)</entry>
-->
        <entry>月番号（01〜12）</entry>
       </row>
       <row>
        <entry><literal>DAY</literal></entry>
<!--
        <entry>full upper case day name (blank-padded to 9 chars)</entry>
-->
        <entry>大文字での完全な曜日名（9文字になるように空白でパッド）</entry>
       </row>
       <row>
        <entry><literal>Day</literal></entry>
<!--
        <entry>full capitalized day name (blank-padded to 9 chars)</entry>
-->
        <entry>大文字で書き始める完全な曜日名（9文字になるように空白でパッド）</entry>
       </row>
       <row>
        <entry><literal>day</literal></entry>
<!--
        <entry>full lower case day name (blank-padded to 9 chars)</entry>
-->
        <entry>小文字での完全な曜日名（9文字になるように空白でパッド）</entry>
       </row>
       <row>
        <entry><literal>DY</literal></entry>
<!--
        <entry>abbreviated upper case day name (3 chars in English, localized lengths vary)</entry>
-->
        <entry>短縮形の大文字での短縮形の曜日名（英語では3文字。現地語化された場合は可変長）</entry>
       </row>
       <row>
        <entry><literal>Dy</literal></entry>
<!--
        <entry>abbreviated capitalized day name (3 chars in English, localized lengths vary)</entry>
-->
        <entry>大文字で書き始める短縮形の曜日名（英語では3文字。現地語化された場合は可変長）</entry>
       </row>
       <row>
        <entry><literal>dy</literal></entry>
<!--
        <entry>abbreviated lower case day name (3 chars in English, localized lengths vary)</entry>
-->
        <entry>小文字での短縮形の曜日名（英語では3文字。現地語化された場合は可変長）</entry>
       </row>
       <row>
        <entry><literal>DDD</literal></entry>
<!--
        <entry>day of year (001-366)</entry>
-->
        <entry>通年の日にち番号（001〜366）</entry>
       </row>
       <row>
        <entry><literal>IDDD</literal></entry>
<!--
        <entry>ISO day of year (001-371; day 1 of the year is Monday of the first ISO week.)</entry>
-->
        <entry>ISO通年の日にち番号（001-371：通年 第１日は最初のISO週の月曜日）</entry>
       </row>
       <row>
        <entry><literal>DD</literal></entry>
<!--
        <entry>day of month (01-31)</entry>
-->
        <entry>ひと月通算の日にち番号（01〜31）</entry>
       </row>
       <row>
        <entry><literal>D</literal></entry>
<!--
        <entry>day of the week, Sunday(<literal>1</>) to Saturday(<literal>7</>)</entry>
-->
        <entry>1週通算の曜日番号、日曜日（<literal>1</>）から土曜日（<literal>7</>）まで</entry>
       </row>
       <row>
        <entry><literal>ID</literal></entry>
<!--
        <entry>ISO day of the week, Monday(<literal>1</>) to Sunday(<literal>7</>)</entry>
-->
        <entry>ISO1週通算の曜日番号、月曜日（<literal>1</>）から日曜日（<literal>7</>）まで</entry>
       </row>
       <row>
        <entry><literal>W</literal></entry>
<!--
        <entry>week of month (1-5) (The first week starts on the first day of the month.)</entry>
-->
        <entry>月中の週番号（1〜5）（その月の初日がある週が第1週）</entry>
       </row>
       <row>
        <entry><literal>WW</literal></entry>
<!--
        <entry>week number of year (1-53) (The first week starts on the first day of the year.)</entry>
-->
        <entry>年間を通じた週番号（1〜53）（元旦のある週が第1週）</entry>
       </row>
       <row>
        <entry><literal>IW</literal></entry>
<!--
        <entry>ISO week number of year (01 - 53; the first Thursday of the new year is in week 1.)</entry>
-->
        <entry>年間を通じたISO週番号（01 - 53：新年の最初の木曜日がある週が第1週）</entry>
       </row>
       <row>
        <entry><literal>CC</literal></entry>
<!--
        <entry>century (2 digits) (The twenty-first century starts on 2001-01-01.)</entry>
-->
        <entry>世紀（2桁。21世紀は2001-01-01から開始）</entry>
       </row>
       <row>
        <entry><literal>J</literal></entry>
<!--
        <entry>Julian Day (integer days since November 24, 4714 BC at midnight UTC)</entry>
-->
        <entry>ユリウス日（UTC紀元前4714年11月24日午前零時からの整数による通算経過日）</entry>
       </row>
       <row>
        <entry><literal>Q</literal></entry>
<!--
        <entry>quarter (ignored by <function>to_date</> and <function>to_timestamp</>)</entry>
-->
        <entry>クウォータ（四半期 : <function>to_date</>と<function>to_timestamp</>により無視されます）</entry>
       </row>
       <row>
        <entry><literal>RM</literal></entry>
<!--
        <entry>month in upper case Roman numerals (I-XII; I=January)</entry>
-->
        <entry>大文字ローマ数字による月（I〜XII：I=1月）</entry>
       </row>
       <row>
        <entry><literal>rm</literal></entry>
<!--
        <entry>month in lower case Roman numerals (i-xii; i=January)</entry>
-->
        <entry>小文字ローマ数字による月（i〜xii：i=1月）</entry>
       </row>
       <row>
        <entry><literal>TZ</literal></entry>
<!--
        <entry>upper case time-zone name</entry>
-->
        <entry>大文字による時間帯名</entry>
       </row>
       <row>
        <entry><literal>tz</literal></entry>
<!--
        <entry>lower case time-zone name</entry>
-->
        <entry>小文字による時間帯名</entry>
       </row>
       <row>
        <entry><literal>OF</literal></entry>
<!--
        <entry>time-zone offset</entry>
-->
        <entry>時間帯オフセット</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
<!--
    Modifiers can be applied to any template pattern to alter its
    behavior.  For example, <literal>FMMonth</literal>
    is the <literal>Month</literal> pattern with the
    <literal>FM</literal> modifier.
    <xref linkend="functions-formatting-datetimemod-table"> shows the
    modifier patterns for date/time formatting.
-->
修飾子はどのようなテンプレートパターンに対しても、その振舞いを変更するために適用することができます。
例えば、<literal>FMMonth</literal>は<literal>FM</literal>修飾子の付いた<literal>Month</literal>パターンです。
<xref linkend="functions-formatting-datetimemod-table">に、日付/時刻書式の修飾子パターンを示します。
   </para>

    <table id="functions-formatting-datetimemod-table">
<!--
     <title>Template Pattern Modifiers for Date/Time Formatting</title>
-->
     <title>日付/時刻書式用のテンプレートパターン修飾子</title>
     <tgroup cols="3">
      <thead>
       <row>
<!--
        <entry>Modifier</entry>
        <entry>Description</entry>
        <entry>Example</entry>
-->
        <entry>修飾子</entry>
        <entry>説明</entry>
        <entry>例</entry>
       </row>
      </thead>
      <tbody>
       <row>
<!--
        <entry><literal>FM</literal> prefix</entry>
-->
        <entry><literal>FM</literal>接頭辞</entry>
<!--
        <entry>fill mode (suppress padding blanks and trailing zeroes)</entry>
-->
        <entry>字詰めモード（空白のパディング、および末尾の0を無効）</entry>
        <entry><literal>FMMonth</literal></entry>
       </row>
       <row>
<!--
        <entry><literal>TH</literal> suffix</entry>
-->
        <entry><literal>TH</literal>接尾辞</entry>
<!--
        <entry>upper case ordinal number suffix</entry>
-->
        <entry>大文字の序数を追加</entry>
<!--
        <entry><literal>DDTH</literal>, e.g., <literal>12TH</></entry>
-->
        <entry><literal>DDTH</literal>、例えば<literal>12TH</></entry>
       </row>
       <row>
<!--
        <entry><literal>th</literal> suffix</entry>
-->
        <entry><literal>th</literal>接尾辞</entry>
<!--
        <entry>lower case ordinal number suffix</entry>
-->
        <entry>小文字の序数を追加</entry>
<!--
        <entry><literal>DDth</literal>, e.g., <literal>12th</></entry>
-->
        <entry><literal>DDth</literal>、例えば<literal>12th</></entry>
       </row>
       <row>
<!--
        <entry><literal>FX</literal> prefix</entry>
-->
        <entry><literal>FX</literal>接頭辞</entry>
<!--
        <entry>fixed format global option (see usage notes)</entry>
-->
        <entry>固定書式のグローバルオプション（使用上の注意事項を参照）</entry>
        <entry><literal>FX&nbsp;Month&nbsp;DD&nbsp;Day</literal></entry>
       </row>
       <row>
<!--
        <entry><literal>TM</literal> prefix</entry>
-->
        <entry><literal>TM</literal>接頭辞</entry>
<!--
        <entry>translation mode (print localized day and month names based on
         <xref linkend="guc-lc-time">)</entry>
-->
        <entry>翻訳モード（<xref linkend="guc-lc-time">に基づき、現地語化された日付、月名を表示します)</entry>
        <entry><literal>TMMonth</literal></entry>
       </row>
       <row>
<!--
        <entry><literal>SP</literal> suffix</entry>
-->
        <entry><literal>SP</literal>接尾辞</entry>
<!--
        <entry>spell mode (not implemented)</entry>
-->
        <entry>スペルモード（未実装）</entry>
        <entry><literal>DDSP</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
<!--
    Usage notes for date/time formatting:
-->
日付/時刻型書式の使用上の注意事項は次のとおりです。

    <itemizedlist>
     <listitem>
      <para>
<!--
       <literal>FM</literal> suppresses leading zeroes and trailing blanks
       that would otherwise be added to make the output of a pattern be
       fixed-width.  In <productname>PostgreSQL</productname>,
       <literal>FM</literal> modifies only the next specification, while in
       Oracle <literal>FM</literal> affects all subsequent
       specifications, and repeated <literal>FM</literal> modifiers
       toggle fill mode on and off.
-->
<literal>FM</literal>はパターンの出力を固定長にするため、先頭にはゼロ、末尾には空白を追加してしまう機能を無効にします。
<productname>PostgreSQL</productname>では、<literal>FM</literal>はその次に記述されたものだけを変更します。一方Oracleでは、<literal>FM</literal>はそれに続く全ての記述に対して影響し、<literal>FM</literal>修飾詞の切り替えに応じて繰り返されます。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       <literal>TM</literal> does not include trailing blanks.
-->
<literal>TM</literal>には末尾の空白は含まれません。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       <function>to_timestamp</function> and <function>to_date</function>
       skip multiple blank spaces in the input string unless the
       <literal>FX</literal> option is used. For example,
       <literal>to_timestamp('2000&nbsp;&nbsp;&nbsp;&nbsp;JUN', 'YYYY MON')</literal> works, but
       <literal>to_timestamp('2000&nbsp;&nbsp;&nbsp;&nbsp;JUN', 'FXYYYY MON')</literal> returns an error
       because <function>to_timestamp</function> expects one space only.
       <literal>FX</literal> must be specified as the first item in
       the template.
-->
<literal>FX</literal>オプションがテンプレートが使用されている場合を除き、<function>to_timestamp</function>と<function>to_date</function>は入力文字列の複数の空白スペースを無視します。
例えば、<function>to_timestamp</function>にはたった1つのスペースがあることになっているので、<literal>to_timestamp('2000&nbsp;&nbsp;&nbsp;&nbsp;JUN', 'YYYY MON')</literal>は動作しますが、<literal>to_timestamp('2000&nbsp;&nbsp;&nbsp;&nbsp;JUN','FXYYYY MON')</literal>はエラーを返します。<literal>FX</literal>はテンプレートの第1項目として指定される必要があります。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       <function>to_timestamp</function> and <function>to_date</function>
       exist to handle input formats that cannot be converted by
       simple casting.  These functions interpret input liberally,
       with minimal error checking.  While they produce valid output,
       the conversion can yield unexpected results.  For example,
       input to these functions is not restricted by normal ranges,
       thus <literal>to_date('20096040','YYYYMMDD')</literal> returns
       <literal>2014-01-17</literal> rather than causing an error.
       Casting does not have this behavior.
-->
<function>to_timestamp</function>と<function>to_date</function>は単純なキャストでは変換できない入力書式を扱うために存在します。
この関数は最低限のエラー検査で入力を自由に解釈します。
有効な出力を生成しますが、変換は思わぬ結果を生じることがあります。
例えば、この関数への入力は通常の範囲で制限されてはいませんので、<literal>to_date('20096040','YYYYMMDD')</literal>はエラーを起こすのではなく、<literal>2014-01-17</literal>を返します。
キャストにはこのような動作はありません。
      </para>
     </listitem>
  
     <listitem>
      <para>
<!--
       Ordinary text is allowed in <function>to_char</function>
       templates and will be output literally.  You can put a substring
       in double quotes to force it to be interpreted as literal text
       even if it contains pattern key words.  For example, in
       <literal>'"Hello Year "YYYY'</literal>, the <literal>YYYY</literal>
       will be replaced by the year data, but the single <literal>Y</literal> in <literal>Year</literal>
       will not be.  In <function>to_date</>, <function>to_number</>,
       and <function>to_timestamp</>, double-quoted strings skip the number of
       input characters contained in the string, e.g. <literal>"XX"</>
       skips two input characters.
-->
<function>to_char</function>テンプレートでは、通常のテキストが許され、そのまま出力されます。
部分文字列を二重引用符で括ることで、部分文字列にパターン用のキーワードがあったとしても、強制的にリテラルテキストとして解釈させることができます。
例えば、<literal>'"Hello Year "YYYY'</literal>では<literal>YYYY</literal>は年データに置換されてしまいますが、<literal>Year</literal>内の<literal>Y</literal>は置換されません。
<function>to_date</>、<function>to_number</>、<function>to_timestamp</>では、二重引用符で括られた文字の数だけ入力された文字をスキップします。例えば<literal>"XX"</>が指定された場合は2文字がスキップされます。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       If you want to have a double quote in the output you must
       precede it with a backslash, for example <literal>'\"YYYY
       Month\"'</literal>. <!&#045;- 原文コメント "" font-lock sanity :-) &#045;->
-->
出力に二重引用符を付けたい場合、<literal>'\"YYYY Month\"'</literal>のようにその前にバックスラッシュを付けなければなりません。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       If the year format specification is less than four digits, e.g.
       <literal>YYY</>, and the supplied year is less than four digits,
       the year will be adjusted to be nearest to the year 2020, e.g.
       <literal>95</> becomes 1995.
-->
もし、<literal>YYY</>の様に4桁未満の年書式が指定され、かつ与えられる年が4桁未満だった場合、年は2020年に最も近くなるよう調整されます。例えば、<literal>95</>の場合は1995年になります。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       The <literal>YYYY</literal> conversion from string to <type>timestamp</type> or
       <type>date</type> has a restriction when processing years with more than 4 digits. You must
       use some non-digit character or template after <literal>YYYY</literal>,
       otherwise the year is always interpreted as 4 digits. For example
       (with the year 20000):
       <literal>to_date('200001131', 'YYYYMMDD')</literal> will be
       interpreted as a 4-digit year; instead use a non-digit
       separator after the year, like
       <literal>to_date('20000-1131', 'YYYY-MMDD')</literal> or
       <literal>to_date('20000Nov31', 'YYYYMonDD')</literal>.
-->
文字列を<type>timestamp</type>型もしくは<type>date</type>型にする<literal>YYYY</literal>変換は、4桁以上の年数値を処理するとき制限が加えられます。
このような場合、数字以外の文字または<literal>YYYY</literal>の後にテンプレートを使わなければなりません。 そうしないと年は常に4桁と解釈されます。
例えば（20000年として）、<literal>to_date('200001131', 'YYYYMMDD')</literal>は4桁の年と解釈されるので、<literal>to_date('20000-1131', 'YYYY-MMDD')</literal>または<literal>to_date('20000Nov31', 'YYYYMonDD')</literal>のように数字でない区切り符号の使用をお勧めします。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       In conversions from string to <type>timestamp</type> or
       <type>date</type>, the <literal>CC</literal> (century) field is ignored
       if there is a <literal>YYY</literal>, <literal>YYYY</literal> or
       <literal>Y,YYY</literal> field. If <literal>CC</literal> is used with
       <literal>YY</literal> or <literal>Y</literal> then the year is computed
       as the year in the specified century.  If the century is
       specified but the year is not, the first year of the century
       is assumed.
-->
文字列から<type>timestamp</type>もしくは<type>date</type>への変換において、<literal>YYY</literal>、<literal>YYYY</literal>、もしくは<literal>Y,YYY</literal>フィールドが存在すると<literal>CC</literal>（世紀）フィールドは無視されます。
<literal>CC</literal>が<literal>YY</literal>もしくは<literal>Y</literal>と共に使用されると、指定された世紀の年と計算されます。
世紀が指定され、年が指定されないときは、その世紀の最初の年と想定されます。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       An ISO week date (as distinct from a Gregorian date) can be
       specified to <function>to_timestamp</function> and
       <function>to_date</function> in one of two ways:
-->
ISO週番号と週の曜日番号（グレゴリオ暦の日付とは異なって）は<function>to_timestamp</function>と<function>to_date</function>の２つの方法のうちのひとつで指定できます。
       <itemizedlist>
        <listitem>
         <para>
<!--
          Year, week, and weekday:  for example <literal>to_date('2006-42-4',
          'IYYY-IW-ID')</literal> returns the date
          <literal>2006-10-19</literal>.  If you omit the weekday it
          is assumed to be 1 (Monday).
-->
年、通年の週番号、週の曜日番号。
例えば、<literal>to_date('2006-42-4', 'IYYY-IW-ID')</literal>は、日付<literal>2006-10-19</literal>を返します。曜日番号を省略した場合、1（月曜日）と想定されます。
         </para>
        </listitem>
        <listitem>
         <para>
<!--
          Year and day of year:  for example <literal>to_date('2006-291',
          'IYYY-IDDD')</literal> also returns <literal>2006-10-19</literal>.
-->
年と通年の日付番号。例えば、<literal>to_date('2006-291', 'IYYY-IDDD')</literal>のは、同様<literal>2006-10-19</literal>を返します。
         </para>
        </listitem>
       </itemizedlist>
      </para>
      <para>
<!--
       Attempting to construct a date using a mixture of ISO week and
       Gregorian date fields is nonsensical, and will cause an error.  In the
       context of an ISO year, the concept of a <quote>month</> or <quote>day
       of month</> has no meaning.  In the context of a Gregorian year, the
       ISO week has no meaning.  Users should avoid mixing Gregorian and
       ISO date specifications.
-->
ISO週番号とグレゴリオ暦日のフィールドを混在して使用して日付を構築する試みは無意味なことで、エラーの原因になります。
ISO年の文脈によると、<quote>月</>、あるいは<quote>月中日付番号</>は意味を持ちません。
グレゴリオ暦の年の文脈では、ISO週番号は意味を持ちません。
グレゴリオとISOの日付の仕様の混在を避けなければなりません。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       In a conversion from string to <type>timestamp</type>, millisecond
       (<literal>MS</literal>) or microsecond (<literal>US</literal>)
       values are used as the
       seconds digits after the decimal point. For example
       <literal>to_timestamp('12:3', 'SS:MS')</literal> is not 3 milliseconds,
       but 300, because the conversion counts it as 12 + 0.3 seconds.
       This means for the format <literal>SS:MS</literal>, the input values
       <literal>12:3</literal>, <literal>12:30</literal>, and <literal>12:300</literal> specify the
       same number of milliseconds. To get three milliseconds, one must use
       <literal>12:003</literal>, which the conversion counts as
       12 + 0.003 = 12.003 seconds.
-->
文字列型から<type>timestamp</type>型への変換に際し、ミリ秒<literal>MS</literal>またはマイクロ秒<literal>US</literal>の値は小数点の位置の後の秒の桁として使用されます。
例えば、<literal>to_timestamp('12:3', 'SS:MS')</literal>は3ミリ秒ではなく300ミリ秒です。なぜなら変換においてこれは12 + 0.3と計算されるからです。
ということは、<literal>SS:MS</literal>書式に対して入力値である<literal>12:3</literal>、<literal>12:30</literal>、および<literal>12:300</literal>は同じミリ秒数を指定します。
3ミリ秒数が必要な場合には<literal>12:003</literal>のようにしなければなりません。この時、変換において12 + 0.003 = 12.003秒と計算します。
      </para>

      <para>
<!--
       Here is a more
       complex example:
       <literal>to_timestamp('15:12:02.020.001230', 'HH:MI:SS.MS.US')</literal>
       is 15 hours, 12 minutes, and 2 seconds + 20 milliseconds +
       1230 microseconds = 2.021230 seconds.
-->
もう少し複雑な例を挙げます。
<literal>to_timestamp('15:12:02.020.001230','HH:MI:SS.MS.US')</literal>は15時間12分と2秒+20ミリ秒+1230マイクロ秒 = 2.021230秒です。 
      </para>
     </listitem>

     <listitem>
      <para>
<!--
        <function>to_char(..., 'ID')</function>'s day of the week numbering
        matches the <function>extract(isodow from ...)</function> function, but
        <function>to_char(..., 'D')</function>'s does not match
        <function>extract(dow from ...)</function>'s day numbering.
-->
<function>to_char(..., 'ID')</function>の曜日番号付けは<function>extract(isodow from ...)</function>関数に一致しますが、<function>to_char(..., 'D')</function>の曜日番号付けは<function>extract(dow from ...)</function>の曜日番号付けに一致しません。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
        <function>to_char(interval)</function> formats <literal>HH</> and
        <literal>HH12</> as shown on a 12-hour clock, i.e. zero hours
        and 36 hours output as <literal>12</>, while <literal>HH24</>
        outputs the full hour value, which can exceed 23 for intervals.
-->
<function>to_char(interval)</function>関数は、<literal>HH</>と<literal>HH12</>により、すなわち0時と36時を<literal>12</>とするような、12時間表示の出力をします。一方<literal>HH24</>はインターバル間で23を超えることが可能な24時間表示の出力をします。
      </para>
     </listitem>

    </itemizedlist>
   </para>

  <para>
<!--
   <xref linkend="functions-formatting-numeric-table"> shows the
   template patterns available for formatting numeric values.
-->
<xref linkend="functions-formatting-numeric-table">に、数値型の値の書式設定に使用可能なテンプレートパターンを示します。
  </para>

    <table id="functions-formatting-numeric-table">
<!--
     <title>Template Patterns for Numeric Formatting</title>
-->
     <title>数値書式用のテンプレートパターン</title>
     <tgroup cols="2">
      <thead>
       <row>
<!--
        <entry>Pattern</entry>
        <entry>Description</entry>
-->
        <entry>パターン</entry>
        <entry>説明</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><literal>9</literal></entry>
<!--
        <entry>value with the specified number of digits</entry>
-->
        <entry>指定された桁数での値</entry>
       </row>
       <row>
        <entry><literal>0</literal></entry>
<!--
        <entry>value with leading zeros</entry>
-->
        <entry>前にゼロが付いた値</entry>
       </row>
       <row>
<!--
        <entry><literal>.</literal> (period)</entry>
        <entry>decimal point</entry>
-->
        <entry><literal>.</literal>（ピリオド）</entry>
        <entry>小数点</entry>
       </row>
       <row>
<!--
        <entry><literal>,</literal> (comma)</entry>
        <entry>group (thousand) separator</entry>
-->
        <entry><literal>,</literal> (コンマ)</entry>
        <entry>千単位で区切る符号</entry>
       </row>
       <row>
        <entry><literal>PR</literal></entry>
<!--
        <entry>negative value in angle brackets</entry>
-->
        <entry>負の値の角括弧表示</entry>
       </row>
       <row>
        <entry><literal>S</literal></entry>
<!--
        <entry>sign anchored to number (uses locale)</entry>
-->
        <entry>（ロケール使用の）符号付き値</entry>
       </row>
       <row>
        <entry><literal>L</literal></entry>
<!--
        <entry>currency symbol (uses locale)</entry>
-->
        <entry>（ロケール使用の）通貨記号</entry>
       </row>
       <row>
        <entry><literal>D</literal></entry>
<!--
        <entry>decimal point (uses locale)</entry>
-->
        <entry>（ロケール使用の）小数点</entry>
       </row>
       <row>
        <entry><literal>G</literal></entry>
<!--
        <entry>group separator (uses locale)</entry>
-->
        <entry>（ロケール使用の）グループ区切り文字</entry>
       </row>
       <row>
        <entry><literal>MI</literal></entry>
<!--
        <entry>minus sign in specified position (if number &lt; 0)</entry>
-->
        <entry>（数値 &lt; 0であれば）指定位置にマイナス記号</entry>
       </row>
       <row>
        <entry><literal>PL</literal></entry>
<!--
        <entry>plus sign in specified position (if number &gt; 0)</entry>
-->
        <entry>（数値 &gt; 0であれば）指定位置にプラス記号</entry>
       </row>
       <row>
        <entry><literal>SG</literal></entry>
<!--
        <entry>plus/minus sign in specified position</entry>
-->
        <entry>指定された位置にプラス/マイナス記号</entry>
       </row>
       <row>
        <entry><literal>RN</literal></entry>
<!--
        <entry>Roman numeral (input between 1 and 3999)</entry>
-->
        <entry>（1〜3999の入力値による）ローマ数字</entry>
       </row>
       <row>
<!--
        <entry><literal>TH</literal> or <literal>th</literal></entry>
        <entry>ordinal number suffix</entry>
-->
        <entry><literal>TH</literal>または<literal>th</literal></entry>
        <entry>序数接尾辞</entry>
       </row>
       <row>
        <entry><literal>V</literal></entry>
<!--
        <entry>shift specified number of digits (see notes)</entry>
-->
        <entry><replaceable>n</replaceable> 桁シフト（注意事項を参照）</entry>
       </row>
       <row>
        <entry><literal>EEEE</literal></entry>
<!--
        <entry>exponent for scientific notation</entry>
-->
        <entry>科学技術表記法用の指数</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
<!--
    Usage notes for numeric formatting:
-->
数値型書式の使用上の注意事項は次のとおりです。

    <itemizedlist>
     <listitem>
      <para>
<!--
       A sign formatted using <literal>SG</literal>, <literal>PL</literal>, or
       <literal>MI</literal> is not anchored to
       the number; for example,
       <literal>to_char(-12, 'MI9999')</literal> produces <literal>'-&nbsp;&nbsp;12'</literal>
       but <literal>to_char(-12, 'S9999')</literal> produces <literal>'&nbsp;&nbsp;-12'</literal>.
       The Oracle implementation does not allow the use of
       <literal>MI</literal> before <literal>9</literal>, but rather
       requires that <literal>9</literal> precede
       <literal>MI</literal>.
-->
<literal>SG</literal>、<literal>PL</literal>、または<literal>MI</literal>で整形された符号は、数値と関連付けられません。
例えば、<literal>to_char(-12, 'MI9999')</literal>は<literal>'&nbsp;&nbsp;-12'</literal>となる一方、<literal>to_char(-12, 'S9999')</literal>は<literal>'&nbsp;&nbsp;-12'</literal>となります。
Oracleの実装では<literal>9</literal>の前の<literal>MI</literal>が置かれてはならず、<literal>9</literal>の後に<literal>MI</literal>が置かれることを要求しています。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       <literal>9</literal> results in a value with the same number of
       digits as there are <literal>9</literal>s. If a digit is
       not available it outputs a space.
-->
<literal>9</literal>は<literal>9</literal>が並んでいる数と同じ桁数の値を出力します。
桁が使用可能でない場合、スペースを出力します。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       <literal>TH</literal> does not convert values less than zero
       and does not convert fractional numbers.
-->
<literal>TH</literal>はゼロ未満の値と小数は変換しません
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       <literal>PL</literal>, <literal>SG</literal>, and
       <literal>TH</literal> are <productname>PostgreSQL</productname>
       extensions.
-->
<literal>PL</literal>、<literal>SG</literal>、および<literal>TH</literal>は<productname>PostgreSQL</productname>の拡張です。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       <literal>V</literal> effectively
       multiplies the input values by
       <literal>10^<replaceable>n</replaceable></literal>, where
       <replaceable>n</replaceable> is the number of digits following
       <literal>V</literal>.
       <function>to_char</function> does not support the use of
       <literal>V</literal> combined with a decimal point
       (e.g., <literal>99.9V99</literal> is not allowed).
-->
<literal>V</literal>は入力値を実質的に<literal>10^<replaceable>n</replaceable></literal>乗します。
ここで<replaceable>n</replaceable>は<literal>V</literal>に続く桁数です。
<function>to_char</function>関数は小数点と<literal>V</literal>との混在をサポートしません（例えば、<literal>99.9V99</literal> は許可されません）。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       <literal>EEEE</literal> (scientific notation) cannot be used in
       combination with any of the other formatting patterns or
       modifiers other than digit and decimal point patterns, and must be at the end of the format string
       (e.g., <literal>9.99EEEE</literal> is a valid pattern).
-->
<literal>EEEE</literal>(科学技術表記)は、他の書式パターンや桁と小数点のパターンを除く修飾子との組み合わせで使うことはできず、また必ず書式文字列の最後に位置しなければなりません(例えば、<literal>9.99EEEE</literal>は正しい表記となります)。
      </para>
     </listitem>
    </itemizedlist>
   </para>

   <para>
<!--
    Certain modifiers can be applied to any template pattern to alter its
    behavior.  For example, <literal>FM9999</literal>
    is the <literal>9999</literal> pattern with the
    <literal>FM</literal> modifier.
    <xref linkend="functions-formatting-numericmod-table"> shows the
    modifier patterns for numeric formatting.
-->
ある修飾子をその動作を変えるために、任意のテンプレートに適用することができます。
例えば、<literal>FM9999</literal>は<literal>FM</literal>修飾子が付いた<literal>9999</literal>パターンです。
<xref linkend="functions-formatting-numericmod-table">に、数値の書式用の修飾子パターンを示します。
   </para>

    <table id="functions-formatting-numericmod-table">
<!--
     <title>Template Pattern Modifiers for Numeric Formatting</title>
-->
     <title>数値の書式用テンプレートパターン修飾子</title>
     <tgroup cols="3">
      <thead>
       <row>
<!--
        <entry>Modifier</entry>
        <entry>Description</entry>
        <entry>Example</entry>
-->
        <entry>修飾子</entry>
        <entry>説明</entry>
        <entry>例</entry>
       </row>
      </thead>
      <tbody>
       <row>
<!--
        <entry><literal>FM</literal> prefix</entry>
-->
        <entry><literal>FM</literal>添え字</entry>
<!--
        <entry>fill mode (suppress padding blanks and trailing zeroes)</entry>
-->
        <entry>字詰めモード（空白パディングの無効、および0の除去）</entry>
        <entry><literal>FM9999</literal></entry>
       </row>
       <row>
<!--
        <entry><literal>TH</literal> suffix</entry>
-->
        <entry><literal>TH</literal>添え字</entry>
<!--
        <entry>upper case ordinal number suffix</entry>
-->
        <entry>大文字による序数添え字</entry>
        <entry><literal>999TH</literal></entry>
       </row>
       <row>
<!--
        <entry><literal>th</literal> suffix</entry>
-->
        <entry><literal>th</literal>添え字</entry>
<!--
        <entry>lower case ordinal number suffix</entry>
-->
        <entry>子文字による序数添え字</entry>
        <entry><literal>999th</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

  <para>
<!--
   <xref linkend="functions-formatting-examples-table"> shows some
   examples of the use of the <function>to_char</function> function.
-->
<xref linkend="functions-formatting-examples-table">に、<function>to_char</function>関数を使用した例をいくつか示します。
  </para>

    <table id="functions-formatting-examples-table">
<!--
     <title><function>to_char</function> Examples</title>
-->
     <title><function>to_char</function>の例</title>
     <tgroup cols="2">
      <thead>
       <row>
<!--
        <entry>Expression</entry>
        <entry>Result</entry>
-->
        <entry>式</entry>
        <entry>結果</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><literal>to_char(current_timestamp, 'Day,&nbsp;DD&nbsp;&nbsp;HH12:MI:SS')</literal></entry>
        <entry><literal>'Tuesday&nbsp;&nbsp;,&nbsp;06&nbsp;&nbsp;05:39:18'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(current_timestamp, 'FMDay,&nbsp;FMDD&nbsp;&nbsp;HH12:MI:SS')</literal></entry>
        <entry><literal>'Tuesday,&nbsp;6&nbsp;&nbsp;05:39:18'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(-0.1, '99.99')</literal></entry>
        <entry><literal>'&nbsp;&nbsp;-.10'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(-0.1, 'FM9.99')</literal></entry>
        <entry><literal>'-.1'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(0.1, '0.9')</literal></entry>
        <entry><literal>'&nbsp;0.1'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(12, '9990999.9')</literal></entry>
        <entry><literal>'&nbsp;&nbsp;&nbsp;&nbsp;0012.0'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(12, 'FM9990999.9')</literal></entry>
        <entry><literal>'0012.'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485, '999')</literal></entry>
        <entry><literal>'&nbsp;485'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(-485, '999')</literal></entry>
        <entry><literal>'-485'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485, '9&nbsp;9&nbsp;9')</literal></entry>
        <entry><literal>'&nbsp;4&nbsp;8&nbsp;5'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(1485, '9,999')</literal></entry>
        <entry><literal>'&nbsp;1,485'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(1485, '9G999')</literal></entry>
        <entry><literal>'&nbsp;1&nbsp;485'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(148.5, '999.999')</literal></entry>
        <entry><literal>'&nbsp;148.500'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(148.5, 'FM999.999')</literal></entry>
        <entry><literal>'148.5'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(148.5, 'FM999.990')</literal></entry>
        <entry><literal>'148.500'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(148.5, '999D999')</literal></entry>
        <entry><literal>'&nbsp;148,500'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(3148.5, '9G999D999')</literal></entry>
        <entry><literal>'&nbsp;3&nbsp;148,500'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(-485, '999S')</literal></entry>
        <entry><literal>'485-'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(-485, '999MI')</literal></entry>
        <entry><literal>'485-'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485, '999MI')</literal></entry>
        <entry><literal>'485&nbsp;'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485, 'FM999MI')</literal></entry>
        <entry><literal>'485'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485, 'PL999')</literal></entry>
        <entry><literal>'+485'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485, 'SG999')</literal></entry>
        <entry><literal>'+485'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(-485, 'SG999')</literal></entry>
        <entry><literal>'-485'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(-485, '9SG99')</literal></entry>
        <entry><literal>'4-85'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(-485, '999PR')</literal></entry>
        <entry><literal>'&lt;485&gt;'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485, 'L999')</literal></entry>
        <entry><literal>'DM&nbsp;485</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485, 'RN')</literal></entry>
        <entry><literal>'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CDLXXXV'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485, 'FMRN')</literal></entry>
        <entry><literal>'CDLXXXV'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(5.2, 'FMRN')</literal></entry>
        <entry><literal>'V'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(482, '999th')</literal></entry>
        <entry><literal>'&nbsp;482nd'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485, '"Good&nbsp;number:"999')</literal></entry>
        <entry><literal>'Good&nbsp;number:&nbsp;485'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485.8, '"Pre:"999"&nbsp;Post:"&nbsp;.999')</literal></entry>
        <entry><literal>'Pre:&nbsp;485&nbsp;Post:&nbsp;.800'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(12, '99V999')</literal></entry>
        <entry><literal>'&nbsp;12000'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(12.4, '99V999')</literal></entry>
        <entry><literal>'&nbsp;12400'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(12.45, '99V9')</literal></entry>
        <entry><literal>'&nbsp;125'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(0.0004859, '9.99EEEE')</literal></entry>
        <entry><literal>' 4.86e-04'</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

  </sect1>


  <sect1 id="functions-datetime">
<!--
   <title>Date/Time Functions and Operators</title>
-->
   <title>日付/時刻関数と演算子</title>

  <para>
<!--
   <xref linkend="functions-datetime-table"> shows the available
   functions for date/time value processing, with details appearing in
   the following subsections.  <xref
   linkend="operators-datetime-table"> illustrates the behaviors of
   the basic arithmetic operators (<literal>+</literal>,
   <literal>*</literal>, etc.).  For formatting functions, refer to
   <xref linkend="functions-formatting">.  You should be familiar with
   the background information on date/time data types from <xref
   linkend="datatype-datetime">.
-->
<xref linkend="functions-datetime-table">は、日付/時刻型の値の処理で使用可能な関数を示しています。詳細は、以下の副節で説明します。
<xref linkend="operators-datetime-table">は、（<literal>+</literal>、<literal>*</literal>等の）基本的な算術演算子の振舞いを説明しています。
書式設定関数については<xref linkend="functions-formatting">を参照してください。
<xref linkend="datatype-datetime">を参照して、日付/時刻データ型についての背景となっている情報に精通していなければなりません。
  </para>

  <para>
<!--
   All the functions and operators described below that take <type>time</type> or <type>timestamp</type>
   inputs actually come in two variants: one that takes <type>time with time zone</type> or <type>timestamp
   with time zone</type>, and one that takes <type>time without time zone</type> or <type>timestamp without time zone</type>.
   For brevity, these variants are not shown separately.  Also, the
   <literal>+</> and <literal>*</> operators come in commutative pairs (for
   example both date + integer and integer + date); we show only one of each
   such pair.
-->
後述の<type>time</type>もしくは<type>timestamp</type>型の入力を受け取る関数および演算子は全て、実際には2つの種類があります。1つは<type>time with time zone</type>型または<type>timestamp with time zone</type>型を取るもので、もう1つは<type>time without time zone</type>型もしくは<type>timestamp without time zone</type>型を取るものです。
省略のため、これらの種類の違いは個別に示していません。
また、<literal>+</>と<literal>*</>演算子は交代演算子を持ちます（例えばdate + integerとinteger + date）。こうした組み合わせは片方のみ示します。
  </para>

    <table id="operators-datetime-table">
<!--
     <title>Date/Time Operators</title>
-->
     <title>日付/時刻演算子</title>

     <tgroup cols="3">
      <thead>
       <row>
<!--
        <entry>Operator</entry>
        <entry>Example</entry>
        <entry>Result</entry>
-->
        <entry>演算子名</entry>
        <entry>例</entry>
        <entry>結果</entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry> <literal>+</literal> </entry>
        <entry><literal>date '2001-09-28' + integer '7'</literal></entry>
        <entry><literal>date '2001-10-05'</literal></entry>
       </row>

       <row>
        <entry> <literal>+</literal> </entry>
        <entry><literal>date '2001-09-28' + interval '1 hour'</literal></entry>
        <entry><literal>timestamp '2001-09-28 01:00:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>+</literal> </entry>
        <entry><literal>date '2001-09-28' + time '03:00'</literal></entry>
        <entry><literal>timestamp '2001-09-28 03:00:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>+</literal> </entry>
        <entry><literal>interval '1 day' + interval '1 hour'</literal></entry>
        <entry><literal>interval '1 day 01:00:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>+</literal> </entry>
        <entry><literal>timestamp '2001-09-28 01:00' + interval '23 hours'</literal></entry>
        <entry><literal>timestamp '2001-09-29 00:00:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>+</literal> </entry>
        <entry><literal>time '01:00' + interval '3 hours'</literal></entry>
        <entry><literal>time '04:00:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>-</literal> </entry>
        <entry><literal>- interval '23 hours'</literal></entry>
        <entry><literal>interval '-23:00:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>-</literal> </entry>
        <entry><literal>date '2001-10-01' - date '2001-09-28'</literal></entry>
<!--
        <entry><literal>integer '3'</literal> (days)</entry>
-->
        <entry><literal>integer '3'</literal>（日付）</entry>
       </row>

       <row>
        <entry> <literal>-</literal> </entry>
        <entry><literal>date '2001-10-01' - integer '7'</literal></entry>
        <entry><literal>date '2001-09-24'</literal></entry>
       </row>

       <row>
        <entry> <literal>-</literal> </entry>
        <entry><literal>date '2001-09-28' - interval '1 hour'</literal></entry>
        <entry><literal>timestamp '2001-09-27 23:00:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>-</literal> </entry>
        <entry><literal>time '05:00' - time '03:00'</literal></entry>
        <entry><literal>interval '02:00:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>-</literal> </entry>
        <entry><literal>time '05:00' - interval '2 hours'</literal></entry>
        <entry><literal>time '03:00:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>-</literal> </entry>
        <entry><literal>timestamp '2001-09-28 23:00' - interval '23 hours'</literal></entry>
        <entry><literal>timestamp '2001-09-28 00:00:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>-</literal> </entry>
        <entry><literal>interval '1 day' - interval '1 hour'</literal></entry>
        <entry><literal>interval '1 day -01:00:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>-</literal> </entry>
        <entry><literal>timestamp '2001-09-29 03:00' - timestamp '2001-09-27 12:00'</literal></entry>
        <entry><literal>interval '1 day 15:00:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>*</literal> </entry>
        <entry><literal>900 * interval '1 second'</literal></entry>
        <entry><literal>interval '00:15:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>*</literal> </entry>
        <entry><literal>21 * interval '1 day'</literal></entry>
        <entry><literal>interval '21 days'</literal></entry>
       </row>

       <row>
        <entry> <literal>*</literal> </entry>
        <entry><literal>double precision '3.5' * interval '1 hour'</literal></entry>
        <entry><literal>interval '03:30:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>/</literal> </entry>
        <entry><literal>interval '1 hour' / double precision '1.5'</literal></entry>
        <entry><literal>interval '00:40:00'</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

    <table id="functions-datetime-table">
<!--
     <title>Date/Time Functions</title>
-->
     <title>日付/時刻関数</title>
     <tgroup cols="5">
      <thead>
       <row>
<!--
        <entry>Function</entry>
        <entry>Return Type</entry>
        <entry>Description</entry>
        <entry>Example</entry>
        <entry>Result</entry>
-->
        <entry>関数名</entry>
        <entry>戻り値型</entry>
        <entry>説明</entry>
        <entry>例</entry>
        <entry>結果</entry>
    
       </row>
      </thead>

      <tbody>
       <row>
        <entry>
         <indexterm>
          <primary>age</primary>
         </indexterm>
         <literal><function>age(<type>timestamp</type>, <type>timestamp</type>)</function></literal>
        </entry>
        <entry><type>interval</type></entry>
<!--
        <entry>Subtract arguments, producing a <quote>symbolic</> result that
        uses years and months, rather than just days</entry>
-->
        <entry>引数間の減算。日だけでなく年と月を使用した<quote>シンボルによる</>結果を生成</entry>
        <entry><literal>age(timestamp '2001-04-10', timestamp '1957-06-13')</literal></entry>
        <entry><literal>43 years 9 mons 27 days</literal></entry>
       </row>

       <row>
        <entry><literal><function>age(<type>timestamp</type>)</function></literal></entry>
        <entry><type>interval</type></entry>
<!--
        <entry>Subtract from <function>current_date</function> (at midnight)</entry>
-->
        <entry><function>current_date</function>（午前零時）から減算</entry>
        <entry><literal>age(timestamp '1957-06-13')</literal></entry>
        <entry><literal>43 years 8 mons 3 days</literal></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>clock_timestamp</primary>
         </indexterm>
         <literal><function>clock_timestamp()</function></literal>
        </entry>
        <entry><type>timestamp with time zone</type></entry>
<!--
        <entry>Current date and time (changes during statement execution);
         see <xref linkend="functions-datetime-current">
-->
        <entry>現在の日付と時刻です。（文実行時に変わります。）<xref linkend="functions-datetime-current">を参照。
        </entry>
        <entry></entry>
        <entry></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>current_date</primary>
         </indexterm>
         <literal><function>current_date</function></literal>
        </entry>
        <entry><type>date</type></entry>
<!--
        <entry>Current date;
         see <xref linkend="functions-datetime-current">
-->
        <entry>現在の日付。<xref linkend="functions-datetime-current">を参照
        </entry>
        <entry></entry>
        <entry></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>current_time</primary>
         </indexterm>
         <literal><function>current_time</function></literal>
        </entry>
        <entry><type>time with time zone</type></entry>
<!--
        <entry>Current time of day;
         see <xref linkend="functions-datetime-current">
-->
        <entry>現在の時刻。<xref linkend="functions-datetime-current">を参照。
        </entry>
        <entry></entry>
        <entry></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>current_timestamp</primary>
         </indexterm>
         <literal><function>current_timestamp</function></literal>
        </entry>
        <entry><type>timestamp with time zone</type></entry>
<!--
        <entry>Current date and time (start of current transaction);
         see <xref linkend="functions-datetime-current">
-->
        <entry>現在の日付と時刻（現在のトランザクションの開始日付時刻）。<xref linkend="functions-datetime-current">を参照。
        </entry>
        <entry></entry>
        <entry></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>date_part</primary>
         </indexterm>
         <literal><function>date_part(<type>text</type>, <type>timestamp</type>)</function></literal>
        </entry>
        <entry><type>double precision</type></entry>
<!--
        <entry>Get subfield (equivalent to <function>extract</function>);
         see <xref linkend="functions-datetime-extract">
-->
        <entry>部分フィールドの取得（<function>extract</function>と同じ）。<xref linkend="functions-datetime-extract">を参照。
        </entry>
        <entry><literal>date_part('hour', timestamp '2001-02-16 20:38:40')</literal></entry>
        <entry><literal>20</literal></entry>
       </row>

       <row>
        <entry><literal><function>date_part(<type>text</type>, <type>interval</type>)</function></literal></entry>
        <entry><type>double precision</type></entry>
<!--
        <entry>Get subfield (equivalent to
         <function>extract</function>); see <xref linkend="functions-datetime-extract">
-->
        <entry>部分フィールドの取得（<function>extract</function>と同じ）。<xref linkend="functions-datetime-extract">を参照。
        </entry>
        <entry><literal>date_part('month', interval '2 years 3 months')</literal></entry>
        <entry><literal>3</literal></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>date_trunc</primary>
         </indexterm>
         <literal><function>date_trunc(<type>text</type>, <type>timestamp</type>)</function></literal>
        </entry>
        <entry><type>timestamp</type></entry>
<!--
        <entry>Truncate to specified precision; see also <xref linkend="functions-datetime-trunc">
-->
        <entry>指定された精度で切り捨て。<xref linkend="functions-datetime-trunc">も参照。
        </entry>
        <entry><literal>date_trunc('hour', timestamp '2001-02-16 20:38:40')</literal></entry>
        <entry><literal>2001-02-16 20:00:00</literal></entry>
       </row>

       <row>
        <entry><literal><function>date_trunc(<type>text</type>, <type>interval</type>)</function></literal></entry>
        <entry><type>interval</type></entry>
<!--
        <entry>Truncate to specified precision; see also <xref linkend="functions-datetime-trunc">
-->
        <entry>指定された精度で切り捨て。<xref linkend="functions-datetime-trunc">も参照。
        </entry>
        <entry><literal>date_trunc('hour', interval '2 days 3 hours 40 minutes')</literal></entry>
        <entry><literal>2 days 03:00:00</literal></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>extract</primary>
         </indexterm>
         <literal><function>extract</function>(<parameter>field</parameter> from
         <type>timestamp</type>)</literal>
        </entry>
        <entry><type>double precision</type></entry>
<!--
        <entry>Get subfield; see <xref linkend="functions-datetime-extract">
-->
        <entry>部分フィールドの取得。<xref linkend="functions-datetime-extract">を参照。
        </entry>
        <entry><literal>extract(hour from timestamp '2001-02-16 20:38:40')</literal></entry>
        <entry><literal>20</literal></entry>
       </row>

       <row>
        <entry><literal><function>extract</function>(<parameter>field</parameter> from
         <type>interval</type>)</literal></entry>
        <entry><type>double precision</type></entry>
<!--
        <entry>Get subfield; see <xref linkend="functions-datetime-extract">
-->
        <entry>部分フィールドの取得。<xref linkend="functions-datetime-extract">を参照。
        </entry>
        <entry><literal>extract(month from interval '2 years 3 months')</literal></entry>
        <entry><literal>3</literal></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>isfinite</primary>
         </indexterm>
         <literal><function>isfinite(<type>date</type>)</function></literal>
        </entry>
        <entry><type>boolean</type></entry>
<!--
        <entry>Test for finite date (not +/-infinity)</entry>
-->
        <entry>日付が有限（+/-無限と等しくない）かどうかの検査</entry>
        <entry><literal>isfinite(date '2001-02-16')</literal></entry>
        <entry><literal>true</literal></entry>
       </row>

       <row>
        <entry><literal><function>isfinite(<type>timestamp</type>)</function></literal></entry>
        <entry><type>boolean</type></entry>
<!--
        <entry>Test for finite time stamp (not +/-infinity)</entry>
-->
        <entry>タイムスタンプが有限（+/-無限でない）かどうかの検査</entry>
        <entry><literal>isfinite(timestamp '2001-02-16 21:28:30')</literal></entry>
        <entry><literal>true</literal></entry>
       </row>

       <row>
        <entry><literal><function>isfinite(<type>interval</type>)</function></literal></entry>
        <entry><type>boolean</type></entry>
<!--
        <entry>Test for finite interval</entry>
-->
        <entry>時間間隔が有限かどうかの検査</entry>
        <entry><literal>isfinite(interval '4 hours')</literal></entry>
        <entry><literal>true</literal></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>justify_days</primary>
         </indexterm>
         <literal><function>justify_days(<type>interval</type>)</function></literal>
        </entry>
        <entry><type>interval</type></entry>
<!--
        <entry>Adjust interval so 30-day time periods are represented as months</entry>
-->
        <entry>30日周期が1月を表すように時間間隔を調整</entry>
        <entry><literal>justify_days(interval '35 days')</literal></entry>
        <entry><literal>1 mon 5 days</literal></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>justify_hours</primary>
         </indexterm>
         <literal><function>justify_hours(<type>interval</type>)</function></literal>
        </entry>
        <entry><type>interval</type></entry>
<!--
        <entry>Adjust interval so 24-hour time periods are represented as days</entry>
-->
        <entry>24時間を1日とする時間間隔の調整</entry>
        <entry><literal>justify_hours(interval '27 hours')</literal></entry>
        <entry><literal>1 day 03:00:00</literal></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>justify_interval</primary>
         </indexterm>
         <literal><function>justify_interval(<type>interval</type>)</function></literal>
        </entry>
        <entry><type>interval</type></entry>
<!--
        <entry>Adjust interval using <function>justify_days</> and <function>justify_hours</>, with additional sign adjustments</entry>
-->
        <entry><function>justify_days</>および<function>justify_hours</>を使用し、さらに符号による調整を行っての時間間隔の調整</entry>
        <entry><literal>justify_interval(interval '1 mon -1 hour')</literal></entry>
        <entry><literal>29 days 23:00:00</literal></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>localtime</primary>
         </indexterm>
         <literal><function>localtime</function></literal>
        </entry>
        <entry><type>time</type></entry>
<!--
        <entry>Current time of day;
         see <xref linkend="functions-datetime-current">
-->
        <entry>現在の時刻。<xref linkend="functions-datetime-current">を参照。
        </entry>
        <entry></entry>
        <entry></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>localtimestamp</primary>
         </indexterm>
         <literal><function>localtimestamp</function></literal>
        </entry>
        <entry><type>timestamp</type></entry>
<!--
        <entry>Current date and time (start of current transaction);
         see <xref linkend="functions-datetime-current">
-->
        <entry>現在の日付と時刻（現在のトランザクションの開始）。<xref linkend="functions-datetime-current">を参照。
        </entry>
        <entry></entry>
        <entry></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>make_date</primary>
         </indexterm>
         <literal>
            <function>
             make_date(<parameter>year</parameter> <type>int</type>,
             <parameter>month</parameter> <type>int</type>,
             <parameter>day</parameter> <type>int</type>)
            </function>
         </literal>
        </entry>
        <entry><type>date</type></entry>
        <entry>
<!--
         Create date from year, month and day fields
-->
         年、月、日フィールドから日付を作成
        </entry>
        <entry><literal>make_date(2013, 7, 15)</literal></entry>
        <entry><literal>2013-07-15</literal></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>make_interval</primary>
         </indexterm>
         <literal>
          <function>
           make_interval(<parameter>years</parameter> <type>int</type> DEFAULT 0,
           <parameter>months</parameter> <type>int</type> DEFAULT 0,
           <parameter>weeks</parameter> <type>int</type> DEFAULT 0,
           <parameter>days</parameter> <type>int</type> DEFAULT 0,
           <parameter>hours</parameter> <type>int</type> DEFAULT 0,
           <parameter>mins</parameter> <type>int</type> DEFAULT 0,
           <parameter>secs</parameter> <type>double precision</type> DEFAULT 0.0)
          </function>
         </literal>
        </entry>
        <entry><type>interval</type></entry>
        <entry>
<!--
         Create interval from years, months, weeks, days, hours, minutes and
         seconds fields
-->
         年、月、週、日、時間、分、秒フィールドから時間間隔を作成
        </entry>
        <entry><literal>make_interval(days := 10)</literal></entry>
        <entry><literal>10 days</literal></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>make_time</primary>
         </indexterm>
         <literal>
          <function>
           make_time(<parameter>hour</parameter> <type>int</type>,
           <parameter>min</parameter> <type>int</type>,
           <parameter>sec</parameter> <type>double precision</type>)
          </function>
         </literal>
        </entry>
        <entry><type>time</type></entry>
        <entry>
<!--
         Create time from hour, minute and seconds fields
-->
         時、分、秒フィールドから時刻を作成
        </entry>
        <entry><literal>make_time(8, 15, 23.5)</literal></entry>
        <entry><literal>08:15:23.5</literal></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>make_timestamp</primary>
         </indexterm>
         <literal>
          <function>
           make_timestamp(<parameter>year</parameter> <type>int</type>,
           <parameter>month</parameter> <type>int</type>,
           <parameter>day</parameter> <type>int</type>,
           <parameter>hour</parameter> <type>int</type>,
           <parameter>min</parameter> <type>int</type>,
           <parameter>sec</parameter> <type>double precision</type>)
          </function>
         </literal>
        </entry>
        <entry><type>timestamp</type></entry>
        <entry>
<!--
         Create timestamp from year, month, day, hour, minute and seconds fields
-->
         年、月、日、時、分、秒フィールドから時刻を作成
        </entry>
        <entry><literal>make_timestamp(1-23, 7, 15, 8, 15, 23.5)</literal></entry>
        <entry><literal>2013-07-15 08:15:23.5</literal></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>make_timestamptz</primary>
         </indexterm>
         <literal>
          <function>
           make_timestamptz(<parameter>year</parameter> <type>int</type>,
           <parameter>month</parameter> <type>int</type>,
           <parameter>day</parameter> <type>int</type>,
           <parameter>hour</parameter> <type>int</type>,
           <parameter>min</parameter> <type>int</type>,
           <parameter>sec</parameter> <type>double precision</type>,
           <optional> <parameter>timezone</parameter> <type>text</type> </optional>)
          </function>
         </literal>
        </entry>
        <entry><type>timestamp with time zone</type></entry>
        <entry>
<!--
         Create timestamp with time zone from year, month, day, hour, minute
         and seconds fields. When <parameter>timezone</parameter> is not specified,
         then current time zone is used.
-->
         年、月、日、時、分、秒フィールドから時間帯付きの時刻を作成。<parameter>timezone</parameter>が指定されていなければ、現在の時間帯が使われる。
        </entry>
        <entry><literal>make_timestamp(1-23, 7, 15, 8, 15, 23.5)</literal></entry>
        <entry><literal>2013-07-15 08:15:23.5+01</literal></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>now</primary>
         </indexterm>
         <literal><function>now()</function></literal>
        </entry>
        <entry><type>timestamp with time zone</type></entry>
<!--
        <entry>Current date and time (start of current transaction);
         see <xref linkend="functions-datetime-current">
-->
        <entry>現在の日付と時刻（現在のトランザクションの開始）。
<xref linkend="functions-datetime-current">を参照。
        </entry>
        <entry></entry>
        <entry></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>statement_timestamp</primary>
         </indexterm>
         <literal><function>statement_timestamp()</function></literal>
        </entry>
        <entry><type>timestamp with time zone</type></entry>
<!--
        <entry>Current date and time (start of current statement);
         see <xref linkend="functions-datetime-current">
-->
        <entry>現在の日付と時刻（現在の文の開始）。
<xref linkend="functions-datetime-current">を参照。
        </entry>
        <entry></entry>
        <entry></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>timeofday</primary>
         </indexterm>
         <literal><function>timeofday()</function></literal>
        </entry>
        <entry><type>text</type></entry>
<!--
        <entry>Current date and time
         (like <function>clock_timestamp</>, but as a <type>text</> string);
         see <xref linkend="functions-datetime-current">
-->
        <entry>現在の日付と時刻。（<function>clock_timestamp</>と似ていますが、<type>text</>型文字列として返す。）<xref linkend="functions-datetime-current">を参照。
        </entry>
        <entry></entry>
        <entry></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>transaction_timestamp</primary>
         </indexterm>
         <literal><function>transaction_timestamp()</function></literal>
        </entry>
        <entry><type>timestamp with time zone</type></entry>
<!--
        <entry>Current date and time (start of current transaction);
         see <xref linkend="functions-datetime-current">
-->
        <entry>現在の日付と時刻（現在のトランザクションの開始）。
<xref linkend="functions-datetime-current">を参照。
        </entry>
        <entry></entry>
        <entry></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
    <indexterm>
      <primary>OVERLAPS</primary>
    </indexterm>
<!--
    In addition to these functions, the SQL <literal>OVERLAPS</> operator is
    supported:
-->
これらの関数に加え、<literal>OVERLAPS</> SQL演算子がサポートされています。
<synopsis>
(<replaceable>start1</replaceable>, <replaceable>end1</replaceable>) OVERLAPS (<replaceable>start2</replaceable>, <replaceable>end2</replaceable>)
(<replaceable>start1</replaceable>, <replaceable>length1</replaceable>) OVERLAPS (<replaceable>start2</replaceable>, <replaceable>length2</replaceable>)
</synopsis>
<!--
    This expression yields true when two time periods (defined by their
    endpoints) overlap, false when they do not overlap.  The endpoints
    can be specified as pairs of dates, times, or time stamps; or as
    a date, time, or time stamp followed by an interval.  When a pair
    of values is provided, either the start or the end can be written
    first; <literal>OVERLAPS</> automatically takes the earlier value
    of the pair as the start.  Each time period is considered to
    represent the half-open interval <replaceable>start</> <literal>&lt;=</>
    <replaceable>time</> <literal>&lt;</> <replaceable>end</>, unless
    <replaceable>start</> and <replaceable>end</> are equal in which case it
    represents that single time instant.  This means for instance that two
    time periods with only an endpoint in common do not overlap.
-->
この式は、2つの時間間隔が重なる（その終端で定義されます）時に真を返します。重ならない場合は偽を返します。
終端は日付、時刻、タイムスタンプ、もしくは、日付/時刻/タイムスタンプに続く時間間隔で指定されます。値の組み合わせが与えられた際、開始と終了のいずれを先に記述しても構いません。<literal>OVERLAPS</>は与えられた値の内、若いものを開始として扱います。
各時間間隔は、<replaceable>start</> <literal>&lt;=</><replaceable>time</> <literal>&lt;</> <replaceable>end</>といった半開区間として見なされます。ただし、<replaceable>start</>と<replaceable>end</>が同じ値の場合には単一の時間点となります。
これは、例えば終了点のみが同じである2つの時間間隔は、必ずしも重ならないことを意味します。
   </para>

<screen>
SELECT (DATE '2001-02-16', DATE '2001-12-21') OVERLAPS
       (DATE '2001-10-30', DATE '2002-10-30');
<lineannotation>Result: </lineannotation><computeroutput>true</computeroutput>
SELECT (DATE '2001-02-16', INTERVAL '100 days') OVERLAPS
       (DATE '2001-10-30', DATE '2002-10-30');
<lineannotation>Result: </lineannotation><computeroutput>false</computeroutput>
SELECT (DATE '2001-10-29', DATE '2001-10-30') OVERLAPS
       (DATE '2001-10-30', DATE '2001-10-31');
<lineannotation>Result: </lineannotation><computeroutput>false</computeroutput>
SELECT (DATE '2001-10-30', DATE '2001-10-30') OVERLAPS
       (DATE '2001-10-30', DATE '2001-10-31');
<lineannotation>Result: </lineannotation><computeroutput>true</computeroutput>
</screen>

  <para>
<!--
   When adding an <type>interval</type> value to (or subtracting an
   <type>interval</type> value from) a <type>timestamp with time zone</type>
   value, the days component advances or decrements the date of the
   <type>timestamp with time zone</type> by the indicated number of days.
   Across daylight saving time changes (when the session time zone is set to a
   time zone that recognizes DST), this means <literal>interval '1 day'</literal>
   does not necessarily equal <literal>interval '24 hours'</literal>.
   For example, with the session time zone set to <literal>CST7CDT</literal>,
   <literal>timestamp with time zone '2005-04-02 12:00-07' + interval '1 day'</literal>
   will produce <literal>timestamp with time zone '2005-04-03 12:00-06'</literal>,
   while adding <literal>interval '24 hours'</literal> to the same initial
   <type>timestamp with time zone</type> produces
   <literal>timestamp with time zone '2005-04-03 13:00-06'</literal>, as there is
   a change in daylight saving time at <literal>2005-04-03 02:00</literal> in time zone
   <literal>CST7CDT</literal>.
-->
<type>timestamp with time zone</type>の値に<type>interval</type>の値を加える時（または<type>timestamp with time zone</type>の値から<type>interval</type>の値を差し引く時）日にちの部分は、日にちの数で示された <type>timestamp with time zone</type>の日付を先に進める、もしくは後に戻します。
夏時間への移行に跨っての変更に関しては（セッションの時間帯がDSTを認識するようになっていれば）、<literal>interval '1 day'</literal>が<literal>interval '24 hours'</literal>に等しい必要はありません。
例えば、セッションの時間帯が <literal>CST7CDT</literal>に設定されている時に、 <literal>timestamp with time zone '2005-04-02 12:00-07' + interval '1 day' </literal>は、<literal>timestamp with time zone '2005-04-03 12:00-06'</literal>をもたらします。一方同じ初期<type>timestamp with time zone</type>に<literal>interval '24 hours'</literal>を加えると、<literal>timestamp with time zone '2005-04-03 13:00-06'</literal>という結果になります。その理由は<literal>CST7CDT</literal>時間帯で<literal>2005-04-03 02:00</literal>に夏時間への変更があるからです。
  </para>

  <para>
<!--
   Note there can be ambiguity in the <literal>months</> field returned by
   <function>age</> because different months have different numbers of
   days.  <productname>PostgreSQL</>'s approach uses the month from the
   earlier of the two dates when calculating partial months.  For example,
   <literal>age('2004-06-01', '2004-04-30')</> uses April to yield
   <literal>1 mon 1 day</>, while using May would yield <literal>1 mon 2
   days</> because May has 31 days, while April has only 30.
-->
異なる月では日数が異なりますので<function>age</>で返される<literal>months</>フィールドにはあいまいさがあります。
<productname>PostgreSQL</>のやり方は月にまたがる２つの日付の計算において、日付の早いほうの月を使用します。
例えば、<literal>age('2004-06-01', '2004-04-30')</>は4月を使用して<literal>1 mon 1 day</>を得ます。一方５月を使用すると、5月は31日あり、4月は30日のため、結果は<literal>1 mon 2 days</>です。
  </para>

  <para>
<!--
   Subtraction of dates and timestamps can also be complex.  One conceptually
   simple way to perform subtraction is to convert each value to a number
   of seconds using <literal>EXTRACT(EPOCH FROM ...)</>, then subtract the
   results; this produces the
   number of <emphasis>seconds</> between the two values.  This will adjust
   for the number of days in each month, timezone changes, and daylight
   saving time adjustments.  Subtraction of date or timestamp
   values with the <quote><literal>-</></quote> operator
   returns the number of days (24-hours) and hours/minutes/seconds
   between the values, making the same adjustments.  The <function>age</>
   function returns years, months, days, and hours/minutes/seconds,
   performing field-by-field subtraction and then adjusting for negative
   field values.  The following queries illustrate the differences in these
   approaches.  The sample results were produced with <literal>timezone
   = 'US/Eastern'</>; there is a daylight saving time change between the
   two dates used:
-->
日付とタイムスタンプの引き算は複雑になることがあります。
引き算をする概念的に単純な方法は、それぞれの値を秒数に<literal>EXTRACT(EPOCH FROM ...)</>で変換してから、結果を引き算する方法です。この結果は2つの値の間の<emphasis>秒</>数になります。
これは各月の日数、時間帯の変更、夏時間の調整に対して調整されるでしょう。
<quote><literal>-</></quote>演算子での日付やタイムスタンプの引き算は値の間の(24時間の)日数と時間/分/秒を、同様に調整して返します。
<function>age</>関数は年、月、日、時間/分/秒をフィールド毎に引き算し、負のフィールドの値を調整します。
以下の問い合わせは上の各方法の違いを説明する例です。
例の結果は<literal>timezone = 'US/Eastern'</>で生成されました。2つの日付の間には夏時間の変更があります。
  </para>

<screen>
SELECT EXTRACT(EPOCH FROM timestamptz '2013-07-01 12:00:00') -
       EXTRACT(EPOCH FROM timestamptz '2013-03-01 12:00:00');
<!--
<lineannotation>Result: </lineannotation><computeroutput>10537200</computeroutput>
-->
<lineannotation>結果: </lineannotation><computeroutput>10537200</computeroutput>
SELECT (EXTRACT(EPOCH FROM timestamptz '2013-07-01 12:00:00') -
        EXTRACT(EPOCH FROM timestamptz '2013-03-01 12:00:00'))
        / 60 / 60 / 24;
<!--
<lineannotation>Result: </lineannotation><computeroutput>121.958333333333</computeroutput>
-->
<lineannotation>結果: </lineannotation><computeroutput>121.958333333333</computeroutput>
SELECT timestamptz '2013-07-01 12:00:00' - timestamptz '2013-03-01 12:00:00';
<!--
<lineannotation>Result: </lineannotation><computeroutput>121 days 23:00:00</computeroutput>
-->
<lineannotation>結果: </lineannotation><computeroutput>121 days 23:00:00</computeroutput>
SELECT age(timestamptz '2013-07-01 12:00:00', timestamptz '2013-03-01 12:00:00');
<!--
<lineannotation>Result: </lineannotation><computeroutput>4 mons</computeroutput>
-->
<lineannotation>結果: </lineannotation><computeroutput>4 mons</computeroutput>
</screen>

  <sect2 id="functions-datetime-extract">
   <title><function>EXTRACT</function>, <function>date_part</function></title>

   <indexterm>
    <primary>date_part</primary>
   </indexterm>
   <indexterm>
    <primary>extract</primary>
   </indexterm>

<synopsis>
EXTRACT(<replaceable>field</replaceable> FROM <replaceable>source</replaceable>)
</synopsis>

   <para>
<!--
    The <function>extract</function> function retrieves subfields
    such as year or hour from date/time values.
    <replaceable>source</replaceable> must be a value expression of
    type <type>timestamp</type>, <type>time</type>, or <type>interval</type>.
    (Expressions of type <type>date</type> are
    cast to <type>timestamp</type> and can therefore be used as
    well.)  <replaceable>field</replaceable> is an identifier or
    string that selects what field to extract from the source value.
    The <function>extract</function> function returns values of type
    <type>double precision</type>.
    The following are valid field names:
-->
<function>extract</function>関数は、日付/時刻の値から年や時などの部分フィールドを抽出します。
<replaceable>source</replaceable>は<type>timestamp</type>型、<type>time</type>型、または<type>interval</type>型の評価式でなければなりません（<type>date</type>型の式は<type>timestamp</type>型にキャストされますので、同様に使用可能です）。
<replaceable>field</replaceable>はsourceの値からどのフィールドを抽出するかを選択する識別子もしくは文字列です。
<function>extract</function>関数は<type>double precision</type>型の値を返します。以下に有効なフィールド名を示します。

    <!-- alphabetical -->
    <variablelist>
     <varlistentry>
      <term><literal>century</literal></term>
      <listitem>
       <para>
<!--
        The century
-->
世紀
       </para>

<screen>
SELECT EXTRACT(CENTURY FROM TIMESTAMP '2000-12-16 12:21:13');
<lineannotation>Result: </lineannotation><computeroutput>20</computeroutput>
SELECT EXTRACT(CENTURY FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>21</computeroutput>
</screen>

       <para>
<!--
        The first century starts at 0001-01-01 00:00:00 AD, although
        they did not know it at the time. This definition applies to all
        Gregorian calendar countries. There is no century number 0,
        you go from -1 century to 1 century.

        If you disagree with this, please write your complaint to:
        Pope, Cathedral Saint-Peter of Roma, Vatican.
-->
当時の人々にはそのような意識はありませんでしたが、最初の世紀は0001-01-01 00:00:00 ADから始まります。
この定義は全てのグレゴリオ暦を使用する国で適用されています。
0という値の世紀はありません。-1世紀の次は1世紀です。

この定義に納得できなければ、苦情をバチカンローマ聖パウロ大聖堂のローマ法王に伝えてください。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>day</literal></term>
      <listitem>
       <para>
<!--
        For <type>timestamp</type> values, the day (of the month) field
        (1 - 31) ; for <type>interval</type> values, the number of days
-->
<type>timestamp</type>値については、(月内の）日付フィールド（1〜31)。<type>interval</type>値については日付。
       </para>

<screen>
SELECT EXTRACT(DAY FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>16</computeroutput>

SELECT EXTRACT(DAY FROM INTERVAL '40 days 1 minute');
<lineannotation>Result: </lineannotation><computeroutput>40</computeroutput>
</screen>



      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>decade</literal></term>
      <listitem>
       <para>
<!--
        The year field divided by 10
-->
年フィールドを10で割ったもの
       </para>

<screen>
SELECT EXTRACT(DECADE FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>200</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>dow</literal></term>
      <listitem>
       <para>
<!--
        The day of the week as Sunday(<literal>0</>) to
        Saturday(<literal>6</>)
-->
日曜日（<literal>0</>）から土曜日（<literal>6</>）までの曜日
       </para>

<screen>
SELECT EXTRACT(DOW FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>5</computeroutput>
</screen>
       <para>
<!--
        Note that <function>extract</function>'s day of the week numbering
        differs from that of the <function>to_char(...,
        'D')</function> function.
-->
<function>extract</function>関数の曜日指定番号は<function>to_char(...,'D')</function>関数のそれとは異なる点に注意してください。
       </para>

      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>doy</literal></term>
      <listitem>
       <para>
<!--
        The day of the year (1 - 365/366)
-->
年内での通算日数（1〜365/366）
       </para>

<screen>
SELECT EXTRACT(DOY FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>47</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>epoch</literal></term>
      <listitem>
       <para>
<!--
        For <type>timestamp with time zone</type> values, the
        number of seconds since 1970-01-01 00:00:00 UTC (can be negative);
        for <type>date</type> and <type>timestamp</type> values, the
        number of seconds since 1970-01-01 00:00:00 local time;
        for <type>interval</type> values, the total number
        of seconds in the interval
-->
<type>timestamp with time zone</type>型の値において、1970-01-01 00:00:00 UTCからの秒数（負の数の場合もあり）。<type>date</type>と<type>timestamp</type>型の値において、ローカルタイムの1970-01-01 00:00:00からの秒数。<type>interval</type>型の値ではその時間間隔における秒の合計。
       </para>

<screen>
SELECT EXTRACT(EPOCH FROM TIMESTAMP WITH TIME ZONE '2001-02-16 20:38:40.12-08');
<lineannotation>Result: </lineannotation><computeroutput>982384720.12</computeroutput>

SELECT EXTRACT(EPOCH FROM INTERVAL '5 days 3 hours');
<lineannotation>Result: </lineannotation><computeroutput>442800</computeroutput>
</screen>

       <para>
<!--
        Here is how you can convert an epoch value back to a time
        stamp:
-->
以下に、この経過秒数をタイムスタンプ値に変換する方法を示します。
       </para>
<screen>
SELECT TIMESTAMP WITH TIME ZONE 'epoch' + 982384720.12 * INTERVAL '1 second';
</screen>
       <para>
<!--
        (The <function>to_timestamp</> function encapsulates the above
        conversion.)
-->
(<function>to_timestamp</>関数は上記の変換をカプセル化します。)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>hour</literal></term>
      <listitem>
       <para>
<!--
        The hour field (0 - 23)
-->
時のフィールド（0〜23）
       </para>

<screen>
SELECT EXTRACT(HOUR FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>20</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>isodow</literal></term>
      <listitem>
       <para>
<!--
        The day of the week as Monday(<literal>1</>) to
        Sunday(<literal>7</>)
-->
月曜日（<literal>1</>）から日曜日（<literal>7</>）までの曜日
       </para>

<screen>
SELECT EXTRACT(ISODOW FROM TIMESTAMP '2001-02-18 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>7</computeroutput>
</screen>
       <para>
<!--
        This is identical to <literal>dow</> except for Sunday.  This
        matches the <acronym>ISO</> 8601 day of the week numbering.
-->
日曜日を除き<literal>dow</>と同一。<acronym>ISO</> 8601曜日番号付けに一致。
       </para>

      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>isoyear</literal></term>
      <listitem>
       <para>
<!--
        The <acronym>ISO</acronym> 8601 year that the date falls in (not applicable to intervals)
-->
日付が同期する<acronym>ISO</acronym> 8601年（intervalには対応しない）。
       </para>

<screen>
SELECT EXTRACT(ISOYEAR FROM DATE '2006-01-01');
<lineannotation>Result: </lineannotation><computeroutput>2005</computeroutput>
SELECT EXTRACT(ISOYEAR FROM DATE '2006-01-02');
<lineannotation>Result: </lineannotation><computeroutput>2006</computeroutput>
</screen>

       <para>
<!--
        Each <acronym>ISO</acronym> year begins with the Monday of the week containing the 4th of January, so in early January or late December the <acronym>ISO</acronym> year may be different from the Gregorian year.  See the <literal>week</literal> field for more information.
-->
全ての<acronym>ISO</acronym>年は１月４日を含む週の月曜日から開始されます。従って、１月上旬、または１２月下旬で<acronym>ISO</acronym>年がグレゴリオ年と異なる可能性があります。
より詳細は<literal>week</literal>フィールドを参照してください。
       </para>
       <para>
<!--
        This field is not available in PostgreSQL releases prior to 8.3.
-->
このフィールドは8.3以前のPostgreSQLリリースでは有効でありません。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>microseconds</literal></term>
      <listitem>
       <para>
<!--
        The seconds field, including fractional parts, multiplied by 1
        000 000;  note that this includes full seconds
-->
端数部分も含み、1,000,000を乗じられた秒フィールド。全ての秒を含むことに注意。
       </para>

<screen>
SELECT EXTRACT(MICROSECONDS FROM TIME '17:12:28.5');
<lineannotation>Result: </lineannotation><computeroutput>28500000</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>millennium</literal></term>
      <listitem>
       <para>
<!--
        The millennium
-->
ミレニアム（1千年期間）
       </para>

<screen>
SELECT EXTRACT(MILLENNIUM FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>3</computeroutput>
</screen>

       <para>
<!--
        Years in the 1900s are in the second millennium.
        The third millennium started January 1, 2001.
-->
1900年代の年は第2ミレニアムです。第3ミレニアムは2001年1月1日から始まりました。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>milliseconds</literal></term>
      <listitem>
       <para>
<!--
        The seconds field, including fractional parts, multiplied by
        1000.  Note that this includes full seconds.
-->
端数部分も含み、1000を乗じられた秒フィールド。全ての秒を含むことに注意してください。
       </para>

<screen>
SELECT EXTRACT(MILLISECONDS FROM TIME '17:12:28.5');
<lineannotation>Result: </lineannotation><computeroutput>28500</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>minute</literal></term>
      <listitem>
       <para>
<!--
        The minutes field (0 - 59)
-->
分フィールド（0〜59）
       </para>

<screen>
SELECT EXTRACT(MINUTE FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>38</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>month</literal></term>
      <listitem>
       <para>
<!--
        For <type>timestamp</type> values, the number of the month
        within the year (1 - 12) ; for <type>interval</type> values,
        the number of months, modulo 12 (0 - 11)
-->
<type>timestamp</type>型の値に対しては年内の月番号（1〜12）。<type>interval</type>型の値に対しては月番号で、12の剰余（0〜11）。
       </para>

<screen>
SELECT EXTRACT(MONTH FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>2</computeroutput>

SELECT EXTRACT(MONTH FROM INTERVAL '2 years 3 months');
<lineannotation>Result: </lineannotation><computeroutput>3</computeroutput>

SELECT EXTRACT(MONTH FROM INTERVAL '2 years 13 months');
<lineannotation>Result: </lineannotation><computeroutput>1</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>quarter</literal></term>
      <listitem>
       <para>
<!--
        The quarter of the year (1 - 4) that the date is in
-->
その日付が含まれる年の四半期（1〜4）。
       </para>

<screen>
SELECT EXTRACT(QUARTER FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>1</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>second</literal></term>
      <listitem>
       <para>
<!--
        The seconds field, including fractional parts (0 -
        59<footnote><simpara>60 if leap seconds are
        implemented by the operating system</simpara></footnote>)
-->
端数を含んだ秒フィールド（0〜59<footnote><simpara>オペレーティングシステムでうるう秒が実装されている場合は60まで。</simpara></footnote>）。
       </para>

<screen>
SELECT EXTRACT(SECOND FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>40</computeroutput>

SELECT EXTRACT(SECOND FROM TIME '17:12:28.5');
<lineannotation>Result: </lineannotation><computeroutput>28.5</computeroutput>
</screen>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>timezone</literal></term>
      <listitem>
       <para>
<!--
        The time zone offset from UTC, measured in seconds.  Positive values
        correspond to time zones east of UTC, negative values to
        zones west of UTC.  (Technically,
        <productname>PostgreSQL</productname> uses <acronym>UT1</> because
        leap seconds are not handled.)
-->
秒単位のUTCからの時間帯オフセット。正の値はUTCより東の時間帯に対応し、負の値はUTCより西の時間帯に対応。
(技術的には、<productname>PostgreSQL</productname>はうるう秒を制御しないため<acronym>UT1</>を使用。)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>timezone_hour</literal></term>
      <listitem>
       <para>
<!--
        The hour component of the time zone offset
-->
時間帯オフセットの時の成分。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>timezone_minute</literal></term>
      <listitem>
       <para>
<!--
        The minute component of the time zone offset
-->
時間帯オフセットの分の成分。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>week</literal></term>
      <listitem>
       <para>
<!--
        The number of the week of the year that the day is in.  By definition
        (<acronym>ISO</acronym> 8601), weeks start on Mondays and the first
        week of a year contains January 4 of that year.  In other words, the
        first Thursday of a year is in week 1 of that year.
-->
その日の年間通算での週を計算します。
（<acronym>ISO</acronym> 8601の）定義では週は月曜日から始まり、その年の1月4日を含む週をその年の第1週としています。
つまり、年の最初の木曜日がある週がその年の第1週となります。
       </para>
       <para>
<!--
        In the ISO definition, it is possible for early-January dates to be
        part of the 52nd or 53rd week of the previous year, and for
        late-December dates to be part of the first week of the next year.
        For example, <literal>2005-01-01</> is part of the 53rd week of year
        2004, and <literal>2006-01-01</> is part of the 52nd week of year
        2005, while <literal>2012-12-31</> is part of the first week of 2013.
        It's recommended to use the <literal>isoyear</> field together with
        <literal>week</> to get consistent results.
-->
ISOの定義では、1月の早い日にちは前年の第52週もしくは第53週となることがあり、12月の遅い日にちには次年の最初の週の一部となることがあります。
例えば、<literal>2005-01-01</>は2004年の第53週であり、<literal>2006-01-01</>は2005年の第52週の一部です、一方<literal>2012-12-31</>は2013年の第1週の一部となります。
整合性のある結果を得るため、<literal>isoyear</>フィールドと<literal>week</>を併用することを推奨します。
       </para>

<screen>
SELECT EXTRACT(WEEK FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>7</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>year</literal></term>
      <listitem>
       <para>
<!--
        The year field.  Keep in mind there is no <literal>0 AD</>, so subtracting
        <literal>BC</> years from <literal>AD</> years should be done with care.
-->
年フィールド。<literal>AD零年</>が存在しないことは忘れないでください。このため<literal>AD</>の年から<literal>BC</>の年を減する時には注意が必要です。
       </para>

<screen>
SELECT EXTRACT(YEAR FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>2001</computeroutput>
</screen>
      </listitem>
     </varlistentry>

    </variablelist>
   </para>

   <para>
<!--
    The <function>extract</function> function is primarily intended
    for computational processing.  For formatting date/time values for
    display, see <xref linkend="functions-formatting">.
-->
<function>extract</function>関数は主に演算処理を意図しています。
日付/時刻の値を表示する目的での書式については<xref linkend="functions-formatting">を参照してください。
   </para>

   <para>
<!--
    The <function>date_part</function> function is modeled on the traditional
    <productname>Ingres</productname> equivalent to the
    <acronym>SQL</acronym>-standard function <function>extract</function>:
-->
<function>date_part</function>関数は伝統的な<productname>Ingres</productname>上で設計されたもので、標準<acronym>SQL</acronym>の<function>extract</function>関数と等価です。
<synopsis>
date_part('<replaceable>field</replaceable>', <replaceable>source</replaceable>)
</synopsis>
<!--
    Note that here the <replaceable>field</replaceable> parameter needs to
    be a string value, not a name.  The valid field names for
    <function>date_part</function> are the same as for
    <function>extract</function>.
-->
ここで<replaceable>field</replaceable>パラメータが名前ではなく文字列値である必要があることに注意してください。
<function>date_part</function>で有効なフィールド名は<function>extract</function>と同じです。
   </para>

<screen>
SELECT date_part('day', TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>16</computeroutput>

SELECT date_part('hour', INTERVAL '4 hours 3 minutes');
<lineannotation>Result: </lineannotation><computeroutput>4</computeroutput>
</screen>

  </sect2>

  <sect2 id="functions-datetime-trunc">
   <title><function>date_trunc</function></title>

   <indexterm>
    <primary>date_trunc</primary>
   </indexterm>

   <para>
<!--
    The function <function>date_trunc</function> is conceptually
    similar to the <function>trunc</function> function for numbers.
-->
<function>date_trunc</function>関数は概念的に数値に対する<function>trunc</function>関数と類似しています。
   </para>

   <para>
<synopsis>
date_trunc('<replaceable>field</replaceable>', <replaceable>source</replaceable>)
</synopsis>
<!--
    <replaceable>source</replaceable> is a value expression of type
    <type>timestamp</type> or <type>interval</>.
    (Values of type <type>date</type> and
    <type>time</type> are cast automatically to <type>timestamp</type> or
    <type>interval</>, respectively.)
    <replaceable>field</replaceable> selects to which precision to
    truncate the input value.  The return value is of type
    <type>timestamp</type> or <type>interval</>
    with all fields that are less significant than the
    selected one set to zero (or one, for day and month).
-->
<replaceable>source</replaceable>は、データ型<type>timestamp</type>もしくは<type>interval</>の評価式です
（データ型<type>date</type>と<type>time</type>はそれぞれ自動的に<type>timestamp</type>もしくは<type>interval</>にキャストされます。）
<replaceable>field</replaceable>は、入力値の値をどの精度で切り捨てるかを選択します。
戻り値の値は、選択されたもの以下をゼロに設定（日と月の場合は1に設定）した、全てのフィールドを持つ<type>timestamp</type>もしくは<type>interval</>型です。
   </para>

   <para>
<!--
    Valid values for <replaceable>field</replaceable> are:
-->
<replaceable>field</replaceable>の有効値には次のものがあります。
    <simplelist>
     <member><literal>microseconds</literal></member>
     <member><literal>milliseconds</literal></member>
     <member><literal>second</literal></member>
     <member><literal>minute</literal></member>
     <member><literal>hour</literal></member>
     <member><literal>day</literal></member>
     <member><literal>week</literal></member>
     <member><literal>month</literal></member>
     <member><literal>quarter</literal></member>
     <member><literal>year</literal></member>
     <member><literal>decade</literal></member>
     <member><literal>century</literal></member>
     <member><literal>millennium</literal></member>
    </simplelist>
   </para>

   <para>
<!--
    Examples:
-->
例：
<screen>
SELECT date_trunc('hour', TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>2001-02-16 20:00:00</computeroutput>

SELECT date_trunc('year', TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>2001-01-01 00:00:00</computeroutput>
</screen>
   </para>
  </sect2>

  <sect2 id="functions-datetime-zoneconvert">
   <title><literal>AT TIME ZONE</literal></title>

   <indexterm>
<!--
    <primary>time zone</primary>
    <secondary>conversion</secondary>
-->
    <primary>時間帯</primary>
    <secondary>変換</secondary>
   </indexterm>

   <indexterm>
    <primary>AT TIME ZONE</primary>
   </indexterm>

   <para>
<!--
    The <literal>AT TIME ZONE</literal> construct allows conversions
    of time stamps to different time zones.  <xref
    linkend="functions-datetime-zoneconvert-table"> shows its
    variants.
-->
<function>AT TIME ZONE</function>構文を使用することにより、タイムスタンプを異なる時間帯に変換することができます。
<xref linkend="functions-datetime-zoneconvert-table">にその種類を示します。
   </para>

    <table id="functions-datetime-zoneconvert-table">
<!--
     <title><literal>AT TIME ZONE</literal> Variants</title>
-->
     <title><literal>AT TIME ZONE</literal>の種類</title>
     <tgroup cols="3">
      <thead>
       <row>
<!--
        <entry>Expression</entry>
        <entry>Return Type</entry>
        <entry>Description</entry>
-->
        <entry>式</entry>
        <entry>戻り値</entry>
        <entry>説明</entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry>
         <literal><type>timestamp without time zone</type> AT TIME ZONE <replaceable>zone</></literal>
        </entry>
        <entry><type>timestamp with time zone</type></entry>
<!--
        <entry>Treat given time stamp <emphasis>without time zone</> as located in the specified time zone</entry>
-->
        <entry>与えられた<emphasis>時間帯なし</>タイムスタンプを指定された時間帯にあるとして取り扱います。</entry>
       </row>

       <row>
        <entry>
         <literal><type>timestamp with time zone</type> AT TIME ZONE <replaceable>zone</></literal>
        </entry>
        <entry><type>timestamp without time zone</type></entry>
<!--
        <entry>Convert given time stamp <emphasis>with time zone</> to the new time
        zone, with no time zone designation</entry>
-->
        <entry>与えられた<emphasis>時間帯付き</>タイムスタンプを新規の時間帯に、時間帯の指定なく変換します。</entry>
       </row>

       <row>
        <entry>
         <literal><type>time with time zone</type> AT TIME ZONE <replaceable>zone</></literal>
        </entry>
        <entry><type>time with time zone</type></entry>
<!--
        <entry>Convert given time <emphasis>with time zone</> to the new time zone</entry>
-->
        <entry>与えられた時刻<emphasis>with time zone</>を新しい時間帯に変換します。</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
<!--
    In these expressions, the desired time zone <replaceable>zone</> can be
    specified either as a text string (e.g., <literal>'PST'</literal>)
    or as an interval (e.g., <literal>INTERVAL '-08:00'</literal>).
    In the text case, a time zone name can be specified in any of the ways
    described in <xref linkend="datatype-timezones">.
-->
これらの式では、設定する時間帯<replaceable>zone</>は、（<literal>'PST'</literal>のような）テキスト文字列、または（<literal>INTERVAL '-08:00'</literal>のような）時間間隔で指定することができます。
テキストの場合、<xref linkend="datatype-timezones">に示した方法で時間帯名称を指定することができます。
   </para>

   <para>
<!--
    Examples (assuming the local time zone is <literal>PST8PDT</>):
-->
以下に例を示します（ローカル時間帯を<literal>PST8PDT</>と想定しています）。
<screen>
SELECT TIMESTAMP '2001-02-16 20:38:40' AT TIME ZONE 'MST';
<lineannotation>Result: </lineannotation><computeroutput>2001-02-16 19:38:40-08</computeroutput>

SELECT TIMESTAMP WITH TIME ZONE '2001-02-16 20:38:40-05' AT TIME ZONE 'MST';
<lineannotation>Result: </lineannotation><computeroutput>2001-02-16 18:38:40</computeroutput>
</screen>
<!--
    The first example takes a time stamp without time zone and interprets it as MST time
    (UTC-7), which is then converted to PST (UTC-8) for display.  The second example takes
    a time stamp specified in EST (UTC-5) and converts it to local time in MST (UTC-7).
-->
最初の例は、時間帯のないタイプスタンプを使用し、それをMST時間（UTC-7）として解釈し、UTCタイムスタンプを生成します。それから、UTCタイムスタンプが、表示用にPST（UTC-7）に置き換えられます。
2番目の例は、EST（UTC-5）で指定されたタイムスタンプを使用し、MST（UTC-7）でのローカル時間に変換しています。
   </para>

   <para>
<!--
    The function <literal><function>timezone</function>(<replaceable>zone</>,
    <replaceable>timestamp</>)</literal> is equivalent to the SQL-conforming construct
    <literal><replaceable>timestamp</> AT TIME ZONE
    <replaceable>zone</></literal>.
-->
関数<function>timezone</function>(<replaceable>zone</>, <replaceable>timestamp</>)は、SQL準拠の構文<literal><replaceable>timestamp</> AT TIME ZONE <replaceable>zone</></literal>と等価です。
   </para>
  </sect2>

  <sect2 id="functions-datetime-current">
   <title>Current Date/Time</title>

   <indexterm>
<!--
    <primary>date</primary>
    <secondary>current</secondary>
-->
    <primary>日付</primary>
    <secondary>現在</secondary>
   </indexterm>

   <indexterm>
<!--
    <primary>time</primary>
    <secondary>current</secondary>
-->
    <primary>時刻</primary>
    <secondary>現在</secondary>
   </indexterm>

   <para>
<!--
    <productname>PostgreSQL</productname> provides a number of functions
    that return values related to the current date and time.  These
    SQL-standard functions all return values based on the start time of
    the current transaction:
-->
<productname>PostgreSQL</productname>は、現在の日付時刻に関した値を返す多くの関数を提供します。
これらの標準SQL関数はすべて、現在のトランザクションの開始時刻に基づいた値を返します。
<synopsis>
CURRENT_DATE
CURRENT_TIME
CURRENT_TIMESTAMP
CURRENT_TIME(<replaceable>precision</replaceable>)
CURRENT_TIMESTAMP(<replaceable>precision</replaceable>)
LOCALTIME
LOCALTIMESTAMP
LOCALTIME(<replaceable>precision</replaceable>)
LOCALTIMESTAMP(<replaceable>precision</replaceable>)
</synopsis>
    </para>

    <para>
<!--
     <function>CURRENT_TIME</function> and
     <function>CURRENT_TIMESTAMP</function> deliver values with time zone;
     <function>LOCALTIME</function> and
     <function>LOCALTIMESTAMP</function> deliver values without time zone.
-->
<function>CURRENT_TIME</function>および<function>CURRENT_TIMESTAMP</function>関数では、時間帯を伴う値を扱います。一方、<function>LOCALTIME</function>および<function>LOCALTIMESTAMP</function>関数では、時間帯を伴わない値を扱います。
    </para>

    <para>
<!--
     <function>CURRENT_TIME</function>,
     <function>CURRENT_TIMESTAMP</function>,
     <function>LOCALTIME</function>, and
     <function>LOCALTIMESTAMP</function>
     can optionally take
     a precision parameter, which causes the result to be rounded
     to that many fractional digits in the seconds field.  Without a precision parameter,
     the result is given to the full available precision.
-->
<function>CURRENT_TIME</function>、<function>CURRENT_TIMESTAMP</function>、<function>LOCALTIME</function>、および<function>LOCALTIMESTAMP</function>関数では、精度のパラメータをオプションで取ることができ、それに合わせて秒フィールドの端数桁を丸める結果をもたらします。
精度のパラメータがない場合、結果は使用可能な最大精度で出力されます。
    </para>

   <para>
<!--
    Some examples:
-->
例：
<screen>
SELECT CURRENT_TIME;
<lineannotation>Result: </lineannotation><computeroutput>14:39:53.662522-05</computeroutput>

SELECT CURRENT_DATE;
<lineannotation>Result: </lineannotation><computeroutput>2001-12-23</computeroutput>

SELECT CURRENT_TIMESTAMP;
<lineannotation>Result: </lineannotation><computeroutput>2001-12-23 14:39:53.662522-05</computeroutput>

SELECT CURRENT_TIMESTAMP(2);
<lineannotation>Result: </lineannotation><computeroutput>2001-12-23 14:39:53.66-05</computeroutput>

SELECT LOCALTIMESTAMP;
<lineannotation>Result: </lineannotation><computeroutput>2001-12-23 14:39:53.662522</computeroutput>
</screen>
   </para>

   <para>
<!--
    Since these functions return
    the start time of the current transaction, their values do not
    change during the transaction. This is considered a feature:
    the intent is to allow a single transaction to have a consistent
    notion of the <quote>current</quote> time, so that multiple
    modifications within the same transaction bear the same
    time stamp.
-->
これらの関数は、現在のトランザクションの開始時刻を返します。
この値は、トランザクションが実行されている間は変化しません。
これは、次の機能を検討した結果です。
単一トランザクションで、<quote>current</quote>時間を一貫性を持った表現を行うことができるようにすることを目的とし、このため、同一トランザクションで何回変更を行っても同一のタイムスタンプを生成します。
   </para>

   <note>
    <para>
<!--
     Other database systems might advance these values more
     frequently.
-->
他のデータベースシステムでは、これらの値をより頻繁に増加させることがあります。
    </para>
   </note>

   <para>
<!--
    <productname>PostgreSQL</productname> also provides functions that
    return the start time of the current statement, as well as the actual
    current time at the instant the function is called.  The complete list
    of non-SQL-standard time functions is:
-->
<productname>PostgreSQL</productname>はまた、関数を呼び出した時の実際の現在時刻や現在の文の開始時刻を返す関数も提供します。
非標準SQLの関数の全一覧を以下に示します。
<synopsis>
transaction_timestamp()
statement_timestamp()
clock_timestamp()
timeofday()
now()
</synopsis>
   </para>

   <para>
<!--
    <function>transaction_timestamp()</> is equivalent to
    <function>CURRENT_TIMESTAMP</function>, but is named to clearly reflect
    what it returns.
    <function>statement_timestamp()</> returns the start time of the current
    statement (more specifically, the time of receipt of the latest command
    message from the client).
    <function>statement_timestamp()</> and <function>transaction_timestamp()</>
    return the same value during the first command of a transaction, but might
    differ during subsequent commands.
    <function>clock_timestamp()</> returns the actual current time, and
    therefore its value changes even within a single SQL command.
    <function>timeofday()</> is a historical
    <productname>PostgreSQL</productname> function.  Like
    <function>clock_timestamp()</>, it returns the actual current time,
    but as a formatted <type>text</> string rather than a <type>timestamp
    with time zone</> value.
    <function>now()</> is a traditional <productname>PostgreSQL</productname>
    equivalent to <function>transaction_timestamp()</function>.
-->
<function>transaction_timestamp()</>は<function>CURRENT_TIMESTAMP</function>と等価ですが、明確に何を返すかを反映する名前になっています。
<function>statement_timestamp()</>は現在の文の実行開始時刻を返すものです（より具体的にいうと、直前のコマンドメッセージをクライアントから受け取った時刻です）。
<function>statement_timestamp()</>および<function>transaction_timestamp()</>はトランザクションの最初のコマンドでは同じ値を返しますが、その後に引き続くコマンドでは異なる可能性があります。
<function>clock_timestamp()</>は実際の現在時刻を返しますので、その値は単一のSQLコマンドであっても異なります。
<function>timeofday()</>は<productname>PostgreSQL</productname>の歴史的な関数です。
<function>clock_timestamp()</>同様、実際の現在時刻を返しますが、<type>timestamp with time zone</>型の値ではなく、整形された<type>text</>文字列を返します。<function>now()</>は<function>transaction_timestamp()</function>と同じもので、伝統的な<productname>PostgreSQL</productname>関数です。
   </para>

   <para>
<!--
    All the date/time data types also accept the special literal value
    <literal>now</literal> to specify the current date and time (again,
    interpreted as the transaction start time).  Thus,
    the following three all return the same result:
-->
すべての日付/時刻型はまた、現在の日付と時刻（繰り返しますがトランザクションの開始時刻として解釈されます）を表す特殊なリテラル値 <literal>now</literal>を受け付けます。
したがって、下記の３つの実行結果は全て同じものとなります。
<programlisting>
SELECT CURRENT_TIMESTAMP;
SELECT now();
<!--
SELECT TIMESTAMP 'now';  &#045;- incorrect for use with DEFAULT
-->
SELECT TIMESTAMP 'now';  -- DEFAULTで使用するのは正しくない
</programlisting>
   </para>

    <tip>
     <para>
<!--
      You do not want to use the third form when specifying a <literal>DEFAULT</>
      clause while creating a table.  The system will convert <literal>now</literal>
      to a <type>timestamp</type> as soon as the constant is parsed, so that when
      the default value is needed,
      the time of the table creation would be used!  The first two
      forms will not be evaluated until the default value is used,
      because they are function calls.  Thus they will give the desired
      behavior of defaulting to the time of row insertion.
-->
テーブルを作成する時、<literal>DEFAULT</>句を指定するのに3番目の形式を使おうとは思わないでしょう。
定数が解析された時、システムが<literal>now</literal>を<type>timestamp</type>に変換するので、デフォルト値としてテーブルが作成された時刻が使われます。最初の2つの形式は関数呼び出しのためデフォルト値が使用されるまで評価されません。ですから、これらの関数は列の挿入時間をデフォルトとする、望ましい振舞いをします。
     </para>
    </tip>
  </sect2>

  <sect2 id="functions-datetime-delay">
<!--
   <title>Delaying Execution</title>
-->
   <title>遅延実行</title>

   <indexterm>
    <primary>pg_sleep</primary>
   </indexterm>
   <indexterm>
    <primary>pg_sleep_for</primary>
   </indexterm>
   <indexterm>
    <primary>pg_sleep_until</primary>
   </indexterm>
   <indexterm>
<!--
    <primary>sleep</primary>
-->
    <primary>休止</primary>
   </indexterm>
   <indexterm>
<!--
    <primary>delay</primary>
-->
    <primary>遅延</primary>
   </indexterm>

   <para>
<!--
    The following functions are available to delay execution of the server
    process:
-->
以下の関数は、サーバプロセスの実行を遅延させるために使用可能です。
<synopsis>
pg_sleep(<replaceable>seconds</replaceable>)
pg_sleep_for(<type>interval</>)
pg_sleep_until(<type>timestamp with time zone</>)
</synopsis>

<!--
    <function>pg_sleep</function> makes the current session's process
    sleep until <replaceable>seconds</replaceable> seconds have
    elapsed.  <replaceable>seconds</replaceable> is a value of type
    <type>double precision</>, so fractional-second delays can be specified.
    <function>pg_sleep_for</function> is a convenience function for larger
    sleep times specified as an <type>interval</>.
    <function>pg_sleep_until</function> is a convenience function for when
    a specific wake-up time is desired.
    For example:
-->
<function>pg_sleep</function>は、<replaceable>seconds</replaceable>秒経過するまで、現在のセッションのプロセスを休止させます。
<replaceable>seconds</replaceable>は<type>double precision</>型の値です。そのため、小数単位で休止秒数を指定することができます。
<function>pg_sleep_for</function>は<type>interval</>でより長い休止時間を指定する便利な関数です。
<function>pg_sleep_until</function>は特定の起床時刻が望まれる場合に便利な関数です。
以下に例を示します。

<programlisting>
SELECT pg_sleep(1.5);
SELECT pg_sleep_for('5 minutes');
SELECT pg_sleep_until('tomorrow 03:00');
</programlisting>
   </para>

   <note>
     <para>
<!--
      The effective resolution of the sleep interval is platform-specific;
      0.01 seconds is a common value.  The sleep delay will be at least as long
      as specified. It might be longer depending on factors such as server load.
      In particular, <function>pg_sleep_until</function> is not guaranteed to
      wake up exactly at the specified time, but it will not wake up any earlier.
-->
休止時間の有効な分解能はプラットフォームに依存します。0.01秒が一般的な値です。
遅延は少なくとも指定した通り行われます。
サーバの負荷が要因となり、より長くなる可能性があります。
特に、<function>pg_sleep_until</function>は指定した時刻ちょうどに起床する保証はありませんが、それより早く起床することはありません。
     </para>
   </note>

   <warning>
     <para>
<!--
      Make sure that your session does not hold more locks than necessary
      when calling <function>pg_sleep</function> or its variants.  Otherwise
      other sessions might have to wait for your sleeping process, slowing down
      the entire system.
-->
<function>pg_sleep</function>またはその亜種を呼び出す時、セッションが必要以上のロックを保持していないことを確実にしてください。
さもないと、他のセッションが休止中のプロセスを待機しなければならないかもしれません。そのためシステム全体の速度が低下することになるかもしれません。
     </para>
   </warning>
  </sect2>

 </sect1>


 <sect1 id="functions-enum">
<!--
  <title>Enum Support Functions</title>
-->
  <title>列挙型サポート関数</title>

  <para>
<!--
   For enum types (described in <xref linkend="datatype-enum">),
   there are several functions that allow cleaner programming without
   hard-coding particular values of an enum type.
   These are listed in <xref linkend="functions-enum-table">. The examples
   assume an enum type created as:
-->
列挙型（<xref linkend="datatype-enum">で解説）に対し、特に列挙型の値をハードコーディングせず簡潔なプログラミングを可能にするいくつかの関数があります。
それらの関数は<xref linkend="functions-enum-table">で一覧されています。
例は以下のようにして列挙型が作成されていることを想定しています。

<programlisting>
CREATE TYPE rainbow AS ENUM ('red', 'orange', 'yellow', 'green', 'blue', 'purple');
</programlisting>

  </para>

  <table id="functions-enum-table">
<!--
    <title>Enum Support Functions</title>
-->
    <title>列挙型サポート関数</title>
    <tgroup cols="4">
     <thead>
      <row>
<!--
       <entry>Function</entry>
       <entry>Description</entry>
       <entry>Example</entry>
       <entry>Example Result</entry>
-->
       <entry>関数</entry>
       <entry>説明</entry>
       <entry>例</entry>
       <entry>例の結果</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>
         <indexterm>
          <primary>enum_first</primary>
         </indexterm>
         <literal>enum_first(anyenum)</literal>
       </entry>
<!--
       <entry>Returns the first value of the input enum type</entry>
-->
       <entry>最初の入力列挙型の値を返す</entry>
       <entry><literal>enum_first(null::rainbow)</literal></entry>
       <entry><literal>red</literal></entry>
      </row>
      <row>
       <entry>
         <indexterm>
          <primary>enum_last</primary>
         </indexterm>
         <literal>enum_last(anyenum)</literal>
       </entry>
<!--
       <entry>Returns the last value of the input enum type</entry>
-->
       <entry>最後の入力列挙型の値を返す</entry>
       <entry><literal>enum_last(null::rainbow)</literal></entry>
       <entry><literal>purple</literal></entry>
      </row>
      <row>
       <entry>
         <indexterm>
          <primary>enum_range</primary>
         </indexterm>
         <literal>enum_range(anyenum)</literal>
       </entry>
<!--
       <entry>Returns all values of the input enum type in an ordered array</entry>
-->
       <entry>ある順序付けられた配列にもとづいて入力列挙型の全ての値を返す</entry>
       <entry><literal>enum_range(null::rainbow)</literal></entry>
       <entry><literal>{red,orange,yellow,green,blue,purple}</literal></entry>
      </row>
      <row>
       <entry morerows="2"><literal>enum_range(anyenum, anyenum)</literal></entry>
       <entry morerows="2">
<!--
        Returns the range between the two given enum values, as an ordered
        array. The values must be from the same enum type. If the first
        parameter is null, the result will start with the first value of
        the enum type.
        If the second parameter is null, the result will end with the last
        value of the enum type.
-->
与えられた２つの列挙型値の範囲を、ある順序付けられた配列として返す。
値は同一の列挙型に拠らなければならない。
始めのパラメータがNULLの場合、結果は列挙型の最初の値から始まる。
２番目のパラメータがNULLの場合、結果は列挙型の最後の値で終端する。
       </entry>
       <entry><literal>enum_range('orange'::rainbow, 'green'::rainbow)</literal></entry>
       <entry><literal>{orange,yellow,green}</literal></entry>
      </row>
      <row>
       <entry><literal>enum_range(NULL, 'green'::rainbow)</literal></entry>
       <entry><literal>{red,orange,yellow,green}</literal></entry>
      </row>
      <row>
       <entry><literal>enum_range('orange'::rainbow, NULL)</literal></entry>
       <entry><literal>{orange,yellow,green,blue,purple}</literal></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
<!--
    Notice that except for the two-argument form of <function>enum_range</>,
    these functions disregard the specific value passed to them; they care
    only about its declared data type.  Either null or a specific value of
    the type can be passed, with the same result.  It is more common to
    apply these functions to a table column or function argument than to
    a hardwired type name as suggested by the examples.
-->
<function>enum_range</>の２引数形式を除いて、関数に渡された特定の値はそれら関数が無視することに注意してください。関数は宣言されたデータ型のみ配慮します。
NULLまたはその型の特定値のみが渡され、同一の結果をもたらします。
例が示唆しているように、組み込まれている型名に対してではなく、テーブル列もしくは関数引数にこれらの関数を適用することがより一般的です。
   </para>
 </sect1>

 <sect1 id="functions-geometry">
<!--
  <title>Geometric Functions and Operators</title>
-->
  <title>幾何関数と演算子</title>

   <para>
<!--
    The geometric types <type>point</type>, <type>box</type>,
    <type>lseg</type>, <type>line</type>, <type>path</type>,
    <type>polygon</type>, and <type>circle</type> have a large set of
    native support functions and operators, shown in <xref
    linkend="functions-geometry-op-table">, <xref
    linkend="functions-geometry-func-table">, and <xref
    linkend="functions-geometry-conv-table">.
-->
<type>point</type>、<type>box</type>、<type>lseg</type>、<type>line</type>、<type>path</type>、<type>polygon</type>、および<type>circle</type>幾何データ型には、PostgreSQLが元々サポートしている関数と演算子が豊富に揃っています（<xref linkend="functions-geometry-op-table">、<xref linkend="functions-geometry-func-table">、および<xref linkend="functions-geometry-conv-table">を参照してください）。
   </para>

   <caution>
    <para>
<!--
     Note that the <quote>same as</> operator, <literal>~=</>, represents
     the usual notion of equality for the <type>point</type>,
     <type>box</type>, <type>polygon</type>, and <type>circle</type> types.
     Some of these types also have an <literal>=</> operator, but
     <literal>=</> compares
     for equal <emphasis>areas</> only.  The other scalar comparison operators
     (<literal>&lt;=</> and so on) likewise compare areas for these types.
-->
<quote>同じを示す</><literal>~=</>演算子は<type>point</type>、<type>box</type>、<type>polygon</type>、および<type>circle</type>型に対し通常の等価概念を示すことに注意してください。これらのいくつかの型は<literal>=</>演算子を持ちますが、<literal>=</>は<emphasis>面積</>の等しさのみを比較します。その他のスカラー比較演算子（<literal>&lt;=</>など）は同様にこれらの型の面積を比較します。
    </para>
   </caution>

   <table id="functions-geometry-op-table">
<!--
     <title>Geometric Operators</title>
-->
     <title>幾何データ演算子</title>
     <tgroup cols="3">
      <thead>
       <row>
<!--
        <entry>Operator</entry>
        <entry>Description</entry>
        <entry>Example</entry>
-->
        <entry>演算子</entry>
        <entry>説明</entry>
        <entry>例</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry> <literal>+</literal> </entry>
<!--
        <entry>Translation</entry>
-->
        <entry>平行移動</entry>
        <entry><literal>box '((0,0),(1,1))' + point '(2.0,0)'</literal></entry>
       </row>
       <row>
        <entry> <literal>-</literal> </entry>
<!--
        <entry>Translation</entry>
-->
        <entry>平行移動</entry>
        <entry><literal>box '((0,0),(1,1))' - point '(2.0,0)'</literal></entry>
       </row>
       <row>
        <entry> <literal>*</literal> </entry>
<!--
        <entry>Scaling/rotation</entry>
-->
        <entry>拡大縮小/回転</entry>
        <entry><literal>box '((0,0),(1,1))' * point '(2.0,0)'</literal></entry>
       </row>
       <row>
        <entry> <literal>/</literal> </entry>
<!--
        <entry>Scaling/rotation</entry>
-->
        <entry>拡大縮小/回転</entry>
        <entry><literal>box '((0,0),(2,2))' / point '(2.0,0)'</literal></entry>
       </row>
       <row>
        <entry> <literal>#</literal> </entry>
<!--
        <entry>Point or box of intersection</entry>
-->
        <entry>交差点、交差矩形</entry>
        <entry><literal>'((1,-1),(-1,1))' # '((1,1),(-1,-1))'</literal></entry>
       </row>
       <row>
        <entry> <literal>#</literal> </entry>
<!--
        <entry>Number of points in path or polygon</entry>
-->
        <entry>経路もしくは多角形の点の数</entry>
        <entry><literal># '((1,0),(0,1),(-1,0))'</literal></entry>
       </row>
       <row>
        <entry> <literal>@-@</literal> </entry>
<!--
        <entry>Length or circumference</entry>
-->
        <entry>長さもしくは円周</entry>
        <entry><literal>@-@ path '((0,0),(1,0))'</literal></entry>
       </row>
       <row>
        <entry> <literal>@@</literal> </entry>
<!--
        <entry>Center</entry>
-->
        <entry>中心</entry>
        <entry><literal>@@ circle '((0,0),10)'</literal></entry>
       </row>
       <row>
        <entry> <literal>##</literal> </entry>
<!--
        <entry>Closest point to first operand on second operand</entry>
-->
        <entry>第1演算項目と第2演算項目との近接点</entry>
        <entry><literal>point '(0,0)' ## lseg '((2,0),(0,2))'</literal></entry>
       </row>
       <row>
        <entry> <literal>&lt;-&gt;</literal> </entry>
<!--
        <entry>Distance between</entry>
-->
        <entry>距離</entry>
        <entry><literal>circle '((0,0),1)' &lt;-&gt; circle '((5,0),1)'</literal></entry>
       </row>
       <row>
        <entry> <literal>&amp;&amp;</literal> </entry>
<!--
        <entry>Overlaps?  (One point in common makes this true.)</entry>
-->
        <entry>重なっているかどうか？(一つでも共通する点があれば真となります)</entry>
        <entry><literal>box '((0,0),(1,1))' &amp;&amp; box '((0,0),(2,2))'</literal></entry>
       </row>
       <row>
        <entry> <literal>&lt;&lt;</literal> </entry>
<!--
        <entry>Is strictly left of?</entry>
-->
        <entry>厳密に左側にあるか？</entry>
        <entry><literal>circle '((0,0),1)' &lt;&lt; circle '((5,0),1)'</literal></entry>
       </row>
       <row>
        <entry> <literal>&gt;&gt;</literal> </entry>
<!--
        <entry>Is strictly right of?</entry>
-->
        <entry>厳密に右側にあるか？</entry>
        <entry><literal>circle '((5,0),1)' &gt;&gt; circle '((0,0),1)'</literal></entry>
       </row>
       <row>
        <entry> <literal>&amp;&lt;</literal> </entry>
<!--
        <entry>Does not extend to the right of?</entry>
-->
        <entry>右側にはみ出さないか？</entry>
        <entry><literal>box '((0,0),(1,1))' &amp;&lt; box '((0,0),(2,2))'</literal></entry>
       </row>
       <row>
        <entry> <literal>&amp;&gt;</literal> </entry>
<!--
        <entry>Does not extend to the left of?</entry>
-->
        <entry>左側にはみ出さないか？</entry>
        <entry><literal>box '((0,0),(3,3))' &amp;&gt; box '((0,0),(2,2))'</literal></entry>
       </row>
       <row>
        <entry> <literal>&lt;&lt;|</literal> </entry>
<!--
        <entry>Is strictly below?</entry>
-->
        <entry>厳密に下側にあるか？</entry>
        <entry><literal>box '((0,0),(3,3))' &lt;&lt;| box '((3,4),(5,5))'</literal></entry>
       </row>
       <row>
        <entry> <literal>|&gt;&gt;</literal> </entry>
<!--
        <entry>Is strictly above?</entry>
-->
        <entry>厳密に上側にあるか？</entry>
        <entry><literal>box '((3,4),(5,5))' |&gt;&gt; box '((0,0),(3,3))'</literal></entry>
       </row>
       <row>
        <entry> <literal>&amp;&lt;|</literal> </entry>
<!--
        <entry>Does not extend above?</entry>
-->
        <entry>上側に出ていないか？</entry>
        <entry><literal>box '((0,0),(1,1))' &amp;&lt;| box '((0,0),(2,2))'</literal></entry>
       </row>
       <row>
        <entry> <literal>|&amp;&gt;</literal> </entry>
<!--
        <entry>Does not extend below?</entry>
-->
        <entry>下側に出ていないか？</entry>
        <entry><literal>box '((0,0),(3,3))' |&amp;&gt; box '((0,0),(2,2))'</literal></entry>
       </row>
       <row>
        <entry> <literal>&lt;^</literal> </entry>
<!--
        <entry>Is below (allows touching)?</entry>
-->
        <entry>（接触を許可し）下側にあるか？</entry>
        <entry><literal>circle '((0,0),1)' &lt;^ circle '((0,5),1)'</literal></entry>
       </row>
       <row>
        <entry> <literal>&gt;^</literal> </entry>
<!--
        <entry>Is above (allows touching)?</entry>
-->
        <entry>（接触を許可し）上側にあるか？</entry>
        <entry><literal>circle '((0,5),1)' &gt;^ circle '((0,0),1)'</literal></entry>
       </row>
       <row>
        <entry> <literal>?#</literal> </entry>
<!--
        <entry>Intersects?</entry>
-->
        <entry>交わるか？</entry>
        <entry><literal>lseg '((-1,0),(1,0))' ?# box '((-2,-2),(2,2))'</literal></entry>
       </row>
       <row>
        <entry> <literal>?-</literal> </entry>
<!--
        <entry>Is horizontal?</entry>
-->
        <entry>水平か？</entry>
        <entry><literal>?- lseg '((-1,0),(1,0))'</literal></entry>
       </row>
       <row>
        <entry> <literal>?-</literal> </entry>
<!--
        <entry>Are horizontally aligned?</entry>
-->
        <entry>水平方向に揃っているか？</entry>
        <entry><literal>point '(1,0)' ?- point '(0,0)'</literal></entry>
       </row>
       <row>
        <entry> <literal>?|</literal> </entry>
<!--
        <entry>Is vertical?</entry>
-->
        <entry>垂直か？</entry>
        <entry><literal>?| lseg '((-1,0),(1,0))'</literal></entry>
       </row>
       <row>
        <entry> <literal>?|</literal> </entry>
<!--
        <entry>Are vertically aligned?</entry>
-->
        <entry>垂直方向に揃っているか？</entry>
        <entry><literal>point '(0,1)' ?| point '(0,0)'</literal></entry>
       </row>
       <row>
        <entry> <literal>?-|</literal> </entry>
<!--
        <entry>Is perpendicular?</entry>
-->
        <entry>直角をなしているか？</entry>
        <entry><literal>lseg '((0,0),(0,1))' ?-| lseg '((0,0),(1,0))'</literal></entry>
       </row>
       <row>
        <entry> <literal>?||</literal> </entry>
<!--
        <entry>Are parallel?</entry>
-->
        <entry>平行か？</entry>
        <entry><literal>lseg '((-1,0),(1,0))' ?|| lseg '((-1,2),(1,2))'</literal></entry>
       </row>
       <row>
        <entry> <literal>@&gt;</literal> </entry>
<!--
        <entry>Contains?</entry>
-->
        <entry>包含しているか？</entry>
        <entry><literal>circle '((0,0),2)' @&gt; point '(1,1)'</literal></entry>
       </row>
       <row>
        <entry> <literal>&lt;@</literal> </entry>
<!--
        <entry>Contained in or on?</entry>
-->
        <entry>包含されているかもしくは境界上か？</entry>
        <entry><literal>point '(1,1)' &lt;@ circle '((0,0),2)'</literal></entry>
       </row>
       <row>
        <entry> <literal>~=</literal> </entry>
<!--
        <entry>Same as?</entry>
-->
        <entry>同等か？</entry>
        <entry><literal>polygon '((0,0),(1,1))' ~= polygon '((1,1),(0,0))'</literal></entry>
       </row>
      </tbody>
     </tgroup>
   </table>

   <note>
    <para>
<!--
     Before <productname>PostgreSQL</productname> 8.2, the containment
     operators <literal>@&gt;</> and <literal>&lt;@</> were respectively
     called <literal>~</> and <literal>@</>.  These names are still
     available, but are deprecated and will eventually be removed.
-->
<productname>PostgreSQL</productname> 8.2より前では、包含演算子<literal>@&gt;</>および<literal>&lt;@</>はそれぞれ<literal>~</>および<literal>@</>という名前でした。
これらの名前はまだ利用できますが、削除予定であり最終的にはなくなるでしょう。
    </para>
   </note>

   <indexterm>
    <primary>area</primary>
   </indexterm>
   <indexterm>
    <primary>center</primary>
   </indexterm>
   <indexterm>
    <primary>diameter</primary>
   </indexterm>
   <indexterm>
    <primary>height</primary>
   </indexterm>
   <indexterm>
    <primary>isclosed</primary>
   </indexterm>
   <indexterm>
    <primary>isopen</primary>
   </indexterm>
   <indexterm>
    <primary>length</primary>
   </indexterm>
   <indexterm>
    <primary>npoints</primary>
   </indexterm>
   <indexterm>
    <primary>pclose</primary>
   </indexterm>
   <indexterm>
    <primary>popen</primary>
   </indexterm>
   <indexterm>
    <primary>radius</primary>
   </indexterm>
   <indexterm>
    <primary>width</primary>
   </indexterm>

   <table id="functions-geometry-func-table">
<!--
     <title>Geometric Functions</title>
-->
     <title>幾何データ型関数</title>
     <tgroup cols="4">
      <thead>
       <row>
<!--
        <entry>Function</entry>
        <entry>Return Type</entry>
        <entry>Description</entry>
        <entry>Example</entry>
-->
        <entry>関数</entry>
        <entry>戻り値</entry>
        <entry>説明</entry>
        <entry>例</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><literal><function>area(<replaceable>object</>)</function></literal></entry>
        <entry><type>double precision</type></entry>
<!--
        <entry>area</entry>
-->
        <entry>面積</entry>
        <entry><literal>area(box '((0,0),(1,1))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>center(<replaceable>object</>)</function></literal></entry>
        <entry><type>point</type></entry>
<!--
        <entry>center</entry>
-->
        <entry>中心</entry>
        <entry><literal>center(box '((0,0),(1,2))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>diameter(<type>circle</>)</function></literal></entry>
        <entry><type>double precision</type></entry>
<!--
        <entry>diameter of circle</entry>
-->
        <entry>円の直径</entry>
        <entry><literal>diameter(circle '((0,0),2.0)')</literal></entry>
       </row>
       <row>
        <entry><literal><function>height(<type>box</>)</function></literal></entry>
        <entry><type>double precision</type></entry>
<!--
        <entry>vertical size of box</entry>
-->
        <entry>矩形の高さ</entry>
        <entry><literal>height(box '((0,0),(1,1))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>isclosed(<type>path</>)</function></literal></entry>
        <entry><type>boolean</type></entry>
<!--
        <entry>a closed path?</entry>
-->
        <entry>閉経路か？</entry>
        <entry><literal>isclosed(path '((0,0),(1,1),(2,0))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>isopen(<type>path</>)</function></literal></entry>
        <entry><type>boolean</type></entry>
<!--
        <entry>an open path?</entry>
-->
        <entry>開経路か？</entry>
        <entry><literal>isopen(path '[(0,0),(1,1),(2,0)]')</literal></entry>
       </row>
       <row>
        <entry><literal><function>length(<replaceable>object</>)</function></literal></entry>
        <entry><type>double precision</type></entry>
<!--
        <entry>length</entry>
-->
        <entry>長さ</entry>
        <entry><literal>length(path '((-1,0),(1,0))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>npoints(<type>path</>)</function></literal></entry>
        <entry><type>int</type></entry>
<!--
        <entry>number of points</entry>
-->
        <entry>点の数</entry>
        <entry><literal>npoints(path '[(0,0),(1,1),(2,0)]')</literal></entry>
       </row>
       <row>
        <entry><literal><function>npoints(<type>polygon</>)</function></literal></entry>
        <entry><type>int</type></entry>
<!--
        <entry>number of points</entry>
-->
        <entry>点の数</entry>
        <entry><literal>npoints(polygon '((1,1),(0,0))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>pclose(<type>path</>)</function></literal></entry>
        <entry><type>path</type></entry>
<!--
        <entry>convert path to closed</entry>
-->
        <entry>閉経路に変換</entry>
        <entry><literal>pclose(path '[(0,0),(1,1),(2,0)]')</literal></entry>
       </row>
<![IGNORE[
<!-- Not defined by this name. Implements the intersection operator '#' -->
       <row>
        <entry><literal><function>point(<type>lseg</>, <type>lseg</>)</function></literal></entry>
        <entry><type>point</type></entry>
<!--
        <entry>intersection</entry>
-->
        <entry>交点</entry>
        <entry><literal>point(lseg '((-1,0),(1,0))',lseg '((-2,-2),(2,2))')</literal></entry>
       </row>
]]>
       <row>
        <entry><literal><function>popen(<type>path</>)</function></literal></entry>
        <entry><type>path</type></entry>
<!--
        <entry>convert path to open</entry>
-->
        <entry>開経路に変換</entry>
        <entry><literal>popen(path '((0,0),(1,1),(2,0))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>radius(<type>circle</type>)</function></literal></entry>
        <entry><type>double precision</type></entry>
<!--
        <entry>radius of circle</entry>
-->
        <entry>円の半径</entry>
        <entry><literal>radius(circle '((0,0),2.0)')</literal></entry>
       </row>
       <row>
        <entry><literal><function>width(<type>box</>)</function></literal></entry>
        <entry><type>double precision</type></entry>
<!--
        <entry>horizontal size of box</entry>
-->
        <entry>矩形の幅</entry>
        <entry><literal>width(box '((0,0),(1,1))')</literal></entry>
       </row>
      </tbody>
     </tgroup>
   </table>

   <table id="functions-geometry-conv-table">
<!--
     <title>Geometric Type Conversion Functions</title>
-->
     <title>幾何型変換関数</title>
     <tgroup cols="4">
      <thead>
       <row>
<!--
        <entry>Function</entry>
        <entry>Return Type</entry>
        <entry>Description</entry>
        <entry>Example</entry>
-->
        <entry>関数</entry>
        <entry>戻り値</entry>
        <entry>説明</entry>
        <entry>例</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>
         <indexterm>
          <primary>box</primary>
         </indexterm>
         <literal><function>box(<type>circle</type>)</function></literal>
        </entry>
        <entry><type>box</type></entry>
<!--
        <entry>circle to box</entry>
-->
        <entry>円から矩形</entry>
        <entry><literal>box(circle '((0,0),2.0)')</literal></entry>
       </row>
       <row>
        <entry><literal><function>box(<type>point</type>, <type>point</type>)</function></literal></entry>
        <entry><type>box</type></entry>
<!--
        <entry>points to box</entry>
-->
        <entry>座標点を矩形に変換</entry>
        <entry><literal>box(point '(0,0)', point '(1,1)')</literal></entry>
       </row>
       <row>
        <entry><literal><function>box(<type>polygon</type>)</function></literal></entry>
        <entry><type>box</type></entry>
<!--
        <entry>polygon to box</entry>
-->
        <entry>多角形を矩形に変換</entry>
        <entry><literal>box(polygon '((0,0),(1,1),(2,0))')</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>circle</primary>
         </indexterm>
         <literal><function>circle(<type>box</type>)</function></literal>
        </entry>
        <entry><type>circle</type></entry>
<!--
        <entry>box to circle</entry>
-->
        <entry>矩形を円に変換</entry>
        <entry><literal>circle(box '((0,0),(1,1))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>circle(<type>point</type>, <type>double precision</type>)</function></literal></entry>
        <entry><type>circle</type></entry>
<!--
        <entry>center and radius to circle</entry>
-->
        <entry>中心と半径から円に変換</entry>
        <entry><literal>circle(point '(0,0)', 2.0)</literal></entry>
       </row>
       <row>
        <entry><literal><function>circle(<type>polygon</type>)</function></literal></entry>
        <entry><type>circle</type></entry>
<!--
        <entry>polygon to circle</entry>
-->
        <entry>多角形を円に変換</entry>
        <entry><literal>circle(polygon '((0,0),(1,1),(2,0))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>line(<type>point</type>, <type>point</type>)</function></literal></entry>
        <entry><type>line</type></entry>
<!--
        <entry>points to line</entry>
-->
        <entry>座標点を直線に変換</entry>
        <entry><literal>line(point '(-1,0)', point '(1,0)')</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>lseg</primary>
         </indexterm>
         <literal><function>lseg(<type>box</type>)</function></literal>
        </entry>
        <entry><type>lseg</type></entry>
<!--
        <entry>box diagonal to line segment</entry>
-->
        <entry>矩形の対角線を線分に変換</entry>
        <entry><literal>lseg(box '((-1,0),(1,0))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>lseg(<type>point</type>, <type>point</type>)</function></literal></entry>
        <entry><type>lseg</type></entry>
<!--
        <entry>points to line segment</entry>
-->
        <entry>座標点を線分に変換</entry>
        <entry><literal>lseg(point '(-1,0)', point '(1,0)')</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>path</primary>
         </indexterm>
         <literal><function>path(<type>polygon</type>)</function></literal>
        </entry>
        <entry><type>path</type></entry>
<!--
        <entry>polygon to path</entry>
-->
        <entry>多角形を経路に変換</entry>
        <entry><literal>path(polygon '((0,0),(1,1),(2,0))')</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>point</primary>
         </indexterm>
         <literal><function>point</function>(<type>double
         precision</type>, <type>double precision</type>)</literal>
        </entry>
        <entry><type>point</type></entry>
<!--
        <entry>construct point</entry>
-->
        <entry>座標点の構築</entry>
        <entry><literal>point(23.4, -44.5)</literal></entry>
       </row>
       <row>
        <entry><literal><function>point(<type>box</type>)</function></literal></entry>
        <entry><type>point</type></entry>
<!--
        <entry>center of box</entry>
-->
        <entry>矩形の中心</entry>
        <entry><literal>point(box '((-1,0),(1,0))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>point(<type>circle</type>)</function></literal></entry>
        <entry><type>point</type></entry>
<!--
        <entry>center of circle</entry>
-->
        <entry>円の中心</entry>
        <entry><literal>point(circle '((0,0),2.0)')</literal></entry>
       </row>
       <row>
        <entry><literal><function>point(<type>lseg</type>)</function></literal></entry>
        <entry><type>point</type></entry>
<!--
        <entry>center of line segment</entry>
-->
        <entry>線分の中心</entry>
        <entry><literal>point(lseg '((-1,0),(1,0))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>point(<type>polygon</type>)</function></literal></entry>
        <entry><type>point</type></entry>
<!--
        <entry>center of polygon</entry>
-->
        <entry>多角形の中心</entry>
        <entry><literal>point(polygon '((0,0),(1,1),(2,0))')</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>polygon</primary>
         </indexterm>
         <literal><function>polygon(<type>box</type>)</function></literal>
        </entry>
        <entry><type>polygon</type></entry>
<!--
        <entry>box to 4-point polygon</entry>
-->
        <entry>矩形から4頂点の多角形</entry>
        <entry><literal>polygon(box '((0,0),(1,1))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>polygon(<type>circle</type>)</function></literal></entry>
        <entry><type>polygon</type></entry>
<!--
        <entry>circle to 12-point polygon</entry>
-->
        <entry>円から12角形</entry>
        <entry><literal>polygon(circle '((0,0),2.0)')</literal></entry>
       </row>
       <row>
        <entry><literal><function>polygon(<replaceable class="parameter">npts</replaceable>, <type>circle</type>)</function></literal></entry>
        <entry><type>polygon</type></entry>
<!--
        <entry>circle to <replaceable class="parameter">npts</replaceable>-point polygon</entry>
-->
        <entry>円から<replaceable class="parameter">npts</replaceable>角形</entry>
        <entry><literal>polygon(12, circle '((0,0),2.0)')</literal></entry>
       </row>
       <row>
        <entry><literal><function>polygon(<type>path</type>)</function></literal></entry>
        <entry><type>polygon</type></entry>
<!--
        <entry>path to polygon</entry>
-->
        <entry>経路から多角形</entry>
        <entry><literal>polygon(path '((0,0),(1,1),(2,0))')</literal></entry>
       </row>
      </tbody>
     </tgroup>
   </table>

    <para>
<!--
     It is possible to access the two component numbers of a <type>point</>
     as though the point were an array with indexes 0 and 1.  For example, if
     <literal>t.p</> is a <type>point</> column then
     <literal>SELECT p[0] FROM t</> retrieves the X coordinate and
     <literal>UPDATE t SET p[1] = ...</> changes the Y coordinate.
     In the same way, a value of type <type>box</> or <type>lseg</> can be treated
     as an array of two <type>point</> values.
-->
あたかもpointは添字0、1を有する配列であるかのように、<type>point</>の２つの構成要素にアクセスすることができます。
例えば、<literal>t.p</>が<type>point</>列の場合、<literal>SELECT p[0] FROM t</>という式でX座標点を抽出できます。また、<literal>UPDATE t SET p[1] = ...</>でY座標点を変更できます。同様に、<type>box</>または<type>lseg</>でも、2つの<type>point</>からなる配列のように扱えます。
    </para>

    <para>
<!--
     The <function>area</function> function works for the types
     <type>box</type>, <type>circle</type>, and <type>path</type>.
     The <function>area</function> function only works on the
     <type>path</type> data type if the points in the
     <type>path</type> are non-intersecting.  For example, the
     <type>path</type>
     <literal>'((0,0),(0,1),(2,1),(2,2),(1,2),(1,0),(0,0))'::PATH</literal>
     will not work;  however, the following visually identical
     <type>path</type>
     <literal>'((0,0),(0,1),(1,1),(1,2),(2,2),(2,1),(1,1),(1,0),(0,0))'::PATH</literal>
     will work.  If the concept of an intersecting versus
     non-intersecting <type>path</type> is confusing, draw both of the
     above <type>path</type>s side by side on a piece of graph paper.
-->
<function>area</function>関数は、<type>box</type>、<type>circle</type>、<type>path</type>型に対して動作します。
<type>path</type>データ型に対する<function>area</function>関数は、その<type>path</type>が交差しない場合にのみ動作します。
例えば、<literal>'((0,0),(0,1),(2,1),(2,2),(1,2),(1,0),(0,0))'::PATH</literal>という<type>path</type>は動作しません。しかし、見た目は同じですが、<literal>'((0,0),(0,1),(1,1),(1,2),(2,2),(2,1),(1,1),(1,0),(0,0))'::PATH</literal>という<type>path</type>では動作します。
<type>path</type>の交差する、しないという概念がよくわからなければ、上の2つの<type>path</type>を並べてグラフ用紙に書いてみてください。
    </para>

  </sect1>


 <sect1 id="functions-net">
<!--
  <title>Network Address Functions and Operators</title>
-->
  <title>ネットワークアドレス関数と演算子</title>

  <para>
<!--
   <xref linkend="cidr-inet-operators-table"> shows the operators
   available for the <type>cidr</type> and <type>inet</type> types.
   The operators <literal>&lt;&lt;</literal>,
   <literal>&lt;&lt;=</literal>, <literal>&gt;&gt;</literal>,
   <literal>&gt;&gt;=</literal>, and <literal>&amp;&amp;</literal>
   test for subnet inclusion.  They
   <literal>&lt;&lt;=</literal>, <literal>&gt;&gt;</literal>, and
   <literal>&gt;&gt;=</literal> test for subnet inclusion.  They
   consider only the network parts of the two addresses (ignoring any
   host part) and determine whether one network is identical to
   or a subnet of the other.
-->
<xref linkend="cidr-inet-operators-table">に、<type>inet</type>型および<type>cidr</type>型で使用可能な演算子を示します。
演算子 <literal>&lt;&lt;</literal>、<literal>&lt;&lt;=</literal>、<literal>&gt;&gt;</literal>、<literal>&gt;&gt;=</literal>および<literal>&amp;&amp;</literal>はサブネットに含まれているかどうかを調べるものです。
ネットワークの部分のみを考慮（ネットワークアドレスのホスト部分を無視）して2つのネットワークアドレスが等しいか、もしくは一方のネットワークが他方のサブネットになっているかを特定します。
  </para>

    <table id="cidr-inet-operators-table">
<!--
     <title><type>cidr</type> and <type>inet</type> Operators</title>
-->
     <title><type>cidr</type>と<type>inet</type>演算子</title>
     <tgroup cols="3">
      <thead>
       <row>
<!--
        <entry>Operator</entry>
        <entry>Description</entry>
        <entry>Example</entry>
-->
        <entry>演算子</entry>
        <entry>説明</entry>
        <entry>例</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry> <literal>&lt;</literal> </entry>
<!--
        <entry>is less than</entry>
-->
        <entry>未満</entry>
        <entry><literal>inet '192.168.1.5' &lt; inet '192.168.1.6'</literal></entry>
       </row>
       <row>
        <entry> <literal>&lt;=</literal> </entry>
<!--
        <entry>is less than or equal</entry>
-->
        <entry>未満もしくは等しい（以下）</entry>
        <entry><literal>inet '192.168.1.5' &lt;= inet '192.168.1.5'</literal></entry>
       </row>
       <row>
        <entry> <literal>=</literal> </entry>
<!--
        <entry>equals</entry>
-->
        <entry>等しい</entry>
        <entry><literal>inet '192.168.1.5' = inet '192.168.1.5'</literal></entry>
       </row>
       <row>
        <entry> <literal>&gt;=</literal> </entry>
<!--
        <entry>is greater or equal</entry>
-->
        <entry>より大きいもしくは等しい（以上）</entry>
        <entry><literal>inet '192.168.1.5' &gt;= inet '192.168.1.5'</literal></entry>
       </row>
       <row>
        <entry> <literal>&gt;</literal> </entry>
<!--
        <entry>is greater than</entry>
-->
        <entry>より大きい</entry>
        <entry><literal>inet '192.168.1.5' &gt; inet '192.168.1.4'</literal></entry>
       </row>
       <row>
        <entry> <literal>&lt;&gt;</literal> </entry>
<!--
        <entry>is not equal</entry>
-->
        <entry>等しくない</entry>
        <entry><literal>inet '192.168.1.5' &lt;&gt; inet '192.168.1.4'</literal></entry>
       </row>
       <row>
        <entry> <literal>&lt;&lt;</literal> </entry>
<!--
        <entry>is contained by</entry>
-->
        <entry>内包される</entry>
        <entry><literal>inet '192.168.1.5' &lt;&lt; inet '192.168.1/24'</literal></entry>
       </row>
       <row>
        <entry> <literal>&lt;&lt;=</literal> </entry>
<!--
        <entry>is contained by or equals</entry>
-->
        <entry>内包されるか等しい</entry>
        <entry><literal>inet '192.168.1/24' &lt;&lt;= inet '192.168.1/24'</literal></entry>
       </row>
       <row>
        <entry> <literal>&gt;&gt;</literal> </entry>
<!--
        <entry>contains</entry>
-->
        <entry>内包する</entry>
        <entry><literal>inet '192.168.1/24' &gt;&gt; inet '192.168.1.5'</literal></entry>
       </row>
       <row>
        <entry> <literal>&gt;&gt;=</literal> </entry>
<!--
        <entry>contains or equals</entry>
-->
        <entry>内包するか等しい</entry>
        <entry><literal>inet '192.168.1/24' &gt;&gt;= inet '192.168.1/24'</literal></entry>
       </row>
       <row>
        <entry> <literal>&amp;&amp;</literal> </entry>
<!--
        <entry>contains or is contained by</entry>
-->
        <entry>内包するか内包されるか</entry>
        <entry><literal>inet '192.168.1/24' &amp;&amp; inet '192.168.1.80/28'</literal></entry>
       </row>
       <row>
        <entry> <literal>~</literal> </entry>
<!--
        <entry>bitwise NOT</entry>
-->
        <entry>ビット否定</entry>
        <entry><literal>~ inet '192.168.1.6'</literal></entry>
       </row>
       <row>
        <entry> <literal>&amp;</literal> </entry>
<!--
        <entry>bitwise AND</entry>
-->
        <entry>ビット積</entry>
        <entry><literal>inet '192.168.1.6' &amp; inet '0.0.0.255'</literal></entry>
       </row>
       <row>
        <entry> <literal>|</literal> </entry>
<!--
        <entry>bitwise OR</entry>
-->
        <entry>ビット和</entry>
        <entry><literal>inet '192.168.1.6' | inet '0.0.0.255'</literal></entry>
       </row>
       <row>
        <entry> <literal>+</literal> </entry>
<!--
        <entry>addition</entry>
-->
        <entry>加算</entry>
        <entry><literal>inet '192.168.1.6' + 25</literal></entry>
       </row>
       <row>
        <entry> <literal>-</literal> </entry>
<!--
        <entry>subtraction</entry>
-->
        <entry>減算</entry>
        <entry><literal>inet '192.168.1.43' - 36</literal></entry>
       </row>
       <row>
        <entry> <literal>-</literal> </entry>
<!--
        <entry>subtraction</entry>
-->
        <entry>減算</entry>
        <entry><literal>inet '192.168.1.43' - inet '192.168.1.19'</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

  <para>
<!--
   <xref linkend="cidr-inet-functions-table"> shows the functions
   available for use with the <type>cidr</type> and <type>inet</type>
   types.  The <function>abbrev</function>, <function>host</function>,
   and <function>text</function>
   functions are primarily intended to offer alternative display
   formats.
-->
<xref linkend="cidr-inet-functions-table">に、<type>inet</type>型および<type>cidr</type>型で使用可能な関数を示します。
関数<function>abbrev</function>、<function>host</function>、および<function>text</function>、は主として、代替の整形表示を提供する目的のものです。
  </para>

    <table id="cidr-inet-functions-table">
<!--
     <title><type>cidr</type> and <type>inet</type> Functions</title>
-->
     <title><type>cidr</type>および<type>inet</type>型関数</title>
     <tgroup cols="5">
      <thead>
       <row>
<!--
        <entry>Function</entry>
        <entry>Return Type</entry>
        <entry>Description</entry>
        <entry>Example</entry>
        <entry>Result</entry>
-->
        <entry>関数</entry>
        <entry>戻り値</entry>
        <entry>説明</entry>
        <entry>例</entry>
        <entry>結果</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>
         <indexterm>
          <primary>abbrev</primary>
         </indexterm>
         <literal><function>abbrev(<type>inet</type>)</function></literal>
        </entry>
        <entry><type>text</type></entry>
<!--
        <entry>abbreviated display format as text</entry>
-->
        <entry>表示用テキスト省略形</entry>
        <entry><literal>abbrev(inet '10.1.0.0/16')</literal></entry>
        <entry><literal>10.1.0.0/16</literal></entry>
       </row>
       <row>
        <entry><literal><function>abbrev(<type>cidr</type>)</function></literal></entry>
        <entry><type>text</type></entry>
<!--
        <entry>abbreviated display format as text</entry>
-->
        <entry>表示用テキスト省略形</entry>
        <entry><literal>abbrev(cidr '10.1.0.0/16')</literal></entry>
        <entry><literal>10.1/16</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>broadcast</primary>
         </indexterm>
         <literal><function>broadcast(<type>inet</type>)</function></literal>
        </entry>
        <entry><type>inet</type></entry>
<!--
        <entry>broadcast address for network</entry>
-->
        <entry>ネットワークブロードキャストアドレス</entry>
        <entry><literal>broadcast('192.168.1.5/24')</literal></entry>
        <entry><literal>192.168.1.255/24</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>family</primary>
         </indexterm>
         <literal><function>family(<type>inet</type>)</function></literal>
        </entry>
        <entry><type>int</type></entry>
<!--
        <entry>extract family of address; <literal>4</literal> for IPv4,
         <literal>6</literal> for IPv6</entry>
-->
         <entry>アドレスファミリの取り出し。IPv4では<literal>4</literal>、IPv6では<literal>6</literal>。</entry>
        <entry><literal>family('::1')</literal></entry>
        <entry><literal>6</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>host</primary>
         </indexterm>
         <literal><function>host(<type>inet</type>)</function></literal>
        </entry>
        <entry><type>text</type></entry>
<!--
        <entry>extract IP address as text</entry>
-->
        <entry>IPアドレスをテキストで抽出</entry>
        <entry><literal>host('192.168.1.5/24')</literal></entry>
        <entry><literal>192.168.1.5</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>hostmask</primary>
         </indexterm>
         <literal><function>hostmask(<type>inet</type>)</function></literal>
        </entry>
        <entry><type>inet</type></entry>
<!--
        <entry>construct host mask for network</entry>
-->
        <entry>ネットワーク用のホストマスクの構築</entry>
        <entry><literal>hostmask('192.168.23.20/30')</literal></entry>
        <entry><literal>0.0.0.3</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>masklen</primary>
         </indexterm>
         <literal><function>masklen(<type>inet</type>)</function></literal>
        </entry>
        <entry><type>int</type></entry>
<!--
        <entry>extract netmask length</entry>
-->
        <entry>ネットマスク長の抽出</entry>
        <entry><literal>masklen('192.168.1.5/24')</literal></entry>
        <entry><literal>24</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>netmask</primary>
         </indexterm>
         <literal><function>netmask(<type>inet</type>)</function></literal>
        </entry>
        <entry><type>inet</type></entry>
<!--
        <entry>construct netmask for network</entry>
-->
        <entry>ネットワーク用ネットマスクの構築</entry>
        <entry><literal>netmask('192.168.1.5/24')</literal></entry>
        <entry><literal>255.255.255.0</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>network</primary>
         </indexterm>
         <literal><function>network(<type>inet</type>)</function></literal>
        </entry>
        <entry><type>cidr</type></entry>
<!--
        <entry>extract network part of address</entry>
-->
        <entry>ネットワークアドレスからネットワーク部を抽出</entry>
        <entry><literal>network('192.168.1.5/24')</literal></entry>
        <entry><literal>192.168.1.0/24</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>set_masklen</primary>
         </indexterm>
         <literal><function>set_masklen(<type>inet</type>, <type>int</type>)</function></literal>
        </entry>
        <entry><type>inet</type></entry>
<!--
        <entry>set netmask length for <type>inet</type> value</entry>
-->
        <entry><type>inet</type>値のネットマスク長を設定</entry>
        <entry><literal>set_masklen('192.168.1.5/24', 16)</literal></entry>
        <entry><literal>192.168.1.5/16</literal></entry>
       </row>
       <row>
        <entry><literal><function>set_masklen(<type>cidr</type>, <type>int</type>)</function></literal></entry>
        <entry><type>cidr</type></entry>
<!--
        <entry>set netmask length for <type>cidr</type> value</entry>
-->
        <entry><type>cidr</type>値のネットマスク長を設定</entry>
        <entry><literal>set_masklen('192.168.1.0/24'::cidr, 16)</literal></entry>
        <entry><literal>192.168.0.0/16</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>text</primary>
         </indexterm>
         <literal><function>text(<type>inet</type>)</function></literal>
        </entry>
        <entry><type>text</type></entry>
<!--
        <entry>extract IP address and netmask length as text</entry>
-->
        <entry>IPアドレスとネットマスク長をテキストで抽出</entry>
        <entry><literal>text(inet '192.168.1.5')</literal></entry>
        <entry><literal>192.168.1.5/32</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

  <para>
<!--
   Any <type>cidr</> value can be cast to <type>inet</> implicitly
   or explicitly; therefore, the functions shown above as operating on
   <type>inet</> also work on <type>cidr</> values.  (Where there are
   separate functions for <type>inet</> and <type>cidr</>, it is because
   the behavior should be different for the two cases.)
   Also, it is permitted to cast an <type>inet</> value to <type>cidr</>.
   When this is done, any bits to the right of the netmask are silently zeroed
   to create a valid <type>cidr</> value.
   In addition,
   you can cast a text value to <type>inet</> or <type>cidr</>
   using normal casting syntax: for example,
   <literal>inet(<replaceable>expression</>)</literal> or
   <literal><replaceable>colname</>::cidr</literal>.
-->
<type>cidr</>値はすべて、暗黙的または明示的に<type>inet</>型にキャスト可能です。
したがって、上で示した<type>inet</>に対する操作を行う関数は<type>cidr</>値でも動作します。
（<type>inet</>と<type>cidr</>で別々に関数が存在しますが、それは、この2つで動作に違いがあるためです。）
また、<type>inet</>値から<type>cidr</>へのキャストも許されます。これが行われると、ネットマスクの右側のビットは、<type>cidr</>として有効な値とするために0となります。
さらに、通常のキャスト構文、例えば、<literal>inet(<replaceable>expression</>)</literal>や<literal><replaceable>colname</>::cidr</literal>を使用して、テキスト値を<type>inet</>や<type>cidr</>にキャストすることもできます。
  </para>

  <para>
<!--
   <xref linkend="macaddr-functions-table"> shows the functions
   available for use with the <type>macaddr</type> type.  The function
   <literal><function>trunc(<type>macaddr</type>)</function></literal> returns a MAC
   address with the last 3 bytes set to zero.  This can be used to
   associate the remaining prefix with a manufacturer.
-->
<xref linkend="macaddr-functions-table">に、<type>macaddr</type>型で使用可能な関数を示します。
関数<literal><function>trunc(<type>macaddr</type>)</function></literal>は終わりの3バイトがゼロに設定されたMACアドレスを返します。
これは、残った接頭部を製造者に対応させることに使えます。
  </para>

    <table id="macaddr-functions-table">
<!--
     <title><type>macaddr</type> Functions</title>
-->
     <title><type>macaddr</type>型関数</title>
     <tgroup cols="5">
      <thead>
       <row>
<!--
        <entry>Function</entry>
        <entry>Return Type</entry>
        <entry>Description</entry>
        <entry>Example</entry>
        <entry>Result</entry>
-->
        <entry>関数</entry>
        <entry>戻り値</entry>
        <entry>説明</entry>
        <entry>例</entry>
        <entry>結果</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>
         <indexterm>
          <primary>trunc</primary>
         </indexterm>
         <literal><function>trunc(<type>macaddr</type>)</function></literal>
        </entry>
        <entry><type>macaddr</type></entry>
<!--
        <entry>set last 3 bytes to zero</entry>
-->
        <entry>終わりの３バイトをゼロに設定</entry>
        <entry><literal>trunc(macaddr '12:34:56:78:90:ab')</literal></entry>
        <entry><literal>12:34:56:00:00:00</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
<!--
    The <type>macaddr</type> type also supports the standard relational
    operators (<literal>&gt;</literal>, <literal>&lt;=</literal>, etc.) for
    lexicographical ordering, and the bitwise arithmetic operators
    (<literal>~</literal>, <literal>&amp;</literal> and <literal>|</literal>)
    for NOT, AND and OR.
-->
<type>macaddr</type>型は（<literal>&gt;</literal>、<literal>&lt;=</literal>等の）辞書編集順に並べる標準関係演算子とNOT、AND、ORのビット演算子(<literal>~</literal>、<literal>&amp;</literal>、<literal>|</literal>)もサポートしています。
   </para>

  </sect1>


 <sect1 id="functions-textsearch">
<!--
  <title>Text Search Functions and Operators</title>
-->
  <title>テキスト検索関数と演算子</title>

   <indexterm zone="datatype-textsearch">
<!--
    <primary>full text search</primary>
    <secondary>functions and operators</secondary>
-->
    <primary>全文テキスト検索</primary>
    <secondary>関数と演算子</secondary>
   </indexterm>

   <indexterm zone="datatype-textsearch">
<!--
    <primary>text search</primary>
    <secondary>functions and operators</secondary>
-->
    <primary>テキスト検索</primary>
    <secondary>関数と演算子</secondary>
   </indexterm>

  <para>
<!--
   <xref linkend="textsearch-operators-table">,
   <xref linkend="textsearch-functions-table"> and
   <xref linkend="textsearch-functions-debug-table">
   summarize the functions and operators that are provided
   for full text searching.  See <xref linkend="textsearch"> for a detailed
   explanation of <productname>PostgreSQL</productname>'s text search
   facility.
-->
   <xref linkend="textsearch-operators-table">、
   <xref linkend="textsearch-functions-table">および 
   <xref linkend="textsearch-functions-debug-table">は全文検索用に提供されている関数と演算子を要約しています。<productname>PostgreSQL</productname>のテキスト検索機能の詳細は<xref linkend="textsearch">を参照してください。
  </para>

    <table id="textsearch-operators-table">
<!--
     <title>Text Search Operators</title>
-->
     <title>テキスト検索演算子</title>
     <tgroup cols="4">
      <thead>
       <row>
<!--
        <entry>Operator</entry>
        <entry>Description</entry>
        <entry>Example</entry>
        <entry>Result</entry>
-->
        <entry>演算子</entry>
        <entry>説明</entry>
        <entry>例</entry>
        <entry>結果</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry> <literal>@@</literal> </entry>
<!--
        <entry><type>tsvector</> matches <type>tsquery</> ?</entry>
-->
        <entry><type>tsvector</>が<type>tsquery</>に一致するか？</entry>
        <entry><literal>to_tsvector('fat cats ate rats') @@ to_tsquery('cat &amp; rat')</literal></entry>
        <entry><literal>t</literal></entry>
       </row>
       <row>
        <entry> <literal>@@@</literal> </entry>
<!--
        <entry>deprecated synonym for <literal>@@</></entry>
-->
        <entry><literal>@@</>に対する廃止予定の同義語</entry>
        <entry><literal>to_tsvector('fat cats ate rats') @@@ to_tsquery('cat &amp; rat')</literal></entry>
        <entry><literal>t</literal></entry>
       </row>
       <row>
        <entry> <literal>||</literal> </entry>
<!--
        <entry>concatenate <type>tsvector</>s</entry>
-->
        <entry><type>tsvector</>（複数）を連結</entry>
        <entry><literal>'a:1 b:2'::tsvector || 'c:1 d:2 b:3'::tsvector</literal></entry>
        <entry><literal>'a':1 'b':2,5 'c':3 'd':4</literal></entry>
       </row>
       <row>
        <entry> <literal>&amp;&amp;</literal> </entry>
<!--
        <entry>AND <type>tsquery</>s together</entry>
-->
        <entry><type>tsquery</>（複数）をともに積</entry>
        <entry><literal>'fat | rat'::tsquery &amp;&amp; 'cat'::tsquery</literal></entry>
        <entry><literal>( 'fat' | 'rat' ) &amp; 'cat'</literal></entry>
       </row>
       <row>
        <entry> <literal>||</literal> </entry>
<!--
        <entry>OR <type>tsquery</>s together</entry>
-->
        <entry><type>tsquery</>（複数）をともに和</entry>
        <entry><literal>'fat | rat'::tsquery || 'cat'::tsquery</literal></entry>
        <entry><literal>( 'fat' | 'rat' ) | 'cat'</literal></entry>
       </row>
       <row>
        <entry> <literal>!!</literal> </entry>
<!--
        <entry>negate a <type>tsquery</></entry>
-->
        <entry><type>tsquery</>を否定</entry>
        <entry><literal>!! 'cat'::tsquery</literal></entry>
        <entry><literal>!'cat'</literal></entry>
       </row>
       <row>
        <entry> <literal>@&gt;</literal> </entry>
<!--
        <entry><type>tsquery</> contains another ?</entry>
-->
        <entry><type>tsquery</>は他を包含するか？</entry>
        <entry><literal>'cat'::tsquery @&gt; 'cat &amp; rat'::tsquery</literal></entry>
        <entry><literal>f</literal></entry>
       </row>
       <row>
        <entry> <literal>&lt;@</literal> </entry>
<!--
        <entry><type>tsquery</> is contained in ?</entry>
-->
        <entry><type>tsquery</>は包含されるか？</entry>
        <entry><literal>'cat'::tsquery &lt;@ 'cat &amp; rat'::tsquery</literal></entry>
        <entry><literal>t</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

    <note>
     <para>
<!--
      The <type>tsquery</> containment operators consider only the lexemes
      listed in the two queries, ignoring the combining operators.
-->
<type>tsquery</>格納演算子は結合された演算子を無視し、２つの問い合わせでリストされた語彙素のみを対象とします。
     </para>
    </note>

    <para>
<!--
     In addition to the operators shown in the table, the ordinary B-tree
     comparison operators (<literal>=</>, <literal>&lt;</>, etc) are defined
     for types <type>tsvector</> and <type>tsquery</>.  These are not very
     useful for text searching but allow, for example, unique indexes to be
     built on columns of these types.
-->
表に示された演算子に加え、通常のB-tree比較演算子（<literal>=</>、<literal>&lt;</>など）が、型<type>tsvector</>および<type>tsquery</>に対して定義されます。
これらはテキスト検索に対してそれほど有用ではありませんが、例えばこれらの型の列に一意インデックスを作成することを許可します。
    </para>

    <table id="textsearch-functions-table">
<!--
     <title>Text Search Functions</title>
-->
     <title>テキスト検索関数</title>
     <tgroup cols="5">
      <thead>
       <row>
<!--
        <entry>Function</entry>
        <entry>Return Type</entry>
        <entry>Description</entry>
        <entry>Example</entry>
        <entry>Result</entry>
-->
        <entry>関数</entry>
        <entry>戻り値型</entry>
        <entry>説明</entry>
        <entry>例</entry>
        <entry>結果</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>
         <indexterm>
          <primary>get_current_ts_config</primary>
         </indexterm>
         <literal><function>get_current_ts_config()</function></literal>
        </entry>
        <entry><type>regconfig</type></entry>
<!--
        <entry>get default text search configuration</entry>
-->
        <entry>
         デフォルトの全文検索設定の取得
        </entry>
        <entry><literal>get_current_ts_config()</literal></entry>
        <entry><literal>english</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>length</primary>
         </indexterm>
         <literal><function>length(<type>tsvector</>)</function></literal>
        </entry>
        <entry><type>integer</type></entry>
<!--
        <entry>number of lexemes in <type>tsvector</></entry>
-->
        <entry><type>tsvector</>にある語彙素の数</entry>
        <entry><literal>length('fat:2,4 cat:3 rat:5A'::tsvector)</literal></entry>
        <entry><literal>3</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>numnode</primary>
         </indexterm>
         <literal><function>numnode(<type>tsquery</>)</function></literal>
        </entry>
        <entry><type>integer</type></entry>
<!--
        <entry>number of lexemes plus operators in <type>tsquery</></entry>
-->
        <entry>
         <type>tsquery</>にある語彙素の数と演算子の数
        </entry>
        <entry><literal> numnode('(fat &amp; rat) | cat'::tsquery)</literal></entry>
        <entry><literal>5</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>plainto_tsquery</primary>
         </indexterm>
         <literal><function>plainto_tsquery(<optional> <replaceable class="PARAMETER">config</> <type>regconfig</> , </optional> <replaceable class="PARAMETER">query</> <type>text</type>)</function></literal>
        </entry>
        <entry><type>tsquery</type></entry>
<!--
        <entry>produce <type>tsquery</> ignoring punctuation</entry>
-->
        <entry>句読点を無視して、<type>tsquery</>を作成</entry>
        <entry><literal>plainto_tsquery('english', 'The Fat Rats')</literal></entry>
        <entry><literal>'fat' &amp; 'rat'</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>querytree</primary>
         </indexterm>
         <literal><function>querytree(<replaceable class="PARAMETER">query</replaceable> <type>tsquery</>)</function></literal>
        </entry>
        <entry><type>text</type></entry>
<!--
        <entry>get indexable part of a <type>tsquery</></entry>
-->
        <entry><type>tsquery</>のインデックス付け可能部分の取得</entry>
        <entry><literal>querytree('foo &amp; ! bar'::tsquery)</literal></entry>
        <entry><literal>'foo'</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>setweight</primary>
         </indexterm>
         <literal><function>setweight(<type>tsvector</>, <type>"char"</>)</function></literal>
        </entry>
        <entry><type>tsvector</type></entry>
<!--
        <entry>assign weight to each element of <type>tsvector</></entry>
-->
        <entry><type>tsvector</>のそれぞれの要素に重みを割り当て</entry>
        <entry><literal>setweight('fat:2,4 cat:3 rat:5B'::tsvector, 'A')</literal></entry>
        <entry><literal>'cat':3A 'fat':2A,4A 'rat':5A</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>strip</primary>
         </indexterm>
         <literal><function>strip(<type>tsvector</>)</function></literal>
        </entry>
        <entry><type>tsvector</type></entry>
<!--
        <entry>remove positions and weights from <type>tsvector</></entry>
-->
        <entry><type>tsvector</>から位置と重みを削除</entry>
        <entry><literal>strip('fat:2,4 cat:3 rat:5A'::tsvector)</literal></entry>
        <entry><literal>'cat' 'fat' 'rat'</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>to_tsquery</primary>
         </indexterm>
         <literal><function>to_tsquery(<optional> <replaceable class="PARAMETER">config</> <type>regconfig</> , </optional> <replaceable class="PARAMETER">query</> <type>text</type>)</function></literal>
        </entry>
        <entry><type>tsquery</type></entry>
<!--
        <entry>normalize words and convert to <type>tsquery</></entry>
-->
        <entry>単語（複数）を正規化し<type>tsquery</>に変換</entry>
        <entry><literal>to_tsquery('english', 'The &amp; Fat &amp; Rats')</literal></entry>
        <entry><literal>'fat' &amp; 'rat'</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>to_tsvector</primary>
         </indexterm>
         <literal><function>to_tsvector(<optional> <replaceable class="PARAMETER">config</> <type>regconfig</> , </optional> <replaceable class="PARAMETER">document</> <type>text</type>)</function></literal>
        </entry>
        <entry><type>tsvector</type></entry>
<!--
        <entry>reduce document text to <type>tsvector</></entry>
-->
        <entry>ドキュメントテキストを<type>tsvector</>に縮小</entry>
        <entry><literal>to_tsvector('english', 'The Fat Rats')</literal></entry>
        <entry><literal>'fat':2 'rat':3</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>ts_headline</primary>
         </indexterm>
         <literal><function>ts_headline(<optional> <replaceable class="PARAMETER">config</replaceable> <type>regconfig</>, </optional> <replaceable class="PARAMETER">document</replaceable> <type>text</>, <replaceable class="PARAMETER">query</replaceable> <type>tsquery</> <optional>, <replaceable class="PARAMETER">options</replaceable> <type>text</> </optional>)</function></literal>
        </entry>
        <entry><type>text</type></entry>
<!--
        <entry>display a query match</entry>
-->
        <entry>問い合わせによるマッチを表示</entry>
        <entry><literal>ts_headline('x y z', 'z'::tsquery)</literal></entry>
        <entry><literal>x y &lt;b&gt;z&lt;/b&gt;</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>ts_rank</primary>
         </indexterm>
         <literal><function>ts_rank(<optional> <replaceable class="PARAMETER">weights</replaceable> <type>float4[]</>, </optional> <replaceable class="PARAMETER">vector</replaceable> <type>tsvector</>, <replaceable class="PARAMETER">query</replaceable> <type>tsquery</> <optional>, <replaceable class="PARAMETER">normalization</replaceable> <type>integer</> </optional>)</function></literal>
        </entry>
        <entry><type>float4</type></entry>
<!--
        <entry>rank document for query</entry>
-->
        <entry>問い合わせのためのドキュメント順位付け</entry>
        <entry><literal>ts_rank(textsearch, query)</literal></entry>
        <entry><literal>0.818</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>ts_rank_cd</primary>
         </indexterm>
         <literal><function>ts_rank_cd(<optional> <replaceable class="PARAMETER">weights</replaceable> <type>float4[]</>, </optional> <replaceable class="PARAMETER">vector</replaceable> <type>tsvector</>, <replaceable class="PARAMETER">query</replaceable> <type>tsquery</> <optional>, <replaceable class="PARAMETER">normalization</replaceable> <type>integer</> </optional>)</function></literal>
        </entry>
        <entry><type>float4</type></entry>
<!--
        <entry>rank document for query using cover density</entry>
-->
        <entry>被覆密度を用いた問い合わせのためのドキュメント順位付け</entry>
        <entry><literal>ts_rank_cd('{0.1, 0.2, 0.4, 1.0}', textsearch, query)</literal></entry>
        <entry><literal>2.01317</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>ts_rewrite</primary>
         </indexterm>
         <literal><function>ts_rewrite(<replaceable class="PARAMETER">query</replaceable> <type>tsquery</>, <replaceable class="PARAMETER">target</replaceable> <type>tsquery</>, <replaceable class="PARAMETER">substitute</replaceable> <type>tsquery</>)</function></literal>
        </entry>
        <entry><type>tsquery</type></entry>
<!--
        <entry>replace target with substitute within query</entry>
-->
        <entry>問い合わせ内で対象を代替と置換</entry>
        <entry><literal>ts_rewrite('a &amp; b'::tsquery, 'a'::tsquery, 'foo|bar'::tsquery)</literal></entry>
        <entry><literal>'b' &amp; ( 'foo' | 'bar' )</literal></entry>
       </row>
       <row>
        <entry><literal><function>ts_rewrite(<replaceable class="PARAMETER">query</replaceable> <type>tsquery</>, <replaceable class="PARAMETER">select</replaceable> <type>text</>)</function></literal></entry>
        <entry><type>tsquery</type></entry>
<!--
        <entry>replace using targets and substitutes from a <command>SELECT</> command</entry>
-->
        <entry><command>SELECT</>から対象と代替を使用して置換</entry>
        <entry><literal>SELECT ts_rewrite('a &amp; b'::tsquery, 'SELECT t,s FROM aliases')</literal></entry>
        <entry><literal>'b' &amp; ( 'foo' | 'bar' )</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>tsvector_update_trigger</primary>
         </indexterm>
         <literal><function>tsvector_update_trigger()</function></literal>
        </entry>
        <entry><type>trigger</type></entry>
<!--
        <entry>trigger function for automatic <type>tsvector</> column update</entry>
-->
        <entry><type>tsvector</>列自動更新のため関数をトリガ</entry>
        <entry><literal>CREATE TRIGGER ... tsvector_update_trigger(tsvcol, 'pg_catalog.swedish', title, body)</literal></entry>
        <entry><literal></literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>tsvector_update_trigger_column</primary>
         </indexterm>
         <literal><function>tsvector_update_trigger_column()</function></literal>
        </entry>
        <entry><type>trigger</type></entry>
<!--
        <entry>trigger function for automatic <type>tsvector</> column update</entry>
-->
        <entry><type>tsvector</>列自動更新のため関数をトリガ</entry>
        <entry><literal>CREATE TRIGGER ... tsvector_update_trigger_column(tsvcol, configcol, title, body)</literal></entry>
        <entry><literal></literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

  <note>
   <para>
<!--
    All the text search functions that accept an optional <type>regconfig</>
    argument will use the configuration specified by
    <xref linkend="guc-default-text-search-config">
    when that argument is omitted.
-->
オプションの<type>regconfig</>引数を受け付ける全てのテキスト検索関数は、その引数が省略された場合<xref linkend="guc-default-text-search-config">で指定された構成を使用します。
   </para>
  </note>

  <para>
<!--
   The functions in
   <xref linkend="textsearch-functions-debug-table">
   are listed separately because they are not usually used in everyday text
   searching operations.  They are helpful for development and debugging
   of new text search configurations.
-->
   <xref linkend="textsearch-functions-debug-table">の関数は、日常のテキスト検索操作では通常使用されないので、別途リストされます。
  </para>

    <table id="textsearch-functions-debug-table">
<!--
     <title>Text Search Debugging Functions</title>
-->
     <title>テキスト検索デバッグ関数</title>
     <tgroup cols="5">
      <thead>
       <row>
<!--
        <entry>Function</entry>
        <entry>Return Type</entry>
        <entry>Description</entry>
        <entry>Example</entry>
        <entry>Result</entry>
-->
        <entry>関数</entry>
        <entry>戻り値型</entry>
        <entry>説明</entry>
        <entry>例</entry>
        <entry>結果</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>
         <indexterm>
          <primary>ts_debug</primary>
         </indexterm>
         <literal><function>ts_debug(<optional> <replaceable class="PARAMETER">config</replaceable> <type>regconfig</>, </optional> <replaceable class="PARAMETER">document</replaceable> <type>text</>, OUT <replaceable class="PARAMETER">alias</> <type>text</>, OUT <replaceable class="PARAMETER">description</> <type>text</>, OUT <replaceable class="PARAMETER">token</> <type>text</>, OUT <replaceable class="PARAMETER">dictionaries</> <type>regdictionary[]</>, OUT <replaceable class="PARAMETER">dictionary</> <type>regdictionary</>, OUT <replaceable class="PARAMETER">lexemes</> <type>text[]</>)</function></literal>
        </entry>
        <entry><type>setof record</type></entry>
<!--
        <entry>test a configuration</entry>
-->
        <entry>構成を検査</entry>
        <entry><literal>ts_debug('english', 'The Brightest supernovaes')</literal></entry>
        <entry><literal>(asciiword,"Word, all ASCII",The,{english_stem},english_stem,{}) ...</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>ts_lexize</primary>
         </indexterm>
         <literal><function>ts_lexize(<replaceable class="PARAMETER">dict</replaceable> <type>regdictionary</>, <replaceable class="PARAMETER">token</replaceable> <type>text</>)</function></literal>
        </entry>
        <entry><type>text[]</type></entry>
<!--
        <entry>test a dictionary</entry>
-->
        <entry>辞書を検査</entry>
        <entry><literal>ts_lexize('english_stem', 'stars')</literal></entry>
        <entry><literal>{star}</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>ts_parse</primary>
         </indexterm>
         <literal><function>ts_parse(<replaceable class="PARAMETER">parser_name</replaceable> <type>text</>, <replaceable class="PARAMETER">document</replaceable> <type>text</>, OUT <replaceable class="PARAMETER">tokid</> <type>integer</>, OUT <replaceable class="PARAMETER">token</> <type>text</>)</function></literal>
        </entry>
        <entry><type>setof record</type></entry>
<!--
        <entry>test a parser</entry>
-->
        <entry>パーサを検査</entry>
        <entry><literal>ts_parse('default', 'foo - bar')</literal></entry>
        <entry><literal>(1,foo) ...</literal></entry>
       </row>
       <row>
        <entry><literal><function>ts_parse(<replaceable class="PARAMETER">parser_oid</replaceable> <type>oid</>, <replaceable class="PARAMETER">document</replaceable> <type>text</>, OUT <replaceable class="PARAMETER">tokid</> <type>integer</>, OUT <replaceable class="PARAMETER">token</> <type>text</>)</function></literal></entry>
        <entry><type>setof record</type></entry>
<!--
        <entry>test a parser</entry>
-->
        <entry>パーサを検査</entry>
        <entry><literal>ts_parse(3722, 'foo - bar')</literal></entry>
        <entry><literal>(1,foo) ...</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>ts_token_type</primary>
         </indexterm>
         <literal><function>ts_token_type(<replaceable class="PARAMETER">parser_name</> <type>text</>, OUT <replaceable class="PARAMETER">tokid</> <type>integer</>, OUT <replaceable class="PARAMETER">alias</> <type>text</>, OUT <replaceable class="PARAMETER">description</> <type>text</>)</function></literal>
        </entry>
        <entry><type>setof record</type></entry>
<!--
        <entry>get token types defined by parser</entry>
-->
    <entry>パーサで定義されたトークンの型を入手</entry>
        <entry><literal>ts_token_type('default')</literal></entry>
        <entry><literal>(1,asciiword,"Word, all ASCII") ...</literal></entry>
       </row>
       <row>
        <entry><literal><function>ts_token_type(<replaceable class="PARAMETER">parser_oid</> <type>oid</>, OUT <replaceable class="PARAMETER">tokid</> <type>integer</>, OUT <replaceable class="PARAMETER">alias</> <type>text</>, OUT <replaceable class="PARAMETER">description</> <type>text</>)</function></literal></entry>
        <entry><type>setof record</type></entry>
<!--
        <entry>get token types defined by parser</entry>
-->
        <entry>パーサで定義されたトークンの型を入手</entry>
        <entry><literal>ts_token_type(3722)</literal></entry>
        <entry><literal>(1,asciiword,"Word, all ASCII") ...</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>ts_stat</primary>
         </indexterm>
         <literal><function>ts_stat(<replaceable class="PARAMETER">sqlquery</replaceable> <type>text</>, <optional> <replaceable class="PARAMETER">weights</replaceable> <type>text</>, </optional> OUT <replaceable class="PARAMETER">word</replaceable> <type>text</>, OUT <replaceable class="PARAMETER">ndoc</replaceable> <type>integer</>, OUT <replaceable class="PARAMETER">nentry</replaceable> <type>integer</>)</function></literal>
        </entry>
        <entry><type>setof record</type></entry>
<!--
        <entry>get statistics of a <type>tsvector</> column</entry>
-->
        <entry><type>tsvector</>列の統計情報を入手</entry>
        <entry><literal>ts_stat('SELECT vector from apod')</literal></entry>
        <entry><literal>(foo,10,15) ...</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

 </sect1>


 <sect1 id="functions-xml">
<!--
  <title>XML Functions</title>
-->
  <title>XML関数</title>

  <para>
<!--
   The functions and function-like expressions described in this
   section operate on values of type <type>xml</type>.  Check <xref
   linkend="datatype-xml"> for information about the <type>xml</type>
   type.  The function-like expressions <function>xmlparse</function>
   and <function>xmlserialize</function> for converting to and from
   type <type>xml</type> are not repeated here.  Use of most of these
   functions requires the installation to have been built
   with <command>configure &#045;-with-libxml</>.
-->
この節で説明される関数および擬似関数式は、<type>xml</type>型の値に対して機能します。
<type>xml</type>型についての情報は<xref linkend="datatype-xml">を点検してください。
<type>xml</type>型のやりとりを変換する<function>xmlparse</function>および<function>xmlserialize</function>擬似関数式はここでは繰り返しません。
これらの多くの関数を使用するには、インストレーションの際<command>configure --with-libxml</>付きでビルドされていることが必要です。
  </para>

  <sect2 id="functions-producing-xml">
<!--
   <title>Producing XML Content</title>
-->
   <title>XML内容の生成</title>

   <para>
<!--
    A set of functions and function-like expressions are available for
    producing XML content from SQL data.  As such, they are
    particularly suitable for formatting query results into XML
    documents for processing in client applications.
-->
SQLデータからXML内容を生成するために関数と擬似関数式の一式が提供されています。
そのようなものとして、クライアントアプリケーションが問い合わせ結果を処理のためXML文書に書式化するのにこれらは特に適しています。
   </para>

   <sect3>
    <title><literal>xmlcomment</literal></title>

    <indexterm>
     <primary>xmlcomment</primary>
    </indexterm>

<synopsis>
<function>xmlcomment</function>(<replaceable>text</replaceable>)
</synopsis>

    <para>
<!--
     The function <function>xmlcomment</function> creates an XML value
     containing an XML comment with the specified text as content.
     The text cannot contain <quote><literal>&#045;-</literal></quote> or end with a
     <quote><literal>-</literal></quote> so that the resulting construct is a valid
     XML comment.  If the argument is null, the result is null.
-->
関数<function>xmlcomment</function>は特定のテキストを内容としてXMLコメントを含んだXML値を作成します。
テキストには結果として構築されるXMLコメントが有効になるよう<quote><literal>--</literal></quote>または<quote><literal>-</literal></quote>で終結する内容を含んではなりません。引数がNULLならば結果もNULLになります。
    </para>

    <para>
<!--
     Example:
-->
例：
<screen><![CDATA[
SELECT xmlcomment('hello');

  xmlcomment
--------------
 <!--hello-->
]]></screen>
    </para>
   </sect3>

   <sect3>
    <title><literal>xmlconcat</literal></title>

    <indexterm>
     <primary>xmlconcat</primary>
    </indexterm>

<synopsis>
<function>xmlconcat</function>(<replaceable>xml</replaceable><optional>, ...</optional>)
</synopsis>

    <para>
<!--
     The function <function>xmlconcat</function> concatenates a list
     of individual XML values to create a single value containing an
     XML content fragment.  Null values are omitted; the result is
     only null if there are no nonnull arguments.
-->
関数<function>xmlconcat</function>は、XMLの内容断片を含む単一値を作成するために個別のXML値のリストを結合します。
NULL値は削除され、NULL以外の引数が存在しないときのみ結果はNULLになります。
    </para>

    <para>
<!--
     Example:
-->
例：
<screen><![CDATA[
SELECT xmlconcat('<abc/>', '<bar>foo</bar>');

      xmlconcat
----------------------
 <abc/><bar>foo</bar>
]]></screen>
    </para>

    <para>
<!--
     XML declarations, if present, are combined as follows.  If all
     argument values have the same XML version declaration, that
     version is used in the result, else no version is used.  If all
     argument values have the standalone declaration value
     <quote>yes</quote>, then that value is used in the result.  If
     all argument values have a standalone declaration value and at
     least one is <quote>no</quote>, then that is used in the result.
     Else the result will have no standalone declaration.  If the
     result is determined to require a standalone declaration but no
     version declaration, a version declaration with version 1.0 will
     be used because XML requires an XML declaration to contain a
     version declaration.  Encoding declarations are ignored and
     removed in all cases.
-->
XML宣言が提示されている場合は次のように組み合わせることができます。
全ての引数の値が同一のXMLversion宣言を持っていれば、そのversionが結果に使用されます。さもなければversionは使用されません。
もし全ての引数の値がstandalone宣言値である<quote>yes</quote>であれば、その値が結果に使用されます。
もし全ての引数の値がstandalone宣言値であり、その中で１つでも<quote>no</quote>がある場合、それが結果に使用されます。
さもなければ、結果はstandalone宣言を持ちません。
もし結果がstandalone宣言を必要としていても、standalone宣言がない場合には、XMLはversion宣言を含むXML宣言を要求するため、version 1.0のversion宣言が使用されます。
encoding宣言は無視され、全ての場合で削除されます。
    </para>

    <para>
<!--
     Example:
-->
例：
<screen><![CDATA[
SELECT xmlconcat('<?xml version="1.1"?><foo/>', '<?xml version="1.1" standalone="no"?><bar/>');

             xmlconcat
-----------------------------------
 <?xml version="1.1"?><foo/><bar/>
]]></screen>
    </para>
   </sect3>

   <sect3>
    <title><literal>xmlelement</literal></title>

   <indexterm>
    <primary>xmlelement</primary>
   </indexterm>

<synopsis>
<function>xmlelement</function>(name <replaceable>name</replaceable> <optional>, xmlattributes(<replaceable>value</replaceable> <optional>AS <replaceable>attname</replaceable></optional> <optional>, ... </optional>)</optional> <optional><replaceable>, content, ...</replaceable></optional>)
</synopsis>

    <para>
<!--
     The <function>xmlelement</function> expression produces an XML
     element with the given name, attributes, and content.
-->
<function>xmlelement</function>式は与えられた名前、属性、および内容を持つXML要素を生成します。
    </para>

    <para>
<!--
     Examples:
-->
例：
<screen><![CDATA[
SELECT xmlelement(name foo);

 xmlelement
------------
 <foo/>

SELECT xmlelement(name foo, xmlattributes('xyz' as bar));

    xmlelement
------------------
 <foo bar="xyz"/>

SELECT xmlelement(name foo, xmlattributes(current_date as bar), 'cont', 'ent');

             xmlelement
-------------------------------------
 <foo bar="2007-01-26">content</foo>
]]></screen>
    </para>

    <para>
<!--
     Element and attribute names that are not valid XML names are
     escaped by replacing the offending characters by the sequence
     <literal>_x<replaceable>HHHH</replaceable>_</literal>, where
     <replaceable>HHHH</replaceable> is the character's Unicode
     codepoint in hexadecimal notation.  For example:
-->
有効でないXML名の要素と属性名は、シーケンス<literal>_x<replaceable>HHHH</replaceable>_</literal>により障害となる文字を置換することでエスケープされます。ここで、<replaceable>HHHH</replaceable>は16進数によるその文字のUnicode文字コード番号です。
例をあげます。
<screen><![CDATA[
SELECT xmlelement(name "foo$bar", xmlattributes('xyz' as "a&b"));

            xmlelement
----------------------------------
 <foo_x0024_bar a_x0026_b="xyz"/>
]]></screen>
    </para>

    <para>
<!--
     An explicit attribute name need not be specified if the attribute
     value is a column reference, in which case the column's name will
     be used as the attribute name by default.  In other cases, the
     attribute must be given an explicit name.  So this example is
     valid:
-->
属性値が列参照の場合、明示的な属性名を指定する必要はありません。この場合、デフォルトで列名が属性名として使用されます。
その他の場合には、属性は明示的な名前で与えられなければなりません。
従って、以下の例は有効です。
<screen>
CREATE TABLE test (a xml, b xml);
SELECT xmlelement(name test, xmlattributes(a, b)) FROM test;
</screen>
<!--
     But these are not:
-->
しかし、以下の例は有効ではありません。
<screen>
SELECT xmlelement(name test, xmlattributes('constant'), a, b) FROM test;
SELECT xmlelement(name test, xmlattributes(func(a, b))) FROM test;
</screen>
    </para>

    <para>
<!--
     Element content, if specified, will be formatted according to
     its data type.  If the content is itself of type <type>xml</type>,
     complex XML documents can be constructed.  For example:
-->
もし要素内容が指定されればそのデータ型に従って書式化されます。
もし内容そのものが<type>xml</type>型であれば、複合XML文書が構築されます。
例をあげます。
<screen><![CDATA[
SELECT xmlelement(name foo, xmlattributes('xyz' as bar),
                            xmlelement(name abc),
                            xmlcomment('test'),
                            xmlelement(name xyz));

                  xmlelement
----------------------------------------------
 <foo bar="xyz"><abc/><!--test--><xyz/></foo>
]]></screen>

<!--
     Content of other types will be formatted into valid XML character
     data.  This means in particular that the characters &lt;, &gt;,
     and &amp; will be converted to entities.  Binary data (data type
     <type>bytea</type>) will be represented in base64 or hex
     encoding, depending on the setting of the configuration parameter
     <xref linkend="guc-xmlbinary">.  The particular behavior for
     individual data types is expected to evolve in order to align the
     SQL and PostgreSQL data types with the XML Schema specification,
     at which point a more precise description will appear.
-->
そのほかの型の内容は有効なXML文字データにフォーマットされます。
これは特に文字&lt;、&gt;、および&amp;がエンティティに変換されることを意味します。
バイナリデータ（データ型は<type>bytea</type>）は、構成パラメータ<xref linkend="guc-xmlbinary">の設定にしたがって、base64もしくは16進符号化方式で表現されます。
個々のデータ型に対する特定の動作は、XMLスキーマ仕様でのSQLおよびPostgreSQLデータ型に調整するため展開されると期待されます。この時点でより詳細な記述が出現します。
    </para>
   </sect3>

   <sect3>
    <title><literal>xmlforest</literal></title>

   <indexterm>
    <primary>xmlforest</primary>
   </indexterm>

<synopsis>
<function>xmlforest</function>(<replaceable>content</replaceable> <optional>AS <replaceable>name</replaceable></optional> <optional>, ...</optional>)
</synopsis>

    <para>
<!--
     The <function>xmlforest</function> expression produces an XML
     forest (sequence) of elements using the given names and content.
-->
<function>xmlforest</function>式は与えられた名前と内容を使用し、要素のXMLフォレスト（シーケンス）を生成します。
    </para>

    <para>
<!--
     Examples:
-->
例：
<screen><![CDATA[
SELECT xmlforest('abc' AS foo, 123 AS bar);

          xmlforest
------------------------------
 <foo>abc</foo><bar>123</bar>


SELECT xmlforest(table_name, column_name)
FROM information_schema.columns
WHERE table_schema = 'pg_catalog';

                                         xmlforest
-------------------------------------------------------------------------------------------
 <table_name>pg_authid</table_name><column_name>rolname</column_name>
 <table_name>pg_authid</table_name><column_name>rolsuper</column_name>
 ...
]]></screen>

<!--
     As seen in the second example, the element name can be omitted if
     the content value is a column reference, in which case the column
     name is used by default.  Otherwise, a name must be specified.
-->
第２の例に見られるように、内容の値が列参照の場合、要素名は省略可能です。この時は、列名がデフォルトで使用されます。
そうでない時は、名前が指定されなければなりません。
    </para>

    <para>
<!--
     Element names that are not valid XML names are escaped as shown
     for <function>xmlelement</function> above.  Similarly, content
     data is escaped to make valid XML content, unless it is already
     of type <type>xml</type>.
-->
有効なXML名ではない要素名は上の<function>xmlelement</function>で説明した通りエスケープされます。
同様にして、既に<type>xml</type>型であるものを除き、内容データは有効なXML内容になるようにエスケープされます。
    </para>

    <para>
<!--
     Note that XML forests are not valid XML documents if they consist
     of more than one element, so it might be useful to wrap
     <function>xmlforest</function> expressions in
     <function>xmlelement</function>.
-->
XMLフォレストは１より多い要素からなる場合、有効なXML文書ではないことに注意してください。
したがって、<function>xmlelement</function>に<function>xmlforest</function>式をラップすることが有用なことがあります。
    </para>
   </sect3>

   <sect3>
    <title><literal>xmlpi</literal></title>

   <indexterm>
    <primary>xmlpi</primary>
   </indexterm>

<synopsis>
<function>xmlpi</function>(name <replaceable>target</replaceable> <optional>, <replaceable>content</replaceable></optional>)
</synopsis>

    <para>
<!--
     The <function>xmlpi</function> expression creates an XML
     processing instruction.  The content, if present, must not
     contain the character sequence <literal>?&gt;</literal>.
-->
<function>xmlpi</function>式はXML処理命令を作成します。
内容が存在すれば、その内容は<literal>?&gt;</literal>文字シーケンスを含んではなりません。
    </para>

    <para>
<!--
     Example:
-->
例：
<screen><![CDATA[
SELECT xmlpi(name php, 'echo "hello world";');

            xmlpi
-----------------------------
 <?php echo "hello world";?>
]]></screen>
    </para>
   </sect3>

   <sect3>
    <title><literal>xmlroot</literal></title>

   <indexterm>
    <primary>xmlroot</primary>
   </indexterm>

<synopsis>
<function>xmlroot</function>(<replaceable>xml</replaceable>, version <replaceable>text</replaceable> | no value <optional>, standalone yes|no|no value</optional>)
</synopsis>

    <para>
<!--
     The <function>xmlroot</function> expression alters the properties
     of the root node of an XML value.  If a version is specified,
     it replaces the value in the root node's version declaration; if a
     standalone setting is specified, it replaces the value in the
     root node's standalone declaration.
-->
<function>xmlroot</function>式はXML値のルートノードの属性を変更します。
versionが指定されていると、ルートノードのversion宣言での値を変更し、standalone設定が指定されていると、ルートノードのstandalone宣言での値を変更します。
    </para>

    <para>
<screen><![CDATA[
SELECT xmlroot(xmlparse(document '<?xml version="1.1"?><content>abc</content>'),
               version '1.0', standalone yes);

                xmlroot
----------------------------------------
 <?xml version="1.0" standalone="yes"?>
 <content>abc</content>
]]></screen>
    </para>
   </sect3>

   <sect3 id="functions-xml-xmlagg">
    <title><literal>xmlagg</literal></title>

    <indexterm>
     <primary>xmlagg</primary>
    </indexterm>

<synopsis>
<function>xmlagg</function>(<replaceable>xml</replaceable>)
</synopsis>

    <para>
<!--
     The function <function>xmlagg</function> is, unlike the other
     functions described here, an aggregate function.  It concatenates the
     input values to the aggregate function call,
     much like <function>xmlconcat</function> does, except that concatenation
     occurs across rows rather than across expressions in a single row.
     See <xref linkend="functions-aggregate"> for additional information
     about aggregate functions.
-->
ここで説明している関数とは異なり、<function>xmlagg</function>関数は集約関数です。
単一行の要素ではなく、複数行にまたがった連結となりますが、<function>xmlconcat</function>が行うように、入力値を集約関数呼び出しに連結します。
集約関数についての追加情報は<xref linkend="functions-aggregate">を参照してください。
    </para>

    <para>
<!--
     Example:
-->
例：
<screen><![CDATA[
CREATE TABLE test (y int, x xml);
INSERT INTO test VALUES (1, '<foo>abc</foo>');
INSERT INTO test VALUES (2, '<bar/>');
SELECT xmlagg(x) FROM test;
        xmlagg
----------------------
 <foo>abc</foo><bar/>
]]></screen>
    </para>

    <para>
<!--
     To determine the order of the concatenation, an <literal>ORDER BY</>
     clause may be added to the aggregate call as described in
     <xref linkend="syntax-aggregates">. For example:
-->
連結の順序を決定するため、<xref linkend="syntax-aggregates">に記述されているように<literal>ORDER BY</>句を集計呼び出しに追加すると良いでしょう。
以下は例です。

<screen><![CDATA[
SELECT xmlagg(x ORDER BY y DESC) FROM test;
        xmlagg
----------------------
 <bar/><foo>abc</foo>
]]></screen>
    </para>

    <para>
<!--
     The following non-standard approach used to be recommended
     in previous versions, and may still be useful in specific
     cases:
-->
下記は以前のバージョンで推奨されていた、非標準的な方法例です。特定のケースでは有用かもしれません。

<screen><![CDATA[
SELECT xmlagg(x) FROM (SELECT * FROM test ORDER BY y DESC) AS tab;
        xmlagg
----------------------
 <bar/><foo>abc</foo>
]]></screen>
    </para>
   </sect3>
   </sect2>

   <sect2 id="functions-xml-predicates">
<!--
    <title>XML Predicates</title>
-->
    <title>XML述語</title>

    <para>
<!--
     The expressions described in this section check properties
     of <type>xml</type> values.
-->
この節で記述されている式は、<type>xml</type>値の属性をチュックします。
    </para>

   <sect3>
    <title><literal>IS DOCUMENT</literal></title>

    <indexterm>
     <primary>IS DOCUMENT</primary>
    </indexterm>

<synopsis>
<replaceable>xml</replaceable> IS DOCUMENT
</synopsis>

    <para>
<!--
     The expression <literal>IS DOCUMENT</literal> returns true if the
     argument XML value is a proper XML document, false if it is not
     (that is, it is a content fragment), or null if the argument is
     null.  See <xref linkend="datatype-xml"> about the difference
     between documents and content fragments.
-->
式<literal>IS DOCUMENT</literal>は引数XML値が適切なXML文書であれば真を返し、そうでなければ（つまり、内容の断片）偽を返すか、もしくは引数がNULLであればNULLを返します。
文書と内容の断片の差異については<xref linkend="datatype-xml">を参照してください。
    </para>
   </sect3>

   <sect3 id="xml-exists">
    <title><literal>XMLEXISTS</literal></title>

    <indexterm>
     <primary>XMLEXISTS</primary>
    </indexterm>

<synopsis>
<function>XMLEXISTS</function>(<replaceable>text</replaceable> PASSING <optional>BY REF</optional> <replaceable>xml</replaceable> <optional>BY REF</optional>)
</synopsis>

    <para>
<!--
     The function <function>xmlexists</function> returns true if the
     XPath expression in the first argument returns any nodes, and
     false otherwise.  (If either argument is null, the result is
     null.)
-->
関数<function>xmlexists</function>はXPath式の第一引数が何かしらのノードであれば真を返し、そうでなければ偽を返します。
(もしいずれの引数もNULLであった場合はNULLを返します。)
    </para>

    <para>
<!--
     Example:
-->
例:
     <screen><![CDATA[
SELECT xmlexists('//town[text() = ''Toronto'']' PASSING BY REF '<towns><town>Toronto</town><town>Ottawa</town></towns>');

 xmlexists
------------
 t
(1 row)
]]></screen>
    </para>

    <para>
<!--
     The <literal>BY REF</literal> clauses have no effect in
     PostgreSQL, but are allowed for SQL conformance and compatibility
     with other implementations.  Per SQL standard, the
     first <literal>BY REF</literal> is required, the second is
     optional.  Also note that the SQL standard specifies
     the <function>xmlexists</function> construct to take an XQuery
     expression as first argument, but PostgreSQL currently only
     supports XPath, which is a subset of XQuery.
-->
<literal>BY REF</literal>句は、PostgreSQLには何の影響も与えませんが、別製品とのSQL互換性や順応性のため、付与することができます。
SQL標準では最初に<literal>BY REF</literal>を必要としており、2つ目の引数以降はオプショナルです。加えてSQL標準では<function>xmlexists</function>はXQueryを第一引数として取る構成としていますが、
PostgreSQLでは現在XQueryのサブセットにあたるXpathのみサポートしていることに注意してください。
    </para>
   </sect3>

   <sect3 id="xml-is-well-formed">
    <title><literal>xml_is_well_formed</literal></title>

    <indexterm>
     <primary>xml_is_well_formed</primary>
    </indexterm>

    <indexterm>
     <primary>xml_is_well_formed_document</primary>
    </indexterm>

    <indexterm>
     <primary>xml_is_well_formed_content</primary>
    </indexterm>

<synopsis>
<function>xml_is_well_formed</function>(<replaceable>text</replaceable>)
<function>xml_is_well_formed_document</function>(<replaceable>text</replaceable>)
<function>xml_is_well_formed_content</function>(<replaceable>text</replaceable>)
</synopsis>

    <para>
<!--
     These functions check whether a <type>text</> string is well-formed XML,
     returning a Boolean result.
     <function>xml_is_well_formed_document</function> checks for a well-formed
     document, while <function>xml_is_well_formed_content</function> checks
     for well-formed content.  <function>xml_is_well_formed</function> does
     the former if the <xref linkend="guc-xmloption"> configuration
     parameter is set to <literal>DOCUMENT</>, or the latter if it is set to
     <literal>CONTENT</>.  This means that
     <function>xml_is_well_formed</function> is useful for seeing whether
     a simple cast to type <type>xml</> will succeed, whereas the other two
     functions are useful for seeing whether the corresponding variants of
     <function>XMLPARSE</> will succeed.
-->
これらの関数は<type>text</>文字列が整形式かどうかをチェックし、論理値で結果を返します。
<function>xml_is_well_formed_document</function>は文書が整形式かをチェックし、一方<function>xml_is_well_formed_content</function>は内容が整形式かをチェックします。
<function>xml_is_well_formed</function>は、<xref linkend="guc-xmloption">パラメータ値が<literal>DOCUMENT</>に設定されていれば前者を、<literal>CONTENT</>が設定されていれば後者のチェックを実施します。
これは、<function>xml_is_well_formed</function>は単純な<type>xml</>型へのキャストが成功するかの判断に有用であり、その他の２つの関数は<function>XMLPARSE</>の対応による変換が成功するかの判断に有用であることを意味します。
    </para>

    <para>
<!--
     Examples:
-->
例:

<screen><![CDATA[
SET xmloption TO DOCUMENT;
SELECT xml_is_well_formed('<>');
 xml_is_well_formed 
--------------------
 f
(1 row)

SELECT xml_is_well_formed('<abc/>');
 xml_is_well_formed 
--------------------
 t
(1 row)

SET xmloption TO CONTENT;
SELECT xml_is_well_formed('abc');
 xml_is_well_formed 
--------------------
 t
(1 row)

SELECT xml_is_well_formed_document('<pg:foo xmlns:pg="http://postgresql.org/stuff">bar</pg:foo>');
 xml_is_well_formed_document 
-----------------------------
 t
(1 row)

SELECT xml_is_well_formed_document('<pg:foo xmlns:pg="http://postgresql.org/stuff">bar</my:foo>');
 xml_is_well_formed_document 
-----------------------------
 f
(1 row)
]]></screen>

<!--
     The last example shows that the checks include whether
     namespaces are correctly matched.
-->
最後の例は、名前空間が正しく一致しているかのチェックも含むことを示しています。
    </para>
   </sect3>
  </sect2>

  <sect2 id="functions-xml-processing">
<!--
   <title>Processing XML</title>
-->
   <title>XMLの処理</title>

   <indexterm>
    <primary>XPath</primary>
   </indexterm>

   <para>
<!--
    To process values of data type <type>xml</type>, PostgreSQL offers
    the functions <function>xpath</function> and
    <function>xpath_exists</function>, which evaluate XPath 1.0
    expressions.
-->
データ型<type>xml</type>の値を処理するため、PostgreSQLは関数<function>xpath</function>と<function>xpath_exists</function>を提供しており、それはXPath 1.0式を評価します。
   </para>

<synopsis>
<function>xpath</function>(<replaceable>xpath</replaceable>, <replaceable>xml</replaceable> <optional>, <replaceable>nsarray</replaceable></optional>)
</synopsis>

   <para>
<!--
    The function <function>xpath</function> evaluates the XPath
    expression <replaceable>xpath</replaceable> (a <type>text</> value)
    against the XML value
    <replaceable>xml</replaceable>.  It returns an array of XML values
    corresponding to the node set produced by the XPath expression.
    If the XPath expression returns a scalar value rather than a node set,
    a single-element array is returned.
-->
関数<function>xpath</function>は、XML値<replaceable>xml</replaceable>に対し、XPath式<replaceable>xpath</replaceable>(ひとつの<type>text</>値)を評価します。そして、XPath式で作成されたノードセットに対応するXML値の配列を返します。
もし、XPath式がノードセットではなくスカラー値を返す場合、単一要素の配列が返されます。
   </para>

  <para>
<!--
    The second argument must be a well formed XML document. In particular,
    it must have a single root node element.
-->
2番目の引数は整形済XML文書でなければなりません。特に、単一のルートノード要素を持たなければなりません。
  </para>

   <para>
<!--
    The optional third argument of the function is an array of namespace
    mappings.  This array should be a two-dimensional <type>text</> array with
    the length of the second axis being equal to 2 (i.e., it should be an
    array of arrays, each of which consists of exactly 2 elements).
    The first element of each array entry is the namespace name (alias), the
    second the namespace URI. It is not required that aliases provided in
    this array be the same as those being used in the XML document itself (in
    other words, both in the XML document and in the <function>xpath</function>
    function context, aliases are <emphasis>local</>).
-->
オプショナルな関数の３番目の引数は名前空間マッピング配列です。
この配列は、第２軸が２に等しい長さをもつ２次元<type>text</>配列です（つまり、それは配列の配列で、それぞれは正確に２つの要素からなります）。
それぞれの配列のエントリの最初の要素は名前空間の名前（別名）で、２番目は名前空間のURIです。
この配列内で提供される別名がXML文書自身で使用されるものと同じであることは必要ではありません（言い換えると、XML文書内および<function>xpath</function>関数の両方の文脈の中で、別名は<emphasis>ローカル</>です）。
   </para>

   <para>
<!--
    Example:
-->
例：
<screen><![CDATA[
SELECT xpath('/my:a/text()', '<my:a xmlns:my="http://example.com">test</my:a>',
             ARRAY[ARRAY['my', 'http://example.com']]);

 xpath  
--------
 {test}
(1 row)
]]></screen>
   </para>

   <para>
<!--
    To deal with default (anonymous) namespaces, do something like this:
-->
デフォルト(匿名)名前空間を取り扱うためには、以下のようなことを実施してください。
<screen><![CDATA[
SELECT xpath('//mydefns:b/text()', '<a xmlns="http://example.com"><b>test</b></a>',
             ARRAY[ARRAY['mydefns', 'http://example.com']]);

 xpath
--------
 {test}
(1 row)
]]></screen>
   </para>

   <indexterm>
    <primary>xpath_exists</primary>
   </indexterm>

<synopsis>
<function>xpath_exists</function>(<replaceable>xpath</replaceable>, <replaceable>xml</replaceable> <optional>, <replaceable>nsarray</replaceable></optional>)
</synopsis>

   <para>
<!--
    The function <function>xpath_exists</function> is a specialized form
    of the <function>xpath</function> function.  Instead of returning the
    individual XML values that satisfy the XPath, this function returns a
    Boolean indicating whether the query was satisfied or not.  This
    function is equivalent to the standard <literal>XMLEXISTS</> predicate,
    except that it also offers support for a namespace mapping argument.
-->
関数<function>xpath_exists</function>は、<function>xpath</function>関数の特別な形式です。この関数は、XPathを満足する個別のXML値を返す代わりに、問い合わせがそれを満足するかどうかを論理値で返します。
この関数は、名前空間にマッピングされた引数をもサポートする点を除き、標準の<literal>XMLEXISTS</>述語と同じです。
   </para>

   <para>
<!--
    Example:
-->
例:
<screen><![CDATA[
SELECT xpath_exists('/my:a/text()', '<my:a xmlns:my="http://example.com">test</my:a>',
                     ARRAY[ARRAY['my', 'http://example.com']]);

 xpath_exists  
--------------
 t
(1 row)
]]></screen>
   </para>
  </sect2>

  <sect2 id="functions-xml-mapping">
<!--
   <title>Mapping Tables to XML</title>
-->
   <title>XMLにテーブルをマップ</title>

   <indexterm zone="functions-xml-mapping">
<!--
    <primary>XML export</primary>
-->
    <primary>XMLエクスポート</primary>
   </indexterm>

   <para>
<!--
    The following functions map the contents of relational tables to
    XML values.  They can be thought of as XML export functionality:
-->
以下の関数はリレーショナルテーブルの内容をXML値にマップします。
これらはXMLエクスポート機能と考えることができます。
<synopsis>
table_to_xml(tbl regclass, nulls boolean, tableforest boolean, targetns text)
query_to_xml(query text, nulls boolean, tableforest boolean, targetns text)
cursor_to_xml(cursor refcursor, count int, nulls boolean,
              tableforest boolean, targetns text)
</synopsis>
<!--
    The return type of each function is <type>xml</type>.
-->
それぞれの関数の戻り値型は<type>xml</type>です。
   </para>

   <para>
<!--
    <function>table_to_xml</function> maps the content of the named
    table, passed as parameter <parameter>tbl</parameter>.  The
    <type>regclass</type> type accepts strings identifying tables using the
    usual notation, including optional schema qualifications and
    double quotes.  <function>query_to_xml</function> executes the
    query whose text is passed as parameter
    <parameter>query</parameter> and maps the result set.
    <function>cursor_to_xml</function> fetches the indicated number of
    rows from the cursor specified by the parameter
    <parameter>cursor</parameter>.  This variant is recommended if
    large tables have to be mapped, because the result value is built
    up in memory by each function.
-->
<function>table_to_xml</function>は、パラメータ<parameter>tbl</parameter>として渡された名前付きのテーブルの内容をマップします。
<type>regclass</type>型はオプションのスキーマ修飾と二重引用符を含む、通常の表記法を使用しテーブルを特定する文字列を受け付けます。
<function>query_to_xml</function>は、パラメータ<parameter>query</parameter>としてテキストが渡された問い合わせを実行し、結果セットをマップします。
<function>cursor_to_xml</function>は、パラメータ<parameter>cursor</parameter>で指定されたカーソルから提示された行数を取得します。
この変異形は、それぞれの関数により結果値がメモリーに構築されるため、巨大なテーブルをマップする必要がある場合推奨されます。
   </para>

   <para>
<!--
    If <parameter>tableforest</parameter> is false, then the resulting
    XML document looks like this:
-->
<parameter>tableforest</parameter>が偽であれば、結果のXML文書は以下のようになります。
<screen><![CDATA[
<tablename>
  <row>
    <columnname1>data</columnname1>
    <columnname2>data</columnname2>
  </row>

  <row>
    ...
  </row>

  ...
</tablename>
]]></screen>

<!--
    If <parameter>tableforest</parameter> is true, the result is an
    XML content fragment that looks like this:
-->
<parameter>tableforest</parameter>が真であれば、結果は以下のようなXML文書の断片です。
<screen><![CDATA[
<tablename>
  <columnname1>data</columnname1>
  <columnname2>data</columnname2>
</tablename>

<tablename>
  ...
</tablename>

...
]]></screen>

<!--
    If no table name is available, that is, when mapping a query or a
    cursor, the string <literal>table</literal> is used in the first
    format, <literal>row</literal> in the second format.
-->
テーブル名が１つも有効でなければ、つまり、問い合わせ、またはカーソルをマップする時、文字列<literal>table</literal>が最初の書式で使用され、<literal>row</literal>が２番目の書式で使用されます。
   </para>

   <para>
<!--
    The choice between these formats is up to the user.  The first
    format is a proper XML document, which will be important in many
    applications.  The second format tends to be more useful in the
    <function>cursor_to_xml</function> function if the result values are to be
    reassembled into one document later on.  The functions for
    producing XML content discussed above, in particular
    <function>xmlelement</function>, can be used to alter the results
    to taste.
-->
これらどの書式を選択するのかはユーザ次第です。
最初の書式は適切なXML文書で、多くのアプリケーションにおいて重要です。
第２の書式は、後に結果値が１つの文書に再び組み立てられる場合、<function>cursor_to_xml</function>関数内でより有用になる傾向があります。
上記で説明したXML内容を作成する関数、特に<function>xmlelement</function>は結果を好みにかえるために使用することができます。
   </para>

   <para>
<!--
    The data values are mapped in the same way as described for the
    function <function>xmlelement</function> above.
-->
データの値は上記関数<function>xmlelement</function>で説明したのと同じ方法でマップされます。
   </para>

   <para>
<!--
    The parameter <parameter>nulls</parameter> determines whether null
    values should be included in the output.  If true, null values in
    columns are represented as:
-->
パラメータ<parameter>nulls</parameter>は出力にNULL値が含まれる必要があるかを決定します。
もし真であれば列内のNULL値は以下のように表現されます。
<screen><![CDATA[
<columnname xsi:nil="true"/>
]]></screen>
<!--
    where <literal>xsi</literal> is the XML namespace prefix for XML
    Schema Instance.  An appropriate namespace declaration will be
    added to the result value.  If false, columns containing null
    values are simply omitted from the output.
-->
ここで<literal>xsi</literal>はXMLスキーマインスタンスに対するXML名前空間接頭辞です。
適切な名前空間宣言が結果値に追加されます。
もし偽の場合、NULL値を含む列は単に出力から削除されます。
   </para>

   <para>
<!--
    The parameter <parameter>targetns</parameter> specifies the
    desired XML namespace of the result.  If no particular namespace
    is wanted, an empty string should be passed.
-->
パラメータ<parameter>targetns</parameter>は結果の希望するXML名前空間を指定します。
特定の名前空間が必要なければ、空文字列を渡す必要があります。
   </para>

   <para>
<!--
    The following functions return XML Schema documents describing the
    mappings performed by the corresponding functions above:
-->
以下の関数は、対応する上記関数により行われたマッピングを記述するXMLスキーマ文書を返します。
<synopsis>
table_to_xmlschema(tbl regclass, nulls boolean, tableforest boolean, targetns text)
query_to_xmlschema(query text, nulls boolean, tableforest boolean, targetns text)
cursor_to_xmlschema(cursor refcursor, nulls boolean, tableforest boolean, targetns text)
</synopsis>
<!--
    It is essential that the same parameters are passed in order to
    obtain matching XML data mappings and XML Schema documents.
-->
    一致するXMLデータマッピングとXMLスキーマ文書を取得するため、同じパラメータが渡されることが不可欠です。
   </para>

   <para>
<!--
    The following functions produce XML data mappings and the
    corresponding XML Schema in one document (or forest), linked
    together.  They can be useful where self-contained and
    self-describing results are wanted:
-->
以下の関数は、XMLデータマッピングとそれに対応するXMLスキーマがお互いにリンクされた、１つの文書（またはフォレスト）を作成します。
これらは自己完結した、自己記述的な結果を希望する場合に便利です。
<synopsis>
table_to_xml_and_xmlschema(tbl regclass, nulls boolean, tableforest boolean, targetns text)
query_to_xml_and_xmlschema(query text, nulls boolean, tableforest boolean, targetns text)
</synopsis>
   </para>

   <para>
<!--
    In addition, the following functions are available to produce
    analogous mappings of entire schemas or the entire current
    database:
-->
さらに、以下の関数がスキーマ全体、または現在のデータベース全体の類似マッピングを作成するため利用できます。
<synopsis>
schema_to_xml(schema name, nulls boolean, tableforest boolean, targetns text)
schema_to_xmlschema(schema name, nulls boolean, tableforest boolean, targetns text)
schema_to_xml_and_xmlschema(schema name, nulls boolean, tableforest boolean, targetns text)

database_to_xml(nulls boolean, tableforest boolean, targetns text)
database_to_xmlschema(nulls boolean, tableforest boolean, targetns text)
database_to_xml_and_xmlschema(nulls boolean, tableforest boolean, targetns text)
</synopsis>

<!--
    Note that these potentially produce a lot of data, which needs to
    be built up in memory.  When requesting content mappings of large
    schemas or databases, it might be worthwhile to consider mapping the
    tables separately instead, possibly even through a cursor.
-->
これらはメモリー内に作成される必要がある、多くのデータを生成する潜在的可能性があることに注意してください。
巨大なスキーマ、またはデータベースの内容マッピングを要求する際は、カーソル経由の可能性があっても、その代わりにテーブルを別々にマップすることを検討することは無駄ではありません。
   </para>

   <para>
<!--
    The result of a schema content mapping looks like this:
-->
スキーマ内容マッピングの結果は以下のようになります。

<screen><![CDATA[
<schemaname>

table1-mapping

table2-mapping

...

</schemaname>]]></screen>

<!--
    where the format of a table mapping depends on the
    <parameter>tableforest</parameter> parameter as explained above.
-->
ここで、テーブルマッピング書式は上で説明したとおり<parameter>tableforest</parameter>パラメータに依存します。
   </para>

   <para>
<!--
    The result of a database content mapping looks like this:
-->
データベース内容マッピング書式は以下のようになります。

<screen><![CDATA[
<dbname>

<schema1name>
  ...
</schema1name>

<schema2name>
  ...
</schema2name>

...

</dbname>]]></screen>

<!--
    where the schema mapping is as above.
-->
ここで、スキーママッピングは上記のとおりです。
   </para>

   <para>
<!--
    As an example of using the output produced by these functions,
    <xref linkend="xslt-xml-html"> shows an XSLT stylesheet that
    converts the output of
    <function>table_to_xml_and_xmlschema</function> to an HTML
    document containing a tabular rendition of the table data.  In a
    similar manner, the results from these functions can be
    converted into other XML-based formats.
-->
これらの関数で作成された出力を使用する１つの例として、<xref linkend="xslt-xml-html">は、テーブルデータの表形式への翻訳を含む<function>table_to_xml_and_xmlschema</function>からHTML文書への出力の変換をおこなうXSLTスタイルシートを示します。
同じようにして、これらの関数の結果は他のXML基準書式に変換されます。
   </para>

   <figure id="xslt-xml-html">
<!--
    <title>XSLT Stylesheet for Converting SQL/XML Output to HTML</title>
-->
    <title>SQL/XML出力をHTMLに変換するXSLTスタイルシート</title>
<programlisting><![CDATA[
<?xml version="1.0"?>
<xsl:stylesheet version="1.0"
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:xsd="http://www.w3.org/2001/XMLSchema"
    xmlns="http://www.w3.org/1999/xhtml"
>

  <xsl:output method="xml"
      doctype-system="http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"
      doctype-public="-//W3C/DTD XHTML 1.0 Strict//EN"
      indent="yes"/>

  <xsl:template match="/*">
    <xsl:variable name="schema" select="//xsd:schema"/>
    <xsl:variable name="tabletypename"
                  select="$schema/xsd:element[@name=name(current())]/@type"/>
    <xsl:variable name="rowtypename"
                  select="$schema/xsd:complexType[@name=$tabletypename]/xsd:sequence/xsd:element[@name='row']/@type"/>

    <html>
      <head>
        <title><xsl:value-of select="name(current())"/></title>
      </head>
      <body>
        <table>
          <tr>
            <xsl:for-each select="$schema/xsd:complexType[@name=$rowtypename]/xsd:sequence/xsd:element/@name">
              <th><xsl:value-of select="."/></th>
            </xsl:for-each>
          </tr>

          <xsl:for-each select="row">
            <tr>
              <xsl:for-each select="*">
                <td><xsl:value-of select="."/></td>
              </xsl:for-each>
            </tr>
          </xsl:for-each>
        </table>
      </body>
    </html>
  </xsl:template>

</xsl:stylesheet>
]]></programlisting>
   </figure>
  </sect2>
 </sect1>

 <sect1 id="functions-json">
<!--
  <title>JSON Functions and Operators</title>
-->
  <title>JSON関数と演算子</title>

  <indexterm zone="functions-json">
    <primary>JSON</primary>
<!--
    <secondary>functions and operators</secondary>
-->
    <secondary>関数と演算子</secondary>
  </indexterm>

  <para>
<!--
   <xref linkend="functions-json-op-table"> shows the operators that
   are available for use with the two JSON data types (see <xref
   linkend="datatype-json">).
-->
<xref linkend="functions-json-op-table">は2つのJSONデータ型(<xref linkend="datatype-json">を参照)で使用可能な演算子を示しています。
  </para>

  <table id="functions-json-op-table">
<!--
     <title><type>json</> and <type>jsonb</> Operators</title>
-->
     <title><type>json</>と<type>jsonb</>演算子</title>
     <tgroup cols="5">
      <thead>
       <row>
<!--
        <entry>Operator</entry>
        <entry>Right Operand Type</entry>
        <entry>Description</entry>
        <entry>Example</entry>
        <entry>Example Result</entry>
-->
        <entry>演算子</entry>
        <entry>右オペランド型</entry>
        <entry>説明</entry>
        <entry>例</entry>
        <entry>例の結果</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><literal>-&gt;</literal></entry>
        <entry><type>int</type></entry>
<!--
        <entry>Get JSON array element (indexed from zero)</entry>
-->
        <entry>JSON配列要素取得(添字はゼロから)</entry>
        <entry><literal>'[{"a":"foo"},{"b":"bar"},{"c":"baz"}]'::json-&gt;2</literal></entry>
        <entry><literal>{"c":"baz"}</literal></entry>
       </row>
       <row>
        <entry><literal>-&gt;</literal></entry>
        <entry><type>text</type></entry>
<!--
        <entry>Get JSON object field by key</entry>
-->
        <entry>キーに依るJSONオブジェクトフィールド取得</entry>
        <entry><literal>'{"a": {"b":"foo"}}'::json-&gt;'a'</literal></entry>
        <entry><literal>{"b":"foo"}</literal></entry>
       </row>
        <row>
        <entry><literal>-&gt;&gt;</literal></entry>
        <entry><type>int</type></entry>
<!--
        <entry>Get JSON array element as <type>text</></entry>
-->
        <entry>JSON 配列要素を<type>text</>として取得</entry>
        <entry><literal>'[1,2,3]'::json-&gt;&gt;2</literal></entry>
        <entry><literal>3</literal></entry>
       </row>
       <row>
        <entry><literal>-&gt;&gt;</literal></entry>
        <entry><type>text</type></entry>
<!--
        <entry>Get JSON object field as <type>text</></entry>
-->
        <entry>JSON オブジェクトフィールドを<type>text</>として取得</entry>
        <entry><literal>'{"a":1,"b":2}'::json-&gt;&gt;'b'</literal></entry>
        <entry><literal>2</literal></entry>
       </row>
       <row>
        <entry><literal>#&gt;</literal></entry>
        <entry><type>text[]</type></entry>
<!--
        <entry>Get JSON object at specified path</entry>
-->
        <entry>指定されたパスにてJSONオブジェクトを取得</entry>
        <entry><literal>'{"a": {"b":{"c": "foo"}}}'::json#&gt;'{a,b}'</literal></entry>
        <entry><literal>{"c": "foo"}</literal></entry>
       </row>
       <row>
        <entry><literal>#&gt;&gt;</literal></entry>
        <entry><type>text[]</type></entry>
<!--
        <entry>Get JSON object at specified path as <type>text</></entry>
-->
        <entry>指定されたパスにてJSONオブジェクトを<type>text</>として取得</entry>
        <entry><literal>'{"a":[1,2,3],"b":[4,5,6]}'::json#&gt;&gt;'{a,2}'</literal></entry>
        <entry><literal>3</literal></entry>
       </row>
      </tbody>
     </tgroup>
   </table>

  <note>
   <para>
<!--
    There are parallel variants of these operators for both the
    <type>json</type> and <type>jsonb</type> types.
    The field/element/path extraction operators
    return the same type as their left-hand input (either <type>json</type>
    or <type>jsonb</type>), except for those specified as
    returning <type>text</>, which coerce the value to text.
    The field/element/path extraction operators return NULL, rather than
    failing, if the JSON input does not have the right structure to match
    the request; for example if no such element exists.
-->
<type>json</type>と<type>jsonb</type>型の両方に対して、以上の演算子の対応するものがあります。
JSON入力が要求と一致する正しい構造をしていなければ、フィールド/要素/パス抽出演算子は失敗するのではなくNULLを返します。例えばそのような要素が存在しない場合です。
   </para>
  </note>
  <para>
<!--
   The standard comparison operators shown in  <xref
   linkend="functions-comparison-table"> are available for
   <type>jsonb</type>, but not for <type>json</type>. They follow the
   ordering rules for B-tree operations outlined at <xref
   linkend="json-indexing">.
-->
<xref linkend="functions-comparison-table">に示されている標準の比較演算子が<type>jsonb</type>で利用可能ですが、<type>json</type>ではそうではありません。
それらは<xref linkend="json-indexing">で概略を述べたB-tree演算子の順序規則に従います。
  </para>
  <para>
<!--
   Some further operators also exist only for <type>jsonb</type>, as shown
   in <xref linkend="functions-jsonb-op-table">.
   Many of these operators can be indexed by
   <type>jsonb</> operator classes.  For a full description of
   <type>jsonb</> containment and existence semantics, see <xref
   linkend="json-containment">.  <xref linkend="json-indexing">
   describes how these operators can be used to effectively index
   <type>jsonb</> data.
-->
<xref linkend="functions-jsonb-op-table">に示されているように<type>jsonb</type>だけにはそれ以上の演算子も存在します。
そのうちの多くの演算子は<type>jsonb</>演算子クラスでインデックス付けすることが可能です。
<type>jsonb</>の包含と存在の意味に関する完全な記述は<xref linkend="json-containment">を参照してください。
<xref linkend="json-indexing">には、<type>jsonb</>データを効率的にインデックス付けするためにこれらの演算子をどのように利用できるかについて書いてあります。
  </para>
  <table id="functions-jsonb-op-table">
<!--
     <title>Additional <type>jsonb</> Operators</title>
-->
     <title>追加<type>jsonb</>演算子</title>
     <tgroup cols="4">
      <thead>
       <row>
<!--
        <entry>Operator</entry>
        <entry>Right Operand Type</entry>
        <entry>Description</entry>
        <entry>Example</entry>
-->
        <entry>演算子</entry>
        <entry>右オペランド型</entry>
        <entry>説明</entry>
        <entry>例</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><literal>@&gt;</literal></entry>
        <entry><type>jsonb</type></entry>
<!--
        <entry>Does the left JSON value contain within it the right value?</entry>
-->
        <entry>左のJSON値はその中に右の値を包含するか。</entry>
        <entry><literal>'{"a":1, "b":2}'::jsonb &#64;&gt; '{"b":2}'::jsonb</literal></entry>
       </row>
       <row>
        <entry><literal>&lt;@</literal></entry>
        <entry><type>jsonb</type></entry>
<!--
        <entry>Is the left JSON value contained within the right value?</entry>
-->
        <entry>左のJSON値は右の値の中に包含されるか。</entry>
        <entry><literal>'{"b":2}'::jsonb &lt;@ '{"a":1, "b":2}'::jsonb</literal></entry>
       </row>
       <row>
        <entry><literal>?</literal></entry>
        <entry><type>text</type></entry>
<!--
        <entry>Does the key/element <emphasis>string</emphasis> exist within
        the JSON value?</entry>
-->
        <entry>キー/要素<emphasis>文字列</emphasis>はJSON値の中に存在するか。</entry>
        <entry><literal>'{"a":1, "b":2}'::jsonb ? 'b'</literal></entry>
       </row>
       <row>
        <entry><literal>?|</literal></entry>
        <entry><type>text[]</type></entry>
<!--
        <entry>Do any of these key/element <emphasis>strings</emphasis> exist?</entry>
-->
        <entry>キー/要素<emphasis>文字列</emphasis>のいずれかが存在するか。</entry>
        <entry><literal>'{"a":1, "b":2, "c":3}'::jsonb ?| array['b', 'c']</literal></entry>
       </row>
       <row>
        <entry><literal>?&amp;</literal></entry>
        <entry><type>text[]</type></entry>
<!--
        <entry>Do all of these key/element <emphasis>strings</emphasis> exist?</entry>
-->
        <entry>キー/要素<emphasis>文字列</emphasis>のすべてが存在するか。</entry>
        <entry><literal>'["a", "b"]'::jsonb ?&amp; array['a', 'b']</literal></entry>
       </row>
      </tbody>
     </tgroup>
   </table>

  <para>
<!--
   <xref linkend="functions-json-creation-table"> shows the functions that are
   available for creating <type>json</type> values.
   (Currently, there are no equivalent functions for <type>jsonb</>, but you
   can cast the result of one of these functions to <type>jsonb</>.)
-->
<xref linkend="functions-json-creation-table">に、JSON値を作成するために利用可能な関数を示します。
(今のところ、<type>jsonb</>のための同様な関数はありませんが、以下の関数の結果を<type>jsonb</>にキャストできます。)
  </para>

  <indexterm>
   <primary>to_json</primary>
  </indexterm>
  <indexterm>
   <primary>array_to_json</primary>
  </indexterm>
  <indexterm>
   <primary>row_to_json</primary>
  </indexterm>
  <indexterm>
   <primary>json_build_array</primary>
  </indexterm>
  <indexterm>
   <primary>json_build_object</primary>
  </indexterm>
  <indexterm>
   <primary>json_object</primary>
  </indexterm>

  <table id="functions-json-creation-table">
<!--
    <title>JSON Creation Functions</title>
-->
    <title>JSON作成関数</title>
    <tgroup cols="4">
     <thead>
      <row>
<!--
       <entry>Function</entry>
       <entry>Description</entry>
       <entry>Example</entry>
       <entry>Example Result</entry>
-->
       <entry>関数</entry>
       <entry>説明</entry>
       <entry>例</entry>
       <entry>例の結果</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>
         <literal>to_json(anyelement)</literal>
       </entry>
       <entry>
<!--
         Returns the value as JSON.  Arrays and composites are converted
         (recursively) to arrays and objects; otherwise, if there is a cast
         from the type to <type>json</type>, the cast function will be used to
         perform the conversion; otherwise, a JSON scalar value is produced.
         For any scalar type other than a number, a Boolean, or a null value,
         the text representation will be used, properly quoted and escaped
         so that it is a valid JSON string.
-->
JSONとして値を返す。
配列と複合型は(それぞれ)配列とオブジェクトに変換される。そうでなければ、その型から<type>json</type>にキャストがあれば、キャスト関数が変換のために用いられる。そうでなければ、JSONスカラ値が生成される。
数値、論理値、またはNULL値以外のスカラ型に対しては、有効なJSONと認められるようエスケープおよび引用符で囲まれた文字列表現が使用される。
       </entry>
       <entry><literal>to_json('Fred said "Hi."'::text)</literal></entry>
       <entry><literal>"Fred said \"Hi.\""</literal></entry>
      </row>
      <row>
       <entry>
         <literal>array_to_json(anyarray [, pretty_bool])</literal>
       </entry>
       <entry>
<!--
         Returns the array as a JSON array. A PostgreSQL multidimensional array
         becomes a JSON array of arrays. Line feeds will be added between
         dimension-1 elements if <parameter>pretty_bool</parameter> is true.
-->
         配列をJSON配列として返す。PostgreSQLの多次元配列はJSON配列の配列となる。もし<parameter>pretty_bool</parameter>が真の場合、次元数-1の要素の間にラインフィードが加えられる。
       </entry>
       <entry><literal>array_to_json('{{1,5},{99,100}}'::int[])</literal></entry>
       <entry><literal>[[1,5],[99,100]]</literal></entry>
      </row>
      <row>
       <entry>
         <literal>row_to_json(record [, pretty_bool])</literal>
       </entry>
       <entry>
<!--
         Returns the row as a JSON object. Line feeds will be added between
         level-1 elements if <parameter>pretty_bool</parameter> is true.
-->
         行をJSONオブジェクトとして返す。もし<parameter>pretty_bool</parameter>が真の場合、レベル-1の要素の間にラインフィードが加えられる。
       </entry>
       <entry><literal>row_to_json(row(1,'foo'))</literal></entry>
       <entry><literal>{"f1":1,"f2":"foo"}</literal></entry>
      </row>
      <row>
       <entry>
         <literal>json_build_array(VARIADIC "any")</literal>
       </entry>
       <entry>
<!--
         Builds a possibly-heterogeneously-typed JSON array out of a variadic
         argument list.
-->
         異なる型から構成される可能性のあるJSON配列をvariadic引数一覧から作成。
       </entry>
       <entry><literal>json_build_array(1,2,'3',4,5)</literal></entry>
       <entry><literal>[1, 2, "3", 4, 5]</literal></entry>
      </row>
      <row>
       <entry>
         <literal>json_build_object(VARIADIC "any")</literal>
       </entry>
       <entry>
<!--
         Builds a JSON object out of a variadic argument list.  By
         convention, the argument list consists of alternating
         keys and values.
-->
         variadic引数一覧からJSONオブジェクトを作成。慣例により引数一覧はキーと値が交互に並んだもの。
       </entry>
       <entry><literal>json_build_object('foo',1,'bar',2)</literal></entry>
       <entry><literal>{"foo": 1, "bar": 2}</literal></entry>
      </row>
      <row>
       <entry>
         <literal>json_object(text[])</literal>
       </entry>
       <entry>
<!--
         Builds a JSON object out of a text array.  The array must have either
         exactly one dimension with an even number of members, in which case
         they are taken as alternating key/value pairs, or two dimensions
         such that each inner array has exactly two elements, which
         are taken as a key/value pair.
-->
         テキスト配列からJSONオブジェクトを作成。配列は、以下のどちらかでなければならない。偶数個の要素からなる1次元、この場合にはキー/値の対が交互に並んでいるものと扱われる。内側の配列が2つの要素を持つ2次元、2つの要素がキー/値の対として扱われる。
       </entry>
       <entry><para><literal>json_object('{a, 1, b, "def", c, 3.5}')</></para>
        <para><literal>json_object('{{a, 1},{b, "def"},{c, 3.5}}')</></para></entry>
       <entry><literal>{"a": "1", "b": "def", "c": "3.5"}</literal></entry>
      </row>
      <row>
       <entry>
         <literal>json_object(keys text[], values text[])</literal>
       </entry>
       <entry>
<!--
         This form of <function>json_object</> takes keys and values pairwise from two separate
         arrays. In all other respects it is identical to the one-argument form.
-->
        この形の<function>json_object</>は2つの別々の配列からキーと値の対を取る。他の点ではすべて、引数1つの形と同じ。
       </entry>
       <entry><literal>json_object('{a, b}', '{1,2}')</literal></entry>
       <entry><literal>{"a": "1", "b": "2"}</literal></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <note>
    <para>
<!--
     <function>array_to_json</> and <function>row_to_json</> have the same
     behavior as <function>to_json</> except for offering a pretty-printing
     option.  The behavior described for <function>to_json</> likewise applies
     to each individual value converted by the other JSON creation functions.
-->
<function>array_to_json</>と<function>row_to_json</>は表示を整えるオプションを提供する以外は<function>to_json</>と同様の振舞いをします。
同様に<function>to_json</>に書かれた振舞いはJSON作成関数により変換された個々の値に適用されます。
    </para>
  </note>

  <note>
    <para>
<!--
     The <xref linkend="hstore"> extension has a cast
     from <type>hstore</type> to <type>json</type>, so that
     <type>hstore</type> values converted via the JSON creation functions
     will be represented as JSON objects, not as primitive string values.
-->
<xref linkend="hstore">拡張は<type>hstore</type>から<type>json</type>へのキャストを含みます。従って、JSON作成関数で変換された<type>hstore</type>値は元の文字列値ではなくJSONオブジェクトとして示されます。
    </para>
  </note>

  <para>
<!--
   <xref linkend="functions-json-processing-table"> shows the functions that
   are available for processing <type>json</type> and <type>jsonb</type> values.
-->
<xref linkend="functions-json-processing-table">に<type>json</type>と<type>jsonb</type>値を処理するのに使える関数を示します。
  </para>

  <indexterm>
   <primary>json_array_length</primary>
  </indexterm>
  <indexterm>
   <primary>jsonb_array_length</primary>
  </indexterm>
  <indexterm>
   <primary>json_each</primary>
  </indexterm>
  <indexterm>
   <primary>jsonb_each</primary>
  </indexterm>
  <indexterm>
   <primary>json_each_text</primary>
  </indexterm>
  <indexterm>
   <primary>jsonb_each_text</primary>
  </indexterm>
  <indexterm>
   <primary>json_extract_path</primary>
  </indexterm>
  <indexterm>
   <primary>jsonb_extract_path</primary>
  </indexterm>
  <indexterm>
   <primary>json_extract_path_text</primary>
  </indexterm>
  <indexterm>
   <primary>jsonb_extract_path_text</primary>
  </indexterm>
  <indexterm>
   <primary>json_object_keys</primary>
  </indexterm>
  <indexterm>
   <primary>jsonb_object_keys</primary>
  </indexterm>
  <indexterm>
   <primary>json_populate_record</primary>
  </indexterm>
  <indexterm>
   <primary>jsonb_populate_record</primary>
  </indexterm>
  <indexterm>
   <primary>json_populate_recordset</primary>
  </indexterm>
  <indexterm>
   <primary>jsonb_populate_recordset</primary>
  </indexterm>
  <indexterm>
   <primary>json_array_elements</primary>
  </indexterm>
  <indexterm>
   <primary>jsonb_array_elements</primary>
  </indexterm>
  <indexterm>
   <primary>json_array_elements_text</primary>
  </indexterm>
  <indexterm>
   <primary>jsonb_array_elements_text</primary>
  </indexterm>
  <indexterm>
   <primary>json_typeof</primary>
  </indexterm>
  <indexterm>
   <primary>jsonb_typeof</primary>
  </indexterm>
  <indexterm>
   <primary>json_to_record</primary>
  </indexterm>
  <indexterm>
   <primary>jsonb_to_record</primary>
  </indexterm>
  <indexterm>
   <primary>json_to_recordset</primary>
  </indexterm>
  <indexterm>
   <primary>jsonb_to_recordset</primary>
  </indexterm>

  <table id="functions-json-processing-table">
<!--
    <title>JSON Processing Functions</title>
-->
    <title>JSON処理関数</title>
    <tgroup cols="5">
     <thead>
      <row>
<!--
       <entry>Function</entry>
       <entry>Return Type</entry>
       <entry>Description</entry>
       <entry>Example</entry>
       <entry>Example Result</entry>
-->
       <entry>関数</entry>
       <entry>戻り値型</entry>
       <entry>説明</entry>
       <entry>例</entry>
       <entry>例の結果</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><para><literal>json_array_length(json)</literal>
         </para><para><literal>jsonb_array_length(jsonb)</literal>
       </para></entry>
       <entry><type>int</type></entry>
       <entry>
<!--
         Returns the number of elements in the outermost JSON array.
-->
         JSON配列の最も外側の要素の数を返す。
       </entry>
       <entry><literal>json_array_length('[1,2,3,{"f1":1,"f2":[5,6]},4]')</literal></entry>
       <entry><literal>5</literal></entry>
      </row>
      <row>
       <entry><para><literal>json_each(json)</literal>
         </para><para><literal>jsonb_each(jsonb)</literal>
       </para></entry>
       <entry><para><literal>setof key text, value json</literal>
         </para><para><literal>setof key text, value jsonb</literal>
       </para></entry>
       <entry>
<!--
         Expands the outermost JSON object into a set of key/value pairs.
-->
         JSONオブジェクトの最も外側をkey/valueの組み合わせに拡張する。
       </entry>
       <entry><literal>select * from json_each('{"a":"foo", "b":"bar"}')</literal></entry>
       <entry>
<programlisting>
 key | value
-----+-------
 a   | "foo"
 b   | "bar"
</programlisting>
       </entry>
      </row>
      <row>
       <entry><para><literal>json_each_text(json)</literal>
         </para><para><literal>jsonb_each_text(jsonb)</literal>
       </para></entry>
       <entry><type>setof key text, value text</type></entry>
       <entry>
<!--
         Expands the outermost JSON object into a set of key/value pairs. The
         returned values will be of type <type>text</>.
-->
        JSONオブジェクトの最も外側をkey/valueの組み合わせに拡張する。返り値は型<type>text</>。
       </entry>
       <entry><literal>select * from json_each_text('{"a":"foo", "b":"bar"}')</literal></entry>
       <entry>
<programlisting>
 key | value
-----+-------
 a   | foo
 b   | bar
</programlisting>
       </entry>
      </row>
      <row>
       <entry><para><literal>json_extract_path(from_json json, VARIADIC path_elems text[])</literal>
        </para><para><literal>jsonb_extract_path(from_json jsonb, VARIADIC path_elems text[])</literal>
       </para></entry>
       <entry><para><type>json</type></para><para><type>jsonb</type>
       </para></entry>
       <entry>
<!--
         Returns JSON value pointed to by <replaceable>path_elems</replaceable>
         (equivalent to <literal>#&gt;</literal> operator).
-->
        <replaceable>path_elems</replaceable>で示されたJSONオブジェクトを返す(<literal>#&gt;</literal>と同じ)。
       </entry>
       <entry><literal>json_extract_path('{"f2":{"f3":1},"f4":{"f5":99,"f6":"foo"}}','f4')</literal></entry>
       <entry><literal>{"f5":99,"f6":"foo"}</literal></entry>
      </row>
      <row>
       <entry><para><literal>json_extract_path_text(from_json json, VARIADIC path_elems text[])</literal>
         </para><para><literal>jsonb_extract_path_text(from_json jsonb, VARIADIC path_elems text[])</literal>
       </para></entry>
       <entry><type>text</type></entry>
       <entry>
<!--
         Returns JSON value pointed to by <replaceable>path_elems</replaceable>
         as <type>text</>
         (equivalent to <literal>#&gt;&gt;</literal> operator).
-->
        <replaceable>path_elems</replaceable>で示されたJSONオブジェクトを<type>text</>として返す(<literal>#&gt;&gt;</literal>演算子と同じ)。
       </entry>
       <entry><literal>json_extract_path_text('{"f2":{"f3":1},"f4":{"f5":99,"f6":"foo"}}','f4', 'f6')</literal></entry>
       <entry><literal>foo</literal></entry>
      </row>
      <row>
       <entry><para><literal>json_object_keys(json)</literal>
         </para><para><literal>jsonb_object_keys(jsonb)</literal>
       </para></entry>
       <entry><type>setof text</type></entry>
       <entry>
<!--
          Returns set of keys in the outermost JSON object.
-->
        最も外側のJSONオブジェクトの中のキー一式を返す。
       </entry>
       <entry><literal>json_object_keys('{"f1":"abc","f2":{"f3":"a", "f4":"b"}}')</literal></entry>
       <entry>
<programlisting>
 json_object_keys
------------------
 f1
 f2
</programlisting>
       </entry>
      </row>
      <row>
       <entry><para><literal>json_populate_record(base anyelement, from_json json)</literal>
         </para><para><literal>jsonb_populate_record(base anyelement, from_json jsonb)</literal>
       </para></entry>
       <entry><type>anyelement</type></entry>
       <entry>
<!--
         Expands the object in <replaceable>from_json</replaceable> to a row
         whose columns match the record type defined by <replaceable>base</>
         (see note below).
-->
<replaceable>from_json</replaceable>内のオブジェクトを行を<replaceable>base</>で定義されたレコード型に一致する列に拡張する(以下の注意書きを参照)。
       </entry>
       <entry><literal>select * from json_populate_record(null::myrowtype, '{"a":1,"b":2}')</literal></entry>
       <entry>
<programlisting>
 a | b
---+---
 1 | 2
</programlisting>
       </entry>
      </row>
      <row>
       <entry><para><literal>json_populate_recordset(base anyelement, from_json json)</literal>
         </para><para><literal>jsonb_populate_recordset(base anyelement, from_json jsonb)</literal>
       </para></entry>
       <entry><type>setof anyelement</type></entry>
       <entry>
<!--
         Expands the outermost array of objects
         in <replaceable>from_json</replaceable> to a set of rows whose
         columns match the record type defined by <replaceable>base</> (see
         note below).
-->
<replaceable>from_json</replaceable>におけるオブジェクトの最も外側の配列を<replaceable>base</>で定義されたレコード型に一致する列を持つ行の集合に展開する(以下の注意書き参照)。
       </entry>
       <entry><literal>select * from json_populate_recordset(null::myrowtype, '[{"a":1,"b":2},{"a":3,"b":4}]')</literal></entry>
       <entry>
<programlisting>
 a | b
---+---
 1 | 2
 3 | 4
</programlisting>
       </entry>
      </row>
      <row>
       <entry><para><literal>json_array_elements(json)</literal>
         </para><para><literal>jsonb_array_elements(jsonb)</literal>
       </para></entry>
       <entry><para><type>setof json</type>
         </para><para><type>setof jsonb</type>
       </para></entry>
       <entry>
<!--
         Expands a JSON array to a set of JSON values.
-->
        JSON配列をJSON値の集合に展開する。
       </entry>
       <entry><literal>select * from json_array_elements('[1,true, [2,false]]')</literal></entry>
       <entry>
<programlisting>
   value
-----------
 1
 true
 [2,false]
</programlisting>
       </entry>
      </row>
      <row>
       <entry><para><literal>json_array_elements_text(json)</literal>
         </para><para><literal>jsonb_array_elements_text(jsonb)</literal>
       </para></entry>
       <entry><type>setof text</type></entry>
       <entry>
<!--
         Expands a JSON array to a set of <type>text</> values.
-->
        JSON配列を<type>text</>値の集合に展開する。
       </entry>
       <entry><literal>select * from json_array_elements_text('["foo", "bar"]')</literal></entry>
       <entry>
<programlisting>
   value
-----------
 foo
 bar
</programlisting>
       </entry>
      </row>
      <row>
       <entry><para><literal>json_typeof(json)</literal>
         </para><para><literal>jsonb_typeof(jsonb)</literal>
       </para></entry>
       <entry><type>text</type></entry>
       <entry>
<!--
         Returns the type of the outermost JSON value as a text string.
         Possible types are
         <literal>object</>, <literal>array</>, <literal>string</>, <literal>number</>,
         <literal>boolean</>, and <literal>null</>.
-->
         最も外側のJSON値の型をテキスト文字列として返す。取りうる型は<literal>object</>、 <literal>array</>、 <literal>string</>、 <literal>number</>、<literal>boolean</>、<literal>null</>である。
       </entry>
       <entry><literal>json_typeof('-123.4')</literal></entry>
       <entry><literal>number</literal></entry>
      </row>
      <row>
       <entry><para><literal>json_to_record(json)</literal>
          </para><para><literal>jsonb_to_record(jsonb)</literal>
       </para></entry>
       <entry><type>record</type></entry>
       <entry>
<!--
         Builds an arbitrary record from a JSON object (see note below).  As
         with all functions returning <type>record</>, the caller must
         explicitly define the structure of the record with an <literal>AS</>
         clause.
-->
        JSONオブジェクトから任意のレコードを作成します(下記の注釈を参照してください)。<type>record</>を返す関数すべてと同様、呼び出し側が<literal>AS</>句でレコードの構造を明示的に決めなければなりません。
       </entry>
       <entry><literal>select * from json_to_record('{"a":1,"b":[1,2,3],"c":"bar"}') as x(a int, b text, d text) </literal></entry>
       <entry>
<programlisting>
 a |    b    | d
---+---------+---
 1 | [1,2,3] |
</programlisting>
       </entry>
      </row>
      <row>
       <entry><para><literal>json_to_recordset(json)</literal>
         </para><para><literal>jsonb_to_recordset(jsonb)</literal>
       </para></entry>
       <entry><type>setof record</type></entry>
       <entry>
<!--
         Builds an arbitrary set of records from a JSON array of objects (see
         note below).  As with all functions returning <type>record</>, the
         caller must explicitly define the structure of the record with
         an <literal>AS</> clause.
-->
        オブジェクトの配列のJSONから任意のレコードを作成します(下記の注釈を参照してください)。<type>record</>を返す関数すべてと同様、呼び出し側が<literal>AS</>句でレコードの構造を明示的に決めなければなりません。
       </entry>
       <entry><literal>select * from json_to_recordset('[{"a":1,"b":"foo"},{"a":"2","c":"bar"}]') as x(a int, b text);</literal></entry>
       <entry>
<programlisting>
 a |  b
---+-----
 1 | foo
 2 |
</programlisting>
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <note>
    <para>
<!--
      Many of these functions and operators will convert Unicode escapes in
      JSON strings to the appropriate single character.  This is a non-issue
      if the input is type <type>jsonb</>, because the conversion was already
      done; but for <type>json</> input, this may result in throwing an error,
      as noted in <xref linkend="datatype-json">.
-->
これらの多くの関数や演算子はデータベースエンコードがUTF8の時は、JSON文字列のUnicodeのエスケープを適切な一文字に変換します。
これは入力が<type>jsonb</>型であれば、変換は既に行なわれていますので、重要な問題ではありません。しかし、<type>json</>の入力に対しては、<xref linkend="datatype-json">で言及したようにこれはエラーを発生させる結果になるかもしれません．
    </para>
  </note>

  <note>
    <para>
<!--
      In <function>json_populate_record</>, <function>json_populate_recordset</>,
      <function>json_to_record</> and <function>json_to_recordset</>,
      type coercion from the JSON is <quote>best effort</> and may not result
      in desired values for some types.  JSON keys are matched to
      identical column names in the target row type.  JSON fields that do not
      appear in the target row type will be omitted from the output, and
      target columns that do not match any JSON field will simply be NULL.
-->
<function>json_to_record</>と<function>json_to_recordset</>、JSONからの型強制は<quote>最善努力</>であり、ある型では望んだ結果にならないかもしれません。
JSONキーは対象の行の型の中の同一の列の名前と一致します。
対象の行の型に現れないJSONフィールドは出力から省略され、JSONフィールドに一致しない対象の列は単にNULLになります。
    </para>
  </note>

  <note>
    <para>
<!--
      The <literal>json_typeof</> function's <literal>null</> return value
      should not be confused with a SQL NULL.  While
      calling <literal>json_typeof('null'::json)</> will
      return <literal>null</>, calling <literal>json_typeof(NULL::json)</>
      will return a SQL NULL.
-->
<literal>json_typeof</>の<literal>null</>戻り値をSQLのNULLと混同してはいけません。
<literal>json_typeof('null'::json)</>を呼び出すと<literal>null</>が返りますが、<literal>json_typeof(NULL::json)</>を呼び出すとSQLのNULLが返ります。
    </para>
  </note>

  <para>
<!--
    See also <xref linkend="functions-aggregate"> for the aggregate
    function <function>json_agg</function> which aggregates record
    values as JSON, and the aggregate function
    <function>json_object_agg</function> which aggregates pairs of values
    into a JSON object.
-->
レコードの値をJSONに集約する<function>json_agg</function>集約関数や、値の対をJSONオブジェクトに集約する<function>json_object_agg</function>集約関数については<xref linkend="functions-aggregate">も参照してください。
  </para>

 </sect1>

 <sect1 id="functions-sequence">
<!--
  <title>Sequence Manipulation Functions</title>
-->
  <title>シーケンス操作関数</title>

  <indexterm>
   <primary>sequence</primary>
  </indexterm>
  <indexterm>
   <primary>nextval</primary>
  </indexterm>
  <indexterm>
   <primary>currval</primary>
  </indexterm>
  <indexterm>
   <primary>lastval</primary>
  </indexterm>
  <indexterm>
   <primary>setval</primary>
  </indexterm>

  <para>
<!--
   This section describes functions for operating on <firstterm>sequence
   objects</firstterm>, also called sequence generators or just sequences.
   Sequence objects are special single-row tables created with <xref
   linkend="sql-createsequence">.
   Sequence objects are commonly used to generate unique identifiers
   for rows of a table.  The sequence functions, listed in <xref
   linkend="functions-sequence-table">, provide simple, multiuser-safe
   methods for obtaining successive sequence values from sequence
   objects.
-->
シーケンスオブジェクト、シーケンスジェネレータとも単にシーケンスとも呼ばれる、本節では<firstterm>シーケンスオブジェクト</firstterm>に対し演算を行う関数について説明します。
シーケンスオブジェクトは特殊な一行テーブルで、<xref linkend="sql-createsequence">で作成されます。
シーケンスオブジェクトは一般的にテーブルの行に一意の識別子を生成するために使用されます。
<xref linkend="functions-sequence-table">に列挙されているシーケンス関数は、シーケンスオブジェクトから連続したシーケンス値を取得するための、簡易でマルチユーザに対応した関数です。
  </para>

   <table id="functions-sequence-table">
<!--
    <title>Sequence Functions</title>
-->
    <title>シーケンス関数</title>
    <tgroup cols="3">
     <thead>
<!--
      <row><entry>Function</entry> <entry>Return Type</entry> <entry>Description</entry></row>
-->
      <row><entry>関数</entry> <entry>戻り値</entry> <entry>説明</entry></row>
     </thead>

     <tbody>
      <row>
        <entry><literal><function>currval(<type>regclass</type>)</function></literal></entry>
        <entry><type>bigint</type></entry>
<!--
        <entry>Return value most recently obtained with
        <function>nextval</function> for specified sequence</entry>
-->
        <entry>指定されたシーケンスに対し<function>nextval</function>で得られた最新の値を返す</entry>
      </row>
      <row>
        <entry><literal><function>lastval()</function></literal></entry>
        <entry><type>bigint</type></entry>
<!--
        <entry>Return value most recently obtained with
        <function>nextval</function> for any sequence</entry>
-->
        <entry>どんなシーケンスに対してでも<function>nextval</function>により最も最近取得された値を返す</entry>
      </row>
      <row>
        <entry><literal><function>nextval(<type>regclass</type>)</function></literal></entry>
        <entry><type>bigint</type></entry>
<!--
        <entry>Advance sequence and return new value</entry>
-->
        <entry>シーケンスを進め、新しい値を返す</entry>
      </row>
      <row>
        <entry><literal><function>setval(<type>regclass</type>, <type>bigint</type>)</function></literal></entry>
        <entry><type>bigint</type></entry>
<!--
        <entry>Set sequence's current value</entry>
-->
        <entry>シーケンスの現在値を設定する</entry>
      </row>
      <row>
        <entry><literal><function>setval(<type>regclass</type>, <type>bigint</type>, <type>boolean</type>)</function></literal></entry>
        <entry><type>bigint</type></entry>
<!--
        <entry>Set sequence's current value and <literal>is_called</literal> flag</entry>
-->
        <entry>シーケンスの現在値と<literal>is_called</literal>フラグを設定する</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <para>
<!--
   The sequence to be operated on by a sequence function is specified by
   a <type>regclass</> argument, which is simply the OID of the sequence in the
   <structname>pg_class</> system catalog.  You do not have to look up the
   OID by hand, however, since the <type>regclass</> data type's input
   converter will do the work for you.  Just write the sequence name enclosed
   in single quotes so that it looks like a literal constant.  For
   compatibility with the handling of ordinary
   <acronym>SQL</acronym> names, the string will be converted to lower case
   unless it contains double quotes around the sequence name.  Thus:
-->
シーケンス関数により操作されるシーケンスは<type>regclass</>引数で指定され、そしてそれは<structname>pg_class</>システムカタログ内のシーケンスのOIDに過ぎません。
しかしながら、手作業でOIDを検索する必要はなく、<type>regclass</>データ型の入力変換器が代わってその作業を行ってくれます。
リテラル関数のように見えるするようにするため、単一引用符で括られたシーケンス名を記述するだけです。
通常の<acronym>SQL</acronym>の名称での操作との互換のため、文字列はシーケンス名が二重引用符で括られている以外、小文字に変換されます。
よって、以下のようになります。
<programlisting>
<!--  
nextval('foo')      <lineannotation>operates on sequence <literal>foo</literal></>
nextval('FOO')      <lineannotation>operates on sequence <literal>foo</literal></>
nextval('"Foo"')    <lineannotation>operates on sequence <literal>Foo</literal></>
-->
nextval('foo')      <lineannotation>シーケンス<literal>foo</literal>の操作</>
nextval('FOO')      <lineannotation>シーケンス<literal>foo</literal>の操作</>
nextval('"Foo"')    <lineannotation>シーケンス<literal>Foo</literal>の操作</>
</programlisting>
<!--
   The sequence name can be schema-qualified if necessary:
-->
必要であれば、以下のようにシーケンス名をスキーマで修飾することができます。
<programlisting>
<!--
nextval('myschema.foo')     <lineannotation>operates on <literal>myschema.foo</literal></>
nextval('"myschema".foo')   <lineannotation>same as above</lineannotation>
nextval('foo')              <lineannotation>searches search path for <literal>foo</literal></>
-->
nextval('myschema.foo')     <lineannotation><literal>myschema.foo</literal>の操作</>
nextval('"myschema".foo')   <lineannotation>上と同じ</lineannotation>
nextval('foo')              <lineannotation><literal>foo</literal>を検索パスで探す</>
</programlisting>
<!--
   See <xref linkend="datatype-oid"> for more information about
   <type>regclass</>.
-->
<type>regclass</>に関してのより詳細な情報は<xref linkend="datatype-oid">を参照してください。
  </para>

  <note>
   <para>
<!--
    Before <productname>PostgreSQL</productname> 8.1, the arguments of the
    sequence functions were of type <type>text</>, not <type>regclass</>, and
    the above-described conversion from a text string to an OID value would
    happen at run time during each call.  For backward compatibility, this
    facility still exists, but internally it is now handled as an implicit
    coercion from <type>text</> to <type>regclass</> before the function is
    invoked.
-->
<productname>PostgreSQL</productname> 8.1以前においては、シーケンス関数の引数は<type>regclass</>型ではなく、<type>text</>型で、そして上記のテキスト文字列からOID値への変換はそれぞれの呼び出し実行時に起こりました。
後方互換性のため、この仕組みはまだ存在しますが、内部的には関数が実行される前に<type>text</>から<type>regclass</>への暗黙的強制型変換として現在処理されています。
   </para>

   <para>
<!--
    When you write the argument of a sequence function as an unadorned
    literal string, it becomes a constant of type <type>regclass</>.
    Since this is really just an OID, it will track the originally
    identified sequence despite later renaming, schema reassignment,
    etc.  This <quote>early binding</> behavior is usually desirable for
    sequence references in column defaults and views.  But sometimes you might
    want <quote>late binding</> where the sequence reference is resolved
    at run time.  To get late-binding behavior, force the constant to be
    stored as a <type>text</> constant instead of <type>regclass</>:
-->
ありのままのリテラル文字列としてシーケンス関数の引数を記述する時は、<type>regclass</>データ型の定数になります。
これは単にOIDなので、後で名前付けが再び行われたとか、スキーマの再割り振りとかに係わらず、最初に特定されたシーケンスを引き継ぎます。
この<quote>初期束縛</>の動作は、通常列のデフォルトとビュー参照するシーケンスにとって魅力があります
。しかし、たまには実行時にシーケンス参照が解決されるような<quote>動的束縛</>が望まれます。動的束縛の動作を得るには、定数を<type>regclass</>ではなく<type>text</>定数としてその定数を保存させます。
<programlisting>
<!--
nextval('foo'::text)      <lineannotation><literal>foo</literal> is looked up at runtime</>
  -->
nextval('foo'::text)      <lineannotation>実行時に<literal>foo</literal>を探す</>
</programlisting>
<!--
    Note that late binding was the only behavior supported in
    <productname>PostgreSQL</productname> releases before 8.1, so you
    might need to do this to preserve the semantics of old applications.
-->
動的束縛は<productname>PostgreSQL</productname>のリリース8.1以前でサポートされた動作であったので、旧来のアプリケーションのセマンティクスを保ちたい場合このようにする必要があるかもしれません。
   </para>

   <para>
<!--
    Of course, the argument of a sequence function can be an expression
    as well as a constant.  If it is a text expression then the implicit
    coercion will result in a run-time lookup.
-->
もちろん、シーケンス関数の引数は定数とともに、評価式であることも可能です。
もしテキスト式の場合は暗黙的強制型変換が実行時検索に用いられます。
   </para>
  </note>

  <para>
<!--
   The available sequence functions are:
-->
使用できるシーケンス関数には以下のものがあります。

    <variablelist>
     <varlistentry>
      <term><function>nextval</function></term>
      <listitem>
       <para>
<!--
        Advance the sequence object to its next value and return that
        value.  This is done atomically: even if multiple sessions
        execute <function>nextval</function> concurrently, each will safely receive
        a distinct sequence value.
-->
シーケンスオブジェクトをその次の値に進め、その値を返します。
これは自動的に処理されます。複数のセッションが同時に<function>nextval</function>を実行したとしても、それぞれのセッションは個別のシーケンス値を間違いなく受け取ります。
       </para>

       <para>
<!--
        If a sequence object has been created with default parameters,
        successive <function>nextval</function> calls will return successive
        values beginning with 1.  Other behaviors can be obtained by using
        special parameters in the <xref linkend="sql-createsequence"> command;
        see its command reference page for more information.
-->
デフォルトのパラメータによってシーケンスオブジェクトが作成されているなら、引き続く<function>nextval</function>呼び出しは１から始まる連続的な値を返します。
その他の動作を<xref linkend="sql-createsequence">コマンドの特別なパラメータを使用してさせることが可能です。より詳しくはコマンドのリファレンスガイドを参照ください。
       </para>

       <important>
        <para>
<!--
         To avoid blocking concurrent transactions that obtain numbers from the
         same sequence, a <function>nextval</function> operation is never
         rolled back; that is, once a value has been fetched it is considered
         used, even if the transaction that did the
         <function>nextval</function> later aborts.  This means that aborted
         transactions might leave unused <quote>holes</quote> in the sequence
         of assigned values.
-->
同一のシーケンスから数値を取得する同時実行トランザクション同士のブロックを防止するため、<function>nextval</function>演算は決してロールバックされません。
と言うことは、たとえ<function>nextval</function>を実行したトランザクションが後にアボートしたとしても、値が一度取り出されたらそれは使用されたものと考えます。
つまり、アボートされたトランザクションは、割り当てられた値のシーケンス内に未使用の<quote>欠損</quote>を残す可能性があります。
        </para>
       </important>

      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>currval</function></term>
      <listitem>
       <para>
<!--
        Return the value most recently obtained by <function>nextval</function>
        for this sequence in the current session.  (An error is
        reported if <function>nextval</function> has never been called for this
        sequence in this session.)  Because this is returning
        a session-local value, it gives a predictable answer whether or not
        other sessions have executed <function>nextval</function> since the
        current session did.
-->
現在のセッションにおいて、そのシーケンスから<function>nextval</function>によって取得された直近の値を返します。
（セッション内でそのシーケンスに対し<function>nextval</function>が呼ばれていない場合には、エラーが報告されます。）
これはローカルのセッション値を返すことから、現在のセッションが実行してから別のセッションが<function>nextval</function>を実行してもしなくても、予想に違わない回答をもたらします。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>lastval</function></term>
      <listitem>
       <para>
<!--
        Return the value most recently returned by
        <function>nextval</> in the current session. This function is
        identical to <function>currval</function>, except that instead
        of taking the sequence name as an argument it fetches the
        value of the last sequence used by <function>nextval</function>
        in the current session. It is an error to call
        <function>lastval</function> if <function>nextval</function>
        has not yet been called in the current session.
-->
現在のセッションの<function>nextval</>で戻される最新の値を返します。
この関数は、現在のセッションの中で<function>nextval</function>によって使用される最後のシーケンスの値をフェッチする引数としてのシーケンス名を取ることを除いて、<function>currval</function>と同等です。
現在のセッションで<function>nextval</function>が未だ呼ばれていなければエラーになります。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>setval</function></term>
      <listitem>
       <para>
<!--
        Reset the sequence object's counter value.  The two-parameter
        form sets the sequence's <literal>last_value</literal> field to the
        specified value and sets its <literal>is_called</literal> field to
        <literal>true</literal>, meaning that the next
        <function>nextval</function> will advance the sequence before
        returning a value.  The value reported by <function>currval</> is
        also set to the specified value.  In the three-parameter form,
        <literal>is_called</literal> can be set to either <literal>true</literal>
        or <literal>false</literal>.  <literal>true</> has the same effect as
        the two-parameter form. If it is set to <literal>false</literal>, the
        next <function>nextval</function> will return exactly the specified
        value, and sequence advancement commences with the following
        <function>nextval</function>.  Furthermore, the value reported by
        <function>currval</> is not changed in this case.  For example,
-->
シーケンスオブジェクトの計数値をリセットします。
２つのパラメータを所有する形式では、シーケンスの<literal>last_value</literal>フィールドを指定された値に設定し、<literal>is_called</literal>フィールドを<literal>true</literal>（真）に設定します。この意味は、次の<function>nextval</function>が値を返す前にシーケンスを進めるということです。
<function>currval</>で報告された値も指定された値に設定されます。
３パラメータ形式の場合、<literal>is_called</literal>を<literal>true</literal>（真）もしくは<literal>false</literal>（偽）に設定することができます。<literal>true</>（真）は２パラメータ形式と同じ効果があります。
<literal>false</literal>（偽）に設定された場合、次の<function>nextval</function>が指定された正確な値を返し、シーケンスの進行は引き続く<function>nextval</function>から始まります。
さらにこの場合、<function>currval</>で報告された値は変更されません。
例えば、次の例です。

<screen>
<!--
SELECT setval('foo', 42);           <lineannotation>Next <function>nextval</> will return 43</lineannotation>
SELECT setval('foo', 42, true);     <lineannotation>Same as above</lineannotation>
SELECT setval('foo', 42, false);    <lineannotation>Next <function>nextval</> will return 42</lineannotation>
-->
SELECT setval('foo', 42);           <lineannotation>次の<function>nextval</>は43を返す</lineannotation>
SELECT setval('foo', 42, true);     <lineannotation>上と同じ</lineannotation>
SELECT setval('foo', 42, false);    <lineannotation>次の<function>nextval</>は42を返す</lineannotation>
</screen>

<!--
        The result returned by <function>setval</function> is just the value of its
        second argument.
-->
<function>setval</function>によって返される結果は単にその第2番目の引数の値です。
       </para>
       <important>
        <para>
<!--
         Because sequences are non-transactional, changes made by
         <function>setval</function> are not undone if the transaction rolls
         back.
-->
シーケンスは非トランザクショナルに扱われるため、<function>setval</function>による変更は、そのトランザクションがロールバックされたとしても元に戻りません。
        </para>
       </important>
      </listitem>
     </varlistentry>
    </variablelist>
  </para>

 </sect1>


 <sect1 id="functions-conditional">
<!--
  <title>Conditional Expressions</title>
-->
  <title>条件式</title>

  <indexterm>
   <primary>CASE</primary>
  </indexterm>

  <indexterm>
<!--
   <primary>conditional expression</primary>
-->
   <primary>条件式</primary>
  </indexterm>

  <para>
<!--
   This section describes the <acronym>SQL</acronym>-compliant conditional expressions
   available in <productname>PostgreSQL</productname>.
-->
本節では<productname>PostgreSQL</productname>で使用可能な<acronym>SQL</acronym>準拠の条件式について説明します。
  </para>

  <tip>
   <para>
<!--
    If your needs go beyond the capabilities of these conditional
    expressions, you might want to consider writing a stored procedure
    in a more expressive programming language.
-->
ここで説明する条件式より発展した機能を求める場合は、より表現の豊富なプログラム言語でストアドプロシージャを記述することで解決されます。
   </para>
  </tip>

  <sect2 id="functions-case">
   <title><literal>CASE</></title>

  <para>
<!--
   The <acronym>SQL</acronym> <token>CASE</token> expression is a
   generic conditional expression, similar to if/else statements in
   other programming languages:
-->
<acronym>SQL</acronym>の<token>CASE</token>式は他のプログラミング言語のif/else構文に類似した汎用条件式です。

<synopsis>
CASE WHEN <replaceable>condition</replaceable> THEN <replaceable>result</replaceable>
     <optional>WHEN ...</optional>
     <optional>ELSE <replaceable>result</replaceable></optional>
END
</synopsis>

<!--
   <token>CASE</token> clauses can be used wherever
   an expression is valid.  Each <replaceable>condition</replaceable> is an
   expression that returns a <type>boolean</type> result.  If the condition's
   result is true, the value of the <token>CASE</token> expression is the
   <replaceable>result</replaceable> that follows the condition, and the
   remainder of the <token>CASE</token> expression is not processed.  If the
   condition's result is not true, any subsequent <token>WHEN</token> clauses
   are examined in the same manner.  If no <token>WHEN</token>
   <replaceable>condition</replaceable> yields true, the value of the
   <token>CASE</> expression is the <replaceable>result</replaceable> of the
   <token>ELSE</token> clause.  If the <token>ELSE</token> clause is
   omitted and no condition is true, the result is null.
-->
<token>CASE</token>句は式が有効な位置であればどこでも使用可能です。
それぞれの<replaceable>condition</replaceable>とは<type>boolean</type>型の結果を返す式です。
もしconditionの結果が真であれば、<token>CASE</token>式の値は、conditionに続く<replaceable>result</replaceable>となります。そして、<token>CASE</token>式の残りは処理されません。
もしconditionの結果が偽であれば後に続く全ての<token>WHEN</token>句が同じようにして調べられます。
<token>WHEN</token>の<replaceable>condition</replaceable>の1つも真でない場合、CASE式の値は<token>ELSE</token>句の<replaceable>result</replaceable>になります。
<token>ELSE</token>句が省略され、どのconditionも真でない場合、結果はNULLです。
  </para>

   <para>
<!--
    An example:
-->
以下に例を示します。
<screen>
SELECT * FROM test;

 a
---
 1
 2
 3


SELECT a,
       CASE WHEN a=1 THEN 'one'
            WHEN a=2 THEN 'two'
            ELSE 'other'
       END
    FROM test;

 a | case
---+-------
 1 | one
 2 | two
 3 | other
</screen>
   </para>

  <para>
<!--
   The data types of all the <replaceable>result</replaceable>
   expressions must be convertible to a single output type.
   See <xref linkend="typeconv-union-case"> for more details.
-->
全ての<replaceable>result</replaceable>式のデータ型は単一の出力型に互換性がなければなりません。
詳細は<xref linkend="typeconv-union-case">を参照してください。
  </para>

  <para>
<!--
   There is a <quote>simple</> form of <token>CASE</token> expression
   that is a variant of the general form above:
-->
以下のように、上記の一般的な形式と異なる<token>CASE</token>式の<quote>単純な</>形式が存在します。

<synopsis>
CASE <replaceable>expression</replaceable>
    WHEN <replaceable>value</replaceable> THEN <replaceable>result</replaceable>
    <optional>WHEN ...</optional>
    <optional>ELSE <replaceable>result</replaceable></optional>
END
</synopsis>

<!--
   The first
   <replaceable>expression</replaceable> is computed, then compared to
   each of the <replaceable>value</replaceable> expressions in the
   <token>WHEN</token> clauses until one is found that is equal to it.  If
   no match is found, the <replaceable>result</replaceable> of the
   <token>ELSE</token> clause (or a null value) is returned.  This is similar
   to the <function>switch</function> statement in C.
-->
最初の<replaceable>expression</replaceable>は計算され、そしてそれに等しいものが見つかるまで<token>WHEN</token>句のそれぞれの<replaceable>value</replaceable>式と比較されます。
等しいものが見つからない場合、<token>ELSE</token>句の<replaceable>result</replaceable>（もしくはNULL値）が返されます。
これはC言語の<function>switch</function>文に似ています。
  </para>

   <para>
<!--
    The example above can be written using the simple
    <token>CASE</token> syntax:
-->
上の例は簡略形<token>CASE</token>構文を使って次のように書くことができます。
<screen>
SELECT a,
       CASE a WHEN 1 THEN 'one'
              WHEN 2 THEN 'two'
              ELSE 'other'
       END
    FROM test;

 a | case
---+-------
 1 | one
 2 | two
 3 | other
</screen>
   </para>

   <para>
<!--
    A <token>CASE</token> expression does not evaluate any subexpressions
    that are not needed to determine the result.  For example, this is a
    possible way of avoiding a division-by-zero failure:
-->
<token>CASE</token>式は、結果を決定するために不必要などんな副式をも評価しません。
例えば、以下は0除算エラーを防ぐための方法です。
<programlisting>
SELECT ... WHERE CASE WHEN x &lt;&gt; 0 THEN y/x &gt; 1.5 ELSE false END;
</programlisting>
   </para>

   <note>
    <para>
<!--
     As described in <xref linkend="xfunc-volatility">, functions and
     operators marked <literal>IMMUTABLE</literal> can be evaluated when
     the query is planned rather than when it is executed.  This means
     that constant parts of a subexpression that is not evaluated during
     query execution might still be evaluated during query planning.
-->
<xref linkend="xfunc-volatility">にて説明したとおり、<literal>IMMUTABLE</literal>と指摘された関数と引数は、それが実行される時点ではなく問い合わせが計画された時点で評価されます。
このことが意味するのは、問い合わせ実行時点で評価されない副文脈の一定部分が問い合わせ計画の期間でも未だに評価され続けるということです。
    </para>
   </note>
  </sect2>

  <sect2 id="functions-coalesce-nvl-ifnull">
   <title><literal>COALESCE</></title>

  <indexterm>
   <primary>COALESCE</primary>
  </indexterm>

  <indexterm>
   <primary>NVL</primary>
  </indexterm>

  <indexterm>
   <primary>IFNULL</primary>
  </indexterm>

<synopsis>
<function>COALESCE</function>(<replaceable>value</replaceable> <optional>, ...</optional>)
</synopsis>

  <para>
<!--
   The <function>COALESCE</function> function returns the first of its
   arguments that is not null.  Null is returned only if all arguments
   are null.  It is often used to substitute a default value for
   null values when data is retrieved for display, for example:
-->
<function>COALESCE</function>関数は、NULLでない自身の最初の引数を返します。
全ての引数がNULLの場合にのみNULLが返されます。データを表示目的で取り出す際、NULL値をデフォルト値で置き換えるためによく使用されています。以下に例を示します。
<programlisting>
SELECT COALESCE(description, short_description, '(none)') ...
</programlisting>
<!--
   This returns <varname>description</> if it is not null, otherwise
   <varname>short_description</> if it is not null, otherwise <literal>(none)</>.
-->
これは<varname>description</>がNULLでなければをそれ返します。そうでない場合(NULLの場合)は、<varname>short_description</>がNULLでなければそれを返します。そうでもない場合は<literal>(none)</>が帰ります。
  </para>

   <para>
<!--
    Like a <token>CASE</token> expression, <function>COALESCE</function> only
    evaluates the arguments that are needed to determine the result;
    that is, arguments to the right of the first non-null argument are
    not evaluated.  This SQL-standard function provides capabilities similar
    to <function>NVL</> and <function>IFNULL</>, which are used in some other
    database systems.
-->
<token>CASE</token>式同様、<function>COALESCE</function>は結果を決定するために必要な引数のみを評価します。つまり、非NULL引数が見つかれば、その右側にある引数は評価されません。
このSQL標準関数は<function>NVL</>と<function>IFNULL</>と類似の機能を提供し、他のいくつかのデータベースシステムで使用されています。
   </para>
  </sect2>

  <sect2 id="functions-nullif">
   <title><literal>NULLIF</></title>

  <indexterm>
   <primary>NULLIF</primary>
  </indexterm>

<synopsis>
<function>NULLIF</function>(<replaceable>value1</replaceable>, <replaceable>value2</replaceable>)
</synopsis>

  <para>
<!--
   The <function>NULLIF</function> function returns a null value if
   <replaceable>value1</replaceable> equals <replaceable>value2</replaceable>;
   otherwise it returns <replaceable>value1</replaceable>.
   This can be used to perform the inverse operation of the
   <function>COALESCE</function> example given above:
-->
<function>NULLIF</function>関数は、<replaceable>value1</replaceable>が<replaceable>value2</replaceable>と等しい場合、NULL値を返します。
その他の場合は<replaceable>value1</replaceable>を返します。
これを使って、上記の<function>COALESCE</function>の例の逆演算を実行できます
<programlisting>
SELECT NULLIF(value, '(none)') ...
</programlisting>
  </para>
  <para>
<!--
   In this example, if <literal>value</literal> is <literal>(none)</>,
   null is returned, otherwise the value of <literal>value</literal>
   is returned.
-->
この例では、<replaceable>value1</replaceable>が<literal>(none)</>ならばNULLが返ります。
さもなくば<replaceable>value1</replaceable>を返します
  </para>

  </sect2>

  <sect2 id="functions-greatest-least">
<!--
   <title><literal>GREATEST</literal> and <literal>LEAST</literal></title>
-->
   <title><literal>GREATEST</literal>および<literal>LEAST</literal></title>

  <indexterm>
   <primary>GREATEST</primary>
  </indexterm>
  <indexterm>
   <primary>LEAST</primary>
  </indexterm>

<synopsis>
<function>GREATEST</function>(<replaceable>value</replaceable> <optional>, ...</optional>)
</synopsis>
<synopsis>
<function>LEAST</function>(<replaceable>value</replaceable> <optional>, ...</optional>)
</synopsis>

   <para>
<!--
    The <function>GREATEST</> and <function>LEAST</> functions select the
    largest or smallest value from a list of any number of expressions.
    The expressions must all be convertible to a common data type, which
    will be the type of the result
    (see <xref linkend="typeconv-union-case"> for details).  NULL values
    in the list are ignored.  The result will be NULL only if all the
    expressions evaluate to NULL.
-->
<function>GREATEST</>と<function>LEAST</>関数は式の任意の数のリストから最大値もしくは最小値を選択します。
評価される全ての式は、結果として得られるデータの型と共通の型に変換できなくてはなりません（詳細は<xref linkend="typeconv-union-case">を参照してください）。
リストの中のNULL値は無視されます。
全ての式がNULLと評価された場合に限って結果はNULLになります。
   </para>

   <para>
<!--
    Note that <function>GREATEST</> and <function>LEAST</> are not in
    the SQL standard, but are a common extension.  Some other databases
    make them return NULL if any argument is NULL, rather than only when
    all are NULL.
-->
<function>GREATEST</>および<function>LEAST</>はSQL標準に載っていませんが、共通した拡張です。
他のいくつかのデータベースでは、全てがNULLの場合に限定せず、いずれかの引数がNULLである場合にNULLを返すようにしているものもあります。
   </para>
  </sect2>
 </sect1>

 <sect1 id="functions-array">
<!--
  <title>Array Functions and Operators</title>
-->
  <title>配列関数と演算子</title>

  <para>
<!--
   <xref linkend="array-operators-table"> shows the operators
   available for array types.
-->
<xref linkend="array-operators-table">に、配列型で使用可能な演算子を示します。
  </para>

    <table id="array-operators-table">
<!--
     <title>Array Operators</title>
-->
     <title>配列演算子</title>
     <tgroup cols="4">
      <thead>
       <row>
<!--
        <entry>Operator</entry>
        <entry>Description</entry>
        <entry>Example</entry>
        <entry>Result</entry>
-->
        <entry>演算子</entry>
        <entry>説明</entry>
        <entry>例</entry>
        <entry>結果</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry> <literal>=</literal> </entry>
<!--
        <entry>equal</entry>
-->
        <entry>等しい</entry>
        <entry><literal>ARRAY[1.1,2.1,3.1]::int[] = ARRAY[1,2,3]</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>&lt;&gt;</literal> </entry>
<!--
        <entry>not equal</entry>
-->
        <entry>等しくない</entry>
        <entry><literal>ARRAY[1,2,3] &lt;&gt; ARRAY[1,2,4]</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>&lt;</literal> </entry>
<!--
        <entry>less than</entry>
-->
        <entry>未満</entry>
        <entry><literal>ARRAY[1,2,3] &lt; ARRAY[1,2,4]</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>&gt;</literal> </entry>
<!--
        <entry>greater than</entry>
-->
        <entry>より大きい</entry>
        <entry><literal>ARRAY[1,4,3] &gt; ARRAY[1,2,4]</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>&lt;=</literal> </entry>
<!--
        <entry>less than or equal</entry>
-->
        <entry>以下</entry>
        <entry><literal>ARRAY[1,2,3] &lt;= ARRAY[1,2,3]</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>&gt;=</literal> </entry>
<!--
        <entry>greater than or equal</entry>
-->
        <entry>以上</entry>
        <entry><literal>ARRAY[1,4,3] &gt;= ARRAY[1,4,3]</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>@&gt;</literal> </entry>
<!--
        <entry>contains</entry>
-->
        <entry>包含する</entry>
        <entry><literal>ARRAY[1,4,3] @&gt; ARRAY[3,1]</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>&lt;@</literal> </entry>
<!--
        <entry>is contained by</entry>
-->
        <entry>・・・により包含される</entry>
        <entry><literal>ARRAY[2,7] &lt;@ ARRAY[1,7,4,2,6]</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>&amp;&amp;</literal> </entry>
<!--
        <entry>overlap (have elements in common)</entry>
-->
        <entry>重複する(共通要素を持つ)</entry>
        <entry><literal>ARRAY[1,4,3] &amp;&amp; ARRAY[2,1]</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>||</literal> </entry>
<!--
        <entry>array-to-array concatenation</entry>
-->
        <entry>配列と配列を連結</entry>
        <entry><literal>ARRAY[1,2,3] || ARRAY[4,5,6]</literal></entry>
        <entry><literal>{1,2,3,4,5,6}</literal></entry>
       </row>

       <row>
        <entry> <literal>||</literal> </entry>
<!--
        <entry>array-to-array concatenation</entry>
-->
        <entry>配列と配列を連結</entry>
        <entry><literal>ARRAY[1,2,3] || ARRAY[[4,5,6],[7,8,9]]</literal></entry>
        <entry><literal>{{1,2,3},{4,5,6},{7,8,9}}</literal></entry>
       </row>

       <row>
        <entry> <literal>||</literal> </entry>
<!--
        <entry>element-to-array concatenation</entry>
-->
        <entry>要素と配列を連結</entry>
        <entry><literal>3 || ARRAY[4,5,6]</literal></entry>
        <entry><literal>{3,4,5,6}</literal></entry>
       </row>

       <row>
        <entry> <literal>||</literal> </entry>
<!--
        <entry>array-to-element concatenation</entry>
-->
        <entry>配列と要素を連結</entry>
        <entry><literal>ARRAY[4,5,6] || 7</literal></entry>
        <entry><literal>{4,5,6,7}</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

  <para>
<!--
   Array comparisons compare the array contents element-by-element,
   using the default B-tree comparison function for the element data type.
   In multidimensional arrays the elements are visited in row-major order
   (last subscript varies most rapidly).
   If the contents of two arrays are equal but the dimensionality is
   different, the first difference in the dimensionality information
   determines the sort order.  (This is a change from versions of
   <productname>PostgreSQL</> prior to 8.2: older versions would claim
   that two arrays with the same contents were equal, even if the
   number of dimensions or subscript ranges were different.)
-->
配列比較では、配列要素ごとに、要素のデータ型のデフォルトのB-tree比較関数を使用して、その内容が比較されます。
多次元配列では、行番号を優先して取り出します（最後の添え字が最も最初になります）。
2つの配列で内容が同じで要素数が異なる場合、どの次元で最初に違いがあったかによってソート順が変わります。
（これは8.2より前の<productname>PostgreSQL</>では異なります。古いバージョンでは、次数や添え字範囲が異なっていたとしても、内容が同じであれば、2つの配列は同じものとしていました。）
  </para>

  <para>
<!--
   See <xref linkend="arrays"> for more details about array operator
   behavior.  See <xref linkend="indexes-types"> for more details about
   which operators support indexed operations.
-->
配列演算子の振舞いの詳細は<xref linkend="arrays">を参照してください。
どの演算子がインデックス付きの操作をサポートしているかのより詳細については<xref linkend="indexes-types">を参照してください。
  </para>

  <para>
<!--
   <xref linkend="array-functions-table"> shows the functions
   available for use with array types. See <xref linkend="arrays">
   for more information  and examples of the use of these functions.
-->
<xref linkend="array-functions-table">に配列型で使用可能な関数を示します。
これらの関数の情報と例については<xref linkend="arrays">を参照してください。
  </para>

  <indexterm>
    <primary>array_append</primary>
  </indexterm>
  <indexterm>
    <primary>array_cat</primary>
  </indexterm>
  <indexterm>
    <primary>array_ndims</primary>
  </indexterm>
  <indexterm>
    <primary>array_dims</primary>
  </indexterm>
  <indexterm>
    <primary>array_fill</primary>
  </indexterm>
  <indexterm>
    <primary>array_length</primary>
  </indexterm>
  <indexterm>
    <primary>array_lower</primary>
  </indexterm>
  <indexterm>
    <primary>array_prepend</primary>
  </indexterm>
  <indexterm>
    <primary>array_remove</primary>
  </indexterm>
  <indexterm>
    <primary>array_replace</primary>
  </indexterm>
  <indexterm>
    <primary>array_to_string</primary>
  </indexterm>
 <indexterm>
    <primary>array_upper</primary>
  </indexterm>
  <indexterm>
    <primary>cardinality</primary>
  </indexterm>
  <indexterm>
    <primary>string_to_array</primary>
  </indexterm>
  <indexterm>
    <primary>unnest</primary>
  </indexterm>

    <table id="array-functions-table">
<!--
     <title>Array Functions</title>
-->
     <title>配列関数</title>
     <tgroup cols="5">
      <thead>
       <row>
<!--
        <entry>Function</entry>
        <entry>Return Type</entry>
        <entry>Description</entry>
        <entry>Example</entry>
        <entry>Result</entry>
-->
        <entry>関数</entry>
        <entry>戻り値型</entry>
        <entry>説明</entry>
        <entry>例</entry>
        <entry>結果</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>
         <literal>
          <function>array_append</function>(<type>anyarray</type>, <type>anyelement</type>)
         </literal>
        </entry>
        <entry><type>anyarray</type></entry>
<!--
        <entry>append an element to the end of an array</entry>
-->
        <entry>配列の末尾に要素を追加</entry>
        <entry><literal>array_append(ARRAY[1,2], 3)</literal></entry>
        <entry><literal>{1,2,3}</literal></entry>
       </row>
       <row>
        <entry>
         <literal>
          <function>array_cat</function>(<type>anyarray</type>, <type>anyarray</type>)
         </literal>
        </entry>
        <entry><type>anyarray</type></entry>
<!--
        <entry>concatenate two arrays</entry>
-->
        <entry>２つの配列を連結</entry>
        <entry><literal>array_cat(ARRAY[1,2,3], ARRAY[4,5])</literal></entry>
        <entry><literal>{1,2,3,4,5}</literal></entry>
       </row>
       <row>
        <entry>
         <literal>
          <function>array_ndims</function>(<type>anyarray</type>)
         </literal>
        </entry>
        <entry><type>int</type></entry>
<!--
        <entry>returns the number of dimensions of the array</entry>
-->
        <entry>その配列の次数を返す</entry>
        <entry><literal>array_ndims(ARRAY[[1,2,3], [4,5,6]])</literal></entry>
        <entry><literal>2</literal></entry>
       </row>
       <row>
        <entry>
         <literal>
          <function>array_dims</function>(<type>anyarray</type>)
         </literal>
        </entry>
        <entry><type>text</type></entry>
<!--
        <entry>returns a text representation of array's dimensions</entry>
-->
        <entry>配列の次数をテキスト表現で返す</entry>
        <entry><literal>array_dims(ARRAY[[1,2,3], [4,5,6]])</literal></entry>
        <entry><literal>[1:2][1:3]</literal></entry>
       </row>
       <row>
        <entry>
         <literal>
          <function>array_fill</function>(<type>anyelement</type>, <type>int[]</type>,
          <optional>, <type>int[]</type></optional>)
         </literal>
        </entry>
        <entry><type>anyarray</type></entry>
<!--
        <entry>returns an array initialized with supplied value and
         dimensions, optionally with lower bounds other than 1</entry>
-->
         <entry>提供された値と次数で初期化された配列を返す。１以外の下限を持たせることもできます</entry>
        <entry><literal>array_fill(7, ARRAY[3], ARRAY[2])</literal></entry>
        <entry><literal>[2:4]={7,7,7}</literal></entry>
       </row>
       <row>
        <entry>
         <literal>
          <function>array_length</function>(<type>anyarray</type>, <type>int</type>)
         </literal>
        </entry>
        <entry><type>int</type></entry>
<!--
        <entry>returns the length of the requested array dimension</entry>
-->
        <entry>入力された配列次元の長さを返す</entry>
        <entry><literal>array_length(array[1,2,3], 1)</literal></entry>
        <entry><literal>3</literal></entry>
       </row>
       <row>
        <entry>
         <literal>
          <function>array_lower</function>(<type>anyarray</type>, <type>int</type>)
         </literal>
        </entry>
        <entry><type>int</type></entry>
<!--
        <entry>returns lower bound of the requested array dimension</entry>
-->
        <entry>配列次元の下限を返す</entry>
        <entry><literal>array_lower('[0:2]={1,2,3}'::int[], 1)</literal></entry>
        <entry><literal>0</literal></entry>
       </row>
       <row>
        <entry>
         <literal>
          <function>array_prepend</function>(<type>anyelement</type>, <type>anyarray</type>)
         </literal>
        </entry>
        <entry><type>anyarray</type></entry>
<!--
        <entry>append an element to the beginning of an array</entry>
-->
        <entry>配列の先頭に要素を追加</entry>
        <entry><literal>array_prepend(1, ARRAY[2,3])</literal></entry>
        <entry><literal>{1,2,3}</literal></entry>
       </row>
       <row>
        <entry>
         <literal>
          <function>array_remove</function>(<type>anyarray</type>, <type>anyelement</type>)
         </literal>
        </entry>
        <entry><type>anyarray</type></entry>
<!--
        <entry>remove all elements equal to the given value from the array
         (array must be one-dimensional)</entry>
-->
        <entry>配列から与えられた値と等しい全ての要素を削除（配列は一次元）</entry>
        <entry><literal>array_remove(ARRAY[1,2,3,2], 2)</literal></entry>
        <entry><literal>{1,3}</literal></entry>
       </row>
       <row>
        <entry>
         <literal>
          <function>array_replace</function>(<type>anyarray</type>, <type>anyelement</type>, <type>anyelement</type>)
         </literal>
        </entry>
        <entry><type>anyarray</type></entry>
<!--
        <entry>replace each array element equal to the given value with a new value</entry>
-->
        <entry>新規値で与えられた値と等しいそれぞれの要素を置換</entry>
        <entry><literal>array_replace(ARRAY[1,2,5,4], 5, 3)</literal></entry>
        <entry><literal>{1,2,3,4}</literal></entry>
       </row>
       <row>
        <entry>
         <literal>
          <function>array_to_string</function>(<type>anyarray</type>, <type>text</type> <optional>, <type>text</type></optional>)
         </literal>
        </entry>
        <entry><type>text</type></entry>
<!--
        <entry>concatenates array elements using supplied delimiter and
         optional null string</entry>
-->
        <entry>配列の要素を提供された区切り文字、および省略可能なNULL文字を使用して連結</entry>
        <entry><literal>array_to_string(ARRAY[1, 2, 3, NULL, 5], ',', '*')</literal></entry>
        <entry><literal>1,2,3,*,5</literal></entry>
       </row>
       <row>
        <entry>
         <literal>
          <function>array_upper</function>(<type>anyarray</type>, <type>int</type>)
         </literal>
        </entry>
        <entry><type>int</type></entry>
<!--
        <entry>returns upper bound of the requested array dimension</entry>
-->
        <entry>入力された配列の次元の上限を返す</entry>
        <entry><literal>array_upper(ARRAY[1,8,3,7], 1)</literal></entry>
        <entry><literal>4</literal></entry>
       </row>
       <row>
        <entry>
         <literal>
          <function>cardinality</function>(<type>anyarray</type>)
         </literal>
        </entry>
        <entry><type>int</type></entry>
<!--
        <entry>returns the total number of elements in the array, or 0 if the array is empty</entry>
-->
        <entry>配列の中の要素の総数を返す。配列が空であれば0</entry>
        <entry><literal>cardinality(ARRAY[[1,2],[3,4]])</literal></entry>
        <entry><literal>4</literal></entry>
       </row>
       <row>
        <entry>
         <literal>
          <function>string_to_array</function>(<type>text</type>, <type>text</type> <optional>, <type>text</type></optional>)
         </literal>
        </entry>
        <entry><type>text[]</type></entry>
<!--
        <entry>splits string into array elements using supplied delimiter and
         optional null string</entry>
-->
        <entry>提供された区切り文字、および省略可能なNULL文字を使用して、文字列を配列の要素に分割</entry>
        <entry><literal>string_to_array('xx~^~yy~^~zz', '~^~', 'yy')</literal></entry>
        <entry><literal>{xx,NULL,zz}</literal></entry>
       </row>
       <row>
        <entry>
         <literal>
          <function>unnest</function>(<type>anyarray</type>)
         </literal>
        </entry>
        <entry><type>setof anyelement</type></entry>
<!--
        <entry>expand an array to a set of rows</entry>
-->
        <entry>配列を行集合に展開</entry>
        <entry><literal>unnest(ARRAY[1,2])</literal></entry>
        <entry><literallayout class="monospaced">1
2</literallayout>(2 rows)</entry>
       </row>
       <row>
        <entry>
         <literal>
          <function>unnest</function>(<type>anyarray</type>, <type>anyarray</type> [, ...])
         </literal>
        </entry>
        <entry><type>setof anyelement, anyelement [, ...]</type></entry>
<!--
        <entry>expand multiple arrays (possibly of different types) to a set
         of rows.  This is only allowed in the FROM clause; see
         <xref linkend="queries-tablefunctions"></entry>
-->
        <entry>(型が異なっているかもしれない)複数の配列の行の集合への展開。これはFROM句の中でのみ許されている。<xref linkend="queries-tablefunctions">を参照</entry>
        <entry><literal>unnest(ARRAY[1,2],ARRAY['foo','bar','baz'])</literal></entry>
        <entry><literallayout class="monospaced">1    foo
2    bar
NULL baz</literallayout>(3 rows)</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
<!--
    In <function>string_to_array</function>, if the delimiter parameter is
    NULL, each character in the input string will become a separate element in
    the resulting array.  If the delimiter is an empty string, then the entire
    input string is returned as a one-element array.  Otherwise the input
    string is split at each occurrence of the delimiter string.
-->
<function>string_to_array</function>では、もし区切り文字がNULLの場合、入力された文字列の各々の文字が分割され要素となった配列を返します。
区切り文字が空白文字の場合、入力された文字列全体が一つの要素となる配列を返します。そうでなければ、入力された文字列が区切り文字で分割されます。
   </para>

   <para>
<!--
    In <function>string_to_array</function>, if the null-string parameter
    is omitted or NULL, none of the substrings of the input will be replaced
    by NULL.
    In <function>array_to_string</function>, if the null-string parameter
    is omitted or NULL, any null elements in the array are simply skipped
    and not represented in the output string.
-->
<function>string_to_array</function>では、NULL文字パラメータが省略、もしくはNULLの指定がされた場合、入力された部分文字列がNULLに変換されることはありません。
<function>array_to_string</function>では、NULL文字パラメータが省略、もしくはNULLの指定がされた場合、すべてのNULL文字の処理がスキップされて出力文字列に現れることはありません。
   </para>

   <note>
    <para>
<!--
     There are two differences in the behavior of <function>string_to_array</>
     from pre-9.1 versions of <productname>PostgreSQL</>.
     First, it will return an empty (zero-element) array rather than NULL when
     the input string is of zero length.  Second, if the delimiter string is
     NULL, the function splits the input into individual characters, rather
     than returning NULL as before.
-->
<function>string_to_array</>は、<productname>PostgreSQL</>9.1から、前のバージョンとは2つの異なる振る舞いするようになりました。
1つ目は、入力した文字列長が0の場合、NULLを返すのではなく空の(要素が0の)配列を返すようになりました。
2つ目は区切り文字がNULLの場合、以前はNULLを返していましたが9.1からは入力文字列を個別の文字列で分割するようになりました。
    </para>
   </note>

   <para>
<!--
    See also <xref linkend="functions-aggregate"> about the aggregate
    function <function>array_agg</function> for use with arrays.
-->
配列を伴った集約関数の使用法は、<xref linkend="functions-aggregate">も参照してください。
   </para>
  </sect1>

 <sect1 id="functions-range">
<!--
  <title>Range Functions and Operators</title>
-->
  <title>範囲関数と演算子</title>

  <para>
<!--
   See <xref linkend="rangetypes"> for an overview of range types.
-->
範囲型の概要に関しては<xref linkend="rangetypes">を参照してください。
  </para>

  <para>
<!--
   <xref linkend="range-operators-table"> shows the operators
   available for range types.
-->
範囲型に対して利用可能な演算子を<xref linkend="range-operators-table">に示します。
  </para>

    <table id="range-operators-table">
<!--
     <title>Range Operators</title>
-->
     <title>範囲演算子</title>
     <tgroup cols="4">
      <thead>
       <row>
<!--
        <entry>Operator</entry>
        <entry>Description</entry>
        <entry>Example</entry>
        <entry>Result</entry>
-->
        <entry>演算子</entry>
        <entry>説明</entry>
        <entry>例</entry>
        <entry>結果</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry> <literal>=</literal> </entry>
<!--
        <entry>equal</entry>
-->
        <entry>等しい</entry>
        <entry><literal>int4range(1,5) = '[1,4]'::int4range</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>&lt;&gt;</literal> </entry>
<!--
        <entry>not equal</entry>
-->
        <entry>等しくない</entry>
        <entry><literal>numrange(1.1,2.2) &lt;&gt; numrange(1.1,2.3)</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>&lt;</literal> </entry>
<!--
        <entry>less than</entry>
-->
        <entry>未満</entry>
        <entry><literal>int4range(1,10) &lt; int4range(2,3)</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>&gt;</literal> </entry>
<!--
        <entry>greater than</entry>
-->
        <entry>より大きい</entry>
        <entry><literal>int4range(1,10) &gt; int4range(1,5)</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>&lt;=</literal> </entry>
<!--
        <entry>less than or equal</entry>
-->
        <entry>以下</entry>
        <entry><literal>numrange(1.1,2.2) &lt;= numrange(1.1,2.2)</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>&gt;=</literal> </entry>
<!--
        <entry>greater than or equal</entry>
-->
        <entry>以上</entry>
        <entry><literal>numrange(1.1,2.2) &gt;= numrange(1.1,2.0)</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>@&gt;</literal> </entry>
<!--
        <entry>contains range</entry>
-->
        <entry>範囲を包含する</entry>
        <entry><literal>int4range(2,4) @&gt; int4range(2,3)</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>@&gt;</literal> </entry>
<!--
        <entry>contains element</entry>
-->
        <entry>要素を包含する</entry>
        <entry><literal>'[2011-01-01,2011-03-01)'::tsrange @&gt; '2011-01-10'::timestamp</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>&lt;@</literal> </entry>
<!--
        <entry>range is contained by</entry>
-->
        <entry>・・・により範囲が包含される</entry>
        <entry><literal>int4range(2,4) &lt;@ int4range(1,7)</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>&lt;@</literal> </entry>
<!--
        <entry>element is contained by</entry>
-->
        <entry>・・・により要素が包含される</entry>
        <entry><literal>42 &lt;@ int4range(1,7)</literal></entry>
        <entry><literal>f</literal></entry>
       </row>

       <row>
        <entry> <literal>&amp;&amp;</literal> </entry>
<!--
        <entry>overlap (have points in common)</entry>
-->
        <entry>重複する(共通点を持つ)</entry>
        <entry><literal>int8range(3,7) &amp;&amp; int8range(4,12)</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>&lt;&lt;</literal> </entry>
<!--
        <entry>strictly left of</entry>
-->
        <entry>厳密に左に位置する</entry>
        <entry><literal>int8range(1,10) &lt;&lt; int8range(100,110)</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>&gt;&gt;</literal> </entry>
<!--
        <entry>strictly right of</entry>
-->
        <entry>厳密に右に位置する</entry>
        <entry><literal>int8range(50,60) &gt;&gt; int8range(20,30)</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>&amp;&lt;</literal> </entry>
<!--
        <entry>does not extend to the right of</entry>
-->
        <entry>右側を越えない</entry>
        <entry><literal>int8range(1,20) &amp;&lt; int8range(18,20)</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>&amp;&gt;</literal> </entry>
<!--
        <entry>does not extend to the left of</entry>
-->
        <entry>左側を越えない</entry>
        <entry><literal>int8range(7,20) &amp;&gt; int8range(5,10)</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>-|-</literal> </entry>
<!--
        <entry>is adjacent to</entry>
-->
        <entry>隣接</entry>
        <entry><literal>numrange(1.1,2.2) -|- numrange(2.2,3.3)</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>+</literal> </entry>
<!--
        <entry>union</entry>
-->
        <entry>結合範囲</entry>
        <entry><literal>numrange(5,15) + numrange(10,20)</literal></entry>
        <entry><literal>[5,20)</literal></entry>
       </row>

       <row>
        <entry> <literal>*</literal> </entry>
<!--
        <entry>intersection</entry>
-->
        <entry>交差範囲</entry>
        <entry><literal>int8range(5,15) * int8range(10,20)</literal></entry>
        <entry><literal>[10,15)</literal></entry>
       </row>

       <row>
        <entry> <literal>-</literal> </entry>
<!--
        <entry>difference</entry>
-->
        <entry>差分範囲</entry>
        <entry><literal>int8range(5,15) - int8range(10,20)</literal></entry>
        <entry><literal>[5,10)</literal></entry>
       </row>

      </tbody>
     </tgroup>
    </table>

  <para>
<!--
   The simple comparison operators <literal>&lt;</literal>,
   <literal>&gt;</literal>, <literal>&lt;=</literal>, and
   <literal>&gt;=</literal> compare the lower bounds first, and only if those
   are equal, compare the upper bounds.  These comparisons are not usually
   very useful for ranges, but are provided to allow B-tree indexes to be
   constructed on ranges.
-->
単純な比較演算子である<literal>&lt;</literal>、<literal>&gt;</literal>、<literal>&lt;=</literal>そして<literal>&gt;=</literal>は、最初に下限の境界を比較し、それらが等しい場合のみ上限の境界を比較する。
これらの比較演算子は、範囲型のデータに関しては大抵便利なものではありませんが、範囲型へB-treeインデックスを付与するのに必要なため提供されています。
  </para>

  <para>
<!--
   The left-of/right-of/adjacent operators always return false when an empty
   range is involved; that is, an empty range is not considered to be either
   before or after any other range.
-->
左に位置する/右に位置する/隣接の演算子は、空の範囲が呼ばれた際は常に偽を返します。つまり、空の範囲に対しては、他のどの範囲の前後のどちらであるかは考慮されないということです。
  </para>

  <para>
<!--
   The union and difference operators will fail if the resulting range would
   need to contain two disjoint sub-ranges, as such a range cannot be
   represented.
-->
結合範囲と差分範囲演算子は、もし得られる結果が互いに離れた2つの範囲を含む必要がある場合、このような範囲を表現することができないため失敗するでしょう。
  </para>

  <para>
<!--
   <xref linkend="range-functions-table"> shows the functions
   available for use with range types.
-->
範囲型に対して利用可能な関数を<xref linkend="range-functions-table">に示します。
  </para>

  <indexterm>
    <primary>lower</primary>
  </indexterm>
  <indexterm>
    <primary>upper</primary>
  </indexterm>
  <indexterm>
    <primary>isempty</primary>
  </indexterm>
  <indexterm>
    <primary>lower_inc</primary>
  </indexterm>
  <indexterm>
    <primary>upper_inc</primary>
  </indexterm>
  <indexterm>
    <primary>lower_inf</primary>
  </indexterm>
  <indexterm>
    <primary>upper_inf</primary>
  </indexterm>

    <table id="range-functions-table">
<!--
     <title>Range Functions</title>
-->
     <title>範囲関数</title>
     <tgroup cols="5">
      <thead>
       <row>
<!--
        <entry>Function</entry>
        <entry>Return Type</entry>
        <entry>Description</entry>
        <entry>Example</entry>
        <entry>Result</entry>
-->
        <entry>関数</entry>
        <entry>戻り値型</entry>
        <entry>説明</entry>
        <entry>例</entry>
        <entry>結果</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>
         <literal>
          <function>lower</function>(<type>anyrange</type>)
         </literal>
        </entry>
<!--
        <entry>range's element type</entry>
        <entry>lower bound of range</entry>
-->
        <entry>範囲の要素の型</entry>
        <entry>範囲の下限</entry>
        <entry><literal>lower(numrange(1.1,2.2))</literal></entry>
        <entry><literal>1.1</literal></entry>
       </row>
       <row>
        <entry>
         <literal>
          <function>upper</function>(<type>anyrange</type>)
         </literal>
        </entry>
<!--
        <entry>range's element type</entry>
        <entry>upper bound of range</entry>
-->
        <entry>範囲の要素の型</entry>
        <entry>範囲の上限</entry>
        <entry><literal>upper(numrange(1.1,2.2))</literal></entry>
        <entry><literal>2.2</literal></entry>
       </row>
       <row>
        <entry>
         <literal>
          <function>isempty</function>(<type>anyrange</type>)
         </literal>
        </entry>
        <entry><type>boolean</type></entry>
<!--
        <entry>is the range empty?</entry>
-->
        <entry>空の範囲か？</entry>
        <entry><literal>isempty(numrange(1.1,2.2))</literal></entry>
        <entry><literal>false</literal></entry>
       </row>
       <row>
        <entry>
         <literal>
          <function>lower_inc</function>(<type>anyrange</type>)
         </literal>
        </entry>
        <entry><type>boolean</type></entry>
<!--
        <entry>is the lower bound inclusive?</entry>
-->
        <entry>下限は内包されているか？</entry>
        <entry><literal>lower_inc(numrange(1.1,2.2))</literal></entry>
        <entry><literal>true</literal></entry>
       </row>
       <row>
        <entry>
         <literal>
          <function>upper_inc</function>(<type>anyrange</type>)
         </literal>
        </entry>
        <entry><type>boolean</type></entry>
<!--
        <entry>is the upper bound inclusive?</entry>
-->
        <entry>上限は内包されているか？</entry>
        <entry><literal>upper_inc(numrange(1.1,2.2))</literal></entry>
        <entry><literal>false</literal></entry>
       </row>
       <row>
        <entry>
         <literal>
          <function>lower_inf</function>(<type>anyrange</type>)
         </literal>
        </entry>
        <entry><type>boolean</type></entry>
<!--
        <entry>is the lower bound infinite?</entry>
-->
        <entry>下限は無限大か？</entry>
        <entry><literal>lower_inf('(,)'::daterange)</literal></entry>
        <entry><literal>true</literal></entry>
       </row>
       <row>
        <entry>
         <literal>
          <function>upper_inf</function>(<type>anyrange</type>)
         </literal>
        </entry>
        <entry><type>boolean</type></entry>
<!--
        <entry>is the upper bound infinite?</entry>
-->
        <entry>上限は無限大か？</entry>
        <entry><literal>upper_inf('(,)'::daterange)</literal></entry>
        <entry><literal>true</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

  <para>
<!--
   The <function>lower</> and  <function>upper</> functions return null
   if the range is empty or the requested bound is infinite.
   The <function>lower_inc</function>, <function>upper_inc</function>,
   <function>lower_inf</function>, and <function>upper_inf</function>
   functions all return false for an empty range.
-->
<function>lower</>と<function>upper</>関数は、もし範囲が空か対象の境界が無限大だった場合、NULLを返します。
<function>lower_inc</function>、<function>upper_inc</function>、<function>lower_inf</function>、そして<function>upper_inf</function>関数は、空の範囲に対しては全て偽を返します。
  </para>
  </sect1>

 <sect1 id="functions-aggregate">
<!--
  <title>Aggregate Functions</title>
-->
  <title>集約関数</title>

  <indexterm zone="functions-aggregate">
<!--
   <primary>aggregate function</primary>
-->
   <primary>集約関数</primary>
   <secondary>built-in</secondary>
  </indexterm>

  <para>
<!--
   <firstterm>Aggregate functions</firstterm> compute a single result
   from a set of input values.  The built-in normal aggregate functions
   are listed in
   <xref linkend="functions-aggregate-table"> and
   <xref linkend="functions-aggregate-statistics-table">.
   The built-in ordered-set aggregate functions
   are listed in <xref linkend="functions-orderedset-table"> and
   <xref linkend="functions-hypothetical-table">.
   The special syntax considerations for aggregate
   functions are explained in <xref linkend="syntax-aggregates">.
   Consult <xref linkend="tutorial-agg"> for additional introductory
   information.
-->
<firstterm>集約関数</firstterm>は複数の入力値から単一の結果を計算します。
<xref linkend="functions-aggregate-table">および<xref linkend="functions-aggregate-statistics-table">に通常の組み込み集約関数を示します。
<xref linkend="functions-orderedset-table">および<xref linkend="functions-hypothetical-table">には組み込みの順序集合集約関数を示します。
集約関数の特殊な構文に関する考察は<xref linkend="syntax-aggregates">で説明されています。
また、初歩的な情報については<xref linkend="tutorial-agg">を参照して下さい。
  </para>

  <table id="functions-aggregate-table">
<!--
   <title>General-Purpose Aggregate Functions</title>
-->
   <title>汎用集約関数</title>

   <tgroup cols="4">
    <thead>
     <row>
<!--
      <entry>Function</entry>
      <entry>Argument Type(s)</entry>
      <entry>Return Type</entry>
      <entry>Description</entry>
-->
      <entry>関数</entry>
      <entry>引数のデータ型</entry>
      <entry>戻り値型</entry>
      <entry>説明</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>
       <indexterm>
        <primary>array_agg</primary>
       </indexterm>
       <function>array_agg(<replaceable class="parameter">expression</replaceable>)</function>
      </entry>
      <entry>
       any
      </entry>
      <entry>
<!--
       array of the argument type
-->
       引数型の配列
      </entry>
<!--
      <entry>input values, including nulls, concatenated into an array</entry>
-->
      <entry>配列に連結されたNULLを含む入力値</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>average</primary>
       </indexterm>
       <indexterm>
        <primary>avg</primary>
       </indexterm>
       <function>avg(<replaceable class="parameter">expression</replaceable>)</function>
      </entry>
      <entry>
       <type>smallint</type>, <type>int</type>,
       <type>bigint</type>, <type>real</type>, <type>double
       precision</type>, <type>numeric</type>, or <type>interval</type>
      </entry>
      <entry>
<!--
       <type>numeric</type> for any integer-type argument,
       <type>double precision</type> for a floating-point argument,
       otherwise the same as the argument data type
-->
       整数型の引数であれば全て<type>numeric</type>、浮動小数点の引数であれば<type>double precision</type>、それ以外は引数のデータ型と同じ
      </entry>
<!--
      <entry>the average (arithmetic mean) of all input values</entry>
-->
      <entry>全ての入力値の平均値（算術平均）</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>bit_and</primary>
       </indexterm>
       <function>bit_and(<replaceable class="parameter">expression</replaceable>)</function>
      </entry>
      <entry>
       <type>smallint</type>, <type>int</type>, <type>bigint</type>, or
       <type>bit</type>
      </entry>
      <entry>
<!--
        same as argument data type
-->
        引数のデータ型と同じ
      </entry>
<!--
      <entry>the bitwise AND of all non-null input values, or null if none</entry>
-->
      <entry>全ての非NULLの入力値のビット積、非NULLの入力値がなければNULL</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>bit_or</primary>
       </indexterm>
       <function>bit_or(<replaceable class="parameter">expression</replaceable>)</function>
      </entry>
      <entry>
<!--
       <type>smallint</type>, <type>int</type>, <type>bigint</type>, or
       <type>bit</type>
-->
       <type>smallint</type>、<type>int</type>、<type>bigint</type>、または
       <type>bit</type>
      </entry>
      <entry>
<!--
        same as argument data type
-->
        引数のデータ型と同じ
      </entry>
<!--
      <entry>the bitwise OR of all non-null input values, or null if none</entry>
-->
      <entry>全ての非NULLの入力値のビット和、非NULLの入力値がなければNULL</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>bool_and</primary>
       </indexterm>
       <function>bool_and(<replaceable class="parameter">expression</replaceable>)</function>
      </entry>
      <entry>
       <type>bool</type>
      </entry>
      <entry>
       <type>bool</type>
      </entry>
<!--
      <entry>true if all input values are true, otherwise false</entry>
-->
      <entry>全ての入力が真ならば真、そうでなければ偽</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>bool_or</primary>
       </indexterm>
       <function>bool_or(<replaceable class="parameter">expression</replaceable>)</function>
      </entry>
      <entry>
       <type>bool</type>
      </entry>
      <entry>
       <type>bool</type>
      </entry>
<!--
      <entry>true if at least one input value is true, otherwise false</entry>
-->
      <entry>少なくとも1つの入力値が真ならば真。そうでなければ偽</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>count</primary>
       </indexterm>
       <function>count(*)</function>
      </entry>
      <entry></entry>
      <entry><type>bigint</type></entry>
<!--
      <entry>number of input rows</entry>
-->
      <entry>入力行の数</entry>
     </row>

     <row>
      <entry><function>count(<replaceable class="parameter">expression</replaceable>)</function></entry>
      <entry>any</entry>
      <entry><type>bigint</type></entry>
      <entry>
<!--
       number of input rows for which the value of <replaceable
       class="parameter">expression</replaceable> is not null
-->
       <replaceable class="parameter">expression</replaceable>が非NULL値を持つ入力行の個数
      </entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>every</primary>
       </indexterm>
       <function>every(<replaceable class="parameter">expression</replaceable>)</function>
      </entry>
      <entry>
       <type>bool</type>
      </entry>
      <entry>
       <type>bool</type>
      </entry>
<!--
      <entry>equivalent to <function>bool_and</function></entry>
-->
      <entry><function>bool_and</function>と等価</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>json_agg</primary>
       </indexterm>
       <function>json_agg(<replaceable class="parameter">record</replaceable>)</function>
      </entry>
      <entry>
       <type>record</type>
      </entry>
      <entry>
       <type>json</type>
      </entry>
<!--
      <entry>aggregates records as a JSON array of objects</entry>
-->
      <entry>オブジェクトのJSON配列としてレコードを集約</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>json_object_agg</primary>
       </indexterm>
       <function>json_object_agg(<replaceable class="parameter">name</replaceable>, <replaceable class="parameter">value</replaceable>)</function>
      </entry>
      <entry>
       <type>("any", "any")</type>
      </entry>
      <entry>
       <type>json</type>
      </entry>
<!--
      <entry>aggregates name/value pairs as a JSON object</entry>
-->
      <entry>名前/値の対をJSONオブジェクトとして集約</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>max</primary>
       </indexterm>
       <function>max(<replaceable class="parameter">expression</replaceable>)</function>
      </entry>
<!--
      <entry>any array, numeric, string, or date/time type</entry>
-->
      <entry>全ての配列、数値、文字列、または日付時刻型</entry>
<!--
      <entry>same as argument type</entry>
-->
      <entry>引数の型と同じ</entry>
      <entry>
<!--
       maximum value of <replaceable
       class="parameter">expression</replaceable> across all input
       values
-->
       全ての入力値にわたり<replaceable class="parameter">expression</replaceable>の最大値
      </entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>min</primary>
       </indexterm>
       <function>min(<replaceable class="parameter">expression</replaceable>)</function>
      </entry>
<!--
      <entry>any array, numeric, string, or date/time type</entry>
-->
      <entry>全ての配列、数値、文字列、または日付時刻型</entry>
<!--
      <entry>same as argument type</entry>
-->
      <entry>引数の型と同じ</entry>
      <entry>
<!--
       minimum value of <replaceable
       class="parameter">expression</replaceable> across all input
       values
-->
       全ての入力値にわたり<replaceable class="parameter">expression</replaceable>の最小値
      </entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>string_agg</primary>
       </indexterm>
       <function>
         string_agg(<replaceable class="parameter">expression</replaceable>,
                    <replaceable class="parameter">delimiter</replaceable>)
       </function>
      </entry>
      <entry>
<!--
       (<type>text</type>, <type>text</type>) or (<type>bytea</type>, <type>bytea</type>)
-->
       (<type>text</type>, <type>text</type>)または(<type>bytea</type>, <type>bytea</type>)
      </entry>
      <entry>
<!--
       same as argument types
-->
       引数と同じ型
      </entry>
<!--
      <entry>input values concatenated into a string, separated by delimiter</entry>
-->
      <entry>入力された値が指定したデリミタで区切られた一つの文字列に連結されます。</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>sum</primary>
       </indexterm>
       <function>sum(<replaceable class="parameter">expression</replaceable>)</function>
      </entry>
      <entry>
<!--
       <type>smallint</type>, <type>int</type>,
       <type>bigint</type>, <type>real</type>, <type>double
       precision</type>, <type>numeric</type>,
       <type>interval</type>, or <type>money</>
-->
       <type>smallint</type>、<type>int</type>、<type>bigint</type>、<type>real</type>、<type>double precision</type>、<type>numeric</type>、<type>interval</type>または<type>money</>
      </entry>
      <entry>
<!--
       <type>bigint</type> for <type>smallint</type> or
       <type>int</type> arguments, <type>numeric</type> for
       <type>bigint</type> arguments, otherwise the same as the
       argument data type
-->
       <type>smallint</type>または<type>int</type>型の引数であれば<type>bigint</type>、<type>bigint</type>型の引数であれば<type>numeric</type>、それ以外は引数のデータ型と同じ
      </entry>
<!--
      <entry>sum of <replaceable class="parameter">expression</replaceable> across all input values</entry>
-->
      <entry>全ての入力値に渡り<replaceable class="parameter">expression</replaceable>の和</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>xmlagg</primary>
       </indexterm>
       <function>xmlagg(<replaceable class="parameter">expression</replaceable>)</function>
      </entry>
      <entry>
       <type>xml</type>
      </entry>
      <entry>
       <type>xml</type>
      </entry>
<!--
      <entry>concatenation of XML values (see also <xref linkend="functions-xml-xmlagg">)</entry>
-->
      <entry>XML値の連結（ <xref linkend="functions-xml-xmlagg">も参照）</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
<!--
   It should be noted that except for <function>count</function>,
   these functions return a null value when no rows are selected.  In
   particular, <function>sum</function> of no rows returns null, not
   zero as one might expect, and <function>array_agg</function>
   returns null rather than an empty array when there are no input
   rows.  The <function>coalesce</function> function can be used to
   substitute zero or an empty array for null when necessary.
-->
上記の関数は、<function>count</function>関数を除き、1行も選択されなかった場合NULL値を返すことに注意してください。
特に、行の選択がない<function>sum</function>関数は、予想されるであろうゼロではなくNULLを返し、そして<function>array_agg</function>は、入力行が存在しない場合に、空配列ではなくNULLを返します。
必要であれば、NULLをゼロまたは空配列と交換する目的で<function>coalesce</function>関数を使うことができます。
  </para>

  <note>
    <indexterm>
      <primary>ANY</primary>
    </indexterm>
    <indexterm>
      <primary>SOME</primary>
    </indexterm>
    <para>
<!--
      Boolean aggregates <function>bool_and</function> and
      <function>bool_or</function> correspond to standard SQL aggregates
      <function>every</function> and <function>any</function> or
      <function>some</function>.
      As for <function>any</function> and <function>some</function>,
      it seems that there is an ambiguity built into the standard syntax:
-->
<function>bool_and</function>、<function>bool_or</function>論理集約関数は標準SQLの集約関数<function>every</function>、<function>any</function>または<function>some</function>に対応します。
<function>any</function>と<function>some</function>についてですが、標準の構文には曖昧さがあるようです。
<programlisting>
SELECT b1 = ANY((SELECT b2 FROM t2 ...)) FROM t1 ...;
</programlisting>
<!--
      Here <function>ANY</function> can be considered either as introducing
      a subquery, or as being an aggregate function, if the subquery
      returns one row with a Boolean value.
      Thus the standard name cannot be given to these aggregates.
-->
ここで、副問い合わせが論理値での１行を返す場合、<function>ANY</function>は副問い合わせを導入するもの、もしくは集約関数であるものいずれかとみなすことができます。
従って、これらの集約関数に標準の名前を付けることはできません。
    </para>
  </note>

  <note>
   <para>
<!--
    Users accustomed to working with other SQL database management
    systems might be disappointed by the performance of the
    <function>count</function> aggregate when it is applied to the
    entire table. A query like:
-->
他のSQLデータベース管理システムでの作業に親しんだユーザは、<function>count</function>集約関数がテーブル全体に適用される場合の性能に失望するかも知れません。
<programlisting>
SELECT count(*) FROM sometable;
</programlisting>
<!--
    will require effort proportional to the size of the table:
    <productname>PostgreSQL</productname> will need to scan either the
    entire table or the entirety of an index which includes all rows in
    the table.
-->
のような問い合わせはテーブルサイズに比例した労力が必要です。<productname>PostgreSQL</productname>はテーブル全体か、そのテーブルの全ての行を含んだインデックス全体のスキャンを必要とします。    

   </para>
  </note>

  <para>
<!--
   The aggregate functions <function>array_agg</function>,
   <function>json_agg</function>,
   <function>json_object_agg</function>,
   <function>string_agg</function>,
   and <function>xmlagg</function>, as well as similar user-defined
   aggregate functions, produce meaningfully different result values
   depending on the order of the input values.  This ordering is
   unspecified by default, but can be controlled by writing an
   <literal>ORDER BY</> clause within the aggregate call, as shown in
   <xref linkend="syntax-aggregates">.
   Alternatively, supplying the input values from a sorted subquery
   will usually work.  For example:
-->
集約関数<function>array_agg</function>、<function>json_agg</function>、<function>json_object_agg</function>、<function>string_agg</function>、および<function>xmlagg</function>、そして類似のユーザ定義の集約関数は、入力値の順序に依存した意味のある別の結果値を生成します。
この並び順はデフォルトでは指定されませんが、<xref linkend="syntax-aggregates">に記述されているように、集計呼び出し中に<literal>ORDER BY</>句を書くことで制御可能となります。別の方法として、並び替えられた副問い合わせから入力値を供給することでも上手くいきます。
例をあげます。

<screen><![CDATA[
SELECT xmlagg(x) FROM (SELECT x FROM test ORDER BY y DESC) AS tab;
]]></screen>

<!--
   But this syntax is not allowed in the SQL standard, and is
   not portable to other database systems.
-->
しかしこの構文はSQL標準では許されておらず、他のデータベースシステムに移植性はありません。
  </para>

  <para>
<!--
   <xref linkend="functions-aggregate-statistics-table"> shows
   aggregate functions typically used in statistical analysis.
   (These are separated out merely to avoid cluttering the listing
   of more-commonly-used aggregates.)  Where the description mentions
   <replaceable class="parameter">N</replaceable>, it means the
   number of input rows for which all the input expressions are non-null.
   In all cases, null is returned if the computation is meaningless,
   for example when <replaceable class="parameter">N</replaceable> is zero.
-->
統計解析処理によく使用される集約関数を<xref linkend="functions-aggregate-statistics-table">に示します。
（これらは、より一般的に使用される集約関数との混乱を防ぐために別出ししました。）
説明の部分における<replaceable class="parameter">N</replaceable>は、すべての入力式が非NULLの入力行の個数を表します。
すべての場合にて、例えば<replaceable class="parameter">N</replaceable>が0の時など計算が無意味である場合にはNULLが返されます。
  </para>

  <indexterm>
<!--
   <primary>statistics</primary>
-->
   <primary>統計処理</primary>
  </indexterm>
  <indexterm>
<!--
   <primary>linear regression</primary>
-->
   <primary>線形リグレッション</primary>
  </indexterm>

  <table id="functions-aggregate-statistics-table">
<!--
   <title>Aggregate Functions for Statistics</title>
-->
   <title>統計処理用の集約関数</title>

   <tgroup cols="4">
    <thead>
     <row>
<!--
      <entry>Function</entry>
      <entry>Argument Type</entry>
      <entry>Return Type</entry>
      <entry>Description</entry>
-->
      <entry>関数</entry>
      <entry>引数の型</entry>
      <entry>戻り値の型</entry>
      <entry>説明</entry>
     </row>
    </thead>

    <tbody>

     <row>
      <entry>
       <indexterm>
<!--
        <primary>correlation</primary>
-->
        <primary>相関</primary>
       </indexterm>
       <indexterm>
        <primary>corr</primary>
       </indexterm>
       <function>corr(<replaceable class="parameter">Y</replaceable>, <replaceable class="parameter">X</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
<!--
      <entry>correlation coefficient</entry>
-->
      <entry>相関係数</entry>
     </row>

     <row>
      <entry>
       <indexterm>
<!--
        <primary>covariance</primary>
        <secondary>population</secondary>
-->
        <primary>共分散</primary>
        <secondary>母集団</secondary>
       </indexterm>
       <indexterm>
        <primary>covar_pop</primary>
       </indexterm>
       <function>covar_pop(<replaceable class="parameter">Y</replaceable>, <replaceable class="parameter">X</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
<!--
      <entry>population covariance</entry>
-->
      <entry>母共分散</entry>
     </row>

     <row>
      <entry>
       <indexterm>
<!--
        <primary>covariance</primary>
        <secondary>sample</secondary>
-->
        <primary>共分散</primary>
        <secondary>標本</secondary>
       </indexterm>
       <indexterm>
        <primary>covar_samp</primary>
       </indexterm>
       <function>covar_samp(<replaceable class="parameter">Y</replaceable>, <replaceable class="parameter">X</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
<!--
      <entry>sample covariance</entry>
-->
      <entry>標本共分散</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>regr_avgx</primary>
       </indexterm>
       <function>regr_avgx(<replaceable class="parameter">Y</replaceable>, <replaceable class="parameter">X</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
<!--
      <entry>average of the independent variable
      (<literal>sum(<replaceable class="parameter">X</replaceable>)/<replaceable class="parameter">N</replaceable></literal>)</entry>
-->
      <entry>独立変数の平均値
      (<literal>sum(<replaceable class="parameter">X</replaceable>)/<replaceable class="parameter">N</replaceable></literal>)</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>regr_avgy</primary>
       </indexterm>
       <function>regr_avgy(<replaceable class="parameter">Y</replaceable>, <replaceable class="parameter">X</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
<!--
      <entry>average of the dependent variable
      (<literal>sum(<replaceable class="parameter">Y</replaceable>)/<replaceable class="parameter">N</replaceable></literal>)</entry>
-->
      <entry>依存変数の平均値
      (<literal>sum(<replaceable class="parameter">Y</replaceable>)/<replaceable class="parameter">N</replaceable></literal>)</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>regr_count</primary>
       </indexterm>
       <function>regr_count(<replaceable class="parameter">Y</replaceable>, <replaceable class="parameter">X</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>
       <type>bigint</type>
      </entry>
<!--
      <entry>number of input rows in which both expressions are nonnull</entry>
-->
      <entry>両式が非NULLとなる入力行の個数</entry>
     </row>

     <row>
      <entry>
       <indexterm>
<!--
        <primary>regression intercept</primary>
-->
        <primary>回帰切片</primary>
       </indexterm>
       <indexterm>
        <primary>regr_intercept</primary>
       </indexterm>
       <function>regr_intercept(<replaceable class="parameter">Y</replaceable>, <replaceable class="parameter">X</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
<!--
      <entry>y-intercept of the least-squares-fit linear equation
      determined by the (<replaceable
      class="parameter">X</replaceable>, <replaceable
      class="parameter">Y</replaceable>) pairs</entry>
-->
      <entry>(<replaceable class="parameter">X</replaceable>, <replaceable class="parameter">Y</replaceable>)の組み合わせで決まる、線型方程式に対する最小二乗法のY切片</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>regr_r2</primary>
       </indexterm>
       <function>regr_r2(<replaceable class="parameter">Y</replaceable>, <replaceable class="parameter">X</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
<!--
      <entry>square of the correlation coefficient</entry>
-->
      <entry>相関係数自乗値</entry>
     </row>

     <row>
      <entry>
       <indexterm>
<!--
        <primary>regression slope</primary>
-->
        <primary>回帰勾配</primary>
       </indexterm>
       <indexterm>
        <primary>regr_slope</primary>
       </indexterm>
       <function>regr_slope(<replaceable class="parameter">Y</replaceable>, <replaceable class="parameter">X</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
<!--
      <entry>slope of the least-squares-fit linear equation determined
      by the (<replaceable class="parameter">X</replaceable>,
      <replaceable class="parameter">Y</replaceable>) pairs</entry>
-->
      <entry><replaceable class="parameter">X</replaceable>, <replaceable class="parameter">Y</replaceable>)の組み合わせで決まる、最小自乗法に合う線型方程式の傾き</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>regr_sxx</primary>
       </indexterm>
       <function>regr_sxx(<replaceable class="parameter">Y</replaceable>, <replaceable class="parameter">X</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
<!--
      <entry><literal>sum(<replaceable
      class="parameter">X</replaceable>^2) - sum(<replaceable
      class="parameter">X</replaceable>)^2/<replaceable
      class="parameter">N</replaceable></literal> (<quote>sum of
      squares</quote> of the independent variable)</entry>
-->
      <entry><literal>sum(<replaceable
      class="parameter">X</replaceable>^2) - sum(<replaceable
      class="parameter">X</replaceable>)^2/<replaceable
      class="parameter">N</replaceable></literal>
     （依存変数の<quote>二乗和</quote>）
     </entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>regr_sxy</primary>
       </indexterm>
       <function>regr_sxy(<replaceable class="parameter">Y</replaceable>, <replaceable class="parameter">X</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
<!--
      <entry><literal>sum(<replaceable
      class="parameter">X</replaceable>*<replaceable
      class="parameter">Y</replaceable>) - sum(<replaceable
      class="parameter">X</replaceable>) * sum(<replaceable
      class="parameter">Y</replaceable>)/<replaceable
      class="parameter">N</replaceable></literal> (<quote>sum of
      products</quote> of independent times dependent
      variable)</entry>
-->
      <entry><literal>sum(<replaceable
      class="parameter">X</replaceable>*<replaceable
      class="parameter">Y</replaceable>) - sum(<replaceable
      class="parameter">X</replaceable>) * sum(<replaceable
      class="parameter">Y</replaceable>)/<replaceable
      class="parameter">N</replaceable></literal> 
     （依存変数×独立変数の<quote>和</quote>）
      </entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>regr_syy</primary>
       </indexterm>
       <function>regr_syy(<replaceable class="parameter">Y</replaceable>, <replaceable class="parameter">X</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
<!--
      <entry><literal>sum(<replaceable
      class="parameter">Y</replaceable>^2) - sum(<replaceable
      class="parameter">Y</replaceable>)^2/<replaceable
      class="parameter">N</replaceable></literal> (<quote>sum of
      squares</quote> of the dependent variable)</entry>
-->
      <entry><literal>sum(<replaceable
      class="parameter">Y</replaceable>^2) - sum(<replaceable
      class="parameter">Y</replaceable>)^2/<replaceable
      class="parameter">N</replaceable></literal>
     （独立変数の<quote>自乗和</quote>）</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>standard deviation</primary>
       </indexterm>
       <indexterm>
        <primary>stddev</primary>
       </indexterm>
       <function>stddev(<replaceable class="parameter">expression</replaceable>)</function>
      </entry>
      <entry>
<!--
       <type>smallint</type>, <type>int</type>,
       <type>bigint</type>, <type>real</type>, <type>double
       precision</type>, or <type>numeric</type>
-->
       <type>smallint</type>、<type>int</type>、
       <type>bigint</type>、<type>real</type>、<type>double
       precision</type>、または<type>numeric</type>
      </entry>
      <entry>
<!--
       <type>double precision</type> for floating-point arguments,
       otherwise <type>numeric</type>
-->
       浮動小数点型の引数では<type>double precision</type>。それ以外では<type>numeric</type>
      </entry>
<!--
      <entry>historical alias for <function>stddev_samp</function></entry>
-->
      <entry><function>stddev_samp</function>の歴史的な別名</entry>
     </row>

     <row>
      <entry>
       <indexterm>
<!--
        <primary>standard deviation</primary>
-->
    <primary>標準偏差</primary>
<!--
        <secondary>population</secondary>
-->
    <secondary>母集団</secondary>
       </indexterm>
       <indexterm>
        <primary>stddev_pop</primary>
       </indexterm>
       <function>stddev_pop(<replaceable class="parameter">expression</replaceable>)</function>
      </entry>
      <entry>
<!--
       <type>smallint</type>, <type>int</type>,
       <type>bigint</type>, <type>real</type>, <type>double
       precision</type>, or <type>numeric</type>
-->
       <type>smallint</type>、<type>int</type>、
       <type>bigint</type>、<type>real</type>、<type>double
       precision</type>、または<type>numeric</type>
      </entry>
      <entry>
<!--
       <type>double precision</type> for floating-point arguments,
       otherwise <type>numeric</type>
-->
       浮動小数点型の引数では<type>double precision</type>。それ以外では<type>numeric</type>
      </entry>
<!--
      <entry>population standard deviation of the input values</entry>
-->
      <entry>入力値に対する母標準偏差</entry>
     </row>

     <row>
      <entry>
       <indexterm>
<!--
        <primary>standard deviation</primary>
        <secondary>sample</secondary>
-->
        <primary>標準偏差</primary>
        <secondary>標本</secondary>
       </indexterm>
       <indexterm>
        <primary>stddev_samp</primary>
       </indexterm>
       <function>stddev_samp(<replaceable class="parameter">expression</replaceable>)</function>
      </entry>
      <entry>
<!--
       <type>smallint</type>, <type>int</type>,
       <type>bigint</type>, <type>real</type>, <type>double
       precision</type>, or <type>numeric</type>
-->
       <type>smallint</type>、<type>int</type>、
       <type>bigint</type>、<type>real</type>、<type>double
       precision</type>、または<type>numeric</type>
      </entry>
      <entry>
<!--
       <type>double precision</type> for floating-point arguments,
       otherwise <type>numeric</type>
-->
       浮動小数点型の引数では<type>double precision</type>。それ以外では<type>numeric</type>
      </entry>
<!--
      <entry>sample standard deviation of the input values</entry>
-->
      <entry>入力値に対する標本標準偏差</entry>
     </row>

     <row>
      <entry>
       <indexterm>
<!--
        <primary>variance</primary>
-->
        <primary>分散</primary>
       </indexterm>
       <function>variance</function>(<replaceable class="parameter">expression</replaceable>)
      </entry>
      <entry>
<!--
       <type>smallint</type>, <type>int</type>,
       <type>bigint</type>, <type>real</type>, <type>double
       precision</type>, or <type>numeric</type>
-->
       <type>smallint</type>、<type>int</type>、
       <type>bigint</type>、<type>real</type>、<type>double
       precision</type>、または<type>numeric</type>
      </entry>
      <entry>
<!--
       <type>double precision</type> for floating-point arguments,
       otherwise <type>numeric</type>
-->
       浮動小数点型の引数では<type>double precision</type>。それ以外では<type>numeric</type>
      </entry>
<!--
      <entry>historical alias for <function>var_samp</function></entry>
-->
      <entry><function>var_samp</function>の歴史的な別名</entry>
     </row>

     <row>
      <entry>
       <indexterm>
<!--
        <primary>variance</primary>
        <secondary>population</secondary>
-->
        <primary>分散</primary>
        <secondary>母集団</secondary>
       </indexterm>
       <indexterm>
        <primary>var_pop</primary>
       </indexterm>
       <function>var_pop</function>(<replaceable class="parameter">expression</replaceable>)
      </entry>
      <entry>
<!--
       <type>smallint</type>, <type>int</type>,
       <type>bigint</type>, <type>real</type>, <type>double
       precision</type>, or <type>numeric</type>
-->
       <type>smallint</type>、<type>int</type>、
       <type>bigint</type>、<type>real</type>、<type>double
       precision</type>、または<type>numeric</type>
      </entry>
      <entry>
<!--
       <type>double precision</type> for floating-point arguments,
       otherwise <type>numeric</type>
-->
       浮動小数点型の引数では<type>double precision</type>。それ以外では<type>numeric</type>
      </entry>
<!--
      <entry>population variance of the input values (square of the population standard deviation)</entry>
-->
      <entry>入力値に対する母分散（母標準偏差の自乗）</entry>
     </row>

     <row>
      <entry>
       <indexterm>
<!--
        <primary>variance</primary>
        <secondary>sample</secondary>
-->
        <primary>分散</primary>
        <secondary>標本</secondary>
       </indexterm>
       <indexterm>
        <primary>var_samp</primary>
       </indexterm>
       <function>var_samp</function>(<replaceable class="parameter">expression</replaceable>)
      </entry>
      <entry>
<!--
       <type>smallint</type>, <type>int</type>,
       <type>bigint</type>, <type>real</type>, <type>double
       precision</type>, or <type>numeric</type>
-->
       <type>smallint</type>、<type>int</type>、
       <type>bigint</type>、<type>real</type>、<type>double
       precision</type>、または<type>numeric</type>
      </entry>
      <entry>
<!--
       <type>double precision</type> for floating-point arguments,
       otherwise <type>numeric</type>
-->
       浮動小数点型の引数では<type>double precision</type>。それ以外では<type>numeric</type>
      </entry>
<!--
      <entry>sample variance of the input values (square of the sample standard deviation)</entry>
-->
      <entry>入力値に対する標本分散（標本標準偏差の二乗）</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
<!--
   <xref linkend="functions-orderedset-table"> shows some
   aggregate functions that use the <firstterm>ordered-set aggregate</>
   syntax.  These functions are sometimes referred to as <quote>inverse
   distribution</> functions.
-->
<xref linkend="functions-orderedset-table">に<firstterm>順序集合集約</>構文を使う集約関数を示します。
これらの関数は<quote>逆分散</>関数として参照されることがあります。
  </para>

  <indexterm>
<!--
   <primary>ordered-set aggregate</primary>
   <secondary>built-in</secondary>
-->
   <primary>順序集合集約</primary>
   <secondary>組み込み</secondary>
  </indexterm>
  <indexterm>
<!--
   <primary>inverse distribution</primary>
-->
   <primary>逆分散</primary>
  </indexterm>

  <table id="functions-orderedset-table">
<!--
   <title>Ordered-Set Aggregate Functions</title>
-->
   <title>順序集合集約関数</title>

   <tgroup cols="5">
    <thead>
     <row>
<!--
      <entry>Function</entry>
      <entry>Direct Argument Type(s)</entry>
      <entry>Aggregated Argument Type(s)</entry>
      <entry>Return Type</entry>
      <entry>Description</entry>
-->
      <entry>関数</entry>
      <entry>直接引数型</entry>
      <entry>集約された引数型</entry>
      <entry>戻り値型</entry>
      <entry>説明</entry>
     </row>
    </thead>

    <tbody>

     <row>
      <entry>
       <indexterm>
<!--
        <primary>mode</primary>
        <secondary>statistical</secondary>
-->
        <primary>最頻値(モード)</primary>
        <secondary>統計</secondary>
       </indexterm>
       <function>mode() WITHIN GROUP (ORDER BY <replaceable class="parameter">sort_expression</replaceable>)</function>
      </entry>
      <entry>
      </entry>
      <entry>
<!--
       any sortable type
-->
       ソート可能な型
      </entry>
      <entry>
<!--
       same as sort expression
-->
       ソート式と同じ
      </entry>
      <entry>
<!--
       returns the most frequent input value (arbitrarily choosing the first
       one if there are multiple equally-frequent results)
-->
       入力の最頻値を返す(複数の同じ度数の結果があれば、任意に選んだ最初のもの)
      </entry>
     </row>

     <row>
      <entry>
       <indexterm>
<!--
        <primary>percentile</primary>
        <secondary>continuous</secondary>
-->
        <primary>百分位数</primary>
        <secondary>連続</secondary>
       </indexterm>
       <indexterm>
<!--
        <primary>median</primary>
-->
        <primary>中央値(メジアン)</primary>
       </indexterm>
       <function>percentile_cont(<replaceable class="parameter">fraction</replaceable>) WITHIN GROUP (ORDER BY <replaceable class="parameter">sort_expression</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>
<!--
       <type>double precision</type> or <type>interval</type>
-->
       <type>double precision</type>または<type>interval</type>
      </entry>
      <entry>
<!--
       same as sort expression
-->
       ソート式と同じ
      </entry>
      <entry>
<!--
       continuous percentile: returns a value corresponding to the specified
       fraction in the ordering, interpolating between adjacent input items if
       needed
-->
       連続百分位数: 入力項目を並べて必要であれば隣り合うものを補間して指定された割合に対応する値を返す
      </entry>
     </row>

     <row>
      <entry>
       <function>percentile_cont(<replaceable class="parameter">fractions</replaceable>) WITHIN GROUP (ORDER BY <replaceable class="parameter">sort_expression</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision[]</type>
      </entry>
      <entry>
<!--
       <type>double precision</type> or <type>interval</type>
-->
       <type>double precision</type>または<type>interval</type>
      </entry>
      <entry>
<!--
       array of sort expression's type
-->
       ソート式の型の配列
      </entry>
      <entry>
<!--
       multiple continuous percentile: returns an array of results matching
       the shape of the <literal>fractions</literal> parameter, with each
       non-null element replaced by the value corresponding to that percentile
-->
       複数の連続百分位数: 各非NULL要素をその百分位数に対応する値で置き換えて、<literal>fractions</literal>パラメータの形に一致する結果の配列を返す
      </entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>percentile</primary>
        <secondary>discrete</secondary>
       </indexterm>
       <function>percentile_disc(<replaceable class="parameter">fraction</replaceable>) WITHIN GROUP (ORDER BY <replaceable class="parameter">sort_expression</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>
<!--
       any sortable type
-->
       ソート可能な型
      </entry>
      <entry>
<!--
       same as sort expression
-->
       ソート式と同じ
      </entry>
      <entry>
<!--
       discrete percentile: returns the first input value whose position in
       the ordering equals or exceeds the specified fraction
-->
       離散百分位数: 並べた時のその位置が指定された割合と等しいもしくは越える最初の入力値を返す
      </entry>
     </row>

     <row>
      <entry>
       <function>percentile_disc(<replaceable class="parameter">fractions</replaceable>) WITHIN GROUP (ORDER BY <replaceable class="parameter">sort_expression</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision[]</type>
      </entry>
      <entry>
<!--
       any sortable type
-->
       ソート可能な型
      </entry>
      <entry>
<!--
       array of sort expression's type
-->
       ソート式の型の配列
      </entry>
      <entry>
<!--
       multiple discrete percentile: returns an array of results matching the
       shape of the <literal>fractions</literal> parameter, with each non-null
       element replaced by the input value corresponding to that percentile
-->
       複数の離散百分位数: 各非NULL要素をその百分位数に対応する値で置き換えて、<literal>fractions</literal>パラメータの形に一致する結果の配列を返す
      </entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <para>
<!--
   All the aggregates listed in <xref linkend="functions-orderedset-table">
   ignore null values in their sorted input.  For those that take
   a <replaceable>fraction</replaceable> parameter, the fraction value must be
   between 0 and 1; an error is thrown if not.  However, a null fraction value
   simply produces a null result.
-->
<xref linkend="functions-orderedset-table">に列挙された集約はすべて整列された入力内のNULL値を無視します。
<replaceable>fraction</replaceable>パラメータを取るものでは、割合値は0と1の間でなければなりません。そうでなければエラーが投げられます。
しかしながら、割合値のNULLは単に結果のNULLを生じます。
  </para>

  <indexterm>
<!--
   <primary>hypothetical-set aggregate</primary>
   <secondary>built-in</secondary>
-->
   <primary>仮定集合集約</primary>
   <secondary>組み込み</secondary>
  </indexterm>

  <para>
<!--
   Each of the aggregates listed in
   <xref linkend="functions-hypothetical-table"> is associated with a
   window function of the same name defined in
   <xref linkend="functions-window">.  In each case, the aggregate result
   is the value that the associated window function would have
   returned for the <quote>hypothetical</> row constructed from
   <replaceable>args</replaceable>, if such a row had been added to the sorted
   group of rows computed from the <replaceable>sorted_args</replaceable>.
-->
<xref linkend="functions-hypothetical-table">に列挙されている集約は、それぞれ<xref linkend="functions-window">で定義されている同じ名前のウィンドウ関数と関連します。
それぞれの場合、集約結果は、そのような行が<replaceable>sorted_args</replaceable>から計算された行の整列されたグループに追加されるのであれば、<replaceable>args</replaceable>から構成される<quote>仮定の</>行のために関連するウィンドウ関数が返す値です。
  </para>

  <table id="functions-hypothetical-table">
<!--
   <title>Hypothetical-Set Aggregate Functions</title>
-->
   <title>仮定集合集約関数</title>

   <tgroup cols="5">
    <thead>
     <row>
<!--
      <entry>Function</entry>
      <entry>Direct Argument Type(s)</entry>
      <entry>Aggregated Argument Type(s)</entry>
      <entry>Return Type</entry>
      <entry>Description</entry>
-->
      <entry>関数</entry>
      <entry>直接引数型</entry>
      <entry>集約された引数型</entry>
      <entry>戻り値型</entry>
      <entry>説明</entry>
     </row>
    </thead>

    <tbody>

     <row>
      <entry>
       <indexterm>
<!--
        <primary>rank</primary>
        <secondary>hypothetical</secondary>
-->
        <primary>順位</primary>
        <secondary>仮定の</secondary>
       </indexterm>
       <function>rank(<replaceable class="parameter">args</replaceable>) WITHIN GROUP (ORDER BY <replaceable class="parameter">sorted_args</replaceable>)</function>
      </entry>
      <entry>
       <literal>VARIADIC</> <type>"any"</type>
      </entry>
      <entry>
       <literal>VARIADIC</> <type>"any"</type>
      </entry>
      <entry>
       <type>bigint</type>
      </entry>
      <entry>
<!--
       rank of the hypothetical row, with gaps for duplicate rows
-->
       重複する行のギャップを含む仮定の行の順位
      </entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>dense_rank</primary>
        <secondary>hypothetical</secondary>
       </indexterm>
       <function>dense_rank(<replaceable class="parameter">args</replaceable>) WITHIN GROUP (ORDER BY <replaceable class="parameter">sorted_args</replaceable>)</function>
      </entry>
      <entry>
       <literal>VARIADIC</> <type>"any"</type>
      </entry>
      <entry>
       <literal>VARIADIC</> <type>"any"</type>
      </entry>
      <entry>
       <type>bigint</type>
      </entry>
      <entry>
<!--
       rank of the hypothetical row, without gaps
-->
       ギャップを含まない仮定の行の順位
      </entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>percent_rank</primary>
        <secondary>hypothetical</secondary>
       </indexterm>
       <function>percent_rank(<replaceable class="parameter">args</replaceable>) WITHIN GROUP (ORDER BY <replaceable class="parameter">sorted_args</replaceable>)</function>
      </entry>
      <entry>
       <literal>VARIADIC</> <type>"any"</type>
      </entry>
      <entry>
       <literal>VARIADIC</> <type>"any"</type>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>
<!--
       relative rank of the hypothetical row, ranging from 0 to 1
-->
       仮定の行の相対順位、0から1まで
      </entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>cume_dist</primary>
        <secondary>hypothetical</secondary>
       </indexterm>
       <function>cume_dist(<replaceable class="parameter">args</replaceable>) WITHIN GROUP (ORDER BY <replaceable class="parameter">sorted_args</replaceable>)</function>
      </entry>
      <entry>
       <literal>VARIADIC</> <type>"any"</type>
      </entry>
      <entry>
       <literal>VARIADIC</> <type>"any"</type>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>
<!--
       relative rank of the hypothetical row, ranging from
       1/<replaceable>N</> to 1
-->
       仮定の行の相対順位、1/<replaceable>N</>から1まで
      </entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <para>
<!--
   For each of these hypothetical-set aggregates, the list of direct arguments
   given in <replaceable>args</replaceable> must match the number and types of
   the aggregated arguments given in <replaceable>sorted_args</replaceable>.
   Unlike most built-in aggregates, these aggregates are not strict, that is
   they do not drop input rows containing nulls.  Null values sort according
   to the rule specified in the <literal>ORDER BY</> clause.
-->
各仮定集合集約に対して<replaceable>args</replaceable>で与えられる直接引数のリストは、<replaceable>sorted_args</replaceable>で与えられる集約された引数の数と型と一致しなければなりません。
ほとんどの組み込み集約とは異なり、この集約は厳格ではありません、すなわち、NULLを含む入力行を落としません。
NULL値は<literal>ORDER BY</>節で指定されるルールに従って並べられます。
  </para>

 </sect1>

 <sect1 id="functions-window">
<!--
  <title>Window Functions</title>
-->
  <title>ウィンドウ関数</title>

  <indexterm zone="functions-window">
<!--
   <primary>window function</primary>
   <secondary>built-in</secondary>
-->
   <primary>ウィンドウ関数</primary>
   <secondary>組み込み</secondary>
  </indexterm>

  <para>
<!--
   <firstterm>Window functions</firstterm> provide the ability to perform
   calculations across sets of rows that are related to the current query
   row.  See <xref linkend="tutorial-window"> for an introduction to this
   feature, and <xref linkend="syntax-window-functions"> for syntax
   details.
-->
<firstterm>ウィンドウ関数</firstterm>は現在の問い合わせ行に関連した行集合に渡っての計算処理機能を提供します。
この機能の手引きは<xref linkend="tutorial-window">を、文法の詳細は<xref linkend="syntax-window-functions">を参照してください。
  </para>

  <para>
<!--
   The built-in window functions are listed in
   <xref linkend="functions-window-table">.  Note that these functions
   <emphasis>must</> be invoked using window function syntax; that is an
   <literal>OVER</> clause is required.
-->
組み込みウィンドウ関数は<xref linkend="functions-window-table">に一覧されています。
これらの関数は<emphasis>必ず</>ウィンドウ関数構文で呼び出されなければなりません。つまり、<literal>OVER</>句が必要です。
  </para>

  <para>
<!--
   In addition to these functions, any built-in or user-defined normal
   aggregate function (but not ordered-set or hypothetical-set aggregates)
   can be used as a window function; see
   <xref linkend="functions-aggregate"> for a list of the built-in aggregates.
   Aggregate functions act as window functions only when an <literal>OVER</>
   clause follows the call; otherwise they act as regular aggregates.
-->
これらの関数に加え、どんな組み込み、またはユーザ定義の通常の集約関数もウィンドウ関数として使用できます(ただし順序集合や仮定集合集約はそうではありません)。組み込み集約関数一覧は<xref linkend="functions-aggregate">を参照してください。
集約関数は、呼び出しの後<literal>OVER</>句が続いた場合のみウィンドウ関数として動作します。それ以外、通常の集約関数として動作します。
  </para>

  <table id="functions-window-table">
<!--
   <title>General-Purpose Window Functions</title>
-->
   <title>汎用ウィンドウ関数</title>

   <tgroup cols="3">
    <thead>
     <row>
<!--
      <entry>Function</entry>
      <entry>Return Type</entry>
      <entry>Description</entry>
-->
      <entry>関数</entry>
      <entry>戻り値</entry>
      <entry>説明</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>
       <indexterm>
        <primary>row_number</primary>
       </indexterm>
       <function>row_number()</function>
      </entry>
      <entry>
       <type>bigint</type>
      </entry>
<!--
      <entry>number of the current row within its partition, counting from 1</entry>
-->
      <entry>1から数えたパーティション内の現在行の数</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>rank</primary>
       </indexterm>
       <function>rank()</function>
      </entry>
      <entry>
       <type>bigint</type>
      </entry>
<!--
      <entry>rank of the current row with gaps; same as <function>row_number</> of its first peer</entry>
-->
      <entry>ギャップを含んだ現在行の順位で、その最初の（対となる）ピアの<function>row_number</>と同一</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>dense_rank</primary>
       </indexterm>
       <function>dense_rank()</function>
      </entry>
      <entry>
       <type>bigint</type>
      </entry>
<!--
      <entry>rank of the current row without gaps; this function counts peer groups</entry>
-->
      <entry>ギャップを含まない現在行の順位で、この関数は（対となる）ピアグループ数を計算する</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>percent_rank</primary>
       </indexterm>
       <function>percent_rank()</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
<!--
      <entry>relative rank of the current row: (<function>rank</> - 1) / (total rows - 1)</entry>
-->
      <entry>現在行の相対順位。 (<function>rank</> - 1) / (総行数 - 1)</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>cume_dist</primary>
       </indexterm>
       <function>cume_dist()</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
<!--
      <entry>relative rank of the current row: (number of rows preceding or peer with current row) / (total rows)</entry>
-->
      <entry>現在行の相対順位。 (先行する行または現在の行を持つピアの番号) / (総行数)</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>ntile</primary>
       </indexterm>
       <function>ntile(<replaceable class="parameter">num_buckets</replaceable> <type>integer</>)</function>
      </entry>
      <entry>
       <type>integer</type>
      </entry>
<!--
      <entry>integer ranging from 1 to the argument value, dividing the
       partition as equally as possible</entry>
-->
       <entry>できるだけ等価にパーティションで割り算した、1から引数値までの整数</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>lag</primary>
       </indexterm>
       <function>
         lag(<replaceable class="parameter">value</replaceable> <type>any</>
             [, <replaceable class="parameter">offset</replaceable> <type>integer</>
             [, <replaceable class="parameter">default</replaceable> <type>any</> ]])
       </function>
      </entry>
      <entry>
<!--
       <type>same type as <replaceable class="parameter">value</replaceable></type>
-->
       <type><replaceable class="parameter">value</replaceable>と同じ型</type>
      </entry>
      <entry>
<!--
       returns <replaceable class="parameter">value</replaceable> evaluated at
       the row that is <replaceable class="parameter">offset</replaceable>
       rows before the current row within the partition; if there is no such
       row, instead return <replaceable class="parameter">default</replaceable>.
       Both <replaceable class="parameter">offset</replaceable> and
       <replaceable class="parameter">default</replaceable> are evaluated
       with respect to the current row.  If omitted,
       <replaceable class="parameter">offset</replaceable> defaults to 1 and
       <replaceable class="parameter">default</replaceable> to null
-->
       パーティション内の現在行以前の<replaceable class="parameter">offset</replaceable>行である行で評価された<replaceable class="parameter">value</replaceable>を返します。該当する行がない場合、その代わりとして<replaceable class="parameter">default</replaceable>を返します。<replaceable class="parameter">offset</replaceable>と<replaceable class="parameter">default</replaceable>は共に現在行について評価されます。省略された場合、<replaceable class="parameter">offset</replaceable>は1となり、<replaceable class="parameter">default</replaceable>はNULLになります。
      </entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>lead</primary>
       </indexterm>
       <function>
         lead(<replaceable class="parameter">value</replaceable> <type>any</>
              [, <replaceable class="parameter">offset</replaceable> <type>integer</>
              [, <replaceable class="parameter">default</replaceable> <type>any</> ]])
       </function>
      </entry>
      <entry>
<!--
       <type>same type as <replaceable class="parameter">value</replaceable></type>
-->
       <type><replaceable class="parameter">value</replaceable>と同じ型</type>
      </entry>
      <entry>
<!--
       returns <replaceable class="parameter">value</replaceable> evaluated at
       the row that is <replaceable class="parameter">offset</replaceable>
       rows after the current row within the partition; if there is no such
       row, instead return <replaceable class="parameter">default</replaceable>.
       Both <replaceable class="parameter">offset</replaceable> and
       <replaceable class="parameter">default</replaceable> are evaluated
       with respect to the current row.  If omitted,
       <replaceable class="parameter">offset</replaceable> defaults to 1 and
       <replaceable class="parameter">default</replaceable> to null
-->
       パーティション内の現在行以降の<replaceable class="parameter">offset</replaceable>行である行で評価された<replaceable class="parameter">value</replaceable>を返します。該当する行がない場合、その代わりとして<replaceable class="parameter">default</replaceable>を返します。<replaceable class="parameter">offset</replaceable>と<replaceable class="parameter">default</replaceable>は共に現在行について評価されます。省略された場合、<replaceable class="parameter">offset</replaceable>は1となり、<replaceable class="parameter">default</replaceable>はNULLになります。
      </entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>first_value</primary>
       </indexterm>
       <function>first_value(<replaceable class="parameter">value</replaceable> <type>any</>)</function>
      </entry>
      <entry>
<!--
       <type>same type as <replaceable class="parameter">value</replaceable></type>
-->
       <type><replaceable class="parameter">value</replaceable>と同じ型</type>
      </entry>
      <entry>
<!--
       returns <replaceable class="parameter">value</replaceable> evaluated
       at the row that is the first row of the window frame
-->
       ウィンドウフレームの最初の行である行で評価された<replaceable class="parameter">value</replaceable> を返す
      </entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>last_value</primary>
       </indexterm>
       <function>last_value(<replaceable class="parameter">value</replaceable> <type>any</>)</function>
      </entry>
      <entry>
<!--
       <type>same type as <replaceable class="parameter">value</replaceable></type>
-->
       <type><replaceable class="parameter">value</replaceable>と同じ型</type>
      </entry>
      <entry>
<!--
       returns <replaceable class="parameter">value</replaceable> evaluated
       at the row that is the last row of the window frame
-->
       ウィンドウフレームの最後の行である行で評価された<replaceable class="parameter">value</replaceable> を返す
      </entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>nth_value</primary>
       </indexterm>
       <function>
         nth_value(<replaceable class="parameter">value</replaceable> <type>any</>, <replaceable class="parameter">nth</replaceable> <type>integer</>)
       </function>
      </entry>
      <entry>
<!--
       <type>same type as <replaceable class="parameter">value</replaceable></type>
-->
       <type><replaceable class="parameter">value</replaceable>と同じ型</type>
      </entry>
      <entry>
<!--
       returns <replaceable class="parameter">value</replaceable> evaluated
       at the row that is the <replaceable class="parameter">nth</replaceable>
       row of the window frame (counting from 1); null if no such row
-->
       ウィンドウフレームの（１から数えて）<replaceable class="parameter">nth</replaceable>番目の行である行で評価された<replaceable class="parameter">value</replaceable>を返す。行が存在しない場合はNULLを返す
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
<!--
   All of the functions listed in
   <xref linkend="functions-window-table"> depend on the sort ordering
   specified by the <literal>ORDER BY</> clause of the associated window
   definition.  Rows that are not distinct in the <literal>ORDER BY</>
   ordering are said to be <firstterm>peers</>; the four ranking functions
   are defined so that they give the same answer for any two peer rows.
-->
<xref linkend="functions-window-table">に列挙された関数はすべて、対応するウィンドウ定義の<literal>ORDER BY</>句で指定されるソート順に依存します。
<literal>ORDER BY</>順で重複する行は<firstterm>ピア</>と呼ばれます。
4つの順位付け関数は、任意の2つのピア間で同じ答えになるように定義されています。
  </para>

  <para>
<!--
   Note that <function>first_value</>, <function>last_value</>, and
   <function>nth_value</> consider only the rows within the <quote>window
   frame</>, which by default contains the rows from the start of the
   partition through the last peer of the current row.  This is
   likely to give unhelpful results for <function>last_value</> and
   sometimes also <function>nth_value</>.  You can redefine the frame by
   adding a suitable frame specification (<literal>RANGE</> or
   <literal>ROWS</>) to the <literal>OVER</> clause.
   See <xref linkend="syntax-window-functions"> for more information
   about frame specifications.
-->
<function>first_value</>、<function>last_value</>、<function>nth_value</>関数は<quote>ウィンドウフレーム</>内の行のみを考慮することに注意してください。
デフォルトで、ウィンドウフレームにはパーティションの先頭から現在の行の最終ピアまでの行が含まれます。
これは<function>last_value</>、または時々<function>nth_value</>では有用ではない結果を得ることになりがちです。
<literal>OVER</>句に適切なフレーム指定(<literal>RANGE</>もしくは<literal>ROWS</>)を加えることで、フレームを再定義することができます。
フレーム指定についての詳細は<xref linkend="syntax-window-functions">を参照してください。
  </para>

  <para>
<!--
   When an aggregate function is used as a window function, it aggregates
   over the rows within the current row's window frame.
   An aggregate used with <literal>ORDER BY</> and the default window frame
   definition produces a <quote>running sum</> type of behavior, which may or
   may not be what's wanted.  To obtain
   aggregation over the whole partition, omit <literal>ORDER BY</> or use
   <literal>ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING</>.
   Other frame specifications can be used to obtain other effects.
-->
集約関数をウィンドウ関数として使用する場合、現在の行のウィンドウフレーム内の行に渡って集約処理を行います。
<literal>ORDER BY</>を付けた集約、および、デフォルトのウィンドウフレーム定義では、<quote>中間和</>のような動作を行います。これが望まれる場合もあれば、望まれない場合もあります。
パーティション全体に渡る集約処理を行うためには、<literal>ORDER BY</>を省略するか<literal>ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING</>を使用してください。
他のフレーム指定を使用することで様々な結果を得ることができます。
  </para>

  <note>
   <para>
<!--
    The SQL standard defines a <literal>RESPECT NULLS</> or
    <literal>IGNORE NULLS</> option for <function>lead</>, <function>lag</>,
    <function>first_value</>, <function>last_value</>, and
    <function>nth_value</>.  This is not implemented in
    <productname>PostgreSQL</productname>: the behavior is always the
    same as the standard's default, namely <literal>RESPECT NULLS</>.
    Likewise, the standard's <literal>FROM FIRST</> or <literal>FROM LAST</>
    option for <function>nth_value</> is not implemented: only the
    default <literal>FROM FIRST</> behavior is supported.  (You can achieve
    the result of <literal>FROM LAST</> by reversing the <literal>ORDER BY</>
    ordering.)
-->
SQL標準は、<function>lead</>、<function>lag</>、<function>first_value</>、<function>last_value</>、および<function>nth_value</>に対し<literal>RESPECT NULLS</>、または<literal>IGNORE NULLS</>オプションを定義します。
これは<productname>PostgreSQL</productname>に実装されていません。動作は常に標準のデフォルトと同一です。つまり、<literal>RESPECT NULLS</>です。同様にして、標準の<function>nth_value</>に対する<literal>FROM FIRST</>、または<literal>FROM LAST</>オプションは実装されていません。デフォルトの<literal>FROM FIRST</>動作のみに対応しています。
（<literal>ORDER BY</>順序付けを逆に行うことで、<literal>FROM LAST</>の結果を得ることができます。）
   </para>
  </note>

 </sect1>

 <sect1 id="functions-subquery">
<!--
  <title>Subquery Expressions</title>
-->
  <title>副問い合わせ式</title>

  <indexterm>
   <primary>EXISTS</primary>
  </indexterm>

  <indexterm>
   <primary>IN</primary>
  </indexterm>

  <indexterm>
   <primary>NOT IN</primary>
  </indexterm>

  <indexterm>
   <primary>ANY</primary>
  </indexterm>

  <indexterm>
   <primary>ALL</primary>
  </indexterm>

  <indexterm>
   <primary>SOME</primary>
  </indexterm>

  <indexterm>
   <primary>subquery</primary>
  </indexterm>

  <para>
<!--
   This section describes the <acronym>SQL</acronym>-compliant subquery
   expressions available in <productname>PostgreSQL</productname>.
   All of the expression forms documented in this section return
   Boolean (true/false) results.
-->
本節では<productname>PostgreSQL</productname>で使用できる<acronym>SQL</acronym>準拠の副問い合わせについて説明します。
本節で記載した全ての式は結果として論理値（真/偽）を返します。
  </para>

  <sect2 id="functions-subquery-exists">
   <title><literal>EXISTS</literal></title>

<synopsis>
EXISTS (<replaceable>subquery</replaceable>)
</synopsis>

  <para>
<!--
   The argument of <token>EXISTS</token> is an arbitrary <command>SELECT</> statement,
   or <firstterm>subquery</firstterm>.  The
   subquery is evaluated to determine whether it returns any rows.
   If it returns at least one row, the result of <token>EXISTS</token> is
   <quote>true</>; if the subquery returns no rows, the result of <token>EXISTS</token>
   is <quote>false</>.
-->
<token>EXISTS</token>の引数は、任意の<command>SELECT</>文または<firstterm>副問い合わせ</firstterm>です。
副問い合わせはそれが何らかの行を返すか否かの決定のために評価されます。
もし1つでも行を返すのであれば、<token>EXISTS</token>の結果は<quote>true（真）</>となり、副問い合わせが行を返さない場合、<token>EXISTS</token>の結果は<quote>false（偽）</>となります。
  </para>

  <para>
<!--
   The subquery can refer to variables from the surrounding query,
   which will act as constants during any one evaluation of the subquery.
-->
副問い合わせは、取り囲んでいる問い合わせから変数を参照することができ、その値は副問い合わせの評価時には定数として扱われます。
  </para>

  <para>
<!--
   The subquery will generally only be executed long enough to determine
   whether at least one row is returned, not all the way to completion.
   It is unwise to write a subquery that has side effects (such as
   calling sequence functions); whether the side effects occur
   might be unpredictable.
-->
この副問い合わせは通常、最後まで実行されず、少なくとも１つの行が返されたかどうかを判定し得るに足りる時点まで実行されます。
（シーケンス関数を呼び出すような）副作用のある副問い合わせを記述することは配慮不足です。副作用が生じるかどうかは予想できません。
  </para>

  <para>
<!--
   Since the result depends only on whether any rows are returned,
   and not on the contents of those rows, the output list of the
   subquery is normally unimportant.  A common coding convention is
   to write all <literal>EXISTS</> tests in the form
   <literal>EXISTS(SELECT 1 WHERE ...)</literal>.  There are exceptions to
   this rule however, such as subqueries that use <token>INTERSECT</token>.
-->
結果は何らかの行が返されるのかのみに依存し、それらの行の内容には依存しないことから、副問い合わせの出力リストは通常重要ではありません。
よく使われるコーディング規約は、全ての<literal>EXISTS</>テストを<literal>EXISTS(SELECT 1 WHERE ...)</literal>といった形式で記述することです。
とは言っても、<token>INTERSECT</token>を使う副問い合わせのようにこの規則には例外があります。
  </para>

  <para>
<!--
   This simple example is like an inner join on <literal>col2</>, but
   it produces at most one output row for each <literal>tab1</> row,
   even if there are several matching <literal>tab2</> rows:
-->
以下の簡単な例は<literal>col2</>上の内部結合に似ていますが、しかしたとえ<literal>tab2</>の行といくつか一致したとしても<literal>tab1</>のそれぞれの行に対して最大限１つの出力行を生成します。
<screen>
SELECT col1
FROM tab1
WHERE EXISTS (SELECT 1 FROM tab2 WHERE col2 = tab1.col2);
</screen>
  </para>
  </sect2>

  <sect2 id="functions-subquery-in">
   <title><literal>IN</literal></title>

<synopsis>
<replaceable>expression</replaceable> IN (<replaceable>subquery</replaceable>)
</synopsis>

  <para>
<!--
   The right-hand side is a parenthesized
   subquery, which must return exactly one column.  The left-hand expression
   is evaluated and compared to each row of the subquery result.
   The result of <token>IN</token> is <quote>true</> if any equal subquery row is found.
   The result is <quote>false</> if no equal row is found (including the
   case where the subquery returns no rows).
-->
右辺は括弧で括られた副問い合わせで、正確に１列を返すものでなければなりません。
左辺式は評価され、副問い合わせの結果行と比較されます。
副問い合わせの行のどれかと等しい場合、<token>IN</token>の結果は<quote>true（真）</>です。
（副問い合わせが行を返さない場合を含め）等しい行が見つからない場合、結果は<quote>false（偽）</>です。
  </para>

  <para>
<!--
   Note that if the left-hand expression yields null, or if there are
   no equal right-hand values and at least one right-hand row yields
   null, the result of the <token>IN</token> construct will be null, not false.
   This is in accordance with SQL's normal rules for Boolean combinations
   of null values.
-->
左辺の式がNULLを生じる場合、または右辺の値に等しいものがなくて少なくとも1つの右辺の行がNULLを持つ場合、<token>IN</token>構文の結果は偽ではなくNULLとなることに注意してください。
これは、NULL値の論理的な組み合わせに対するSQLの標準規則に従うものです。
  </para>

  <para>
<!--
   As with <token>EXISTS</token>, it's unwise to assume that the subquery will
   be evaluated completely.
-->
<token>EXISTS</token>と同様、副問い合わせが完全に評価されると前提してはなりません。
  </para>

<synopsis>
<replaceable>row_constructor</replaceable> IN (<replaceable>subquery</replaceable>)
</synopsis>

  <para>
<!--
   The left-hand side of this form of <token>IN</token> is a row constructor,
   as described in <xref linkend="sql-syntax-row-constructors">.
   The right-hand side is a parenthesized
   subquery, which must return exactly as many columns as there are
   expressions in the left-hand row.  The left-hand expressions are
   evaluated and compared row-wise to each row of the subquery result.
   The result of <token>IN</token> is <quote>true</> if any equal subquery row is found.
   The result is <quote>false</> if no equal row is found (including the
   case where the subquery returns no rows).
-->
<token>IN</token>のこの形式の左辺は、<xref linkend="sql-syntax-row-constructors">で説明する、行のコンストラクタです。
右辺は括弧で括られた副問い合わせで、左辺の行にある式の数と正確に同じ数の列を返さなければなりません。
左辺の式は副問い合わせの結果のそれぞれの行に対し、行に関して評価、比較が行われます。
副問い合わせの行に等しいものが見つかった場合、<token>IN</token> の結果は<quote>true（真）</>となります。
（副問い合わせが行を返さない場合を含め）等しい行が見つからない場合、結果は<quote>false（偽）</>です。
  </para>

  <para>
<!--
   As usual, null values in the rows are combined per
   the normal rules of SQL Boolean expressions.  Two rows are considered
   equal if all their corresponding members are non-null and equal; the rows
   are unequal if any corresponding members are non-null and unequal;
   otherwise the result of that row comparison is unknown (null).
   If all the per-row results are either unequal or null, with at least one
   null, then the result of <token>IN</token> is null.
-->
行にあるNULL値はいつもSQLの論理式の標準規則で結合されます。
２つの行は対応する全ての構成要素が非NULLかつ等しい場合に等しいとみなされます。１つでも対応する構成要素が非NULLかつ等しくないものがあれば、２つの行は等しくないとみなされます。それ以外その行の比較結果は不明（NULL）です。
行毎の結果すべてが不等もしくはNULLの場合、少なくとも１つのNULLがあると、<token>IN</token>の結果はNULLとなります。
  </para>
  </sect2>

  <sect2 id="functions-subquery-notin">
   <title><literal>NOT IN</literal></title>

<synopsis>
<replaceable>expression</replaceable> NOT IN (<replaceable>subquery</replaceable>)
</synopsis>

  <para>
<!--
   The right-hand side is a parenthesized
   subquery, which must return exactly one column.  The left-hand expression
   is evaluated and compared to each row of the subquery result.
   The result of <token>NOT IN</token> is <quote>true</> if only unequal subquery rows
   are found (including the case where the subquery returns no rows).
   The result is <quote>false</> if any equal row is found.
-->
右辺は括弧で括られた副問い合わせで、正確に１つの列を返さなければなりません。
左辺の式は副問い合わせ結果の行それぞれに対して評価、比較されます。
（副問い合わせが行を返さない場合を含む）等しくない副問い合わせの行だけがあると、<token>NOT IN</token>の結果は<quote>true（真）</>です。
等しい行が1つでもあれば、結果は<quote>false（偽）</>です。
  </para>

  <para>
<!--
   Note that if the left-hand expression yields null, or if there are
   no equal right-hand values and at least one right-hand row yields
   null, the result of the <token>NOT IN</token> construct will be null, not true.
   This is in accordance with SQL's normal rules for Boolean combinations
   of null values.
-->
左辺の式でNULLが生じる場合、または右辺の値に等しいものがなく、少なくとも１つの右辺の式がNULLを生み出す場合、<token>NOT IN</token>構文の結果は真ではなくNULLとなることに注意してください。
これは、NULL値の論理的な組み合わせに対するSQLの標準規則に従うものです。
  </para>

  <para>
<!--
   As with <token>EXISTS</token>, it's unwise to assume that the subquery will
   be evaluated completely.
-->
<token>EXISTS</token>と同様、副問い合わせが完全に評価されると前提してはなりません。
  </para>

<synopsis>
<replaceable>row_constructor</replaceable> NOT IN (<replaceable>subquery</replaceable>)
</synopsis>

  <para>
<!--
   The left-hand side of this form of <token>NOT IN</token> is a row constructor,
   as described in <xref linkend="sql-syntax-row-constructors">.
   The right-hand side is a parenthesized
   subquery, which must return exactly as many columns as there are
   expressions in the left-hand row.  The left-hand expressions are
   evaluated and compared row-wise to each row of the subquery result.
   The result of <token>NOT IN</token> is <quote>true</> if only unequal subquery rows
   are found (including the case where the subquery returns no rows).
   The result is <quote>false</> if any equal row is found.
-->
<token>NOT IN</token>のこの形式の左辺は、<xref linkend="sql-syntax-row-constructors">で説明する行コンストラクタです。
右辺は括弧で括られた副問い合わせで、左辺の行にある式の数と正確に同じ数の列を返さなければなりません。
左辺の式は副問い合わせの結果のそれぞれの行に対し、評価、比較が行われます。
（副問い合わせが行を返さない場合を含め）副問い合わせの行に不等のもののみが見つかった場合、<token>NOT IN</token>の結果は<quote>true（真）</>となります。
等しい行が１つでも見つかった場合、結果は<quote>false（偽）</>です。
  </para>

  <para>
<!--
   As usual, null values in the rows are combined per
   the normal rules of SQL Boolean expressions.  Two rows are considered
   equal if all their corresponding members are non-null and equal; the rows
   are unequal if any corresponding members are non-null and unequal;
   otherwise the result of that row comparison is unknown (null).
   If all the per-row results are either unequal or null, with at least one
   null, then the result of <token>NOT IN</token> is null.
-->
行にあるNULL値はいつもSQLの論理式の標準規則で結合されます。
2つの行は対応する全ての構成要素が非NULLかつ等しい場合に等しいとみなされます。１つでも構成要素が非NULLかつ等しくない場合、２つの行は等しくないとみなされます。それ以外その行の比較結果は不明（NULL）です。
行毎の結果すべてが不等もしくはNULLの場合、少なくとも1つのNULLがあると、<token>NOT IN</token>の結果はNULLとなります。
  </para>
  </sect2>

  <sect2 id="functions-subquery-any-some">
   <title><literal>ANY</literal>/<literal>SOME</literal></title>

<synopsis>
<replaceable>expression</replaceable> <replaceable>operator</replaceable> ANY (<replaceable>subquery</replaceable>)
<replaceable>expression</replaceable> <replaceable>operator</replaceable> SOME (<replaceable>subquery</replaceable>)
</synopsis>

  <para>
<!--
   The right-hand side is a parenthesized
   subquery, which must return exactly one column.  The left-hand expression
   is evaluated and compared to each row of the subquery result using the
   given <replaceable>operator</replaceable>, which must yield a Boolean
   result.
   The result of <token>ANY</token> is <quote>true</> if any true result is obtained.
   The result is <quote>false</> if no true result is found (including the
   case where the subquery returns no rows).
-->
右辺は括弧で括られた副問い合わせで、正確に1つの列を返さなければなりません。
左辺の式は副問い合わせの結果行それぞれに対して、指定された<replaceable>operator</replaceable>を使用して評価、比較されます。なお、<replaceable>operator</replaceable>は結果として論理値を生成する必要があります。
真の結果が１つでもあると、<token>ANY</token>の結果は<quote>true（真）</>です。
（副問い合わせが行を返さない場合を含む）真の結果がないと、結果は<quote>false（偽）</>です。
  </para>

  <para>
<!--
   <token>SOME</token> is a synonym for <token>ANY</token>.
   <token>IN</token> is equivalent to <literal>= ANY</literal>.
-->
<token>SOME</token>は<token>ANY</token>の同義語です。
<token>IN</token>は<literal>= ANY</literal>と等価です。
  </para>

  <para>
<!--
   Note that if there are no successes and at least one right-hand row yields
   null for the operator's result, the result of the <token>ANY</token> construct
   will be null, not false.
   This is in accordance with SQL's normal rules for Boolean combinations
   of null values.
-->
成功がなく、右辺の行が演算子の結果として１つでもNULLを生成した場合、<token>ANY</token>構文の結果は偽ではなくNULLになることに注意してください。
これは、NULL値の論理的な組み合わせに対するSQLの標準規則に従うものです。
  </para>

  <para>
<!--
   As with <token>EXISTS</token>, it's unwise to assume that the subquery will
   be evaluated completely.
-->
<token>EXISTS</token>と同様、副問い合わせが完全に評価されると前提してはなりません。
  </para>

<synopsis>
<replaceable>row_constructor</replaceable> <replaceable>operator</> ANY (<replaceable>subquery</replaceable>)
<replaceable>row_constructor</replaceable> <replaceable>operator</> SOME (<replaceable>subquery</replaceable>)
</synopsis>

  <para>
<!--
   The left-hand side of this form of <token>ANY</token> is a row constructor,
   as described in <xref linkend="sql-syntax-row-constructors">.
   The right-hand side is a parenthesized
   subquery, which must return exactly as many columns as there are
   expressions in the left-hand row.  The left-hand expressions are
   evaluated and compared row-wise to each row of the subquery result,
   using the given <replaceable>operator</replaceable>.
   The result of <token>ANY</token> is <quote>true</> if the comparison
   returns true for any subquery row.
   The result is <quote>false</> if the comparison returns false for every
   subquery row (including the case where the subquery returns no
   rows).
   The result is NULL if the comparison does not return true for any row,
   and it returns NULL for at least one row.
-->
<token>ANY</token>のこの形式の左辺は、<xref linkend="sql-syntax-row-constructors">で説明されている行コンストラクタです。
右辺は括弧で括られた副問い合わせで、左辺の行にある式の数と正確に同じ数の列を返さなければなりません。
左辺の式は副問い合わせの結果のそれぞれの行に対し、与えられた<replaceable>operator</replaceable>を使用して行に関する評価、比較が行われます。
比較の結果、副問い合わせのいかなる行に対して真となる場合、<token>ANY</token>の結果は<quote>true（真）</>です。
比較の結果、副問い合わせの全ての行に対して偽となる場合（副問い合わせが行を返さないという場合も含めて）、結果は<quote>false（偽）</>です。
比較の結果、いかなる行でも真を返さず、かつ、少なくとも１つの行がNULLを返す場合、結果はNULLになります。
  </para>

  <para>
<!--
   See <xref linkend="row-wise-comparison"> for details about the meaning
   of a row constructor comparison.
-->
行コンストラクタ比較の意味についての詳細は<xref linkend="row-wise-comparison">を参照して下さい。
  </para>
  </sect2>

  <sect2 id="functions-subquery-all">
   <title><literal>ALL</literal></title>

<synopsis>
<replaceable>expression</replaceable> <replaceable>operator</replaceable> ALL (<replaceable>subquery</replaceable>)
</synopsis>

  <para>
<!--
   The right-hand side is a parenthesized
   subquery, which must return exactly one column.  The left-hand expression
   is evaluated and compared to each row of the subquery result using the
   given <replaceable>operator</replaceable>, which must yield a Boolean
   result.
   The result of <token>ALL</token> is <quote>true</> if all rows yield true
   (including the case where the subquery returns no rows).
   The result is <quote>false</> if any false result is found.
   The result is NULL if the comparison does not return false for any row,
   and it returns NULL for at least one row.
-->
右辺は括弧で括られた副問い合わせで、正確に１つの列を返さなければなりません。
左辺の式は副問い合わせの結果行それぞれに対して、指定された<replaceable>operator</replaceable>を使用して評価、比較されます。なお、<replaceable>operator</replaceable>は結果として論理値を生成する必要があります。
（副問い合わせが行を返さない場合を含む）全ての行が真になる場合、<token>ALL</token>の結果は<quote>true（真）</>です。
1つでも偽の結果があると、結果は<quote>false（偽）</>です。
比較がすべての行で偽を返さず、かつ、少なくとも1つの行でNULLを返した場合、結果はNULLとなります。
  </para>

  <para>
<!--
   <token>NOT IN</token> is equivalent to <literal>&lt;&gt; ALL</literal>.
-->
   <token>NOT IN</token>は<literal>&lt;&gt; ALL</literal>と等価です。
  </para>

  <para>
<!--
   As with <token>EXISTS</token>, it's unwise to assume that the subquery will
   be evaluated completely.
-->
<token>EXISTS</token>と同様、副問い合わせが完全に評価されると前提してはなりません。
  </para>

<synopsis>
<replaceable>row_constructor</replaceable> <replaceable>operator</replaceable> ALL (<replaceable>subquery</replaceable>)
</synopsis>

  <para>
<!--
   The left-hand side of this form of <token>ALL</token> is a row constructor,
   as described in <xref linkend="sql-syntax-row-constructors">.
   The right-hand side is a parenthesized
   subquery, which must return exactly as many columns as there are
   expressions in the left-hand row.  The left-hand expressions are
   evaluated and compared row-wise to each row of the subquery result,
   using the given <replaceable>operator</replaceable>.
   The result of <token>ALL</token> is <quote>true</> if the comparison
   returns true for all subquery rows (including the
   case where the subquery returns no rows).
   The result is <quote>false</> if the comparison returns false for any
   subquery row.
   The result is NULL if the comparison does not return false for any
   subquery row, and it returns NULL for at least one row.
-->
<token>ALL</token>のこの形式の左辺は、<xref linkend="sql-syntax-row-constructors">で説明する行コンストラクタです。
右辺は括弧で括られた副問い合わせで、左辺の行にある式の数と正確に同じ数の列を返さなければなりません。
左辺の式は副問い合わせの結果のそれぞれの行に対し、与えられた<replaceable>operator</replaceable>を使用して行に関する評価、比較が行われます。
比較した結果、すべての副問い合わせ行に対して真を返す場合（副問い合わせが行を返さないという場合も含めて）、<token>ALL</token>の結果は<quote>true（真）</>となります。
比較した結果、いずれかの副問い合わせ行で偽を返す場合、この結果は<quote>false（偽）</>となります。
比較結果がすべての副問い合わせ行に対して偽を返さず、少なくとも１行でNULLを返す場合、結果はNULLとなります。
  </para>

  <para>
<!--
   See <xref linkend="row-wise-comparison"> for details about the meaning
   of a row constructor comparison.
-->
行コンストラクタに関する比較の意味については<xref linkend="row-wise-comparison">を参照してください。
  </para>
  </sect2>

  <sect2>
<!--
   <title>Single-row Comparison</title>
-->
   <title>単独行に関する比較</title>

   <indexterm zone="functions-subquery">
<!--
    <primary>comparison</primary>
-->
    <primary>比較</primary>
<!--
    <secondary>subquery result row</secondary>
-->
    <secondary>副問い合わせ結果行</secondary>
   </indexterm>

<synopsis>
<replaceable>row_constructor</replaceable> <replaceable>operator</replaceable> (<replaceable>subquery</replaceable>)
</synopsis>

  <para>
<!--
   The left-hand side is a row constructor,
   as described in <xref linkend="sql-syntax-row-constructors">.
   The right-hand side is a parenthesized subquery, which must return exactly
   as many columns as there are expressions in the left-hand row. Furthermore,
   the subquery cannot return more than one row.  (If it returns zero rows,
   the result is taken to be null.)  The left-hand side is evaluated and
   compared row-wise to the single subquery result row.
-->
左辺は、<xref linkend="sql-syntax-row-constructors">で説明されている行コンストラクタです。
右辺は括弧で括られた副問い合わせで、左辺の行とまったく同じ数の列を返さなければなりません。さらに、副問い合わせは複数行を返すことはできません。
（行をまったく返さない場合、結果はNULLとみなされます。）
左辺は副問い合わせの結果の単一行に対し行全体で評価、比較が行われます。
  </para>

  <para>
<!--
   See <xref linkend="row-wise-comparison"> for details about the meaning
   of a row constructor comparison.
-->
行コンストラクタに関する比較の意味についての詳細は<xref linkend="row-wise-comparison">を参照してください。
  </para>
  </sect2>
 </sect1>


 <sect1 id="functions-comparisons">
<!--
  <title>Row and Array Comparisons</title>
-->
  <title>行と配列の比較</title>

  <indexterm>
   <primary>IN</primary>
  </indexterm>

  <indexterm>
   <primary>NOT IN</primary>
  </indexterm>

  <indexterm>
   <primary>ANY</primary>
  </indexterm>

  <indexterm>
   <primary>ALL</primary>
  </indexterm>

  <indexterm>
   <primary>SOME</primary>
  </indexterm>

  <indexterm>
<!--
   <primary>composite type</primary>
   <secondary>comparison</secondary>
-->
   <primary>複合型</primary>
   <secondary>比較</secondary>
  </indexterm>

  <indexterm>
<!--
   <primary>row-wise comparison</primary>
-->
   <primary>行に関する比較</primary>
  </indexterm>

  <indexterm>
<!--
   <primary>comparison</primary>
   <secondary>composite type</secondary>
-->
   <primary>比較</primary>
   <secondary>複合型</secondary>
  </indexterm>

  <indexterm>
<!--
   <primary>comparison</primary>
   <secondary>row constructor</secondary>
-->
   <primary>比較</primary>
   <secondary>行コンストラクタ</secondary>
  </indexterm>

  <indexterm>
   <primary>IS DISTINCT FROM</primary>
  </indexterm>

  <indexterm>
   <primary>IS NOT DISTINCT FROM</primary>
  </indexterm>

  <para>
<!--
   This section describes several specialized constructs for making
   multiple comparisons between groups of values.  These forms are
   syntactically related to the subquery forms of the previous section,
   but do not involve subqueries.
   The forms involving array subexpressions are
   <productname>PostgreSQL</productname> extensions; the rest are
   <acronym>SQL</acronym>-compliant.
   All of the expression forms documented in this section return
   Boolean (true/false) results.
-->
本節では、値のグループ間で複数の比較を行う、さまざまな特殊化したコンストラクトについて説明します。
この形式は構文的には、前節の副問い合わせ形式と関係しています。しかし、副問い合わせを含みません。
配列副式を含むこの形式は<productname>PostgreSQL</productname>の拡張です。この他は<acronym>SQL</acronym>準拠です。
本節で記載した全ての式形式は結果として論理値（真/偽）を返します。
  </para>

  <sect2>
   <title><literal>IN</literal></title>

<synopsis>
<replaceable>expression</replaceable> IN (<replaceable>value</replaceable> <optional>, ...</optional>)
</synopsis>

  <para>
<!--
   The right-hand side is a parenthesized list
   of scalar expressions.  The result is <quote>true</> if the left-hand expression's
   result is equal to any of the right-hand expressions.  This is a shorthand
   notation for
-->
右辺は括弧で括られたスカラ式のリストです。
左辺の式の結果が右辺の式のいずれかと等しい場合、結果は<quote>true（真）</>になります。
これは以下の省略形です。

<synopsis>
<replaceable>expression</replaceable> = <replaceable>value1</replaceable>
OR
<replaceable>expression</replaceable> = <replaceable>value2</replaceable>
OR
...
</synopsis>
  </para>

  <para>
<!--
   Note that if the left-hand expression yields null, or if there are
   no equal right-hand values and at least one right-hand expression yields
   null, the result of the <token>IN</token> construct will be null, not false.
   This is in accordance with SQL's normal rules for Boolean combinations
   of null values.
-->
左辺の式がNULLを生じる場合、または右側の値に等しいものがなくて少なくとも1つの右辺の行がNULLを持つ場合、<token>IN</token>構文の結果は偽ではなくNULLとなることに注意してください。
これは、NULL値の論理的な組み合わせに対するSQLの標準規則に従うものです。
  </para>
  </sect2>

  <sect2>
   <title><literal>NOT IN</literal></title>

<synopsis>
<replaceable>expression</replaceable> NOT IN (<replaceable>value</replaceable> <optional>, ...</optional>)
</synopsis>

  <para>
<!--
   The right-hand side is a parenthesized list
   of scalar expressions.  The result is <quote>true</quote> if the left-hand expression's
   result is unequal to all of the right-hand expressions.  This is a shorthand
   notation for
-->
右辺は括弧で括られたスカラ式のリストです。
左辺の式の結果が右辺の式の全てと等しくない場合、結果は<quote>真</>です。
これは以下の省略形です。

<synopsis>
<replaceable>expression</replaceable> &lt;&gt; <replaceable>value1</replaceable>
AND
<replaceable>expression</replaceable> &lt;&gt; <replaceable>value2</replaceable>
AND
...
</synopsis>
  </para>

  <para>
<!--
   Note that if the left-hand expression yields null, or if there are
   no equal right-hand values and at least one right-hand expression yields
   null, the result of the <token>NOT IN</token> construct will be null, not true
   as one might naively expect.
   This is in accordance with SQL's normal rules for Boolean combinations
   of null values.
-->
左辺の式でNULLが生じる場合、または右側の値に等しいものがなく、少なくとも1つの右辺の式がNULLを生み出す場合、予想通り<token>NOT IN</token>構文の結果は真ではなくNULLとなることに注意してください。
これは、NULL値の論理的な組み合わせに対するSQLの標準規則に従うものです。
  </para>

  <tip>
  <para>
<!--
   <literal>x NOT IN y</literal> is equivalent to <literal>NOT (x IN y)</literal> in all
   cases.  However, null values are much more likely to trip up the novice when
   working with <token>NOT IN</token> than when working with <token>IN</token>.
   It is best to express your condition positively if possible.
-->
全ての場合において、<literal>x NOT IN y</literal>は<literal>NOT (x IN y)</literal>と等価です。
しかし、<token>IN</token>を使用するよりも<token>NOT IN</token>を使用する方が初心者がNULL値による間違いをしやすくなります。
可能な限り条件を肯定的に表現することが最善です。
  </para>
  </tip>
  </sect2>

  <sect2>
<!--
   <title><literal>ANY</literal>/<literal>SOME</literal> (array)</title>
-->
   <title><literal>ANY</literal>/<literal>SOME</literal> (配列)</title>

<synopsis>
<replaceable>expression</replaceable> <replaceable>operator</replaceable> ANY (<replaceable>array expression</replaceable>)
<replaceable>expression</replaceable> <replaceable>operator</replaceable> SOME (<replaceable>array expression</replaceable>)
</synopsis>

  <para>
<!--
   The right-hand side is a parenthesized expression, which must yield an
   array value.
   The left-hand expression
   is evaluated and compared to each element of the array using the
   given <replaceable>operator</replaceable>, which must yield a Boolean
   result.
   The result of <token>ANY</token> is <quote>true</> if any true result is obtained.
   The result is <quote>false</> if no true result is found (including the
   case where the array has zero elements).
-->
右辺は括弧で括られた式で、配列値を返さなければなりません。
左辺の式は配列要素それぞれに対して、指定された<replaceable>operator</replaceable>を使用して評価、比較されます。なお、<replaceable>operator</replaceable>は結果として論理値を生成する必要があります。
真の結果が１つでもあると、<token>ANY</token>の結果は<quote>true（真）</>です。
（配列の要素数がゼロである場合を含み）真の結果がないと、結果は<quote>false（偽）</>です。
  </para>

  <para>
<!--
   If the array expression yields a null array, the result of
   <token>ANY</token> will be null.  If the left-hand expression yields null,
   the result of <token>ANY</token> is ordinarily null (though a non-strict
   comparison operator could possibly yield a different result).
   Also, if the right-hand array contains any null elements and no true
   comparison result is obtained, the result of <token>ANY</token>
   will be null, not false (again, assuming a strict comparison operator).
   This is in accordance with SQL's normal rules for Boolean combinations
   of null values.
-->
配列式がNULL配列を生成する場合、<token>ANY</token>の結果はNULLになります。
左辺式がNULLとなる場合、<token>ANY</token>の結果は通常NULLになります（あまり厳密でない比較演算子では異なる結果になるかもしれません）。
また、右辺の配列にNULL要素が含まれ、かつ、比較した結果真でない値になった場合、<token>ANY</token>の結果は偽ではなくNULLになります（繰り返しになりますが、厳密な演算子の場合です）。
これは、NULLに対する、SQLの論理値組み合わせに関する標準規則に従うものです。
  </para>

  <para>
<!--
   <token>SOME</token> is a synonym for <token>ANY</token>.
-->
<token>SOME</token>は<token>ANY</token>の同義語です。
  </para>
  </sect2>

  <sect2>
<!--
   <title><literal>ALL</literal> (array)</title>
-->
   <title><literal>ALL</literal> (配列)</title>

<synopsis>
<replaceable>expression</replaceable> <replaceable>operator</replaceable> ALL (<replaceable>array expression</replaceable>)
</synopsis>

  <para>
<!--
   The right-hand side is a parenthesized expression, which must yield an
   array value.
   The left-hand expression
   is evaluated and compared to each element of the array using the
   given <replaceable>operator</replaceable>, which must yield a Boolean
   result.
   The result of <token>ALL</token> is <quote>true</> if all comparisons yield true
   (including the case where the array has zero elements).
   The result is <quote>false</> if any false result is found.
-->
右辺は括弧で括られた式で、配列値を返さなければなりません。
左辺の式は配列の要素それぞれに対して、指定された<replaceable>operator</replaceable>を使用して評価、比較されます。なお、<replaceable>operator</replaceable>は結果として論理値を生成する必要があります。
（配列の要素数がゼロである場合を含み）全ての比較が真になる場合、<token>ALL</token>の結果は<quote>true（真）</>です。
1つでも偽の結果があると、結果は<quote>false（偽）</>です。
  </para>

  <para>
<!--
   If the array expression yields a null array, the result of
   <token>ALL</token> will be null.  If the left-hand expression yields null,
   the result of <token>ALL</token> is ordinarily null (though a non-strict
   comparison operator could possibly yield a different result).
   Also, if the right-hand array contains any null elements and no false
   comparison result is obtained, the result of <token>ALL</token>
   will be null, not true (again, assuming a strict comparison operator).
   This is in accordance with SQL's normal rules for Boolean combinations
   of null values.
-->
配列式がNULL配列を生成する場合、<token>ALL</token>の結果はNULLになります。
左辺式がNULLとなる場合、<token>ALL</token>の結果は通常NULLになります（厳密でない比較演算子では異なる結果になるかもしれません）。
また、右辺の配列にNULL要素が含まれ、かつ、比較した結果偽でない値になった場合、<token>ALL</token>の結果は真ではなくNULLになります（繰り返しになりますが、厳密な演算子の場合です）。
これは、NULLに対する、SQLの論理値組み合わせに関する標準規則に従うものです。
  </para>
  </sect2>

  <sect2 id="row-wise-comparison">
<!--
   <title>Row Constructor Comparison</title>
-->
   <title>行コンストラクタに関しての比較</title>

<synopsis>
<replaceable>row_constructor</replaceable> <replaceable>operator</replaceable> <replaceable>row_constructor</replaceable>
</synopsis>

  <para>
<!--
   Each side is a row constructor,
   as described in <xref linkend="sql-syntax-row-constructors">.
   The two row values must have the same number of fields.
   Each side is evaluated and they are compared row-wise.  Row constructor
   comparisons are allowed when the <replaceable>operator</replaceable> is
   <literal>=</>,
   <literal>&lt;&gt;</>,
   <literal>&lt;</>,
   <literal>&lt;=</>,
   <literal>&gt;</> or
   <literal>&gt;=</>.
   Every row element must be of a type which has a default B-tree operator
   class or the attempted comparison may generate an error.
-->
両辺とも<xref linkend="sql-syntax-row-constructors">で説明する行コンストラクタです。
この２つの行値は同じフィールド数でなければなりません。
両辺はそれぞれ評価され、行として比較されます。
行コンストラクタの比較は、<replaceable>operator</replaceable>が<literal>=</>、<literal>&lt;&gt;</>、<literal>&lt;</>、<literal>&lt;=</>、<literal>&gt;</>、<literal>&gt;=</>の場合に認められます。
各行の要素はデフォルトのB-tree演算子クラスを持つ型でなければなりません。そうでなければ、比較を試みるとエラーが発生します。
  </para>

  <note>
   <para>
<!--
    Errors related to the number or types of elements might not occur if
    the comparison is resolved using earlier columns.
-->
比較が先行する列で解決された場合、要素の数や型に関係するエラーは起きません．
   </para>
  </note>

  <para>
<!--
   The <literal>=</> and <literal>&lt;&gt;</> cases work slightly differently
   from the others.  Two rows are considered
   equal if all their corresponding members are non-null and equal; the rows
   are unequal if any corresponding members are non-null and unequal;
   otherwise the result of the row comparison is unknown (null).
-->
<literal>=</>と<literal>&lt;&gt;</>の場合、他と動作が多少異なります。
2つの行は対応する全ての構成要素が非NULLかつ等しい場合に等しいとみなされます。１つでも構成要素が非NULLかつ等しくない場合、2つの行は等しくないとみなされます。それ以外その行の比較結果は不明（NULL）です。
  </para>

  <para>
<!--
   For the <literal>&lt;</>, <literal>&lt;=</>, <literal>&gt;</> and
   <literal>&gt;=</> cases, the row elements are compared left-to-right,
   stopping as soon as an unequal or null pair of elements is found.
   If either of this pair of elements is null, the result of the
   row comparison is unknown (null); otherwise comparison of this pair
   of elements determines the result.  For example,
   <literal>ROW(1,2,NULL) &lt; ROW(1,3,0)</>
   yields true, not null, because the third pair of elements are not
   considered.
-->
<literal>&lt;</>、<literal>&lt;=</>、<literal>&gt;</>、<literal>&gt;=</>の場合、行の要素は左から右に比較されます。そして、不等またはNULLの組み合わせが見つかったところで停止します。
要素の組み合わせのどちらかがNULLであった場合、行比較の結果は不明（NULL）です。さもなくば、要素の組み合わせの比較により結果が決まります。
例えば、<literal>ROW(1,2,NULL) &lt; ROW(1,3,0)</>は、３番目の要素の組み合わせまで進まないため、NULLではなく真を返します。
  </para>

  <note>
   <para>
<!--
    Prior to <productname>PostgreSQL</productname> 8.2, the
    <literal>&lt;</>, <literal>&lt;=</>, <literal>&gt;</> and <literal>&gt;=</>
    cases were not handled per SQL specification.  A comparison like
    <literal>ROW(a,b) &lt; ROW(c,d)</>
    was implemented as
    <literal>a &lt; c AND b &lt; d</>
    whereas the correct behavior is equivalent to
    <literal>a &lt; c OR (a = c AND b &lt; d)</>.
-->
<productname>PostgreSQL</productname> 8.2以前では、<literal>&lt;</>、<literal>&lt;=</>、<literal>&gt;</> 、<literal>&gt;=</>の場合SQL仕様に従っていませんでした。
<literal>ROW(a,b) &lt; ROW(c,d)</>などの比較は正しくは<literal>a &lt; c OR (a = c AND b &lt; d)</>ですが、<literal>a &lt; c AND b &lt; d</>として実装されていました。
   </para>
  </note>

<synopsis>
<replaceable>row_constructor</replaceable> IS DISTINCT FROM <replaceable>row_constructor</replaceable>
</synopsis>

  <para>
<!--
   This construct is similar to a <literal>&lt;&gt;</literal> row comparison,
   but it does not yield null for null inputs.  Instead, any null value is
   considered unequal to (distinct from) any non-null value, and any two
   nulls are considered equal (not distinct).  Thus the result will
   either be true or false, never null.
-->
このコンストラクトは<literal>&lt;&gt;</literal>行比較と類似していますが、NULL入力に対してNULLを生成しない点が異なります。
その代わりに、全てのNULL値は非NULL値と等しくない（DISTINCT FROM）ものとみなされ、また、２つのNULLは等しい（NOT DISTINCT）ものとみなされます。
したがって、結果は真か偽のいずれかで、NULLにはなりません。
  </para>

<synopsis>
<replaceable>row_constructor</replaceable> IS NOT DISTINCT FROM <replaceable>row_constructor</replaceable>
</synopsis>

  <para>
<!--
   This construct is similar to a <literal>=</literal> row comparison,
   but it does not yield null for null inputs.  Instead, any null value is
   considered unequal to (distinct from) any non-null value, and any two
   nulls are considered equal (not distinct).  Thus the result will always
   be either true or false, never null.
-->
このコンストラクトは<literal>=</literal>行比較と類似していますが、NULL入力に対してNULLを生成しません。
代わりに、NULL値を、すべての非NULLの値に対して不等（DISTINCT FROM）とみなし、２つのNULLを等しいもの（NOT DISTINCT）とみなします。
したがって、結果は常に真か偽となり、NULLになることはありません
  </para>

  </sect2>

  <sect2 id="composite-type-comparison">
<!--
   <title>Composite Type Comparison</title>
-->
   <title>複合型の比較</title>

<synopsis>
<replaceable>record</replaceable> <replaceable>operator</replaceable> <replaceable>record</replaceable>
</synopsis>

  <para>
<!--
   The SQL specification requires row-wise comparison to return NULL if the
   result depends on comparing two NULL values or a NULL and a non-NULL.
   <productname>PostgreSQL</productname> does this only when comparing the
   results of two row constructors (as in
   <xref linkend="row-wise-comparison">) or comparing a row constructor
   to the output of a subquery (as in <xref linkend="functions-subquery">).
   In other contexts where two composite-type values are compared, two
   NULL field values are considered equal, and a NULL is considered larger
   than a non-NULL.  This is necessary in order to have consistent sorting
   and indexing behavior for composite types.
-->
SQL仕様では、結果が2つのNULL値、またはNULLと非NULLの比較に基づくのであれば、行の観点からの比較はNULLを返すことを要求されています。
<productname>PostgreSQL</productname>は、(<xref linkend="row-wise-comparison">にあるように)２つの行コンストラクタの出力の比較を行う時、または副問い合わせの出力に対し(<xref linkend="functions-subquery">にあるように)行コンストラクタの比較を行う時のみこれを実施します。
２つの複合型の値が比較されるほかの状況では、２つのNULLフィールドの値は等しいと考えられ、NULLは非NULLより大きいとみなされます。
複合型に対して、これは一貫した並び替えとインデックス付け動作担保のため必要です。
  </para>

  <para>
<!--
   Each side is evaluated and they are compared row-wise.  Composite type
   comparisons are allowed when the <replaceable>operator</replaceable> is
   <literal>=</>,
   <literal>&lt;&gt;</>,
   <literal>&lt;</>,
   <literal>&lt;=</>,
   <literal>&gt;</> or
   <literal>&gt;=</>,
   or has semantics similar to one of these.  (To be specific, an operator
   can be a row comparison operator if it is a member of a B-tree operator
   class, or is the negator of the <literal>=</> member of a B-tree operator
   class.)  The default behavior of the above operators is the same as for
   <literal>IS [ NOT ] DISTINCT FROM</literal> for row constructors (see
   <xref linkend="row-wise-comparison">).
-->
各辺が評価され、行単位で比較が行なわれます。
複合型の比較は<replaceable>operator</replaceable>が<literal>=</>、<literal>&lt;&gt;</>、<literal>&lt;</>、<literal>&lt;=</>、<literal>&gt;</>、<literal>&gt;=</>またはそのいずれかと類似の意味を持つ場合に許されます。
(正確には、演算子はB-tree演算子クラスのメンバである場合、またはB-tree演算子クラスの<literal>=</>メンバの否定子である場合に行比較演算子となり得ます。)
  </para>

  <para>
<!--
   To support matching of rows which include elements without a default
   B-tree operator class, the following operators are defined for composite
   type comparison:
   <literal>*=</>,
   <literal>*&lt;&gt;</>,
   <literal>*&lt;</>,
   <literal>*&lt;=</>,
   <literal>*&gt;</>, and
   <literal>*&gt;=</>.
   These operators compare the internal binary representation of the two
   rows.  Two rows might have a different binary representation even
   though comparisons of the two rows with the equality operator is true.
   The ordering of rows under these comparison operators is deterministic
   but not otherwise meaningful.  These operators are used internally for
   materialized views and might be useful for other specialized purposes
   such as replication but are not intended to be generally useful for
   writing queries.
-->
デフォルトB-tree演算子クラスを持たない要素を含む行の一致をサポートするために、以下の演算子が複合型の比較のために定義されています。
<literal>*=</>、<literal>*&lt;&gt;</>、<literal>*&lt;</>、<literal>*&lt;=</>、<literal>*&gt;</>、<literal>*&gt;=</>。
上記の演算子は2つの行の内部バイナリ表現を比較します。
2つの行の等価演算子での比較が真であっても、2つの行はバイナリ表現が異なるかもしれません。
上記の比較演算子での行の順序は決定論的ですが、それ以外は意味がありません。
上記の演算子はマテリアライズドビューで内部的に使われ、レプリケーションのような他の特定の目的のためには有用かもしれませんが、問い合わせを書くのに一般的に有用であるようにとは意図していません。
  </para>
  </sect2>
 </sect1>

 <sect1 id="functions-srf">
<!--
  <title>Set Returning Functions</title>
-->
  <title>集合を返す関数</title>

  <indexterm zone="functions-srf">
<!--
   <primary>set returning functions</primary>
-->
   <primary>集合を返す関数</primary>
<!--
   <secondary>functions</secondary>
-->
   <secondary>関数</secondary>
  </indexterm>

  <indexterm>
   <primary>generate_series</primary>
  </indexterm>

  <para>
<!--
   This section describes functions that possibly return more than one row.
   The most widely used functions in this class are series generating
   functions, as detailed in <xref linkend="functions-srf-series"> and
   <xref linkend="functions-srf-subscripts">.  Other, more specialized
   set-returning functions are described elsewhere in this manual.
   See <xref linkend="queries-tablefunctions"> for ways to combine multiple
   set-returning functions.
-->
本節では、場合により複数行を返す関数について説明します。
最も広く用いられているこのクラスの関数は、<xref linkend="functions-srf-series">、および<xref linkend="functions-srf-subscripts">にて詳細が触れられている、連続生成関数です。
他方、より特化された集合を返す関数の記述がこのマニュアルのいたるところにあります。
集合を返す関数を複数組み合わせる方法については<xref linkend="queries-tablefunctions">を参照してください。
  </para>

  <table id="functions-srf-series">
<!--
   <title>Series Generating Functions</title>
-->
   <title>連続値生成関数</title>
   <tgroup cols="4">
    <thead>
     <row>
<!--
      <entry>Function</entry>
      <entry>Argument Type</entry>
      <entry>Return Type</entry>
      <entry>Description</entry>
-->
      <entry>関数</entry>
      <entry>引数型</entry>
      <entry>戻り型</entry>
      <entry>説明</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal><function>generate_series(<parameter>start</parameter>, <parameter>stop</parameter>)</function></literal></entry>
<!--
      <entry><type>int</type> or <type>bigint</type></entry>
-->
      <entry><type>int</type>または<type>bigint</type></entry>
<!--
      <entry><type>setof int</type> or <type>setof bigint</type> (same as argument type)</entry>
-->
      <entry><type>setof int</type>または<type>setof bigint</type>（引数の型と同一）</entry>
      <entry>
<!--
       Generate a series of values, from <parameter>start</parameter> to <parameter>stop</parameter>
       with a step size of one
-->
      <parameter>start</parameter>から<parameter>stop</parameter>まで、刻み１で連続する値を生成します。
      </entry>
     </row>

     <row>
      <entry><literal><function>generate_series(<parameter>start</parameter>, <parameter>stop</parameter>, <parameter>step</parameter>)</function></literal></entry>
<!--
      <entry><type>int</type> or <type>bigint</type></entry>
-->
      <entry><type>int</type>または<type>bigint</type></entry>
<!--
      <entry><type>setof int</type> or <type>setof bigint</type> (same as argument type)</entry>
-->
      <entry><type>setof int</type>または<type>setof bigint</type>（引数の型と同一）</entry>
      <entry>
<!--
       Generate a series of values, from <parameter>start</parameter> to <parameter>stop</parameter>
       with a step size of <parameter>step</parameter>
-->
       <parameter>start</parameter>から<parameter>stop</parameter>まで、刻み<parameter>step</parameter>で連続する値を生成します。
      </entry>
     </row>

     <row>
      <entry><literal><function>generate_series(<parameter>start</parameter>, <parameter>stop</parameter>, <parameter>step</parameter> <type>interval</>)</function></literal></entry>
<!--
      <entry><type>timestamp</type> or <type>timestamp with time zone</type></entry>
-->
      <entry><type>timestamp</type> または <type>timestamp with time zone</type></entry>
<!--
      <entry><type>setof timestamp</type> or <type>setof timestamp with time zone</type> (same as argument type)</entry>
-->
      <entry><type>setof timestamp</type> または <type>setof timestamp with time zone</type>（引数型と同じ）</entry>
      <entry>
<!--
       Generate a series of values, from <parameter>start</parameter> to <parameter>stop</parameter>
       with a step size of <parameter>step</parameter>
-->
       <parameter>start</parameter>から<parameter>stop</parameter>まで、刻み<parameter>step</parameter>で連続する値を生成します。
      </entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <para>
<!--
   When <parameter>step</parameter> is positive, zero rows are returned if
   <parameter>start</parameter> is greater than <parameter>stop</parameter>.
   Conversely, when <parameter>step</parameter> is negative, zero rows are
   returned if <parameter>start</parameter> is less than <parameter>stop</parameter>.
   Zero rows are also returned for <literal>NULL</literal> inputs. It is an error
   for <parameter>step</parameter> to be zero. Some examples follow:
-->
<parameter>step</parameter>が正の場合、<parameter>start</parameter>が<parameter>stop</parameter>よりも大きいと０行が返ります。
反対に、<parameter>step</parameter>が負の場合は、<parameter>start</parameter>が<parameter>stop</parameter>よりも小さいと０行が返ります。
また、<literal>NULL</literal>が入力された場合も０行が返ります。
<parameter>step</parameter>が０の時はエラーになります。
以下にいくつか例を示します。
<programlisting>
SELECT * FROM generate_series(2,4);
 generate_series
-----------------
               2
               3
               4
(3 rows)

SELECT * FROM generate_series(5,1,-2);
 generate_series
-----------------
               5
               3
               1
(3 rows)

SELECT * FROM generate_series(4,3);
 generate_series
-----------------
(0 rows)

<!--
&#045;- this example relies on the date-plus-integer operator
-->
-- この例は日付に整数を足し込む演算子に依存します。
SELECT current_date + s.a AS dates FROM generate_series(0,14,7) AS s(a);
   dates
------------
 2004-02-05
 2004-02-12
 2004-02-19
(3 rows)

SELECT * FROM generate_series('2008-03-01 00:00'::timestamp,
                              '2008-03-04 12:00', '10 hours');
   generate_series   
---------------------
 2008-03-01 00:00:00
 2008-03-01 10:00:00
 2008-03-01 20:00:00
 2008-03-02 06:00:00
 2008-03-02 16:00:00
 2008-03-03 02:00:00
 2008-03-03 12:00:00
 2008-03-03 22:00:00
 2008-03-04 08:00:00
(9 rows)
</programlisting>
  </para>

  <table id="functions-srf-subscripts">
<!--
   <title>Subscript Generating Functions</title>
-->
   <title>添え字生成関数</title>
   <tgroup cols="3">
    <thead>
     <row>
<!--
      <entry>Function</entry>
      <entry>Return Type</entry>
      <entry>Description</entry>
-->
      <entry>関数</entry>
      <entry>戻り値型</entry>
      <entry>説明</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal><function>generate_subscripts(<parameter>array anyarray</parameter>, <parameter>dim int</parameter>)</function></literal></entry>
      <entry><type>setof int</type></entry>
      <entry>
<!--
       Generate a series comprising the given array's subscripts.
-->
       指定した配列の添え字を構成するシリーズを生成します。
      </entry>
     </row>

     <row>
      <entry><literal><function>generate_subscripts(<parameter>array anyarray</parameter>, <parameter>dim int</parameter>, <parameter>reverse boolean</parameter>)</function></literal></entry>
      <entry><type>setof int</type></entry>
      <entry>
<!--
       Generate a series comprising the given array's subscripts. When
       <parameter>reverse</parameter> is true, the series is returned in
       reverse order.
-->
       指定した配列の添え字を構成する連番を生成します。
       <parameter>reverse</parameter>が真の場合、連番は逆順に返されます。
      </entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <indexterm>
   <primary>generate_subscripts</primary>
  </indexterm>

  <para>
<!--
   <function>generate_subscripts</> is a convenience function that generates
   the set of valid subscripts for the specified dimension of the given
   array.
   Zero rows are returned for arrays that do not have the requested dimension,
   or for NULL arrays (but valid subscripts are returned for NULL array
   elements).  Some examples follow:
-->
<function>generate_subscripts</>は、指定した配列の指定した次数で有効な添え字からなる集合を生成するために便利な関数です。
要求された次数を持たない配列またはNULL配列では行は返されません。
しかしこれはNULL配列要素では有効な添え字です。）
いくつかの例を以下に示します。
   
<programlisting>
<!--
&#045;- basic usage
-->
-- 基本的用法
SELECT generate_subscripts('{NULL,1,NULL,2}'::int[], 1) AS s;
 s 
---
 1
 2
 3
 4
(4 rows)

<!--
&#045;- presenting an array, the subscript and the subscripted
&#045;- value requires a subquery
-->
-- ある配列では、添え字とその添え字が示す値は
-- 副問い合わせが必要です。
SELECT * FROM arrays;
         a          
--------------------
 {-1,-2}
 {100,200,300}
(2 rows)

SELECT a AS array, s AS subscript, a[s] AS value
FROM (SELECT generate_subscripts(a, 1) AS s, a FROM arrays) foo;
     array     | subscript | value
---------------+-----------+-------
 {-1,-2}       |         1 |    -1
 {-1,-2}       |         2 |    -2
 {100,200,300} |         1 |   100
 {100,200,300} |         2 |   200
 {100,200,300} |         3 |   300
(5 rows)

<!--
&#045;- unnest a 2D array
-->
-- 2次元配列の入れ子を解きます。
CREATE OR REPLACE FUNCTION unnest2(anyarray)
RETURNS SETOF anyelement AS $$
select $1[i][j]
   from generate_subscripts($1,1) g1(i),
        generate_subscripts($1,2) g2(j);
$$ LANGUAGE sql IMMUTABLE;
CREATE FUNCTION
SELECT * FROM unnest2(ARRAY[[1,2],[3,4]]);
 unnest2 
---------
       1
       2
       3
       4
(4 rows)
</programlisting>
  </para>

  <indexterm>
<!--
   <primary>ordinality</primary>
-->
   <primary>順序性</primary>
  </indexterm>

  <para>
<!--
   When a function in the <literal>FROM</literal> clause is suffixed
   by <literal>WITH ORDINALITY</literal>, a <type>bigint</type> column is
   appended to the output which starts from 1 and increments by 1 for each row
   of the function's output.  This is most useful in the case of set returning
   functions such as <function>unnest()</>.
-->
<literal>FROM</literal>句の関数の後に<literal>WITH ORDINALITY</literal>が付いている場合、1から始まり関数の出力の行毎に1増えていく<type>bigint</type>列が出力に追加されます。
これは<function>unnest()</>のような集合を返す関数の場合に最も役に立ちます。

<programlisting>
<!--
&#045;- set returning function WITH ORDINALITY
-->
-- WITH ORDINALITYの付いた集合を返す関数
SELECT * FROM pg_ls_dir('.') WITH ORDINALITY AS t(ls,n);
       ls        | n
-----------------+----
 pg_serial       |  1
 pg_twophase     |  2
 postmaster.opts |  3
 pg_notify       |  4
 postgresql.conf |  5
 pg_tblspc       |  6
 logfile         |  7
 base            |  8
 postmaster.pid  |  9
 pg_ident.conf   | 10
 global          | 11
 pg_clog         | 12
 pg_snapshots    | 13
 pg_multixact    | 14
 PG_VERSION      | 15
 pg_xlog         | 16
 pg_hba.conf     | 17
 pg_stat_tmp     | 18
 pg_subtrans     | 19
(19 rows)
</programlisting>
  </para>

 </sect1>

 <sect1 id="functions-info">
<!--
  <title>System Information Functions</title>
-->
  <title>システム情報関数</title>

  <para>
<!--
   <xref linkend="functions-info-session-table"> shows several
   functions that extract session and system information.
-->
<xref linkend="functions-info-session-table">に、セッションおよびシステムの情報を抽出する関数を示します。
  </para>

  <para>
<!--
   In addition to the functions listed in this section, there are a number of
   functions related to the statistics system that also provide system
   information. See <xref linkend="monitoring-stats-views"> for more
   information.
-->
本節でリストされている関数のほかに、同様にシステム情報を提供する統計システムに関連した数多くの関数があります。
<xref linkend="monitoring-stats-views">にさらに情報があります。
  </para>

   <table id="functions-info-session-table">
<!--
    <title>Session Information Functions</title>
-->
    <title>セッション情報関数</title>
    <tgroup cols="3">
     <thead>
<!--
      <row><entry>Name</entry> <entry>Return Type</entry> <entry>Description</entry></row>
-->
      <row><entry>名前</entry> <entry>戻り型</entry> <entry>説明</entry></row>
     </thead>

     <tbody>
      <row>
       <entry><literal><function>current_catalog</function></literal></entry>
       <entry><type>name</type></entry>
<!--
       <entry>name of current database (called <quote>catalog</quote> in the SQL standard)</entry>
-->
       <entry>（SQL標準で<quote>カタログ</quote>と呼ばれる）現在のデータベースの名前</entry>
      </row>

      <row>
       <entry><literal><function>current_database()</function></literal></entry>
       <entry><type>name</type></entry>
<!--
       <entry>name of current database</entry>
-->
       <entry>現在のデータベースの名前</entry>
      </row>

      <row>
       <entry><literal><function>current_query()</function></literal></entry>
       <entry><type>text</type></entry>
<!--
       <entry>text of the currently executing query, as submitted
       by the client (might contain more than one statement)</entry>
-->
       <entry>クライアントから提示された、現在実行中問い合わせのテキスト（複数の文を含むことあり）</entry>
      </row>

      <row>
       <entry><literal><function>current_schema</function>[()]</literal></entry>
       <entry><type>name</type></entry>
<!--
       <entry>name of current schema</entry>
-->
       <entry>現在のスキーマの名前</entry>
      </row>

      <row>
       <entry><literal><function>current_schemas(<type>boolean</type>)</function></literal></entry>
       <entry><type>name[]</type></entry>
<!--
       <entry>names of schemas in search path, optionally including implicit schemas</entry>
-->
       <entry>オプションで暗黙的なスキーマも含む、検索パス内のスキーマの名前</entry>
      </row>

      <row>
       <entry><literal><function>current_user</function></literal></entry>
       <entry><type>name</type></entry>
<!--
       <entry>user name of current execution context</entry>
-->
       <entry>現在の処理実施コンテキストのユーザ名</entry>
      </row>

      <row>
       <entry><literal><function>inet_client_addr()</function></literal></entry>
       <entry><type>inet</type></entry>
<!--
       <entry>address of the remote connection</entry>
-->
       <entry>リモート接続のアドレス</entry>
      </row>

      <row>
       <entry><literal><function>inet_client_port()</function></literal></entry>
       <entry><type>int</type></entry>
<!--
       <entry>port of the remote connection</entry>
-->
       <entry>リモート接続のポート</entry>
      </row>

      <row>
       <entry><literal><function>inet_server_addr()</function></literal></entry>
       <entry><type>inet</type></entry>
<!--
       <entry>address of the local connection</entry>
-->
       <entry>ローカル接続のアドレス</entry>
      </row>

      <row>
       <entry><literal><function>inet_server_port()</function></literal></entry>
       <entry><type>int</type></entry>
<!--
       <entry>port of the local connection</entry>
-->
       <entry>ローカル接続のポート</entry>
      </row>

      <row>
       <!-- See also the entry for this in monitoring.sgml -->
       <!-- これについてmonitoring.sgmlの項目も参照 -->
       <entry><literal><function>pg_backend_pid()</function></literal></entry>
       <entry><type>int</type></entry>
       <entry>
<!--
        Process ID of the server process attached to the current session
-->
        現在のセッションに結びついたサーバプロセスのプロセスID
       </entry>
      </row>

      <row>
       <entry><literal><function>pg_conf_load_time()</function></literal></entry>
       <entry><type>timestamp with time zone</type></entry>
<!--
       <entry>configuration load time</entry>
-->
       <entry>設定を読み込んだ時刻</entry>
      </row>

      <row>
       <entry><literal><function>pg_is_other_temp_schema(<type>oid</type>)</function></literal></entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>is schema another session's temporary schema?</entry>
-->
       <entry>スキーマが他のセッションの一時スキーマかどうか？</entry>
      </row>

      <row>
       <entry><literal><function>pg_listening_channels()</function></literal></entry>
       <entry><type>setof text</type></entry>
<!--
       <entry>channel names that the session is currently listening on</entry>
-->
       <entry>今のセッションにおいて現在LISTEN中のチャンネル名</entry>
      </row>

      <row>
       <entry><literal><function>pg_my_temp_schema()</function></literal></entry>
       <entry><type>oid</type></entry>
<!--
       <entry>OID of session's temporary schema, or 0 if none</entry>
-->
       <entry>セッションの一時スキーマのOID。もしなければ０</entry>
      </row>

      <row>
       <entry><literal><function>pg_postmaster_start_time()</function></literal></entry>
       <entry><type>timestamp with time zone</type></entry>
<!--
       <entry>server start time</entry>
-->
       <entry>サーバの起動時刻</entry>
      </row>

      <row>
       <entry><literal><function>pg_trigger_depth()</function></literal></entry>
       <entry><type>int</type></entry>
<!--
       <entry>current nesting level of <productname>PostgreSQL</> triggers
       (0 if not called, directly or indirectly, from inside a trigger)</entry>
-->
       <entry><productname>PostgreSQL</>のトリガの現在の入れ子の深さ (直接もしくは間接的に、トリガ内部から呼ばれていなければ0を返す)</entry>
      </row>

      <row>
       <entry><literal><function>session_user</function></literal></entry>
       <entry><type>name</type></entry>
<!--
       <entry>session user name</entry>
-->
       <entry>セッションのユーザ名</entry>
      </row>

      <row>
       <entry><literal><function>user</function></literal></entry>
       <entry><type>name</type></entry>
<!--
       <entry>equivalent to <function>current_user</function></entry>
-->
       <entry><function>current_user</function>と等価</entry>
      </row>

      <row>
       <entry><literal><function>version()</function></literal></entry>
       <entry><type>text</type></entry>
<!--
       <entry><productname>PostgreSQL</> version information</entry>
-->
       <entry><productname>PostgreSQLバージョン情報</></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <note>
    <para>
<!--
     <function>current_catalog</function>, <function>current_schema</function>,
     <function>current_user</function>, <function>session_user</function>,
     and <function>user</function> have special syntactic status
     in <acronym>SQL</acronym>: they must be called without trailing
     parentheses.  (In PostgreSQL, parentheses can optionally be used with
     <function>current_schema</function>, but not with the others.)
-->
<function>current_catalog</function>、<function>current_schema</function>、<function>current_user</function>、<function>session_user</function>および<function>user</function>は<acronym>SQL</acronym>において特殊な構文上の地位を持っており、最後に括弧を付けずに呼び出さなければなりません。
（PostgreSQLでは<function>current_schema</function>の場合括弧を使用することができますが、他は使えません。）
    </para>
   </note>

   <indexterm>
    <primary>current_catalog</primary>
   </indexterm>

   <indexterm>
    <primary>current_database</primary>
   </indexterm>

   <indexterm>
    <primary>current_query</primary>
   </indexterm>

   <indexterm>
    <primary>current_schema</primary>
   </indexterm>

   <indexterm>
    <primary>current_schemas</primary>
   </indexterm>

   <indexterm>
    <primary>current_user</primary>
   </indexterm>

   <indexterm>
    <primary>pg_backend_pid</primary>
   </indexterm>

   <indexterm>
<!--
    <primary>schema</primary>
    <secondary>current</secondary>
-->
    <primary>スキーマ</primary>
    <secondary>現在の</secondary>
   </indexterm>

   <indexterm>
<!--
    <primary>search path</primary>
    <secondary>current</secondary>
-->
    <primary>検索パス</primary>
    <secondary>現在の</secondary>
   </indexterm>

   <indexterm>
    <primary>session_user</primary>
   </indexterm>

   <indexterm>
<!--
    <primary>user</primary>
    <secondary>current</secondary>
-->
    <primary>ユーザ</primary>
    <secondary>現在の</secondary>
   </indexterm>

   <indexterm>
    <primary>user</primary>
   </indexterm>

   <para>
<!--
    The <function>session_user</function> is normally the user who initiated
    the current database connection; but superusers can change this setting
    with <xref linkend="sql-set-session-authorization">.
    The <function>current_user</function> is the user identifier
    that is applicable for permission checking. Normally it is equal
    to the session user, but it can be changed with
    <xref linkend="sql-set-role">.
    It also changes during the execution of
    functions with the attribute <literal>SECURITY DEFINER</literal>.
    In Unix parlance, the session user is the <quote>real user</quote> and
    the current user is the <quote>effective user</quote>.
-->
<function>session_user</function>は、通常、現在のデータベース接続を初期化したユーザです。しかし、スーパユーザはこの設定を<xref linkend="sql-set-session-authorization">を使用して変更することができます。
<function>current_user</function>は、権限の検査に適用されるユーザ識別子です。
通常はセッションユーザと同じですが、<xref linkend="sql-set-role">を使用して変更可能です。
<literal>SECURITY DEFINER</literal>属性を持つ関数の実行中にも変更します。
Unix用語で言うと、セッションユーザは<quote>実ユーザ</quote>で、現在のユーザは<quote>実効ユーザ</quote>です。
   </para>

   <para>
<!--
    <function>current_schema</function> returns the name of the schema that is
    first in the search path (or a null value if the search path is
    empty).  This is the schema that will be used for any tables or
    other named objects that are created without specifying a target schema.
    <function>current_schemas(boolean)</function> returns an array of the names of all
    schemas presently in the search path.  The Boolean option determines whether or not
    implicitly included system schemas such as <literal>pg_catalog</> are included in the
    returned search path.
-->
<function>current_schema</function>関数は、検索パスの最初にあるスキーマ名（もしくは、検索パスが空の場合はNULL値）を返します。
これは、対象スキーマを指定せずに作成された、任意のテーブルまたは他の名前付きオブジェクトに使用されるスキーマです。
また、<function>current_schemas(boolean)</function> は、検索パスに存在する全てのスキーマ名の配列を返します。
booleanオプションにより、<literal>pg_catalog</>のような暗黙的に含まれているシステムスキーマを、結果の検索パスに含めるかどうかを指定します。
   </para>

   <note>
    <para>
<!--
     The search path can be altered at run time.  The command is:
-->
検索パスは、実行時の設定で変更することができます。使
用するコマンドは以下の通りです。
<programlisting>
SET search_path TO <replaceable>schema</> <optional>, <replaceable>schema</>, ...</optional>
</programlisting>
    </para>
   </note>

   <indexterm>
    <primary>pg_listening_channels</primary>
   </indexterm>

   <para>
<!--
    <function>pg_listening_channels</function> returns a set of names of
    channels that the current session is listening to.  See <xref
    linkend="sql-listen"> for more information.
-->
<function>pg_listening_channels</function>は、現在のセッションでLISTEN中のチャンネル名のセットを返します。
詳細は<xref linkend="sql-listen">を参照して下さい。
   </para>

   <indexterm>
    <primary>inet_client_addr</primary>
   </indexterm>

   <indexterm>
    <primary>inet_client_port</primary>
   </indexterm>

   <indexterm>
    <primary>inet_server_addr</primary>
   </indexterm>

   <indexterm>
    <primary>inet_server_port</primary>
   </indexterm>

   <para>
<!--
     <function>inet_client_addr</function> returns the IP address of the
     current client, and <function>inet_client_port</function> returns the
     port number.
     <function>inet_server_addr</function> returns the IP address on which
     the server accepted the current connection, and
     <function>inet_server_port</function> returns the port number.
     All these functions return NULL if the current connection is via a
     Unix-domain socket.
-->
<function>inet_client_addr</function>は現在のクライアントのIPアドレスを返し、<function>inet_client_port</function>はそのポート番号を返します。
<function>inet_server_addr</function>は、現在の接続を受け付けたサーバのIPアドレスを返し、<function>inet_server_port</function>はそのポート番号を返します。
これら全ての関数は接続がUnix-domain socket経由の場合NULLを返します。
   </para>

   <indexterm>
    <primary>pg_my_temp_schema</primary>
   </indexterm>

   <indexterm>
    <primary>pg_is_other_temp_schema</primary>
   </indexterm>

   <para>
<!--
    <function>pg_my_temp_schema</function> returns the OID of the current
    session's temporary schema, or zero if it has none (because it has not
    created any temporary tables).
    <function>pg_is_other_temp_schema</function> returns true if the
    given OID is the OID of another session's temporary schema.
    (This can be useful, for example, to exclude other sessions' temporary
    tables from a catalog display.)
-->
<function>pg_my_temp_schema</function>は、現在のセッションの一時スキーマのOIDを返します。もし（どんな一時テーブルも作成していないので）存在しなければゼロを返します。
<function>pg_is_other_temp_schema</function>は、指定したOIDが他のセッションの一時スキーマのOIDであれば、真を返します。
（例えば、他のセッションの一時テーブルをカタログ表示から除外したい場合などで有用です。）
   </para>

   <indexterm>
    <primary>pg_postmaster_start_time</primary>
   </indexterm>

   <para>
<!--
    <function>pg_postmaster_start_time</function> returns the
    <type>timestamp with time zone</type> when the
    server started.
-->
<function>pg_postmaster_start_time</function>はサーバが起動した時の<type>timestamp with time zone</type>を返します。
   </para>

   <indexterm>
    <primary>pg_conf_load_time</primary>
   </indexterm>

   <para>
<!--
    <function>pg_conf_load_time</function> returns the
    <type>timestamp with time zone</type> when the
    server configuration files were last loaded.
    (If the current session was alive at the time, this will be the time
    when the session itself re-read the configuration files, so the
    reading will vary a little in different sessions.  Otherwise it is
    the time when the postmaster process re-read the configuration files.)
-->
<function>pg_conf_load_time</function>はサーバの設定ファイルが最後に読み込まれた時の<type>timestamp with time zone</type>を返します。
（現在のセッションがその時点で稼働していた場合、これはセッション自体が設定ファイルを読み込んだ時刻となります。
このためこの読み取った結果は多少他のセッションと異なります。
この他の場合は、postmasterプロセスが設定ファイルを再読み込みした時刻となります。）
   </para>

   <indexterm>
    <primary>version</primary>
   </indexterm>

   <para>
<!--
    <function>version</function> returns a string describing the
    <productname>PostgreSQL</productname> server's version.
-->
<function>version</function>関数は<productname>PostgreSQL</productname>サーバのバージョンを記述した文字列を返します。
   </para>

  <indexterm>
<!--
   <primary>privilege</primary>
   <secondary>querying</secondary>
-->
   <primary>権限</primary>
   <secondary>問い合わせ</secondary>
  </indexterm>

  <para>
<!--
   <xref linkend="functions-info-access-table"> lists functions that
   allow the user to query object access privileges programmatically.
   See <xref linkend="ddl-priv"> for more information about
   privileges.
-->
<xref linkend="functions-info-access-table">に列挙した関数を使用して、ユーザはオブジェクトのアクセス権限をプログラムから問い合わせることができます。
権限についての詳細は、<xref linkend="ddl-priv">を参照してください。
  </para>

   <table id="functions-info-access-table">
<!--
    <title>Access Privilege Inquiry Functions</title>
-->
    <title>アクセス権限照会関数</title>
    <tgroup cols="3">
     <thead>
<!--
      <row><entry>Name</entry> <entry>Return Type</entry> <entry>Description</entry></row>
-->
      <row><entry>名前</entry> <entry>戻り型</entry> <entry>説明</entry></row>
     </thead>

     <tbody>
      <row>
       <entry><literal><function>has_any_column_privilege</function>(<parameter>user</parameter>,
                                  <parameter>table</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>does user have privilege for any column of table</entry>
-->
       <entry>ユーザがテーブルのどの列に対しても権限を所有しているか</entry>
      </row>
      <row>
       <entry><literal><function>has_any_column_privilege</function>(<parameter>table</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>does current user have privilege for any column of table</entry>
-->
       <entry>現在のユーザがテーブルのどの列に対しても権限を所有しているか</entry>
      </row>
      <row>
       <entry><literal><function>has_column_privilege</function>(<parameter>user</parameter>,
                                  <parameter>table</parameter>,
                                  <parameter>column</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>does user have privilege for column</entry>
-->
       <entry>ユーザに列に対する権限があるか</entry>
      </row>
      <row>
       <entry><literal><function>has_column_privilege</function>(<parameter>table</parameter>,
                                  <parameter>column</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>does current user have privilege for column</entry>
-->
       <entry>現在のユーザに列に対する権限があるか</entry>
      </row>
      <row>
       <entry><literal><function>has_database_privilege</function>(<parameter>user</parameter>,
                                  <parameter>database</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>does user have privilege for database</entry>
-->
       <entry>ユーザにデータベースに対する権限があるのか</entry>
      </row>
      <row>
       <entry><literal><function>has_database_privilege</function>(<parameter>database</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>does current user have privilege for database</entry>
-->
       <entry>現在のユーザにデータベースに対する権限があるのか</entry>
      </row>
      <row>
       <entry><literal><function>has_foreign_data_wrapper_privilege</function>(<parameter>user</parameter>,
                                  <parameter>fdw</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>does user have privilege for foreign-data wrapper</entry>
-->
       <entry>ユーザに外部データラッパに対する権限があるのか</entry>
      </row>
      <row>
       <entry><literal><function>has_foreign_data_wrapper_privilege</function>(<parameter>fdw</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>does current user have privilege for foreign-data wrapper</entry>
-->
       <entry>現在のユーザに外部データラッパに対する権限があるのか</entry>
      </row>
      <row>
       <entry><literal><function>has_function_privilege</function>(<parameter>user</parameter>,
                                  <parameter>function</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>does user have privilege for function</entry>
-->
       <entry>ユーザに関数に対する権限があるのか</entry>
      </row>
      <row>
       <entry><literal><function>has_function_privilege</function>(<parameter>function</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>does current user have privilege for function</entry>
-->
       <entry>現在のユーザに関数に対する権限があるのか</entry>
      </row>
      <row>
       <entry><literal><function>has_language_privilege</function>(<parameter>user</parameter>,
                                  <parameter>language</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>does user have privilege for language</entry>
-->
       <entry>ユーザに言語に対する権限があるのか</entry>
      </row>
      <row>
       <entry><literal><function>has_language_privilege</function>(<parameter>language</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>does current user have privilege for language</entry>
-->
       <entry>現在のユーザに言語に対する権限があるのか</entry>
      </row>
      <row>
       <entry><literal><function>has_schema_privilege</function>(<parameter>user</parameter>,
                                  <parameter>schema</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>does user have privilege for schema</entry>
-->
       <entry>ユーザにスキーマに対する権限があるのか</entry>
      </row>
      <row>
       <entry><literal><function>has_schema_privilege</function>(<parameter>schema</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>does current user have privilege for schema</entry>
-->
       <entry>現在のユーザにスキーマに対する権限があるのか</entry>
      </row>
      <row>
       <entry><literal><function>has_sequence_privilege</function>(<parameter>user</parameter>,
                                  <parameter>sequence</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>does user have privilege for sequence</entry>
-->
       <entry>ユーザにシーケンスに対する権限があるのか</entry>
      </row>
      <row>
       <entry><literal><function>has_sequence_privilege</function>(<parameter>sequence</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>does current user have privilege for sequence</entry>
-->
       <entry>現在のユーザにシーケンスに対する権限があるのか</entry>
      </row>
      <row>
       <entry><literal><function>has_server_privilege</function>(<parameter>user</parameter>,
                                  <parameter>server</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>does user have privilege for foreign server</entry>
-->
       <entry>ユーザに外部サーバに対する権限があるのか</entry>
      </row>
      <row>
       <entry><literal><function>has_server_privilege</function>(<parameter>server</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>does current user have privilege for foreign server</entry>
-->
       <entry>現在のユーザに外部サーバに対する権限があるのか</entry>
      </row>
      <row>
       <entry><literal><function>has_table_privilege</function>(<parameter>user</parameter>,
                                  <parameter>table</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>does user have privilege for table</entry>
-->
       <entry>ユーザにテーブルに対する権限があるのか</entry>
      </row>
      <row>
       <entry><literal><function>has_table_privilege</function>(<parameter>table</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>does current user have privilege for table</entry>
-->
       <entry>現在のユーザにテーブルに対する権限があるのか</entry>
      </row>
      <row>
       <entry><literal><function>has_tablespace_privilege</function>(<parameter>user</parameter>,
                                  <parameter>tablespace</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>does user have privilege for tablespace</entry>
-->
       <entry>ユーザにテーブル空間に対する権限があるのか</entry>
      </row>
      <row>
       <entry><literal><function>has_tablespace_privilege</function>(<parameter>tablespace</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>does current user have privilege for tablespace</entry>
-->
       <entry>現在のユーザにテーブル空間に対する権限があるのか</entry>
      </row>
      <row>
       <entry><literal><function>pg_has_role</function>(<parameter>user</parameter>,
                                  <parameter>role</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>does user have privilege for role</entry>
-->
       <entry>ユーザにロールに対する権限があるのか</entry>
      </row>
      <row>
       <entry><literal><function>pg_has_role</function>(<parameter>role</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>does current user have privilege for role</entry>
-->
       <entry>現在のユーザにロールに対する権限があるのか</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <indexterm>
    <primary>has_any_column_privilege</primary>
   </indexterm>
   <indexterm>
    <primary>has_column_privilege</primary>
   </indexterm>
   <indexterm>
    <primary>has_database_privilege</primary>
   </indexterm>
   <indexterm>
    <primary>has_function_privilege</primary>
   </indexterm>
   <indexterm>
    <primary>has_foreign_data_wrapper_privilege</primary>
   </indexterm>
   <indexterm>
    <primary>has_language_privilege</primary>
   </indexterm>
   <indexterm>
    <primary>has_schema_privilege</primary>
   </indexterm>
   <indexterm>
    <primary>has_server_privilege</primary>
   </indexterm>
   <indexterm>
    <primary>has_sequence_privilege</primary>
   </indexterm>
   <indexterm>
    <primary>has_table_privilege</primary>
   </indexterm>
   <indexterm>
    <primary>has_tablespace_privilege</primary>
   </indexterm>
   <indexterm>
    <primary>pg_has_role</primary>
   </indexterm>

   <para>
<!--
    <function>has_table_privilege</function> checks whether a user
    can access a table in a particular way.  The user can be
    specified by name, by OID (<literal>pg_authid.oid</literal>),
    <literal>public</> to indicate the PUBLIC pseudo-role, or if the argument is
    omitted
    <function>current_user</function> is assumed.  The table can be specified
    by name or by OID.  (Thus, there are actually six variants of
    <function>has_table_privilege</function>, which can be distinguished by
    the number and types of their arguments.)  When specifying by name,
    the name can be schema-qualified if necessary.
    The desired access privilege type
    is specified by a text string, which must evaluate to one of the
    values <literal>SELECT</literal>, <literal>INSERT</literal>,
    <literal>UPDATE</literal>, <literal>DELETE</literal>, <literal>TRUNCATE</>,
    <literal>REFERENCES</literal>, or <literal>TRIGGER</literal>.  Optionally,
    <literal>WITH GRANT OPTION</> can be added to a privilege type to test
    whether the privilege is held with grant option.  Also, multiple privilege
    types can be listed separated by commas, in which case the result will
    be <literal>true</> if any of the listed privileges is held.
    (Case of the privilege string is not significant, and extra whitespace
    is allowed between but not within privilege names.)
    Some examples:
-->
<function>has_table_privilege</function>はあるユーザが特定の方法でテーブルにアクセス可能かどうかを検査します。
ユーザは名前、OID(<literal>pg_authid.oid</literal>)、もしくは擬似的なPUBLICロールを意味する<literal>public</>で指定できます。省略された場合は<function>current_user</function>が使われます。
テーブルは名前もしくはOIDで指定可能です。
（従って、実際には<function>has_table_privilege</function>の６つの変形があり、引数の数と型で区別されます。）
名前を指定する場合、必要であればスキーマ権限で指定できます。
目的とするアクセス権限の型はテキスト文字列で指定され、それは、<literal>SELECT</literal>、<literal>INSERT</literal>、<literal>UPDATE</literal>、<literal>DELETE</literal>、<literal>TRUNCATE</>、<literal>REFERENCES</literal>、または<literal>TRIGGER</literal>の内の１つで評価されます。
オプションとして、権限がGRANTオプションにより付与されているかどうかの権限の検査するため、<literal>WITH GRANT OPTION</>を付加することができます。
更に、複数の権限型はコンマで区切ってリスト可能です。この場合、結果はリストされた権限の１つでも存在すれば<literal>真</>となります。
（権限文字列の大文字小文字は重要ではなく、余分な空白は権限名の間にはあっても良いですが、中にはあってはいけません。）
例を示します。

<programlisting>
SELECT has_table_privilege('myschema.mytable', 'select');
SELECT has_table_privilege('joe', 'mytable', 'INSERT, SELECT WITH GRANT OPTION');
</programlisting>
   </para>

   <para>
<!--
    <function>has_sequence_privilege</function> checks whether a user
    can access a sequence in a particular way.  The possibilities for its
    arguments are analogous to <function>has_table_privilege</function>.
    The desired access privilege type must evaluate to one of
    <literal>USAGE</literal>,
    <literal>SELECT</literal>, or
    <literal>UPDATE</literal>.
-->
<function>has_sequence_privilege</function>はあるユーザが特定の方法でシーケンスにアクセス可能かどうかを検査します。
可能な引数は<function>has_table_privilege</>に対するものと類似しています。
<literal>USAGE</literal>、<literal>SELECT</literal>または<literal>UPDATE</literal>の内のいずれかにより目的とする権限型が評価されます。
   </para>

   <para>
<!--
    <function>has_any_column_privilege</function> checks whether a user can
    access any column of a table in a particular way.
    Its argument possibilities
    are analogous to <function>has_table_privilege</>,
    except that the desired access privilege type must evaluate to some
    combination of
    <literal>SELECT</literal>,
    <literal>INSERT</literal>,
    <literal>UPDATE</literal>, or
    <literal>REFERENCES</literal>.  Note that having any of these privileges
    at the table level implicitly grants it for each column of the table,
    so <function>has_any_column_privilege</function> will always return
    <literal>true</> if <function>has_table_privilege</> does for the same
    arguments.  But <function>has_any_column_privilege</> also succeeds if
    there is a column-level grant of the privilege for at least one column.
-->
<function>has_any_column_privilege</function>はあるユーザが特定の方法でテーブルのどんな列にもアクセス可能かどうかを検査します。
可能な引数は<function>has_table_privilege</>に対するものと類似していますが、<literal>SELECT</literal>、<literal>INSERT</literal>、<literal>UPDATE</literal>、または<literal>REFERENCES</literal>のいくつかの組み合わせで目的とする権限型が評価される点を除きます。
テーブル階層におけるこれらの権限を所有することは、テーブルのそれぞれの列に対し暗黙的にそれら権限を与えることに注意してください。従って、同一の引数に対して<function>has_table_privilege</>が<literal>真</>を返す場合、<function>has_any_column_privilege</function>は常に<literal>真</>を返します。
しかし、少なくとも一つの列に対し権限の列階層許可があれば、<function>has_any_column_privilege</>も成功します。
   </para>

   <para>
<!--
    <function>has_column_privilege</function> checks whether a user
    can access a column in a particular way.
    Its argument possibilities
    are analogous to <function>has_table_privilege</function>,
    with the addition that the column can be specified either by name
    or attribute number.
    The desired access privilege type must evaluate to some combination of
    <literal>SELECT</literal>,
    <literal>INSERT</literal>,
    <literal>UPDATE</literal>, or
    <literal>REFERENCES</literal>.  Note that having any of these privileges
    at the table level implicitly grants it for each column of the table.
-->
<function>has_column_privilege</function>はあるユーザが特定の方法でテーブルのある列にもアクセス可能かどうかを検査します。
可能な引数は、列が追加的に名前または属性番号のいずれかで指定される点を加えれば、<function>has_table_privilege</function>と類似しています。
目的とするアクセス権限型は、<literal>SELECT</literal>、<literal>INSERT</literal>、<literal>UPDATE</literal>、または<literal>REFERENCES</literal>のいくつかの組み合わせで評価されなければなりません。
テーブル階層におけるこれらの権限を所有することは、テーブルのそれぞれの列に対し暗黙的にそれら権限を与えることに注意してください。
   </para>

   <para>
<!--
    <function>has_database_privilege</function> checks whether a user
    can access a database in a particular way.
    Its argument possibilities
    are analogous to <function>has_table_privilege</function>.
    The desired access privilege type must evaluate to some combination of
    <literal>CREATE</literal>,
    <literal>CONNECT</literal>,
    <literal>TEMPORARY</literal>, or
    <literal>TEMP</literal> (which is equivalent to
    <literal>TEMPORARY</literal>).
-->
<function>has_database_privilege</function>関数は、あるユーザが特定の方法でデータベースにアクセス可能かどうかを検査します。
可能な引数は、<function>has_table_privilege</function>に類似しています。
対象とするアクセス権限の種類は、<literal>CREATE</literal>、<literal>CONNECT</literal>、<literal>TEMPORARY</literal>、または<literal>TEMP</literal>（<literal>TEMPORARY</literal>と同じ）のいくつかの組み合わせで評価する必要があります。
   </para>

   <para>
<!--
    <function>has_function_privilege</function> checks whether a user
    can access a function in a particular way.
    Its argument possibilities
    are analogous to <function>has_table_privilege</function>.
    When specifying a function by a text string rather than by OID,
    the allowed input is the same as for the <type>regprocedure</> data type
    (see <xref linkend="datatype-oid">).
    The desired access privilege type must evaluate to
    <literal>EXECUTE</literal>.
    An example is:
-->
 <function>has_function_privilege</function>関数は、あるユーザが特定の方法で関数にアクセス可能かどうかを検査します。
 引数として取り得るものは<function>has_table_privilege</function>と同じです。
関数をOIDではなくテキスト文字列で指定した場合、<type>regprocedure</> データ型（<xref linkend="datatype-oid">を参照）と同じ入力が可能です。
対象とするアクセス権限の種類は、現在<literal>EXECUTE</literal>で評価する必要があります。
以下に例を示します。
<programlisting>
SELECT has_function_privilege('joeuser', 'myfunc(int, text)', 'execute');
</programlisting>
   </para>

   <para>
<!--
    <function>has_foreign_data_wrapper_privilege</function> checks whether a user
    can access a foreign-data wrapper in a particular way.
    Its argument possibilities
    are analogous to <function>has_table_privilege</function>.
    The desired access privilege type must evaluate to
    <literal>USAGE</literal>.
-->
<function>has_foreign_data_wrapper_privilege</function>関数は、あるユーザが特定の方法で外部データラッパーにアクセス可能かどうかを検査します。
引数として取り得るものは<function>has_table_privilege</function>と同じです。
対象とするアクセス権限の種類は<literal>USAGE</literal>で評価する必要があります。
   </para>

   <para>
<!--
    <function>has_language_privilege</function> checks whether a user
    can access a procedural language in a particular way.
    Its argument possibilities
    are analogous to <function>has_table_privilege</function>.
    The desired access privilege type must evaluate to
    <literal>USAGE</literal>.
-->
<function>has_language_privilege</function>関数は、あるユーザが特定の方法で手続き言語にアクセス可能かどうかを検査します。
可能な引数は、<function>has_table_privilege</function>に類似しています。
対象とするアクセス権限の種類は、現在<literal>USAGE</literal>で評価する必要があります。
   </para>

   <para>
<!--
    <function>has_schema_privilege</function> checks whether a user
    can access a schema in a particular way.
    Its argument possibilities
    are analogous to <function>has_table_privilege</function>.
    The desired access privilege type must evaluate to some combination of
    <literal>CREATE</literal> or
    <literal>USAGE</literal>.
-->
<function>has_schema_privilege</function>関数は、あるユーザが特定の方法でスキーマにアクセス可能かどうかを検査します。
可能な引数は、<function>has_table_privilege</function>に類似しています。
対象とするアクセス権限の種類は、<literal>CREATE</literal>もしくは<literal>USAGE</literal>の何らかの組み合わせで評価する必要があります。
   </para>

   <para>
<!--
    <function>has_server_privilege</function> checks whether a user
    can access a foreign server in a particular way.
    Its argument possibilities
    are analogous to <function>has_table_privilege</function>.
    The desired access privilege type must evaluate to
    <literal>USAGE</literal>.

-->
<function>has_server_privilege</function>はユーザが特定の方法で外部サーバにアクセスできるかどうかを検査します。
可能な引数は<function>has_table_privilege</function>に類似しています。対象とするアクセス権限は<literal>USAGE</literal>で評価する必要があります。
   </para>

   <para>
<!--
    <function>has_tablespace_privilege</function> checks whether a user
    can access a tablespace in a particular way.
    Its argument possibilities
    are analogous to <function>has_table_privilege</function>.
    The desired access privilege type must evaluate to
    <literal>CREATE</literal>.
-->
<function>has_tablespace_privilege</function>関数は、あるユーザが特定の方法でテーブル空間にアクセス可能かどうかを検査します。
可能な引数は、<function>has_table_privilege</function>に類似しています。
対象とするアクセス権限の種類は、<literal>CREATE</literal>で評価する必要があります。
   </para>

   <para>
<!--
    <function>pg_has_role</function> checks whether a user
    can access a role in a particular way.
    Its argument possibilities
    are analogous to <function>has_table_privilege</function>,
    except that <literal>public</> is not allowed as a user name.
    The desired access privilege type must evaluate to some combination of
    <literal>MEMBER</literal> or
    <literal>USAGE</literal>.
    <literal>MEMBER</literal> denotes direct or indirect membership in
    the role (that is, the right to do <command>SET ROLE</>), while
    <literal>USAGE</literal> denotes whether the privileges of the role
    are immediately available without doing <command>SET ROLE</>.
-->
<function>pg_has_role</function>は、ユーザが特定の方法でロールにアクセスできるかどうかを検査します。
取り得る引数については、<literal>public</>がユーザ名として使用不可であることを除き、<function>has_table_privilege</function>と類似しています。
対象とするアクセス権限の種類は、 <literal>MEMBER</literal>、<literal>USAGE</literal>の組み合わせで評価する必要があります。
<literal>MEMBER</literal>は、ロールの直接または間接メンバ資格（つまり、<command>SET ROLE</>を行う権限）を表します。一方、<literal>USAGE</literal>は、そのロール権限が<command>SET ROLE</>をしなくてもすぐに利用できることを表します。
   </para>

  <para>
<!--
   <xref linkend="functions-info-schema-table"> shows functions that
   determine whether a certain object is <firstterm>visible</> in the
   current schema search path.
   For example, a table is said to be visible if its
   containing schema is in the search path and no table of the same
   name appears earlier in the search path.  This is equivalent to the
   statement that the table can be referenced by name without explicit
   schema qualification.  To list the names of all visible tables:
-->
<xref linkend="functions-info-schema-table">に、特定のオブジェクトが、現行スキーマの検索パスにおいて<firstterm>可視</>かどうかを判別する関数を示します。
例えば、あるテーブルを含むスキーマが検索パス内に存在し、検索パス内の前方に同じ名前のテーブルがない場合、そのテーブルは可視であると言います。
つまり、これは、テーブルが明示的なスキーマ修飾なしで名前によって参照可能であるということです。
全ての可視テーブルの名前を列挙するには以下のようにします。
<programlisting>
SELECT relname FROM pg_class WHERE pg_table_is_visible(oid);
</programlisting>
  </para>

   <indexterm>
<!--
    <primary>search path</primary>
    <secondary>object visibility</secondary>
-->
    <primary>検索パス</primary>
    <secondary>オブジェクトの可視性</secondary>   
   </indexterm>

   <table id="functions-info-schema-table">
<!--
    <title>Schema Visibility Inquiry Functions</title>
-->
    <title>スキーマ可視性照会関数</title>
    <tgroup cols="3">
     <thead>
<!--
      <row><entry>Name</entry> <entry>Return Type</entry> <entry>Description</entry></row>
-->
      <row><entry>名前</entry> <entry>戻り型</entry> <entry>説明</entry></row>
     </thead>

     <tbody>
      <row>
       <entry><literal><function>pg_collation_is_visible(<parameter>collation_oid</parameter>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>is collation visible in search path</entry>
-->
       <entry>照合順序が検索パスにおいて可視かどうか</entry>
      </row>
      <row>
       <entry><literal><function>pg_conversion_is_visible(<parameter>conversion_oid</parameter>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>is conversion visible in search path</entry>
-->
       <entry>変換が検索パスにおいて可視かどうか</entry>
      </row>
      <row>
       <entry><literal><function>pg_function_is_visible(<parameter>function_oid</parameter>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>is function visible in search path</entry>
-->
       <entry>関数が検索パスにおいて可視であるか</entry>
      </row>
      <row>
       <entry><literal><function>pg_opclass_is_visible(<parameter>opclass_oid</parameter>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>is operator class visible in search path</entry>
-->
       <entry>演算子クラスが検索パスにおいて可視であるか</entry>
      </row>
      <row>
       <entry><literal><function>pg_operator_is_visible(<parameter>operator_oid</parameter>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>is operator visible in search path</entry>
-->
       <entry>演算子が検索パスにおいて可視であるか</entry>
      </row>
      <row>
       <entry><literal><function>pg_opfamily_is_visible(<parameter>opclass_oid</parameter>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>is operator family visible in search path</entry>
-->
       <entry>演算子族が検索パスにおいて可視であるか</entry>
      </row>
      <row>
       <entry><literal><function>pg_table_is_visible(<parameter>table_oid</parameter>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>is table visible in search path</entry>
-->
       <entry>テーブルが検索パスにおいて可視かどうか</entry>
      </row>
      <row>
       <entry><literal><function>pg_ts_config_is_visible(<parameter>config_oid</parameter>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>is text search configuration visible in search path</entry>
-->
       <entry>テキスト検索設定が検索パスにおいて可視かどうか</entry>
      </row>
      <row>
       <entry><literal><function>pg_ts_dict_is_visible(<parameter>dict_oid</parameter>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>is text search dictionary visible in search path</entry>
-->
       <entry>テキスト検索辞書が検索パスにおいて可視かどうか</entry>
      </row>
      <row>
       <entry><literal><function>pg_ts_parser_is_visible(<parameter>parser_oid</parameter>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>is text search parser visible in search path</entry>
-->
       <entry>テキスト検索パーサが検索パスにおいて可視かどうか</entry>
      </row>
      <row>
       <entry><literal><function>pg_ts_template_is_visible(<parameter>template_oid</parameter>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>is text search template visible in search path</entry>
-->
       <entry>テキスト検索テンプレートが検索パスにおいて可視かどうか</entry>
      </row>
      <row>
       <entry><literal><function>pg_type_is_visible(<parameter>type_oid</parameter>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>is type (or domain) visible in search path</entry>
-->
       <entry>型（またはドメイン）が検索パスにおいて可視かどうか</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <indexterm>
    <primary>pg_collation_is_visible</primary>
   </indexterm>
   <indexterm>
    <primary>pg_conversion_is_visible</primary>
   </indexterm>
   <indexterm>
    <primary>pg_function_is_visible</primary>
   </indexterm>
   <indexterm>
    <primary>pg_opclass_is_visible</primary>
   </indexterm>
   <indexterm>
    <primary>pg_operator_is_visible</primary>
   </indexterm>
   <indexterm>
    <primary>pg_opfamily_is_visible</primary>
   </indexterm>
   <indexterm>
    <primary>pg_table_is_visible</primary>
   </indexterm>
   <indexterm>
    <primary>pg_ts_config_is_visible</primary>
   </indexterm>
   <indexterm>
    <primary>pg_ts_dict_is_visible</primary>
   </indexterm>
   <indexterm>
    <primary>pg_ts_parser_is_visible</primary>
   </indexterm>
   <indexterm>
    <primary>pg_ts_template_is_visible</primary>
   </indexterm>
   <indexterm>
    <primary>pg_type_is_visible</primary>
   </indexterm>

   <para>
<!--
    Each function performs the visibility check for one type of database
    object.  Note that <function>pg_table_is_visible</function> can also be used
    with views, indexes and sequences; <function>pg_type_is_visible</function>
    can also be used with domains. For functions and operators, an object in
    the search path is visible if there is no object of the same name
    <emphasis>and argument data type(s)</> earlier in the path.  For operator
    classes, both name and associated index access method are considered.
-->
それぞれの関数はデータベースオブジェクトの１つの型に対して可視性の検査を行います。
<function>pg_table_is_visible</function>がビュー、インデックス、シーケンスに対しても使用できること、<function>pg_type_is_visible</function>がドメインに対しても使用できることに注意してください。
関数および演算子では、パスの前方に同じ名前かつ同じ<emphasis>引数のデータ型</>を持つオブジェクトが存在しなければ、検索パス内のオブジェクトは可視です。
演算子クラスでは、名前と関連するインデックスアクセスメソッドが考慮されます。
   </para>

   <para>
<!--
    All these functions require object OIDs to identify the object to be
    checked.  If you want to test an object by name, it is convenient to use
    the OID alias types (<type>regclass</>, <type>regtype</>,
    <type>regprocedure</>, <type>regoperator</>, <type>regconfig</>,
    or <type>regdictionary</>),
    for example:
-->
これらの関数は全て、検査するオブジェクトを識別するために、オブジェクトのOIDを必要とします。
オブジェクトを名前でテストする場合、OID別名型（<type>regclass</>、<type>regtype</>、<type>regprocedure</>、<type>regoperator</>、<type>regconfig</>、または<type>regdictionary</>）を使用すると便利です。
例えば、以下のようにします。
<programlisting>
SELECT pg_type_is_visible('myschema.widget'::regtype);
</programlisting>
<!--
    Note that it would not make much sense to test a non-schema-qualified
    type name in this way &mdash; if the name can be recognized at all, it must be visible.
-->
ただし、このようなやり方でスキーマ修飾されていない型名をテストしても、あまり意味がないことに注意してください。名前が認識されれば、それは必ず可視ということになります。
   </para>

   <indexterm>
    <primary>format_type</primary>
   </indexterm>

   <indexterm>
    <primary>pg_describe_object</primary>
   </indexterm>

   <indexterm>
    <primary>pg_identify_object</primary>
   </indexterm>

   <indexterm>
    <primary>pg_get_constraintdef</primary>
   </indexterm>

   <indexterm>
    <primary>pg_get_expr</primary>
   </indexterm>

   <indexterm>
    <primary>pg_get_functiondef</primary>
   </indexterm>

   <indexterm>
    <primary>pg_get_function_arguments</primary>
   </indexterm>

   <indexterm>
    <primary>pg_get_function_identity_arguments</primary>
   </indexterm>

   <indexterm>
    <primary>pg_get_function_result</primary>
   </indexterm>

   <indexterm>
    <primary>pg_get_indexdef</primary>
   </indexterm>

   <indexterm>
    <primary>pg_get_keywords</primary>
   </indexterm>

   <indexterm>
    <primary>pg_get_ruledef</primary>
   </indexterm>

   <indexterm>
    <primary>pg_get_serial_sequence</primary>
   </indexterm>

   <indexterm>
    <primary>pg_get_triggerdef</primary>
   </indexterm>

   <indexterm>
    <primary>pg_get_userbyid</primary>
   </indexterm>

   <indexterm>
    <primary>pg_get_viewdef</primary>
   </indexterm>

   <indexterm>
    <primary>pg_options_to_table</primary>
   </indexterm>

   <indexterm>
    <primary>pg_tablespace_databases</primary>
   </indexterm>

   <indexterm>
    <primary>pg_tablespace_location</primary>
   </indexterm>

   <indexterm>
    <primary>pg_typeof</primary>
   </indexterm>

   <indexterm>
    <primary>collation for</primary>
   </indexterm>

   <indexterm>
    <primary>to_regclass</primary>
   </indexterm>

   <indexterm>
    <primary>to_regproc</primary>
   </indexterm>

   <indexterm>
    <primary>to_regprocedure</primary>
   </indexterm>

   <indexterm>
    <primary>to_regoper</primary>
   </indexterm>

   <indexterm>
    <primary>to_regoperator</primary>
   </indexterm>

   <indexterm>
    <primary>to_regtype</primary>
   </indexterm>

  <para>
<!--
   <xref linkend="functions-info-catalog-table"> lists functions that
   extract information from the system catalogs.
-->
<xref linkend="functions-info-catalog-table">に、システムカタログから情報を抽出する関数を列挙します。
  </para>

   <table id="functions-info-catalog-table">
<!--
    <title>System Catalog Information Functions</title>
-->
    <title>システムカタログ情報関数</title>
    <tgroup cols="3">
     <thead>
<!--
      <row><entry>Name</entry> <entry>Return Type</entry> <entry>Description</entry></row>
-->
      <row><entry>名前</entry> <entry>戻り型</entry> <entry>説明</entry></row>
     </thead>

     <tbody>
      <row>
       <entry><literal><function>format_type(<parameter>type_oid</parameter>, <parameter>typemod</>)</function></literal></entry>
       <entry><type>text</type></entry>
<!--
       <entry>get SQL name of a data type</entry>
-->
       <entry>データ型のSQL名の取得</entry>
      </row>
      <row>
       <entry><literal><function>pg_describe_object(<parameter>catalog_id</parameter>, <parameter>object_id</parameter>, <parameter>object_sub_id</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
<!--
       <entry>get description of a database object</entry>
-->
       <entry>データベースオブジェクトの説明の取得</entry>
      </row>
      <row>
       <entry><literal><function>pg_identify_object(<parameter>catalog_id</parameter> <type>oid</>, <parameter>object_id</parameter> <type>oid</>, <parameter>object_sub_id</parameter> <type>integer</>)</function></literal></entry>
       <entry><parameter>type</> <type>text</>, <parameter>schema</> <type>text</>, <parameter>name</> <type>text</>, <parameter>identity</> <type>text</></entry>
<!--
       <entry>get identity of a database object</entry>
-->
       <entry>データベースオブジェクトの識別を取得</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_constraintdef(<parameter>constraint_oid</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
<!--
       <entry>get definition of a constraint</entry>
-->
       <entry>制約の定義を取得</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_constraintdef(<parameter>constraint_oid</parameter>, <parameter>pretty_bool</>)</function></literal></entry>
       <entry><type>text</type></entry>
<!--
       <entry>get definition of a constraint</entry>
-->
       <entry>制約の定義を取得</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_expr(<parameter>pg_node_tree</parameter>, <parameter>relation_oid</>)</function></literal></entry>
       <entry><type>text</type></entry>
<!--
       <entry>decompile internal form of an expression, assuming that any Vars
       in it refer to the relation indicated by the second parameter</entry>
-->
       <entry>式中のいかなるVarも、２番目のパラメータによって指定されるリレーションを参照すると仮定して、式の内部形式を逆コンパイル</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_expr(<parameter>pg_node_tree</parameter>, <parameter>relation_oid</>, <parameter>pretty_bool</>)</function></literal></entry>
       <entry><type>text</type></entry>
<!--
       <entry>decompile internal form of an expression, assuming that any Vars
       in it refer to the relation indicated by the second parameter</entry>
-->
       <entry>式中のいかなるVarも、２番目のパラメータによって指定されるリレーションを参照すると仮定して、式の内部形式を逆コンパイル</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_functiondef(<parameter>func_oid</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
<!--
       <entry>get definition of a function</entry>
-->
       <entry>関数定義の取得</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_function_arguments(<parameter>func_oid</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
<!--
       <entry>get argument list of function's definition (with default values)</entry>
-->
       <entry>関数定義（デフォルト値付き）の引数リストを取得</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_function_identity_arguments(<parameter>func_oid</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
<!--
       <entry>get argument list to identify a function (without default values)</entry>
-->
       <entry>関数（デフォルト値の付いていない）特定の引数リストを取得</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_function_result(<parameter>func_oid</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
<!--
       <entry>get <literal>RETURNS</> clause for function</entry>
-->
       <entry>関数に対する<literal>RETURNS</>句の取得</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_indexdef(<parameter>index_oid</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
<!--
       <entry>get <command>CREATE INDEX</> command for index</entry>
-->
       <entry>インデックスに対する<command>CREATE INDEX</>コマンドの取得</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_indexdef(<parameter>index_oid</parameter>, <parameter>column_no</>, <parameter>pretty_bool</>)</function></literal></entry>
       <entry><type>text</type></entry>
<!--
       <entry>get <command>CREATE INDEX</> command for index,
       or definition of just one index column when
       <parameter>column_no</> is not zero</entry>
-->
       <entry>インデックスに対する<command>CREATE INDEX</>コマンドの取得、または<parameter>column_no</>が非ゼロの場合は、１つのインデックス列のみの定義の取得</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_keywords()</function></literal></entry>
       <entry><type>setof record</type></entry>
<!--
       <entry>get list of SQL keywords and their categories</entry>
-->
       <entry>SQLキーワードとそれらの種類のリストを取得</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_ruledef(<parameter>rule_oid</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
<!--
       <entry>get <command>CREATE RULE</> command for rule</entry>
-->
       <entry>ルールに対する<command>CREATE RULE</>コマンドを取得</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_ruledef(<parameter>rule_oid</parameter>, <parameter>pretty_bool</>)</function></literal></entry>
       <entry><type>text</type></entry>
<!--
       <entry>get <command>CREATE RULE</> command for rule</entry>
-->
       <entry>ルールに対する<command>CREATE RULE</>コマンドを取得</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_serial_sequence(<parameter>table_name</parameter>, <parameter>column_name</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
<!--
       <entry>get name of the sequence that a <type>serial</type>, <type>smallserial</type> or <type>bigserial</type> column
       uses</entry>
-->
       <entry><type>serial</type>、<type>smallserial</type>、または<type>bigserial</type>列が使用するシーケンス名の取得</entry>
      </row>
      <row>
       <entry><function>pg_get_triggerdef</function>(<parameter>trigger_oid</parameter>)</entry>
       <entry><type>text</type></entry>
<!--
       <entry>get <command>CREATE [ CONSTRAINT ] TRIGGER</> command for trigger</entry>
-->
       <entry>トリガに対する<command>CREATE [ CONSTRAINT ] TRIGGER</>コマンドの取得</entry>
      </row>
      <row>
       <entry><function>pg_get_triggerdef</function>(<parameter>trigger_oid</parameter>, <parameter>pretty_bool</>)</entry>
       <entry><type>text</type></entry>
<!--
       <entry>get <command>CREATE [ CONSTRAINT ] TRIGGER</> command for trigger</entry>
-->
       <entry>トリガに対する<command>CREATE [ CONSTRAINT ] TRIGGER</>コマンドの取得</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_userbyid(<parameter>role_oid</parameter>)</function></literal></entry>
       <entry><type>name</type></entry>
<!--
       <entry>get role name with given OID</entry>
-->
       <entry>与えられたOIDでロール名を取得</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_viewdef(<parameter>view_name</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
<!--
       <entry>get underlying <command>SELECT</command> command for view or materialized view (<emphasis>deprecated</emphasis>)</entry>
-->
       <entry>ビューまたはマテリアライズドビューの元になる<command>SELECT</command>コマンドを取得（<emphasis>廃止予定</emphasis>）</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_viewdef(<parameter>view_name</parameter>, <parameter>pretty_bool</>)</function></literal></entry>
       <entry><type>text</type></entry>
<!--
       <entry>get underlying <command>SELECT</command> command for view or materialized view (<emphasis>deprecated</emphasis>)</entry>
-->
       <entry>ビューまたはマテリアライズドビューの元になる<command>SELECT</command>コマンドを取得（<emphasis>廃止予定</emphasis>）</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_viewdef(<parameter>view_oid</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
<!--
       <entry>get underlying <command>SELECT</command> command for view or materialized view</entry>
-->
       <entry>ビューまたはマテリアライズドビューの元になる<command>SELECT</command>コマンドを取得</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_viewdef(<parameter>view_oid</parameter>, <parameter>pretty_bool</>)</function></literal></entry>
       <entry><type>text</type></entry>
<!--
       <entry>get underlying <command>SELECT</command> command for view or materialized view</entry>
-->
       <entry>ビューまたはマテリアライズドビューの元になる<command>SELECT</command>コマンドを取得</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_viewdef(<parameter>view_oid</parameter>, <parameter>wrap_column_int</>)</function></literal></entry>
       <entry><type>text</type></entry>
<!--
       <entry>get underlying <command>SELECT</command> command for view or
              materialized view; lines with fields are wrapped to specified
              number of columns, pretty-printing is implied</entry>
-->
       <entry>ビューまたはマテリアライズドビューの元になる<command>SELECT</command>コマンドを取得。
       フィールドを含む行は指定された列数で折り返され、成形された表示が行われます。</entry>
      </row>
      <row>
       <entry><literal><function>pg_options_to_table(<parameter>reloptions</parameter>)</function></literal></entry>
       <entry><type>setof record</type></entry>
<!--
       <entry>get the set of storage option name/value pairs</entry>
-->
       <entry>格納オプションの名前/値のペアのセットを取得</entry>
      </row>
      <row>
       <entry><literal><function>pg_tablespace_databases(<parameter>tablespace_oid</parameter>)</function></literal></entry>
       <entry><type>setof oid</type></entry>
<!--
       <entry>get the set of database OIDs that have objects in the tablespace</entry>
-->
       <entry>テーブル空間内にオブジェクトを所有するデータベースOID集合を取得</entry>
      </row>
      <row>
       <entry><literal><function>pg_tablespace_location(<parameter>tablespace_oid</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
<!--
       <entry>get the path in the file system that this tablespace is located in</entry>
-->
       <entry>指定したテーブル空間が実際に配置されているファイルシステム上のパスを取得</entry>
      </row>
      <row>
       <entry><literal><function>pg_typeof(<parameter>any</parameter>)</function></literal></entry>
       <entry><type>regtype</type></entry>
<!--
       <entry>get the data type of any value</entry>
-->
       <entry>指定した値のデータ型を取得</entry>
      </row>
      <row>
       <entry><literal><function>collation for (<parameter>any</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
<!--
       <entry>get the collation of the argument</entry>
-->
       <entry>引数の照合順序を取得</entry>
      </row>
      <row>
       <entry><literal><function>to_regclass(<parameter>rel_name</parameter>)</function></literal></entry>
       <entry><type>regclass</type></entry>
<!--
       <entry>get the OID of the named relation</entry>
-->
       <entry>名前付けされたリレーションのOIDを取得</entry>

      </row>
      <row>
       <entry><literal><function>to_regproc(<parameter>func_name</parameter>)</function></literal></entry>
       <entry><type>regproc</type></entry>
<!--
       <entry>get the OID of the named function</entry>
-->
       <entry>名前付けされた関数のOIDを取得</entry>
      </row>
      <row>
       <entry><literal><function>to_regprocedure(<parameter>func_name</parameter>)</function></literal></entry>
       <entry><type>regprocedure</type></entry>
<!--
       <entry>get the OID of the named function</entry>
-->
       <entry>名前付けされた関数のOIDを取得</entry>
      </row>
      <row>
       <entry><literal><function>to_regoper(<parameter>operator_name</parameter>)</function></literal></entry>
       <entry><type>regoper</type></entry>
<!--
       <entry>get the OID of the named operator</entry>
-->
       <entry>名前付けされた演算子のOIDを取得</entry>
      </row>
      <row>
       <entry><literal><function>to_regoperator(<parameter>operator_name</parameter>)</function></literal></entry>
       <entry><type>regoperator</type></entry>
<!--
       <entry>get the OID of the named operator</entry>
-->
       <entry>名前付けされた演算子のOIDを取得</entry>
      </row>
      <row>
       <entry><literal><function>to_regtype(<parameter>type_name</parameter>)</function></literal></entry>
       <entry><type>regtype</type></entry>
<!--
       <entry>get the OID of the named type</entry>
-->
       <entry>名前付けされた型のOIDを取得</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <para>
<!--
   <function>format_type</function> returns the SQL name of a data type that
   is identified by its type OID and possibly a type modifier.  Pass NULL
   for the type modifier if no specific modifier is known.
-->
関数<function>format_type</function>は、自身の型OIDと場合により型修飾子によって特定されるデータ型のSQL名を返します。
特定の修飾子が既知でなければ型修飾子にNULLを渡します。
  </para>

  <para>
<!--
   <function>pg_get_keywords</function> returns a set of records describing
   the SQL keywords recognized by the server. The <structfield>word</> column
   contains the keyword.  The <structfield>catcode</> column contains a
   category code: <literal>U</> for unreserved, <literal>C</> for column name,
   <literal>T</> for type or function name, or <literal>R</> for reserved.
   The <structfield>catdesc</> column contains a possibly-localized string
   describing the category.
-->
関数<function>pg_get_keywords</function>は、サーバが認識したSQLキーワードを記述するレコード一式を返します。
<structfield>word</>列にはキーワードが含まれます。
<structfield>catcode</>列は種類コードを含みます。それらは、予約されていないを表わす<literal>U</>、列名の<literal>C</>、関数名型の<literal>T</>、または予約語であることの<literal>R</>、のいずれかです。
<structfield>catdesc</>列は種類を記述する現地語化された可能性のある文字列を含みます。
  </para>

  <para>
<!--
   <function>pg_get_constraintdef</function>,
   <function>pg_get_indexdef</function>, <function>pg_get_ruledef</function>,
   and <function>pg_get_triggerdef</function>, respectively reconstruct the
   creating command for a constraint, index, rule, or trigger. (Note that this
   is a decompiled reconstruction, not the original text of the command.)
   <function>pg_get_expr</function> decompiles the internal form of an
   individual expression, such as the default value for a column.  It can be
   useful when examining the contents of system catalogs.  If the expression
   might contain Vars, specify the OID of the relation they refer to as the
   second parameter; if no Vars are expected, zero is sufficient.
   <function>pg_get_viewdef</function> reconstructs the <command>SELECT</>
   query that defines a view. Most of these functions come in two variants,
   one of which can optionally <quote>pretty-print</> the result.  The
   pretty-printed format is more readable, but the default format is more
   likely to be interpreted the same way by future versions of
   <productname>PostgreSQL</>; avoid using pretty-printed output for dump
   purposes.  Passing <literal>false</> for the pretty-print parameter yields
   the same result as the variant that does not have the parameter at all.
-->
<function>pg_get_constraintdef</function>、<function>pg_get_indexdef</function>、<function>pg_get_ruledef</function>、および <function>pg_get_triggerdef</function>それぞれは、対応する制約、インデックス、ルール、もしくはトリガに対するコマンド作成を再構築します。
（これはコマンドのオリジナルテキストではなく、逆コンパイルされた再構築であることに注意してください。）
<function>pg_get_expr</function>は、列のデフォルト値のような個々の式の内部形式を逆コンパイルします。
システムカタログの内容を試験するときに便利です。 
もしも式がVarを含んでいるとすれば、２番目のパラメータとして参照する関連（リレーション）のOIDを指定します。もしVarがないと期待されればゼロで充分です。
<function>pg_get_viewdef</function> はビューを定義する<command>SELECT</>問い合わせを再構築します。
これらの関数のほとんどは２つの異形があり、そのうちの１つはオプションとして結果を<quote>pretty-print</>（訳注：<quote>見やすく表示</>）します。
pretty-printされた書式はより読みやすい半面、デフォルトの書式の方が今後のバージョンの<productname>PostgreSQL</>でも同様に解釈することができそうです。ダンプを目的とする場合は、見やすく表示する出力を使用しないでください。
見やすい表示用のパラメータに<literal>false</>を渡すことで、このパラメータをまったく持たない種類の結果と同一の結果を生成します。
  </para>

  <para>
<!--
   <function>pg_get_functiondef</> returns a complete
   <command>CREATE OR REPLACE FUNCTION</> statement for a function.
   <function>pg_get_function_arguments</function> returns the argument list
   of a function, in the form it would need to appear in within
   <command>CREATE FUNCTION</>.
   <function>pg_get_function_result</function> similarly returns the
   appropriate <literal>RETURNS</> clause for the function.
   <function>pg_get_function_identity_arguments</function> returns the
   argument list necessary to identify a function, in the form it
   would need to appear in within <command>ALTER FUNCTION</>, for
   instance.  This form omits default values.
-->
<function>pg_get_functiondef</>は、ある関数の<command>CREATE OR REPLACE FUNCTION</>文全てを返します。
<function>pg_get_function_arguments</function>は、<command>CREATE FUNCTION</>の中に出現しなければならない形式で、引数リストを返します。
<function>pg_get_function_result</function>は同様、その関数の適切な<literal>RETURNS</>句を返します。
<function>pg_get_function_identity_arguments</function>は、インスタンスに対し、<command>ALTER FUNCTION</>の中に出現しなければならない形式で、ある関数を特定するのに必要な引数リストを返します。
この形式はデフォルト値を省略します。
  </para>

  <para>
<!--
   <function>pg_get_serial_sequence</function> returns the name of the
   sequence associated with a column, or NULL if no sequence is associated
   with the column.  The first input parameter is a table name with
   optional schema, and the second parameter is a column name.  Because
   the first parameter is potentially a schema and table, it is not treated
   as a double-quoted identifier, meaning it is lower cased by default,
   while the second parameter, being just a column name, is treated as
   double-quoted and has its case preserved.  The function returns a value
   suitably formatted for passing to sequence functions (see <xref
   linkend="functions-sequence">).  This association can be modified or
   removed with <command>ALTER SEQUENCE OWNED BY</>.  (The function
   probably should have been called
   <function>pg_get_owned_sequence</function>; its current name reflects the fact
   that it's typically used with <type>serial</> or <type>bigserial</>
   columns.)
-->
<function>pg_get_serial_sequence</function>は、列に関連したシーケンスの名前を返します。もし、列に関連したシーケンスが存在しなければ、NULLを返します。
最初の入力パラメータはテーブル名です。スキーマを付けることもできます。２番目のパラメータは列名です。
最初のパラメータは普通スキーマとテーブルですので、二重引用符付の識別子としては解釈されません。つまり、デフォルトで小文字に変換されます。一方２番目のパラメータは単なる列名であり、二重引用符付として解釈され、その大文字小文字は保持されます。
この関数は、シーケンス関数に渡すことができるよう適切な書式で値を返します（<xref linkend="functions-sequence">を参照）。
この関連付けは<command>ALTER SEQUENCE OWNED BY</>により変更、削除することができます。
（この関数はおそらく<function>pg_get_owned_sequence</function>から呼び出されるはずです。その現在の名前は、<type>serial</>や <type>bigserial</>列で実際に入力されたものが反映されます。）
  </para>

  <para>
<!--
   <function>pg_get_userbyid</function> extracts a role's name given
   its OID.
-->
<function>pg_get_userbyid</function>はそのOIDで与えられたロールの名前を抽出します。
  </para>

  <para>
<!--
   <function>pg_options_to_table</function> returns the set of storage
   option name/value pairs
   (<literal>option_name</>/<literal>option_value</>) when passed
   <structname>pg_class</>.<structfield>reloptions</> or
   <structname>pg_attribute</>.<structfield>attoptions</>.
-->
 <function>pg_options_to_table</function>は<structname>pg_class</>.<structfield>reloptions</>か<structname>pg_attribute</>.<structfield>attoptions</>へ格納オプションが設定されている場合にそのペア(<literal>option_name</>/<literal>option_value</>)を返します。
  </para>

  <para>
<!--
   <function>pg_tablespace_databases</function> allows a tablespace to be
   examined. It returns the set of OIDs of databases that have objects stored
   in the tablespace. If this function returns any rows, the tablespace is not
   empty and cannot be dropped. To display the specific objects populating the
   tablespace, you will need to connect to the databases identified by
   <function>pg_tablespace_databases</function> and query their
   <structname>pg_class</> catalogs.
-->
<function>pg_tablespace_databases</function>によりテーブル空間の使用状況を確認することができます。
これは、そのテーブル空間内に格納されたオブジェクトを持つデータベースのOIDの集合を返します。
この関数が何らかの行を返した場合、このテーブル空間は空ではなく、そのため、削除することができません。
テーブル空間内に格納された特定のオブジェクトを表示するためには、<function>pg_tablespace_databases</function>で識別されたデータベースに接続し、その<structname>pg_class</>カタログに問い合わせを行う必要があります。
  </para>

  <para>
<!--
   <function>pg_describe_object</function> returns a textual description of a database
   object specified by catalog OID, object OID and a (possibly zero) sub-object ID.
   This description is intended to be human-readable, and might be translated,
   depending on server configuration.
   This is useful to determine the identity of an object as stored in the
   <structname>pg_depend</structname> catalog.
-->
<function>pg_describe_object</function>はカタログOID、オブジェクトOID、もしくは(おそらく0の)サブオブジェクトOIDで指定されたデータベースオブジェクトのテキストによる説明を返します。
この説明はサーバの設定に依存しますが、人が読んでわかる、そして翻訳も可能になることを目的としたのもです。
これは<structname>pg_depend</structname>カタログに格納されたオブジェクトの識別判断の際に有用です。
  </para>

  <para>
<!--
   <function>pg_identify_object</function> returns a row containing enough information
   to uniquely identify the database object specified by catalog OID, object OID and a
   (possibly zero) sub-object ID.  This information is intended to be machine-readable,
   and is never translated.
   <parameter>type</> identifies the type of database object;
   <parameter>schema</> is the schema name that the object belongs in, or
   <literal>NULL</> for object types that do not belong to schemas;
   <parameter>name</> is the name of the object, quoted if necessary, only
   present if it can be used (alongside schema name, if pertinent) as a unique
   identifier of the object, otherwise <literal>NULL</>;
   <parameter>identity</> is the complete object identity, with the precise format
   depending on object type, and each part within the format being
   schema-qualified and quoted as necessary.
-->
<function>pg_identify_object</function>はたログOID, オブジェクトOID、そして（ゼロである可能性を有する）サブオブジェクトIDにより指定されるデータベースオブジェクトを一意的に特定するために充分な情報を所有する行を返します。
この情報は機械による解読目的で決して翻訳されません。
データベースオブジェクトの型を特定する<parameter>type</>識別子、
オブジェクトが所属するスキーマの名前である<parameter>schema</>、またはスキーマに所属しないオブジェクト型の<literal>NULL</>、
必要であれば引用符で括られたオブジェクトの名前の<parameter>name</>であって、そのオブジェクトに対する一意の識別子として（もし付属としてあるとした時、一緒にあるスキーマ名）使用されるもの。そうでなければ<literal>NULL</>。
<parameter>identity</>はオブジェクト型に依存する詳細なフォーマットを持つ完結したオブジェクトの識別。そしてフォーマットの中のそれぞれの部分はスキーマ権限を与えられていて、必要な場合は括弧で括られる。  
  </para>

  <para>
<!--
   <function>pg_typeof</function> returns the OID of the data type of the
   value that is passed to it.  This can be helpful for troubleshooting or
   dynamically constructing SQL queries.  The function is declared as
   returning <type>regtype</>, which is an OID alias type (see
   <xref linkend="datatype-oid">); this means that it is the same as an
   OID for comparison purposes but displays as a type name.  For example:
-->
<function>pg_typeof</function>は、OIDに渡される値のデータ型のOIDを返します。
これはトラブル解決作業、または動的にSQL問い合わせを生成するのに便利です。
この関数は、OID型の別名である<type>regtype</>を返すものとして宣言されます（<xref linkend="datatype-oid">を参照）。つまり、比較目的でのOIDと同一ですが、型名として表示されます。
以下に例をあげます。
<programlisting>
SELECT pg_typeof(33);

 pg_typeof 
-----------
 integer
(1 row)

SELECT typlen FROM pg_type WHERE oid = pg_typeof(33);
 typlen 
--------
      4
(1 row)
</programlisting>
  </para>

  <para>
<!--
   The expression <literal>collation for</literal> returns the collation of the
   value that is passed to it.  Example:
-->
<literal>collation for</literal>式は、それに渡された値の照合順序を返します。例を示します。
<programlisting>
SELECT collation for (description) FROM pg_description LIMIT 1;
 pg_collation_for 
------------------
 "default"
(1 row)

SELECT collation for ('foo' COLLATE "de_DE");
 pg_collation_for 
------------------
 "de_DE"
(1 row)
</programlisting>
<!--
  The value might be quoted and schema-qualified.  If no collation is derived
  for the argument expression, then a null value is returned.  If the argument
  is not of a collatable data type, then an error is raised.
-->
値はクォートで囲い、スキーマを明示的に指定します。
もし引数の式から何も照合順序が得られなかった場合、NULLが返されます。
もし引数が照合順序をサポートしないデータ型だった場合、エラーとなります。
  </para>

  <para>
<!--
   The <function>to_regclass</function>, <function>to_regproc</function>,
   <function>to_regprocedure</function>, <function>to_regoper</function>,
   <function>to_regoperator</function>, and <function>to_regtype</function>
   functions translate relation, function, operator, and type names to objects
   of type <type>regclass</>, <type>regproc</>, <type>regprocedure</type>,
   <type>regoper</>, <type>regoperator</type>, and <type>regtype</>,
   respectively.  These functions differ from a cast from
   text in that they don't accept a numeric OID, and that they return null
   rather than throwing an error if the name is not found (or, for
   <function>to_regproc</function> and <function>to_regoper</function>, if
   the given name matches multiple objects).
-->
<function>to_regclass</function>、<function>to_regproc</function>、<function>to_regprocedure</function>、<function>to_regoper</function>、<function>to_regoperator</function>、<function>to_regtype</function>関数はリレーション、関数、演算子、型の名前をそれぞれ<type>regclass</>、<type>regproc</>、<type>regprocedure</type>、<type>regoper</>、<type>regoperator</type>、<type>regtype</>型のオブジェクトに変換します。
数値OIDを受け付けず、名前が見つからない(もしくは、<function>to_regproc</function>と<function>to_regoper</function>では、与えられた名前が複数のオブジェクトに一致する)場合にはエラーを発生するのではなくnullを返すという点で、これらの関数はテキストからのキャストとは異なります。
  </para>

   <indexterm>
    <primary>col_description</primary>
   </indexterm>

   <indexterm>
    <primary>obj_description</primary>
   </indexterm>

   <indexterm>
    <primary>shobj_description</primary>
   </indexterm>

   <indexterm>
<!--
    <primary>comment</primary>
    <secondary sortas="database objects">about database objects</secondary>
-->
    <primary>コメント</primary>
    <secondary sortas="database objects">データベースオブジェクトについて</secondary>
   </indexterm>

   <para>
<!--
    The functions shown in <xref linkend="functions-info-comment-table">
    extract comments previously stored with the <xref linkend="sql-comment">
    command.  A null value is returned if no
    comment could be found for the specified parameters.
-->
<xref linkend="functions-info-comment-table">に示される関数は、<xref linkend="sql-comment">コマンドによって以前に保存されたコメントを抽出します。
指定されたパラメータに対するコメントが存在しない場合、NULL値が返されます。
   </para>

   <table id="functions-info-comment-table">
<!--
    <title>Comment Information Functions</title>
-->
    <title>コメント情報関数</title>
    <tgroup cols="3">
     <thead>
<!--
      <row><entry>Name</entry> <entry>Return Type</entry> <entry>Description</entry></row>
-->
      <row><entry>名前</entry> <entry>戻り型</entry> <entry>説明</entry></row>
     </thead>

     <tbody>
      <row>
       <entry><literal><function>col_description(<parameter>table_oid</parameter>, <parameter>column_number</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
<!--
       <entry>get comment for a table column</entry>
-->
       <entry>テーブル列のコメントを取得</entry>
      </row>
      <row>
       <entry><literal><function>obj_description(<parameter>object_oid</parameter>, <parameter>catalog_name</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
<!--
       <entry>get comment for a database object</entry>
-->
       <entry>データベースオブジェクトのコメントを取得</entry>
      </row>
      <row>
       <entry><literal><function>obj_description(<parameter>object_oid</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
<!--
       <entry>get comment for a database object (<emphasis>deprecated</emphasis>)</entry>
-->
       <entry>データベースオブジェクトのコメントを取得（<emphasis>廃止予定</emphasis>）</entry>
      </row>
      <row>
       <entry><literal><function>shobj_description(<parameter>object_oid</parameter>, <parameter>catalog_name</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
<!--
       <entry>get comment for a shared database object</entry>
-->
       <entry>共有データベースオブジェクトのコメントを取得</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
<!--
    <function>col_description</function> returns the comment for a table
    column, which is specified by the OID of its table and its column number.
    (<function>obj_description</function> cannot be used for table columns
    since columns do not have OIDs of their own.)
-->
<function>col_description()</function>関数は、テーブルのOIDとその列番号で指定されるテーブルの列のコメントを返します。
<function>obj_description()</function>関数は、テーブル列自体がOIDを所有していませんので、テーブル列に対して使用することはできません。
   </para>

   <para>
<!--
    The two-parameter form of <function>obj_description</function> returns the
    comment for a database object specified by its OID and the name of the
    containing system catalog.  For example,
    <literal>obj_description(123456,'pg_class')</literal>
    would retrieve the comment for the table with OID 123456.
    The one-parameter form of <function>obj_description</function> requires only
    the object OID.  It is deprecated since there is no guarantee that
    OIDs are unique across different system catalogs; therefore, the wrong
    comment might be returned.
-->
<function>obj_description()</function>関数の２つのパラメータを取る形式はそのOIDと保有しているシステムカタログの名前で指定されたデータベースオブジェクトのコメントを返します。
例えば、<literal>obj_description(123456,'pg_class')</literal>はOID 123456を持つテーブルのコメントを抽出します。
<function>obj_description()</function>関数の単一パラメータ形式はオブジェクトのOIDのみ必要とします。
異なったシステムカタログに渡ってOIDが一意である保証はないことから廃止予定です。従って、間違ったコメントが返ることがあります。
   </para>

   <para>
<!--
    <function>shobj_description</function> is used just like
    <function>obj_description</function> except it is used for retrieving
    comments on shared objects.  Some system catalogs are global to all
    databases within each cluster, and the descriptions for objects in them
    are stored globally as well.
-->
<function>shobj_description</function>は、共有オブジェクトのコメント取得のために使用されることを除いて、<function>obj_description</function>と同じように使用されます。
一部のシステムカタログは、各クラスタ内のデータベース全体に対して大域的です。これらのコメントも同様に大域的に格納されます。
   </para>

   <indexterm>
    <primary>txid_current</primary>
   </indexterm>

   <indexterm>
    <primary>txid_current_snapshot</primary>
   </indexterm>

   <indexterm>
    <primary>txid_snapshot_xip</primary>
   </indexterm>

   <indexterm>
    <primary>txid_snapshot_xmax</primary>
   </indexterm>

   <indexterm>
    <primary>txid_snapshot_xmin</primary>
   </indexterm>

   <indexterm>
    <primary>txid_visible_in_snapshot</primary>
   </indexterm>

   <para>
<!--
    The functions shown in <xref linkend="functions-txid-snapshot">
    provide server transaction information in an exportable form.  The main
    use of these functions is to determine which transactions were committed
    between two snapshots.
-->
<xref linkend="functions-txid-snapshot">で示される関数はサーバトランザクション情報をエクスポートできる形式で提供します。
これら関数の主な使用目的は２つのスナップショット間でどちらのトランザクションがコミットされたのかを特定するためです。
   </para>

   <table id="functions-txid-snapshot">
<!--
    <title>Transaction IDs and Snapshots</title>
-->
    <title>トランザクションIDとスナップショット</title>
    <tgroup cols="3">
     <thead>
<!--
      <row><entry>Name</entry> <entry>Return Type</entry> <entry>Description</entry></row>
-->
      <row><entry>名前</entry> <entry>戻り型</entry> <entry>説明</entry></row>
     </thead>

     <tbody>
      <row>
       <entry><literal><function>txid_current()</function></literal></entry>
       <entry><type>bigint</type></entry>
<!--
       <entry>get current transaction ID</entry>
-->
       <entry>現在のトランザクションIDの取得</entry>
      </row>
      <row>
       <entry><literal><function>txid_current_snapshot()</function></literal></entry>
       <entry><type>txid_snapshot</type></entry>
<!--
       <entry>get current snapshot</entry>
-->
       <entry>現在のスナップショットの取得</entry>
      </row>
      <row>
      
       <entry><literal><function>txid_snapshot_xip(<parameter>txid_snapshot</parameter>)</function></literal></entry>
       <entry><type>setof bigint</type></entry>
<!--
       <entry>get in-progress transaction IDs in snapshot</entry>
-->
       <entry>スナップショットにある進行中のトランザクションIDの取得</entry>
      </row>
      <row>
       <entry><literal><function>txid_snapshot_xmax(<parameter>txid_snapshot</parameter>)</function></literal></entry>
       <entry><type>bigint</type></entry>
<!--
       <entry>get <literal>xmax</literal> of snapshot</entry>
-->
       <entry>スナップショットの<literal>xmax</literal>の取得</entry>
      </row>
      <row>
       <entry><literal><function>txid_snapshot_xmin(<parameter>txid_snapshot</parameter>)</function></literal></entry>
       <entry><type>bigint</type></entry>
<!--
       <entry>get <literal>xmin</literal> of snapshot</entry>
-->
       <entry>スナップショットの<literal>xmin</literal>の取得</entry>
      </row>
      <row>
       <entry><literal><function>txid_visible_in_snapshot(<parameter>bigint</parameter>, <parameter>txid_snapshot</parameter>)</function></literal></entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>is transaction ID visible in snapshot? (do not use with subtransaction ids)</entry>
-->
       <entry>スナップショットにあるトランザクションIDは可視か？（サブトランザクションIDと一緒に使用しないこと）</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
<!--
    The internal transaction ID type (<type>xid</>) is 32 bits wide and
    wraps around every 4 billion transactions.  However, these functions
    export a 64-bit format that is extended with an <quote>epoch</> counter
    so it will not wrap around during the life of an installation.
    The data type used by these functions, <type>txid_snapshot</type>,
    stores information about transaction ID
    visibility at a particular moment in time.  Its components are
    described in <xref linkend="functions-txid-snapshot-parts">.
-->
内部トランザクションID型（<type>xid</>）は32ビット幅あるので40億トランザクション毎ラップします。
とは言っても、これらの関数は<quote>epoch</>カウンタにより64ビット形式にエクスポートするため、インストレーションの生涯にわたってラップしません。
これらの関数で使用されるデータ型、<type>txid_snapshot</type>はある時間特有時のトランザクションIDの可視化に関する情報を格納します。
構成要素は<xref linkend="functions-txid-snapshot-parts">に記載されています。
   </para>

   <table id="functions-txid-snapshot-parts">
<!--
    <title>Snapshot Components</title>
-->
    <title>スナップショット構成要素</title>
    <tgroup cols="2">
     <thead>
      <row>
<!--
       <entry>Name</entry>
       <entry>Description</entry>
-->
       <entry>名前</entry>
       <entry>説明</entry>
      </row>
     </thead>

     <tbody>

      <row>
       <entry><type>xmin</type></entry>
       <entry>
<!--
         Earliest transaction ID (txid) that is still active.  All earlier
         transactions will either be committed and visible, or rolled
         back and dead.
-->
         いまだ使用中の最先として出現したトランザクションID（txid）。全ての最も早期のトランザクションはコミットされ、可視化となるか、またはロールバックされ消滅するのいずれか。
       </entry>
      </row>

      <row>
       <entry><type>xmax</type></entry>
       <entry>
<!--
        First as-yet-unassigned txid.  All txids greater than or equal to this
        are not yet started as of the time of the snapshot, and thus invisible.
-->
        最初のまだ割り当てられていないtxid。これと等しいかより大きい全てのtxidはスナップショットの時点で未開始。従って不可視。
       </entry>
      </row>

      <row>
       <entry><type>xip_list</type></entry>
       <entry>
<!--
        Active txids at the time of the snapshot.  The list
        includes only those active txids between <literal>xmin</>
        and <literal>xmax</>; there might be active txids higher
        than <literal>xmax</>.  A txid that is <literal>xmin &lt;= txid &lt;
        xmax</literal> and not in this list was already completed
        at the time of the snapshot, and thus either visible or
        dead according to its commit status.  The list does not
        include txids of subtransactions.
-->
        スナップショット時の使用中のtxid。リストは<literal>xmin</>と<literal>xmax</>間にのみ使用中のtxidを含む。<literal>xmax</>より高位の使用中のtxidが存在することもある。
        <literal>xmin &lt;= txid &lt; xmax</literal>であり、このリストにないtxidはスナップショット時に既に完了している。従い、コミット状態で可視か消滅かのいづれか。リストには副トランザクションのtxidは含まれない。
       </entry>
      </row>

     </tbody>
    </tgroup>
   </table>

   <para>
<!--
    <type>txid_snapshot</>'s textual representation is
    <literal><replaceable>xmin</>:<replaceable>xmax</>:<replaceable>xip_list</></literal>.
    For example <literal>10:20:10,14,15</literal> means
    <literal>xmin=10, xmax=20, xip_list=10, 14, 15</literal>.
-->
    <type>txid_snapshot</>のテキスト表現は<literal><replaceable>xmin</>:<replaceable>xmax</>:<replaceable>xip_list</></literal>。例えば、<literal>10:20:10,14,15</literal>は<literal>xmin=10, xmax=20, xip_list=10, 14, 15</literal>を指す。
   </para>
  </sect1>

  <sect1 id="functions-admin">
<!--
   <title>System Administration Functions</title>
-->
   <title>システム管理関数</title>

   <para>
<!--
    The functions described in this section are used to control and
    monitor a <productname>PostgreSQL</> installation.
-->
本節で説明する関数は、<productname>PostgreSQL</>インストレーションの制御と監視を行うために使用されます。
   </para>

  <sect2 id="functions-admin-set">
<!--
   <title>Configuration Settings Functions</title>
-->
   <title>構成設定関数</title>

   <para>
<!--
    <xref linkend="functions-admin-set-table"> shows the functions
    available to query and alter run-time configuration parameters.
-->
<xref linkend="functions-admin-set-table">は、実行時構成パラメータの問い合わせや変更に使用できる関数を示しています。
   </para>

   <table id="functions-admin-set-table">
<!--
    <title>Configuration Settings Functions</title>
-->
    <title>構成設定関数</title>
    <tgroup cols="3">
     <thead>
<!--
      <row><entry>Name</entry> <entry>Return Type</entry> <entry>Description</entry></row>
-->
      <row><entry>名前</entry> <entry>戻り型</entry> <entry>説明</entry></row>
     </thead>

     <tbody>
      <row>
       <entry>
        <indexterm>
         <primary>current_setting</primary>
        </indexterm>
        <literal><function>current_setting(<parameter>setting_name</parameter>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
<!--
       <entry>get current value of setting</entry>
-->
       <entry>現在の設定値の取得</entry>
      </row>
      <row>
       <entry>
        <indexterm>
         <primary>set_config</primary>
        </indexterm>
        <literal><function>set_config(<parameter>setting_name</parameter>,
                             <parameter>new_value</parameter>,
                             <parameter>is_local</parameter>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
<!--
       <entry>set parameter and return new value</entry>
-->
       <entry>パラメータを設定し、新規値を返す</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <indexterm>
    <primary>SET</primary>
   </indexterm>

   <indexterm>
    <primary>SHOW</primary>
   </indexterm>

   <indexterm>
<!--
    <primary>configuration</primary>
-->
    <primary>設定</primary>
<!--
    <secondary sortas="server">of the server</secondary>
-->
    <secondary sortas="server">サーバの</secondary>
<!--
    <tertiary>functions</tertiary>
-->
    <tertiary>関数</tertiary>
   </indexterm>

   <para>
<!--
    The function <function>current_setting</function> yields the
    current value of the setting <parameter>setting_name</parameter>.
    It corresponds to the <acronym>SQL</acronym> command
    <command>SHOW</command>.  An example:
-->
関数<function>current_setting</function>は、設定<parameter>setting_name</parameter>の現在の値を返します。
この関数は、<acronym>SQL</acronym>の<command>SHOW</command>コマンドと同じです。
以下に例を示します。
<programlisting>
SELECT current_setting('datestyle');

 current_setting
-----------------
 ISO, MDY
(1 row)
</programlisting>
   </para>

   <para>
<!--
    <function>set_config</function> sets the parameter
    <parameter>setting_name</parameter> to
    <parameter>new_value</parameter>.  If
    <parameter>is_local</parameter> is <literal>true</literal>, the
    new value will only apply to the current transaction. If you want
    the new value to apply for the current session, use
    <literal>false</literal> instead. The function corresponds to the
    SQL command <command>SET</command>. An example:
-->
<function>set_config</function>関数は、パラメータ<parameter>setting_name</parameter>を<parameter>new_value</parameter>に設定します。
ただし、<parameter>is_local</parameter>が<literal>true</literal>の場合、新規値は現在のトランザクションにのみ適用されます。
新規値を現在のセッションに適用する場合は、代わりに<literal>false</literal>を使用してください。
この関数は、SQLの<command>SET</command>コマンドと同じです。
以下に例を示します。
<programlisting>
SELECT set_config('log_statement_stats', 'off', false);

 set_config
------------
 off
(1 row)
</programlisting>
   </para>

  </sect2>

  <sect2 id="functions-admin-signal">
<!--
   <title>Server Signaling Functions</title>
-->
   <title>サーバシグナル送信関数</title>

   <indexterm>
    <primary>pg_cancel_backend</primary>
   </indexterm>
   <indexterm>
    <primary>pg_reload_conf</primary>
   </indexterm>
   <indexterm>
    <primary>pg_rotate_logfile</primary>
   </indexterm>
   <indexterm>
    <primary>pg_terminate_backend</primary>
   </indexterm>

   <indexterm>
<!--
    <primary>signal</primary>
    <secondary sortas="backend">backend processes</secondary>
-->
    <primary>シグナル</primary>
    <secondary sortas="backend">バックエンドプロセス</secondary>
   </indexterm>

   <para>
<!--
    The functions shown in <xref
    linkend="functions-admin-signal-table"> send control signals to
    other server processes.  Use of these functions is usually restricted
    to superusers, with noted exceptions.
-->
<xref linkend="functions-admin-signal-table">に示す関数は、制御用シグナルを他のサーバプロセスに送信します。
これらの関数の使用は、著名な例外を除き、大抵の場合スーパーユーザのみに制限されています。
   </para>

   <table id="functions-admin-signal-table">
<!--
    <title>Server Signaling Functions</title>
-->
    <title>サーバシグナル送信関数</title>
    <tgroup cols="3">
     <thead>
<!--
      <row><entry>Name</entry> <entry>Return Type</entry> <entry>Description</entry>
-->
      <row><entry>名前</entry> <entry>戻り型</entry> <entry>説明</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry>
        <literal><function>pg_cancel_backend(<parameter>pid</parameter> <type>int</>)</function></literal>
        </entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>Cancel a backend's current query.  You can execute this against
        another backend that has exactly the same role as the user calling the
        function.  In all other cases, you must be a superuser.
        </entry>
-->
       <entry>バックエンドの現在の問い合わせを取り消す。もし関数を読ぶユーザが取り消す対象のバックエンドと正確に同じロールを保持している場合は、関数を実行することができます。その他全てのケースでは、スーパーユーザでなければいけません。</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_reload_conf()</function></literal>
        </entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>Cause server processes to reload their configuration files</entry>
-->
       <entry>サーバプロセスに構成ファイルの再読み込みをさせる</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_rotate_logfile()</function></literal>
        </entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>Rotate server's log file</entry>
-->
       <entry>サーバログファイルを循環させる</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_terminate_backend(<parameter>pid</parameter> <type>int</>)</function></literal>
        </entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>Terminate a backend.  You can execute this against
        another backend that has exactly the same role as the user
        calling the function.  In all other cases, you must be a
        superuser.
       </entry>
-->
       <entry>バックエンドを終結する。もし関数を読ぶユーザが取り消す対象のバックエンドと正確に同じロールを保持している場合は、関数を実行することができます。その他全てのケースでは、スーパーユーザでなければいけません。</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
<!--
    Each of these functions returns <literal>true</literal> if
    successful and <literal>false</literal> otherwise.
-->
これらのぞれぞれの関数は成功の場合<literal>true（真）</literal>を返し、そうでない場合は<literal>false（偽）</literal>を返します。
   </para>

   <para>
<!--
    <function>pg_cancel_backend</> and <function>pg_terminate_backend</>
    send signals (<systemitem>SIGINT</> or <systemitem>SIGTERM</>
    respectively) to backend processes identified by process ID.
    The process ID of an active backend can be found from
    the <structfield>pid</structfield> column of the
    <structname>pg_stat_activity</structname> view, or by listing the
    <command>postgres</command> processes on the server (using
    <application>ps</> on Unix or the <application>Task
    Manager</> on <productname>Windows</>).
    The role of an active backend can be found from the
    <structfield>usename</structfield> column of the
    <structname>pg_stat_activity</structname> view.
-->
<function>pg_cancel_backend</>と<function>pg_terminate_backend</>は（それぞれ、<systemitem>SIGINT</>または<systemitem>SIGTERM</>）シグナルをプロセス識別子で特定されたバックエンドプロセスに送ります。
使用中のバックエンドのプロセス識別子は<structname>pg_stat_activity</structname>ビューの<structfield>pid</structfield>列から、もしくは、（Unixでは<application>ps</>、<productname>Windows</>では<application>Task Manager</>により）サーバ上の<command>postgres</command>プロセスをリストすることで見つけられます。
実行中のバックエンドのロールは<structname>pg_stat_activity</structname>の<structfield>usename</structfield>列から確認することができます。
   </para>

   <para>
<!--
    <function>pg_reload_conf</> sends a <systemitem>SIGHUP</> signal
    to the server, causing configuration files
    to be reloaded by all server processes.
-->
<function>pg_reload_conf</>は<systemitem>SIGHUP</>シグナルをサーバに送り、その結果全てのサーバプロセスが構成ファイルを再読み込みすることになります。
   </para>

   <para>
<!--
    <function>pg_rotate_logfile</> signals the log-file manager to switch
    to a new output file immediately.  This works only when the built-in
    log collector is running, since otherwise there is no log-file manager
    subprocess.
-->
<function>pg_rotate_logfile</>はログファイルマネージャに即座に新規出力ファイルに切替えるよう信号を送ります。
これは組み込みログ取得が起動している場合のみ有効です。起動していない場合はログファイルマネージャの子プロセスが存在しない理由からです。
   </para>

  </sect2>

  <sect2 id="functions-admin-backup">
<!--
   <title>Backup Control Functions</title>
-->
   <title>バックアップ制御関数</title>

   <indexterm>
<!--
    <primary>backup</primary>
-->
    <primary>バックアップ</primary>
   </indexterm>
   <indexterm>
    <primary>pg_create_restore_point</primary>
   </indexterm>
   <indexterm>
    <primary>pg_current_xlog_insert_location</primary>
   </indexterm>
   <indexterm>
    <primary>pg_current_xlog_location</primary>
   </indexterm>
   <indexterm>
    <primary>pg_start_backup</primary>
   </indexterm>
   <indexterm>
    <primary>pg_stop_backup</primary>
   </indexterm>
   <indexterm>
    <primary>pg_is_in_backup</primary>
   </indexterm>
   <indexterm>
    <primary>pg_backup_start_time</primary>
   </indexterm>
   <indexterm>
    <primary>pg_switch_xlog</primary>
   </indexterm>
   <indexterm>
    <primary>pg_xlogfile_name</primary>
   </indexterm>
   <indexterm>
    <primary>pg_xlogfile_name_offset</primary>
   </indexterm>
   <indexterm>
    <primary>pg_xlog_location_diff</primary>
   </indexterm>

   <para>
<!--
    The functions shown in <xref
    linkend="functions-admin-backup-table"> assist in making on-line backups.
    These functions cannot be executed during recovery (except
    <function>pg_is_in_backup</function>, <function>pg_backup_start_time</function>
    and <function>pg_xlog_location_diff</function>).
-->
<xref linkend="functions-admin-backup-table">に示す関数はオンラインバックアップの作成を支援するものです。
これらの関数は、リカバリ中には実行できません(<function>pg_is_in_backup</function>、<function>pg_backup_start_time</function>、および<function>pg_xlog_location_diff</function>は除く)。
   </para>

   <table id="functions-admin-backup-table">
<!--
    <title>Backup Control Functions</title>
-->
    <title>バックアップ制御関数</title>
    <tgroup cols="3">
     <thead>
<!--
      <row><entry>Name</entry> <entry>Return Type</entry> <entry>Description</entry>
-->
      <row><entry>名前</entry> <entry>戻り型</entry> <entry>説明</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry>
        <literal><function>pg_create_restore_point(<parameter>name</> <type>text</>)</function></literal>
        </entry>
       <entry><type>pg_lsn</type></entry>
<!--
       <entry>Create a named point for performing restore (restricted to superusers)</entry>
-->
       <entry>リストア実行用に名前付けされたポイントを作成(スーパーユーザのみ実施可能です)</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_current_xlog_insert_location()</function></literal>
        </entry>
       <entry><type>pg_lsn</type></entry>
<!--
       <entry>Get current transaction log insert location</entry>
-->
       <entry>現在のトランザクションログの挿入位置の取得</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_current_xlog_location()</function></literal>
        </entry>
       <entry><type>pg_lsn</type></entry>
<!--
       <entry>Get current transaction log write location</entry>
-->
       <entry>現在のトランザクションログの書き込み位置を取得</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_start_backup(<parameter>label</> <type>text</> <optional>, <parameter>fast</> <type>boolean</> </optional>)</function></literal>
        </entry>
       <entry><type>pg_lsn</type></entry>
<!--
       <entry>Prepare for performing on-line backup (restricted to superusers or replication roles)</entry>
-->
       <entry>オンラインバックアップの実行準備(スーパーユーザかレプリケーション用のロールでのみ実施可能です)</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_stop_backup()</function></literal>
        </entry>
       <entry><type>pg_lsn</type></entry>
<!--
       <entry>Finish performing on-line backup (restricted to superusers or replication roles)</entry>
-->
       <entry>オンラインバックアップの実行の終了(スーパーユーザかレプリケーション用のロールでのみ実施可能です)</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_is_in_backup()</function></literal>
        </entry>
       <entry><type>bool</type></entry>
<!--
       <entry>True if an on-line exclusive backup is still in progress.</entry>
-->
       <entry>オンラインでの排他的バックアップが実行中は真。</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_backup_start_time()</function></literal>
        </entry>
       <entry><type>timestamp with time zone</type></entry>
<!--
       <entry>Get start time of an on-line exclusive backup in progress.</entry>
-->
       <entry>実行中のオンライン排他的バックアップの開始時刻を取得。</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_switch_xlog()</function></literal>
        </entry>
       <entry><type>pg_lsn</type></entry>
<!--
       <entry>Force switch to a new transaction log file (restricted to superusers)</entry>
-->
       <entry>新しいトランザクションログファイルへの強制移行(スーパユーザのみ実施可能です)</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_xlogfile_name(<parameter>location</> <type>pg_lsn</>)</function></literal>
        </entry>
       <entry><type>text</type></entry>
<!--
       <entry>Convert transaction log location string to file name</entry>
-->
       <entry>トランザクションログの位置を表す文字列をファイル名に変換</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_xlogfile_name_offset(<parameter>location</> <type>pg_lsn</>)</function></literal>
        </entry>
       <entry><type>text</>, <type>integer</></entry>
<!--
       <entry>Convert transaction log location string to file name and decimal byte offset within file</entry>
-->
       <entry>トランザクションログの位置を表す文字列を、ファイル名とファイル内の10進のバイトオフセットに変換</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_xlog_location_diff(<parameter>location</> <type>pg_lsn</>, <parameter>location</> <type>pg_lsn</>)</function></literal>
       </entry>
       <entry><type>numeric</></entry>
<!--
       <entry>Calculate the difference between two transaction log locations</entry>
-->
       <entry>2つのトランザクションログの位置差分を算出</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
<!--
    <function>pg_start_backup</> accepts an
    arbitrary user-defined label for the backup.  (Typically this would be
    the name under which the backup dump file will be stored.)  The function
    writes a backup label file (<filename>backup_label</>) into the
    database cluster's data directory, performs a checkpoint,
    and then returns the backup's starting transaction log location as text.
    The user can ignore this result value, but it is
    provided in case it is useful.
-->
<function>pg_start_backup</>は、ユーザが任意に定義したバックアップラベルを受け付けます。
（通常、格納に使用するバックアップダンプファイルにちなんだ名前が付けられます。）
この関数は、データベースクラスタのデータディレクトリにバックアップラベルファイル（<filename>backup_label</>）を書き出し、チェックポイントを実行し、バックアップを始めるトランザクションログの位置をテキスト形式で返します。
ユーザはこの結果値を無視することができますが、便利なこともあるので提供されています。
<programlisting>
postgres=# select pg_start_backup('label_goes_here');
 pg_start_backup
-----------------
 0/D4445B8
(1 row)
</programlisting>
<!--
    There is an optional second parameter of type <type>boolean</type>.  If <literal>true</>,
    it specifies executing <function>pg_start_backup</> as quickly as
    possible.  This forces an immediate checkpoint which will cause a
    spike in I/O operations, slowing any concurrently executing queries.
-->
オプションの<type>boolean</type>型パラメータがあります。
<literal>真</>であれば、すべからく早く<function>pg_start_backup</>の実行を指定します。
いかなる現時点で実行中の問い合わせも速度を落とし、I/O操作で急増の原因の即時チェックポイントを強要します。
   </para>

   <para>
<!--
    <function>pg_stop_backup</> removes the label file created by
    <function>pg_start_backup</>, and creates a backup history file in
    the transaction log archive area.  The history file includes the label given to
    <function>pg_start_backup</>, the starting and ending transaction log locations for
    the backup, and the starting and ending times of the backup.  The return
    value is the backup's ending transaction log location (which again
    can be ignored).  After recording the ending location, the current
    transaction log insertion
    point is automatically advanced to the next transaction log file, so that the
    ending transaction log file can be archived immediately to complete the backup.
-->
<function>pg_stop_backup</>は、<function>pg_start_backup</>で作成されたラベルファイルを削除し、トランザクションログ格納領域にバックアップ履歴ファイルを作成します。
履歴ファイルには<function>pg_start_backup</>で付与されたラベル、バックアップのトランザクションログの位置の開始位置、終了位置、バックアップ開始時刻、終了時刻が含まれます。
戻り値は、バックアップの終了トランザクションログの位置です（これも同様に無視可能です）。
終了位置を記録した後、現在のトランザクションログの挿入位置は自動的に、次のトランザクションログに進みます。ですので、終了トランザクションログファイルをすぐにアーカイブし、バックアップを完了させることができます。
   </para>

   <para>
<!--
    <function>pg_switch_xlog</> moves to the next transaction log file, allowing the
    current file to be archived (assuming you are using continuous archiving).
    The return value is the ending transaction log location + 1 within the just-completed transaction log file.
    If there has been no transaction log activity since the last transaction log switch,
    <function>pg_switch_xlog</> does nothing and returns the start location
    of the transaction log file currently in use.
-->
<function>pg_switch_xlog</>は、次のトランザクションログファイルに移動し、現在のファイルをアーカイブできるようにします（アーカイブを続けて使用することを前提とします）。
戻り値は、完了した現在のトランザクションログファイル内の終了トランザクションログの位置に1を加えたものです。
前回のトランザクションログファイルの切り替えからトランザクションログに変化がなければ、<function>pg_switch_xlog</>は現在使用中のトランザクションログファイルの開始位置を返します。
   </para>

   <para>
<!--
    <function>pg_create_restore_point</> creates a named transaction log
    record that can be used as recovery target, and returns the corresponding
    transaction log location.  The given name can then be used with
    <xref linkend="recovery-target-name"> to specify the point up to which
    recovery will proceed.  Avoid creating multiple restore points with the
    same name, since recovery will stop at the first one whose name matches
    the recovery target.
-->
<function>pg_create_restore_point</>はリカバリターゲットとして使用可能な名前付けされたトランザクションログレコードを生成し、それに該当するログ位置を返します。
与えられた名前は、どこまでリカバリをするかを明示的に指定する<xref linkend="recovery-target-name">パラメータに使用することができます。
リカバリ処理はリカバリターゲットに指定した名前と一致した最初の時点で終了するため、同じ名前で複数のリストアポイントを作成することは避けてください。
   </para>

   <para>
<!--
    <function>pg_current_xlog_location</> displays the current transaction log write
    location in the same format used by the above functions.  Similarly,
    <function>pg_current_xlog_insert_location</> displays the current transaction log
    insertion point.  The insertion point is the <quote>logical</> end
    of the transaction log
    at any instant, while the write location is the end of what has actually
    been written out from the server's internal buffers.  The write location
    is the end of what can be examined from outside the server, and is usually
    what you want if you are interested in archiving partially-complete transaction log
    files.  The insertion point is made available primarily for server
    debugging purposes.  These are both read-only operations and do not
    require superuser permissions.
-->
<function>pg_current_xlog_location</>は、上記の関数で使用される同一の書式で現在のトランザクションログの書き込み位置を表示します。
同様に<function>pg_current_xlog_insert_location</>は、現在のトランザクションログの挿入位置を表示します。
挿入位置は <quote>論理的</>な任意の時点のトランザクションログの終了位置です。一方、書き込み位置は、サーバの内部バッファから書き出された実際の終了位置です。
書き込み位置はサーバ外部から検証可能なものの終端です。通常は、部分的に完了したトランザクションログファイルのアーカイブ処理を行いたい場合に必要とされるものです。
挿入位置はサーバをデバッグする際に主に使用されます。
これらはどちらも読み取りのみの操作であり、スーパーユーザ権限を必要としません。
   </para>

   <para>
<!--
    You can use <function>pg_xlogfile_name_offset</> to extract the
    corresponding transaction log file name and byte offset from the results of any of the
    above functions.  For example:
-->
<function>pg_xlogfile_name_offset</>を使用して、上記いずれの関数の結果からも、対応するトランザクションログファイルとバイトオフセットを取り出すことができます。
以下に例を示します。
<programlisting>
postgres=# SELECT * FROM pg_xlogfile_name_offset(pg_stop_backup());
        file_name         | file_offset 
--------------------------+-------------
 00000001000000000000000D |     4039624
(1 row)
</programlisting>
<!--
    Similarly, <function>pg_xlogfile_name</> extracts just the transaction log file name.
    When the given transaction log location is exactly at a transaction log file boundary, both
    these functions return the name of the preceding transaction log file.
    This is usually the desired behavior for managing transaction log archiving
    behavior, since the preceding file is the last one that currently
    needs to be archived.
-->
同様に、<function>pg_xlogfile_name</>は、トランザクションログファイル名のみを取り出します。
指定したトランザクションログの位置が正確にトランザクションログファイルの境界であった場合、これらの両関数は前のトランザクションログファイルの名前を返します。
通常これは、トランザクションログファイルのアーカイブ動作では好まれる動作です。前のファイルが現在のアーカイブで必要とする最後のファイルであるからです。
   </para>

   <para>
<!--
    <function>pg_xlog_location_diff</> calculates the difference in bytes
    between two transaction log locations. It can be used with
    <structname>pg_stat_replication</structname> or some functions shown in
    <xref linkend="functions-admin-backup-table"> to get the replication lag.
-->
<function>pg_xlog_location_diff</>は、2つのトランザクションログの位置の差分をバイト数で算出します。
この関数は<structname>pg_stat_replication</structname>や<xref linkend="functions-admin-backup-table">に示される関数と併用することで、レプリケーションの遅延の確認に使用できます。
   </para>

   <para>
<!--
    For details about proper usage of these functions, see
    <xref linkend="continuous-archiving">.
-->
これらの関数の正しい使用方法については、<xref linkend="continuous-archiving">を参照してください。
   </para>

  </sect2>

  <sect2 id="functions-recovery-control">
<!--
   <title>Recovery Control Functions</title>
-->
   <title>リカバリ制御関数</title>

   <indexterm>
    <primary>pg_is_in_recovery</primary>
   </indexterm>
   <indexterm>
    <primary>pg_last_xlog_receive_location</primary>
   </indexterm>
   <indexterm>
    <primary>pg_last_xlog_replay_location</primary>
   </indexterm>
   <indexterm>
    <primary>pg_last_xact_replay_timestamp</primary>
   </indexterm>

   <para>
<!--
    The functions shown in <xref
    linkend="functions-recovery-info-table"> provide information
    about the current status of the standby.
    These functions may be executed both during recovery and in normal running.
-->
<xref linkend="functions-recovery-info-table">に示される関数は、スタンバイサーバの現在のステータス情報を提供します。
これらの関数はリカバリ中、および通常稼動時に実行することができるでしょう。
   </para>

   <table id="functions-recovery-info-table">
<!--
    <title>Recovery Information Functions</title>
-->
    <title>リカバリ情報関数</title>
    <tgroup cols="3">
     <thead>
<!--
      <row><entry>Name</entry> <entry>Return Type</entry> <entry>Description</entry>
-->
      <row><entry>名前</entry> <entry>戻り型</entry> <entry>説明</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry>
        <literal><function>pg_is_in_recovery()</function></literal>
        </entry>
       <entry><type>bool</type></entry>
<!--
       <entry>True if recovery is still in progress.
-->
       <entry>まだリカバリ実施中であれば真を返します。
       </entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_last_xlog_receive_location()</function></literal>
        </entry>
       <entry><type>pg_lsn</type></entry>
<!--
       <entry>Get last transaction log location received and synced to disk by
        streaming replication. While streaming replication is in progress
        this will increase monotonically. If recovery has completed this will
        remain static at
        the value of the last WAL record received and synced to disk during
        recovery. If streaming replication is disabled, or if it has not yet
        started, the function returns NULL.
-->
       <entry>ストリーミングレプリケーションにより受信されディスクに書き込みされた、トランザクションログの最後の位置を取得します。ストリーミングレプリケーションが実施されている場合は、この値が単調に増加していくでしょう。リカバリが完了した場合、受信されディスクに書き込まれた最後のWALレコードの位置の値がそのまま残ります。ストリーミングレプリケーションが無効、もしくは開始されていない場合、この関数はNULLを返します。
       </entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_last_xlog_replay_location()</function></literal>
        </entry>
       <entry><type>pg_lsn</type></entry>
<!--
       <entry>Get last transaction log location replayed during recovery.
        If recovery is still in progress this will increase monotonically.
        If recovery has completed then this value will remain static at
        the value of the last WAL record applied during that recovery.
        When the server has been started normally without recovery
        the function returns NULL.
-->
       <entry>リカバリ中に再生された最後のトランザクションログの位置を取得します。リカバリが実施されている場合は、この値が単調に増加していくでしょう。リカバリが完了した場合は、リカバリ時に適用された最後のWALレコードの値がそのまま残ります。もしサーバがリカバリ無しで普通に起動された場合、この関数はNULLを返します。
       </entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_last_xact_replay_timestamp()</function></literal>
        </entry>
       <entry><type>timestamp with time zone</type></entry>
<!--
       <entry>Get time stamp of last transaction replayed during recovery.
        This is the time at which the commit or abort WAL record for that
        transaction was generated on the primary.
        If no transactions have been replayed during recovery, this function
        returns NULL.  Otherwise, if recovery is still in progress this will
        increase monotonically.  If recovery has completed then this value will
        remain static at the value of the last transaction applied during that
        recovery.  When the server has been started normally without recovery
        the function returns NULL.
-->
        <entry>
        リカバリ中に再生された最後のトランザクションのタイムスタンプを取得します。このタイムスタンプは、プライマリにて該当するトランザクションがコミット、もしくはアボートされた際のトランザクションログが生成された時間です。もしリカバリ中に何のトランザクションも再生されていない場合、この関数はNULLを返します。もしリカバリが完了した場合、この関数はリカバリ中に再生した最後のトランザクションの時間を静的に示し続けます。サーバがリカバリ処理無しに開始された場合、この関数はNULLを返します。
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <indexterm>
    <primary>pg_is_xlog_replay_paused</primary>
   </indexterm>
   <indexterm>
    <primary>pg_xlog_replay_pause</primary>
   </indexterm>
   <indexterm>
    <primary>pg_xlog_replay_resume</primary>
   </indexterm>

   <para>
<!--
    The functions shown in <xref
    linkend="functions-recovery-control-table"> control the progress of recovery.
    These functions may be executed only during recovery.
-->
<xref linkend="functions-recovery-control-table">に示す関数は、リカバリの進行を制御する関数です。
これらの関数はリカバリ中のみ実施することが可能です。
   </para>

   <table id="functions-recovery-control-table">
<!--
    <title>Recovery Control Functions</title>
-->
    <title>リカバリ制御関数</title>
    <tgroup cols="3">
     <thead>
<!--
      <row><entry>Name</entry> <entry>Return Type</entry> <entry>Description</entry>
-->
      <row><entry>名前</entry> <entry>戻り型</entry> <entry>説明</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry>
        <literal><function>pg_is_xlog_replay_paused()</function></literal>
        </entry>
       <entry><type>bool</type></entry>
<!--
       <entry>True if recovery is paused.
       </entry>
-->
       <entry>リカバリが停止中であれば真を返す
       </entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_xlog_replay_pause()</function></literal>
        </entry>
       <entry><type>void</type></entry>
<!--
       <entry>Pauses recovery immediately (restricted to superusers).
-->
       <entry>即座にリカバリを停止する(スーパーユーザに限定)
       </entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_xlog_replay_resume()</function></literal>
        </entry>
       <entry><type>void</type></entry>
<!--
       <entry>Restarts recovery if it was paused (restricted to superusers).
-->
       <entry>もしリカバリ停止中であれば再開する(スーパーユーザに限定)
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
<!--
    While recovery is paused no further database changes are applied.
    If in hot standby, all new queries will see the same consistent snapshot
    of the database, and no further query conflicts will be generated until
    recovery is resumed.
-->
リカバリ停止中は、それ以降のデータベースへの変更は適用されません。
ホットスタンバイ側であれば、停止以降に発行されたSQLは、同じ一貫性を持ったデータベースのスナップショットを参照することができます。
そしてリカバリが再開されるまで、以降のSQLとプライマリへのSQLの衝突は発生しません。
   </para>

   <para>
<!--
    If streaming replication is disabled, the paused state may continue
    indefinitely without problem. While streaming replication is in
    progress WAL records will continue to be received, which will
    eventually fill available disk space, depending upon the duration of
    the pause, the rate of WAL generation and available disk space.
-->
もしストリーミングレプリケーションが無効の場合、停止状態はいつまでも問題なく継続するでしょう。
一方、ストリーミングレプリケーションによりWALレコードの受信が継続されていた場合、停止時間、WALの生成速度、ディスクの残存容量によりますが、ディスク溢れが発生する可能性があります。
   </para>

  </sect2>

  <sect2 id="functions-snapshot-synchronization">
<!--
   <title>Snapshot Synchronization Functions</title>
-->
   <title>スナップショット同期関数</title>

   <indexterm>
     <primary>pg_export_snapshot</primary>
   </indexterm>

   <para>
<!--
    <productname>PostgreSQL</> allows database sessions to synchronize their
    snapshots. A <firstterm>snapshot</> determines which data is visible to the
    transaction that is using the snapshot. Synchronized snapshots are
    necessary when two or more sessions need to see identical content in the
    database. If two sessions just start their transactions independently,
    there is always a possibility that some third transaction commits
    between the executions of the two <command>START TRANSACTION</> commands,
    so that one session sees the effects of that transaction and the other
    does not.
-->
<productname>PostgreSQL</>はデータベースのセッションに対して、それらのスナップショットを同期させることが可能です。<firstterm>snapshot</>は、そのスナップショットを使用しているトランザクションがどのデータを可視とできるかを決定します。
同期スナップショットは、2つかそれ以上のセッションにおいて、全く同じデータベース内容を見たい場合に必要となります。もし、2つのセッションが独立したそれぞれのトランザクションを開始しただけであれば、ある第3のトランザクションのコミットが、
2つのトランザクションの<command>START TRANSACTION</>の狭間で実行される可能性があり、そのため一方のトランザクションではそのコミット結果が見え、他方では見えないという影響を受けてしまうでしょう。
   </para>

   <para>
<!--
    To solve this problem, <productname>PostgreSQL</> allows a transaction to
    <firstterm>export</> the snapshot it is using.  As long as the exporting
    transaction remains open, other transactions can <firstterm>import</> its
    snapshot, and thereby be guaranteed that they see exactly the same view
    of the database that the first transaction sees.  But note that any
    database changes made by any one of these transactions remain invisible
    to the other transactions, as is usual for changes made by uncommitted
    transactions.  So the transactions are synchronized with respect to
    pre-existing data, but act normally for changes they make themselves.
-->
このような問題を解決するため、<productname>PostgreSQL</>ではトランザクションが使用しているスナップショットを<firstterm>エクスポート</>できるようになっています。エクスポートしたトランザクションが開かれ続けている限り、他のトランザクションがそれを<firstterm>インポート</>することができ、
そしてこれにより最初のトランザクションと正確に同じとなるデータベースの可視性を保証されます。ただし、これらの(スナップショットを共有している)トランザクションによって発生したデータベースへの変更は、コミットされていないトランザクションによる変更と同様に、(スナップショットを共有している)他のトランザクションには見えないままです。
そのため、既存データに対しては同期されますが、それら自身による変更については通常の振る舞いをします。
   </para>

   <para>
<!--
    Snapshots are exported with the <function>pg_export_snapshot</> function,
    shown in <xref linkend="functions-snapshot-synchronization-table">, and
    imported with the <xref linkend="sql-set-transaction"> command.
-->
スナップショットは、<xref linkend="functions-snapshot-synchronization-table">に示す<function>pg_export_snapshot</>関数を用いてエクスポートされ、<xref linkend="sql-set-transaction">コマンドを用いてインポートされます。
   </para>

   <table id="functions-snapshot-synchronization-table">
<!--
    <title>Snapshot Synchronization Functions</title>
-->
    <title>スナップショット同期関数</title>
    <tgroup cols="3">
     <thead>
<!--
      <row><entry>Name</entry> <entry>Return Type</entry> <entry>Description</entry>
-->
      <row><entry>名前</entry> <entry>戻り値型</entry> <entry>説明</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry>
        <literal><function>pg_export_snapshot()</function></literal>
       </entry>
       <entry><type>text</type></entry>
<!--
       <entry>Save the current snapshot and return its identifier</entry>
-->
       <entry>現在のスナップショットを保存し、その識別子を返す</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
<!--
    The function <function>pg_export_snapshot</> saves the current snapshot
    and returns a <type>text</> string identifying the snapshot.  This string
    must be passed (outside the database) to clients that want to import the
    snapshot.  The snapshot is available for import only until the end of the
    transaction that exported it.  A transaction can export more than one
    snapshot, if needed.  Note that doing so is only useful in <literal>READ
    COMMITTED</> transactions, since in <literal>REPEATABLE READ</> and
    higher isolation levels, transactions use the same snapshot throughout
    their lifetime.  Once a transaction has exported any snapshots, it cannot
    be prepared with <xref linkend="sql-prepare-transaction">.
-->
<function>pg_export_snapshot</>関数は現在のスナップショットを保存し、そのスナップショットを識別する<type>text</>文字列を返します。
この文字列はスナップショットをインポートしたい(データベース外の)クライアントに渡されなければなりません。
エクスポートしたトランザクションが終わるまでの間のみ、そのスナップショットをインポートすることができます。必要ならばトランザクションを複数回エキスポートすることができます。
<literal>REPEATABLE READ</>や上位の隔離レベルでは、トランザクションはその有効期間の間同じスナップショットを使用しますので、これは<literal>READ COMMITTED</>トランザクションでのみ有用であることに注意してください。
一旦スナップショットをエクスポートしたトランザクションでは、<xref linkend="sql-prepare-transaction">によるPREPARE TRANSACTIONを使用するこができなくなります。
   </para>

   <para>
<!--
    See  <xref linkend="sql-set-transaction"> for details of how to use an
    exported snapshot.
-->
エクスポートしたトランザクションの使用方法の詳細については<xref linkend="sql-set-transaction">を参照してください。
   </para>
  </sect2>

  <sect2 id="functions-replication">
<!--
   <title>Replication Functions</title>
-->
   <title>レプリケーション関数</title>

   <para>
<!--
    The functions shown in <xref linkend="functions-replication-table"> are
    for controlling and interacting with replication features.
    See <xref linkend="streaming-replication">
    and <xref linkend="streaming-replication-slots"> for information about the
    underlying features.  Use of these functions is restricted to superusers.
-->
<xref linkend="functions-replication-table">に示す関数はレプリケーション機能を制御したり、相互作用したりするためのものです。
基盤となっている機能の情報に関しては<xref linkend="streaming-replication">と<xref linkend="streaming-replication-slots">を参照してください。
これらの関数の使用はスーパユーザに限定されています。
   </para>

   <para>
<!--
    Many of these functions have equivalent commands in the replication
    protocol; see <xref linkend="protocol-replication">.
-->
ここの関数の多くには、レプリケーションプロトコルに等価なコマンドがあります。<xref linkend="protocol-replication">を参照してください。
   </para>

   <para>
<!--
    The functions described in <xref linkend="functions-snapshot-synchronization">, <xref
    linkend="functions-recovery-control">, and <xref
    linkend="functions-admin-backup"> are also relevant for replication.
-->
<xref linkend="functions-snapshot-synchronization">、<xref linkend="functions-recovery-control">、<xref linkend="functions-admin-backup">に書かれている関数もレプリケーションに関係するものです。
   </para>

   <table id="functions-replication-table">
<!--
    <title>Replication <acronym>SQL</acronym> Functions</title>
-->
    <title>レプリケーション<acronym>SQL</acronym>関数</title>
    <tgroup cols="3">
     <thead>
      <row>
<!--
       <entry>Function</entry>
       <entry>Return Type</entry>
       <entry>Description</entry>
-->
       <entry>関数</entry>
       <entry>戻り値型</entry>
       <entry>説明</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>
        <indexterm>
         <primary>pg_create_physical_replication_slot</primary>
        </indexterm>
        <literal><function>pg_create_physical_replication_slot(<parameter>slot_name</parameter> <type>name</type>)</function></literal>
       </entry>
       <entry>
        (<parameter>slot_name</parameter> <type>name</type>, <parameter>xlog_position</parameter> <type>pg_lsn</type>)
       </entry>
       <entry>
<!--
        Creates a new physical replication slot named
        <parameter>slot_name</parameter>. Streaming changes from a physical slot
        is only possible with the streaming-replication protocol - see <xref
        linkend="protocol-replication">. Corresponds to the replication protocol
        command <literal>CREATE_REPLICATION_SLOT ... PHYSICAL</literal>.
-->
<parameter>slot_name</parameter>という名前の新しい物理レプリケーションスロットを作成します。
物理スロットからのストリーミングの変更はストリーミングレプリケーションプロトコルでのみ可能です。<xref linkend="protocol-replication">を参照してください。
レプリケーションプロトコルコマンド<literal>CREATE_REPLICATION_SLOT ... PHYSICAL</literal>に対応します。
       </entry>
      </row>
      <row>
       <entry>
        <indexterm>
         <primary>pg_drop_replication_slot</primary>
        </indexterm>
        <literal><function>pg_drop_replication_slot(<parameter>slot_name</parameter> <type>name</type>)</function></literal>
       </entry>
       <entry>
        <type>void</type>
       </entry>
       <entry>
<!--
        Drops the physical or logical replication slot
        named <parameter>slot_name</parameter>. Same as replication protocol
        command <literal>DROP_REPLICATION_SLOT</>.
-->
<parameter>slot_name</parameter>という名前の物理もしくは論理レプリケーションスロットを削除します。
レプリケーションプロトコルコマンド<literal>DROP_REPLICATION_SLOT</>と同じです。
       </entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>pg_create_logical_replication_slot</primary>
        </indexterm>
        <literal><function>pg_create_logical_replication_slot(<parameter>slot_name</parameter> <type>name</type>, <parameter>plugin</parameter> <type>name</type>)</function></literal>
       </entry>
       <entry>
        (<parameter>slot_name</parameter> <type>name</type>, <parameter>xlog_position</parameter> <type>pg_lsn</type>)
       </entry>
       <entry>
<!--
        Creates a new logical (decoding) replication slot named
        <parameter>slot_name</parameter> using the output plugin
        <parameter>plugin</parameter>.  A call to this function has the same
        effect as the replication protocol command
        <literal>CREATE_REPLICATION_SLOT ... LOGICAL</literal>.
-->
<parameter>slot_name</parameter>という名前の新しい論理(デコード)レプリケーションスロットを作成します。
この関数を呼び出すのはレプリケーションプロトコルコマンド<literal>CREATE_REPLICATION_SLOT ... LOGICAL</literal>と同じ効果があります。
       </entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>pg_logical_slot_get_changes</primary>
        </indexterm>
        <literal><function>pg_logical_slot_get_changes(<parameter>slot_name</parameter> <type>name</type>, <parameter>upto_lsn</parameter> <type>pg_lsn</type>, <parameter>upto_nchanges</parameter> <type>int</type>, VARIADIC <parameter>options</parameter> <type>text[]</type>)</function></literal>
       </entry>
       <entry>
        (<parameter>location</parameter> <type>pg_lsn</type>, <parameter>xid</parameter> <type>xid</type>, <parameter>data</parameter> <type>text</type>)
       </entry>
       <entry>
<!--
        Returns changes in the slot <parameter>slot_name</parameter>, starting
        from the point at which since changes have been consumed last.  If
        <parameter>upto_lsn</> and <parameter>upto_nchanges</> are NULL,
        logical decoding will continue until end of WAL.  If
        <parameter>upto_lsn</> is non-NULL, decoding will include only
        those transactions which commit prior to the specified LSN.  If
        <parameter>upto_nchanges</parameter> is non-NULL, decoding will
        stop when the number of rows produced by decoding exceeds
        the specified value.  Note, however, that the actual number of
        rows returned may be larger, since this limit is only checked after
        adding the rows produced when decoding each new transaction commit.
-->
変更が最後に消費された時点から開始して、スロット<parameter>slot_name</parameter>の変更を返します。
<parameter>upto_lsn</>と<parameter>upto_nchanges</>がNULLならば論理デコードはWALの最後まで続きます。
<parameter>upto_lsn</>が非NULLであれば、デコードは指定されたLSNより前にコミットされたトランザクションのみを含みます。
<parameter>upto_nchanges</parameter>が非NULLであれば、デコードにより生成された行の数が指定された値を越えたときに、デコードは止まります。
しかしながら、新しいトランザクションの各コミットをデコードして生成された行を追加した後でしかこの制限は確認されませんので、実際に返される行の数は大きいかもしれないことに注意してください。
       </entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>pg_logical_slot_peek_changes</primary>
        </indexterm>
        <literal><function>pg_logical_slot_peek_changes(<parameter>slot_name</parameter> <type>name</type>, <parameter>upto_lsn</parameter> <type>pg_lsn</type>, <parameter>upto_nchanges</parameter> <type>int</type>, VARIADIC <parameter>options</parameter> <type>text[]</type>)</function></literal>
       </entry>
       <entry>
        (<parameter>location</parameter> <type>text</type>, <parameter>xid</parameter> <type>xid</type>, <parameter>data</parameter> <type>text</type>)
       </entry>
       <entry>
<!--
        Behaves just like
        the <function>pg_logical_slot_get_changes()</function> function,
        except that changes are not consumed; that is, they will be returned
        again on future calls.
-->
        変更が消費されないということを除いて、<function>pg_logical_slot_get_changes()</function>関数と同じように振る舞います。すなわち、将来の呼び出しでは再び同じものが返ります。
       </entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>pg_logical_slot_get_binary_changes</primary>
        </indexterm>
        <literal><function>pg_logical_slot_get_binary_changes(<parameter>slot_name</parameter> <type>name</type>, <parameter>upto_lsn</parameter> <type>pg_lsn</type>, <parameter>upto_nchanges</parameter> <type>int</type>, VARIADIC <parameter>options</parameter> <type>text[]</type>)</function></literal>
       </entry>
       <entry>
        (<parameter>location</parameter> <type>pg_lsn</type>, <parameter>xid</parameter> <type>xid</type>, <parameter>data</parameter> <type>bytea</type>)
       </entry>
       <entry>
<!--
        Behaves just like
        the <function>pg_logical_slot_get_changes()</function> function,
        except that changes are returned as <type>bytea</type>.
-->
        変更は<type>bytea</type>として返されるということを除いて<function>pg_logical_slot_get_changes()</function>関数と同じように振る舞います。
       </entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>pg_logical_slot_peek_binary_changes</primary>
        </indexterm>
        <literal><function>pg_logical_slot_peek_binary_changes(<parameter>slot_name</parameter> <type>name</type>, <parameter>upto_lsn</parameter> <type>pg_lsn</type>, <parameter>upto_nchanges</parameter> <type>int</type>, VARIADIC <parameter>options</parameter> <type>text[]</type>)</function></literal>
       </entry>
       <entry>
        (<parameter>location</parameter> <type>pg_lsn</type>, <parameter>xid</parameter> <type>xid</type>, <parameter>data</parameter> <type>bytea</type>)
       </entry>
       <entry>
<!--
        Behaves just like
        the <function>pg_logical_slot_get_changes()</function> function,
        except that changes are returned as <type>bytea</type> and that
        changes are not consumed; that is, they will be returned again
        on future calls.
-->
        変更は<type>bytea</type>として返され消費されないということを除いて<function>pg_logical_slot_get_changes()</function>関数と同じように振る舞います。すなわち、将来の呼び出しでは再び同じものが返ります。
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  </sect2>

  <sect2 id="functions-admin-dbobject">
<!--
   <title>Database Object Management Functions</title>
-->
   <title>データベースオブジェクト管理関数</title>

   <para>
<!--
    The functions shown in <xref linkend="functions-admin-dbsize"> calculate
    the disk space usage of database objects.
-->
<xref linkend="functions-admin-dbsize">で示された関数はデータベースオブジェクトのディスク領域を計算します。
   </para>

   <indexterm>
    <primary>pg_column_size</primary>
   </indexterm>
   <indexterm>
    <primary>pg_database_size</primary>
   </indexterm>
   <indexterm>
    <primary>pg_indexes_size</primary>
   </indexterm>
   <indexterm>
    <primary>pg_relation_size</primary>
   </indexterm>
   <indexterm>
    <primary>pg_size_pretty</primary>
   </indexterm>
   <indexterm>
    <primary>pg_table_size</primary>
   </indexterm>
   <indexterm>
    <primary>pg_tablespace_size</primary>
   </indexterm>
   <indexterm>
    <primary>pg_total_relation_size</primary>
   </indexterm>

   <table id="functions-admin-dbsize">
<!--
    <title>Database Object Size Functions</title>
-->
    <title>データベースオブジェクト容量関数</title>
    <tgroup cols="3">
     <thead>
<!--
      <row><entry>Name</entry> <entry>Return Type</entry> <entry>Description</entry>
-->
      <row><entry>名前</entry> <entry>戻り型</entry> <entry>説明</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry><literal><function>pg_column_size(<type>any</type>)</function></literal></entry>
       <entry><type>int</type></entry>
<!--
       <entry>Number of bytes used to store a particular value (possibly compressed)</entry>
-->
       <entry>特定の値を格納するのに使用される（場合により圧縮された）バイト数</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_database_size(<type>oid</type>)</function></literal>
        </entry>
       <entry><type>bigint</type></entry>
<!--
       <entry>Disk space used by the database with the specified OID</entry>
-->
       <entry>指定されたOIDのデータベースで使用されるディスク容量</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_database_size(<type>name</type>)</function></literal>
        </entry>
       <entry><type>bigint</type></entry>
<!--
       <entry>Disk space used by the database with the specified name</entry>
-->
       <entry>指定された名前のデータベースで使用されるディスク容量</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_indexes_size(<type>regclass</type>)</function></literal>
        </entry>
       <entry><type>bigint</type></entry>
       <entry>
<!--
        Total disk space used by indexes attached to the specified table
-->
       指定されテーブルに付与されたインデックスで使用される総ディスク容量。
       </entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_relation_size(<parameter>relation</parameter> <type>regclass</type>, <parameter>fork</parameter> <type>text</type>)</function></literal>
        </entry>
       <entry><type>bigint</type></entry>
       <entry>
<!--
        Disk space used by the specified fork (<literal>'main'</literal>,
        <literal>'fsm'</literal>, <literal>'vm'</>, or <literal>'init'</>)
        of the specified table or index
-->
       指定されたテーブルまたはインデックスの指定されたフォーク（<literal>'main'</literal>、<literal>'fsm'</literal>、<literal>'vm'</>または<literal>'init'</>）で使用されるディスク容量
       </entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_relation_size(<parameter>relation</parameter> <type>regclass</type>)</function></literal>
        </entry>
       <entry><type>bigint</type></entry>
       <entry>
<!--
        Shorthand for <literal>pg_relation_size(..., 'main')</literal>
-->
        <literal>pg_relation_size(..., 'main')</literal>の省略表現
       </entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_size_pretty(<type>bigint</type>)</function></literal>
        </entry>
       <entry><type>text</type></entry>
       <entry>
<!--
         Converts a size in bytes expressed as a 64-bit integer into a
         human-readable format with size units
-->
         64ビット整数で表現されたバイト単位のサイズを可読性が高いサイズ単位の書式に変換
       </entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_size_pretty(<type>numeric</type>)</function></literal>
        </entry>
       <entry><type>text</type></entry>
       <entry>
<!--
         Converts a size in bytes expressed as a numeric value into a
         human-readable format with size units
-->
         numeric値で表現されたバイト単位のサイズを可読性が高いサイズ単位の書式に変換
       </entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_table_size(<type>regclass</type>)</function></literal>
        </entry>
       <entry><type>bigint</type></entry>
       <entry>
<!--
        Disk space used by the specified table, excluding indexes
        (but including TOAST, free space map, and visibility map)
-->
       指定されたテーブルで使用される容量の内、すべてのインデックスを除外した(しかしTOAST、空き領域マップ、可視性マップを含む)ディスク総容量。
       </entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_tablespace_size(<type>oid</type>)</function></literal>
        </entry>
       <entry><type>bigint</type></entry>
<!--
       <entry>Disk space used by the tablespace with the specified OID</entry>
-->
       <entry>指定されたOIDを持つテーブル空間で使用されるディスク容量</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_tablespace_size(<type>name</type>)</function></literal>
        </entry>
       <entry><type>bigint</type></entry>
<!--
       <entry>Disk space used by the tablespace with the specified name</entry>
-->
       <entry>指定された名前を持つテーブル空間で使用されるディスク容量</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_total_relation_size(<type>regclass</type>)</function></literal>
        </entry>
       <entry><type>bigint</type></entry>
       <entry>
<!--
        Total disk space used by the specified table,
        including all indexes and <acronym>TOAST</> data
-->
       指定されたテーブルで使用される、すべてのインデックスと<acronym>TOAST</>データを含むディスク総容量
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
<!--
    <function>pg_column_size</> shows the space used to store any individual
    data value.
-->
    <function>pg_column_size</>はどんな個別のデータ値を格納するのにも使用される領域を示します。
   </para>

   <para>
<!--
    <function>pg_total_relation_size</> accepts the OID or name of a
    table or toast table, and returns the total on-disk space used for
    that table, including all associated indexes.  This function is
    equivalent to <function>pg_table_size</function>
    <literal>+</> <function>pg_indexes_size</function>.
-->
<function>pg_total_relation_size</>は、テーブルまたはTOASTテーブルのOIDまたは名前を受け付け、指定されたテーブルと関連する全てのインデックスで使用される総ディスク容量を返します。
この関数は<function>pg_table_size</function> <literal>+</> <function>pg_indexes_size</function> の結果と等しいです。
   </para>

   <para>
<!--
    <function>pg_table_size</> accepts the OID or name of a table and
    returns the disk space needed for that table, exclusive of indexes.
    (TOAST space, free space map, and visibility map are included.)
-->
<function>pg_table_size</>は、テーブルのOIDまたは名前を受け付け、インデックスを除いたテーブルのみで使用されるディスク容量を返します。
(TOAST領域、空き領域マップ、可視性マップを含みます。)
   </para>

   <para>
<!--
    <function>pg_indexes_size</> accepts the OID or name of a table and
    returns the total disk space used by all the indexes attached to that
    table.
-->
<function>pg_indexes_size</>は、テーブルのOIDまたは名前を受け付け、指定されたテーブル付与されている全てのインデックスで使用されるディスク容量を返します。
   </para>

   <para>
<!--
    <function>pg_database_size</function> and <function>pg_tablespace_size</>
    accept the OID or name of a database or tablespace, and return the total
    disk space used therein.  To use <function>pg_database_size</function>,
    you must have <literal>CONNECT</> permission on the specified database
    (which is granted by default).  To use <function>pg_tablespace_size</>,
    you must have <literal>CREATE</> permission on the specified tablespace,
    unless it is the default tablespace for the current database.
-->
<function>pg_database_size</>と<function>pg_tablespace_size</>はデータベースまたはテーブル空間の名前またはOIDを受付け、そこで使用される総容量を返します。
<function>pg_database_size</function>を使うためには、(デフォルトで付与されている)指定されたデータベースに<literal>CONNECT</>権限を持っていなければなりません。
<function>pg_tablespace_size</>を使うためには、それが現在のデータベースのデフォルトテーブル空間でない限り、指定されたテーブル空間に<literal>CREATE</>権限を持っていなければなりません。
   </para>

   <para>
<!--
    <function>pg_relation_size</> accepts the OID or name of a table, index
    or toast table, and returns the on-disk size in bytes of one fork of
    that relation.  (Note that for most purposes it is more convenient to
    use the higher-level functions <function>pg_total_relation_size</>
    or <function>pg_table_size</>, which sum the sizes of all forks.)
    With one argument, it returns the size of the main data fork of the
    relation.  The second argument can be provided to specify which fork
    to examine:
-->
<function>pg_relation_size</>は、テーブル、インデックス、またはTOASTテーブルのOIDまたは名前を受け付け、そのリレーションの1つのフォークのディスク容量をバイト単位で返します。
(たいていの目的には、高位の関数<function>pg_total_relation_size</>や<function>pg_table_size</>を使うのがより便利であることに注意してください。高位の関数はフォークすべての容量を合計します。)
引数1つでは、そのリレーションの主データフォークの容量を返します。
2番目の引数はどのフォークを調査するかを指定するために設定できます。
    <itemizedlist spacing="compact">
     <listitem>
      <para>
<!--
       <literal>'main'</literal> returns the size of the main
       data fork of the relation.
-->
<literal>'main'</literal>を指定すると、そのリレーションの主データフォークの容量を返します。
      </para>
     </listitem>
     <listitem>
      <para>
<!--
       <literal>'fsm'</literal> returns the size of the Free Space Map
       (see <xref linkend="storage-fsm">) associated with the relation.
-->
<literal>'fsm'</literal>を指定すると、リレーションに関連した空き領域マップ(<xref linkend="storage-fsm">を参照)を返します。
      </para>
     </listitem>
     <listitem>
      <para>
<!--
       <literal>'vm'</literal> returns the size of the Visibility Map
       (see <xref linkend="storage-vm">) associated with the relation.
-->
<literal>'vm'</literal>を指定すると、リレーションに関連した可視性マップ(<xref linkend="storage-vm">を参照)の容量を返します。
      </para>
     </listitem>
     <listitem>
      <para>
<!--
       <literal>'init'</literal> returns the size of the initialization
       fork, if any, associated with the relation.
-->
<literal>'init'</literal>を指定すると、もしあれば、リレーションに関連した初期化フォークを返します。
      </para>
     </listitem>
    </itemizedlist>
   </para>

   <para>
<!--
    <function>pg_size_pretty</> can be used to format the result of one of
    the other functions in a human-readable way, using kB, MB, GB or TB as
    appropriate.
-->
<function>pg_size_pretty</>は、適切にkB、MB、GB、もしくはTB単位を使用して目で見て判るようにその他の関数の1つの結果を整形するのに使用可能です。
   </para>

   <para>
<!--
    The functions above that operate on tables or indexes accept a
    <type>regclass</> argument, which is simply the OID of the table or index
    in the <structname>pg_class</> system catalog.  You do not have to look up
    the OID by hand, however, since the <type>regclass</> data type's input
    converter will do the work for you.  Just write the table name enclosed in
    single quotes so that it looks like a literal constant.  For compatibility
    with the handling of ordinary <acronym>SQL</acronym> names, the string
    will be converted to lower case unless it contains double quotes around
    the table name.
-->
上記の関数において、テーブルやインデックスを<type>regclass</>引数として受け取って処理するものがありますが、この引数は単に<structname>pg_class</>システムカタログにあるテーブルやインデックスのOIDです。
ただし、<type>regclass</>データ型が自動で入力変換を行うため、ユーザが手動で該当するOIDを調べる必要はありません。リテラル定数のようにシングルクォートで囲んだテーブル名を記述するだけです。
通常のSQL名に対する処理互換のため、テーブル名をダブルクォートで囲わない限り、テーブル名として入力された文字列は小文字に変換されます。
   </para>

   <para>
<!--
    If an OID that does not represent an existing object is passed as
    argument to one of the above functions, NULL is returned.
-->
上記の関数に対し、既存オブジェクトに該当するOIDがないものが渡された場合はNULLが返されます。
   </para>

   <para>
<!--
    The functions shown in <xref linkend="functions-admin-dblocation"> assist
    in identifying the specific disk files associated with database objects.
-->
<xref linkend="functions-admin-dblocation"> に示される関数は、データベースオブジェクトに関連する特定のディスクファイルを確認する際の手助けとなります。
   </para>

   <indexterm>
    <primary>pg_relation_filenode</primary>
   </indexterm>
   <indexterm>
    <primary>pg_relation_filepath</primary>
   </indexterm>
   <indexterm>
    <primary>pg_filenode_relation</primary>
   </indexterm>

   <table id="functions-admin-dblocation">
<!--
    <title>Database Object Location Functions</title>
-->
    <title>データベースオブジェクト位置関数</title>
    <tgroup cols="3">
     <thead>
<!--
      <row><entry>Name</entry> <entry>Return Type</entry> <entry>Description</entry>
-->
      <row><entry>名前</entry> <entry>戻り型</entry> <entry>説明</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry>
        <literal><function>pg_relation_filenode(<parameter>relation</parameter> <type>regclass</type>)</function></literal>
        </entry>
       <entry><type>oid</type></entry>
       <entry>
<!--
        Filenode number of the specified relation
-->
        指定されたリレーションのファイルノード番号
       </entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_relation_filepath(<parameter>relation</parameter> <type>regclass</type>)</function></literal>
        </entry>
       <entry><type>text</type></entry>
       <entry>
<!--
        File path name of the specified relation
-->
        指定されたリレーションのファイルパス
       </entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_filenode_relation(<parameter>tablespace</parameter> <type>oid</type>, <parameter>filenode</parameter> <type>oid</type>)</function></literal>
        </entry>
       <entry><type>regclass</type></entry>
       <entry>
<!--
        Find the relation associated with a given tablespace and filenode
-->
        与えられたテーブル空間とファイルノードに関連するリレーションを見つける
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
<!--
    <function>pg_relation_filenode</> accepts the OID or name of a table,
    index, sequence, or toast table, and returns the <quote>filenode</> number
    currently assigned to it.  The filenode is the base component of the file
    name(s) used for the relation (see <xref linkend="storage-file-layout">
    for more information).  For most tables the result is the same as
    <structname>pg_class</>.<structfield>relfilenode</>, but for certain
    system catalogs <structfield>relfilenode</> is zero and this function must
    be used to get the correct value.  The function returns NULL if passed
    a relation that does not have storage, such as a view.
-->
<function>pg_relation_filenode</>は、テーブル、インデックス、シーケンス、もしくはTOASTテーブルのOIDまたは名前を受け付け、現在それに充てられている<quote>ファイルノード</>を返します。
ファイルノードは、リレーションに使用しているファイル名の基礎部分です(詳しくは<xref linkend="storage-file-layout">を参照して下さい)。
ほとんどのテーブルについては、結果が<structname>pg_class</>.<structfield>relfilenode</>と同じになります。ただし、いくつかのシステムカタログでは<structfield>relfilenode</>が0になるため、これらのシステムカタログの正しいファイルノードを取得するには、この関数を使用しなければいけません。
この関数は、ビューの様にストレージに格納されないリレーションが指定された場合はNULLを返します。
   </para>

   <para>
<!--
    <function>pg_relation_filepath</> is similar to
    <function>pg_relation_filenode</>, but it returns the entire file path name
    (relative to the database cluster's data directory <varname>PGDATA</>) of
    the relation.
-->
<function>pg_relation_filepath</>は<function>pg_relation_filenode</>と似ていますが、こちらはリレーションのファイルパス名(データベースクラスタのディレクトリである<varname>PGDATA</>からの相対パス)を返します。
   </para>

   <para>
<!--
    <function>pg_filenode_relation</> is the reverse of
    <function>pg_relation_filenode</>. Given a <quote>tablespace</> OID and
    a <quote>filenode</>, it returns the associated relation's OID. For a table
    in the database's default tablespace, the tablespace can be specified as 0.
-->
<function>pg_filenode_relation</>は<function>pg_relation_filenode</>の逆です。
<quote>テーブル空間</>OIDと<quote>ファイルノード</>を与えると、関連するリレーションのOIDを返します。
データベースのデフォルトテーブル空間内のテーブルに対しては、テーブル空間は0と指定できます。
   </para>

  </sect2>

  <sect2 id="functions-admin-genfile">
<!--
   <title>Generic File Access Functions</title>
-->
   <title>汎用ファイルアクセス関数</title>

   <para>
<!--
    The functions shown in <xref
    linkend="functions-admin-genfile-table"> provide native access to
    files on the machine hosting the server. Only files within the
    database cluster directory and the <varname>log_directory</> can be
    accessed.  Use a relative path for files in the cluster directory,
    and a path matching the <varname>log_directory</> configuration setting
    for log files.  Use of these functions is restricted to superusers.
-->
<xref linkend="functions-admin-genfile-table">で示されている関数はサーバをホスティングしているマシン上のファイルに対し、生来のアクセスを提供します。
データベースクラスタディレクトリと<varname>log_directory</>に存在するファイルのみがアクセス可能です。
クラスタディレクトリ内のファイルに対して相対パスを、そしてログファイルに対しては<varname>log_directory</>構成設定に一致するパスを使用してください。
   </para>

   <table id="functions-admin-genfile-table">
<!--
    <title>Generic File Access Functions</title>
-->
    <title>汎用ファイルアクセス関数</title>
    <tgroup cols="3">
     <thead>
<!--
      <row><entry>Name</entry> <entry>Return Type</entry> <entry>Description</entry>
-->
      <row><entry>名前</entry> <entry>戻り型</entry> <entry>説明</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry>
        <literal><function>pg_ls_dir(<parameter>dirname</> <type>text</>)</function></literal>
       </entry>
       <entry><type>setof text</type></entry>
<!--
       <entry>List the contents of a directory</entry>
-->
       <entry>ディレクトリ内容のリスト</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_read_file(<parameter>filename</> <type>text</> [, <parameter>offset</> <type>bigint</>, <parameter>length</> <type>bigint</>])</function></literal>
       </entry>
       <entry><type>text</type></entry>
<!--
       <entry>Return the contents of a text file</entry>
-->
       <entry>テキストファイルの内容を返す</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_read_binary_file(<parameter>filename</> <type>text</> [, <parameter>offset</> <type>bigint</>, <parameter>length</> <type>bigint</>])</function></literal>
       </entry>
       <entry><type>bytea</type></entry>
<!--
       <entry>Return the contents of a file</entry>
-->
       <entry>ファイルの内容を返す</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_stat_file(<parameter>filename</> <type>text</>)</function></literal>
       </entry>
       <entry><type>record</type></entry>
<!--
       <entry>Return information about a file</entry>
-->
       <entry>ファイル情報を返す</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <indexterm>
    <primary>pg_ls_dir</primary>
   </indexterm>
   <para>
<!--
    <function>pg_ls_dir</> returns all the names in the specified
    directory, except the special entries <quote><literal>.</></> and
    <quote><literal>..</></>.
-->
<function>pg_ls_dir</>は、特別なエントリである<quote><literal>.</></>、および<quote><literal>..</></>を除いた、指定されたディレクトリの全ての名前を返します。
   </para>

   <indexterm>
    <primary>pg_read_file</primary>
   </indexterm>
   <para>
<!--
    <function>pg_read_file</> returns part of a text file, starting
    at the given <parameter>offset</>, returning at most <parameter>length</>
    bytes (less if the end of file is reached first).  If <parameter>offset</>
    is negative, it is relative to the end of the file.
    If <parameter>offset</> and <parameter>length</> are omitted, the entire
    file is returned.  The bytes read from the file are interpreted as a string
    in the server encoding; an error is thrown if they are not valid in that
    encoding.
-->
<function>pg_read_file</>は与えられた<parameter>offset</>から始まり、最大<parameter>length</>バイト（最初にファイルの終りに到達すればこれより少なくなりますが）テキストファイルの一部分を返します。<parameter>offset</>が負の場合にはファイルの終りから数えた位置から読み出します。
もし<parameter>offset</>と<parameter>length</>が省略された場合、ファイル全体が返されます。ファイルからのバイトの読み込みは、そのサーバ符号化方式に対する文字列と同様の解釈をされます。そのため、読み込んだバイト列がその符号化方式において有効でない場合にはエラーが投げられます。
   </para>

   <indexterm>
    <primary>pg_read_binary_file</primary>
   </indexterm>
   <para>
<!--
    <function>pg_read_binary_file</> is similar to
    <function>pg_read_file</>, except that the result is a <type>bytea</type> value;
    accordingly, no encoding checks are performed.
    In combination with the <function>convert_from</> function, this function
    can be used to read a file in a specified encoding:
-->
<function>pg_read_binary_file</>は、結果が<type>bytea</type>値となり、従って符号化の検査がされないことを除き、<function>pg_read_file</>と似ています。
<function>convert_from</>関数と組み合わせることで、この指定した符号化方式でファイルの読み込みを行うことができます。
    
<programlisting>
SELECT convert_from(pg_read_binary_file('file_in_utf8.txt'), 'UTF8');
</programlisting>
   </para>

   <indexterm>
    <primary>pg_stat_file</primary>
   </indexterm>
   <para>
<!--
    <function>pg_stat_file</> returns a record containing the file
    size, last accessed time stamp, last modified time stamp,
    last file status change time stamp (Unix platforms only),
    file creation time stamp (Windows only), and a <type>boolean</type>
    indicating if it is a directory.  Typical usages include:
-->
<function>pg_stat_file</>はファイル容量、最終アクセス時刻、最終更新時刻、最後にファイルステータスを変更した時刻（これはUnixプラットフォームのみ）、ファイル作成時刻（Windowsのみ）およびもしディレクトリであればそれを示す<type>boolean</type>を返します。
典型的な使用法を示します。
<programlisting>
SELECT * FROM pg_stat_file('filename');
SELECT (pg_stat_file('filename')).modification;
</programlisting>
   </para>

  </sect2>

  <sect2 id="functions-advisory-locks">
<!--
   <title>Advisory Lock Functions</title>
-->
   <title>勧告的ロック用関数</title>

   <para>
<!--
    The functions shown in <xref linkend="functions-advisory-locks-table">
    manage advisory locks.  For details about proper use of these functions,
    see <xref linkend="advisory-locks">.
-->
<xref linkend="functions-advisory-locks-table">に示す関数は勧告的ロックを管理します。
これらの関数の適切な使用方法についての詳細は、<xref linkend="advisory-locks">を参照してください。
   </para>

   <table id="functions-advisory-locks-table">
<!--
    <title>Advisory Lock Functions</title>
-->
    <title>勧告的ロック用関数</title>
    <tgroup cols="3">
     <thead>
<!--
      <row><entry>Name</entry> <entry>Return Type</entry> <entry>Description</entry>
-->
      <row><entry>名前</entry> <entry>戻り型</entry> <entry>説明</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry>
        <literal><function>pg_advisory_lock(<parameter>key</> <type>bigint</>)</function></literal>
       </entry>
       <entry><type>void</type></entry>
<!--
       <entry>Obtain exclusive session level advisory lock</entry>
-->
       <entry>セッションレベルの排他勧告的ロックを獲得</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_advisory_lock(<parameter>key1</> <type>int</>, <parameter>key2</> <type>int</>)</function></literal>
       </entry>
       <entry><type>void</type></entry>
<!--
       <entry>Obtain exclusive session level advisory lock</entry>
-->
       <entry>セッションレベルの排他勧告的ロックを獲得</entry>
      </row>

      <row>
       <entry>
        <literal><function>pg_advisory_lock_shared(<parameter>key</> <type>bigint</>)</function></literal>
       </entry>
       <entry><type>void</type></entry>
<!--
       <entry>Obtain shared session level advisory lock</entry>
-->
       <entry>セッションレベルの共有勧告的ロックを獲得</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_advisory_lock_shared(<parameter>key1</> <type>int</>, <parameter>key2</> <type>int</>)</function></literal>
       </entry>
       <entry><type>void</type></entry>
<!--
       <entry>Obtain shared session level advisory lock</entry>
-->
       <entry>セッションレベルの共有勧告的ロックを獲得</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_advisory_unlock(<parameter>key</> <type>bigint</>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>Release an exclusive session level advisory lock</entry>
-->
       <entry>セッションレベルの排他勧告的ロックを解放</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_advisory_unlock(<parameter>key1</> <type>int</>, <parameter>key2</> <type>int</>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>Release an exclusive session level advisory lock</entry>
-->
       <entry>セッションレベルの排他勧告的ロックを解放</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_advisory_unlock_all()</function></literal>
       </entry>
       <entry><type>void</type></entry>
<!--
       <entry>Release all session level advisory locks held by the current session</entry>
-->
       <entry>現在のセッションで保持している全てのセッションレベルの勧告的ロックを解放</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_advisory_unlock_shared(<parameter>key</> <type>bigint</>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>Release a shared session level advisory lock</entry>
-->
       <entry>セッションレベルの共有勧告的ロックを解放</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_advisory_unlock_shared(<parameter>key1</> <type>int</>, <parameter>key2</> <type>int</>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>Release a shared session level advisory lock</entry>
-->
       <entry>セッションレベルの共有勧告的ロックの解放</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_advisory_xact_lock(<parameter>key</> <type>bigint</>)</function></literal>
       </entry>
       <entry><type>void</type></entry>
<!--
       <entry>Obtain exclusive transaction level advisory lock</entry>
-->
       <entry>トランザクションレベルの排他勧告的ロックの獲得</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_advisory_xact_lock(<parameter>key1</> <type>int</>, <parameter>key2</> <type>int</>)</function></literal>
       </entry>
       <entry><type>void</type></entry>
<!--
       <entry>Obtain exclusive transaction level advisory lock</entry>
-->
       <entry>トランザクションレベルの排他勧告的ロックの獲得</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_advisory_xact_lock_shared(<parameter>key</> <type>bigint</>)</function></literal>
       </entry>
       <entry><type>void</type></entry>
<!--
       <entry>Obtain shared transaction level advisory lock</entry>
-->
       <entry>トランザクションレベルの共有勧告的ロックの獲得</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_advisory_xact_lock_shared(<parameter>key1</> <type>int</>, <parameter>key2</> <type>int</>)</function></literal>
       </entry>
       <entry><type>void</type></entry>
<!--
       <entry>Obtain shared transaction level advisory lock</entry>
-->
       <entry>トランザクションレベルの共有勧告的ロックの獲得</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_try_advisory_lock(<parameter>key</> <type>bigint</>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>Obtain exclusive session level advisory lock if available</entry>
-->
       <entry>可能ならばセッションレベルの排他勧告的ロックを獲得</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_try_advisory_lock(<parameter>key1</> <type>int</>, <parameter>key2</> <type>int</>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>Obtain exclusive session level advisory lock if available</entry>
-->
       <entry>可能ならばセッションレベルの排他勧告的ロックを獲得</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_try_advisory_lock_shared(<parameter>key</> <type>bigint</>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>Obtain shared session level advisory lock if available</entry>
-->
       <entry>可能ならばセッションレベルの共有勧告的ロックを獲得</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_try_advisory_lock_shared(<parameter>key1</> <type>int</>, <parameter>key2</> <type>int</>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>Obtain shared session level advisory lock if available</entry>
-->
       <entry>可能ならばセッションレベルの共有勧告的ロックを獲得</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_try_advisory_xact_lock(<parameter>key</> <type>bigint</>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>Obtain exclusive transaction level advisory lock if available</entry>
-->
       <entry>可能ならばトランザクションレベルの排他勧告的ロックの獲得</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_try_advisory_xact_lock(<parameter>key1</> <type>int</>, <parameter>key2</> <type>int</>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>Obtain exclusive transaction level advisory lock if available</entry>
-->
       <entry>可能ならばトランザクションレベルの排他勧告的ロックの獲得</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_try_advisory_xact_lock_shared(<parameter>key</> <type>bigint</>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>Obtain shared transaction level advisory lock if available</entry>
-->
       <entry>可能ならばトランザクションレベルの共有勧告的ロックの獲得</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_try_advisory_xact_lock_shared(<parameter>key1</> <type>int</>, <parameter>key2</> <type>int</>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>Obtain shared transaction level advisory lock if available</entry>
-->
       <entry>可能ならばトランザクションレベルの共有勧告的ロックの獲得</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <indexterm>
    <primary>pg_advisory_lock</primary>
   </indexterm>
   <para>
<!--
    <function>pg_advisory_lock</> locks an application-defined resource,
    which can be identified either by a single 64-bit key value or two
    32-bit key values (note that these two key spaces do not overlap).
    If another session already holds a lock on the same resource identifier,
    this function will wait until the resource becomes available.  The lock
    is exclusive.  Multiple lock requests stack, so that if the same resource
    is locked three times it must then be unlocked three times to be
    released for other sessions' use.
-->
<function>pg_advisory_lock</>は、アプリケーションが定義したリソースをロックします。キーは単一の64ビットキー値、または、２つの32ビットキー（この2つのキー空間は重複しないことに注意）によって識別されます。
もし、別のセッションが同一リソースに対するロックを保持している場合、関数はリソースが利用可能になるまで待機します。ロックは排他ロックです。
複数のロック要求が待ち状態になります。ですので、同一リソースが３回ロックされた場合、他のセッションが使用できるように解放するためにはロック解除を３回行わなければなりません。
   </para>

   <indexterm>
    <primary>pg_advisory_lock_shared</primary>
   </indexterm>
   <para>
<!--
    <function>pg_advisory_lock_shared</> works the same as
    <function>pg_advisory_lock</>,
    except the lock can be shared with other sessions requesting shared locks.
    Only would-be exclusive lockers are locked out.
-->
<function>pg_advisory_lock_shared</>の動作は<function>pg_advisory_lock</>と同じですが、他のセッションの共有ロックと共有できるロックである点が異なります。
排他ロック要求のみ締め出されます。
   </para>

   <indexterm>
    <primary>pg_try_advisory_lock</primary>
   </indexterm>
   <para>
<!--
    <function>pg_try_advisory_lock</> is similar to
    <function>pg_advisory_lock</>, except the function will not wait for the
    lock to become available.  It will either obtain the lock immediately and
    return <literal>true</>, or return <literal>false</> if the lock cannot be
    acquired immediately.
-->
<function>pg_try_advisory_lock</>は<function>pg_advisory_lock</>と同様ですが、この関数の場合、ロックが利用可能になるまで待機しません。
ロックを即座に取得し<literal>true</>を返すか、ロックを即座に獲得できなかった場合に<literal>false</>を返すかのいずれかです。
   </para>

   <indexterm>
    <primary>pg_try_advisory_lock_shared</primary>
   </indexterm>
   <para>
<!--
    <function>pg_try_advisory_lock_shared</> works the same as
    <function>pg_try_advisory_lock</>, except it attempts to acquire
    a shared rather than an exclusive lock.
-->
<function>pg_try_advisory_lock_shared</>の動作は <function>pg_try_advisory_lock</>と同じですが、排他ロックではなく共有ロックの獲得を試みます。
   </para>

   <indexterm>
    <primary>pg_advisory_unlock</primary>
   </indexterm>
   <para>
<!--
    <function>pg_advisory_unlock</> will release a previously-acquired
    exclusive session level advisory lock.  It
    returns <literal>true</> if the lock is successfully released.
    If the lock was not held, it will return <literal>false</>,
    and in addition, an SQL warning will be reported by the server.
-->
<function>pg_advisory_unlock</>は、事前に獲得したセッションレベルの勧告的排他ロックを解放します。ロックの解放に成功した場合、<literal>true</>を返します。ロックを保持していない場合、<literal>false</>を返し、さらに、SQL警告がサーバから報告されます。
   </para>

   <indexterm>
    <primary>pg_advisory_unlock_shared</primary>
   </indexterm>
   <para>
<!--
    <function>pg_advisory_unlock_shared</> works the same as
    <function>pg_advisory_unlock</>,
    except it releases a shared session level advisory lock.
-->
<function>pg_advisory_unlock_shared</>の動作は<function>pg_advisory_unlock</>と同じですが、セッションレベルの勧告的共有ロックを解放する点が異なります。
   </para>

   <indexterm>
    <primary>pg_advisory_unlock_all</primary>
   </indexterm>
   <para>
<!--
    <function>pg_advisory_unlock_all</> will release all session level advisory
    locks held by the current session.  (This function is implicitly invoked
    at session end, even if the client disconnects ungracefully.)
-->
<function>pg_advisory_unlock_all</>は、現在のセッションで保持するセッションレベルの勧告的ロックをすべて解放します。
（この関数は、クライアントとの接続がぶざまに切れた場合でも、セッション終了時に暗黙的に呼び出されます。)
   </para>

   <indexterm>
    <primary>pg_advisory_xact_lock</primary>
   </indexterm>
   <para>
<!--
    <function>pg_advisory_xact_lock</> works the same as
    <function>pg_advisory_lock</>, except the lock is automatically released
    at the end of the current transaction and cannot be released explicitly.
-->
<function>pg_advisory_xact_lock</>の動作は<function>pg_advisory_lock</>と同じですが、現在のトランザクションの終了時に自動的にロックが解放され、明示的なロックの解放はできません。
   </para>

   <indexterm>
    <primary>pg_advisory_xact_lock_shared</primary>
   </indexterm>
   <para>
<!--
    <function>pg_advisory_xact_lock_shared</> works the same as
    <function>pg_advisory_lock_shared</>, except the lock is automatically released
    at the end of the current transaction and cannot be released explicitly.
-->
<function>pg_advisory_xact_lock_shared</>の動作は<function>pg_advisory_lock_shared</>と同じですが、現在のトランザクションの終了時に自動的にロックが解放され、明示的なロックの解放はできません。
   </para>

   <indexterm>
    <primary>pg_try_advisory_xact_lock</primary>
   </indexterm>
   <para>
<!--
    <function>pg_try_advisory_xact_lock</> works the same as
    <function>pg_try_advisory_lock</>, except the lock, if acquired,
    is automatically released at the end of the current transaction and
    cannot be released explicitly.
-->
<function>pg_try_advisory_xact_lock</>の動作は<function>pg_try_advisory_lock</>と同じですが、ロックが獲得できた場合は現在のトランザクションの終了時に自動的にロックが解放され、明示的なロックの解放はできません。
   </para>

   <indexterm>
    <primary>pg_try_advisory_xact_lock_shared</primary>
   </indexterm>
   <para>
<!--
    <function>pg_try_advisory_xact_lock_shared</> works the same as
    <function>pg_try_advisory_lock_shared</>, except the lock, if acquired,
    is automatically released at the end of the current transaction and
    cannot be released explicitly.
-->
<function>pg_try_advisory_xact_lock_shared</>の動作は<function>pg_try_advisory_lock_shared</>と同じですが、ロックが獲得できた場合は現在のトランザクションの終了時に自動的にロックが解放され、明示的なロックの解放はできません。
   </para>

  </sect2>

  </sect1>

  <sect1 id="functions-trigger">
<!--
   <title>Trigger Functions</title>
-->
   <title>トリガ関数</title>

   <indexterm>
     <primary>suppress_redundant_updates_trigger</primary>
   </indexterm>

   <para>
<!--
      Currently <productname>PostgreSQL</> provides one built in trigger
      function, <function>suppress_redundant_updates_trigger</>,
      which will prevent any update
      that does not actually change the data in the row from taking place, in
      contrast to the normal behavior which always performs the update
      regardless of whether or not the data has changed. (This normal behavior
      makes updates run faster, since no checking is required, and is also
      useful in certain cases.)
-->
現在、<productname>PostgreSQL</>は、１つの組み込みトリガ関数<function>suppress_redundant_updates_trigger</>を提供しており、通常の動作、つまりデータが変更されようがされまいがに関わらず常に更新をする場合とは正反対に、行のデータを実際に変更しない更新が起こらないようにします。
（この通常の動作は、検査を必要としないため更新をより迅速に行い、場合によっては便利です。）
    </para>

    <para>
<!--
      Ideally, you should normally avoid running updates that don't actually
      change the data in the record. Redundant updates can cost considerable
      unnecessary time, especially if there are lots of indexes to alter,
      and space in dead rows that will eventually have to be vacuumed.
      However, detecting such situations in client code is not
      always easy, or even possible, and writing expressions to detect
      them can be error-prone. An alternative is to use
      <function>suppress_redundant_updates_trigger</>, which will skip
      updates that don't change the data. You should use this with care,
      however. The trigger takes a small but non-trivial time for each record,
      so if most of the records affected by an update are actually changed,
      use of this trigger will actually make the update run slower.
-->
理想的には、通常実際レコード内のデータを変更しない更新の実行を避けるべきです。
冗長な更新により、特に変更対象の多くのインデックスが存在する場合、無視できない不要な時間にかかるコストが発生することがあります。
また、最後にはバキュームしなければならなくなる不要行が場所を取ることになります。
しかし、こうした状況をクライアント側で判定することは常に簡単ではありません。
また、可能であったとしても、それを検知するための式の記述はエラーを招きがちです。
他の方法として、<function>suppress_redundant_updates_trigger</>を使用することがあります。
これはデータを変更しない更新を飛ばします。
しかしこの関数は注意して使用しなければなりません。
このトリガはレコードごとに小さな、しかし僅かではない時間がかかります。
このため、更新が影響するレコードのほとんどが実際には変更されない場合、このトリガは確実に更新の実行を低速にします。
    </para>

    <para>
<!--
      The <function>suppress_redundant_updates_trigger</> function can be
      added to a table like this:
-->
<function>suppress_redundant_updates_trigger</>関数は以下のようにテーブルに追加できます。
<programlisting>
CREATE TRIGGER z_min_update
BEFORE UPDATE ON tablename
FOR EACH ROW EXECUTE PROCEDURE suppress_redundant_updates_trigger();
</programlisting>
<!--
      In most cases, you would want to fire this trigger last for each row.
      Bearing in mind that triggers fire in name order, you would then
      choose a trigger name that comes after the name of any other trigger
      you might have on the table.
-->
ほとんどの場合、それぞれの行に対しこのトリガを最後に起動させる必要が生じます。
トリガは名前順に起動されることを判っているとして、テーブル上に存在する可能性のある他のトリガの名前の後に続くようトリガ名を選択できます。
    </para>
    <para>
<!--
       For more information about creating triggers, see
        <xref linkend="SQL-CREATETRIGGER">.
-->
トリガ作成についてより詳細は<xref linkend="SQL-CREATETRIGGER">を参照ください。
    </para>
  </sect1>

  <sect1 id="functions-event-triggers">
<!--
   <title>Event Trigger Functions</title>
-->
   <title>イベントトリガ関数</title>

   <indexterm>
     <primary>pg_event_trigger_dropped_objects</primary>
   </indexterm>

   <para>
<!--
    Currently <productname>PostgreSQL</> provides one built-in event trigger
    helper function, <function>pg_event_trigger_dropped_objects</>.
-->
現時点で<productname>PostgreSQL</>は一つの組み込みイベントトリガ支援関数、<function>pg_event_trigger_dropped_objects</>を提供しています。
   </para>

   <para>
<!--
    <function>pg_event_trigger_dropped_objects</> returns a list of all objects
    dropped by the command in whose <literal>sql_drop</> event it is called.
    If called in any other context,
    <function>pg_event_trigger_dropped_objects</> raises an error.
    <function>pg_event_trigger_dropped_objects</> returns the following columns:
-->
関数<function>pg_event_trigger_dropped_objects</>は、それが呼ばれた<literal>sql_drop</>イベントのコマンドにより削除された全てのオブジェクトのリストを返します。
その他いかなる状況で呼ばれた場合、<function>pg_event_trigger_dropped_objects</>はエラーを生じさせます。
<function>pg_event_trigger_dropped_objects</>は以下の列を返します。

    <informaltable>
     <tgroup cols="3">
      <thead>
       <row>
<!--
        <entry>Name</entry>
        <entry>Type</entry>
        <entry>Description</entry>
-->
        <entry>名前</entry>
        <entry>型</entry>
        <entry>説明</entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry><literal>classid</literal></entry>
        <entry><type>Oid</type></entry>
<!--
        <entry>OID of catalog the object belonged in</entry>
-->
        <entry>オブジェクトが所属するカタログのOID</entry>
       </row>
       <row>
        <entry><literal>objid</literal></entry>
        <entry><type>Oid</type></entry>
<!--
        <entry>OID the object had within the catalog</entry>
-->
        <entry>カタログ内に所有するオブジェクトのOID</entry>
       </row>
       <row>
        <entry><literal>objsubid</literal></entry>
        <entry><type>int32</type></entry>
<!--
        <entry>Object sub-id (e.g. attribute number for columns)</entry>
-->
        <entry> (列の属性番号のような)オブジェクトの副id</entry>
       </row>
       <row>
        <entry><literal>object_type</literal></entry>
        <entry><type>text</type></entry>
<!--
        <entry>Type of the object</entry>
-->
        <entry>オブジェクトの型</entry>
       </row>
       <row>
        <entry><literal>schema_name</literal></entry>
        <entry><type>text</type></entry>
        <entry>
<!--
         Name of the schema the object belonged in, if any; otherwise <literal>NULL</>.
         No quoting is applied.
-->
オブジェクトが所属しているスキーマの名前, if any; otherwise <literal>NULL</>.
No quoting is applied.
        </entry>
       </row>
       <row>
        <entry><literal>object_name</literal></entry>
        <entry><type>text</type></entry>
        <entry>
<!--
         Name of the object, if the combination of schema and name can be
         used as a unique identifier for the object; otherwise <literal>NULL</>.
         No quoting is applied, and name is never schema-qualified.
-->
スキーマと名前の組み合わせがオブジェクトに対する一意の識別子として使用可能な場合のオブジェクトの名前。そうでないときは<literal>NULL</>。
引用符は適用されず、名前は決してスキーマで修飾されません。
        </entry>
       </row>
       <row>
        <entry><literal>object_identity</literal></entry>
        <entry><type>text</type></entry>
        <entry>
<!--
         Text rendering of the object identity, schema-qualified. Each and every
         identifier present in the identity is quoted if necessary.
-->
オブジェクト識別のテキスト表現で、スキーマで修飾さられています。
権限のなかにあるそれぞれ全ての識別子は必要であれば引用符で括られます。
        </entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>
   </para>

   <para>
<!--
    The <function>pg_event_trigger_dropped_objects</> function can be used
    in an event trigger like this:
-->
関数<function>pg_event_trigger_dropped_objects</>は以下のようにイベントトリガとして使用可能です。
<programlisting>
CREATE FUNCTION test_event_trigger_for_drops()
        RETURNS event_trigger LANGUAGE plpgsql AS $$
DECLARE
    obj record;
BEGIN
    FOR obj IN SELECT * FROM pg_event_trigger_dropped_objects()
    LOOP
        RAISE NOTICE '% dropped object: % %.% %',
                     tg_tag,
                     obj.object_type,
                     obj.schema_name,
                     obj.object_name,
                     obj.object_identity;
    END LOOP;
END
$$;
CREATE EVENT TRIGGER test_event_trigger_for_drops
   ON sql_drop
   EXECUTE PROCEDURE test_event_trigger_for_drops();
</programlisting>
    </para>

     <para>
<!--
       For more information about event triggers,
       see <xref linkend="event-triggers">.
-->
イベントトリガについての詳細は<xref linkend="event-triggers">を参照してください。
    </para>
  </sect1>

</chapter>
