<!--
doc/src/sgml/ref/create_aggregate.sgml 20110326
PostgreSQL documentation
-->

<refentry id="SQL-CREATEAGGREGATE">
 <refmeta>
  <refentrytitle>CREATE AGGREGATE</refentrytitle>
  <manvolnum>7</manvolnum>
<!--
  <refmiscinfo>SQL - Language Statements</refmiscinfo>
-->
<refmiscinfo>SQL - 言語</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>CREATE AGGREGATE</refname>
<!--
  <refpurpose>define a new aggregate function</refpurpose>
-->
  <refpurpose>新しい集約関数を定義する</refpurpose>
 </refnamediv>

 <indexterm zone="sql-createaggregate">
  <primary>CREATE AGGREGATE</primary>
 </indexterm>

 <refsynopsisdiv>
<synopsis>
CREATE AGGREGATE <replaceable class="PARAMETER">name</replaceable> ( <replaceable class="PARAMETER">input_data_type</replaceable> [ , ... ] ) (
    SFUNC = <replaceable class="PARAMETER">sfunc</replaceable>,
    STYPE = <replaceable class="PARAMETER">state_data_type</replaceable>
    [ , FINALFUNC = <replaceable class="PARAMETER">ffunc</replaceable> ]
    [ , INITCOND = <replaceable class="PARAMETER">initial_condition</replaceable> ]
    [ , SORTOP = <replaceable class="PARAMETER">sort_operator</replaceable> ]
)

<!--
<phrase>or the old syntax</phrase>
-->
<phrase>または以下の旧構文</phrase>

CREATE AGGREGATE <replaceable class="PARAMETER">name</replaceable> (
    BASETYPE = <replaceable class="PARAMETER">base_type</replaceable>,
    SFUNC = <replaceable class="PARAMETER">sfunc</replaceable>,
    STYPE = <replaceable class="PARAMETER">state_data_type</replaceable>
    [ , FINALFUNC = <replaceable class="PARAMETER">ffunc</replaceable> ]
    [ , INITCOND = <replaceable class="PARAMETER">initial_condition</replaceable> ]
    [ , SORTOP = <replaceable class="PARAMETER">sort_operator</replaceable> ]
)
</synopsis>
 </refsynopsisdiv>

 <refsect1>
<!--
  <title>Description</title>
-->
  <title>説明</title>

  <para>
<!--
   <command>CREATE AGGREGATE</command> defines a new aggregate
   function. Some basic and commonly-used aggregate functions are
   included with the distribution; they are documented in <xref
   linkend="functions-aggregate">. If one defines new types or needs
   an aggregate function not already provided, then <command>CREATE
   AGGREGATE</command> can be used to provide the desired features.
-->
<command>CREATE AGGREGATE</command>は、新しい集約関数を定義します。
配布物には基本的、かつ、よく使用される集約関数がいくつか含まれています。これらの集約関数については、<xref linkend="functions-aggregate">に文書化されています。
新しい型を定義する場合、またはまだ提供されていない集約関数が必要な場合、必要な機能を実現するために<command>CREATE AGGREGATE</command>を使うことができます。
  </para>

  <para>
<!--
   If a schema name is given (for example, <literal>CREATE AGGREGATE
   myschema.myagg ...</>) then the aggregate function is created in the
   specified schema.  Otherwise it is created in the current schema.
-->
スキーマ名が付けられている場合（例えば、<literal>CREATE AGGREGATE myschema.myagg ...</>）、集約関数は指定されたスキーマで作成されます。
スキーマ名がなければ、集約関数は現在のスキーマで作成されます。
  </para>

  <para>
<!--
   An aggregate function is identified by its name and input data type(s).
   Two aggregates in the same schema can have the same name if they operate on
   different input types.  The
   name and input data type(s) of an aggregate must also be distinct from
   the name and input data type(s) of every ordinary function in the same
   schema.
-->
集約関数は名前と入力データ型(複数可)の組み合わせによって識別されます。
演算の対象となる入力データ型が異なっていれば、同じスキーマ内に同じ名前の集約関数があっても構いません。
1つのスキーマ内では、集約関数の名前と入力データ型(複数可)は、通常の関数の名前と入力データ型と異なる必要があります。
  </para>

  <para>
<!--
   An aggregate function is made from one or two ordinary
   functions:
   a state transition function
   <replaceable class="PARAMETER">sfunc</replaceable>,
   and an optional final calculation function
   <replaceable class="PARAMETER">ffunc</replaceable>.
   These are used as follows:
-->
集約関数は1つか2つの通常の関数から作られます。
状態遷移関数<replaceable class="PARAMETER">sfunc</replaceable>と省略可能な最終計算関数<replaceable class="PARAMETER">ffunc</replaceable>です。
これらは以下のように使われます。
<programlisting>
<!--
<replaceable class="PARAMETER">sfunc</replaceable>( internal-state, next-data-values ) &#045;&#045;&#045;> next-internal-state
<replaceable class="PARAMETER">ffunc</replaceable>( internal-state ) &#055;&#055;&#055;> aggregate-value
-->
<replaceable class="PARAMETER">sfunc</replaceable>( 内部状態, 次のデータ値 ) ---> 次の内部状態
<replaceable class="PARAMETER">ffunc</replaceable>( 内部状態 ) ---> 集約の結果
</programlisting>
  </para>

  <para>
<!--
   <productname>PostgreSQL</productname> creates a temporary variable
   of data type <replaceable class="PARAMETER">stype</replaceable>
   to hold the current internal state of the aggregate.  At each input row,
   the aggregate argument value(s) are calculated and
   the state transition function is invoked with the current state value
   and the new argument value(s) to calculate a new
   internal state value.  After all the rows have been processed,
   the final function is invoked once to calculate the aggregate's return
   value.  If there is no final function then the ending state value
   is returned as-is.
-->
<productname>PostgreSQL</productname>は、集約の現在の内部状態を保持する<replaceable class="PARAMETER">stype</replaceable>データ型の一時変数を作成します。
それぞれの入力行に対して、集約引数の値が計算され、現在の状態値と新しい引数値で新しい内部状態変数を計算するために状態遷移関数が呼び出されます。
全ての行が処理されると、集約の出力値を計算するために最終関数が1回呼び出されます。
最終関数がない場合は、終了時の状態値がそのまま返されます。

  </para>
  
  <para>
<!--
   An aggregate function can provide an initial condition,
   that is, an initial value for the internal state value.
   This is specified and stored in the database as a value of type
   <type>text</type>, but it must be a valid external representation
   of a constant of the state value data type.  If it is not supplied
   then the state value starts out null.
-->
集約関数は、内部状態の初期値として初期状態を提供することができます。
これは<type>text</type>型の値としてデータベースに格納されますが、状態値データ型の定数として有効な外部表現でなければいけません。
初期状態が与えられていない場合、状態値はNULLから始まります。
  </para>
  
  <para>
<!--
   If the state transition function is declared <quote>strict</quote>,
   then it cannot be called with null inputs.  With such a transition
   function, aggregate execution behaves as follows.  Rows with any null input
   values are ignored (the function is not called and the previous state value
   is retained).  If the initial state value is null, then at the first row
   with all-nonnull input values, the first argument value replaces the state
   value, and the transition function is invoked at subsequent rows with
   all-nonnull input values.
   This is handy for implementing aggregates like <function>max</function>.
   Note that this behavior is only available when
   <replaceable class="PARAMETER">state_data_type</replaceable>
   is the same as the first
   <replaceable class="PARAMETER">input_data_type</replaceable>.
   When these types are different, you must supply a nonnull initial
   condition or use a nonstrict transition function.
-->
状態遷移関数が<quote>厳格（strict）</quote>と宣言されている場合、NULLを入力値にして呼び出すことはできません。
そのような遷移関数では、集約は次のように実行されます。
NULL入力値を持つ行は無視されます。
（関数は呼び出されず、前回の状態値が保持されます。）
初期状態値がNULLである場合、初めて入力行がすべて非NULL入力値であった時にその引数の値で状態値を置き換え、次に入力行がすべて非NULL入力値を持つ時から遷移関数の呼び出しが始まります。
このような動作は、<function>max</function>のような集約を実装するには便利です。
ただし、<replaceable class="PARAMETER">state_data_type</replaceable>が最初の<replaceable class="PARAMETER">input_data_type</replaceable>と同じ時にのみ有効であることに注意してください。
これらの型が異なる時は、非NULL初期値を供給するか、厳格でない遷移関数を使わなければいけません。
  </para>
  
  <para>
<!--
   If the state transition function is not strict, then it will be called
   unconditionally at each input row, and must deal with null inputs
   and null transition values for itself.  This allows the aggregate
   author to have full control over the aggregate's handling of null values.
-->
状態遷移関数が厳格（strict）でない場合は、それぞれの入力行に対してその関数が無条件に呼び出されるので、NULL入力とNULL遷移値を自分で処理しなければいけません。
これは、関数の作成者が、集約関数におけるNULL値の扱いを完全に制御できることを意味します。
  </para>
  
  <para>
<!--
   If the final function is declared <quote>strict</quote>, then it will not
   be called when the ending state value is null; instead a null result
   will be returned automatically.  (Of course this is just the normal
   behavior of strict functions.)  In any case the final function has
   the option of returning a null value.  For example, the final function for
   <function>avg</function> returns null when it sees there were zero
   input rows.
-->
最終関数が<quote>厳格（strict）</quote>と宣言されていると、終了状態値がNULLの時は、最終関数が呼び出されません。
その場合、NULLという結果が自動的に出力されます
（もちろんこれは、厳格な関数の一般的な動作に過ぎません）。
どのような場合でも、最終関数はNULLを返すことができます。
例えば、<function>avg</function>の最終関数は、入力が0行だとわかるとNULLを返します。
  </para>

  <para>
<!--
   Aggregates that behave like <function>MIN</> or <function>MAX</> can
   sometimes be optimized by looking into an index instead of scanning every
   input row.  If this aggregate can be so optimized, indicate it by
   specifying a <firstterm>sort operator</>.  The basic requirement is that
   the aggregate must yield the first element in the sort ordering induced by
   the operator; in other words:
-->
<function>MIN</>や<function>MAX</>のような振舞いをする集約では、すべての入力行を走査せずにインデックスを検索することで最適化できることがあります。
このように最適化される集約の場合、<firstterm>ソート演算子</>を指定することで明示してください。
その演算子で生成されるソート順で集約の最初の要素が生成されなければならないということが基本的な必要条件です。
言い換えると、
<programlisting>
SELECT agg(col) FROM tab;
</programlisting>
<!--
   must be equivalent to:
-->
が
<programlisting>
SELECT col FROM tab ORDER BY col USING sortop LIMIT 1;
</programlisting>
と同じでなければならないということです。
<!--

   Further assumptions are that the aggregate ignores null inputs, and that
   it delivers a null result if and only if there were no non-null inputs.
   Ordinarily, a data type's <literal>&lt;</> operator is the proper sort
   operator for <function>MIN</>, and <literal>&gt;</> is the proper sort
   operator for <function>MAX</>.  Note that the optimization will never
   actually take effect unless the specified operator is the <quote>less
   than</quote> or <quote>greater than</quote> strategy member of a B-tree
   index operator class.
-->
更に、集約がNULL入力を無視すること、および、NULL以外の入力がまったくなかった時にのみNULLという結果を返すことも前提となります。
通常、データ型の<literal>&lt;</>演算子は<function>MIN</>のソート演算子として、また、<literal>&gt;</>演算子は<function>MAX</>のソート演算子として適切です。
指定した演算子がB-treeインデックス演算子クラスの<quote>より小さい</quote>ストラテジか<quote>より大きい</quote>ストラテジのメンバでない限り、最適化が実際には効果がないことに注意してください。
  </para>
  <para>
<!--
   To be able to create an aggregate function, you must
   have <literal>USAGE</literal> privilege on the argument types, the state
   type, and the return type, as well as <literal>EXECUTE</literal> privilege
   on the transition and final functions.
-->
集約関数を作成するためには、引数の型、状態の型、戻り値の型に対する<literal>USAGE</literal>権限と遷移関数と最終関数に対する<literal>EXECUTE</literal>権限を持たなければなりません。
  </para>
 </refsect1>

 <refsect1>
<!--
  <title>Parameters</title>
-->
  <title>パラメータ</title>

  <variablelist>
   <varlistentry>
    <term><replaceable class="PARAMETER">name</replaceable></term>
    <listitem>
     <para>
<!--
      The name (optionally schema-qualified) of the aggregate function
      to create.
-->
      作成する集約関数の名前です（スキーマ修飾名も可）。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="PARAMETER">input_data_type</replaceable></term>
    <listitem>
     <para>
<!--
      An input data type on which this aggregate function operates.
      To create a zero-argument aggregate function, write <literal>*</>
      in place of the list of input data types.  (An example of such an
      aggregate is <function>count(*)</function>.)
-->
集約関数が演算する入力データ型です。 
引数が存在しない集約関数を作成するには、入力データ型のリストに<literal>*</>と記載してください
（例えば <function>count(*)</function>などの集約です）。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="PARAMETER">base_type</replaceable></term>
    <listitem>
     <para>
<!--
      In the old syntax for <command>CREATE AGGREGATE</>, the input data type
      is specified by a <literal>basetype</> parameter rather than being
      written next to the aggregate name.  Note that this syntax allows
      only one input parameter.  To define a zero-argument aggregate function,
      specify the <literal>basetype</> as
      <literal>"ANY"</> (not <literal>*</>).
-->
<command>CREATE AGGREGATE</>の旧構文では、入力データ型は集約名称の次に記載されたものではなく<literal>basetype</>パラメータにより指定されます。
この構文では１つの入力パラメータしか指定できないことに注意してください。
引数を持たない集約を定義するためには、<literal>basetype</>を<literal>"ANY"</> （<literal>*</>ではありません）と指定してください。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="PARAMETER">sfunc</replaceable></term>
    <listitem>
     <para>
<!--
      The name of the state transition function to be called for each
      input row.  For an <replaceable class="PARAMETER">N</>-argument
      aggregate function, the <replaceable class="PARAMETER">sfunc</>
      must take <replaceable class="PARAMETER">N</>+1 arguments,
      the first being of type <replaceable
      class="PARAMETER">state_data_type</replaceable> and the rest
      matching the declared input data type(s) of the aggregate.
      The function must return a value of type <replaceable
      class="PARAMETER">state_data_type</replaceable>.  This function
      takes the current state value and the current input data value(s),
      and returns the next state value.
-->
それぞれの入力行に対して呼び出される状態遷移関数の名前です。
<replaceable class="PARAMETER">N</>引数を持つ集約関数では、<replaceable class="PARAMETER">sfunc</>は<replaceable class="PARAMETER">N</>+1個の引数を取らなければなりません。
最初の引数は<replaceable class="PARAMETER">state_data_type</replaceable>型で、残りはその集約の入力データ型として宣言したものと一致していなければなりません。
この関数は<replaceable class="PARAMETER">state_data_type</replaceable>型の値を返さなければなりません。
この関数は、現在の状態値と現在の入力データ値を受け取り、次の状態値を返します。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="PARAMETER">state_data_type</replaceable></term>
    <listitem>
     <para>
<!--
      The data type for the aggregate's state value.
-->
集約の状態値のデータ型です。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="PARAMETER">ffunc</replaceable></term>
    <listitem>
     <para>
<!--
      The name of the final function called to compute the aggregate's
      result after all input rows have been traversed.  The function
      must take a single argument of type <replaceable
      class="PARAMETER">state_data_type</replaceable>.  The return
      data type of the aggregate is defined as the return type of this
      function.  If <replaceable class="PARAMETER">ffunc</replaceable>
      is not specified, then the ending state value is used as the
      aggregate's result, and the return type is <replaceable
      class="PARAMETER">state_data_type</replaceable>.
-->
最終関数の名前です。最終関数は、全ての入力行に対する処理が終わった後、集約の結果を計算するために呼び出されます。
この関数は<replaceable class="PARAMETER">state_data_type</replaceable>型の引数を1つ取らなければなりません。
集約の出力データ型はこの関数の返り値として定義されます。
<replaceable class="PARAMETER">ffunc</replaceable>が指定されない場合には、集約の結果として終了時の状態値が使われます。出力型は<replaceable class="PARAMETER">state_data_type</replaceable>になります。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="PARAMETER">initial_condition</replaceable></term>
    <listitem>
     <para>
<!--
      The initial setting for the state value.  This must be a string
      constant in the form accepted for the data type <replaceable
      class="PARAMETER">state_data_type</replaceable>.  If not
      specified, the state value starts out null.
-->
状態値の初期設定です。
データ型<replaceable class="PARAMETER">state_data_type</replaceable>として受け取り可能な文字列定数でなければいけません。
このパラメータが指定されない場合、状態値はNULLから始まります。
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><replaceable class="PARAMETER">sort_operator</replaceable></term>
    <listitem>
     <para>
<!--
      The associated sort operator for a <function>MIN</>- or
      <function>MAX</>-like aggregate.
      This is just an operator name (possibly schema-qualified).
      The operator is assumed to have the same input data types as
      the aggregate (which must be a single-argument aggregate).
-->
<function>MIN</>または<function>MAX</>のような集約に対して関連付いたソート演算子です。
これは単なる演算子の名前です（スキーマで修飾可能）。
この演算子は集約（これは単一引数の集約でなければなりません）と同じ入力データ型を持つと前提されています。
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

  <para>
<!--
   The parameters of <command>CREATE AGGREGATE</command> can be
   written in any order, not just the order illustrated above.
-->
<command>CREATE AGGREGATE</command>のパラメータは、任意の順番で記述することができます。上記の順番で記述する必要はありません。
  </para>
 </refsect1>
  
 <refsect1>
<!--
  <title>Examples</title>
-->
  <title>例</title>

  <para>
<!--
   See <xref linkend="xaggr">.
-->
<xref linkend="xaggr">を参照してください。
  </para>
 </refsect1>

 <refsect1>
<!--
  <title>Compatibility</title>
-->
  <title>互換性</title>

  <para>
<!--
   <command>CREATE AGGREGATE</command> is a
   <productname>PostgreSQL</productname> language extension.  The SQL
   standard does not provide for user-defined aggregate functions.
-->
<command>CREATE AGGREGATE</command>は<productname>PostgreSQL</productname>の言語拡張です。
標準SQLには、ユーザ定義の集約関数を使用する機能はありません。
  </para>
 </refsect1>

 <refsect1>
<!--
  <title>See Also</title>
-->
  <title>関連項目</title>

  <simplelist type="inline">
   <member><xref linkend="sql-alteraggregate"></member>
   <member><xref linkend="sql-dropaggregate"></member>
  </simplelist>
 </refsect1>
</refentry>
