<!-- 警告：このファイルは直接編集しないでください！
1. libpq.sgmlを編集したら、split-libpq.shを起動します。
2. するとlibpq[0-3].sgmlが生成されます。
3. libpq.sgmlとともにlibpq[0-3].sgmlのうち変更されたファイルをcommit/pushしてpull requestを作成してください。
4. レビューはlibpq[0-3].sgmlに対して行います。
5. 指摘された点があればlibpq.sgmlに反映し、1に戻ります。
6. libpq.sgmlの変更がなければ、pull requestをマージして終了です。お疲れ様でした！
-->
<!-- split-libpq2-start -->

 <sect1 id="libpq-single-row-mode">
<!--
  <title>Retrieving Query Results Row-by-Row</title>
-->
  <title>１行１行問い合わせ結果を受け取る</title>

  <indexterm zone="libpq-single-row-mode">
   <primary>libpq</primary>
   <secondary>single-row mode</secondary>
  </indexterm>
  <indexterm zone="libpq-single-row-mode">
   <primary>libpq</primary>
   <secondary>単一行モード</secondary>
  </indexterm>

  <para>
<!--
   Ordinarily, <application>libpq</application> collects a SQL command's
   entire result and returns it to the application as a single
   <structname>PGresult</structname>.  This can be unworkable for commands
   that return a large number of rows.  For such cases, applications can use
   <xref linkend="libpq-PQsendQuery"/> and <xref linkend="libpq-PQgetResult"/> in
   <firstterm>single-row mode</firstterm>.  In this mode, the result row(s) are
   returned to the application one at a time, as they are received from the
   server.
-->
通常、<application>libpq</application>はSQLコマンドの結果全体を収集し、それを１つの<structname>PGresult</structname>としてアプリケーションに返します。
これは、多くの行数を返すコマンドでは動作しなくなるかもしれません。
こうした場合、アプリケーションは<xref linkend="libpq-PQsendQuery"/>と<xref linkend="libpq-PQgetResult"/>を<firstterm>単一行モード</firstterm>で使用することができます。
このモードでは、結果行は、サーバから受け取ったかのように、アプリケーションに１度に１行返されます。
  </para>

  <para>
<!--
   To enter single-row mode, call <xref linkend="libpq-PQsetSingleRowMode"/>
   immediately after a successful call of <xref linkend="libpq-PQsendQuery"/>
   (or a sibling function).  This mode selection is effective only for the
   currently executing query.  Then call <xref linkend="libpq-PQgetResult"/>
   repeatedly, until it returns null, as documented in <xref
   linkend="libpq-async"/>.  If the query returns any rows, they are returned
   as individual <structname>PGresult</structname> objects, which look like
   normal query results except for having status code
   <literal>PGRES_SINGLE_TUPLE</literal> instead of
   <literal>PGRES_TUPLES_OK</literal>.  After the last row, or immediately if
   the query returns zero rows, a zero-row object with status
   <literal>PGRES_TUPLES_OK</literal> is returned; this is the signal that no
   more rows will arrive.  (But note that it is still necessary to continue
   calling <xref linkend="libpq-PQgetResult"/> until it returns null.)  All of
   these <structname>PGresult</structname> objects will contain the same row
   description data (column names, types, etc) that an ordinary
   <structname>PGresult</structname> object for the query would have.
   Each object should be freed with <xref linkend="libpq-PQclear"/> as usual.
-->
単一行モードに入るためには、<xref linkend="libpq-PQsendQuery"/>（または同系列の関数）の呼び出しに成功した直後に<xref linkend="libpq-PQsetSingleRowMode"/>を呼び出してください。
このモード選択は、現在実行中の問い合わせに対してのみ有効です。
その後、<xref linkend="libpq-async"/>の説明通りに、ヌルを返すようになるまで<xref linkend="libpq-PQgetResult"/>を繰り返し呼び出してください。
問い合わせが何らかの行を返す場合、<literal>PGRES_TUPLES_OK</literal>ではなく<literal>PGRES_SINGLE_TUPLE</literal>状態コードを持つ以外通常の問い合わせ結果と同じように見える、個々の<structname>PGresult</structname>オブジェクトを返します。
最後の行の後、または問い合わせがゼロ行を返す場合は即座に、<literal>PGRES_TUPLES_OK</literal>状態のゼロ行のオブジェクトが返されます。
これはもう行が届かないことを通知するものです。
（しかしヌルが返るまで<xref linkend="libpq-PQgetResult"/>を呼び出さなければならないことに注意してください。）
<structname>PGresult</structname>オブジェクトのすべては、その問い合わせに対する通常の<structname>PGresult</structname>と同一の行説明データ（列名、型など）を持ちます。
各オブジェクトは通常通り<xref linkend="libpq-PQclear"/>で解放しなければなりません。
  </para>

  <para>
   <variablelist>
    <varlistentry id="libpq-PQsetSingleRowMode">
     <term><function>PQsetSingleRowMode</function><indexterm><primary>PQsetSingleRowMode</primary></indexterm></term>

     <listitem>
      <para>
<!--
       Select single-row mode for the currently-executing query.
-->
現在実行中の問い合わせについて単一行モードを選択します。

<synopsis>
int PQsetSingleRowMode(PGconn *conn);
</synopsis>
      </para>

      <para>
<!--
       This function can only be called immediately after
       <xref linkend="libpq-PQsendQuery"/> or one of its sibling functions,
       before any other operation on the connection such as
       <xref linkend="libpq-PQconsumeInput"/> or
       <xref linkend="libpq-PQgetResult"/>.  If called at the correct time,
       the function activates single-row mode for the current query and
       returns 1.  Otherwise the mode stays unchanged and the function
       returns 0.  In any case, the mode reverts to normal after
       completion of the current query.
-->
この関数は<xref linkend="libpq-PQsendQuery"/>またはその系列の関数のいずれかの後即座に、<xref linkend="libpq-PQconsumeInput"/>や<xref linkend="libpq-PQgetResult"/>など接続に対する何らかの他の操作を行う前のみに呼び出すことができます。
正しい時点で呼び出された場合、この関数は現在の問い合わせに対して単一行モードを有効にし、１を返します。
この他の場合、モードは変更されず、関数はゼロを返します。
いずれの場合でも、現在の問い合わせが完了した後に通常モードに戻ります。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

  <caution>
   <para>
<!--
    While processing a query, the server may return some rows and then
    encounter an error, causing the query to be aborted.  Ordinarily,
    <application>libpq</application> discards any such rows and reports only the
    error.  But in single-row mode, those rows will have already been
    returned to the application.  Hence, the application will see some
    <literal>PGRES_SINGLE_TUPLE</literal> <structname>PGresult</structname>
    objects followed by a <literal>PGRES_FATAL_ERROR</literal> object.  For
    proper transactional behavior, the application must be designed to
    discard or undo whatever has been done with the previously-processed
    rows, if the query ultimately fails.
-->
問い合わせを処理している間、サーバはいくつか行を返した後にエラーになり、問い合わせがアボートする可能性があります。
通常の<application>libpq</application>では、こうした行を破棄しエラーのみを報告します。
しかし単一行モードでは、これらの行はすでにアプリケーションに返されています。
このためアプリケーションは<literal>PGRES_SINGLE_TUPLE</literal>状態の<structname>PGresult</structname>オブジェクトをいくつか見た後に<literal>PGRES_FATAL_ERROR</literal>オブジェクトを見るかもしれません。
適切な振る舞いのトランザクションのために、最終的に問い合わせが失敗した場合、アプリケーションはこれまで処理した行を破棄するまたは取り消すように設計しなければなりません。
   </para>
  </caution>

 </sect1>

 <sect1 id="libpq-cancel">
<!--
  <title>Canceling Queries in Progress</title>
-->
  <title>処理中の問い合わせのキャンセル</title>

  <indexterm zone="libpq-cancel">
   <primary>canceling</primary>
   <secondary>SQL command</secondary>
  </indexterm>
  <indexterm zone="libpq-cancel">
   <primary>キャンセル</primary>
   <secondary>SQLコマンドの</secondary>
  </indexterm>

  <para>
<!--
   A client application can request cancellation of a command that is
   still being processed by the server, using the functions described in
   this section.
-->
本節で説明する関数を使用して、クライアントアプリケーションはサーバで処理中のコマンドをキャンセルする要求を行うことができます。

   <variablelist>
    <varlistentry id="libpq-PQgetCancel">
     <term><function>PQgetCancel</function><indexterm><primary>PQgetCancel</primary></indexterm></term>

     <listitem>
      <para>
<!--
       Creates a data structure containing the information needed to cancel
       a command issued through a particular database connection.
-->
特定のデータベース接続を通して発行されたコマンドをキャンセルするために必要な情報を持つデータ構造を作成します。
<synopsis>
PGcancel *PQgetCancel(PGconn *conn);
</synopsis>
      </para>

      <para>
<!--
       <xref linkend="libpq-PQgetCancel"/> creates a
       <structname>PGcancel</structname><indexterm><primary>PGcancel</primary></indexterm> object
       given a <structname>PGconn</structname> connection object.  It will return
       <symbol>NULL</symbol> if the given <parameter>conn</parameter> is <symbol>NULL</symbol> or an invalid
       connection.  The <structname>PGcancel</structname> object is an opaque
       structure that is not meant to be accessed directly by the
       application; it can only be passed to <xref linkend="libpq-PQcancel"/>
       or <xref linkend="libpq-PQfreeCancel"/>.
-->
<xref linkend="libpq-PQgetCancel"/>は、与えられた<structname>PGconn</structname>接続オブジェクトの<structname>PGcancel</structname><indexterm><primary>PGcancel</primary></indexterm>オブジェクトを作成します。
与えられた<parameter>conn</parameter>が<symbol>NULL</symbol>もしくは無効な接続であった場合、<symbol>NULL</symbol>が返されます。
<structname>PGcancel</structname>オブジェクトは不透明な構造体であり、アプリケーションから直接アクセスすることができません。
これは<xref linkend="libpq-PQcancel"/>もしくは<xref linkend="libpq-PQfreeCancel"/>に渡すことしかできません。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQfreeCancel">
     <term><function>PQfreeCancel</function><indexterm><primary>PQfreeCancel</primary></indexterm></term>

     <listitem>
      <para>
<!--
       Frees a data structure created by <xref linkend="libpq-PQgetCancel"/>.
-->
<xref linkend="libpq-PQgetCancel"/>で作成されたデータ構造を解放します。
<synopsis>
void PQfreeCancel(PGcancel *cancel);
</synopsis>
      </para>

      <para>
<!--
       <xref linkend="libpq-PQfreeCancel"/> frees a data object previously created
       by <xref linkend="libpq-PQgetCancel"/>.
-->
<xref linkend="libpq-PQfreeCancel"/>は事前に<xref linkend="libpq-PQgetCancel"/>で作成されたデータオブジェクトを解放します。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQcancel">
     <term><function>PQcancel</function><indexterm><primary>PQcancel</primary></indexterm></term>

     <listitem>
      <para>
<!--
       Requests that the server abandon processing of the current command.
-->
サーバに現在のコマンドの廃棄処理を要求します。
<synopsis>
int PQcancel(PGcancel *cancel, char *errbuf, int errbufsize);
</synopsis>
      </para>

      <para>
<!--
       The return value is 1 if the cancel request was successfully
       dispatched and 0 if not.  If not, <parameter>errbuf</parameter> is filled
       with an explanatory error message.  <parameter>errbuf</parameter>
       must be a char array of size <parameter>errbufsize</parameter> (the
       recommended size is 256 bytes).
-->
キャンセル要求の受け入れが成功すれば1を、そうでなければ0を返します。
失敗した場合、<parameter>errbuf</parameter>にそれを説明するエラーメッセージが収納されます。
<parameter>errbuf</parameter>は<parameter>errbufsize</parameter>サイズの文字配列でなければなりません。
(推奨サイズは256バイトです。)
      </para>

      <para>
<!--
       Successful dispatch is no guarantee that the request will have
       any effect, however.  If the cancellation is effective, the current
       command will terminate early and return an error result.  If the
       cancellation fails (say, because the server was already done
       processing the command), then there will be no visible result at
       all.
-->
しかし、要求の受け入れが成功したとしても、その要求の効果が出ることは全く保証していません。
もしキャンセル操作が有効であれば、現在のコマンドは間もなく中断され、エラーが結果として返ります。
キャンセル操作に失敗した場合（例えばバックエンドがすでにコマンド処理を終了していたため）、目に見える結果は何も出てこなくなります。
      </para>

      <para>
<!--
       <xref linkend="libpq-PQcancel"/> can safely be invoked from a signal
       handler, if the <parameter>errbuf</parameter> is a local variable in the
       signal handler.  The <structname>PGcancel</structname> object is read-only
       as far as <xref linkend="libpq-PQcancel"/> is concerned, so it can
       also be invoked from a thread that is separate from the one
       manipulating the <structname>PGconn</structname> object.
-->
<parameter>errbuf</parameter>がシグナルハンドラ内のローカル変数であれば、<xref linkend="libpq-PQcancel"/>はシグナルハンドラから起動しても問題ありません。
<xref linkend="libpq-PQcancel"/>の実行中、<structname>PGcancel</structname>は読み取りのみです。
従って、<structname>PGconn</structname>オブジェクトを操作するスレッドと別のスレッドからこの関数を呼び出すこともできます。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>

   <variablelist>
    <varlistentry id="libpq-PQrequestCancel">
     <term><function>PQrequestCancel</function><indexterm><primary>PQrequestCancel</primary></indexterm></term>

     <listitem>
      <para>
<!--
       <xref linkend="libpq-PQrequestCancel"/> is a deprecated variant of
       <xref linkend="libpq-PQcancel"/>.
-->
<xref linkend="libpq-PQrequestCancel"/>は<xref linkend="libpq-PQcancel"/>の廃止予定の変形版です。

<synopsis>
int PQrequestCancel(PGconn *conn);
</synopsis>
      </para>

      <para>
<!--
       Requests that the server abandon processing of the current
       command.  It operates directly on the
       <structname>PGconn</structname> object, and in case of failure stores the
       error message in the <structname>PGconn</structname> object (whence it can
       be retrieved by <xref linkend="libpq-PQerrorMessage"/>).  Although
       the functionality is the same, this approach creates hazards for
       multiple-thread programs and signal handlers, since it is possible
       that overwriting the <structname>PGconn</structname>'s error message will
       mess up the operation currently in progress on the connection.
-->
サーバに現在のコマンドの廃棄処理を要求します。
これは<structname>PGconn</structname>オブジェクトを直接扱い、また、失敗した場合エラーメッセージは<structname>PGconn</structname>オブジェクト内に収納されます。
(<xref linkend="libpq-PQerrorMessage"/>により取り出すことができます。)
機能的には同一ですが、<structname>PGconn</structname>のエラーメッセージが上書きされることにより、その接続で現在進行中の操作が壊れてしまうため、この方法は複数スレッドプログラムやシグナルハンドラでは問題が起こります。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

 </sect1>

 <sect1 id="libpq-fastpath">
<!--
  <title>The Fast-Path Interface</title>
-->
  <title>近道インタフェース</title>

  <indexterm zone="libpq-fastpath">
   <primary>fast path</primary>
  </indexterm>
  <indexterm zone="libpq-fastpath">
   <primary>近道</primary>
  </indexterm>

  <para>
<!--
   <productname>PostgreSQL</productname> provides a fast-path interface
   to send simple function calls to the server.
-->
<productname>PostgreSQL</productname>は、サーバへの簡単な関数呼び出しを送信する近道 (fast-path) インタフェースを用意しています。
  </para>

  <tip>
   <para>
<!--
    This interface is somewhat obsolete, as one can achieve similar
    performance and greater functionality by setting up a prepared
    statement to define the function call.  Then, executing the statement
    with binary transmission of parameters and results substitutes for a
    fast-path function call.
-->
この関数はどちらかというと廃れたものです。
同様の性能やそれ以上の機能を、関数呼び出しを定義したプリペアド文を設定することで達成できるからです。
そして、その文をパラメータと結果をバイナリ転送するように実行すれば、近道関数呼び出しを置き換えることになります。
   </para>
  </tip>

  <para>
<!--
   The function <function id="libpq-PQfn">PQfn</function><indexterm><primary>PQfn</primary></indexterm>
   requests execution of a server function via the fast-path interface:
-->
<function id="libpq-PQfn">PQfn</function><indexterm><primary>PQfn</primary></indexterm>関数は近道インタフェースを使ってサーバ関数の実行を要求します。
<synopsis>
PGresult *PQfn(PGconn *conn,
               int fnid,
               int *result_buf,
               int *result_len,
               int result_is_int,
               const PQArgBlock *args,
               int nargs);

typedef struct
{
    int len;
    int isint;
    union
    {
        int *ptr;
        int integer;
    } u;
} PQArgBlock;
</synopsis>
  </para>

  <para>
<!--
   The <parameter>fnid</parameter> argument is the OID of the function to be
   executed.  <parameter>args</parameter> and <parameter>nargs</parameter> define the
   parameters to be passed to the function; they must match the declared
   function argument list.  When the <parameter>isint</parameter> field of a
   parameter structure is true, the <parameter>u.integer</parameter> value is sent
   to the server as an integer of the indicated length (this must be
   2 or 4 bytes); proper byte-swapping occurs.  When <parameter>isint</parameter>
   is false, the indicated number of bytes at <parameter>*u.ptr</parameter> are
   sent with no processing; the data must be in the format expected by
   the server for binary transmission of the function's argument data
   type.  (The declaration of <parameter>u.ptr</parameter> as being of
   type <type>int *</type> is historical; it would be better to consider
   it <type>void *</type>.)
   <parameter>result_buf</parameter> points to the buffer in which to place
   the function's return value.  The caller must have allocated sufficient
   space to store the return value.  (There is no check!) The actual result
   length in bytes will be returned in the integer pointed to by
   <parameter>result_len</parameter>.  If a 2- or 4-byte integer result
   is expected, set <parameter>result_is_int</parameter> to 1, otherwise
   set it to 0.  Setting <parameter>result_is_int</parameter> to 1 causes
   <application>libpq</application> to byte-swap the value if necessary, so that it
   is delivered as a proper <type>int</type> value for the client machine;
   note that a 4-byte integer is delivered into <parameter>*result_buf</parameter>
   for either allowed result size.
   When <parameter>result_is_int</parameter> is 0, the binary-format byte string
   sent by the server is returned unmodified. (In this case it's better
   to consider <parameter>result_buf</parameter> as being of
   type <type>void *</type>.)
-->
<parameter>fnid</parameter>引数は実行する関数のOIDです。
<parameter>args</parameter>と<parameter>nargs</parameter>は関数に渡すパラメータを定義します。
これらは関数宣言における引数リストに一致しなければなりません。
パラメータ構造体の<parameter>isint</parameter>が真の場合、<parameter>u.integer</parameter>の値はサーバに指定長の整数として送信されます。
(これは2もしくは4バイトでなければなりません。)
この時、適切なバイト順の交換が行なわれます。
<parameter>isint</parameter>が偽の場合は、<parameter>*u.ptr</parameter>で指定されたバイト数が無処理で送信されます。
関数のパラメータデータ型をバイナリ転送で行うために、このデータはサーバで想定する書式である必要があります。
(<parameter>u.ptr</parameter>を<type>int *</type>型と宣言するのは歴史的なものです。<type>void *</type>と考えた方が良いでしょう。)
<parameter>result_buf</parameter>は関数の戻り値を格納するバッファを指しています。
呼び出し側は戻り値を格納するのに十分な領域を確保しておかなければいけません。
（ライブラリ側ではこの検査はしていません！）
バイト単位での結果の実データ長は<parameter>result_len</parameter>が指す整数で返されます。
結果が2、4バイト整数だと想定できるなら<parameter>result_is_int</parameter>を1に、そうでなければ0を設定します。
<parameter>result_is_int</parameter>を1にすれば、必要に応じて値のバイト順を入れ換えるよう<application>libpq</application>に指示することになります。
そしてクライアントマシン上で正しい<type>int</type>値となるように転送します。
4バイト整数は認められた結果の大きさで<parameter>*result_buf</parameter>に転送されることに注意してください。
<parameter>result_is_int</parameter>が0の場合は、バックエンドが送ったバイナリ書式のバイト列を何も修正せずに返します。
(この場合、<parameter>result_buf</parameter>は<type>void *</type>型と考えた方が良いでしょう。)
  </para>

  <para>
<!--
   <function>PQfn</function> always returns a valid
   <structname>PGresult</structname> pointer. The result status should be
   checked before the result is used.   The caller is responsible for
   freeing  the  <structname>PGresult</structname>  with
   <xref linkend="libpq-PQclear"/> when it is no longer needed.
-->
<function>PQfn</function>は常に有効な<structname>PGresult*</structname>を返します。
結果を使う前にはまず、結果ステータスを調べておくべきでしょう。
結果が必要なくなった時点で、<xref linkend="libpq-PQclear"/>によって、<structname>PGresult</structname>を解放するのは、呼び出し側の責任です。
  </para>

  <para>
<!--
   Note that it is not possible to handle null arguments, null results,
   nor set-valued results when using this interface.
-->
このインタフェースを使用した場合、NULL引数やNULL結果、セット値の結果を扱うことができないことに注意してください。
  </para>

 </sect1>

 <sect1 id="libpq-notify">
<!--
  <title>Asynchronous Notification</title>
-->
<title>非同期通知</title>

  <indexterm zone="libpq-notify">
   <primary>NOTIFY</primary>
   <secondary>in libpq</secondary>
  </indexterm>
  <indexterm zone="libpq-notify">
   <primary>NOTIFY</primary>
   <secondary>libpqにおける</secondary>
  </indexterm>

  <para>
<!--
   <productname>PostgreSQL</productname> offers asynchronous notification
   via the <command>LISTEN</command> and <command>NOTIFY</command>
   commands.  A client session registers its interest in a particular
   notification channel with the <command>LISTEN</command> command (and
   can stop listening with the <command>UNLISTEN</command> command).  All
   sessions listening on a particular channel will be notified
   asynchronously when a <command>NOTIFY</command> command with that
   channel name is executed by any session. A <quote>payload</quote> string can
   be passed to communicate additional data to the listeners.
-->
<productname>PostgreSQL</productname>は、<command>LISTEN</command>と<command>NOTIFY</command>コマンドを使用した、非同期通知をサポートします。
クライアントセッションは、<command>LISTEN</command>コマンドを使用して処理対象とする特定の通知チャネルを登録します。
（通知監視を取り止めるには<command>UNLISTEN</command>コマンドを使用します。）
任意のセッションでそのチャネル名による<command>NOTIFY</command>コマンドが実行されると、特定チャネルを監視しているすべてのセッションは非同期に通知を受け取ります。
監視者に追加データを通信するために<quote>ペイロード</quote>文字列を渡すことができます。
  </para>

  <para>
<!--
   <application>libpq</application> applications submit
   <command>LISTEN</command>, <command>UNLISTEN</command>,
   and <command>NOTIFY</command> commands as
   ordinary SQL commands.  The arrival of <command>NOTIFY</command>
   messages can subsequently be detected by calling
   <function id="libpq-PQnotifies">PQnotifies</function>.<indexterm><primary>PQnotifies</primary></indexterm>
-->
<application>libpq</application>アプリケーションは、通常のSQLによる問い合わせと同じように<command>LISTEN</command>、<command>UNLISTEN</command>および<command>NOTIFY</command>コマンドを発行することができます。
<command>NOTIFY</command>メッセージの到着は、続いて<function id="libpq-PQnotifies">PQnotifies</function>.<indexterm><primary>PQnotifies</primary></indexterm>を呼び出せば検出できます。
  </para>

  <para>
<!--
   The function <function>PQnotifies</function> returns the next notification
   from a list of unhandled notification messages received from the server.
   It returns a null pointer if there are no pending notifications.  Once a
   notification is returned from <function>PQnotifies</function>, it is considered
   handled and will be removed from the list of notifications.
-->
<function>PQnotifies</function>関数は、サーバから受信した通知メッセージの未処理リストから次の通知を返します。
保留中の通知がなくなればヌルポインタを返します。
<function>PQnotifies</function>が通知を返すと、その通知は処理済みとみなされ、通知リストから取り除かれます。

<synopsis>
PGnotify *PQnotifies(PGconn *conn);

typedef struct pgNotify
{
<!--
    char *relname;              /* notification channel name */
    int  be_pid;                /* process ID of notifying server process */
    char *extra;                /* notification payload string */
-->
    char *relname;              /* 通知チャネル名 */
    int  be_pid;                /* 通知元サーバプロセスのプロセスID */
    char *extra;                /* 通知ペイロード文字列 */
} PGnotify;
</synopsis>

<!--
   After processing a <structname>PGnotify</structname> object returned
   by <function>PQnotifies</function>, be sure to free it with
   <xref linkend="libpq-PQfreemem"/>.  It is sufficient to free the
   <structname>PGnotify</structname> pointer; the
   <structfield>relname</structfield> and <structfield>extra</structfield>
   fields do not represent separate allocations.  (The names of these fields
   are historical; in particular, channel names need not have anything to
   do with relation names.)
-->
<function>PQnotifies</function>で返された<structname>PGnotify</structname>オブジェクトの処理が終わったら、<function>PQfreemem</function>を使用して確実に解放してください。
<structname>PGnotify</structname>ポインタを解放することは重要です。
<structfield>relname</structfield>と<structfield>extra</structfield>フィールドは別の割り当てを表していません。
(これらのフィールド名は歴史的なものです。特にチャネル名はリレーション名と関係するものである必要はありません。)
  </para>

  <para>
<!--
   <xref linkend="libpq-example-2"/> gives a sample program that illustrates
   the use of asynchronous notification.
-->
<xref linkend="libpq-example-2"/>で非同期通知を使用したサンプルプログラムを示しています。
  </para>

  <para>
<!--
   <function>PQnotifies</function> does not actually read data from the
   server; it just returns messages previously absorbed by another
   <application>libpq</application> function.  In ancient releases of
   <application>libpq</application>, the only way to ensure timely receipt
   of <command>NOTIFY</command> messages was to constantly submit commands, even
   empty ones, and then check <function>PQnotifies</function> after each
   <xref linkend="libpq-PQexec"/>.  While this still works, it is deprecated
   as a waste of processing power.
-->
<function>PQnotifies</function>は実際にサーバのデータを読み出すわけではありません。
これは単に、他の<application>libpq</application>関数が吸収してしまっていた通知メッセージを返すだけです。
<application>libpq</application>の古いリリースでは、<command>NOTIFY</command>メッセージを適切な時点で確実に受け取るには、空の問い合わせでも何でも、とにかく一定時間ごとに問い合わせを送り、そして<xref linkend="libpq-PQexec"/>を実行するたびに<function>PQnotifies</function>を検査するしかありませんでした。
今でもこの方法は動作しますが、処理能力の無駄使いをすることになるのでやめておくべきでしょう。
  </para>

  <para>
<!--
   A better way to check for <command>NOTIFY</command> messages when you have no
   useful commands to execute is to call
   <xref linkend="libpq-PQconsumeInput"/>, then check
   <function>PQnotifies</function>.  You can use
   <function>select()</function> to wait for data to arrive from the
   server, thereby using no <acronym>CPU</acronym> power unless there is
   something to do.  (See <xref linkend="libpq-PQsocket"/> to obtain the file
   descriptor number to use with <function>select()</function>.) Note that
   this will work OK whether you submit commands with
   <xref linkend="libpq-PQsendQuery"/>/<xref linkend="libpq-PQgetResult"/> or
   simply use <xref linkend="libpq-PQexec"/>.  You should, however, remember
   to check <function>PQnotifies</function> after each
   <xref linkend="libpq-PQgetResult"/> or <xref linkend="libpq-PQexec"/>, to
   see if any notifications came in during the processing of the command.
-->
実行すべき問い合わせがない時に<command>NOTIFY</command>メッセージを検査するよい方法は、まず<xref linkend="libpq-PQconsumeInput"/>を呼び出し、それから<function>PQnotifies</function>を検査することです。
サーバからのデータの到着を<function>select()</function>で待つことができ、不必要な動作で<acronym>CPU</acronym>パワーを消費してしまうことがありません。
（<function>select()</function>で使用するファイル記述子番号の取得については、<xref linkend="libpq-PQsocket"/>を参照してください。）
なお、これは問い合わせに<xref linkend="libpq-PQsendQuery"/>と<xref linkend="libpq-PQgetResult"/>を使った時でも、またはおなじみの<xref linkend="libpq-PQexec"/>を使った時でも動作します。
しかし通知がコマンドの処理中に届いていないかどうか、<xref linkend="libpq-PQgetResult"/>あるいは<xref linkend="libpq-PQexec"/>の実行ごとに<function>PQnotifies</function>を調べることを忘れないようにしておくべきです。
  </para>

 </sect1>

 <sect1 id="libpq-copy">
<!--
  <title>Functions Associated with the <command>COPY</command> Command</title>
-->
<title><command>COPY</command>コマンド関連関数</title>

  <indexterm zone="libpq-copy">
   <primary>COPY</primary>
   <secondary>with libpq</secondary>
  </indexterm>
  <indexterm zone="libpq-copy">
   <primary>COPY</primary>
   <secondary>libpqを使用した</secondary>
  </indexterm>

  <para>
<!--
   The <command>COPY</command> command in
   <productname>PostgreSQL</productname> has options to read from or write
   to the network connection used by <application>libpq</application>.
   The functions described in this section allow applications to take
   advantage of this capability by supplying or consuming copied data.
-->
<productname>PostgreSQL</productname>の<command>COPY</command>コマンドでは、<application>libpq</application>が使っているネットワーク接続に対して読み込み、あるいは書き込みを選ぶことができるようになっています。
本節で説明する関数により、アプリケーションはコピーするデータの提供やコピーされるデータの使用が可能になるという利点を持ちます。
  </para>

  <para>
<!--
   The overall process is that the application first issues the SQL
   <command>COPY</command> command via <xref linkend="libpq-PQexec"/> or one
   of the equivalent functions.  The response to this (if there is no
   error in the command) will be a <structname>PGresult</structname> object bearing
   a status code of <literal>PGRES_COPY_OUT</literal> or
   <literal>PGRES_COPY_IN</literal> (depending on the specified copy
   direction).  The application should then use the functions of this
   section to receive or transmit data rows.  When the data transfer is
   complete, another <structname>PGresult</structname> object is returned to indicate
   success or failure of the transfer.  Its status will be
   <literal>PGRES_COMMAND_OK</literal> for success or
   <literal>PGRES_FATAL_ERROR</literal> if some problem was encountered.
   At this point further SQL commands can be issued via
   <xref linkend="libpq-PQexec"/>.  (It is not possible to execute other SQL
   commands using the same connection while the <command>COPY</command>
   operation is in progress.)
-->
全体的な処理として、アプリケーションはまず<xref linkend="libpq-PQexec"/>もしくは同等な関数経由で<command>COPY</command> SQLコマンドを発行します。
（コマンドでエラーが発生しなければ）この応答は、（指定したコピーの方向に応じて）<literal>PGRES_COPY_OUT</literal>もしくは<literal>PGRES_COPY_IN</literal>という状態コードを持った<structname>PGresult</structname>になります。
その後、アプリケーションは本節の関数を使用して、行データを受信、もしくは、送信しなければなりません。
データの転送が完了した時、転送に成功したか失敗したかを示す別の<structname>PGresult</structname>オブジェクトが返されます。
その状態は、成功時には<literal>PGRES_COMMAND_OK</literal>になり、何らかの問題が起きていた時には <literal>PGRES_FATAL_ERROR</literal>になります。
この時点で、別のSQLコマンドを<xref linkend="libpq-PQexec"/>経由で発行することができます。
（<command>COPY</command>操作の実行中は、同じ接続を使用して他のSQLコマンドを実行することはできません。）
  </para>

  <para>
<!--
   If a <command>COPY</command> command is issued via
   <xref linkend="libpq-PQexec"/> in a string that could contain additional
   commands, the application must continue fetching results via
   <xref linkend="libpq-PQgetResult"/> after completing the <command>COPY</command>
   sequence.  Only when <xref linkend="libpq-PQgetResult"/> returns
   <symbol>NULL</symbol> is it certain that the <xref linkend="libpq-PQexec"/>
   command string is done and it is safe to issue more commands.
-->
<command>COPY</command>コマンドが、他にもコマンドを含んだ文字列として<xref linkend="libpq-PQexec"/>経由で発行された場合、アプリケーションは<command>COPY</command>処理を終えた後に、<xref linkend="libpq-PQgetResult"/>経由で結果の取り出しを続けなければなりません。
<xref linkend="libpq-PQexec"/>コマンド文字列が完了し、その後のコマンドが安全に発行できることが確実になるのは、<xref linkend="libpq-PQgetResult"/>が<symbol>NULL</symbol>を返す時のみです。
  </para>

  <para>
<!--
   The functions of this section should be executed only after obtaining
   a result status of <literal>PGRES_COPY_OUT</literal> or
   <literal>PGRES_COPY_IN</literal> from <xref linkend="libpq-PQexec"/> or
   <xref linkend="libpq-PQgetResult"/>.
-->
本節の関数は、<xref linkend="libpq-PQexec"/>もしくは<xref linkend="libpq-PQgetResult"/>から<literal>PGRES_COPY_OUT</literal>もしくは<literal>PGRES_COPY_IN</literal>という結果状態を得た後のみに実行されなければなりません。
  </para>

  <para>
<!--
   A <structname>PGresult</structname> object bearing one of these status values
   carries some additional data about the <command>COPY</command> operation
   that is starting.  This additional data is available using functions
   that are also used in connection with query results:
-->
これらの状態値の一つを持つ<structname>PGresult</structname>オブジェクトは、開始した<command>COPY</command>操作に関する追加データを持ちます。
この追加データは、以下の問い合わせ結果を持つ接続で使用される関数を使用して利用することができます。

   <variablelist>
    <varlistentry id="libpq-PQnfields-1">
     <term><function>PQnfields</function><indexterm
     ><primary>PQnfields</primary><secondary>with COPY</secondary></indexterm></term>

     <listitem>
      <para>
<!--
       Returns the number of columns (fields) to be copied.
-->
コピーされる列(フィールド)数を返します。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQbinaryTuples-1">
     <term><function>PQbinaryTuples</function><indexterm
     ><primary>PQbinaryTuples</primary><secondary>with COPY</secondary></indexterm></term>

     <listitem>
      <para>
<!--
       0 indicates the overall copy format is textual (rows separated by
       newlines, columns separated by separator characters, etc).  1
       indicates the overall copy format is binary.  See <xref
       linkend="sql-copy"/> for more information.
-->
0は、コピー全体の書式がテキスト(改行で区切られた行、区切り文字で区切られた列など)であることを示します。
1は、コピー全体の書式がバイナリであることを示します。
詳細は<xref linkend="sql-copy"/>を参照してください。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQfformat-1">
     <term><function>PQfformat</function><indexterm
     ><primary>PQfformat</primary><secondary>with COPY</secondary></indexterm></term>

     <listitem>
      <para>
<!--
       Returns the format code (0 for text, 1 for binary) associated with
       each column of the copy operation.  The per-column format codes
       will always be zero when the overall copy format is textual, but
       the binary format can support both text and binary columns.
       (However, as of the current implementation of <command>COPY</command>,
       only binary columns appear in a binary copy; so the per-column
       formats always match the overall format at present.)
-->
コピー操作対象の列それぞれに関した書式コード(テキストでは0、バイナリでは1)を返します。
コピー全体の書式がテキストの場合は、列単位の書式コードは常にゼロです。
しかし、バイナリ書式はテキスト列もバイナリ列もサポートすることができます。
(しかし、現在の<command>COPY</command>実装では、バイナリコピーでのみバイナリ列が発生します。
そのため、今の所列単位の書式は常に全体の書式と一致します。)
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

  <note>
   <para>
<!--
    These additional data values are only available when using protocol
    3.0.  When using protocol 2.0, all these functions will return 0.
-->
これらの追加データ値はプロトコル3.0を使用した場合にのみ利用可能です。
プロトコル2.0を使用する場合は、これらの関数はすべて0を返します。
   </para>
  </note>

  <sect2 id="libpq-copy-send">
<!--
   <title>Functions for Sending <command>COPY</command> Data</title>
-->
   <title><command>COPY</command>データ送信用関数</title>

   <para>
<!--
    These functions are used to send data during <literal>COPY FROM
    STDIN</literal>.  They will fail if called when the connection is not in
    <literal>COPY_IN</literal> state.
-->
これらの関数は、<literal>COPY FROM STDIN</literal>期間にデータを送信するために使用されます。
接続が<literal>COPY_IN</literal>状態でない時に呼び出された場合、これらは失敗します。
   </para>

   <variablelist>
    <varlistentry id="libpq-PQputCopyData">
     <term><function>PQputCopyData</function><indexterm><primary>PQputCopyData</primary></indexterm></term>

     <listitem>
      <para>
<!--
       Sends data to the server during <literal>COPY_IN</literal> state.
-->
<literal>COPY_IN</literal>状態の間、サーバにデータを送信します。
<synopsis>
int PQputCopyData(PGconn *conn,
                  const char *buffer,
                  int nbytes);
</synopsis>
      </para>

      <para>
<!--
       Transmits the <command>COPY</command> data in the specified
       <parameter>buffer</parameter>, of length <parameter>nbytes</parameter>, to the server.
       The result is 1 if the data was queued, zero if it was not queued
       because of full buffers (this will only happen in nonblocking mode),
       or -1 if an error occurred.
       (Use <xref linkend="libpq-PQerrorMessage"/> to retrieve details if
       the return value is -1.  If the value is zero, wait for write-ready
       and try again.)
-->
指定した<parameter>buffer</parameter>にある<command>COPY</command>データを<parameter>nbytes</parameter>長分、サーバに送信します。
データがキューに入れられた場合、この結果は1になります。
バッファが一杯でキューに入らなかった場合はゼロになります。
（これは、接続が非ブロックモードの場合にのみ起こります。）
エラーが発生した場合は-1になります。
（戻り値が-1の場合、詳細を取り出すためには<xref linkend="libpq-PQerrorMessage"/>を使用してください。
戻り値がゼロの場合は書き込み準備が整うまで待ち、再実行してください。）
      </para>

      <para>
<!--
       The application can divide the <command>COPY</command> data stream
       into buffer loads of any convenient size.  Buffer-load boundaries
       have no semantic significance when sending.  The contents of the
       data stream must match the data format expected by the
       <command>COPY</command> command; see <xref linkend="sql-copy"/> for details.
-->
アプリケーションは<command>COPY</command>データストリームを使いやすい大きさのバッファに分けて読み込むことができます。
送信時の読み込みバッファの境界には意味的な重要性はありません。
データストリームの内容は、<command>COPY</command>コマンドで想定しているデータ書式に一致している必要があります。
詳細は<xref linkend="sql-copy"/>を参照してください。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQputCopyEnd">
     <term><function>PQputCopyEnd</function><indexterm><primary>PQputCopyEnd</primary></indexterm></term>

     <listitem>
      <para>
<!--
       Sends end-of-data indication to the server during <literal>COPY_IN</literal> state.
-->
<literal>COPY_IN</literal>状態の間に、サーバにデータ終了指示を送信します。
<synopsis>
int PQputCopyEnd(PGconn *conn,
                 const char *errormsg);
</synopsis>
      </para>

      <para>
<!--
       Ends the <literal>COPY_IN</literal> operation successfully if
       <parameter>errormsg</parameter> is <symbol>NULL</symbol>.  If
       <parameter>errormsg</parameter> is not <symbol>NULL</symbol> then the
       <command>COPY</command> is forced to fail, with the string pointed to by
       <parameter>errormsg</parameter> used as the error message.  (One should not
       assume that this exact error message will come back from the server,
       however, as the server might have already failed the
       <command>COPY</command> for its own reasons.  Also note that the option
       to force failure does not work when using pre-3.0-protocol
       connections.)
-->
<parameter>errormsg</parameter>が<symbol>NULL</symbol>の場合は、<literal>COPY_IN</literal>操作の終了に成功しました。
<parameter>errormsg</parameter>が<symbol>NULL</symbol>でない場合は、<command>COPY</command>は強制的に失敗させられました。
<parameter>errormsg</parameter>が指し示す文字列はエラーメッセージとして使用されます。
（しかし、このエラーメッセージが正しくサーバから返ったものであるとは仮定すべきではありません。
サーバは既に別の原因で<command>COPY</command>に失敗していた可能性があります。
また、この強制的な失敗は3.0より前のプロトコルの接続を使用している場合は動作しません。）
      </para>

      <para>
<!--
       The result is 1 if the termination message was sent; or in
       nonblocking mode, this may only indicate that the termination
       message was successfully queued.  (In nonblocking mode, to be
       certain that the data has been sent, you should next wait for
       write-ready and call <xref linkend="libpq-PQflush"/>, repeating until it
       returns zero.)  Zero indicates that the function could not queue
       the termination message because of full buffers; this will only
       happen in nonblocking mode.  (In this case, wait for
       write-ready and try the <xref linkend="libpq-PQputCopyEnd"/> call
       again.)  If a hard error occurs, -1 is returned; you can use
       <xref linkend="libpq-PQerrorMessage"/> to retrieve details.
-->
終端メッセージが送信された場合は結果は1になります。
非ブロックモードでは、終端メッセージがキューに入れられたことしか意味しないかもしれません。
（非ブロックモードでデータが送信されたことを確認するには、次に書き込み準備ができるまで待ち、<xref linkend="libpq-PQflush"/>を呼ぶことを、それが0を返すまでくり返します。）
バッファが一杯で終端メッセージがキューに入れられなかった場合はゼロになります。
これは、接続が非ブロックモードの場合にのみ起こります。
（この場合、書き込み準備ができるまで待ち、再度<xref linkend="libpq-PQputCopyEnd"/>を呼び出してみてください。）
ハードエラーが発生した場合は-1になります。
このとき、詳細を取得するために<xref linkend="libpq-PQerrorMessage"/>を使用できます。
      </para>

      <para>
<!--
       After successfully calling <xref linkend="libpq-PQputCopyEnd"/>, call
       <xref linkend="libpq-PQgetResult"/> to obtain the final result status of the
       <command>COPY</command> command.  One can wait for this result to be
       available in the usual way.  Then return to normal operation.
-->
<xref linkend="libpq-PQputCopyEnd"/>の呼び出しに成功した後、<xref linkend="libpq-PQgetResult"/>を呼び出して<command>COPY</command>コマンドの最終的な結果状態を取り出してください。
通常の方法でこの結果が使用できるようになるまで待機しても構いません。
そして、通常の操作に戻ってください。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>

  </sect2>

  <sect2 id="libpq-copy-receive">
<!--
   <title>Functions for Receiving <command>COPY</command> Data</title>
-->
   <title><command>COPY</command>データ受信用関数</title>

   <para>
<!--
    These functions are used to receive data during <literal>COPY TO
    STDOUT</literal>.  They will fail if called when the connection is not in
    <literal>COPY_OUT</literal> state.
-->
これらの関数は<literal>COPY TO STDOUT</literal>時にデータを受信するために使用されます。
<literal>COPY_OUT</literal>状態以外の接続で呼び出すと、失敗します。
   </para>

   <variablelist>
    <varlistentry id="libpq-PQgetCopyData">
     <term><function>PQgetCopyData</function><indexterm><primary>PQgetCopyData</primary></indexterm></term>

     <listitem>
      <para>
<!--
       Receives data from the server during <literal>COPY_OUT</literal> state.
-->
<literal>COPY_OUT</literal>状態時にサーバからデータを受信します。

<synopsis>
int PQgetCopyData(PGconn *conn,
                  char **buffer,
                  int async);
</synopsis>
      </para>

      <para>
<!--
       Attempts to obtain another row of data from the server during a
       <command>COPY</command>.  Data is always returned one data row at
       a time; if only a partial row is available, it is not returned.
       Successful return of a data row involves allocating a chunk of
       memory to hold the data.  The <parameter>buffer</parameter> parameter must
       be non-<symbol>NULL</symbol>.  <parameter>*buffer</parameter> is set to
       point to the allocated memory, or to <symbol>NULL</symbol> in cases
       where no buffer is returned.  A non-<symbol>NULL</symbol> result
       buffer should be freed using <xref linkend="libpq-PQfreemem"/> when no longer
       needed.
-->
<command>COPY</command>期間中、サーバから別の行データの入手を試みます。
常に1度に1つの行データが返されます。
部分的な行のみが利用可能な場合は返されません。
行データの取得に成功することは、そのデータを保持するためのメモリチャンクの割り当てを意味します。
<parameter>buffer</parameter>パラメータは非<symbol>NULL</symbol>でなければなりません。
<parameter>*buffer</parameter>は割り当てられたメモリへのポインタに、バッファが返されなかった場合は<symbol>NULL</symbol>に設定されます。
非<symbol>NULL</symbol>の結果バッファは、不要になったら<xref linkend="libpq-PQfreemem"/>を使用して解放しなければなりません。
      </para>

      <para>
<!--
       When a row is successfully returned, the return value is the number
       of data bytes in the row (this will always be greater than zero).
       The returned string is always null-terminated, though this is
       probably only useful for textual <command>COPY</command>.  A result
       of zero indicates that the <command>COPY</command> is still in
       progress, but no row is yet available (this is only possible when
       <parameter>async</parameter> is true).  A result of -1 indicates that the
       <command>COPY</command> is done.  A result of -2 indicates that an
       error occurred (consult <xref linkend="libpq-PQerrorMessage"/> for the reason).
-->
行の取り込みに成功した時、戻り値は行内のデータのバイト数になります。
(これは常に0より大きくなります。)
返された文字列は常にヌル終端ですが、おそらくテキスト<command>COPY</command>でのみ有用になるでしょう。
ゼロという結果は、<command>COPY</command>が進行中で、行がまだ利用できない状態であることを示します。
(<parameter>async</parameter>が真の場合にのみ発生することがあります。)
-1という結果は、<command>COPY</command>が完了したことを示します。
-2という結果はエラーが発生したことを示します。
(その理由については<xref linkend="libpq-PQerrorMessage"/>を参照してください。)
      </para>

      <para>
<!--
       When <parameter>async</parameter> is true (not zero),
       <xref linkend="libpq-PQgetCopyData"/> will not block waiting for input; it
       will return zero if the <command>COPY</command> is still in progress
       but no complete row is available.  (In this case wait for read-ready
       and then call <xref linkend="libpq-PQconsumeInput"/> before calling
       <xref linkend="libpq-PQgetCopyData"/> again.)  When <parameter>async</parameter> is
       false (zero), <xref linkend="libpq-PQgetCopyData"/> will block until data is
       available or the operation completes.
-->
<parameter>async</parameter>が真(非0)の場合、<xref linkend="libpq-PQgetCopyData"/>は入力待ちのためのブロックを行いません。
<command>COPY</command>実行中で完全な行を取り出せない場合<xref linkend="libpq-PQgetCopyData"/>は0を返します。
(この場合、再試行の前に読み込み準備が整うまで待機してください。
<xref linkend="libpq-PQconsumeInput"/>を呼び出したかどうかは関係ありません。)
<parameter>async</parameter>が偽(0)の場合、<xref linkend="libpq-PQgetCopyData"/>はデータが利用できるようになるまで、もしくは、操作が完了するまでブロックします。
      </para>

      <para>
<!--
       After <xref linkend="libpq-PQgetCopyData"/> returns -1, call
       <xref linkend="libpq-PQgetResult"/> to obtain the final result status of the
       <command>COPY</command> command.  One can wait for this result to be
       available in the usual way.  Then return to normal operation.
-->
<xref linkend="libpq-PQgetCopyData"/>が-1を返した後、<xref linkend="libpq-PQgetResult"/>を呼び出して、<command>COPY</command>コマンドの最終結果状態を取り出してください。
通常の方法で結果が利用できるようになるまで待機しても構いません。
そして、通常の操作に戻ってください。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>

  </sect2>

  <sect2 id="libpq-copy-deprecated">
<!--
   <title>Obsolete Functions for <command>COPY</command></title>
-->
   <title>廃れた<command>COPY</command>用関数</title>

   <para>
<!--
    These functions represent older methods of handling <command>COPY</command>.
    Although they still work, they are deprecated due to poor error handling,
    inconvenient methods of detecting end-of-data, and lack of support for binary
    or nonblocking transfers.
-->
以下の関数は<command>COPY</command>を取扱う、古めの手法を行います。
これらはまだ動作しますが、エラーの取扱いが貧弱であることやデータの終端を検知する方法が不便であることより使用を奨めません。
   </para>

   <variablelist>
    <varlistentry id="libpq-PQgetline">
     <term><function>PQgetline</function><indexterm><primary>PQgetline</primary></indexterm></term>

     <listitem>
      <para>
<!--
       Reads  a  newline-terminated  line  of  characters (transmitted
       by the server) into a buffer string of size <parameter>length</parameter>.
-->
改行で終端する文字列（サーバから送信されたもの）を長さ<parameter>length</parameter>のバッファ用文字列に読み込みます。
<synopsis>
int PQgetline(PGconn *conn,
              char *buffer,
              int length);
</synopsis>
      </para>

      <para>
<!--
       This function copies up to <parameter>length</parameter>-1 characters into
       the buffer and converts the terminating newline into a zero byte.
       <xref linkend="libpq-PQgetline"/> returns <symbol>EOF</symbol> at the
       end of input, 0 if the entire line has been read, and 1 if the
       buffer is full but the terminating newline has not yet been read.
-->
この関数はバッファに<parameter>length</parameter>-1個までの文字をコピーし、終端の改行を1バイトのゼロに置き換えます。
<xref linkend="libpq-PQgetline"/>は、入力の終端では<symbol>EOF</symbol>を、行全体が読み込まれれば0を返します。
そしてまだ終端の改行が読み込まれていないうちにバッファがいっぱいになってしまった場合は1を返します。
       </para>
       <para>
<!--
       Note that the application must check to see if a new line consists
       of  the  two characters  <literal>\.</literal>, which  indicates
       that the server has finished sending the results  of  the
       <command>COPY</command> command.  If  the  application might receive
       lines that are more than <parameter>length</parameter>-1  characters  long,
       care is needed to be sure it recognizes the <literal>\.</literal>
       line correctly (and does not, for example, mistake the end of a
       long data line for a terminator line).
-->
アプリケーションは新しく読み込んだ行が、<literal>\.</literal>という2文字であるかどうか確認しなければいけません。
この2文字は、<command>COPY</command>コマンドの結果をサーバが送信し終えたことを示すものです。
アプリケーションには、仮に<parameter>length</parameter>-1文字より長い行を受け取るようなことがあっても、間違いなく<literal>\.</literal>行を認識するような配慮が必要です
（また例えば長いデータの行の終端を、最終行と取り違えないようにもしてください）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQgetlineAsync">
     <term><function>PQgetlineAsync</function><indexterm><primary>PQgetlineAsync</primary></indexterm></term>

     <listitem>
      <para>
<!--
       Reads a row of <command>COPY</command> data (transmitted  by the
       server) into a buffer without blocking.
-->
<command>COPY</command>データ行（サーバから送信されたもの）を、ブロッキングなしでバッファに読み込みます。
<synopsis>
int PQgetlineAsync(PGconn *conn,
                   char *buffer,
                   int bufsize);
</synopsis>
      </para>

      <para>
<!--
       This function is similar to <xref linkend="libpq-PQgetline"/>, but it can be used
       by applications
       that must read <command>COPY</command> data asynchronously, that is, without blocking.
       Having issued the <command>COPY</command> command and gotten a <literal>PGRES_COPY_OUT</literal>
       response, the
       application should call <xref linkend="libpq-PQconsumeInput"/> and
       <xref linkend="libpq-PQgetlineAsync"/> until the
       end-of-data signal is detected.
-->
<xref linkend="libpq-PQgetline"/>と似ていますが、<command>COPY</command>のデータを非同期的に、つまりブロッキングなしで読み出さなければならないアプリケーションで使用することができます。
<command>COPY</command>コマンドを発行し、そして<literal>PGRES_COPY_OUT</literal>応答を受け取ったら、アプリケーションはデータ終了の合図を受け取るまで<xref linkend="libpq-PQconsumeInput"/>と<xref linkend="libpq-PQgetlineAsync"/>を呼び出します。
       </para>
       <para>
<!--
       Unlike <xref linkend="libpq-PQgetline"/>, this function takes
       responsibility for detecting end-of-data.
-->
<xref linkend="libpq-PQgetline"/>と違い、この関数はデータ終了の検出に対して責任を持ちます。
      </para>

      <para>
<!--
       On each call, <xref linkend="libpq-PQgetlineAsync"/> will return data if a
       complete data row is available in <application>libpq</application>'s input buffer.
       Otherwise, no data is returned until the rest of the row arrives.
       The function returns -1 if the end-of-copy-data marker has been recognized,
       or 0 if no data is available, or a positive number giving the number of
       bytes of data returned.  If -1 is returned, the caller must next call
       <xref linkend="libpq-PQendcopy"/>, and then return to normal processing.
-->
<xref linkend="libpq-PQgetlineAsync"/>の個々の呼び出しでは、<application>libpq</application>の入力バッファ内で完全な行データが利用できる場合にデータを返します。
さもなければ、行の残りが届くまでデータは返されません。
この関数は、コピーデータの終端を示す符号を認識すると-1を、また何もデータがなければ0を、そしてデータを返す場合はそのバイト数を正の値で返します。
もし-1が返されたら、呼び出し側は次に<xref linkend="libpq-PQendcopy"/>を呼び出さなければいけません。
それから通常の処理に戻ります。
      </para>

      <para>
<!--
       The data returned will not extend beyond a data-row boundary.  If possible
       a whole row will be returned at one time.  But if the buffer offered by
       the caller is too small to hold a row sent by the server, then a partial
       data row will be returned.  With textual data this can be detected by testing
       whether the last returned byte is <literal>\n</literal> or not.  (In a binary
       <command>COPY</command>, actual parsing of the <command>COPY</command> data format will be needed to make the
       equivalent determination.)
       The returned string is not null-terminated.  (If you want to add a
       terminating null, be sure to pass a <parameter>bufsize</parameter> one smaller
       than the room actually available.)
-->
返されるデータは行データの境界を越えて拡張されることはありません。
可能であれば行全体を一度に返します。
しかし呼び出し側が準備したバッファが少なすぎ、サーバから送られてくる行を保持しておくことができない場合には、分割された行データを返します。
テキストデータでは、これは最後の1バイトが<literal>\n</literal>かどうかを確認すれば検出できます。
（バイナリ<command>COPY</command>の場合に同様の検出を行うためには、実際に<command>COPY</command>データの書式を解析しなければなりません。）
なお、返される文字列はヌル終端ではありません。
（ヌル終端を後から付け加えるのであれば、実際に確保するバッファサイズ-1を<parameter>bufsize</parameter>として渡すようにしてください。）
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQputline">
     <term><function>PQputline</function><indexterm><primary>PQputline</primary></indexterm></term>

     <listitem>
      <para>
<!--
       Sends  a  null-terminated  string  to  the server.  Returns 0 if
       OK and <symbol>EOF</symbol> if unable to send the string.
-->
サーバにヌル終端の文字列を送信します。
問題なければ0を返します。
文字列の送信ができなかった場合は<symbol>EOF</symbol>を返します。
<synopsis>
int PQputline(PGconn *conn,
              const char *string);
</synopsis>
      </para>

      <para>
<!--
       The <command>COPY</command> data stream sent by a series of calls
       to <xref linkend="libpq-PQputline"/> has the same format as that
       returned by <xref linkend="libpq-PQgetlineAsync"/>, except that
       applications are not obliged to send exactly one data row per
       <xref linkend="libpq-PQputline"/> call; it is okay to send a partial
       line or multiple lines per call.
-->
<xref linkend="libpq-PQputline"/>の呼び出しによって送信される<command>COPY</command>データストリームは、<xref linkend="libpq-PQgetlineAsync"/>で返される書式と同じ書式を持ちます。
ただし、アプリケーションは、<xref linkend="libpq-PQputline"/>毎に正確に1つのデータ行を送信するように強制されていません。
呼び出し毎に行の一部や複数の行を送信しても問題ありません。
      </para>

      <note>
       <para>
<!--
        Before <productname>PostgreSQL</productname> protocol 3.0, it was necessary
        for the application to explicitly send the two characters
        <literal>\.</literal> as a final line to indicate to the server that it had
        finished sending <command>COPY</command> data.  While this still works, it is deprecated and the
        special meaning of <literal>\.</literal> can be expected to be removed in a
        future release.  It is sufficient to call <xref linkend="libpq-PQendcopy"/> after
        having sent the actual data.
-->
<productname>PostgreSQL</productname>プロトコル3.0より前では、アプリケーションは、サーバに対して<command>COPY</command>データの送信を完了したことを通知するために、最終の行として<literal>\.</literal>という2文字を明示的に送信する必要がありました。
これはまだ動作します。
しかし、これは廃れたものとして、<literal>\.</literal>の特殊な意味は将来のリリースで無くなることが予想されます。
実際のデータの送信完了後に<xref linkend="libpq-PQendcopy"/>を呼び出すことが重要です。
       </para>
      </note>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQputnbytes">
     <term><function>PQputnbytes</function><indexterm><primary>PQputnbytes</primary></indexterm></term>

     <listitem>
      <para>
<!--
       Sends  a  non-null-terminated  string  to  the server.  Returns
       0 if OK and <symbol>EOF</symbol> if unable to send the string.
-->
ヌル終端ではない文字列をサーバに送信します。
問題なければ0を返します。
文字列の送信ができなかった場合は<symbol>EOF</symbol>を返します。
<synopsis>
int PQputnbytes(PGconn *conn,
                const char *buffer,
                int nbytes);
</synopsis>
      </para>

      <para>
<!--
       This is exactly like <xref linkend="libpq-PQputline"/>, except that the data
       buffer need not be null-terminated since the number of bytes to send is
       specified directly.  Use this procedure when sending binary data.
-->
これはまさに<xref linkend="libpq-PQputline"/>と同様です。
ただし、直接送信バイト数を指定するため、ヌル終端である必要がありません。
バイナリデータを送信する時はこのプロシージャを使用してください。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQendcopy">
     <term><function>PQendcopy</function><indexterm><primary>PQendcopy</primary></indexterm></term>

     <listitem>
      <para>
<!--
       Synchronizes with the server.
-->
サーバと同期します。
<synopsis>
int PQendcopy(PGconn *conn);
</synopsis>
<!--
       This function waits until the  server  has  finished  the copying.
       It should either be issued when the  last  string  has  been sent
       to  the  server using <xref linkend="libpq-PQputline"/> or when the
       last string has been  received  from  the  server using
       <function>PQgetline</function>.  It must be issued or the server
       will get <quote>out of sync</quote> with  the client.   Upon return
       from this function, the server is ready to receive the next SQL
       command.  The return value is 0  on  successful  completion,
       nonzero otherwise.  (Use <xref linkend="libpq-PQerrorMessage"/> to
       retrieve details if the return value is nonzero.)
-->
この関数はサーバがコピーを完了するのを待ちます。
この関数は、<function>PQputline</function>を使ったサーバへの文字列送信が完了した時点、あるいは<function>PQgetline</function>を使ったサーバからの文字列受信が完了した時点のいずれでも呼び出さなければなりません。
これを発行しないと、サーバはクライアントとの<quote>同期がずれた</quote>状態になってしまいます。
この関数から戻った時点で、サーバは次のSQLコマンドを受ける準備が整います。
正常に終了した場合、返り値は0です。 さもなくば、非ゼロです。
（戻り値が非ゼロの場合、<function>PQerrorMessage</function>を使用して詳細を取り出してください。）
      </para>

      <para>
<!--
       When using <xref linkend="libpq-PQgetResult"/>, the application should
       respond to a <literal>PGRES_COPY_OUT</literal> result by executing
       <xref linkend="libpq-PQgetline"/> repeatedly, followed by
       <xref linkend="libpq-PQendcopy"/> after the terminator line is seen.
       It should then return to the <xref linkend="libpq-PQgetResult"/> loop
       until <xref linkend="libpq-PQgetResult"/> returns a null pointer.
       Similarly a <literal>PGRES_COPY_IN</literal> result is processed
       by a series of <xref linkend="libpq-PQputline"/> calls followed by
       <xref linkend="libpq-PQendcopy"/>, then return to the
       <xref linkend="libpq-PQgetResult"/> loop.  This arrangement will
       ensure that a <command>COPY</command> command embedded in a series
       of <acronym>SQL</acronym> commands will be executed correctly.
-->
<xref linkend="libpq-PQgetResult"/>を使う場合、アプリケーションは<xref linkend="libpq-PQgetline"/>を繰り返し呼び出して<literal>PGRES_COPY_OUT</literal>に応答し、終端行を見つけたら続いて<xref linkend="libpq-PQendcopy"/>を呼び出さなければなりません。
それから、<xref linkend="libpq-PQgetResult"/>がヌルポインタを返すまで、<xref linkend="libpq-PQgetResult"/>のループに戻らなければなりません。
同じように <literal>PGRES_COPY_IN</literal>は連続した<xref linkend="libpq-PQputline"/>で処理し、それから<xref linkend="libpq-PQendcopy"/>で締めくくった後に<xref linkend="libpq-PQgetResult"/>のループに戻ります。
このようにすることで、一連の<acronym>SQL</acronym>コマンド群に含めた<command>COPY</command>コマンドを確実に、また正しく実行できるはずです。
      </para>

      <para>
<!--
       Older applications are likely to submit a <command>COPY</command>
       via <xref linkend="libpq-PQexec"/> and assume that the transaction
       is done after <xref linkend="libpq-PQendcopy"/>.  This will work
       correctly only if the <command>COPY</command> is the only
       <acronym>SQL</acronym> command in the command string.
-->
比較的古いアプリケーションでは、<command>COPY</command>を<xref linkend="libpq-PQexec"/>で実行し、<xref linkend="libpq-PQendcopy"/>の実行でトランザクションは完了する、と想定していることがよくあります。
これはコマンド文字列中の<acronym>SQL</acronym>が<command>COPY</command>だけであった時にのみ正しく動作します。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>

  </sect2>

 </sect1>

 <sect1 id="libpq-control">
<!--
  <title>Control Functions</title>
-->
  <title>制御関数</title>

  <para>
<!--
   These functions control miscellaneous details of <application>libpq</application>'s
   behavior.
-->
これらの関数は<application>libpq</application>の動作の各種詳細を制御します。
  </para>

  <variablelist>
   <varlistentry id="libpq-PQclientEncoding">
    <term><function>PQclientEncoding</function><indexterm><primary>PQclientEncoding</primary></indexterm></term>

    <listitem>
     <para>
<!--
      Returns the client encoding.
-->
クライアント符号化方式を返します。
<synopsis>
int PQclientEncoding(const PGconn *<replaceable>conn</replaceable>);
</synopsis>

<!--
      Note that it returns the encoding ID, not a symbolic string
      such as <literal>EUC_JP</literal>. If unsuccessful, it returns -1.
      To convert an encoding ID to an encoding name, you
      can use:
-->
これが<literal>EUC_JP</literal>などのシンボル文字列ではなく符号化方式IDを返すことに注意してください。
成功しなかった場合には、-1が返ります。
符号化方式IDを符号化方式名に変換するためには以下を使用してください。

<synopsis>
char *pg_encoding_to_char(int <replaceable>encoding_id</replaceable>);
</synopsis>
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-PQsetClientEncoding">
    <term><function>PQsetClientEncoding</function><indexterm><primary>PQsetClientEncoding</primary></indexterm></term>

    <listitem>
     <para>
<!--
      Sets the client encoding.
-->
クライアント符号化方式を設定します。
<synopsis>
int PQsetClientEncoding(PGconn *<replaceable>conn</replaceable>, const char *<replaceable>encoding</replaceable>);
</synopsis>

<!--
      <replaceable>conn</replaceable> is a connection to the server,
      and <replaceable>encoding</replaceable> is the encoding you want to
      use. If the function successfully sets the encoding, it returns 0,
      otherwise -1. The current encoding for this connection can be
      determined by using <xref linkend="libpq-PQclientEncoding"/>.
-->
<replaceable>conn</replaceable>はサーバへの接続、<replaceable>encoding</replaceable>は使用したい符号化方式です。
この関数は符号化方式の設定に成功すると、ゼロを返します。
さもなくば-1を返します。
この接続における現在の符号化方式は<function>PQclientEncoding</function>を使用して決定することができます。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-PQsetErrorVerbosity">
    <term><function>PQsetErrorVerbosity</function><indexterm><primary>PQsetErrorVerbosity</primary></indexterm></term>

    <listitem>
     <para>
<!--
      Determines the verbosity of messages returned by
      <xref linkend="libpq-PQerrorMessage"/> and <xref linkend="libpq-PQresultErrorMessage"/>.
-->
<xref linkend="libpq-PQerrorMessage"/>と<xref linkend="libpq-PQresultErrorMessage"/>で返されるメッセージの冗長度を決定します。
<synopsis>
typedef enum
{
    PQERRORS_TERSE,
    PQERRORS_DEFAULT,
    PQERRORS_VERBOSE,
    PQERRORS_SQLSTATE
} PGVerbosity;

PGVerbosity PQsetErrorVerbosity(PGconn *conn, PGVerbosity verbosity);
</synopsis>

<!--
      <xref linkend="libpq-PQsetErrorVerbosity"/> sets the verbosity mode,
      returning the connection's previous setting.
      In <firstterm>TERSE</firstterm> mode, returned messages include
      severity, primary text, and position only; this will normally fit on a
      single line.  The <firstterm>DEFAULT</firstterm> mode produces messages
      that include the above plus any detail, hint, or context fields (these
      might span multiple lines).  The <firstterm>VERBOSE</firstterm> mode
      includes all available fields.  The <firstterm>SQLSTATE</firstterm>
      mode includes only the error severity and the <symbol>SQLSTATE</symbol>
      error code, if one is available (if not, the output is like
      <firstterm>TERSE</firstterm> mode).
-->
<xref linkend="libpq-PQsetErrorVerbosity"/>は冗長度モードを設定し、接続における以前の状態を返します。
<firstterm>TERSE</firstterm>モードでは、返されるメッセージには深刻度、主テキスト、位置のみが含まれます。
これは通常単一行に収まります。
<firstterm>DEFAULT</firstterm>モードでは、上に加え、詳細、ヒント、文脈フィールドが含まれるメッセージが生成されます（これは複数行に跨るかもしれません。）
<firstterm>VERBOSE</firstterm>モードでは、すべての利用可能なフィールドが含まれます。
<firstterm>SQLSTATE</firstterm>モードでは、エラーの深刻度と、利用可能であれば<symbol>SQLSTATE</symbol>エラーコードだけが含まれます(利用できなければ、出力は<firstterm>TERSE</firstterm>モードのようになります)。
     </para>

     <para>
<!--
      Changing the verbosity setting does not affect the messages available
      from already-existing <structname>PGresult</structname> objects, only
      subsequently-created ones.
      (But see <xref linkend="libpq-PQresultVerboseErrorMessage"/> if you
      want to print a previous error with a different verbosity.)
-->
冗長度の変更は、既に存在する<structname>PGresult</structname>オブジェクト内から取り出せるメッセージには影響を与えません。
その後に作成されたオブジェクトにのみ影響を与えます。
（ただし、以前のエラーを異なる冗長さで表示したい場合は<xref linkend="libpq-PQresultVerboseErrorMessage"/>を参照してください。）
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-PQsetErrorContextVisibility">
    <term><function>PQsetErrorContextVisibility</function><indexterm><primary>PQsetErrorContextVisibility</primary></indexterm></term>

    <listitem>
     <para>
<!--
      Determines the handling of <literal>CONTEXT</literal> fields in messages
      returned by <xref linkend="libpq-PQerrorMessage"/>
      and <xref linkend="libpq-PQresultErrorMessage"/>.
-->
<xref linkend="libpq-PQerrorMessage"/>および<xref linkend="libpq-PQresultErrorMessage"/>から返されるメッセージ内の<literal>CONTEXT</literal>フィールドの扱いについて決定します。
<synopsis>
typedef enum
{
    PQSHOW_CONTEXT_NEVER,
    PQSHOW_CONTEXT_ERRORS,
    PQSHOW_CONTEXT_ALWAYS
} PGContextVisibility;

PGContextVisibility PQsetErrorContextVisibility(PGconn *conn, PGContextVisibility show_context);
</synopsis>

<!--
      <xref linkend="libpq-PQsetErrorContextVisibility"/> sets the context display mode,
      returning the connection's previous setting.  This mode controls
      whether the <literal>CONTEXT</literal> field is included in messages.
      The <firstterm>NEVER</firstterm> mode
      never includes <literal>CONTEXT</literal>, while <firstterm>ALWAYS</firstterm> always
      includes it if available.  In <firstterm>ERRORS</firstterm> mode (the
      default), <literal>CONTEXT</literal> fields are included only in error
      messages, not in notices and warnings.
      (However, if the verbosity setting is <firstterm>TERSE</firstterm>
      or <firstterm>SQLSTATE</firstterm>, <literal>CONTEXT</literal> fields
      are omitted regardless of the context display mode.)
-->
<xref linkend="libpq-PQsetErrorContextVisibility"/>はコンテキストの表示モードを設定し、その接続での以前の設定を返します。
このモードはメッセージに<literal>CONTEXT</literal>フィールドが含まれるかどうかを制御します。
<firstterm>NEVER</firstterm>モードでは、決して<literal>CONTEXT</literal>を含みませんが、<firstterm>ALWAYS</firstterm>では<literal>CONTEXT</literal>が利用可能であれば常に含まれます。
<firstterm>ERRORS</firstterm>モード（デフォルト）では、<literal>CONTEXT</literal>はエラーメッセージには含まれますが、注意や警告では含まれません。
（しかしながら、冗長設定が<firstterm>TERSE</firstterm>や<firstterm>SQLSTATE</firstterm>の場合は、コンテキストの表示モードに関わらず<literal>CONTEXT</literal>フィールドは省略されます。）
     </para>

     <para>
<!--
      Changing this mode does not
      affect the messages available from
      already-existing <structname>PGresult</structname> objects, only
      subsequently-created ones.
      (But see <xref linkend="libpq-PQresultVerboseErrorMessage"/> if you
      want to print a previous error with a different display mode.)
-->
このモードを変更しても、既存の<structname>PGresult</structname>から取得可能なメッセージには影響を与えず、その後で作成されるものにのみ影響します。
（ただし、以前のエラーについて異なる表示モードで表示したい場合は、<xref linkend="libpq-PQresultVerboseErrorMessage"/>を参照してください。）
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-PQtrace">
    <term><function>PQtrace</function><indexterm><primary>PQtrace</primary></indexterm></term>

    <listitem>
     <para>
<!--
      Enables  tracing of the client/server communication to a debugging file stream.
-->
クライアント／サーバ間の通信トレースを有効にし、デバッグ用のファイルストリームに書き出します。
<synopsis>
void PQtrace(PGconn *conn, FILE *stream);
</synopsis>
     </para>

     <note>
      <para>
<!--
       On Windows, if the <application>libpq</application> library and an application are
       compiled with different flags, this function call will crash the
       application because the internal representation of the <literal>FILE</literal>
       pointers differ.  Specifically, multithreaded/single-threaded,
       release/debug, and static/dynamic flags should be the same for the
       library and all applications using that library.
-->
Windowsにおいて、<application>libpq</application>ライブラリとアプリケーションを異なるフラグでコンパイルすると、この関数呼び出しで<literal>FILE</literal>ポインタの内部表現の違いによりアプリケーションはクラッシュするでしょう。
特に、このライブラリを使用するアプリケーションでは、マルチスレッド/シングルスレッド、リリース/デバッグ、静的リンク/動的リンクに関して、ライブラリと同じフラグを使わなければなりません。
      </para>
     </note>

    </listitem>
   </varlistentry>

   <varlistentry id="libpq-PQuntrace">
    <term><function>PQuntrace</function><indexterm><primary>PQuntrace</primary></indexterm></term>

    <listitem>
     <para>
<!--
      Disables tracing started by <xref linkend="libpq-PQtrace"/>.
-->
<xref linkend="libpq-PQtrace"/>によって起動されたトレース処理を無効にします。
<synopsis>
void PQuntrace(PGconn *conn);
</synopsis>
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

 </sect1>

 <sect1 id="libpq-misc">
<!--
  <title>Miscellaneous Functions</title>
-->
<title>雑多な関数</title>

  <para>
<!--
   As always, there are some functions that just don't fit anywhere.
-->
よくあることですが、うまく分類できない関数がいくつか存在します。
  </para>

  <variablelist>
   <varlistentry id="libpq-PQfreemem">
    <term><function>PQfreemem</function><indexterm><primary>PQfreemem</primary></indexterm></term>

    <listitem>
     <para>
<!--
      Frees memory allocated by <application>libpq</application>.
-->
<application>libpq</application>が割り当てたメモリを解放します。
<synopsis>
void PQfreemem(void *ptr);
</synopsis>
     </para>

     <para>
<!--
      Frees memory allocated by <application>libpq</application>, particularly
      <xref linkend="libpq-PQescapeByteaConn"/>,
      <xref linkend="libpq-PQescapeBytea"/>,
      <xref linkend="libpq-PQunescapeBytea"/>,
      and <function>PQnotifies</function>.
      It is particularly important that this function, rather than
      <function>free()</function>, be used on Microsoft Windows.  This is because
      allocating memory in a DLL and releasing it in the application works
      only if multithreaded/single-threaded, release/debug, and static/dynamic
      flags are the same for the DLL and the application.  On non-Microsoft
      Windows platforms, this function is the same as the standard library
      function <function>free()</function>.
-->
具体的には<xref linkend="libpq-PQescapeByteaConn"/>、<xref linkend="libpq-PQescapeBytea"/>、<xref linkend="libpq-PQunescapeBytea"/>および<function>PQnotifies</function>により<application>libpq</application>が割り当てたメモリを解放します。
Microsoft Windowsにおいて<function>free()</function>ではなく、この関数を使用することが特に重要です。
DLLにおけるメモリ割り当てとアプリケーションにおけるその解放が、DLLとアプリケーションとでマルチスレッド/シングルスレッド、リリース用/デバッグ用、静的/動的フラグが同じ場合でのみ動作するためです。
Microsoft Windowsプラットフォーム以外では、この関数は標準ライブラリの<function>free()</function>関数と同じです。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-PQconninfoFree">
    <term><function>PQconninfoFree</function><indexterm><primary>PQconninfoFree</primary></indexterm></term>

    <listitem>
     <para>
<!--
      Frees the data structures allocated by
      <xref linkend="libpq-PQconndefaults"/> or <xref linkend="libpq-PQconninfoParse"/>.
-->
<xref linkend="libpq-PQconndefaults"/>もしくは<xref linkend="libpq-PQconninfoParse"/>が割り当てたデータ構造を解放します。
<synopsis>
void PQconninfoFree(PQconninfoOption *connOptions);
</synopsis>
     </para>

     <para>
<!--
      A simple <xref linkend="libpq-PQfreemem"/> will not do for this, since
      the array contains references to subsidiary strings.
-->
単純な<xref linkend="libpq-PQfreemem"/>は、配列が補助文字列への参照を含んでいることから、このためには作業しません。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-PQencryptPasswordConn">
    <term><function>PQencryptPasswordConn</function><indexterm><primary>PQencryptPasswordConn</primary></indexterm></term>

    <listitem>
     <para>
<!--
      Prepares the encrypted form of a <productname>PostgreSQL</productname> password.
-->
<productname>PostgreSQL</productname>パスワードの暗号化された形式を準備します。
<synopsis>
char *PQencryptPasswordConn(PGconn *conn, const char *passwd, const char *user, const char *algorithm);
</synopsis>
<!--
      This function is intended to be used by client applications that
      wish to send commands like <literal>ALTER USER joe PASSWORD
      'pwd'</literal>.  It is good practice not to send the original cleartext
      password in such a command, because it might be exposed in command
      logs, activity displays, and so on.  Instead, use this function to
      convert the password to encrypted form before it is sent.
-->
この関数は、<literal>ALTER USER joe PASSWORD 'pwd'</literal>のようなコマンドを送信したいクライアントアプリケーションで使用されることを意図したものです。
こうしたコマンドでは、コマンドログが活動の監視などで晒されてしまうため、元々の平文テキストでパスワードを送信しないことが推奨されています。
その代わりに、この関数を使用して送信前にパスワードを暗号化形式に変換してください。
     </para>

     <para>
<!--
      The <parameter>passwd</parameter> and <parameter>user</parameter> arguments
      are the cleartext password, and the SQL name of the user it is for.
      <parameter>algorithm</parameter> specifies the encryption algorithm
      to use to encrypt the password. Currently supported algorithms are
      <literal>md5</literal> and <literal>scram-sha-256</literal> (<literal>on</literal> and
      <literal>off</literal> are also accepted as aliases for <literal>md5</literal>, for
      compatibility with older server versions). Note that support for
      <literal>scram-sha-256</literal> was introduced in <productname>PostgreSQL</productname>
      version 10, and will not work correctly with older server versions. If
      <parameter>algorithm</parameter> is <symbol>NULL</symbol>, this function will query
      the server for the current value of the
      <xref linkend="guc-password-encryption"/> setting. That can block, and
      will fail if the current transaction is aborted, or if the connection
      is busy executing another query. If you wish to use the default
      algorithm for the server but want to avoid blocking, query
      <varname>password_encryption</varname> yourself before calling
      <xref linkend="libpq-PQencryptPasswordConn"/>, and pass that value as the
      <parameter>algorithm</parameter>.
-->
<parameter>passwd</parameter>と<parameter>user</parameter>引数は、関数が使用する平文のパスワードとそのSQL上のユーザ名です。
<parameter>algorithm</parameter>は、パスワードを暗号化するために使用する暗号化アルゴリズムを指定します。
現在サポートされているアルゴリズムは、<literal>md5</literal>と<literal>scram-sha-256</literal>です。
(古いサーババージョンとの互換性のために、<literal>md5</literal>の別名として、<literal>on</literal>と<literal>off</literal>も受け付けます。)
<literal>scram-sha-256</literal>のサポートは、<productname>PostgreSQL</productname>バージョン10で導入されたので、古いサーババージョンでは正しく動作しないことに注意してください。
<parameter>algorithm</parameter>が<symbol>NULL</symbol>なら、この関数はサーバに問合せて現在の<xref linkend="guc-password-encryption"/>設定を返します。
これは、ブロックする可能性があり、また現在のトランザクションがアボートしているか、あるいは他の問合せを実行中でビジーなら失敗します。
サーバのデフォルトアルゴリズムを使用したいが、ブロックは避けたい、という場合は、<xref linkend="libpq-PQencryptPasswordConn"/>を呼び出す前に<varname>password_encryption</varname>を自分で調べ、その値を<parameter>algorithm</parameter>に渡してください。
     </para>

     <para>
<!--
      The return value is a string allocated by <function>malloc</function>.
      The caller can assume the string doesn't contain any special characters
      that would require escaping.  Use <xref linkend="libpq-PQfreemem"/> to free the
      result when done with it. On error, returns <symbol>NULL</symbol>, and
      a suitable message is stored in the connection object.
-->
戻り値は<function>malloc</function>で割り当てられた文字列です。
呼び出し元は、その文字列にエスケープしなければならない特殊な文字列が含まれていないことを仮定することができます。
処理が終わった時に<xref linkend="libpq-PQfreemem"/>を使用して結果を解放してください。
エラーの場合に<symbol>NULL</symbol>が返され、接続オブジェクトに対応するメッセージが格納されます。
     </para>

    </listitem>
   </varlistentry>

   <varlistentry id="libpq-PQencryptPassword">
    <term><function>PQencryptPassword</function><indexterm><primary>PQencryptPassword</primary></indexterm></term>

    <listitem>
     <para>
<!--
      Prepares the md5-encrypted form of a <productname>PostgreSQL</productname> password.
-->
md5暗号化形式の<productname>PostgreSQL</productname>パスワードを準備します。
<synopsis>
char *PQencryptPassword(const char *passwd, const char *user);
</synopsis>
<!--
      <xref linkend="libpq-PQencryptPassword"/> is an older, deprecated version of
      <xref linkend="libpq-PQencryptPasswordConn"/>. The difference is that
      <xref linkend="libpq-PQencryptPassword"/> does not
      require a connection object, and <literal>md5</literal> is always used as the
      encryption algorithm.
-->
<function>PQencryptPassword</function>は、古くて非推奨のバージョンの<function>PQencryptPasswordConn</function>です。
違いは、<function>PQencryptPassword</function>はコネクションオブジェクトを必要とせず、<literal>md5</literal>が常に暗号化アルゴリズムに使用されることです。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-PQmakeEmptyPGresult">
    <term><function>PQmakeEmptyPGresult</function><indexterm><primary>PQmakeEmptyPGresult</primary></indexterm></term>

    <listitem>
     <para>
<!--
      Constructs an empty <structname>PGresult</structname> object with the given status.
-->
与えられたステータスで空の<structname>PGresult</structname>オブジェクトを構築します。
<synopsis>
PGresult *PQmakeEmptyPGresult(PGconn *conn, ExecStatusType status);
</synopsis>
     </para>

     <para>
<!--
      This is <application>libpq</application>'s internal function to allocate and
      initialize an empty <structname>PGresult</structname> object.  This
      function returns <symbol>NULL</symbol> if memory could not be allocated. It is
      exported because some applications find it useful to generate result
      objects (particularly objects with error status) themselves.  If
      <parameter>conn</parameter> is not null and <parameter>status</parameter>
      indicates an error, the current error message of the specified
      connection is copied into the <structname>PGresult</structname>.
      Also, if <parameter>conn</parameter> is not null, any event procedures
      registered in the connection are copied into the
      <structname>PGresult</structname>.  (They do not get
      <literal>PGEVT_RESULTCREATE</literal> calls, but see
      <xref linkend="libpq-PQfireResultCreateEvents"/>.)
      Note that <xref linkend="libpq-PQclear"/> should eventually be called
      on the object, just as with a <structname>PGresult</structname>
      returned by <application>libpq</application> itself.
-->
これは空の<structname>PGresult</structname>オブジェクトを割り当てて、初期化する<application>libpq</application>の内部関数です。
メモリが割り当てられなかった場合、この関数は<symbol>NULL</symbol>を返します。
一部のアプリケーションで結果オブジェクト（特にエラーステータスを伴ったオブジェクト）それ自身を生成することが便利であることが分かりましたので、外部公開されました。
<parameter>conn</parameter>が非ヌルで、<parameter>status</parameter>がエラーを示唆している場合、特定された接続の現在のエラーメッセージは<structname>PGresult</structname>にコピーされます。
同時に、<parameter>conn</parameter>が非ヌルの場合、接続で登録された任意のイベントプロシージャは<structname>PGresult</structname>にコピーされます。
（それらは<literal>PGEVT_RESULTCREATE</literal>呼び出しを受けませんが、<xref linkend="libpq-PQfireResultCreateEvents"/>を理解します。）
<application>libpq</application>自身で返された<structname>PGresult</structname>と同様に、最終的にはこのオブジェクトに対して<xref linkend="libpq-PQclear"/>を呼び出さなければならないことに注意してください。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-PQfireResultCreateEvents">
    <term><function>PQfireResultCreateEvents</function><indexterm><primary>PQfireResultCreateEvents</primary></indexterm></term>
    <listitem>
     <para>
<!--
      Fires a <literal>PGEVT_RESULTCREATE</literal> event (see <xref
      linkend="libpq-events"/>) for each event procedure registered in the
      <structname>PGresult</structname> object.  Returns non-zero for success,
      zero if any event procedure fails.
-->
<structname>PGresult</structname>オブジェクトに登録されたそれぞれのイベントプロシージャに対し、<literal>PGEVT_RESULTCREATE</literal>イベント（<xref linkend="libpq-events"/>を参照）を発行します。
イベントプロシージャが成功の場合は非ゼロ、失敗の場合はゼロを返します。

<synopsis>
int PQfireResultCreateEvents(PGconn *conn, PGresult *res);
</synopsis>
     </para>

     <para>
<!--
      The <literal>conn</literal> argument is passed through to event procedures
      but not used directly.  It can be <symbol>NULL</symbol> if the event
      procedures won't use it.
-->
<literal>conn</literal>引数はイベントプロシージャに渡されますが、直接には使用されません。
イベントプロシージャが使用しない場合は<symbol>NULL</symbol>で構いません。
     </para>

     <para>
<!--
      Event procedures that have already received a
      <literal>PGEVT_RESULTCREATE</literal> or <literal>PGEVT_RESULTCOPY</literal> event
      for this object are not fired again.
-->
このオブジェクトに対し、<literal>PGEVT_RESULTCREATE</literal>もしくは<literal>PGEVT_RESULTCOPY</literal>イベントを過去に受け取ったイベントプロシージャは再び発行されません。
     </para>

     <para>
<!--
      The main reason that this function is separate from
      <xref linkend="libpq-PQmakeEmptyPGresult"/> is that it is often appropriate
      to create a <structname>PGresult</structname> and fill it with data
      before invoking the event procedures.
-->
この関数が<xref linkend="libpq-PQmakeEmptyPGresult"/>と分離されている主たる理由は、多くの場合イベントプロシージャを呼び出す前に<structname>PGresult</structname>を作成し、データを挿入するのが適切であることによります。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-PQcopyResult">
    <term><function>PQcopyResult</function><indexterm><primary>PQcopyResult</primary></indexterm></term>

    <listitem>
     <para>
<!--
      Makes a copy of a <structname>PGresult</structname> object.  The copy is
      not linked to the source result in any way and
      <xref linkend="libpq-PQclear"/> must be called when the copy is no longer
      needed.  If the function fails, <symbol>NULL</symbol> is returned.
-->
<structname>PGresult</structname>オブジェクトのコピーを作ります。
コピーは元の結果にいかなる方法でもリンクされず、コピーが不要になった時に<xref linkend="libpq-PQclear"/>を呼び出されなければなりません。
関数が失敗すると<symbol>NULL</symbol>が返されます。

<synopsis>
PGresult *PQcopyResult(const PGresult *src, int flags);
</synopsis>
     </para>

     <para>
<!--
      This is not intended to make an exact copy.  The returned result is
      always put into <literal>PGRES_TUPLES_OK</literal> status, and does not
      copy any error message in the source.  (It does copy the command status
      string, however.)  The <parameter>flags</parameter> argument determines
      what else is copied.  It is a bitwise OR of several flags.
      <literal>PG_COPYRES_ATTRS</literal> specifies copying the source
      result's attributes (column definitions).
      <literal>PG_COPYRES_TUPLES</literal> specifies copying the source
      result's tuples.  (This implies copying the attributes, too.)
      <literal>PG_COPYRES_NOTICEHOOKS</literal> specifies
      copying the source result's notify hooks.
      <literal>PG_COPYRES_EVENTS</literal> specifies copying the source
      result's events.  (But any instance data associated with the source
      is not copied.)
-->
これは正確なコピーの作成を目的としたものではありません。
返された結果は常に<literal>PGRES_TUPLES_OK</literal>状態の中に置かれ、元の結果におけるエラーメッセージはまったくコピーされません。
（しかしコマンド状態文字列をコピーします。）
<parameter>flags</parameter>引数はその他にコピーするものがないかを決定します。
それはいくつかのフラグのビット単位のORです。
<literal>PG_COPYRES_ATTRS</literal>は元の結果の属性（列定義）のコピーを指定します。
<literal>PG_COPYRES_TUPLES</literal>は元の結果のタプルのコピーを指定します。
（これは属性もコピーされることを意味しています。）
<literal>PG_COPYRES_NOTICEHOOKS</literal>は元の結果の警告フックのコピーを指定します。
<literal>PG_COPYRES_EVENTS</literal>は元の結果イベントのコピーを指定します。
（しかし、元の結果に関連したインスタンスデータはまったくコピーされません。）
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-PQsetResultAttrs">
    <term><function>PQsetResultAttrs</function><indexterm><primary>PQsetResultAttrs</primary></indexterm></term>

    <listitem>
     <para>
<!--
      Sets the attributes of a <structname>PGresult</structname> object.
-->
<structname>PGresult</structname>オブジェクトの属性を設定します。
<synopsis>
int PQsetResultAttrs(PGresult *res, int numAttributes, PGresAttDesc *attDescs);
</synopsis>
     </para>

     <para>
<!--
      The provided <parameter>attDescs</parameter> are copied into the result.
      If the <parameter>attDescs</parameter> pointer is <symbol>NULL</symbol> or
      <parameter>numAttributes</parameter> is less than one, the request is
      ignored and the function succeeds.  If <parameter>res</parameter>
      already contains attributes, the function will fail.  If the function
      fails, the return value is zero.  If the function succeeds, the return
      value is non-zero.
-->
提供された<parameter>attDescs</parameter>は結果にコピーされます。
もし<parameter>attDescs</parameter>ポインタが<symbol>NULL</symbol>、または<parameter>numAttributes</parameter>が１未満の場合、要求は無視され、関数は成功します。
<parameter>res</parameter>が既に属性を所有している場合、関数は失敗に終わります。
関数が失敗すると、戻り値はゼロです。
関数が成功すると戻り値は非ゼロになります。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-PQsetvalue">
    <term><function>PQsetvalue</function><indexterm><primary>PQsetvalue</primary></indexterm></term>

    <listitem>
     <para>
<!--
      Sets a tuple field value of a <structname>PGresult</structname> object.
-->
<structname>PGresult</structname>オブジェクトのタプルフィールド値を設定します。
<synopsis>
int PQsetvalue(PGresult *res, int tup_num, int field_num, char *value, int len);
</synopsis>
     </para>

     <para>
<!--
      The function will automatically grow the result's internal tuples array
      as needed.  However, the <parameter>tup_num</parameter> argument must be
      less than or equal to <xref linkend="libpq-PQntuples"/>, meaning this
      function can only grow the tuples array one tuple at a time.  But any
      field of any existing tuple can be modified in any order.  If a value at
      <parameter>field_num</parameter> already exists, it will be overwritten.
      If <parameter>len</parameter> is -1 or
      <parameter>value</parameter> is <symbol>NULL</symbol>, the field value
      will be set to an SQL null value.  The
      <parameter>value</parameter> is copied into the result's private storage,
      thus is no longer needed after the function
      returns.  If the function fails, the return value is zero.  If the
      function succeeds, the return value is non-zero.
-->
必要に応じて関数は自動的に結果の内部タプル配列を肥大化させます。
しかし、<parameter>tup_num</parameter>引数は<xref linkend="libpq-PQntuples"/>と同じか、もしくは小さくなければなりません。
その意味は、この関数は一回にタプル配列を１タプル大きくさせるだけだからです。
とは言っても、存在するいかなるタプルの任意のフィールドも、順序を問わず変更できます。
もし<parameter>field_num</parameter>に値が既に存在すれば、書き換えられます。
<parameter>len</parameter>が-1、または<parameter>value</parameter>が<symbol>NULL</symbol>であれば、フィールドの値はSQLのNULLに設定されます。
<parameter>value</parameter>は結果のプライベート格納領域にコピーされるため、関数が返った後ではもう必要がなくなります。
関数が失敗すると、戻り値はゼロです。
関数が成功すると戻り値は非ゼロになります。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-PQresultAlloc">
    <term><function>PQresultAlloc</function><indexterm><primary>PQresultAlloc</primary></indexterm></term>

    <listitem>
     <para>
<!--
      Allocate subsidiary storage for a <structname>PGresult</structname> object.
-->
<structname>PGresult</structname>オブジェクトに補助ストレージを割り当てます。
<synopsis>
void *PQresultAlloc(PGresult *res, size_t nBytes);
</synopsis>
     </para>

     <para>
<!--
      Any memory allocated with this function will be freed when
      <parameter>res</parameter> is cleared.  If the function fails,
      the return value is <symbol>NULL</symbol>.  The result is
      guaranteed to be adequately aligned for any type of data,
      just as for <function>malloc</function>.
-->
<parameter>res</parameter>が消去された時、この関数で割り付けられたメモリは解放されます。
関数が失敗すると戻り値は<symbol>NULL</symbol>です。
<function>malloc</function>と同じように、どのような種類のデータでも結果は適切に整列されることが保証されています。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-PQresultMemorySize">
    <term><function>PQresultMemorySize</function><indexterm><primary>PQresultMemorySize</primary></indexterm></term>

    <listitem>
     <para>
<!--
      Retrieves the number of bytes allocated for
      a <structname>PGresult</structname> object.
-->
<structname>PGresult</structname>オブジェクトのために割り当てられたバイト数を取り出します。
<synopsis>
size_t PQresultMemorySize(const PGresult *res);
</synopsis>
     </para>

     <para>
<!--
      This value is the sum of all <function>malloc</function> requests
      associated with the <structname>PGresult</structname> object, that is,
      all the space that will be freed by <xref linkend="libpq-PQclear"/>.
      This information can be useful for managing memory consumption.
-->
この値は<structname>PGresult</structname>オブジェクトに関連する<function>malloc</function>要求すべての和、すなわち<xref linkend="libpq-PQclear"/>で解放される空間全体です。
この情報はメモリ消費を管理するのに有用でしょう。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-PQlibVersion">
    <term><function>PQlibVersion</function><indexterm
    ><primary>PQlibVersion</primary><seealso>PQserverVersion</seealso></indexterm></term>

    <listitem>
     <para>
<!--
      Return the version of <productname>libpq</productname> that is being used.
-->
使用中の<productname>libpq</productname>のバージョンを返します。
<synopsis>
int PQlibVersion(void);
</synopsis>
     </para>

     <para>
<!--
      The result of this function can be used to determine, at
      run time, whether specific functionality is available in the currently
      loaded version of libpq. The function can be used, for example,
      to determine which connection options are available in
      <xref linkend="libpq-PQconnectdb"/>.
-->
この関数の結果を使用して、現在読み込まれているバージョンのlibpqで特定の機能が利用可能かどうかを実行時に決定することができます。
例えばこの関数を使用して、<xref linkend="libpq-PQconnectdb"/>でどの接続オプションが利用できるかを確認することができます。
     </para>

     <para>
<!--
      The result is formed by multiplying the library's major version
      number by 10000 and adding the minor version number.  For example,
      version 10.1 will be returned as 100001, and version 11.0 will be
      returned as 110000.
-->
返却値の形式は、メジャーバージョン番号に10000を掛け、マイナーバージョン番号を加えたものです。
例えば、バージョン10.1では100001を返し、バージョン11.0では110000を返します。
     </para>

     <para>
<!--
      Prior to major version 10, <productname>PostgreSQL</productname> used
      three-part version numbers in which the first two parts together
      represented the major version.  For those
      versions, <xref linkend="libpq-PQlibVersion"/> uses two digits for each
      part; for example version 9.1.5 will be returned as 90105, and
      version 9.2.0 will be returned as 90200.
-->
バージョン10よりも前では、<productname>PostgreSQL</productname>では、最初の2つの部分がメジャーバージョンを表す、3つの部分からなるバージョン番号が使われていました。
これらのバージョンでは、<xref linkend="libpq-PQlibVersion"/>はそれぞれの部分に2桁の数字を使います。
たとえば、バージョン9.1.5では90105が返され、バージョン9.2.0では90200が返されます。
     </para>

     <para>
<!--
      Therefore, for purposes of determining feature compatibility,
      applications should divide the result of <xref linkend="libpq-PQlibVersion"/>
      by 100 not 10000 to determine a logical major version number.
      In all release series, only the last two digits differ between
      minor releases (bug-fix releases).
-->
ですから、機能の互換性を見極めるのが目的なら、アプリケーションは<xref linkend="libpq-PQlibVersion"/>の結果を10000ではなく、100で割り、論理的なメジャーバージョンを求めるべきです。
すべてのリリースで、最後の2桁だけがマイナーリリースで異なります。
（バグ修正リリースです。）
     </para>

     <note>

      <para>
<!--
       This function appeared in <productname>PostgreSQL</productname> version 9.1, so
       it cannot be used to detect required functionality in earlier
       versions, since calling it will create a link dependency
       on version 9.1 or later.
-->
この関数は<productname>PostgreSQL</productname>バージョン9.1で追加されました。
このため以前のバージョンにおいて要求される機能を検知するために使用することができません。
この関数の呼び出しがバージョン9.1以降とのリンク依存性を作成するためです。
      </para>
     </note>
    </listitem>
   </varlistentry>

  </variablelist>

 </sect1>

 <sect1 id="libpq-notice-processing">
<!--
  <title>Notice Processing</title>
-->
  <title>警告処理</title>

  <indexterm zone="libpq-notice-processing">
   <primary>notice processing</primary>
   <secondary>in libpq</secondary>
  </indexterm>
  <indexterm zone="libpq-notice-processing">
   <primary>警告処理</primary>
   <secondary>libpqでの</secondary>
  </indexterm>

  <para>
<!--
   Notice and warning messages generated by the server are not returned
   by the query execution functions, since they do not imply failure of
   the query.  Instead they are passed to a notice handling function, and
   execution continues normally after the handler returns.  The default
   notice handling function prints the message on
   <filename>stderr</filename>, but the application can override this
   behavior by supplying its own handling function.
-->
問い合わせ実行関数では、サーバにより生成された通知と警告メッセージは、問い合わせの失敗を意味していないので返されません。
その代わり、それらは通知処理関数に渡され、ハンドラから返った後も実行は通常通り継続します。
デフォルトの通知処理関数は<filename>stderr</filename>にメッセージを出力しますが、アプリケーションは自身の処理関数を提供することでこの動作を書き換えることができます。
  </para>

  <para>
<!--
   For historical reasons, there are two levels of notice handling, called
   the notice receiver and notice processor.  The default behavior is for
   the notice receiver to format the notice and pass a string to the notice
   processor for printing.  However, an application that chooses to provide
   its own notice receiver will typically ignore the notice processor
   layer and just do all the work in the notice receiver.
-->
歴史的理由で、通知レシーバと通知プロセッサと呼ばれる２階層の通知処理が存在します。
デフォルトの動作は、通知レシーバが通知を書式化し、出力のため通知プロセッサに文字列を渡します。
しかし、独自の通知レシーバを提供することを選んだアプリケーションでは、通常、通知プロセッサ層を無視し、すべての作業を単に通知レシーバで行います。
  </para>

  <para>
<!--
   The function <function id="libpq-PQsetNoticeReceiver">PQsetNoticeReceiver</function>
   <indexterm><primary>notice receiver</primary></indexterm>
   <indexterm><primary>PQsetNoticeReceiver</primary></indexterm> sets or
   examines the current notice receiver for a connection object.
   Similarly, <function id="libpq-PQsetNoticeProcessor">PQsetNoticeProcessor</function>
   <indexterm><primary>notice processor</primary></indexterm>
   <indexterm><primary>PQsetNoticeProcessor</primary></indexterm> sets or
   examines the current notice processor.
-->
関数<function id="libpq-PQsetNoticeReceiver">PQsetNoticeReceiver</function><indexterm><primary>通知レシーバ</primary></indexterm><indexterm><primary>PQsetNoticeReceiver</primary></indexterm>は接続オブジェクトに対し現在の通知レシーバを設定もしくは確認します。
同様に、<function id="libpq-PQsetNoticeProcessor">PQsetNoticeProcessor</function>は現在の通知プロセッサの設定もしくは確認を行います。
<indexterm><primary>通知プロセッサ</primary></indexterm><indexterm><primary>PQsetNoticeProcessor</primary></indexterm>

<synopsis>
typedef void (*PQnoticeReceiver) (void *arg, const PGresult *res);

PQnoticeReceiver
PQsetNoticeReceiver(PGconn *conn,
                    PQnoticeReceiver proc,
                    void *arg);

typedef void (*PQnoticeProcessor) (void *arg, const char *message);

PQnoticeProcessor
PQsetNoticeProcessor(PGconn *conn,
                     PQnoticeProcessor proc,
                     void *arg);
</synopsis>

<!--
   Each of these functions returns the previous notice receiver or
   processor function pointer, and sets the new value.  If you supply a
   null function pointer, no action is taken, but the current pointer is
   returned.
-->
各関数は、以前の通知レシーバもしくは通知プロセッサ用の関数へのポインタを返し、新しい値を設定します。
関数ポインタにヌルを渡した場合、何も変更されず、現在のポインタが返されるだけです。
  </para>

  <para>
<!--
   When a notice or warning message is received from the server, or
   generated internally by <application>libpq</application>, the notice
   receiver function is called.  It is passed the message in the form of
   a <symbol>PGRES_NONFATAL_ERROR</symbol>
   <structname>PGresult</structname>.  (This allows the receiver to extract
   individual fields using <xref linkend="libpq-PQresultErrorField"/>, or obtain a
   complete preformatted message using <xref linkend="libpq-PQresultErrorMessage"/>
   or <xref linkend="libpq-PQresultVerboseErrorMessage"/>.)  The same
   void pointer passed to <function>PQsetNoticeReceiver</function> is also
   passed.  (This pointer can be used to access application-specific state
   if needed.)
-->
サーバから注意/警告メッセージを受け取ると、あるいは、<application>libpq</application>内部で注意/警告メッセージが生成されると、通知レシーバ関数が呼び出されます。
<symbol>PGRES_NONFATAL_ERROR</symbol> <structname>PGresult</structname>という形でメッセージが渡されます。
（これにより、レシーバは<xref linkend="libpq-PQresultErrorField"/>を使用して個々のフィールドを取り出すことや、<xref linkend="libpq-PQresultErrorMessage"/>あるいは<xref linkend="libpq-PQresultVerboseErrorMessage"/>を使用して事前に整形された完全なメッセージを取得することができます。）
<function>PQsetNoticeReceiver</function>に渡されたvoidポインタと同じものも渡されます。
（このポインタを使用して、必要に応じてアプリケーション特有の状態にアクセスすることができます。）
  </para>

  <para>
<!--
   The default notice receiver simply extracts the message (using
   <xref linkend="libpq-PQresultErrorMessage"/>) and passes it to the notice
   processor.
-->
デフォルトの通知レシーバは単に（<xref linkend="libpq-PQresultErrorMessage"/>を使用して）メッセージを取り出し、それを通知プロセッサに渡すだけです。
  </para>

  <para>
<!--
   The notice processor is responsible for handling a notice or warning
   message given in text form.  It is passed the string text of the message
   (including a trailing newline), plus a void pointer that is the same
   one passed to <function>PQsetNoticeProcessor</function>.  (This pointer
   can be used to access application-specific state if needed.)
-->
通知プロセッサは、テキスト形式で与えられた注意/警告メッセージの取扱いに責任を持ちます。
メッセージは（最後の改行を含む）文字列テキストで渡され、更に、<function>PQsetNoticeProcessor</function>に渡したものと同じvoidポインタも渡されます。
（このポインタを使用して、必要に応じてアプリケーション特有の状態にアクセスすることができます。）
  </para>

  <para>
<!--
   The default notice processor is simply:
-->
デフォルトの通知プロセッサは以下のような単純なものです。
<programlisting>
static void
defaultNoticeProcessor(void *arg, const char *message)
{
    fprintf(stderr, "%s", message);
}
</programlisting>
  </para>

  <para>
<!--
   Once you have set a notice receiver or processor, you should expect
   that that function could be called as long as either the
   <structname>PGconn</structname> object or <structname>PGresult</structname> objects made
   from it exist.  At creation of a <structname>PGresult</structname>, the
   <structname>PGconn</structname>'s current notice handling pointers are copied
   into the <structname>PGresult</structname> for possible use by functions like
   <xref linkend="libpq-PQgetvalue"/>.
-->
一旦通知レシーバや通知プロセッサを設定したら、<structname>PGconn</structname>オブジェクトか、それから生成された<structname>PGresult</structname>オブジェクトが存在している間は、その関数が呼び出される可能性があると考えておくべきです。
<structname>PGresult</structname>の生成時には、<structname>PGconn</structname>の現在の警告処理用のポインタが、<xref linkend="libpq-PQgetvalue"/>のような関数で使用可能であるように、<structname>PGresult</structname>へコピーされます。
  </para>

 </sect1>

 <sect1 id="libpq-events">
<!--
  <title>Event System</title>
-->
  <title>イベントシステム</title>

  <para>
<!--
   <application>libpq</application>'s event system is designed to notify
   registered event handlers about interesting
   <application>libpq</application> events, such as the creation or
   destruction of <structname>PGconn</structname> and
   <structname>PGresult</structname> objects.  A principal use case is that
   this allows applications to associate their own data with a
   <structname>PGconn</structname> or <structname>PGresult</structname>
   and ensure that that data is freed at an appropriate time.
-->
<application>libpq</application>のイベントシステムは、<structname>PGconn</structname>および<structname>PGresult</structname>オブジェクトの作成と削除のような関心を引く<application>libpq</application>イベントについて登録されたイベントハンドラに通知を行うため設計されています。
主たる使用状況は、アプリケーションがそれ自身のデータを<structname>PGconn</structname>または<structname>PGresult</structname>と提携させ、データが適切な時間に解放されることを保証するものです。
  </para>

  <para>
<!--
   Each registered event handler is associated with two pieces of data,
   known to <application>libpq</application> only as opaque <literal>void *</literal>
   pointers.  There is a <firstterm>passthrough</firstterm> pointer that is provided
   by the application when the event handler is registered with a
   <structname>PGconn</structname>.  The passthrough pointer never changes for the
   life of the <structname>PGconn</structname> and all <structname>PGresult</structname>s
   generated from it; so if used, it must point to long-lived data.
   In addition there is an <firstterm>instance data</firstterm> pointer, which starts
   out <symbol>NULL</symbol> in every <structname>PGconn</structname> and <structname>PGresult</structname>.
   This pointer can be manipulated using the
   <xref linkend="libpq-PQinstanceData"/>,
   <xref linkend="libpq-PQsetInstanceData"/>,
   <xref linkend="libpq-PQresultInstanceData"/> and
   <function>PQsetResultInstanceData</function> functions.  Note that
   unlike the passthrough pointer, instance data of a <structname>PGconn</structname>
   is not automatically inherited by <structname>PGresult</structname>s created from
   it.  <application>libpq</application> does not know what passthrough
   and instance data pointers point to (if anything) and will never attempt
   to free them &mdash; that is the responsibility of the event handler.
-->
それぞれの登録されたイベントハンドラは、<application>libpq</application>からは曖昧とした<literal>void *</literal>ポインタとしてだけ知られる２つのデータの断片と提携します。
イベントハンドラが<structname>PGconn</structname>で登録された時にアプリケーションが提供する<firstterm>通過地点</firstterm>ポインタがあります。
通過地点ポインタは<structname>PGconn</structname>やそれから生成されたすべての（複数の）<structname>PGresult</structname>が有効な間決して変わることはありません。
したがって使用された場合、長期間生存しているデータを指し示します。
さらに、<firstterm>インスタンスデータ</firstterm>ポインタがあって、それはすべての<structname>PGconn</structname>と<structname>PGresult</structname>で<symbol>NULL</symbol>から開始します。
ポインタは、<xref linkend="libpq-PQinstanceData"/>、<xref linkend="libpq-PQsetInstanceData"/>、<xref linkend="libpq-PQresultInstanceData"/>および<function>PQsetResultInstanceData</function>関数を使って操作することができます。
通過地点ポインタとは異なり、<structname>PGconn</structname>のインスタンスデータはそれから作成された<structname>PGresult</structname>により自動的に継承されません。
<application>libpq</application>は通過地点とインスタンスデータポインタが（もしあったとしても）何を指し示すのか判らず、決して解放しようとは試みません。
それはイベントハンドラの責任です。
  </para>

  <sect2 id="libpq-events-types">
<!--
   <title>Event Types</title>
-->
   <title>イベントの種類</title>

   <para>
<!--
    The enum <literal>PGEventId</literal> names the types of events handled by
    the event system.  All its values have names beginning with
    <literal>PGEVT</literal>.  For each event type, there is a corresponding
    event info structure that carries the parameters passed to the event
    handlers.  The event types are:
-->
<literal>PGEventId</literal>列挙はイベントシステムにより処理されるイベントの種類に名前をつけます。
その値はすべて<literal>PGEVT</literal>で始まる名前を持っています。
それぞれのイベントの種類に対し、イベントハンドラに渡されるパラメータを運ぶ関連したイベント情報構造体があります。
イベントの種類を以下に示します。
   </para>

   <variablelist>
    <varlistentry id="libpq-pgevt-register">
     <term><literal>PGEVT_REGISTER</literal></term>
     <listitem>
      <para>
<!--
       The register event occurs when <xref linkend="libpq-PQregisterEventProc"/>
       is called.  It is the ideal time to initialize any
       <literal>instanceData</literal> an event procedure may need.  Only one
       register event will be fired per event handler per connection.  If the
       event procedure fails, the registration is aborted.
-->
登録イベントは<xref linkend="libpq-PQregisterEventProc"/>が呼ばれたとき発生します。
イベントプロシージャが必要とするかもしれない任意の<literal>instanceData</literal>を初期化するために、これは理想的な時間です。
接続毎、イベントハンドラ毎でたった１つの登録イベントが発行されます。
イベントプロシージャが失敗すると、登録は中止されます。

<synopsis>
typedef struct
{
    PGconn *conn;
} PGEventRegister;
</synopsis>

<!--
       When a <literal>PGEVT_REGISTER</literal> event is received, the
       <parameter>evtInfo</parameter> pointer should be cast to a
       <structname>PGEventRegister *</structname>.  This structure contains a
       <structname>PGconn</structname> that should be in the
       <literal>CONNECTION_OK</literal> status; guaranteed if one calls
       <xref linkend="libpq-PQregisterEventProc"/> right after obtaining a good
       <structname>PGconn</structname>.  When returning a failure code, all
       cleanup must be performed as no <literal>PGEVT_CONNDESTROY</literal>
       event will be sent.
-->
<literal>PGEVT_REGISTER</literal>イベントが受け取られると、<parameter>evtInfo</parameter>ポインタは<structname>PGEventRegister *</structname>にキャストされなければなりません。
この構造体は<literal>CONNECTION_OK</literal>状態ではなくてはならない<structname>PGconn</structname>を含んでいます。
そしてそれは、効果のある<structname>PGconn</structname>を取得した直後、<xref linkend="libpq-PQregisterEventProc"/>を呼び出せば、保証されます。
失敗コードを返すとき、<literal>PGEVT_CONNDESTROY</literal>イベントが送られないので、すべての消去が実行されなければなりません。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pgevt-connreset">
     <term><literal>PGEVT_CONNRESET</literal></term>
     <listitem>
      <para>
<!--
       The connection reset event is fired on completion of
       <xref linkend="libpq-PQreset"/> or <function>PQresetPoll</function>.  In
       both cases, the event is only fired if the reset was successful.  If
       the event procedure fails, the entire connection reset will fail; the
       <structname>PGconn</structname> is put into
       <literal>CONNECTION_BAD</literal> status and
       <function>PQresetPoll</function> will return
       <literal>PGRES_POLLING_FAILED</literal>.
-->
接続初期化イベントは<xref linkend="libpq-PQreset"/>または<function>PQresetPoll</function>の完了時点で発行されます。
どちらの場合も、初期化が成功したときのみ発行されます。
イベントプロシージャが失敗すると、接続初期化全体が失敗します。
<structname>PGconn</structname>は<literal>CONNECTION_BAD</literal>状態になり、<function>PQresetPoll</function>は<literal>PGRES_POLLING_FAILED</literal>を返します。

<synopsis>
typedef struct
{
    PGconn *conn;
} PGEventConnReset;
</synopsis>

<!--
       When a <literal>PGEVT_CONNRESET</literal> event is received, the
       <parameter>evtInfo</parameter> pointer should be cast to a
       <structname>PGEventConnReset *</structname>.  Although the contained
       <structname>PGconn</structname> was just reset, all event data remains
       unchanged.  This event should be used to reset/reload/requery any
       associated <literal>instanceData</literal>.  Note that even if the
       event procedure fails to process <literal>PGEVT_CONNRESET</literal>, it will
       still receive a <literal>PGEVT_CONNDESTROY</literal> event when the connection
       is closed.
-->
<literal>PGEVT_CONNRESET</literal>イベントが受け取られた時、<parameter>evtInfo</parameter>ポインタは<structname>PGEventConnReset *</structname>にキャストされなければなりません。
含まれた<structname>PGconn</structname>は単に初期化されますが、すべてのイベントデータは変更されずに残ります。
このイベントはすべての関連した<literal>instanceData</literal>の初期化・再読み込み・再問い合わせに使用されなければなりません。
イベントプロシージャが<literal>PGEVT_CONNRESET</literal>処理に失敗したとしても、接続が閉じられた時<literal>PGEVT_CONNDESTROY</literal>イベントを依然として受け付けることに注意してください。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pgevt-conndestroy">
     <term><literal>PGEVT_CONNDESTROY</literal></term>
     <listitem>
      <para>
<!--
       The connection destroy event is fired in response to
       <xref linkend="libpq-PQfinish"/>.  It is the event procedure's
       responsibility to properly clean up its event data as libpq has no
       ability to manage this memory.  Failure to clean up will lead
       to memory leaks.
-->
接続破棄イベントは<xref linkend="libpq-PQfinish"/>に対応して発行されます。
libpqはこのメモリを管理する機能がありませんので、そのイベントデータを的確に消去するのはイベントプロシージャの責任です。
消去の失敗はメモリーリークに通じます。

<synopsis>
typedef struct
{
    PGconn *conn;
} PGEventConnDestroy;
</synopsis>

<!--
       When a <literal>PGEVT_CONNDESTROY</literal> event is received, the
       <parameter>evtInfo</parameter> pointer should be cast to a
       <structname>PGEventConnDestroy *</structname>.  This event is fired
       prior to <xref linkend="libpq-PQfinish"/> performing any other cleanup.
       The return value of the event procedure is ignored since there is no
       way of indicating a failure from <xref linkend="libpq-PQfinish"/>.  Also,
       an event procedure failure should not abort the process of cleaning up
       unwanted memory.
-->
<literal>PGEVT_CONNDESTROY</literal>イベントが受け取られた時、<parameter>evtInfo</parameter>ポインタは<structname>PGEventConnDestroy *</structname>にキャストされなければなりません。
このイベントは<xref linkend="libpq-PQfinish"/>が他のすべての消去を行う前に発行されます。
イベントプロシージャの戻り値は、<xref linkend="libpq-PQfinish"/>から失敗を示唆する方法がないので無視されます。
同時に、イベントプロシージャの失敗が不要なメモリ消去処理を中止してはなりません。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pgevt-resultcreate">
     <term><literal>PGEVT_RESULTCREATE</literal></term>
     <listitem>
      <para>
<!--
       The result creation event is fired in response to any query execution
       function that generates a result, including
       <xref linkend="libpq-PQgetResult"/>.  This event will only be fired after
       the result has been created successfully.
-->
結果作成イベントは、<xref linkend="libpq-PQgetResult"/>を含み、結果を生成する任意の問い合わせ実行関数に対応して発行されます。
このイベントは結果が成功裏に作成されたときのみ発行されます。

<synopsis>
typedef struct
{
    PGconn *conn;
    PGresult *result;
} PGEventResultCreate;
</synopsis>

<!--
       When a <literal>PGEVT_RESULTCREATE</literal> event is received, the
       <parameter>evtInfo</parameter> pointer should be cast to a
       <structname>PGEventResultCreate *</structname>.  The
       <parameter>conn</parameter> is the connection used to generate the
       result.  This is the ideal place to initialize any
       <literal>instanceData</literal> that needs to be associated with the
       result.  If the event procedure fails, the result will be cleared and
       the failure will be propagated.  The event procedure must not try to
       <xref linkend="libpq-PQclear"/> the result object for itself.  When returning a
       failure code, all cleanup must be performed as no
       <literal>PGEVT_RESULTDESTROY</literal> event will be sent.
-->
<literal>PGEVT_RESULTCREATE</literal>イベントが受け取られた時、<parameter>evtInfo</parameter>ポインタは<structname>PGEventResultCreate *</structname>にキャストされなければなりません。
<parameter>conn</parameter>は結果を生成するために使われた接続です。
これは、結果と関連しなければならないすべての<literal>instanceData</literal>を初期化するために、理想的な場所です。
イベントプロシージャが失敗すると、結果は消去され、失敗が伝播します。
イベントプロシージャはそれ自身の結果オブジェクトを<xref linkend="libpq-PQclear"/>しようと試みてはいけません。
失敗コードを返す時、<literal>PGEVT_RESULTDESTROY</literal>イベントは送られないのですべての消去が行われなくてはなりません。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pgevt-resultcopy">
     <term><literal>PGEVT_RESULTCOPY</literal></term>
     <listitem>
      <para>
<!--
       The result copy event is fired in response to
       <xref linkend="libpq-PQcopyResult"/>.  This event will only be fired after
       the copy is complete.  Only event procedures that have
       successfully handled the <literal>PGEVT_RESULTCREATE</literal>
       or <literal>PGEVT_RESULTCOPY</literal> event for the source result
       will receive <literal>PGEVT_RESULTCOPY</literal> events.
-->
結果コピーイベントは<xref linkend="libpq-PQcopyResult"/>の応答として発行されます。
このイベントはコピーが完了した後にのみ発行されます。
元の結果に対する<literal>PGEVT_RESULTCREATE</literal>もしくは<literal>PGEVT_RESULTCOPY</literal>イベントを成功裏に処理したイベントプロシージャのみ、<literal>PGEVT_RESULTCOPY</literal>イベントを受け取ります。

<synopsis>
typedef struct
{
    const PGresult *src;
    PGresult *dest;
} PGEventResultCopy;
</synopsis>

<!--
       When a <literal>PGEVT_RESULTCOPY</literal> event is received, the
       <parameter>evtInfo</parameter> pointer should be cast to a
       <structname>PGEventResultCopy *</structname>.  The
       <parameter>src</parameter> result is what was copied while the
       <parameter>dest</parameter> result is the copy destination.  This event
       can be used to provide a deep copy of <literal>instanceData</literal>,
       since <literal>PQcopyResult</literal> cannot do that.  If the event
       procedure fails, the entire copy operation will fail and the
       <parameter>dest</parameter> result will be cleared.   When returning a
       failure code, all cleanup must be performed as no
       <literal>PGEVT_RESULTDESTROY</literal> event will be sent for the
       destination result.
-->
<literal>PGEVT_RESULTCOPY</literal>イベントが受け取られた時、<parameter>evtInfo</parameter>ポインタは<structname>PGEventResultCopy *</structname>にキャストされなければなりません。
<parameter>src</parameter>結果はコピーされるものであり、一方で<parameter>dest</parameter>結果はコピー先です。
このイベントは<literal>instanceData</literal>のディープコピーを提供するために使用されます。
<literal>PQcopyResult</literal>ではこれを行うことができないためです。
もしイベントプロシージャが失敗すると、コピー操作全体は失敗になり、<parameter>dest</parameter>結果は消去されます。
失敗コードを返す時、<literal>PGEVT_RESULTDESTROY</literal>イベントがコピー先の結果に対し送られないため、すべての消去を行われなければなりません。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pgevt-resultdestroy">
     <term><literal>PGEVT_RESULTDESTROY</literal></term>
     <listitem>
      <para>
<!--
       The result destroy event is fired in response to a
       <xref linkend="libpq-PQclear"/>.  It is the event procedure's
       responsibility to properly clean up its event data as libpq has no
       ability to manage this memory.  Failure to clean up will lead
       to memory leaks.
-->
結果破棄イベントは<xref linkend="libpq-PQclear"/>に対応して発行されます。
libpqはこのメモリを管理する機能がありませんので、そのイベントデータを的確に消去するのはイベントプロシージャの責任です。
消去の失敗はメモリーリークに通じます。

<synopsis>
typedef struct
{
    PGresult *result;
} PGEventResultDestroy;
</synopsis>

<!--
       When a <literal>PGEVT_RESULTDESTROY</literal> event is received, the
       <parameter>evtInfo</parameter> pointer should be cast to a
       <structname>PGEventResultDestroy *</structname>.  This event is fired
       prior to <xref linkend="libpq-PQclear"/> performing any other cleanup.
       The return value of the event procedure is ignored since there is no
       way of indicating a failure from <xref linkend="libpq-PQclear"/>.  Also,
       an event procedure failure should not abort the process of cleaning up
       unwanted memory.
-->
<literal>PGEVT_RESULTDESTROY</literal>が受け取られた時、<parameter>evtInfo</parameter>ポインタは<structname>PGEventResultDestroy *</structname>にキャストされなければなりません。
このイベントは<xref linkend="libpq-PQclear"/>がその他の消去を行う以前に起動されなければなりません。
イベントプロシージャの戻り値は、<xref linkend="libpq-PQclear"/>から失敗を示唆する方法がないので無視されます。
同時に、イベントプロシージャの失敗が不要なメモリ消去処理を中止してはなりません。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>

  <sect2 id="libpq-events-proc">
<!--
   <title>Event Callback Procedure</title>
-->
   <title>イベントコールバックプロシージャ</title>

   <variablelist>
    <varlistentry id="libpq-PGEventProc">
     <term><literal>PGEventProc</literal><indexterm><primary>PGEventProc</primary></indexterm></term>

     <listitem>
      <para>
<!--
       <literal>PGEventProc</literal> is a typedef for a pointer to an
       event procedure, that is, the user callback function that receives
       events from libpq.  The signature of an event procedure must be
-->
<literal>PGEventProc</literal>はイベントプロシージャへのポインタに対するtypedefです。
つまり、libpqからイベントを受け取るユーザコールバック関数です。
イベントプロシージャのシグネチャは以下でなければなりません。

<synopsis>
int eventproc(PGEventId evtId, void *evtInfo, void *passThrough)
</synopsis>

<!--
       The <parameter>evtId</parameter> parameter indicates which
       <literal>PGEVT</literal> event occurred.  The
       <parameter>evtInfo</parameter> pointer must be cast to the appropriate
       structure type to obtain further information about the event.
       The <parameter>passThrough</parameter> parameter is the pointer
       provided to <xref linkend="libpq-PQregisterEventProc"/> when the event
       procedure was registered.  The function should return a non-zero value
       if it succeeds and zero if it fails.
-->
<parameter>evtId</parameter>パラメータはどの<literal>PGEVT</literal>イベントが発生したかを示します。
<parameter>evtInfo</parameter>ポインタは、イベントに対する追加情報を入手するため適切な構造体型にキャストされなければなりません。
<parameter>passThrough</parameter>パラメータは、イベントプロシージャが登録された時、<function>PQregisterEventProc</function>に提供されるポインタです。
関数は成功した場合非ゼロを、失敗した場合ゼロを返さなければなりません。
      </para>

      <para>
<!--
       A particular event procedure can be registered only once in any
       <structname>PGconn</structname>.  This is because the address of the procedure
       is used as a lookup key to identify the associated instance data.
-->
特定のイベントプロシージャは任意の<structname>PGconn</structname>において一回だけ登録できます。
これは、プロシージャのアドレスが関連するインスタンスデータを特定する検索キーとして用いられるからです。
      </para>

      <caution>
       <para>
<!--
        On Windows, functions can have two different addresses: one visible
        from outside a DLL and another visible from inside the DLL.  One
        should be careful that only one of these addresses is used with
        <application>libpq</application>'s event-procedure functions, else confusion will
        result.  The simplest rule for writing code that will work is to
        ensure that event procedures are declared <literal>static</literal>.  If the
        procedure's address must be available outside its own source file,
        expose a separate function to return the address.
-->
Windowsにおいて、関数は２つの異なるアドレスを持つことができます。
外部から可視のDLLと内部から可視のDLLです。
<application>libpq</application>のイベントプロシージャ関数ではこれらのアドレスのうちの１つだけが使用されることに注意してください。
さもないと、混乱が起きます。
正常に機能するコードを書く最も単純な規則は、イベントプロシージャが<literal>static</literal>として宣言されることを確実にすることです。
もし、プロシージャのアドレスがそれ自身のファイルの外部から有効とならなければならない場合、アドレスを返すため別の関数を公開します。
       </para>
      </caution>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>

  <sect2 id="libpq-events-funcs">
<!--
   <title>Event Support Functions</title>
-->
   <title>イベントサポート関数</title>

    <variablelist>
    <varlistentry id="libpq-PQregisterEventProc">
     <term><function>PQregisterEventProc</function><indexterm><primary>PQregisterEventProc</primary></indexterm></term>

     <listitem>
      <para>
<!--
       Registers an event callback procedure with libpq.
-->
libpqでイベントコールバックプロシージャを登録します。

<synopsis>
int PQregisterEventProc(PGconn *conn, PGEventProc proc,
                        const char *name, void *passThrough);
</synopsis>
      </para>

      <para>
<!--
       An event procedure must be registered once on each
       <structname>PGconn</structname> you want to receive events about.  There is no
       limit, other than memory, on the number of event procedures that
       can be registered with a connection.  The function returns a non-zero
       value if it succeeds and zero if it fails.
-->
そのイベントを取得したいそれぞれの<structname>PGconn</structname>で１回イベントプロシージャは登録されなければなりません。
一つの接続に登録できるイベントプロシージャの数には、メモリ以外の制限はありません。
関数は成功した場合非ゼロ、失敗の場合ゼロを返します。
      </para>

      <para>
<!--
       The <parameter>proc</parameter> argument will be called when a libpq
       event is fired.  Its memory address is also used to lookup
       <literal>instanceData</literal>.  The <parameter>name</parameter>
       argument is used to refer to the event procedure in error messages.
       This value cannot be <symbol>NULL</symbol> or a zero-length string.  The name string is
       copied into the <structname>PGconn</structname>, so what is passed need not be
       long-lived.  The <parameter>passThrough</parameter> pointer is passed
       to the <parameter>proc</parameter> whenever an event occurs. This
       argument can be <symbol>NULL</symbol>.
-->
libpqイベントが発行されたとき<parameter>proc</parameter>引数が呼ばれます。
そのメモリアドレスは<literal>instanceData</literal>を検索するのにも使用されます。
<parameter>name</parameter>引数はエラーメッセージ内でイベントプロシージャを参照するために使用されます。
この値は<symbol>NULL</symbol>もしくは空文字列であってはなりません。
このname文字列は<structname>PGconn</structname>にコピーされますので、渡されたものは長寿命である必要がありません。
<parameter>passThrough</parameter>ポインタはイベントが発生した時はいつでも<parameter>proc</parameter>に渡されます。
この引数は<symbol>NULL</symbol>であっても構いません。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQsetInstanceData">
     <term><function>PQsetInstanceData</function><indexterm><primary>PQsetInstanceData</primary></indexterm></term>
     <listitem>
      <para>
<!--
       Sets the connection <parameter>conn</parameter>'s <literal>instanceData</literal>
       for procedure <parameter>proc</parameter> to <parameter>data</parameter>.  This
       returns non-zero for success and zero for failure.  (Failure is
       only possible if <parameter>proc</parameter> has not been properly
       registered in <parameter>conn</parameter>.)
-->
<parameter>proc</parameter>プロシージャに対する<parameter>conn</parameter>接続の<literal>instanceData</literal>を<parameter>data</parameter>に設定します。
成功の場合非ゼロ、失敗の場合ゼロが返ります。
（<parameter>conn</parameter>で<parameter>proc</parameter>が正しく登録されていない場合のみ失敗する可能性があります。）

<synopsis>
int PQsetInstanceData(PGconn *conn, PGEventProc proc, void *data);
</synopsis>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQinstanceData">
     <term><function>PQinstanceData</function><indexterm><primary>PQinstanceData</primary></indexterm></term>
     <listitem>
      <para>
<!--
       Returns the
       connection <parameter>conn</parameter>'s <literal>instanceData</literal>
       associated with procedure <parameter>proc</parameter>,
       or <symbol>NULL</symbol> if there is none.
-->
<parameter>proc</parameter>プロシージャに関連した<parameter>conn</parameter>接続の<literal>instanceData</literal>、または存在しなければ<symbol>NULL</symbol>を返します。

<synopsis>
void *PQinstanceData(const PGconn *conn, PGEventProc proc);
</synopsis>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQresultSetInstanceData">
     <term><function>PQresultSetInstanceData</function><indexterm><primary>PQresultSetInstanceData</primary></indexterm></term>
     <listitem>
      <para>
<!--
       Sets the result's <literal>instanceData</literal>
       for <parameter>proc</parameter> to <parameter>data</parameter>.  This returns
       non-zero for success and zero for failure.  (Failure is only
       possible if <parameter>proc</parameter> has not been properly registered
       in the result.)
-->
<parameter>proc</parameter>に対する結果の<literal>instanceData</literal>を<parameter>data</parameter>に設定します。
成功の場合非ゼロ、失敗の場合ゼロが返ります。
（結果で<parameter>proc</parameter>正しく登録されていない場合のみ失敗する可能性があります。）

<synopsis>
int PQresultSetInstanceData(PGresult *res, PGEventProc proc, void *data);
</synopsis>
      </para>

      <para>
<!--
       Beware that any storage represented by <parameter>data</parameter>
       will not be accounted for by <xref linkend="libpq-PQresultMemorySize"/>,
       unless it is allocated using <xref linkend="libpq-PQresultAlloc"/>.
       (Doing so is recommendable because it eliminates the need to free
       such storage explicitly when the result is destroyed.)
-->
<parameter>data</parameter>で示された領域は、<xref linkend="libpq-PQresultAlloc"/>を使って割り当てたのでない限り、<xref linkend="libpq-PQresultMemorySize"/>では考慮されないことに注意してください。
(結果を破棄する時に、領域を明示的に解放する必要がなくなりますので、<xref linkend="libpq-PQresultAlloc"/>を使って割り当てるのがお勧めです。)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-PQresultInstanceData">
     <term><function>PQresultInstanceData</function><indexterm><primary>PQresultInstanceData</primary></indexterm></term>
     <listitem>
      <para>
<!--
       Returns the result's <literal>instanceData</literal> associated with <parameter>proc</parameter>, or <symbol>NULL</symbol>
       if there is none.
-->
<parameter>proc</parameter>に関連した結果の<literal>instanceData</literal>、または存在しなければ<symbol>NULL</symbol>を返します。

<synopsis>
void *PQresultInstanceData(const PGresult *res, PGEventProc proc);
</synopsis>
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>

  <sect2 id="libpq-events-example">
<!--
   <title>Event Example</title>
-->
   <title>イベント事例</title>

   <para>
<!--
    Here is a skeleton example of managing private data associated with
    libpq connections and results.
-->
以下にlibpq接続と結果に関連したプライベートデータを管理する例の大枠を示します。
   </para>

<programlisting>
<![CDATA[
]]><!--
/* required header for libpq events (note: includes libpq-fe.h) */
--><![CDATA[
/* libpqイベントに必要なヘッダ（覚書：libpq-fe.hのインクルード) */
#include <libpq-events.h>

]]><!--
/* The instanceData */
--><![CDATA[
/* instanceData */
typedef struct
{
    int n;
    char *str;
} mydata;

/* PGEventProc */
static int myEventProc(PGEventId evtId, void *evtInfo, void *passThrough);

int
main(void)
{
    mydata *data;
    PGresult *res;
    PGconn *conn =
        PQconnectdb("dbname=postgres options=-csearch_path=");

    if (PQstatus(conn) != CONNECTION_OK)
    {
        fprintf(stderr, "Connection to database failed: %s",
                PQerrorMessage(conn));
        PQfinish(conn);
        return 1;
    }

]]><!--
    /* called once on any connection that should receive events.
     * Sends a PGEVT_REGISTER to myEventProc.
     */
--><![CDATA[
    /* イベントを受け取るべきすべての接続で１回呼ばれる
     * myEventProcにPGEVT_REGISTERを送る
     */
    if (!PQregisterEventProc(conn, myEventProc, "mydata_proc", NULL))
    {
        fprintf(stderr, "Cannot register PGEventProc\n");
        PQfinish(conn);
        return 1;
    }

]]><!--
    /* conn instanceData is available */
--><![CDATA[
    /* conn instanceDataが有効 */
    data = PQinstanceData(conn, myEventProc);

]]><!--
    /* Sends a PGEVT_RESULTCREATE to myEventProc */
--><![CDATA[
    /* myEventProcにPGEVT_RESULTCREATEを送る */
    res = PQexec(conn, "SELECT 1 + 1");

]]><!--
    /* result instanceData is available */
--><![CDATA[
    /* 結果 instanceDataが有効 */
    data = PQresultInstanceData(res, myEventProc);

]]><!--
    /* If PG_COPYRES_EVENTS is used, sends a PGEVT_RESULTCOPY to myEventProc */
--><![CDATA[
    /* PG_COPYRES_EVENTSが使われた場合、PGEVT_RESULTCOPYをmyEventProcに送る */
    res_copy = PQcopyResult(res, PG_COPYRES_TUPLES | PG_COPYRES_EVENTS);

]]><!--
    /* result instanceData is available if PG_COPYRES_EVENTS was
     * used during the PQcopyResult call.
     */
--><![CDATA[
    /* PQcopyResult呼び出しの過程でPG_COPYRES_EVENTSが使用された場合、
     * 結果 instanceDataが有効
     */
    data = PQresultInstanceData(res_copy, myEventProc);

]]><!--
    /* Both clears send a PGEVT_RESULTDESTROY to myEventProc */
--><![CDATA[
    /* 双方のclearがPGEVT_RESULTDESTROYをmyEventProcに送る */
    PQclear(res);
    PQclear(res_copy);

]]><!--
    /* Sends a PGEVT_CONNDESTROY to myEventProc */
--><![CDATA[
    /* PGEVT_CONNDESTROYをmyEventProcに送る */
    PQfinish(conn);

    return 0;
}

static int
myEventProc(PGEventId evtId, void *evtInfo, void *passThrough)
{
    switch (evtId)
    {
        case PGEVT_REGISTER:
        {
            PGEventRegister *e = (PGEventRegister *)evtInfo;
            mydata *data = get_mydata(e->conn);

]]><!--
            /* associate app specific data with connection */
--><![CDATA[
            /* アプリ特有のデータを接続に関連付ける */
            PQsetInstanceData(e->conn, myEventProc, data);
            break;
        }

        case PGEVT_CONNRESET:
        {
            PGEventConnReset *e = (PGEventConnReset *)evtInfo;
            mydata *data = PQinstanceData(e->conn, myEventProc);

            if (data)
              memset(data, 0, sizeof(mydata));
            break;
        }

        case PGEVT_CONNDESTROY:
        {
            PGEventConnDestroy *e = (PGEventConnDestroy *)evtInfo;
            mydata *data = PQinstanceData(e->conn, myEventProc);

]]><!--
            /* free instance data because the conn is being destroyed */
--><![CDATA[
            /* connが破棄されたのでインスタンスデータを解放 */
            if (data)
              free_mydata(data);
            break;
        }

        case PGEVT_RESULTCREATE:
        {
            PGEventResultCreate *e = (PGEventResultCreate *)evtInfo;
            mydata *conn_data = PQinstanceData(e->conn, myEventProc);
            mydata *res_data = dup_mydata(conn_data);

]]><!--
            /* associate app specific data with result (copy it from conn) */
--><![CDATA[
            /* アプリ特有のデータを結果と（connから複写して）関連付ける */
            PQsetResultInstanceData(e->result, myEventProc, res_data);
            break;
        }

        case PGEVT_RESULTCOPY:
        {
            PGEventResultCopy *e = (PGEventResultCopy *)evtInfo;
            mydata *src_data = PQresultInstanceData(e->src, myEventProc);
            mydata *dest_data = dup_mydata(src_data);

]]><!--
            /* associate app specific data with result (copy it from a result) */
--><![CDATA[
            /* アプリ特有のデータを結果と（結果から複写して）関連付ける */
            PQsetResultInstanceData(e->dest, myEventProc, dest_data);
            break;
        }

        case PGEVT_RESULTDESTROY:
        {
            PGEventResultDestroy *e = (PGEventResultDestroy *)evtInfo;
            mydata *data = PQresultInstanceData(e->result, myEventProc);

]]><!--
            /* free instance data because the result is being destroyed */
--><![CDATA[
            /* 結果が破棄されたためインスタンスデータを解放 */
            if (data)
              free_mydata(data);
            break;
        }

]]><!--
        /* unknown event ID, just return true. */
--><![CDATA[
        /* 未知のイベント識別子。単にtrueを返す */
        default:
            break;
    }

]]><!--
    return true; /* event processing succeeded */
--><![CDATA[
    return true; /* イベント処理成功 */
}
]]>
</programlisting>
  </sect2>
 </sect1>

 <sect1 id="libpq-envars">
<!--
  <title>Environment Variables</title>
-->
<title>環境変数</title>

  <indexterm zone="libpq-envars">
   <primary>environment variable</primary>
  </indexterm>
  <indexterm zone="libpq-envars">
   <primary>環境変数</primary>
  </indexterm>

  <para>
<!--
   The following environment variables can be used to select default
   connection parameter values, which will be used by
   <xref linkend="libpq-PQconnectdb"/>, <xref linkend="libpq-PQsetdbLogin"/> and
   <xref linkend="libpq-PQsetdb"/> if no value is directly specified by the calling
   code.  These are useful to avoid hard-coding database connection
   information into simple client applications, for example.
-->
以下の環境変数を使用して、呼び出し側のプログラムで直接値を指定しなかった場合の接続パラメータのデフォルト値を選ぶことができます。
この値は、<xref linkend="libpq-PQconnectdb"/>、<xref linkend="libpq-PQsetdbLogin"/>および<xref linkend="libpq-PQsetdb"/>で使用されます。
例えば、簡単なクライアントアプリケーションでは、データベース接続情報を直接プログラムに記述しない方が便利です。

   <itemizedlist>
    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGHOST</envar></primary>
      </indexterm>
<!--
      <envar>PGHOST</envar> behaves the same as the <xref
      linkend="libpq-connect-host"/> connection parameter.
-->
<envar>PGHOST</envar>は<xref linkend="libpq-connect-host"/>接続パラメータと同様に動作します。
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGHOSTADDR</envar></primary>
      </indexterm>
<!--
      <envar>PGHOSTADDR</envar> behaves the same as the <xref
      linkend="libpq-connect-hostaddr"/> connection parameter.
      This can be set instead of or in addition to <envar>PGHOST</envar>
      to avoid DNS lookup overhead.
-->
<envar>PGHOSTADDR</envar>は<xref linkend="libpq-connect-hostaddr"/>接続パラメータと同様に動作します。
<envar>PGHOST</envar>の代わりに設定して、または、<envar>PGHOST</envar>に追加して、DNS検索に要するオーバヘッドをなくすことができます。
     </para>

    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGPORT</envar></primary>
      </indexterm>
<!--
      <envar>PGPORT</envar> behaves the same as the <xref
      linkend="libpq-connect-port"/> connection parameter.
-->
<envar>PGPORT</envar>は<xref linkend="libpq-connect-port"/>接続パラメータと同様に動作します。
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGDATABASE</envar></primary>
      </indexterm>
<!--
      <envar>PGDATABASE</envar> behaves the same as the <xref
      linkend="libpq-connect-dbname"/> connection parameter.
-->
<envar>PGDATABASE</envar>は<xref linkend="libpq-connect-dbname"/>接続パラメータと同様に動作します。
      </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGUSER</envar></primary>
      </indexterm>
<!--
      <envar>PGUSER</envar> behaves the same as the <xref
      linkend="libpq-connect-user"/> connection parameter.
-->
<envar>PGUSER</envar>は<xref linkend="libpq-connect-user"/>接続パラメータと同様に動作します。
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGPASSWORD</envar></primary>
      </indexterm>
<!--
      <envar>PGPASSWORD</envar> behaves the same as the <xref
      linkend="libpq-connect-password"/> connection parameter.
      Use of this environment variable
      is not recommended for security reasons, as some operating systems
      allow non-root users to see process environment variables via
      <application>ps</application>; instead consider using a password file
      (see <xref linkend="libpq-pgpass"/>).
-->
<envar>PGPASSWORD</envar>は<xref linkend="libpq-connect-password"/>接続パラメータと同様に動作します。
この環境変数は、一部のオペレーティングシステムではroot以外のユーザが<application>ps</application>コマンド経由で環境変数を見ることができるなど、セキュリティ上の理由から現在では推奨されていません。
代わりにパスワードファイル(<xref linkend="libpq-pgpass"/>を参照してください)を使用することを検討してください。
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGPASSFILE</envar></primary>
      </indexterm>
<!--
      <envar>PGPASSFILE</envar> behaves the same as the <xref
      linkend="libpq-connect-passfile"/> connection parameter.
-->
<envar>PGPASSFILE</envar>は<xref linkend="libpq-connect-passfile"/>接続パラメータと同様に動作します。
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGCHANNELBINDING</envar></primary>
      </indexterm>
<!--
      <envar>PGCHANNELBINDING</envar> behaves the same as the <xref
      linkend="libpq-connect-channel-binding"/> connection parameter.
-->
 <envar>PGCHANNELBINDING</envar>は<xref linkend="libpq-connect-channel-binding"/>接続パラメータと同様に動作します。
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGSERVICE</envar></primary>
      </indexterm>
<!--
      <envar>PGSERVICE</envar> behaves the same as the <xref
      linkend="libpq-connect-service"/> connection parameter.
-->
<envar>PGSERVICE</envar>は<xref linkend="libpq-connect-service"/>接続パラメータと同様に動作します。
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGSERVICEFILE</envar></primary>
      </indexterm>
<!--
      <envar>PGSERVICEFILE</envar> specifies the name of the per-user
      connection service file.  If not set, it defaults
      to <filename>~/.pg_service.conf</filename>
      (see <xref linkend="libpq-pgservice"/>).
-->
<envar>PGSERVICEFILE</envar>はユーザごとの接続サービスファイルを指定します。
設定されていない場合、デフォルトは<filename>~/.pg_service.conf</filename>（<xref linkend="libpq-pgservice"/>参照）となります。
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGOPTIONS</envar></primary>
      </indexterm>
<!--
      <envar>PGOPTIONS</envar> behaves the same as the <xref
      linkend="libpq-connect-options"/> connection parameter.
-->
<envar>PGOPTIONS</envar>は<xref linkend="libpq-connect-options"/>接続パラメータと同様に動作します。
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGAPPNAME</envar></primary>
      </indexterm>
<!--
      <envar>PGAPPNAME</envar> behaves the same as the <xref
      linkend="libpq-connect-application-name"/> connection parameter.
-->
<envar>PGAPPNAME</envar>は<xref linkend="libpq-connect-application-name"/>接続パラメータと同様に動作します。
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGSSLMODE</envar></primary>
      </indexterm>
<!--
      <envar>PGSSLMODE</envar> behaves the same as the <xref
      linkend="libpq-connect-sslmode"/> connection parameter.
-->
<envar>PGSSLMODE</envar>は<xref linkend="libpq-connect-sslmode"/>接続パラメータと同様に動作します。
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGREQUIRESSL</envar></primary>
      </indexterm>
<!--
      <envar>PGREQUIRESSL</envar> behaves the same as the <xref
      linkend="libpq-connect-requiressl"/> connection parameter.
      This environment variable is deprecated in favor of the
      <envar>PGSSLMODE</envar> variable; setting both variables suppresses the
      effect of this one.
-->
<envar>PGREQUIRESSL</envar>は<xref linkend="libpq-connect-requiressl"/>接続パラメータと同様に動作します。
この環境変数は<envar>PGSSLMODE</envar>変数があるため、廃止予定となっています。
両方の変数を設定すると、<envar>PGREQUIRESSL</envar>の設定は無視されます。
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGSSLCOMPRESSION</envar></primary>
      </indexterm>
<!--
      <envar>PGSSLCOMPRESSION</envar> behaves the same as the <xref
      linkend="libpq-connect-sslcompression"/> connection parameter.
-->
<envar>PGSSLCOMPRESSION</envar>は<xref linkend="libpq-connect-sslcompression"/>接続パラメータと同様に動作します。
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGSSLCERT</envar></primary>
      </indexterm>
<!--
      <envar>PGSSLCERT</envar> behaves the same as the <xref
      linkend="libpq-connect-sslcert"/> connection parameter.
-->
<envar>PGSSLCERT</envar>は<xref linkend="libpq-connect-sslcert"/>接続パラメータと同様に動作します。
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGSSLKEY</envar></primary>
      </indexterm>
<!--
      <envar>PGSSLKEY</envar> behaves the same as the <xref
      linkend="libpq-connect-sslkey"/> connection parameter.
-->
<envar>PGSSLKEY</envar>は<xref linkend="libpq-connect-sslkey"/>接続パラメータと同様に動作します。
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGSSLROOTCERT</envar></primary>
      </indexterm>
<!--
      <envar>PGSSLROOTCERT</envar>  behaves the same as the <xref
      linkend="libpq-connect-sslrootcert"/> connection parameter.
-->
<envar>PGSSLROOTCERT</envar>は<xref linkend="libpq-connect-sslrootcert"/>接続パラメータと同様に動作します。
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGSSLCRL</envar></primary>
      </indexterm>
<!--
      <envar>PGSSLCRL</envar>  behaves the same as the <xref
      linkend="libpq-connect-sslcrl"/> connection parameter.
-->
<envar>PGSSLCRL</envar>は<xref linkend="libpq-connect-sslcrl"/>接続パラメータと同様に動作します。
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGREQUIREPEER</envar></primary>
      </indexterm>
<!--
      <envar>PGREQUIREPEER</envar> behaves the same as the <xref
      linkend="libpq-connect-requirepeer"/> connection parameter.
-->
<envar>PGREQUIREPEER</envar>は<xref linkend="libpq-connect-requirepeer"/>接続パラメータと同様に動作します。
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGSSLMINPROTOCOLVERSION</envar></primary>
      </indexterm>
<!--
      <envar>PGSSLMINPROTOCOLVERSION</envar> behaves the same as the <xref
      linkend="libpq-connect-ssl-min-protocol-version"/> connection parameter.
-->
 <envar>PGSSLMINPROTOCOLVERSION</envar>は<xref linkend="libpq-connect-ssl-min-protocol-version"/>接続パラメータと同様に動作します。
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGSSLMAXPROTOCOLVERSION</envar></primary>
      </indexterm>
<!--
      <envar>PGSSLMAXPROTOCOLVERSION</envar> behaves the same as the <xref
      linkend="libpq-connect-ssl-min-protocol-version"/> connection parameter.
-->
<envar>PGSSLMAXPROTOCOLVERSION</envar>は<xref linkend="libpq-connect-ssl-min-protocol-version"/>接続パラメータと同様に動作します。
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGGSSENCMODE</envar></primary>
      </indexterm>
<!--
      <envar>PGGSSENCMODE</envar> behaves the same as the <xref
      linkend="libpq-connect-gssencmode"/> connection parameter.
-->
<envar>PGGSSENCMODE</envar>は<xref linkend="libpq-connect-gssencmode"/>接続パラメータと同様に動作します。
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGKRBSRVNAME</envar></primary>
      </indexterm>
<!--
      <envar>PGKRBSRVNAME</envar>  behaves the same as the <xref
      linkend="libpq-connect-krbsrvname"/> connection parameter.
-->
<envar>PGKRBSRVNAME</envar>は<xref linkend="libpq-connect-krbsrvname"/>接続パラメータと同様に動作します。
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGGSSLIB</envar></primary>
      </indexterm>
<!--
      <envar>PGGSSLIB</envar> behaves the same as the <xref
      linkend="libpq-connect-gsslib"/> connection parameter.
-->
<envar>PGGSSLIB</envar>は<xref linkend="libpq-connect-gsslib"/>接続パラメータと同様に動作します。
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGCONNECT_TIMEOUT</envar></primary>
      </indexterm>
<!--
      <envar>PGCONNECT_TIMEOUT</envar>  behaves the same as the <xref
      linkend="libpq-connect-connect-timeout"/> connection parameter.
-->
<envar>PGCONNECT_TIMEOUT</envar>は<xref linkend="libpq-connect-connect-timeout"/>接続パラメータと同様に動作します。
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGCLIENTENCODING</envar></primary>
      </indexterm>
<!--
      <envar>PGCLIENTENCODING</envar> behaves the same as the <xref
      linkend="libpq-connect-client-encoding"/> connection parameter.
-->
<envar>PGCLIENTENCODING</envar>は<xref linkend="libpq-connect-client-encoding"/>接続パラメータと同様に動作します。
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGTARGETSESSIONATTRS</envar></primary>
      </indexterm>
<!--
      <envar>PGTARGETSESSIONATTRS</envar> behaves the same as the <xref
      linkend="libpq-connect-target-session-attrs"/> connection parameter.
-->
<envar>PGTARGETSESSIONATTRS</envar>は<xref linkend="libpq-connect-target-session-attrs"/>接続パラメータと同様に動作します。
     </para>
    </listitem>
   </itemizedlist>
  </para>

  <para>
<!--
   The following environment variables can be used to specify default
   behavior for each <productname>PostgreSQL</productname> session.  (See
   also the <xref linkend="sql-alterrole"/>
   and <xref linkend="sql-alterdatabase"/>
   commands for ways to set default behavior on a per-user or per-database
   basis.)
-->
以下の環境変数を使用して、<productname>PostgreSQL</productname>セッション毎のデフォルト動作を指定することができます。
(また、ユーザ毎、もしくは、データベース毎を単位としたデフォルト動作の設定方法については<xref linkend="sql-alterrole"/>および<xref linkend="sql-alterdatabase"/>コマンドを参照してください。)

   <itemizedlist>
    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGDATESTYLE</envar></primary>
      </indexterm>
<!--
      <envar>PGDATESTYLE</envar> sets the default style of date/time
      representation.  (Equivalent to <literal>SET datestyle TO
      ...</literal>.)
-->
<envar>PGDATESTYLE</envar>はデフォルトの日付/時刻表現形式を設定します。
(<literal>SET datestyle TO ...</literal>と等価です。)
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGTZ</envar></primary>
      </indexterm>
<!--
      <envar>PGTZ</envar> sets the default time zone.  (Equivalent to
      <literal>SET timezone TO ...</literal>.)
-->
<envar>PGTZ</envar>はデフォルトの時間帯を設定します。
(<literal>SET timezone TO ...</literal>と等価です。)
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGGEQO</envar></primary>
      </indexterm>
<!--
      <envar>PGGEQO</envar> sets the default mode for the genetic query
      optimizer.  (Equivalent to <literal>SET geqo TO ...</literal>.)
-->
<envar>PGGEQO</envar>は遺伝的問い合わせオプティマイザのデフォルトのモードを設定します。
(<literal>SET geqo TO ...</literal>と等価です。)
     </para>
    </listitem>
   </itemizedlist>

<!--
   Refer to the <acronym>SQL</acronym> command <xref linkend="sql-set"/>
   for information on correct values for these
   environment variables.
-->
これらの環境変数の正確な値については、<xref linkend="sql-set"/> <acronym>SQL</acronym>コマンドを参照してください。
  </para>

  <para>
<!--
   The following environment variables determine internal behavior of
   <application>libpq</application>; they override compiled-in defaults.
-->
以下の環境変数は、<application>libpq</application>の内部動作を決定します。
これらはコンパイル時のデフォルトを上書きします。

   <itemizedlist>
    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGSYSCONFDIR</envar></primary>
      </indexterm>
<!--
      <envar>PGSYSCONFDIR</envar> sets the directory containing the
      <filename>pg_service.conf</filename> file and in a future version
      possibly other system-wide configuration files.
-->
<envar>PGSYSCONFDIR</envar>は<filename>pg_service.conf</filename>ファイルがあるディレクトリを設定します。
また今後のバージョンでは他のシステム全体の設定ファイルとなるかもしれません。
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGLOCALEDIR</envar></primary>
      </indexterm>
<!--
      <envar>PGLOCALEDIR</envar> sets the directory containing the
      <literal>locale</literal> files for message localization.
-->
<envar>PGLOCALEDIR</envar>はメッセージのローカライズ用の<literal>locale</literal>ファイルがあるディレクトリを設定します。
     </para>
    </listitem>
   </itemizedlist>
  </para>

 </sect1>

<!-- split-libpq2-end -->
