<!-- doc/src/sgml/plpgsql.sgml -->

<chapter id="plpgsql">
<!--
  <title><application>PL/pgSQL</application> &mdash; <acronym>SQL</acronym> Procedural Language</title>
-->
<title><application>PL/pgSQL</application> &mdash; <acronym>SQL</acronym>手続き言語</title>

 <indexterm zone="plpgsql">
  <primary>PL/pgSQL</primary>
 </indexterm>

 <sect1 id="plpgsql-overview">
<!--
  <title>Overview</title>
-->
<title>概要</title>

 <para>
<!--
  <application>PL/pgSQL</application> is a loadable procedural
  language for the <productname>PostgreSQL</productname> database
  system.  The design goals of <application>PL/pgSQL</application> were to create
  a loadable procedural language that
-->
<application>PL/pgSQL</application>は、<productname>PostgreSQL</productname>データベースシステム用の読み込み可能な手続き言語です。
<application>PL/pgSQL</application>の設計目的は、次のような読み込み可能な手続き言語でした。

    <itemizedlist>
     <listitem>
      <para>
<!--
       can be used to create functions, procedures, and triggers,
-->
関数とトリガを作成するために使用できること
      </para>
     </listitem>
     <listitem>
      <para>
<!--
       adds control structures to the <acronym>SQL</acronym> language,
-->
<acronym>SQL</acronym>言語に制御構造を追加すること
      </para>
     </listitem>
     <listitem>
      <para>
<!--
       can perform complex computations,
-->
複雑な演算が可能であること
      </para>
     </listitem>
     <listitem>
      <para>
<!--
       inherits all user-defined types, functions, procedures, and operators,
-->
全てのユーザ定義型、関数、演算子を継承すること
      </para>
     </listitem>
     <listitem>
      <para>
<!--
       can be defined to be trusted by the server,
-->
サーバによって信頼できるものと定義できること
      </para>
     </listitem>
     <listitem>
      <para>
<!--
       is easy to use.
-->
使いやすいこと
      </para>
     </listitem>
    </itemizedlist>
   </para>

   <para>
<!--
    Functions created with <application>PL/pgSQL</application> can be
    used anywhere that built-in functions could be used.
    For example, it is possible to
    create complex conditional computation functions and later use
    them to define operators or use them in index expressions.
-->
<application>PL/pgSQL</application>で作成した関数は、組み込み関数が使えるところであれば、どこでも使用できます。
例えば、複雑な条件のある演算処理関数の作成が可能ですし、作成した関数を使用して演算子を定義することも、インデックス式にその関数を使用することも可能です。
   </para>

   <para>
<!--
    In <productname>PostgreSQL</productname> 9.0 and later,
    <application>PL/pgSQL</application> is installed by default.
    However it is still a loadable module, so especially security-conscious
    administrators could choose to remove it.
-->
<productname>PostgreSQL</productname> 9.0以降では<application>PL/pgSQL</application>はデフォルトでインストールされます。
しかしこれはまだロード可能なモジュールですので、特にセキュリティに厳しい管理者は削除することもできます。
   </para>

  <sect2 id="plpgsql-advantages">
<!--
   <title>Advantages of Using <application>PL/pgSQL</application></title>
-->
<title><application>PL/pgSQL</application>を使用することの利点</title>

    <para>
<!--
     <acronym>SQL</acronym> is the language <productname>PostgreSQL</productname>
     and most other relational databases use as query language. It's
     portable and easy to learn. But every <acronym>SQL</acronym>
     statement must be executed individually by the database server.
-->
<acronym>SQL</acronym>は<productname>PostgreSQL</productname>およびその他のほとんどのリレーショナルデータベースが問い合わせ言語として使用している言語です。
移植性があり、習得が容易です。
しかし、あらゆる<acronym>SQL</acronym>文はデータベースサーバによって個々に実行されなければいけません。
    </para>

    <para>
<!--
     That means that your client application must send each query to
     the database server, wait for it to be processed, receive and
     process the results, do some computation, then send further
     queries to the server.  All this incurs interprocess
     communication and will also incur network overhead if your client
     is on a different machine than the database server.
-->
これはクライアントアプリケーションに対して以下のようなことを要求しています。
まず、データベースサーバに問い合わせを送信します。
次にそれが処理されるのを待ちます。
次に、結果を取得して処理します。
次に若干の計算を行います。
そして、サーバに次の問い合わせを送信します。
クライアントがデータベースサーバマシンと異なるマシンの場合、これが招いたプロセス間通信により、ネットワークオーバーヘッドを起こすでしょう。
    </para>

    <para>
<!--
     With <application>PL/pgSQL</application> you can group a block of
     computation and a series of queries <emphasis>inside</emphasis>
     the database server, thus having the power of a procedural
     language and the ease of use of SQL, but with considerable
     savings of client/server communication overhead.
-->
<application>PL/pgSQL</application>を使うことで、計算と複数の問い合わせをデータベースサーバ<emphasis>内部</emphasis>でひとまとめに実行することができます。
このように、手続き言語の能力とSQLの使いやすさを持ち合わせているにもかかわらず、クライアント/サーバ通信のオーバーヘッドをかなり節約できます。
    </para>
    <itemizedlist>

<!--
     <listitem><para> Extra round trips between
     client and server are eliminated </para></listitem>
-->
<listitem><para>クライアント・サーバ間の余計なやり取りを排除する。</para></listitem>

<!--
     <listitem><para> Intermediate results that the client does not
     need do not have to be marshaled or transferred between server
     and client </para></listitem>
-->
<listitem><para>クライアントサーバ間において、クライアントに不必要な中間結果の整理と転送を不要とする。</para></listitem>

<!--
     <listitem><para> Multiple rounds of query
     parsing can be avoided </para></listitem>
-->
<listitem><para>一連の問い合わせに、複数の解析が不要である。</para></listitem>

    </itemizedlist>
<!--
    <para> This can result in a considerable performance increase as
    compared to an application that does not use stored functions.
-->
<para>これにより、ストアドプロシージャを使用しないアプリケーションに比較して、かなり性能を向上させることができます。
    </para>

    <para>
<!--
     Also, with <application>PL/pgSQL</application> you can use all
     the data types, operators and functions of SQL.
-->
また、<application>PL/pgSQL</application>ではSQL全てのデータ型、演算子、関数を使用することができます。
    </para>
  </sect2>

  <sect2 id="plpgsql-args-results">
<!--
   <title>Supported Argument and Result Data Types</title>
-->
<title>引数と結果データ型のサポート</title>

    <para>
<!--
     Functions written in <application>PL/pgSQL</application> can accept
     as arguments any scalar or array data type supported by the server,
     and they can return a result of any of these types.  They can also
     accept or return any composite type (row type) specified by name.
     It is also possible to declare a <application>PL/pgSQL</application>
     function as accepting <type>record</type>, which means that any
     composite type will do as input, or
     as returning <type>record</type>, which means that the result
     is a row type whose columns are determined by specification in the
     calling query, as discussed in <xref linkend="queries-tablefunctions"/>.
-->
<application>PL/pgSQL</application>で作成された関数は、サーバでサポートされる任意のスカラデータ型や配列データ型を引数として受け付けることができ、また、これらの型を結果として返すことができます。
また、任意の、名前で指定された複合型（行型）を受け付けたり、返したりすることもできます。
さらに、<xref linkend="queries-tablefunctions"/>で説明されているように、<application>PL/pgSQL</application>関数が<type>record</type>を受け入れるように、すなわち、任意の複合型を入力としたり<type>record</type>を返すように宣言することも可能です。<type>record</type>を返す場合の結果は、その各列が呼び出す問い合わせの中での指定で決まる行型です。
    </para>

    <para>
<!--
     <application>PL/pgSQL</application> functions can be declared to accept a variable
     number of arguments by using the <literal>VARIADIC</literal> marker.  This
     works exactly the same way as for SQL functions, as discussed in
     <xref linkend="xfunc-sql-variadic-functions"/>.
-->
<application>PL/pgSQL</application>関数は<literal>VARIADIC</literal>記号を使用して可変長の引数を受け付けられるように宣言することができます。
これは<xref linkend="xfunc-sql-variadic-functions"/>で論議したように、SQL関数と全く同じ方法で動作します。
    </para>

    <para>
<!--
     <application>PL/pgSQL</application> functions can also be declared to
     accept and return the polymorphic types described in
     <xref linkend="extend-types-polymorphic"/>, thus allowing the actual data
     types handled by the function to vary from call to call.
     Examples appear in <xref linkend="plpgsql-declaration-parameters"/>.
-->
また、<application>PL/pgSQL</application>関数を、<xref linkend="extend-types-polymorphic"/>で説明されている多様型を受け付けたり、返したりするように宣言することもできます。
これにより、関数によって処理される実際のデータ型は呼び出しごとに変動することができます。
例を<xref linkend="plpgsql-declaration-parameters"/>に示します。
    </para>

    <para>
<!--
     <application>PL/pgSQL</application> functions can also be declared to return
     a <quote>set</quote> (or table) of any data type that can be returned as
     a single instance.  Such a function generates its output by executing
     <command>RETURN NEXT</command> for each desired element of the result
     set, or by using <command>RETURN QUERY</command> to output the result of
     evaluating a query.
-->
<application>PL/pgSQL</application>関数は、1つのインスタンスとして返すことができる任意のデータ型の<quote>集合</quote>（テーブル）を返すように宣言できます。
こうした関数は、結果集合の必要な要素に対して<command>RETURN NEXT</command>を実行すること、または問い合わせの評価結果を得るために<command>RETURN QUERY</command>を使用することで、その出力を生成します。
    </para>

    <para>
<!--
     Finally, a <application>PL/pgSQL</application> function can be declared to return
     <type>void</type> if it has no useful return value.  (Alternatively, it
     could be written as a procedure in that case.)
-->
最後に、有用な戻り値を持たない場合、<application>PL/pgSQL</application>関数は、<type>void</type>を返すように宣言することができます。
（あるいは、この場合はプロシージャとして書くこともできます）
    </para>

    <para>
<!--
     <application>PL/pgSQL</application> functions can also be declared with output
     parameters in place of an explicit specification of the return type.
     This does not add any fundamental capability to the language, but
     it is often convenient, especially for returning multiple values.
     The <literal>RETURNS TABLE</literal> notation can also be used in place
     of <literal>RETURNS SETOF</literal>.
-->
<application>PL/pgSQL</application>関数は戻り値の型を明確に指定する代わりに、出力パラメータと共に宣言することもできます。
これは言語に対して基本的な能力を追加するものではありませんが、特に複数の値を返す時にしばしば便利です。
<literal>RETURNS TABLE</literal>表記は<literal>RETURNS SETOF</literal>の代わりとして使用できます。
    </para>

    <para>
<!--
     Specific examples appear in
     <xref linkend="plpgsql-declaration-parameters"/> and
     <xref linkend="plpgsql-statements-returning"/>.
-->
関連する例は<xref linkend="plpgsql-declaration-parameters"/>および<xref linkend="plpgsql-statements-returning"/>にあります。
    </para>
  </sect2>
 </sect1>

 <sect1 id="plpgsql-structure">
<!--
  <title>Structure of <application>PL/pgSQL</application></title>
-->
<title><application>PL/pgSQL</application>の構造</title>

  <para>
<!--
   Functions written in <application>PL/pgSQL</application> are defined
   to the server by executing <xref linkend="sql-createfunction"/> commands.
   Such a command would normally look like, say,
-->
<application>PL/pgSQL</application>で書かれた関数は<xref linkend="sql-createfunction"/>コマンドを実行することでサーバに定義されます。
そのようなコマンドは通常、例えば次のようになります。
<programlisting>
CREATE FUNCTION somefunc(integer, text) RETURNS integer
AS '<replaceable>function body text</replaceable>'
LANGUAGE plpgsql;
</programlisting>
<!--
   The function body is simply a string literal so far as <command>CREATE
   FUNCTION</command> is concerned.  It is often helpful to use dollar quoting
   (see <xref linkend="sql-syntax-dollar-quoting"/>) to write the function
   body, rather than the normal single quote syntax.  Without dollar quoting,
   any single quotes or backslashes in the function body must be escaped by
   doubling them.  Almost all the examples in this chapter use dollar-quoted
   literals for their function bodies.
-->
関数本体は<command>CREATE FUNCTION</command>にとっては単なる文字列リテラルです。
関数本体を書くのには、普通の単一引用符構文よりは、ドル引用符(<xref linkend="sql-syntax-dollar-quoting"/>を参照)を使うのが、多くの場合役に立ちます。
ドル引用符でなければ、関数本体内の単一引用符やバックスラッシュをすべて二重化してエスケープしなければなりません。
この章のほぼすべての例では、関数本体にドル記号で括られたリテラルを使っています。
  </para>

  <para>
<!--
   <application>PL/pgSQL</application> is a block-structured language.
   The complete text of a function body must be a
   <firstterm>block</firstterm>. A block is defined as:
-->
<application>PL/pgSQL</application>はブロック構造の言語です。
関数本体のテキスト全体は<firstterm>ブロック</firstterm>でなければなりません。
ブロックは以下のように定義されます。

<synopsis>
<optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>
<optional> DECLARE
    <replaceable>declarations</replaceable> </optional>
BEGIN
    <replaceable>statements</replaceable>
END <optional> <replaceable>label</replaceable> </optional>;
</synopsis>
    </para>

    <para>
<!--
     Each declaration and each statement within a block is terminated
     by a semicolon.  A block that appears within another block must
     have a semicolon after <literal>END</literal>, as shown above;
     however the final <literal>END</literal> that
     concludes a function body does not require a semicolon.
-->
ブロック内の宣言や文はそれぞれ、セミコロンで終わります。
上に示したように、他のブロック内に出現するブロックの<literal>END</literal>の後にはセミコロンが必要ですが、関数本体を完結する最後の<literal>END</literal>には不要です。
    </para>

    <tip>
     <para>
<!--
      A common mistake is to write a semicolon immediately after
      <literal>BEGIN</literal>.  This is incorrect and will result in a syntax error.
-->
<literal>BEGIN</literal>の直後にセミコロンを書くことも、同じように間違いです。
これは不正であり、構文エラーとなります。
     </para>
    </tip>

    <para>
<!--
     A <replaceable>label</replaceable> is only needed if you want to
     identify the block for use
     in an <literal>EXIT</literal> statement, or to qualify the names of the
     variables declared in the block.  If a label is given after
     <literal>END</literal>, it must match the label at the block's beginning.
-->
<replaceable>label</replaceable>が必要となるのは、<literal>EXIT</literal>文が使用されるブロックを特定したい場合、またはブロック内で宣言された変数名を修飾したい場合だけです。
<literal>END</literal>の後にラベルを配置する時は、そのブロックの先頭ラベルと一致させなければなりません。
    </para>

    <para>
<!--
     All key words are case-insensitive.
     Identifiers are implicitly converted to lower case
     unless double-quoted, just as they are in ordinary SQL commands.
-->
全てのキーワードは大文字と小文字を区別しません。
識別子は二重引用符でくくられていない限り、通常のSQLコマンドと同様に、暗黙的に小文字に変換されます。
    </para>

    <para>
<!--
     Comments work the same way in <application>PL/pgSQL</application> code as in
     ordinary SQL.  A double dash (<literal>&#045;&#045;</literal>) starts a comment
     that extends to the end of the line. A <literal>/*</literal> starts a
     block comment that extends to the matching occurrence of
     <literal>*/</literal>.  Block comments nest.
-->
<application>PL/pgSQL</application>コード内では、通常のSQLと同じ方法のコメントが動作します。
二重のダッシュ(<literal>--</literal>)はその行末までをコメントとするコメントを開始します。
<literal>/*</literal>はコメントブロックの始まりを意味し、次に<literal>*/</literal>が現れるまでをコメントとします。
ブロックコメントは入れ子になります。
    </para>

    <para>
<!--
     Any statement in the statement section of a block
     can be a <firstterm>subblock</firstterm>.  Subblocks can be used for
     logical grouping or to localize variables to a small group
     of statements.  Variables declared in a subblock mask any
     similarly-named variables of outer blocks for the duration
     of the subblock; but you can access the outer variables anyway
     if you qualify their names with their block's label. For example:
-->
ブロックの文節内の全ての文は<firstterm>副ブロック</firstterm>になることができます。
副ブロックは論理的なグループ分けや変数を文の小さな集まりに局所化するのに使用できます。
副ブロックにおいて宣言された変数は、副ブロック内部では外側のブロックにおける同名の変数を遮蔽しますが、外側のラベルを変数名に付加して指定すればアクセスできます。
以下に例を示します。
<programlisting>
CREATE FUNCTION somefunc() RETURNS integer AS $$
&lt;&lt; outerblock &gt;&gt;
DECLARE
    quantity integer := 30;
BEGIN
<!--
    RAISE NOTICE 'Quantity here is %', quantity;  &#045;&#045; Prints 30
-->
    RAISE NOTICE 'Quantity here is %', quantity;  -- Quantity here is 30と表示
    quantity := 50;
    --
<!--
    &#045;&#045; Create a subblock
-->
    -- 副ブロックの作成
    --
    DECLARE
        quantity integer := 80;
    BEGIN
<!--
        RAISE NOTICE 'Quantity here is %', quantity;  &#045;&#045; Prints 80
        RAISE NOTICE 'Outer quantity here is %', outerblock.quantity;  &#045;&#045; Prints 50
-->
        RAISE NOTICE 'Quantity here is %', quantity;  -- Quantity here is 80と表示
        RAISE NOTICE 'Outer quantity here is %', outerblock.quantity;  -- Quantity here is 50と表示
    END;

<!--
    RAISE NOTICE 'Quantity here is %', quantity;  &#045;&#045; Prints 50
-->
    RAISE NOTICE 'Quantity here is %', quantity;  -- Quantity here is 50と表示

    RETURN quantity;
END;
$$ LANGUAGE plpgsql;
</programlisting>
    </para>

    <note>
     <para>
<!--
      There is actually a hidden <quote>outer block</quote> surrounding the body
      of any <application>PL/pgSQL</application> function.  This block provides the
      declarations of the function's parameters (if any), as well as some
      special variables such as <literal>FOUND</literal> (see
      <xref linkend="plpgsql-statements-diagnostics"/>).  The outer block is
      labeled with the function's name, meaning that parameters and special
      variables can be qualified with the function's name.
-->
<application>PL/pgSQL</application>関数の本体を囲む、隠れた<quote>外側のブロック</quote>が存在します。
この隠れたブロックにおいて、関数のパラメータがあれば宣言をして、同様に<literal>FOUND</literal>のような特殊な変数（<xref linkend="plpgsql-statements-diagnostics"/>を参照）を提供します。
この外側のブロックのラベルは関数名となります。
つまりパラメータと特殊な変数は関数名によって修飾することを意味します。
     </para>
    </note>

    <para>
<!--
     It is important not to confuse the use of
     <command>BEGIN</command>/<command>END</command> for grouping statements in
     <application>PL/pgSQL</application> with the similarly-named SQL commands
     for transaction
     control.  <application>PL/pgSQL</application>'s <command>BEGIN</command>/<command>END</command>
     are only for grouping; they do not start or end a transaction.
     See <xref linkend="plpgsql-transactions"/> for information on managing
     transactions in <application>PL/pgSQL</application>.
     Also, a block containing an <literal>EXCEPTION</literal> clause effectively
     forms a subtransaction that can be rolled back without affecting the
     outer transaction.  For more about that see <xref
     linkend="plpgsql-error-trapping"/>.
-->
<application>PL/pgSQL</application>における文をまとめるための<command>BEGIN</command>/<command>END</command>とトランザクション制御用の同名のSQLコマンドとを取り違えないようにすることが重要です。
<application>PL/pgSQL</application>の<command>BEGIN</command>/<command>END</command>は単にまとめるためのもので、トランザクションを始めたり終わらせたりしません。
トランザクションを<application>PL/pgSQL</application>内で制御するための情報に関しては、<xref linkend="plpgsql-transactions"/>を参照してください。
また、<literal>EXCEPTION</literal>句を含むブロックは外側のトランザクションに影響しないでロールバックできるサブトランザクションを、実質的に作成できます。
これについては<xref linkend="plpgsql-error-trapping"/>を参照してください。
    </para>
  </sect1>

  <sect1 id="plpgsql-declarations">
<!--
    <title>Declarations</title>
-->
<title>宣言</title>

    <para>
<!--
     All variables used in a block must be declared in the
     declarations section of the block.
     (The only exceptions are that the loop variable of a <literal>FOR</literal> loop
     iterating over a range of integer values is automatically declared as an
     integer variable, and likewise the loop variable of a <literal>FOR</literal> loop
     iterating over a cursor's result is automatically declared as a
     record variable.)
-->
ブロック内で使用される全ての変数はそのブロックの宣言部で宣言されなければなりません。
（唯一の例外は、<literal>FOR</literal>ループである整数値の範囲に渡って繰り返されるループ変数で、これは、自動的に整数型変数として宣言されます。
同様に、カーソルの結果に対して繰り返し適用される<literal>FOR</literal>ループのループ変数はレコード変数として自動的に宣言されます。）
    </para>

    <para>
<!--
     <application>PL/pgSQL</application> variables can have any SQL data type, such as
     <type>integer</type>, <type>varchar</type>, and
     <type>char</type>.
-->
<application>PL/pgSQL</application>変数は、<type>integer</type>、<type>varchar</type>、<type>char</type>といった、任意のSQLデータ型を持つことができます。
    </para>

    <para>
<!--
     Here are some examples of variable declarations:
-->
変数宣言の例を以下に示します。
<programlisting>
user_id integer;
quantity numeric(5);
url varchar;
myrow tablename%ROWTYPE;
myfield tablename.columnname%TYPE;
arow RECORD;
</programlisting>
    </para>

    <para>
<!--
     The general syntax of a variable declaration is:
-->
変数宣言の一般的な構文は以下の通りです。
<synopsis>
<replaceable>name</replaceable> <optional> CONSTANT </optional> <replaceable>type</replaceable> <optional> COLLATE <replaceable>collation_name</replaceable> </optional> <optional> NOT NULL </optional> <optional> { DEFAULT | := | = } <replaceable>expression</replaceable> </optional>;
</synopsis>
<!--
      The <literal>DEFAULT</literal> clause, if given, specifies the initial value assigned
      to the variable when the block is entered.  If the <literal>DEFAULT</literal> clause
      is not given then the variable is initialized to the
      <acronym>SQL</acronym> null value.
      The <literal>CONSTANT</literal> option prevents the variable from being
      assigned to after initialization, so that its value will remain constant
      for the duration of the block.
      The <literal>COLLATE</literal> option specifies a collation to use for the
      variable (see <xref linkend="plpgsql-declaration-collation"/>).
      If <literal>NOT NULL</literal>
      is specified, an assignment of a null value results in a run-time
      error. All variables declared as <literal>NOT NULL</literal>
      must have a nonnull default value specified.
      Equal (<literal>=</literal>) can be used instead of PL/SQL-compliant
      <literal>:=</literal>.
-->
<literal>DEFAULT</literal>句が指定された場合、ブロックに入った時に変数に代入される初期値を指定します。
<literal>DEFAULT</literal>句が指定されない場合、変数は<acronym>SQL</acronym>のNULL値に初期化されます。
<literal>CONSTANT</literal>オプションにより、そのブロック内でその値が不変になるように、その変数への初期化後の代入は禁止されます。
<literal>COLLATE</literal>オプションは、変数として使用するための照合を指定します（<xref linkend="plpgsql-declaration-collation"/>を参照してください）。
<literal>NOT NULL</literal>が指定された場合、NULL値の代入は実行時エラーになります。
<literal>NOT NULL</literal>として宣言した変数は全て、非NULLのデフォルト値を指定しなければなりません。
等号（<literal>=</literal>）がPL/SQLにおける代入記号（<literal>:=</literal>）の代わりに使用できます。
     </para>

     <para>
<!--
      A variable's default value is evaluated and assigned to the variable
      each time the block is entered (not just once per function call).
      So, for example, assigning <literal>now()</literal> to a variable of type
      <type>timestamp</type> causes the variable to have the
      time of the current function call, not the time when the function was
      precompiled.
-->
変数のデフォルト値はブロックに入る度に評価され、変数に代入されます（関数を呼び出す時に一度だけではありません）。
ですから、例えば<literal>now()</literal>を<type>timestamp</type>型の変数に代入することで、その変数には関数をプリコンパイルした時刻ではなく、関数呼び出し時の現在時刻が格納されます。
     </para>

     <para>
<!--
      Examples:
-->
例：
<programlisting>
quantity integer DEFAULT 32;
url varchar := 'http://mysite.com';
user_id CONSTANT integer := 10;
</programlisting>
     </para>

    <sect2 id="plpgsql-declaration-parameters">
<!--
     <title>Declaring Function Parameters</title>
-->
<title>関数引数の宣言</title>

     <para>
<!--
      Parameters passed to functions are named with the identifiers
      <literal>$1</literal>, <literal>$2</literal>,
      etc.  Optionally, aliases can be declared for
      <literal>$<replaceable>n</replaceable></literal>
      parameter names for increased readability.  Either the alias or the
      numeric identifier can then be used to refer to the parameter value.
-->
関数に渡されるパラメータの名前には<literal>$1</literal>、<literal>$2</literal>という識別子が付けられます。
省略することもできますが、<literal>$<replaceable>n</replaceable></literal>というパラメータ名に別名を宣言することができ、可読性が向上します。
別名、数字による識別子の両方とも引数の値を参照する時に使用することができます。
     </para>

     <para>
<!--
      There are two ways to create an alias.  The preferred way is to give a
      name to the parameter in the <command>CREATE FUNCTION</command> command,
      for example:
-->
別名を作成する方法は2つあり、望ましい方法は<command>CREATE FUNCTION</command>コマンドの中でパラメータを命名するものです。
以下に例を示します。
<programlisting>
CREATE FUNCTION sales_tax(subtotal real) RETURNS real AS $$
BEGIN
    RETURN subtotal * 0.06;
END;
$$ LANGUAGE plpgsql;
</programlisting>
<!--
      The other way is to explicitly declare an alias, using the
      declaration syntax
-->
他の方法は、宣言構文を用いて別名を明確に宣言するものです。

<synopsis>
<replaceable>name</replaceable> ALIAS FOR $<replaceable>n</replaceable>;
</synopsis>

<!--
      The same example in this style looks like:
-->
以下にこの方法による例を示します。
<programlisting>
CREATE FUNCTION sales_tax(real) RETURNS real AS $$
DECLARE
    subtotal ALIAS FOR $1;
BEGIN
    RETURN subtotal * 0.06;
END;
$$ LANGUAGE plpgsql;
</programlisting>
     </para>

    <note>
     <para>
<!--
      These two examples are not perfectly equivalent.  In the first case,
      <literal>subtotal</literal> could be referenced as
      <literal>sales_tax.subtotal</literal>, but in the second case it could not.
      (Had we attached a label to the inner block, <literal>subtotal</literal> could
      be qualified with that label, instead.)
-->
この二例は完全に同等ではありません。
最初の例では、<literal>subtotal</literal>を<literal>sales_tax.subtotal</literal>で参照できますが、次の例ではできません
（その代わり、内部ブロックにラベルを付与すれば、<literal>subtotal</literal>をラベルで修飾することができます）。
     </para>
    </note>

     <para>
<!--
      Some more examples:
-->
さらに数例を示します。
<programlisting>
CREATE FUNCTION instr(varchar, integer) RETURNS integer AS $$
DECLARE
    v_string ALIAS FOR $1;
    index ALIAS FOR $2;
BEGIN
<!--
    &#045;&#045; some computations using v_string and index here
-->
    -- v_string とインデックスを使用した何らかの演算を行なう
END;
$$ LANGUAGE plpgsql;


CREATE FUNCTION concat_selected_fields(in_t sometablename) RETURNS text AS $$
BEGIN
    RETURN in_t.f1 || in_t.f3 || in_t.f5 || in_t.f7;
END;
$$ LANGUAGE plpgsql;
</programlisting>
     </para>

     <para>
<!--
      When a <application>PL/pgSQL</application> function is declared
      with output parameters, the output parameters are given
      <literal>$<replaceable>n</replaceable></literal> names and optional
      aliases in just the same way as the normal input parameters.  An
      output parameter is effectively a variable that starts out NULL;
      it should be assigned to during the execution of the function.
      The final value of the parameter is what is returned.  For instance,
      the sales-tax example could also be done this way:
-->
<application>PL/pgSQL</application>関数が出力パラメータと共に宣言されると、通常の入力パラメータと同様に、出力パラメータには<literal>$<replaceable>n</replaceable></literal>というパラメータ名と任意の別名が与えられます。
出力パラメータは実質的には最初がNULL値の変数であり、関数の実行中に値が指定されるはずです。
出力パラメータの最後の値は戻り値です。
例えば、消費税の例題は、次のようにすることもできます。

<programlisting>
CREATE FUNCTION sales_tax(subtotal real, OUT tax real) AS $$
BEGIN
    tax := subtotal * 0.06;
END;
$$ LANGUAGE plpgsql;
</programlisting>

<!--
      Notice that we omitted <literal>RETURNS real</literal> &mdash; we could have
      included it, but it would be redundant.
-->
<literal>RETURNS real</literal>を省略したことに注意してください。
含めることもできますが、冗長になります。
     </para>

     <para>
      To call a function with <literal>OUT</literal> parameters, omit the
      output parameter(s) in the function call:
<programlisting>
SELECT sales_tax(100.00);
</programlisting>
     </para>

     <para>
<!--
      Output parameters are most useful when returning multiple values.
      A trivial example is:
-->
出力パラメータは複数の値を返す時に最も有用になります。
簡単な例題を示します。

<programlisting>
CREATE FUNCTION sum_n_product(x int, y int, OUT sum int, OUT prod int) AS $$
BEGIN
    sum := x + y;
    prod := x * y;
END;
$$ LANGUAGE plpgsql;

SELECT * FROM sum_n_product(2, 4);
 sum | prod
-----+------
   6 |    8
</programlisting>

<!--
      As discussed in <xref linkend="xfunc-output-parameters"/>, this
      effectively creates an anonymous record type for the function's
      results.  If a <literal>RETURNS</literal> clause is given, it must say
      <literal>RETURNS record</literal>.
-->
<xref linkend="xfunc-output-parameters"/>で述べたように、この方法は関数の結果に対する匿名のレコード型を実質的に作成します。
<literal>RETURNS</literal>句が与えられた時は、<literal>RETURNS record</literal>と言わなければなりません。
     </para>

     <para>
      This also works with procedures, for example:

<programlisting>
CREATE PROCEDURE sum_n_product(x int, y int, OUT sum int, OUT prod int) AS $$
BEGIN
    sum := x + y;
    prod := x * y;
END;
$$ LANGUAGE plpgsql;
</programlisting>

      In a call to a procedure, all the parameters must be specified.  For
      output parameters, <literal>NULL</literal> may be specified when
      calling the procedure from plain SQL:
<programlisting>
CALL sum_n_product(2, 4, NULL, NULL);
 sum | prod
-----+------
   6 |    8
</programlisting>

      However, when calling a procedure
      from <application>PL/pgSQL</application>, you should instead write a
      variable for any output parameter; the variable will receive the result
      of the call.  See <xref linkend="plpgsql-statements-calling-procedure"/>
      for details.
     </para>

     <para>
<!--
      Another way to declare a <application>PL/pgSQL</application> function
      is with <literal>RETURNS TABLE</literal>, for example:
-->
<application>PL/pgSQL</application>関数を宣言する他の方法として、<literal>RETURNS TABLE</literal>を伴うことが挙げられます。
以下に例を示します。

<programlisting>
CREATE FUNCTION extended_sales(p_itemno int)
RETURNS TABLE(quantity int, total numeric) AS $$
BEGIN
    RETURN QUERY SELECT s.quantity, s.quantity * s.price FROM sales AS s
                 WHERE s.itemno = p_itemno;
END;
$$ LANGUAGE plpgsql;
</programlisting>

<!--
      This is exactly equivalent to declaring one or more <literal>OUT</literal>
      parameters and specifying <literal>RETURNS SETOF
      <replaceable>sometype</replaceable></literal>.
-->
これは、１つ、またはそれ以上の<literal>OUT</literal>パラメータを宣言すること、および<literal>RETURNS SETOF <replaceable>何らかのデータ型</replaceable></literal>を指定することと全く等価です。
     </para>

     <para>
<!--
      When the return type of a <application>PL/pgSQL</application> function
      is declared as a polymorphic type (see
      <xref linkend="extend-types-polymorphic"/>), a special
      parameter <literal>$0</literal> is created.  Its data type is the actual
      return type of the function, as deduced from the actual input types.
      This allows the function to access its actual return type
      as shown in <xref linkend="plpgsql-declaration-type"/>.
      <literal>$0</literal> is initialized to null and can be modified by
      the function, so it can be used to hold the return value if desired,
      though that is not required.  <literal>$0</literal> can also be
      given an alias.  For example, this function works on any data type
      that has a <literal>+</literal> operator:
-->
<application>PL/pgSQL</application>関数の戻り値が多様型（<xref linkend="extend-types-polymorphic"/>を参照）として宣言されると、特別な<literal>$0</literal>パラメータが作成されます。
このデータ型が、実際の入力型から推定された関数の実際の戻り値の型です。
これにより、関数は<xref linkend="plpgsql-declaration-type"/>に示すように、実際の戻り値の型にアクセスできます。
<literal>$0</literal>はNULLで初期化され、関数内で変更することができます。
ですので、必須ではありませんが、これを戻り値を保持するために使用しても構いません。
また<literal>$0</literal>に別名を付与することもできます。
例えば、以下の関数は<literal>+</literal>演算子を持つ任意のデータ型に対して稼働します。

<programlisting>
CREATE FUNCTION add_three_values(v1 anyelement, v2 anyelement, v3 anyelement)
RETURNS anyelement AS $$
DECLARE
    result ALIAS FOR $0;
BEGIN
    result := v1 + v2 + v3;
    RETURN result;
END;
$$ LANGUAGE plpgsql;
</programlisting>
     </para>

     <para>
<!--
      The same effect can be obtained by declaring one or more output parameters as
      polymorphic types.  In this case the
      special <literal>$0</literal> parameter is not used; the output
      parameters themselves serve the same purpose.  For example:
-->
1つ以上の出力パラメータを多様型として宣言することにより、同様の結果を得ることができます。
この場合、特殊な<literal>$0</literal>パラメータは使用されません。
出力パラメータ自身が同じ目的を果たします。
以下に例を示します。

<programlisting>
CREATE FUNCTION add_three_values(v1 anyelement, v2 anyelement, v3 anyelement,
                                 OUT sum anyelement)
AS $$
BEGIN
    sum := v1 + v2 + v3;
END;
$$ LANGUAGE plpgsql;
</programlisting>
     </para>

     <para>
<!--
      In practice it might be more useful to declare a polymorphic function
      using the <type>anycompatible</type> family of types, so that automatic
      promotion of the input arguments to a common type will occur.
      For example:
-->
実際には型に<type>anycompatible</type>族を使用して多様関数を宣言する方が有用である可能性があります。そうすれば、 入力引数が共通の型に自動的に昇格されます。
以下に例を示します。

<programlisting>
CREATE FUNCTION add_three_values(v1 anycompatible, v2 anycompatible, v3 anycompatible)
RETURNS anycompatible AS $$
BEGIN
    RETURN v1 + v2 + v3;
END;
$$ LANGUAGE plpgsql;
</programlisting>

<!--
      With this example, a call such as
-->
この例は

<programlisting>
SELECT add_three_values(1, 2, 4.7);
</programlisting>

<!--
      will work, automatically promoting the integer inputs to numeric.
      The function using <type>anyelement</type> would require you to
      cast the three inputs to the same type manually.
-->
自動的に整数の入力を数値データに昇格して呼び出しが動作します。
<type>anyelement</type>を使用する関数では、3つの入力を同じ型に手動でキャストする必要があります。
     </para>
    </sect2>

  <sect2 id="plpgsql-declaration-alias">
   <title><literal>ALIAS</literal></title>

<synopsis>
<replaceable>newname</replaceable> ALIAS FOR <replaceable>oldname</replaceable>;
</synopsis>

   <para>
<!--
    The <literal>ALIAS</literal> syntax is more general than is suggested in the
    previous section: you can declare an alias for any variable, not just
    function parameters.  The main practical use for this is to assign
    a different name for variables with predetermined names, such as
    <varname>NEW</varname> or <varname>OLD</varname> within
    a trigger function.
-->
<literal>ALIAS</literal>構文は前節で示したものより一般的です。
関数の引数だけではなく、任意の変数に別名を宣言することができます。
この現実的な使用は主に、トリガ関数における<varname>NEW</varname>や<varname>OLD</varname>など、前もって決まった名前の変数に別の名前を割り当てることです。
   </para>

   <para>
<!--
    Examples:
-->
以下に例を示します。
<programlisting>
DECLARE
  prior ALIAS FOR old;
  updated ALIAS FOR new;
</programlisting>
   </para>

   <para>
<!--
    Since <literal>ALIAS</literal> creates two different ways to name the same
    object, unrestricted use can be confusing.  It's best to use it only
    for the purpose of overriding predetermined names.
-->
<literal>ALIAS</literal>は同じオブジェクトを命名する2つの異なる手段を提供しますので、無制限に使用すると混乱を招くかもしれません。
前もって決まっている名前を上書きする目的に限定して使用することが最善です。
   </para>
   </sect2>

  <sect2 id="plpgsql-declaration-type">
<!--
   <title>Copying Types</title>
-->
<title>型のコピー</title>

<synopsis>
<replaceable>variable</replaceable>%TYPE
</synopsis>

   <para>
<!--
    <literal>%TYPE</literal> provides the data type of a variable or
    table column. You can use this to declare variables that will hold
    database values. For example, let's say you have a column named
    <literal>user_id</literal> in your <literal>users</literal>
    table. To declare a variable with the same data type as
    <literal>users.user_id</literal> you write:
-->
<literal>%TYPE</literal>は変数やテーブル列のデータ型を提供します。
これを使用してデータベース値を保持する変数を宣言することができます。
例えば、<literal>users</literal>テーブルに<literal>user_id</literal>という列があるものとします。
<literal>users.user_id</literal>と同じデータ型の変数を宣言するには、以下のように記述します。
<programlisting>
user_id users.user_id%TYPE;
</programlisting>
   </para>

   <para>
<!--
    By using <literal>%TYPE</literal> you don't need to know the data
    type of the structure you are referencing, and most importantly,
    if the data type of the referenced item changes in the future (for
    instance: you change the type of <literal>user_id</literal>
    from <type>integer</type> to <type>real</type>), you might not need
    to change your function definition.
-->
<literal>%TYPE</literal>を使用することで、参照する構造のデータ型を把握する必要がなくなります。
また、これが最も重要なことですが、参照される項目のデータ型が将来変更された（例えば、user_idのテーブル定義を<type>integer</type>から<type>real</type>に変更した）場合でも、関数定義を変更する必要をなくすことができます。
   </para>

   <para>
<!--
    <literal>%TYPE</literal> is particularly valuable in polymorphic
    functions, since the data types needed for internal variables can
    change from one call to the next.  Appropriate variables can be
    created by applying <literal>%TYPE</literal> to the function's
    arguments or result placeholders.
-->
内部変数用のデータ型は呼び出す度に変わるかもしれませんので<literal>%TYPE</literal>は特に多様関数で有用です。
関数の引数や結果用のプレースホルダに<literal>%TYPE</literal>を適用することで、適切な変数を作成することができます。
   </para>

  </sect2>

    <sect2 id="plpgsql-declaration-rowtypes">
<!--
     <title>Row Types</title>
-->
<title>行型</title>

<synopsis>
<replaceable>name</replaceable> <replaceable>table_name</replaceable><literal>%ROWTYPE</literal>;
<replaceable>name</replaceable> <replaceable>composite_type_name</replaceable>;
</synopsis>

   <para>
<!--
    A variable of a composite type is called a <firstterm>row</firstterm>
    variable (or <firstterm>row-type</firstterm> variable).  Such a variable
    can hold a whole row of a <command>SELECT</command> or <command>FOR</command>
    query result, so long as that query's column set matches the
    declared type of the variable.
    The individual fields of the row value
    are accessed using the usual dot notation, for example
    <literal>rowvar.field</literal>.
-->
複合型の変数は、<firstterm>行</firstterm>変数（または<firstterm>行型</firstterm>変数）と呼ばれます。
こういった変数には、問い合わせの列集合が変数の型宣言と一致する限り、<command>SELECT</command>や<command>FOR</command>問い合わせの結果の行全体を保持することができます。
行変数の個々のフィールド値には、例えば、<literal>rowvar.field</literal>といったドット記法を使用してアクセスすることができます。
   </para>

   <para>
<!--
    A row variable can be declared to have the same type as the rows of
    an existing table or view, by using the
    <replaceable>table_name</replaceable><literal>%ROWTYPE</literal>
    notation; or it can be declared by giving a composite type's name.
    (Since every table has an associated composite type of the same name,
    it actually does not matter in <productname>PostgreSQL</productname> whether you
    write <literal>%ROWTYPE</literal> or not.  But the form with
    <literal>%ROWTYPE</literal> is more portable.)
-->
<replaceable>table_name</replaceable><literal>%ROWTYPE</literal>という記法を使用して、既存のテーブルやビューの行と同じ型を持つ行変数を宣言することができます。
もしくは、複合型の名前を付与して宣言することができます。
（全てのテーブルは、同じ名前の関連する複合型を持ちますので、実際のところ<productname>PostgreSQL</productname>では、<literal>%ROWTYPE</literal>と書いても書かなくても問題にはなりません。
しかし、<literal>%ROWTYPE</literal>の方がより移植性が高まります。）
   </para>

   <para>
<!--
    Parameters to a function can be
    composite types (complete table rows). In that case, the
    corresponding identifier <literal>$<replaceable>n</replaceable></literal> will be a row variable, and fields can
    be selected from it, for example <literal>$1.user_id</literal>.
-->
関数へのパラメータとして複合型（テーブル行全体）を取ることができます。
その場合、対応する識別子<literal>$<replaceable>n</replaceable></literal>は行変数であり、そのフィールドを、例えば、<literal>$1.user_id</literal>で選択することができます。
   </para>

   <para>
<!--
    Here is an example of using composite types.  <structname>table1</structname>
    and <structname>table2</structname> are existing tables having at least the
    mentioned fields:
-->
以下に複合型を使用する例を示します。
<structname>table1</structname>及び<structname>table2</structname>は、
少なくとも言及するフィールドを有する既存のテーブルです。

<programlisting>
CREATE FUNCTION merge_fields(t_row table1) RETURNS text AS $$
DECLARE
    t2_row table2%ROWTYPE;
BEGIN
    SELECT * INTO t2_row FROM table2 WHERE ... ;
    RETURN t_row.f1 || t2_row.f3 || t_row.f5 || t2_row.f7;
END;
$$ LANGUAGE plpgsql;

SELECT merge_fields(t.*) FROM table1 t WHERE ... ;
</programlisting>
   </para>
  </sect2>

  <sect2 id="plpgsql-declaration-records">
<!--
   <title>Record Types</title>
-->
<title>レコード型</title>

<synopsis>
<replaceable>name</replaceable> RECORD;
</synopsis>

   <para>
<!--
    Record variables are similar to row-type variables, but they have no
    predefined structure.  They take on the actual row structure of the
    row they are assigned during a <command>SELECT</command> or <command>FOR</command> command.  The substructure
    of a record variable can change each time it is assigned to.
    A consequence of this is that until a record variable is first assigned
    to, it has no substructure, and any attempt to access a
    field in it will draw a run-time error.
-->
レコード変数は行型変数と似ていますが、事前に定義された構造を持っていません。
これは<command>SELECT</command>や<command>FOR</command>コマンドの間で代入された行の実際の行構造を取ります。
レコード変数の副構造は、代入を行う度に変更できます。
つまり、レコード変数は、最初に代入されるまで副構造を持たず、したがって、フィールドへのアクセスを試みると実行時エラーが発生します。
   </para>

   <para>
<!--
    Note that <literal>RECORD</literal> is not a true data type, only a placeholder.
    One should also realize that when a <application>PL/pgSQL</application>
    function is declared to return type <type>record</type>, this is not quite the
    same concept as a record variable, even though such a function might
    use a record variable to hold its result.  In both cases the actual row
    structure is unknown when the function is written, but for a function
    returning <type>record</type> the actual structure is determined when the
    calling query is parsed, whereas a record variable can change its row
    structure on-the-fly.
-->
<literal>RECORD</literal>は本当のデータ型ではなく、単なるプレースホルダであることに注意してください。
<application>PL/pgSQL</application>関数が<type>record</type>型を返す時、この関数ではレコード変数を使用してその結果を保持することができますが、これはレコード変数としての概念とはまったく異なることを認識すべきです。
両方とも、関数の作成段階では実際の行構造は不明です。
しかし、レコード変数はその場その場でその行構造を変更できるにもかかわらず、<type>record</type>を返す関数では呼び出し元の問い合わせが解析された時点で実際の構造は決定されます。
   </para>
  </sect2>

  <sect2 id="plpgsql-declaration-collation">
<!--
   <title>Collation of <application>PL/pgSQL</application> Variables</title>
-->
<title><application>PL/pgSQL</application>変数の照合</title>

   <indexterm>
<!--
    <primary>collation</primary>
    <secondary>in PL/pgSQL</secondary>
-->
    <primary>照合</primary>
    <secondary>PL/pgSQLにおける</secondary>
   </indexterm>

   <para>
<!--
    When a <application>PL/pgSQL</application> function has one or more
    parameters of collatable data types, a collation is identified for each
    function call depending on the collations assigned to the actual
    arguments, as described in <xref linkend="collation"/>.  If a collation is
    successfully identified (i.e., there are no conflicts of implicit
    collations among the arguments) then all the collatable parameters are
    treated as having that collation implicitly.  This will affect the
    behavior of collation-sensitive operations within the function.
    For example, consider
-->
<application>PL/pgSQL</application>関数が照合可能なデータ型のパラメータを 1つ以上保有する場合、<xref linkend="collation"/>に記述したように、実際の引数に割り当てられた照合に従って、関数呼び出し毎に照合が識別されます。
照合の識別に成功した場合（すなわち、引数の間に事実上の照合における衝突がない場合）、照合可能な全てのパラメータは暗黙の照合を有するとして扱われます。
これは関数内部において、照合に依存する操作の作用に影響します。
以下の例を考えてください。

<programlisting>
CREATE FUNCTION less_than(a text, b text) RETURNS boolean AS $$
BEGIN
    RETURN a &lt; b;
END;
$$ LANGUAGE plpgsql;

SELECT less_than(text_field_1, text_field_2) FROM table1;
SELECT less_than(text_field_1, text_field_2 COLLATE "C") FROM table1;
</programlisting>

<!--
    The first use of <function>less_than</function> will use the common collation
    of <structfield>text_field_1</structfield> and <structfield>text_field_2</structfield> for
    the comparison, while the second use will use <literal>C</literal> collation.
-->
第一の使用方法において<function>less_than</function>は、<structfield>text_field_1</structfield>と<structfield>text_field_2</structfield>の比較のための通常の照合として用いられます。
第二の使用方法においては、<literal>C</literal>照合として用いられます。
   </para>

   <para>
<!--
    Furthermore, the identified collation is also assumed as the collation of
    any local variables that are of collatable types.  Thus this function
    would not work any differently if it were written as
-->
さらに、識別された照合は、照合可能なデータ型の全ての局所変数の照合としても仮定されます。
したがって、この関数は下に記述する関数と差異なく作動します。

<programlisting>
CREATE FUNCTION less_than(a text, b text) RETURNS boolean AS $$
DECLARE
    local_a text := a;
    local_b text := b;
BEGIN
    RETURN local_a &lt; local_b;
END;
$$ LANGUAGE plpgsql;
</programlisting>
   </para>

   <para>
<!--
    If there are no parameters of collatable data types, or no common
    collation can be identified for them, then parameters and local variables
    use the default collation of their data type (which is usually the
    database's default collation, but could be different for variables of
    domain types).
-->
照合可能なデータ型のパラメータが存在しない場合、または、それらで共通する照合順序を識別できない場合、パラメータと局所変数は自身のデータ型のデフォルトの照合順序（通常これはデータベースのデフォルトの照合順序ですが、ドメイン型の変数の場合は異なるかもしれません）を使用します。
   </para>

   <para>
<!--
    A local variable of a collatable data type can have a different collation
    associated with it by including the <literal>COLLATE</literal> option in its
    declaration, for example
-->
照合可能なデータ型の局所変数は、宣言内で<literal>COLLATE</literal>オプションを含めることにより、別の照合と関連づけることができます。
例を示します。

<programlisting>
DECLARE
    local_a text COLLATE "en_US";
</programlisting>

<!--
    This option overrides the collation that would otherwise be
    given to the variable according to the rules above.
-->
このオプションは上記ルールにより、変数に他の方法で付与されるはずであった照合を上書きします。
   </para>

   <para>
<!--
    Also, of course explicit <literal>COLLATE</literal> clauses can be written inside
    a function if it is desired to force a particular collation to be used in
    a particular operation.  For example,
-->
また当然ながら、強制的に特定の操作において特定の照合順序を使用したい場合、明示的な<literal>COLLATE</literal>句を関数内部に記述することができます。
例を示します。

<programlisting>
CREATE FUNCTION less_than_c(a text, b text) RETURNS boolean AS $$
BEGIN
    RETURN a &lt; b COLLATE "C";
END;
$$ LANGUAGE plpgsql;
</programlisting>

<!--
    This overrides the collations associated with the table columns,
    parameters, or local variables used in the expression, just as would
    happen in a plain SQL command.
-->
単純な SQL コマンドで起こるように、これはテーブルの列、パラメータ、または式の中の局所変数に関連づけられた照合を上書きします
   </para>
  </sect2>
  </sect1>

  <sect1 id="plpgsql-expressions">
<!--
  <title>Expressions</title>
-->
<title>式</title>

    <para>
<!--
     All expressions used in <application>PL/pgSQL</application>
     statements are processed using the server's main
     <acronym>SQL</acronym> executor.  For example, when you write
     a <application>PL/pgSQL</application> statement like
-->
<application>PL/pgSQL</application>文で使用される式は全て、サーバの主<acronym>SQL</acronym>エクゼキュータを使用して処理されます。
例えば、以下の<application>PL/pgSQL</application>文
<synopsis>
IF <replaceable>expression</replaceable> THEN ...
</synopsis>
<!--
     <application>PL/pgSQL</application> will evaluate the expression by
     feeding a query like
-->
が記述された時、<application>PL/pgSQL</application>は
<synopsis>
SELECT <replaceable>expression</replaceable>
</synopsis>
<!--
     to the main SQL engine.  While forming the <command>SELECT</command> command,
     any occurrences of <application>PL/pgSQL</application> variable names
     are replaced by query parameters, as discussed in detail in
     <xref linkend="plpgsql-var-subst"/>.
     This allows the query plan for the <command>SELECT</command> to
     be prepared just once and then reused for subsequent
     evaluations with different values of the variables.  Thus, what
     really happens on first use of an expression is essentially a
     <command>PREPARE</command> command.  For example, if we have declared
     two integer variables <literal>x</literal> and <literal>y</literal>, and we write
-->
を主SQLエンジンに供給して、上式を評価します。
<xref linkend="plpgsql-var-subst"/>において詳細を説明したように、<command>SELECT</command>コマンドの形成において<application>PL/pgSQL</application>変数名は、その都度パラメータによって置換されます。
これにより、<command>SELECT</command>の問い合わせ計画は一度だけ準備することができ、その後の評価で異なった変数値を代入して再利用されます。
すなわち、式の最初の使用においては、実質的に<command>PREPARE</command>コマンドと同等です。
例えば、2つの整数変数<literal>x</literal>と<literal>y</literal>を宣言して、
<programlisting>
IF x &lt; y THEN ...
</programlisting>
<!--
     what happens behind the scenes is equivalent to
-->
という条件式を記述すると背後では
<programlisting>
PREPARE <replaceable>statement_name</replaceable>(integer, integer) AS SELECT $1 &lt; $2;
</programlisting>
<!--
     and then this prepared statement is <command>EXECUTE</command>d for each
     execution of the <command>IF</command> statement, with the current values
     of the <application>PL/pgSQL</application> variables supplied as
     parameter values.  Normally these details are
     not important to a <application>PL/pgSQL</application> user, but
     they are useful to know when trying to diagnose a problem.
     More information appears in <xref linkend="plpgsql-plan-caching"/>.
-->
と同等なプリペアドステートメントが作成されます。
そして<command>IF</command>文を実行する度に<application>PL/pgSQL</application>の最新の変数値をパラメータ値として供給して、このプリペアドステートメントに対して<command>EXECUTE</command>を行います。
通常この詳細は、<application>PL/pgSQL</application>ユーザにとって重要ではありませんが、この知識は問題点の解析に有用です。
それ以外の情報は、<xref linkend="plpgsql-plan-caching"/>に記述されています。
    </para>

    <para>
     Since an <replaceable>expression</replaceable> is converted to a
     <literal>SELECT</literal> command, it can contain the same clauses
     that an ordinary <literal>SELECT</literal> would, except that it
     cannot include a top-level <literal>UNION</literal>,
     <literal>INTERSECT</literal>, or <literal>EXCEPT</literal> clause.
     Thus for example one could test whether a table is non-empty with
<programlisting>
IF count(*) &gt; 0 FROM my_table THEN ...
</programlisting>
     since the <replaceable>expression</replaceable>
     between <literal>IF</literal> and <literal>THEN</literal> is parsed as
     though it were <literal>SELECT count(*) &gt; 0 FROM my_table</literal>.
     The <literal>SELECT</literal> must produce a single column, and not
     more than one row.  (If it produces no rows, the result is taken as
     NULL.)
    </para>
  </sect1>

  <sect1 id="plpgsql-statements">
<!--
  <title>Basic Statements</title>
-->
<title>基本的な文</title>

   <para>
<!--
    In this section and the following ones, we describe all the statement
    types that are explicitly understood by
    <application>PL/pgSQL</application>.
    Anything not recognized as one of these statement types is presumed
    to be an SQL command and is sent to the main database engine to execute,
    as described in <xref linkend="plpgsql-statements-general-sql"/>.
-->
本節および次節では、明示的に<application>PL/pgSQL</application>で解釈される、全ての種類の文について説明します。
   </para>

   <sect2 id="plpgsql-statements-assignment">
<!--
    <title>Assignment</title>
-->
<title>代入</title>

    <para>
<!--
     An assignment of a value to a <application>PL/pgSQL</application>
     variable is written as:
-->
値を<application>PL/pgSQL</application>変数に代入する場合は以下のように記述します。
<synopsis>
<replaceable>variable</replaceable> { := | = } <replaceable>expression</replaceable>;
</synopsis>
<!--
     As explained previously, the expression in such a statement is evaluated
     by means of an SQL <command>SELECT</command> command sent to the main
     database engine.  The expression must yield a single value (possibly
     a row value, if the variable is a row or record variable).  The target
     variable can be a simple variable (optionally qualified with a block
     name), a field of a row or record target, or an element or slice of
     an array target.  Equal (<literal>=</literal>) can be
     used instead of PL/SQL-compliant <literal>:=</literal>.
-->
上述した通り、このような文中にある式は、メインデータベースエンジンに送信される<command>SELECT</command> SQLコマンドによって評価されます。
式は1つの値を生成しなければなりません
(変数が行変数またはレコード変数の場合は行値となるかもしれません)。
対象の変数は単純な変数(ブロック名で修飾可能)、行変数またはレコード変数のフィールド、または単純な変数またはフィールドとなる配列要素とすることができます。
等号（<literal>=</literal>）がPL/SQLにおける代入記号（<literal>:=</literal>）の代わりに使用できます。
    </para>

    <para>
<!--
     If the expression's result data type doesn't match the variable's
     data type, the value will be coerced as though by an assignment cast
     (see <xref linkend="typeconv-query"/>).  If no assignment cast is known
     for the pair of data types involved, the <application>PL/pgSQL</application>
     interpreter will attempt to convert the result value textually, that is
     by applying the result type's output function followed by the variable
     type's input function.  Note that this could result in run-time errors
     generated by the input function, if the string form of the result value
     is not acceptable to the input function.
-->
式の結果データ型が変数のデータ型に一致しない場合、値は代入キャスト（<xref linkend="typeconv-query"/>を参照）と同様に変換されます。
関係する二つのデータ型のための代入キャストが無いときには、<application>PL/pgSQL</application>インタプリタは結果値を、変数のデータ型の入力関数に続けて結果データ型の出力関数を適用することで、テキストとして変換しようとします。
結果値の文字列形式が入力関数で受け付けることができない場合に、入力関数において実行時エラーが発生するかもしれないことに注意してください。
    </para>

    <para>
<!--
     Examples:
-->
例：
<programlisting>
tax := subtotal * 0.06;
my_record.user_id := 20;
my_array[j] := 20;
my_array[1:3] := array[1,2,3];
complex_array[n].realpart = 12.3;
</programlisting>
    </para>
   </sect2>

   <sect2 id="plpgsql-statements-general-sql">
    <title>Executing SQL Commands</title>

    <para>
     In general, any SQL command that does not return rows can be executed
     within a <application>PL/pgSQL</application> function just by writing
     the command.  For example, you could create and fill a table by writing
<programlisting>
CREATE TABLE mytable (id int primary key, data text);
INSERT INTO mytable VALUES (1,'one'), (2,'two');
</programlisting>
    </para>

    <para>
     If the command does return rows (for example <command>SELECT</command>,
     or <command>INSERT</command>/<command>UPDATE</command>/<command>DELETE</command>
     with <literal>RETURNING</literal>), there are two ways to proceed.
     When the command will return at most one row, or you only care about
     the first row of output, write the command as usual but add
     an <literal>INTO</literal> clause to capture the output, as described
     in <xref linkend="plpgsql-statements-sql-onerow"/>.
     To process all of the output rows, write the command as the data
     source for a <command>FOR</command> loop, as described in
     <xref linkend="plpgsql-records-iterating"/>.
    </para>

    <para>
     Usually it is not sufficient just to execute statically-defined SQL
     commands.  Typically you'll want a command to use varying data values,
     or even to vary in more fundamental ways such as by using different
     table names at different times.  Again, there are two ways to proceed
     depending on the situation.
    </para>

    <para>
<!--
     <application>PL/pgSQL</application> variable values can be
     automatically inserted into optimizable SQL commands, which
     are <command>SELECT</command>, <command>INSERT</command>,
     <command>UPDATE</command>, <command>DELETE</command>, and certain
     utility commands that incorporate one of these, such
     as <command>EXPLAIN</command> and <command>CREATE TABLE ... AS
     SELECT</command>.  In these commands,
     any <application>PL/pgSQL</application> variable name appearing
     in the command text is replaced by a query parameter, and then the
     current value of the variable is provided as the parameter value
     at run time.  This is exactly like the processing described earlier
     for expressions; for details see <xref linkend="plpgsql-var-subst"/>.
-->
コマンドテキストに現れる全ての<application>PL/pgSQL</application>変数名は、パラメータとして扱われます。
その後、実行時のパラメータ値として、その時点の変数値が提供されます。
これは以前に述べた式に関する処理と同じです。
<xref linkend="plpgsql-var-subst"/>を参照してください。
    </para>

    <para>
<!--
     When executing an optimizable SQL command in this way,
     <application>PL/pgSQL</application> may cache and re-use the execution
     plan for the command, as discussed in
     <xref linkend="plpgsql-plan-caching"/>.
-->
SQLコマンドがこのように実行されると、<xref linkend="plpgsql-plan-caching"/>に記述したように、<application>PL/pgSQL</application>はコマンドのために、実行計画をキャッシュして再利用します。
    </para>

    <para>
     Non-optimizable SQL commands (also called utility commands) are not
     capable of accepting query parameters.  So automatic substitution
     of <application>PL/pgSQL</application> variables does not work in such
     commands.  To include non-constant text in a utility command executed
     from <application>PL/pgSQL</application>, you must build the utility
     command as a string and then <command>EXECUTE</command> it, as
     discussed in <xref linkend="plpgsql-statements-executing-dyn"/>.
    </para>

    <para>
     <command>EXECUTE</command> must also be used if you want to modify
     the command in some other way than supplying a data value, for example
     by changing a table name.
    </para>

    <para>
<!--
     Sometimes it is useful to evaluate an expression or <command>SELECT</command>
     query but discard the result, for example when calling a function
     that has side-effects but no useful result value.  To do
     this in <application>PL/pgSQL</application>, use the
     <command>PERFORM</command> statement:
-->
式または<command>SELECT</command>問い合わせを評価して結果を破棄することが、役に立つ場合があります。
例えば、関数の呼び出しにおいて、副次的な成果を取得できるが、結果は無用である場合です。
このような時<application>PL/pgSQL</application>では、<command>PERFORM</command>文を使用してください。

<synopsis>
PERFORM <replaceable>query</replaceable>;
</synopsis>

<!--
     This executes <replaceable>query</replaceable> and discards the
     result.  Write the <replaceable>query</replaceable> the same
     way you would write an SQL <command>SELECT</command> command, but replace the
     initial keyword <command>SELECT</command> with <command>PERFORM</command>.
     For <command>WITH</command> queries, use <command>PERFORM</command> and then
     place the query in parentheses.  (In this case, the query can only
     return one row.)
     <application>PL/pgSQL</application> variables will be
     substituted into the query just as described above,
     and the plan is cached in the same way.  Also, the special variable
     <literal>FOUND</literal> is set to true if the query produced at
     least one row, or false if it produced no rows (see
     <xref linkend="plpgsql-statements-diagnostics"/>).
-->
これは<replaceable>query</replaceable>を実行し、その結果を破棄します。
SQLの<command>SELECT</command>文と同じ方法で<replaceable>query</replaceable>を記述しますが、最初のキーワード<command>SELECT</command>を<command>PERFORM</command>に置き換えてください。
<command>WITH</command>問い合わせに対しては、<command>PERFORM</command> を使用して、問い合わせをカッコ内に配置してください。
（この場合、問い合わせは1行だけ返すことができます。）
結果を返さないコマンドと同様に、<application>PL/pgSQL</application>変数は問い合わせ内に置き換えられ、計画は同様にキャッシュされます。
また、特殊な変数である<literal>FOUND</literal>は問い合わせ結果が1行でも生成された場合は真に設定され、生成されない場合は偽に設定されます（<xref linkend="plpgsql-statements-diagnostics"/>を参照してください）。
    </para>

    <note>
     <para>
<!--
      One might expect that writing <command>SELECT</command> directly
      would accomplish this result, but at
      present the only accepted way to do it is
      <command>PERFORM</command>.  An SQL command that can return rows,
      such as <command>SELECT</command>, will be rejected as an error
      unless it has an <literal>INTO</literal> clause as discussed in the
      next section.
-->
直接<command>SELECT</command>を記述すれば、この結果を得ることができると考えるかもしれませんが、現時点でこれを行う方法は<command>PERFORM</command>しかありません。
<command>SELECT</command>のように行を返すSQLコマンドは、エラーとして拒絶されます。
なお、<literal>INTO</literal>句を有する時は例外であり、次節で説明します。
     </para>
    </note>

    <para>
<!--
     An example:
-->
以下に例を示します。
<programlisting>
PERFORM create_mv('cs_session_page_requests_mv', my_query);
</programlisting>
    </para>
   </sect2>

   <sect2 id="plpgsql-statements-sql-onerow">
<!--
    <title>Executing a Command with a Single-Row Result</title>
-->
<title>1行の結果を返す問い合わせの実行</title>

    <indexterm zone="plpgsql-statements-sql-onerow">
     <primary>SELECT INTO</primary>
<!--
     <secondary>in PL/pgSQL</secondary>
-->
<secondary>PL/pgSQLにおける</secondary>
    </indexterm>

    <indexterm zone="plpgsql-statements-sql-onerow">
     <primary>RETURNING INTO</primary>
<!--
     <secondary>in PL/pgSQL</secondary>
-->
<secondary>PL/pgSQLにおける</secondary>
    </indexterm>

    <para>
<!--
     The result of an SQL command yielding a single row (possibly of multiple
     columns) can be assigned to a record variable, row-type variable, or list
     of scalar variables.  This is done by writing the base SQL command and
     adding an <literal>INTO</literal> clause.  For example,
-->
（多分、複数列の）1行を返すSQLコマンドの結果は、レコード変数、行型の変数、スカラ変数のリストに代入することができます。
これは、基本的なSQLコマンドを記述して、それに<literal>INTO</literal>句を追加することによって行われます。
以下に例を示します。

<synopsis>
SELECT <replaceable>select_expressions</replaceable> INTO <optional>STRICT</optional> <replaceable>target</replaceable> FROM ...;
INSERT ... RETURNING <replaceable>expressions</replaceable> INTO <optional>STRICT</optional> <replaceable>target</replaceable>;
UPDATE ... RETURNING <replaceable>expressions</replaceable> INTO <optional>STRICT</optional> <replaceable>target</replaceable>;
DELETE ... RETURNING <replaceable>expressions</replaceable> INTO <optional>STRICT</optional> <replaceable>target</replaceable>;
</synopsis>

<!--
     where <replaceable>target</replaceable> can be a record variable, a row
     variable, or a comma-separated list of simple variables and
     record/row fields.
     <application>PL/pgSQL</application> variables will be
     substituted into the rest of the command (that is, everything but the
     <literal>INTO</literal> clause) just as described above,
     and the plan is cached in the same way.
     This works for <command>SELECT</command>,
     <command>INSERT</command>/<command>UPDATE</command>/<command>DELETE</command> with
     <literal>RETURNING</literal>, and certain utility commands
     that return row sets, such as <command>EXPLAIN</command>.
     Except for the <literal>INTO</literal> clause, the SQL command is the same
     as it would be written outside <application>PL/pgSQL</application>.
-->
ここで、<replaceable>target</replaceable>はレコード変数、行変数、あるいは、単純な変数とレコード/行変数のフィールドをカンマで区切ったリストです。
<application>PL/pgSQL</application>変数により残りの問い合わせが置換され、行を返さないコマンドにおいて述べたように計画がキャッシュされます。
このように作動するのは、<literal>RETURNING</literal>を伴った<command>INSERT</command>/<command>UPDATE</command>/<command>DELETE</command>と<command>SELECT</command>および行セットの結果を返すユーティリティコマンド（例えば、<command>EXPLAIN</command>）です。
<literal>INTO</literal>句以外では、SQLコマンドは<application>PL/pgSQL</application>の外部に記述したものと同じです。
    </para>

   <tip>
    <para>
<!--
     Note that this interpretation of <command>SELECT</command> with <literal>INTO</literal>
     is quite different from <productname>PostgreSQL</productname>'s regular
     <command>SELECT INTO</command> command, wherein the <literal>INTO</literal>
     target is a newly created table.  If you want to create a table from a
     <command>SELECT</command> result inside a
     <application>PL/pgSQL</application> function, use the syntax
     <command>CREATE TABLE ... AS SELECT</command>.
-->
通常の<productname>PostgreSQL</productname>の<command>SELECT INTO</command>文では、<literal>INTO</literal>の対象は新しく作成されるテーブルです。
しかし、<literal>INTO</literal>を伴った<command>SELECT</command>では、この解釈が通常と大きく異なることに注意してください。
<application>PL/pgSQL</application>関数内部で<command>SELECT</command>の結果からテーブルを作成したい場合は、<command>CREATE TABLE ... AS SELECT</command>構文を使用してください。
    </para>
   </tip>

    <para>
<!--
     If a row variable or a variable list is used as target,
     the command's result columns
     must exactly match the structure of the target as to number and data
     types, or else a run-time error
     occurs.  When a record variable is the target, it automatically
     configures itself to the row type of the command's result columns.
-->
行または変数リストが対象に使用された場合、列数とデータ型において問い合わせの結果と対象の構造が正確に一致しなければなりません。
さもないと、実行時エラーが発生します。
レコード変数が対象の場合は、問い合わせ結果の列の行型に自身を自動的に設定します。
    </para>

    <para>
<!--
     The <literal>INTO</literal> clause can appear almost anywhere in the SQL
     command.  Customarily it is written either just before or just after
     the list of <replaceable>select_expressions</replaceable> in a
     <command>SELECT</command> command, or at the end of the command for other
     command types.  It is recommended that you follow this convention
     in case the <application>PL/pgSQL</application> parser becomes
     stricter in future versions.
-->
<literal>INTO</literal>句はSQLコマンドのほとんど任意の場所に記述することができます。
習慣的には、<command>SELECT</command>文においては<replaceable>select_expressions</replaceable>の直前または直後に、他のコマンドにおいては文の終わりに記述されます。
将来のバージョンで<application>PL/pgSQL</application>のパーサがより厳格になる場合に備えて、この習慣に従うことを推奨します。
    </para>

    <para>
<!--
     If <literal>STRICT</literal> is not specified in the <literal>INTO</literal>
     clause, then <replaceable>target</replaceable> will be set to the first
     row returned by the command, or to nulls if the command returned no rows.
     (Note that <quote>the first row</quote> is not
     well-defined unless you've used <literal>ORDER BY</literal>.)  Any result rows
     after the first row are discarded.
     You can check the special <literal>FOUND</literal> variable (see
     <xref linkend="plpgsql-statements-diagnostics"/>) to
     determine whether a row was returned:
-->
<literal>INTO</literal>句において<literal>STRICT</literal>が指定されない場合、<replaceable>target</replaceable>は問い合わせが返す最初の行となり、行を返さない時はNULLとなります。
（<quote>最初の行</quote>とは<literal>ORDER BY</literal>を使用しないと定義できないことに注意してください。）
2行目以降の行の結果は、全て破棄されます。
以下のように、特殊な<literal>FOUND</literal>変数（<xref linkend="plpgsql-statements-diagnostics"/>を参照してください）を調べて、行が返されたかどうかを検査することができます。

<programlisting>
SELECT * INTO myrec FROM emp WHERE empname = myname;
IF NOT FOUND THEN
    RAISE EXCEPTION 'employee % not found', myname;
END IF;
</programlisting>

<!--
     If the <literal>STRICT</literal> option is specified, the command must
     return exactly one row or a run-time error will be reported, either
     <literal>NO_DATA_FOUND</literal> (no rows) or <literal>TOO_MANY_ROWS</literal>
     (more than one row). You can use an exception block if you wish
     to catch the error, for example:
-->
<literal>STRICT</literal>オプションが指定された場合、問い合わせは正確に1行を返さなければなりません。
さもないと、行がない時は<literal>NO_DATA_FOUND</literal>、2行以上が返った時は<literal>TOO_MANY_ROWS</literal>という実行時エラーが生じます。
エラーを捕捉したい時は、例外ブロックを使用できます。
以下に例を示します。

<programlisting>
BEGIN
    SELECT * INTO STRICT myrec FROM emp WHERE empname = myname;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RAISE EXCEPTION 'employee % not found', myname;
        WHEN TOO_MANY_ROWS THEN
            RAISE EXCEPTION 'employee % not unique', myname;
END;
</programlisting>
<!--
     Successful execution of a command with <literal>STRICT</literal>
     always sets <literal>FOUND</literal> to true.
-->
<literal>STRICT</literal>を指定したコマンドが成功すると、<literal>FOUND</literal>変数は常に真に設定されます。
    </para>

    <para>
<!--
     For <command>INSERT</command>/<command>UPDATE</command>/<command>DELETE</command> with
     <literal>RETURNING</literal>, <application>PL/pgSQL</application> reports
     an error for more than one returned row, even when
     <literal>STRICT</literal> is not specified.  This is because there
     is no option such as <literal>ORDER BY</literal> with which to determine
     which affected row should be returned.
-->
<application>PL/pgSQL</application>は<literal>STRICT</literal>が指定されない場合でも、<literal>RETURNING</literal>を伴った<command>INSERT</command>/<command>UPDATE</command>/<command>DELETE</command>が2行以上を返した時は、エラーとなります。
なぜなら、どの1行を返すか決定する<literal>ORDER BY</literal>のようなオプションが存在しないからです。
    </para>

    <para>
<!--
     If <literal>print_strict_params</literal> is enabled for the function,
     then when an error is thrown because the requirements
     of <literal>STRICT</literal> are not met, the <literal>DETAIL</literal> part of
     the error message will include information about the parameters
     passed to the command.
     You can change the <literal>print_strict_params</literal>
     setting for all functions by setting
     <varname>plpgsql.print_strict_params</varname>, though only subsequent
     function compilations will be affected.  You can also enable it
     on a per-function basis by using a compiler option, for example:
-->
<literal>print_strict_params</literal>が関数に利用可能であり、かつ要求がSTRICTでないためにエラーが発生した場合、エラーメッセージの<literal>STRICT</literal>部分は問い合わせに渡したパラメータに関する情報を含みます。
<varname>plpgsql.print_strict_params</varname>を指定することにより、全ての関数の<literal>print_strict_params</literal>設定を変更できます。
しかし、変更後にコンパイルした関数にだけ有効です。
コンパイルオプションを使用すれば、個々の関数を基準とした設定変更もできます。
例を示します。
<programlisting>
CREATE FUNCTION get_userid(username text) RETURNS int
AS $$
#print_strict_params on
DECLARE
userid int;
BEGIN
    SELECT users.userid INTO STRICT userid
        FROM users WHERE users.username = get_userid.username;
    RETURN userid;
END;
$$ LANGUAGE plpgsql;
</programlisting>
<!--
     On failure, this function might produce an error message such as
-->
失敗したとき、この関数は次のようなエラーメッセージを生成します。
<programlisting>
ERROR:  query returned no rows
DETAIL:  parameters: $1 = 'nosuchuser'
CONTEXT:  PL/pgSQL function get_userid(text) line 6 at SQL statement
</programlisting>
    </para>

    <note>
     <para>
<!--
      The <literal>STRICT</literal> option matches the behavior of
      Oracle PL/SQL's <command>SELECT INTO</command> and related statements.
-->
<literal>STRICT</literal>オプションは、OracleのPL/SQLの<command>SELECT INTO</command>および関連した文に対応します。
     </para>
    </note>

   </sect2>

   <sect2 id="plpgsql-statements-executing-dyn">
<!--
    <title>Executing Dynamic Commands</title>
-->
<title>動的コマンドの実行</title>

    <para>
<!--
     Oftentimes you will want to generate dynamic commands inside your
     <application>PL/pgSQL</application> functions, that is, commands
     that will involve different tables or different data types each
     time they are executed.  <application>PL/pgSQL</application>'s
     normal attempts to cache plans for commands (as discussed in
     <xref linkend="plpgsql-plan-caching"/>) will not work in such
     scenarios.  To handle this sort of problem, the
     <command>EXECUTE</command> statement is provided:
-->
<application>PL/pgSQL</application>関数の内部で、動的コマンド、つまり実行する度に別のテーブルや別のデータ型を使用するコマンドを生成したいということがよくあるでしょう。
<application>PL/pgSQL</application>が通常行うコマンドの計画のキャッシュは（<xref linkend="plpgsql-plan-caching"/>で述べたように）このような状況では動作しません。
この種の問題を扱うために、以下の<command>EXECUTE</command>文が用意されています。

<synopsis>
EXECUTE <replaceable class="command">command-string</replaceable> <optional> INTO <optional>STRICT</optional> <replaceable>target</replaceable> </optional> <optional> USING <replaceable>expression</replaceable> <optional>, ... </optional> </optional>;
</synopsis>

<!--
     where <replaceable>command-string</replaceable> is an expression
     yielding a string (of type <type>text</type>) containing the
     command to be executed.  The optional <replaceable>target</replaceable>
     is a record variable, a row variable, or a comma-separated list of
     simple variables and record/row fields, into which the results of
     the command will be stored.  The optional <literal>USING</literal> expressions
     supply values to be inserted into the command.
-->
ここで、<replaceable>command-string</replaceable>は実行されるコマンドを含む（<type>text</type>型の）文字列を生成する式です。
オプションの<replaceable>target</replaceable>はレコード変数、行変数、あるいは、単純な変数とレコード/行変数のフィールドをカンマで区切ったリストで、その中にコマンドの結果が格納されます。
オプションの<literal>USING</literal>式は コマンドに挿入される値を与えます。
    </para>

    <para>
<!--
     No substitution of <application>PL/pgSQL</application> variables is done on the
     computed command string.  Any required variable values must be inserted
     in the command string as it is constructed; or you can use parameters
     as described below.
-->
<application>PL/pgSQL</application>変数は、この演算用のコマンド文字列へ置換されません。
必要な変数の値はすべてコマンド文字列を作成する時に埋め込まなければなりません。
もしくは、以下に説明するパラメータを使用することもできます。
    </para>

    <para>
<!--
     Also, there is no plan caching for commands executed via
     <command>EXECUTE</command>.  Instead, the command is always planned
     each time the statement is run. Thus the command
     string can be dynamically created within the function to perform
     actions on different tables and columns.
-->
また、<command>EXECUTE</command>を介して実行されるコマンド計画をキャッシュすることはありません。
代わりに、コマンドは文が実行されるとき常に計画されます。
したがって、異なるテーブルと列に対する操作を実行できるように、コマンド文字列を関数内部で動的に作成することができます。
    </para>

    <para>
<!--
     The <literal>INTO</literal> clause specifies where the results of
     an SQL command returning rows should be assigned. If a row variable
     or variable list is provided, it must exactly match the structure
     of the command's results; if a
     record variable is provided, it will configure itself to match the
     result structure automatically. If multiple rows are returned,
     only the first will be assigned to the <literal>INTO</literal>
     variable(s). If no rows are returned, NULL is assigned to the
     <literal>INTO</literal> variable(s). If no <literal>INTO</literal>
     clause is specified, the command results are discarded.
-->
<literal>INTO</literal>句は、行を返すSQLコマンドの結果を代入するべき場所を指定します。
行または変数リストが用いられる時、それは問い合わせの結果の構造と正確に一致しなければなりません
(レコード変数が使用される時、自動的に結果の構造と一致するように自身を構築させます)。
複数の行が返された時、最初の行だけが<literal>INTO</literal>変数に代入されます。
1行も返されない時、NULL が<literal>INTO</literal>変数に代入されます。
<literal>INTO</literal>句が指定されない時、問い合わせの結果は捨てられます。
    </para>

    <para>
<!--
     If the <literal>STRICT</literal> option is given, an error is reported
     unless the command produces exactly one row.
-->
<literal>STRICT</literal>オプションが指定された時、問い合わせの結果が正確に1行の場合を除き、エラーとなります。
    </para>

    <para>
<!--
     The command string can use parameter values, which are referenced
     in the command as <literal>$1</literal>, <literal>$2</literal>, etc.
     These symbols refer to values supplied in the <literal>USING</literal>
     clause.  This method is often preferable to inserting data values
     into the command string as text: it avoids run-time overhead of
     converting the values to text and back, and it is much less prone
     to SQL-injection attacks since there is no need for quoting or escaping.
     An example is:
-->
コマンド文字列はパラメータ値を使用可能で、それらは<literal>$1</literal>、<literal>$2</literal>等としてコマンドの中で参照されます。
これらの記号は<literal>USING</literal>で与えられる値を参照します。
この方式はデータの値をテキストとしてコマンド文字列の中に挿入する際、よく好まれます。
それは値をテキストに変換、そしてその逆を行う場合の実行時オーバーヘッドを防止するとともに、引用符付けするとか、エスケープをする必要がないため、SQLインジェクション攻撃に対してより襲われにくくなります。
以下に例を示します。
<programlisting>
EXECUTE 'SELECT count(*) FROM mytable WHERE inserted_by = $1 AND inserted &lt;= $2'
   INTO c
   USING checked_user, checked_date;
</programlisting>
    </para>

    <para>
<!--
     Note that parameter symbols can only be used for data values
     &mdash; if you want to use dynamically determined table or column
     names, you must insert them into the command string textually.
     For example, if the preceding query needed to be done against a
     dynamically selected table, you could do this:
-->
パラメータ記号はデータ値のみ使用可能です。
もし動的に決定されるテーブルや列名を使用したい場合、テキストでコマンド文字列にそれらを挿入する必要があります。
例えば、先行する問い合わせが、動的に選択されたテーブルに対して処理される必要がある時は、次のようにします。
<programlisting>
EXECUTE 'SELECT count(*) FROM '
    || quote_ident(tabname)
    || ' WHERE inserted_by = $1 AND inserted &lt;= $2'
   INTO c
   USING checked_user, checked_date;
</programlisting>
<!--
     A cleaner approach is to use <function>format()</function>'s <literal>%I</literal>
     specification to insert table or column names with automatic quoting:
-->
よりきれいな方法は<function>format()</function>の<literal>%I</literal>指定をテーブル名または列名に使うことです（改行で分かれた文字列は連結されます）。
<programlisting>
EXECUTE format('SELECT count(*) FROM %I '
   'WHERE inserted_by = $1 AND inserted &lt;= $2', tabname)
   INTO c
   USING checked_user, checked_date;
</programlisting>
     (This example relies on the SQL rule that string literals separated by a
     newline are implicitly concatenated.)
    </para>

    <para>
<!--
     Another restriction on parameter symbols is that they only work in
     optimizable SQL commands
     (<command>SELECT</command>, <command>INSERT</command>, <command>UPDATE</command>,
     <command>DELETE</command>, and certain commands containing one of these).
     In other statement
     types (generically called utility statements), you must insert
     values textually even if they are just data values.
-->
他にもパラメータ記号は<command>SELECT</command>、<command>INSERT</command>、<command>UPDATE</command>、<command>DELETE</command>コマンドでしか動作しない、という制限があります。
他の種類の文(一般的にユーティリティ文と呼ばれます)では、単なるデータ値であったとしてもテキストの値として埋め込まなければなりません。
    </para>

    <para>
<!--
     An <command>EXECUTE</command> with a simple constant command string and some
     <literal>USING</literal> parameters, as in the first example above, is
     functionally equivalent to just writing the command directly in
     <application>PL/pgSQL</application> and allowing replacement of
     <application>PL/pgSQL</application> variables to happen automatically.
     The important difference is that <command>EXECUTE</command> will re-plan
     the command on each execution, generating a plan that is specific
     to the current parameter values; whereas
     <application>PL/pgSQL</application> may otherwise create a generic plan
     and cache it for re-use.  In situations where the best plan depends
     strongly on the parameter values, it can be helpful to use
     <command>EXECUTE</command> to positively ensure that a generic plan is not
     selected.
-->
最初の例のように、単純な定数コマンドと<literal>USING</literal>パラメータを使った<command>EXECUTE</command>は、コマンドを直接<application>PL/pgSQL</application>で書いて、<application>PL/pgSQL</application>変数を自動的に置換したものと機能的に同じです。
重要な差異として、<command>EXECUTE</command>が現在のパラメータ値に特化した計画を生成し、コマンドを実行する度に計画を再作成することです。
一方、<application>PL/pgSQL</application>はその他に汎用的な計画を作成し、再使用に備えキャッシュします。
最適な計画がパラメータ値に大きく依存する場合、汎用的な計画が選択されないことを確保するために、<command>EXECUTE</command>の使用は助けになります。
    </para>

    <para>
<!--
     <command>SELECT INTO</command> is not currently supported within
     <command>EXECUTE</command>; instead, execute a plain <command>SELECT</command>
     command and specify <literal>INTO</literal> as part of the <command>EXECUTE</command>
     itself.
-->
<command>SELECT INTO</command>は<command>EXECUTE</command>では現在サポートされません。
代わりに、普通の<command>SELECT</command>コマンドを実行し、<command>EXECUTE</command>の一部として<literal>INTO</literal>を記述してください。
    </para>

   <note>
    <para>
<!--
     The <application>PL/pgSQL</application>
     <command>EXECUTE</command> statement is not related to the
     <link linkend="sql-execute"><command>EXECUTE</command></link> SQL
     statement supported by the
     <productname>PostgreSQL</productname> server. The server's
     <command>EXECUTE</command> statement cannot be used directly within
     <application>PL/pgSQL</application> functions (and is not needed).
-->
<application>PL/pgSQL</application> <command>EXECUTE</command>文は<productname>PostgreSQL</productname>サーバでサポートされている<xref linkend="sql-execute"/>SQL文とは関連がありません。
サーバの<command>EXECUTE</command>文は<application>PL/pgSQL</application>関数内で使用することはできません（使用する必要もありません）。
    </para>
   </note>

   <example id="plpgsql-quote-literal-example">
<!--
   <title>Quoting Values in Dynamic Queries</title>
-->
<title>動的問い合わせの中の値の引用符付け</title>

    <indexterm>
     <primary>quote_ident</primary>
<!--
     <secondary>use in PL/pgSQL</secondary>
-->
<secondary>PL/pgSQLでの使用</secondary>
    </indexterm>

    <indexterm>
     <primary>quote_literal</primary>
<!--
     <secondary>use in PL/pgSQL</secondary>
-->
<secondary>PL/pgSQLでの使用</secondary>
    </indexterm>

    <indexterm>
     <primary>quote_nullable</primary>
<!--
     <secondary>use in PL/pgSQL</secondary>
-->
<secondary>PL/pgSQLでの使用</secondary>
    </indexterm>

    <indexterm>
     <primary>format</primary>
<!--
     <secondary>use in PL/pgSQL</secondary>
-->
<secondary>PL/pgSQLでの使用</secondary>
    </indexterm>

    <para>
<!--
     When working with dynamic commands you will often have to handle escaping
     of single quotes.  The recommended method for quoting fixed text in your
     function body is dollar quoting.  (If you have legacy code that does
     not use dollar quoting, please refer to the
     overview in <xref linkend="plpgsql-quote-tips"/>, which can save you
     some effort when translating said code to a more reasonable scheme.)
-->
動的コマンドを使用する時、しばしば単一引用符をエスケープしなければなりません。
関数本体における固定のテキストを引用符付けする推奨方法は、ドル引用符を使用する方法です。
（ドル引用符を用いない旧式のコードを保有している場合は、<xref linkend="plpgsql-quote-tips"/>の概要を参照することが、理解しやすいコードへの変換作業の手助けになります）。
    </para>

    <para>
<!--
     Dynamic values require careful handling since they might contain
     quote characters.
     An example using <function>format()</function> (this assumes that you are
     dollar quoting the function body so quote marks need not be doubled):
-->
動的な値は引用符を含んでいる可能性があるので注意深い取り扱いが必要です。
以下に<function>format()</function>を使う例を示します（ここでは関数にドル引用符を用いる方法を使用すると仮定しているので、引用符を二重化する必要はありません）。
<programlisting>
EXECUTE format('UPDATE tbl SET %I = $1 '
   'WHERE key = $2', colname) USING newvalue, keyvalue;
</programlisting>
<!--
     It is also possible to call the quoting functions directly:
-->
クオート関数を直接呼び出すことも可能です。
<programlisting>
EXECUTE 'UPDATE tbl SET '
        || quote_ident(colname)
        || ' = '
        || quote_literal(newvalue)
        || ' WHERE key = '
        || quote_literal(keyvalue);
</programlisting>
    </para>

    <para>
<!--
     This example demonstrates the use of the
     <function>quote_ident</function> and
     <function>quote_literal</function> functions (see <xref
     linkend="functions-string"/>).  For safety, expressions containing column
     or table identifiers should be passed through
     <function>quote_ident</function> before insertion in a dynamic query.
     Expressions containing values that should be literal strings in the
     constructed command should be passed through <function>quote_literal</function>.
     These functions take the appropriate steps to return the input text
     enclosed in double or single quotes respectively, with any embedded
     special characters properly escaped.
-->
この例は、<function>quote_ident</function>と<function>quote_literal</function>関数（<xref linkend="functions-string"/>を参照）の使用方法を示しています。
安全のため、列またはテーブル識別子を含む式は動的問い合わせに挿入する前に<function>quote_ident</function>を介して渡されなくてはなりません。
組み立てられるコマンドの中のリテラル文字列となるはずの値を含む式は、<function>quote_literal</function>を介して渡されなければなりません。
これらの関数は、すべての特殊文字を適切にエスケープして埋め込んだ、二重引用符または単一引用符で囲まれた入力テキストを返すために、適切な手順を踏みます。
    </para>

    <para>
<!--
     Because <function>quote_literal</function> is labeled
     <literal>STRICT</literal>, it will always return null when called with a
     null argument.  In the above example, if <literal>newvalue</literal> or
     <literal>keyvalue</literal> were null, the entire dynamic query string would
     become null, leading to an error from <command>EXECUTE</command>.
     You can avoid this problem by using the <function>quote_nullable</function>
     function, which works the same as <function>quote_literal</function> except that
     when called with a null argument it returns the string <literal>NULL</literal>.
     For example,
-->
<function>quote_literal</function>は<literal>STRICT</literal>ラベル付けされているため、NULL引数で呼び出された場合、常にNULLを返します。
上記の例で、<literal>newvalue</literal>または<literal>keyvalue</literal>がNULLの場合、動的問合せ文字列全体がNULLとなり、<command>EXECUTE</command>からのエラーを導きます。
<function>quote_nullable</function>関数を使用することで、この問題を回避することができます。
その動作は、NULL引数付きで呼び出された場合に文字列<literal>NULL</literal>を返すことを除いて<function>quote_literal</function>と同一です。
以下に例を示します。
<programlisting>
EXECUTE 'UPDATE tbl SET '
        || quote_ident(colname)
        || ' = '
        || quote_nullable(newvalue)
        || ' WHERE key = '
        || quote_nullable(keyvalue);
</programlisting>
<!--
     If you are dealing with values that might be null, you should usually
     use <function>quote_nullable</function> in place of <function>quote_literal</function>.
-->
NULLの可能性のある値を処理するのであれば、通常<function>quote_literal</function>の代わりに<function>quote_nullable</function>を使用しなければなりません。
    </para>

    <para>
<!--
     As always, care must be taken to ensure that null values in a query do
     not deliver unintended results.  For example the <literal>WHERE</literal> clause
-->
いつものように、問い合わせの中のNULL値は意図しない結果を確実にもたらさないよう配慮をしなければなりません。
例えば次のような<literal>WHERE</literal>句の結果はどうなるのでしょう。
<programlisting>
'WHERE key = ' || quote_nullable(keyvalue)
</programlisting>
<!--
     will never succeed if <literal>keyvalue</literal> is null, because the
     result of using the equality operator <literal>=</literal> with a null operand
     is always null.  If you wish null to work like an ordinary key value,
     you would need to rewrite the above as
-->
これは<literal>keyvalue</literal>がNULLである限り成功しません。
その理由は、等価演算子<literal>=</literal>をNULLオペランドで使用するとその結果は常にNULLとなるからです。
NULLを通常のキーの値と同じように動作させたい場合、上記を、以下のように書き換えなければなりません。
<programlisting>
'WHERE key IS NOT DISTINCT FROM ' || quote_nullable(keyvalue)
</programlisting>
<!--
     (At present, <literal>IS NOT DISTINCT FROM</literal> is handled much less
     efficiently than <literal>=</literal>, so don't do this unless you must.
     See <xref linkend="functions-comparison"/> for
     more information on nulls and <literal>IS DISTINCT</literal>.)
-->
（現時点では、<literal>IS NOT DISTINCT FROM</literal>は<literal>=</literal>よりもより効率性が少なく扱われますので、必要に迫られた場合以外は行わないようにしてください。
NULLと<literal>IS DISTINCT</literal>についての更なる情報は<xref linkend="functions-comparison"/>を参照してください。）
    </para>

    <para>
<!--
     Note that dollar quoting is only useful for quoting fixed text.
     It would be a very bad idea to try to write this example as:
-->
ドル引用符は固定のテキストを引用符付けする場合のみ有用であるということに注意してください。
この例を次のように記述するのは非常に悪い考えです。
<programlisting>
EXECUTE 'UPDATE tbl SET '
        || quote_ident(colname)
        || ' = $$'
        || newvalue
        || '$$ WHERE key = '
        || quote_literal(keyvalue);
</programlisting>
<!--
     because it would break if the contents of <literal>newvalue</literal>
     happened to contain <literal>$$</literal>.  The same objection would
     apply to any other dollar-quoting delimiter you might pick.
     So, to safely quote text that is not known in advance, you
     <emphasis>must</emphasis> use <function>quote_literal</function>,
     <function>quote_nullable</function>, or <function>quote_ident</function>, as appropriate.
-->
なぜなら、<literal>newvalue</literal>の内容がたまたま<literal>$$</literal>を含む時は、途中で次の処理へ移ってしまうからです。
同様の不測事態は、ドル引用符の他の区切り文字を選んだ時も起こります。
したがって、テキストの内容を把握していない時は、安全にテキストを引用符付けするために、<function>quote_literal</function>、<function>quote_nullable</function>、または<function>quote_ident</function>関数を適切に使用<emphasis>しなければなりません</emphasis>。
    </para>

    <para>
<!--
     Dynamic SQL statements can also be safely constructed using the
     <function>format</function> function (see <xref
     linkend="functions-string-format"/>). For example:
-->
動的なSQL文も<function>format</function>関数（<xref linkend="functions-string-format"/>を参照）を使って安全に作ることができます。例を示します。
<programlisting>
EXECUTE format('UPDATE tbl SET %I = %L '
   'WHERE key = %L', colname, newvalue, keyvalue);
</programlisting>
<!--
     <literal>%I</literal> is equivalent to <function>quote_ident</function>, and
     <literal>%L</literal> is equivalent to <function>quote_nullable</function>.
     The <function>format</function> function can be used in conjunction with
     the <literal>USING</literal> clause:
-->
<literal>%I</literal>は<function>quote_ident</function>と同等で、<literal>%L</literal>は<function>quote_nullable</function>と同等です。
<function>format</function>関数は<literal>USING</literal>句と共に使用できます。
<programlisting>
EXECUTE format('UPDATE tbl SET %I = $1 WHERE key = $2', colname)
   USING newvalue, keyvalue;
</programlisting>
<!--
     This form is better because the variables are handled in their native
     data type format, rather than unconditionally converting them to
     text and quoting them via <literal>%L</literal>.  It is also more efficient.
-->
変数が、無条件にテキストに変換されて<literal>%L</literal>で引用符付けされることなく、固有のデータ形式で処理されるため、この形式はより優れています。
    </para>
   </example>

    <para>
<!--
     A much larger example of a dynamic command and
     <command>EXECUTE</command> can be seen in <xref
     linkend="plpgsql-porting-ex2"/>, which builds and executes a
     <command>CREATE FUNCTION</command> command to define a new function.
-->
動的問い合わせと<command>EXECUTE</command>の長大な例は<xref linkend="plpgsql-porting-ex2"/>にあります。
それは新しい関数を定義するために<command>CREATE FUNCTION</command>コマンドを組み立て実行するものです。
    </para>
   </sect2>

   <sect2 id="plpgsql-statements-diagnostics">
<!--
    <title>Obtaining the Result Status</title>
-->
<title>結果ステータスの取得</title>

    <para>
<!--
     There are several ways to determine the effect of a command. The
     first method is to use the <command>GET DIAGNOSTICS</command>
     command, which has the form:
-->
コマンドの効果を判断するにはいくつか方法があります。
最初の方法は以下のような形式の<command>GET DIAGNOSTICS</command>を使用する方法です。

<synopsis>
GET <optional> CURRENT </optional> DIAGNOSTICS <replaceable>variable</replaceable> { = | := } <replaceable>item</replaceable> <optional> , ... </optional>;
</synopsis>

<!--
     This command allows retrieval of system status indicators.
     <literal>CURRENT</literal> is a noise word (but see also <command>GET STACKED
     DIAGNOSTICS</command> in <xref linkend="plpgsql-exception-diagnostics"/>).
     Each <replaceable>item</replaceable> is a key word identifying a status
     value to be assigned to the specified <replaceable>variable</replaceable>
     (which should be of the right data type to receive it).  The currently
     available status items are shown
     in <xref linkend="plpgsql-current-diagnostics-values"/>.  Colon-equal
     (<literal>:=</literal>) can be used instead of the SQL-standard <literal>=</literal>
     token.  An example:
-->
このコマンドによってシステムステータスインジケータを取り出すことができます。
<literal>CURRENT</literal>は無意味な単語です（しかし<xref linkend="plpgsql-exception-diagnostics"/>の<command>GET STACKED DIAGNOSTICS</command>も参照してください）。
各<replaceable>item</replaceable>は、指定された<replaceable>variable</replaceable>（これは受け取るために正しいデータ型でなければなりません）に代入されるステータス値を識別するキーワードです。
現在使用可能なステータス項目は、<xref linkend="plpgsql-current-diagnostics-values"/>で示されています。
代入記号（<literal>:=</literal>）が標準SQLにおける等号（<literal>=</literal>）の代わりに使用できます。
以下に例を示します。
<programlisting>
GET DIAGNOSTICS integer_var = ROW_COUNT;
</programlisting>
    </para>

     <table id="plpgsql-current-diagnostics-values">
<!--
      <title>Available Diagnostics Items</title>
-->
      <title>使用できるステータス項目</title>
      <tgroup cols="3">
       <colspec colname="col1" colwidth="1*"/>
       <colspec colname="col2" colwidth="1*"/>
       <colspec colname="col3" colwidth="2*"/>
       <thead>
        <row>
<!--
         <entry>Name</entry>
         <entry>Type</entry>
         <entry>Description</entry>
-->
         <entry>名前</entry>
         <entry>型</entry>
         <entry>説明</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry><varname>ROW_COUNT</varname></entry>
         <entry><type>bigint</type></entry>
<!--
         <entry>the number of rows processed by the most
          recent <acronym>SQL</acronym> command</entry>
-->
         <entry>最後の<acronym>SQL</acronym>コマンドにより処理された行数</entry>
        </row>
        <row>
         <entry><literal>PG_CONTEXT</literal></entry>
         <entry><type>text</type></entry>
<!--
         <entry>line(s) of text describing the current call stack
          (see <xref linkend="plpgsql-call-stack"/>)</entry>
-->
         <entry>現在の呼び出しスタックを記述したテキストの行
          （<xref linkend="plpgsql-call-stack"/>を参照）</entry>
        </row>
       </tbody>
      </tgroup>
     </table>

    <para>
<!--
     The second method to determine the effects of a command is to check the
     special variable named <literal>FOUND</literal>, which is of
     type <type>boolean</type>.  <literal>FOUND</literal> starts out
     false within each <application>PL/pgSQL</application> function call.
     It is set by each of the following types of statements:
-->
コマンドの効果を判断する2番目の方法は、<literal>FOUND</literal>という<type>boolean</type>型の特殊な変数を検査することです。
<application>PL/pgSQL</application>の各関数呼び出しで使用される際、<literal>FOUND</literal>は最初は偽に設定されています。
以下のように、それぞれの文の種類によって設定が変更されます。

         <itemizedlist>
          <listitem>
           <para>
<!--
            A <command>SELECT INTO</command> statement sets
            <literal>FOUND</literal> true if a row is assigned, false if no
            row is returned.
-->
<command>SELECT INTO</command>文は、行が代入された場合は真、返されなかった場合は偽を<literal>FOUND</literal>に設定します。
           </para>
          </listitem>
          <listitem>
           <para>
<!--
            A <command>PERFORM</command> statement sets <literal>FOUND</literal>
            true if it produces (and discards) one or more rows, false if
            no row is produced.
-->
<command>PERFORM</command>文は、1つ以上の行が生成（破棄）された場合は真、まったく生成されなかった場合は偽を<literal>FOUND</literal>に設定します。
           </para>
          </listitem>
          <listitem>
           <para>
<!--
            <command>UPDATE</command>, <command>INSERT</command>, and <command>DELETE</command>
            statements set <literal>FOUND</literal> true if at least one
            row is affected, false if no row is affected.
-->
<command>UPDATE</command>、<command>INSERT</command>、および<command>DELETE</command>文は、少なくとも1行が影響を受けた場合は真、まったく影響を受けなかった場合は偽を<literal>FOUND</literal>に設定します。
           </para>
          </listitem>
          <listitem>
           <para>
<!--
            A <command>FETCH</command> statement sets <literal>FOUND</literal>
            true if it returns a row, false if no row is returned.
-->
<command>FETCH</command>文は、行が返された場合は真、まったく返されなかった場合は偽を<literal>FOUND</literal>に設定します。
           </para>
          </listitem>
          <listitem>
           <para>
<!--
            A <command>MOVE</command> statement sets <literal>FOUND</literal>
            true if it successfully repositions the cursor, false otherwise.
-->
<command>MOVE</command>文は、カーソルの移動が成功した場合は真、失敗した場合は偽を<literal>FOUND</literal>に設定します。
           </para>
          </listitem>
          <listitem>
           <para>
<!--
            A <command>FOR</command> or <command>FOREACH</command> statement sets
            <literal>FOUND</literal> true
            if it iterates one or more times, else false.
            <literal>FOUND</literal> is set this way when the
            loop exits; inside the execution of the loop,
            <literal>FOUND</literal> is not modified by the
            loop statement, although it might be changed by the
            execution of other statements within the loop body.
-->
<command>FOR</command>文または<command>FOREACH</command>文は、1回以上繰り返しが行われた場合は真、行われなかった場合は偽を<literal>FOUND</literal>に設定します。
<literal>FOUND</literal>はループが終了した際、このように設定されます。
ループ実行中はループ文による<literal>FOUND</literal>の変更はありません。
ただし、ループ本体内の他種類の文を実行することによって、変更されるかもしれません。
           </para>
          </listitem>
          <listitem>
           <para>
<!--
            <command>RETURN QUERY</command> and <command>RETURN QUERY
            EXECUTE</command> statements set <literal>FOUND</literal>
            true if the query returns at least one row, false if no row
            is returned.
-->
<command>RETURN QUERY</command>と<command>RETURN QUERY EXECUTE</command>文は、問い合わせが行を１つでも返せば真、行が返されなければ偽を<literal>FOUND</literal>に設定します。
           </para>
          </listitem>
         </itemizedlist>

<!--
     Other <application>PL/pgSQL</application> statements do not change
     the state of <literal>FOUND</literal>.
     Note in particular that <command>EXECUTE</command>
     changes the output of <command>GET DIAGNOSTICS</command>, but
     does not change <literal>FOUND</literal>.
-->
他の<application>PL/pgSQL</application>文は<literal>FOUND</literal>の状態を変更しません。
特に、<command>EXECUTE</command>は<command>GET DIAGNOSTICS</command>の出力を変更しますが、<literal>FOUND</literal>を変更しないことに注意してください。
    </para>

    <para>
<!--
     <literal>FOUND</literal> is a local variable within each
     <application>PL/pgSQL</application> function; any changes to it
     affect only the current function.
-->
<literal>FOUND</literal>はそれぞれの<application>PL/pgSQL</application>関数内部のローカル変数です。
<literal>FOUND</literal>に対して行われた全ての変更は、現在の関数にのみ影響します。
    </para>

   </sect2>

   <sect2 id="plpgsql-statements-null">
<!--
    <title>Doing Nothing At All</title>
-->
<title>まったく何もしない</title>

    <para>
<!--
     Sometimes a placeholder statement that does nothing is useful.
     For example, it can indicate that one arm of an if/then/else
     chain is deliberately empty.  For this purpose, use the
     <command>NULL</command> statement:
-->
何もしないプレースホルダ文が有用になることがあります。
例えば、IF/THEN/ELSE文の一部が空文であることを明示したい時です。
このような目的には<command>NULL</command>文を使用します。

<synopsis>
NULL;
</synopsis>
    </para>

    <para>
<!--
     For example, the following two fragments of code are equivalent:
-->
例えば、次の2つのコードは同等です。
<programlisting>
BEGIN
    y := x / 0;
EXCEPTION
    WHEN division_by_zero THEN
<!--
        NULL;  &#045;- ignore the error
-->
        NULL;  -- 誤りを無視する
END;
</programlisting>

<programlisting>
BEGIN
    y := x / 0;
EXCEPTION
<!--
    WHEN division_by_zero THEN  &#045;- ignore the error
-->
    WHEN division_by_zero THEN  -- 誤りを無視する
END;
</programlisting>
<!--
     Which is preferable is a matter of taste.
-->
どちらが望ましいと思うかは、好みの問題です。
    </para>

    <note>
     <para>
<!--
      In Oracle's PL/SQL, empty statement lists are not allowed, and so
      <command>NULL</command> statements are <emphasis>required</emphasis> for situations
      such as this.  <application>PL/pgSQL</application> allows you to
      just write nothing, instead.
-->
OracleのPL/SQLでは無記述の文は許されませんので、こうした状況では<command>NULL</command>文が<emphasis>必須</emphasis>です。
しかし<application>PL/pgSQL</application>では無記述の文が許可されています。
     </para>
    </note>

   </sect2>
  </sect1>

  <sect1 id="plpgsql-control-structures">
<!--
   <title>Control Structures</title>
-->
<title>制御構造</title>

   <para>
<!--
    Control structures are probably the most useful (and
    important) part of <application>PL/pgSQL</application>. With
    <application>PL/pgSQL</application>'s control structures,
    you can manipulate <productname>PostgreSQL</productname> data in a very
    flexible and powerful way.
-->
制御構造はおそらく<application>PL/pgSQL</application>の最も有用（かつ重要）な部分です。
<application>PL/pgSQL</application>の制御構造を使用して、<productname>PostgreSQL</productname>のデータを非常に柔軟、強力に操作することができます。
   </para>

   <sect2 id="plpgsql-statements-returning">
<!--
    <title>Returning from a Function</title>
-->
<title>関数からの復帰</title>

    <para>
<!--
     There are two commands available that allow you to return data
     from a function: <command>RETURN</command> and <command>RETURN
     NEXT</command>.
-->
関数からデータを返すために使用できるコマンドが2つあります。
<command>RETURN</command>および<command>RETURN NEXT</command>です。
    </para>

    <sect3>
     <title><command>RETURN</command></title>

<synopsis>
RETURN <replaceable>expression</replaceable>;
</synopsis>

     <para>
<!--
      <command>RETURN</command> with an expression terminates the
      function and returns the value of
      <replaceable>expression</replaceable> to the caller.  This form
      is used for <application>PL/pgSQL</application> functions that do
      not return a set.
-->
式を持つ<command>RETURN</command>は関数を終了し、<replaceable>expression</replaceable>の値を呼び出し元に返します。
この形式は集合を返さない<application>PL/pgSQL</application>関数で使用されます。
     </para>

     <para>
<!--
      In a function that returns a scalar type, the expression's result will
      automatically be cast into the function's return type as described for
      assignments.  But to return a composite (row) value, you must write an
      expression delivering exactly the requested column set.  This may
      require use of explicit casting.
-->
スカラ型を返す関数において、代入のところで説明したように、式の結果は自動的に関数の戻り値の型にキャストされます。
しかし、複合（行）値を返すためには、要求された列集合を正確に導出する式を記述しなければなりません。
これにより、明示的なキャストの使用が必要となることがあります。
     </para>

     <para>
<!--
      If you declared the function with output parameters, write just
      <command>RETURN</command> with no expression.  The current values
      of the output parameter variables will be returned.
-->
出力パラメータを持った関数を宣言した時は、式の無い<command>RETURN</command>を記述してください。
その時点における出力パラメータの値が返されます。
     </para>

     <para>
<!--
      If you declared the function to return <type>void</type>, a
      <command>RETURN</command> statement can be used to exit the function
      early; but do not write an expression following
      <command>RETURN</command>.
-->
<type>void</type>を返すように関数を宣言した場合でも、関数を直ちに抜け出すために<command>RETURN</command>を使用できますが、<command>RETURN</command>の後に式を記述しないでください。
     </para>

     <para>
<!--
      The return value of a function cannot be left undefined. If
      control reaches the end of the top-level block of the function
      without hitting a <command>RETURN</command> statement, a run-time
      error will occur.  This restriction does not apply to functions
      with output parameters and functions returning <type>void</type>,
      however.  In those cases a <command>RETURN</command> statement is
      automatically executed if the top-level block finishes.
-->
関数の戻り値は未定義とさせたままにすることはできません。
制御が、<command>RETURN</command>文が見つからない状態で関数の最上位のブロックの終わりまで達した時、実行時エラーが発生します。
しかし、この制限は出力パラメータを持った関数及び<type>void</type>を返す関数には当てはまりません。
このような場合は最上位のブロックが終わった時、<command>RETURN</command>文が自動的に実行されます。
     </para>

     <para>
<!--
      Some examples:
-->
例を示します。

<programlisting>
<!--
&#045;- functions returning a scalar type
-->
-- スカラ型を返す関数
RETURN 1 + 2;
RETURN scalar_var;

<!--
&#045;- functions returning a composite type
-->
-- 複合型を返す関数
RETURN composite_type_var;
<!--
RETURN (1, 2, 'three'::text);  &#045;- must cast columns to correct types
-->
RETURN (1, 2, 'three'::text);  -- 正しい型の列にキャストしなければなりません
</programlisting>
     </para>
    </sect3>

    <sect3>
<!--
     <title><command>RETURN NEXT</command> and <command>RETURN QUERY</command></title>
-->
<title><command>RETURN NEXT</command>および<command>RETURN QUERY</command></title>
    <indexterm>
     <primary>RETURN NEXT</primary>
<!--
     <secondary>in PL/pgSQL</secondary>
-->
<secondary>PL/pgSQLにおける</secondary>
    </indexterm>
    <indexterm>
     <primary>RETURN QUERY</primary>
<!--
     <secondary>in PL/pgSQL</secondary>
-->
<secondary>PL/pgSQLにおける</secondary>
    </indexterm>

<synopsis>
RETURN NEXT <replaceable>expression</replaceable>;
RETURN QUERY <replaceable>query</replaceable>;
RETURN QUERY EXECUTE <replaceable class="command">command-string</replaceable> <optional> USING <replaceable>expression</replaceable> <optional>, ... </optional> </optional>;
</synopsis>

     <para>
<!--
      When a <application>PL/pgSQL</application> function is declared to return
      <literal>SETOF <replaceable>sometype</replaceable></literal>, the procedure
      to follow is slightly different.  In that case, the individual
      items to return are specified by a sequence of <command>RETURN
      NEXT</command> or <command>RETURN QUERY</command> commands, and
      then a final <command>RETURN</command> command with no argument
      is used to indicate that the function has finished executing.
      <command>RETURN NEXT</command> can be used with both scalar and
      composite data types; with a composite result type, an entire
      <quote>table</quote> of results will be returned.
      <command>RETURN QUERY</command> appends the results of executing
      a query to the function's result set. <command>RETURN
      NEXT</command> and <command>RETURN QUERY</command> can be freely
      intermixed in a single set-returning function, in which case
      their results will be concatenated.
-->
<application>PL/pgSQL</application>関数が<literal>SETOF <replaceable>sometype</replaceable></literal>を返すように宣言した場合、後続の処理が多少違います。
この場合、戻り値の個々の項目は、<command>RETURN NEXT</command>コマンドまたは<command>RETURN QUERY</command>コマンドで指定されます。
そして、引数のない最後の<command>RETURN</command>コマンドにより、関数が実行を終了したことが示されます。
<command>RETURN NEXT</command>は、スカラ型および複合型の両方で使用することができます。
複合型の場合、結果の<quote>テーブル</quote>全体が返されます。
<command>RETURN QUERY</command>は、問い合わせを実行した結果を関数の結果集合に追加します。
<command>RETURN NEXT</command>と<command>RETURN QUERY</command>は、単一の集合を返す関数の中で自由に混合できます。
この場合、連結されたものが結果となります。
     </para>

     <para>
<!--
      <command>RETURN NEXT</command> and <command>RETURN
      QUERY</command> do not actually return from the function &mdash;
      they simply append zero or more rows to the function's result
      set.  Execution then continues with the next statement in the
      <application>PL/pgSQL</application> function.  As successive
      <command>RETURN NEXT</command> or <command>RETURN
      QUERY</command> commands are executed, the result set is built
      up.  A final <command>RETURN</command>, which should have no
      argument, causes control to exit the function (or you can just
      let control reach the end of the function).
-->
実際には、<command>RETURN NEXT</command>および<command>RETURN QUERY</command>は関数から戻りません。
単に関数の結果集合に行を追加しているだけです。
そして、その実行は<application>PL/pgSQL</application>関数内の次の文に継続します。
<command>RETURN NEXT</command>または<command>RETURN QUERY</command>コマンドが連続して実行されると、結果集合が作成されます。
最後の、引数を持ってはならない<command>RETURN</command>により、関数の終了を制御します
(または制御を関数の最後に移すことができます)。
     </para>

     <para>
<!--
      <command>RETURN QUERY</command> has a variant
      <command>RETURN QUERY EXECUTE</command>, which specifies the
      query to be executed dynamically.  Parameter expressions can
      be inserted into the computed query string via <literal>USING</literal>,
      in just the same way as in the <command>EXECUTE</command> command.
-->
<command>RETURN QUERY</command>には<command>RETURN QUERY EXECUTE</command>という亜種があり、それは問い合わせが動的に実行されることを指定します。
パラメータ式を、<command>EXECUTE</command>コマンド内と全く同じように、<literal>USING</literal>によって演算された問い合わせ文字列に挿入することができます。
     </para>

     <para>
<!--
      If you declared the function with output parameters, write just
      <command>RETURN NEXT</command> with no expression.  On each
      execution, the current values of the output parameter
      variable(s) will be saved for eventual return as a row of the
      result.  Note that you must declare the function as returning
      <literal>SETOF record</literal> when there are multiple output
      parameters, or <literal>SETOF <replaceable>sometype</replaceable></literal>
      when there is just one output parameter of type
      <replaceable>sometype</replaceable>, in order to create a set-returning
      function with output parameters.
-->
出力パラメータを持つ関数を宣言した時は、式の無い<command>RETURN NEXT</command>だけを記述してください。
実行の度に、その時点における出力パラメータの値が、関数からの戻り値のために結果の行として保存されます。
出力パラメータを持つ集合を返す関数を作成するためには、出力パラメータが複数の時は<literal>SETOF record</literal>を返すように関数を宣言し、単一の<replaceable>sometype</replaceable>型の出力パラメータの時は<literal>SETOF <replaceable>sometype</replaceable></literal>を返すように関数を宣言しなければならないことに注意してください。
     </para>

     <para>
<!--
      Here is an example of a function using <command>RETURN
      NEXT</command>:
-->
<command>RETURN NEXT</command>を使用する関数の例を以下に示します。

<programlisting>
CREATE TABLE foo (fooid INT, foosubid INT, fooname TEXT);
INSERT INTO foo VALUES (1, 2, 'three');
INSERT INTO foo VALUES (4, 5, 'six');

CREATE OR REPLACE FUNCTION get_all_foo() RETURNS SETOF foo AS
$BODY$
DECLARE
    r foo%rowtype;
BEGIN
    FOR r IN
        SELECT * FROM foo WHERE fooid &gt; 0
    LOOP
<!--
        &#045;- can do some processing here
        RETURN NEXT r; &#045;- return current row of SELECT
-->
        -- ここで処理を実行できます
        RETURN NEXT r; -- SELECTの現在の行を返します
    END LOOP;
    RETURN;
END;
$BODY$
LANGUAGE plpgsql;

SELECT * FROM get_all_foo();
</programlisting>
     </para>

     <para>
<!--
      Here is an example of a function using <command>RETURN
      QUERY</command>:
-->
<command>RETURN QUERY</command>を使用する関数の例を以下に示します。

<programlisting>
CREATE FUNCTION get_available_flightid(date) RETURNS SETOF integer AS
$BODY$
BEGIN
    RETURN QUERY SELECT flightid
                   FROM flight
                  WHERE flightdate &gt;= $1
                    AND flightdate &lt; ($1 + 1);

<!--
    &#045;- Since execution is not finished, we can check whether rows were returned
    &#045;- and raise exception if not.
-->
-- 実行が終わっていないので、行が返されたか検査して、行がなければ例外を発生させます。
    IF NOT FOUND THEN
        RAISE EXCEPTION 'No flight at %.', $1;
    END IF;

    RETURN;
 END;
$BODY$
LANGUAGE plpgsql;

<!--
&#045;- Returns available flights or raises exception if there are no
&#045;- available flights.
-->
-- 利用できるフライトを返し、フライトがない場合は例外を発生させます。
SELECT * FROM get_available_flightid(CURRENT_DATE);
</programlisting>
     </para>

     <note>
      <para>
<!--
       The current implementation of <command>RETURN NEXT</command>
       and <command>RETURN QUERY</command> stores the entire result set
       before returning from the function, as discussed above.  That
       means that if a <application>PL/pgSQL</application> function produces a
       very large result set, performance might be poor: data will be
       written to disk to avoid memory exhaustion, but the function
       itself will not return until the entire result set has been
       generated.  A future version of <application>PL/pgSQL</application> might
       allow users to define set-returning functions
       that do not have this limitation.  Currently, the point at
       which data begins being written to disk is controlled by the
       <xref linkend="guc-work-mem"/>
       configuration variable.  Administrators who have sufficient
       memory to store larger result sets in memory should consider
       increasing this parameter.
-->
上記のように、<command>RETURN NEXT</command>および<command>RETURN QUERY</command>の現在の実装では、関数から返される前に結果集合全体を保管します。
これにより、<application>PL/pgSQL</application>関数が非常に大量の結果集合を返した場合、性能が低下する可能性があります。
メモリの枯渇を避けるため、データはディスクに書き込まれます。
しかし、関数自体は結果集合全体が生成されるまでは戻りません。
将来の<application>PL/pgSQL</application>のバージョンでは、この制限を受けずに集合を返す関数をユーザが定義できるようになるかもしれません。
現在、データがディスクに書き込まれ始まる時点は<xref linkend="guc-work-mem"/>設定変数によって制御されています。
大量の結果集合を保管するのに十分なメモリがある場合、管理者はこのパラメータの値を大きくすることを考慮すべきです。
      </para>
     </note>
    </sect3>
   </sect2>

   <sect2 id="plpgsql-statements-returning-procedure">
<!--
    <title>Returning from a Procedure</title>
-->
    <title>プロシージャからの戻り</title>

    <para>
<!--
     A procedure does not have a return value.  A procedure can therefore end
     without a <command>RETURN</command> statement.  If you wish to use
     a <command>RETURN</command> statement to exit the code early, write
     just <command>RETURN</command> with no expression.
-->
プロシージャは戻り値を持ちません。
したがって、プロシージャは<command>RETURN</command>文なしで終了できます。
早期にコードを抜けるために<command>RETURN</command>文を使いたいときには、式を伴わない<command>RETURN</command>だけを書いてください。
    </para>

    <para>
<!--
     If the procedure has output parameters, the final values of the output
     parameter variables will be returned to the caller.
-->
プロシージャが出力パラメータを持っている場合、出力パラメータ変数の最終の値が呼び出し元に返されます。
    </para>
   </sect2>

   <sect2 id="plpgsql-statements-calling-procedure">
<!--
    <title>Calling a Procedure</title>
-->
    <title>プロシージャを呼び出す</title>

    <para>
<!--
     A <application>PL/pgSQL</application> function, procedure,
     or <command>DO</command> block can call a procedure
     using <command>CALL</command>.  Output parameters are handled
     differently from the way that <command>CALL</command> works in plain
     SQL.  Each <literal>OUT</literal> or <literal>INOUT</literal>
     parameter of the procedure must
     correspond to a variable in the <command>CALL</command> statement, and
     whatever the procedure returns is assigned back to that variable after
     it returns.  For example:
-->
<application>PL/pgSQL</application>の関数、プロシージャ、<command>DO</command>ブロックは、<command>CALL</command>を使ってプロシージャを呼び出しできます。
<command>CALL</command>を普通のSQLで実行する場合とは、出力パラメータの扱いが異なります。
プロシージャの各<literal>INOUT</literal>パラメータは<command>CALL</command>文の変数と対応しなければならず、プロシージャが返すものは全て、<command>CALL</command>文が返った後にこの変数に書き戻されます。
以下に例を示します。
<programlisting>
CREATE PROCEDURE triple(INOUT x int)
LANGUAGE plpgsql
AS $$
BEGIN
    x := x * 3;
END;
$$;

DO $$
DECLARE myvar int := 5;
BEGIN
  CALL triple(myvar);
  RAISE NOTICE 'myvar = %', myvar;  -- prints 15
END;
$$;
</programlisting>
     The variable corresponding to an output parameter can be a simple
     variable or a field of a composite-type variable.  Currently,
     it cannot be an element of an array.
    </para>
   </sect2>

   <sect2 id="plpgsql-conditionals">
<!--
    <title>Conditionals</title>
-->
<title>条件分岐</title>

    <para>
<!--
     <command>IF</command> and <command>CASE</command> statements let you execute
     alternative commands based on certain conditions.
     <application>PL/pgSQL</application> has three forms of <command>IF</command>:
-->
<command>IF</command>と<command>CASE</command>文はある条件に基づいて代わりのコマンドを実行させます。
<application>PL/pgSQL</application>には、以下のような３つの<command>IF</command>の形式があります。
    <itemizedlist>
     <listitem>
      <para><literal>IF ... THEN ... END IF</literal></para>
     </listitem>
     <listitem>
      <para><literal>IF ... THEN ... ELSE ... END IF</literal></para>
     </listitem>
     <listitem>
      <para><literal>IF ... THEN ... ELSIF ... THEN ... ELSE ... END IF</literal></para>
     </listitem>
    </itemizedlist>

<!--
    and two forms of <command>CASE</command>:
-->
また、以下のような２つの<command>CASE</command>の形式があります。
    <itemizedlist>
     <listitem>
      <para><literal>CASE ... WHEN ... THEN ... ELSE ... END CASE</literal></para>
     </listitem>
     <listitem>
      <para><literal>CASE WHEN ... THEN ... ELSE ... END CASE</literal></para>
     </listitem>
    </itemizedlist>
    </para>

    <sect3>
     <title><literal>IF-THEN</literal></title>

<synopsis>
IF <replaceable>boolean-expression</replaceable> THEN
    <replaceable>statements</replaceable>
END IF;
</synopsis>

       <para>
<!--
        <literal>IF-THEN</literal> statements are the simplest form of
        <literal>IF</literal>. The statements between
        <literal>THEN</literal> and <literal>END IF</literal> will be
        executed if the condition is true. Otherwise, they are
        skipped.
-->
<literal>IF-THEN</literal>文は最も単純な<literal>IF</literal>の形式です。
<literal>THEN</literal>と<literal>END IF</literal>の間の文が条件が真の場合に実行されます。
さもなければそれらは飛ばされます。
       </para>

       <para>
<!--
        Example:
-->
例：
<programlisting>
IF v_user_id &lt;&gt; 0 THEN
    UPDATE users SET email = v_email WHERE user_id = v_user_id;
END IF;
</programlisting>
       </para>
     </sect3>

     <sect3>
      <title><literal>IF-THEN-ELSE</literal></title>

<synopsis>
IF <replaceable>boolean-expression</replaceable> THEN
    <replaceable>statements</replaceable>
ELSE
    <replaceable>statements</replaceable>
END IF;
</synopsis>

       <para>
<!--
        <literal>IF-THEN-ELSE</literal> statements add to
        <literal>IF-THEN</literal> by letting you specify an
        alternative set of statements that should be executed if the
        condition is not true.  (Note this includes the case where the
        condition evaluates to NULL.)
-->
<literal>IF-THEN-ELSE</literal>文は<literal>IF-THEN</literal>に加え、条件評価が偽の場合に実行すべき代替となる文の集合を指定することができます。
（これには条件がNULLと評価した場合も含まれることに注意してください。）
       </para>

       <para>
<!--
        Examples:
-->
例：
<programlisting>
IF parentid IS NULL OR parentid = ''
THEN
    RETURN fullname;
ELSE
    RETURN hp_true_filename(parentid) || '/' || fullname;
END IF;
</programlisting>

<programlisting>
IF v_count &gt; 0 THEN
    INSERT INTO users_count (count) VALUES (v_count);
    RETURN 't';
ELSE
    RETURN 'f';
END IF;
</programlisting>
     </para>
    </sect3>

     <sect3>
      <title><literal>IF-THEN-ELSIF</literal></title>

<synopsis>
IF <replaceable>boolean-expression</replaceable> THEN
    <replaceable>statements</replaceable>
<optional> ELSIF <replaceable>boolean-expression</replaceable> THEN
    <replaceable>statements</replaceable>
<optional> ELSIF <replaceable>boolean-expression</replaceable> THEN
    <replaceable>statements</replaceable>
    ...
</optional>
</optional>
<optional> ELSE
    <replaceable>statements</replaceable> </optional>
END IF;
</synopsis>

       <para>
<!--
        Sometimes there are more than just two alternatives.
        <literal>IF-THEN-ELSIF</literal> provides a convenient
        method of checking several alternatives in turn.
        The <literal>IF</literal> conditions are tested successively
        until the first one that is true is found.  Then the
        associated statement(s) are executed, after which control
        passes to the next statement after <literal>END IF</literal>.
        (Any subsequent <literal>IF</literal> conditions are <emphasis>not</emphasis>
        tested.)  If none of the <literal>IF</literal> conditions is true,
        then the <literal>ELSE</literal> block (if any) is executed.
-->
選択肢が２つだけではなくより多くになる場合があります。
<literal>IF-THEN-ELSIF</literal>は、順番に複数の代替手段を検査する、より便利な方法を提供します。
<literal>IF</literal>条件は最初の真である結果が見つかるまで連続して検査されます。
そして関連した文が実行され、その後<literal>END IF</literal>以降の次の文に制御が渡されます。
（以降にある<literal>IF</literal>条件の検査はすべて実行<emphasis>されません</emphasis>。）
全ての<literal>IF</literal>条件が真でない場合、<literal>ELSE</literal>ブロックが（もし存在すれば）実行されます。
機能的には、<literal>IF-THEN-ELSE-IF-THEN</literal>コマンドを入れ子にしたものと同じですが、必要な<literal>END IF</literal>は1つだけです。
       </para>

       <para>
<!--
        Here is an example:
-->
以下に例を示します。

<programlisting>
IF number = 0 THEN
    result := 'zero';
ELSIF number &gt; 0 THEN
    result := 'positive';
ELSIF number &lt; 0 THEN
    result := 'negative';
ELSE
<!--
    &#045;&#045; hmm, the only other possibility is that number is null
-->
    -- ふうむ、残る唯一の可能性はその値がNULLであることだ
    result := 'NULL';
END IF;
</programlisting>
       </para>

       <para>
<!--
        The key word <literal>ELSIF</literal> can also be spelled
        <literal>ELSEIF</literal>.
-->
<literal>ELSIF</literal>キーワードは<literal>ELSEIF</literal>のように書くことができます。
       </para>

       <para>
<!--
        An alternative way of accomplishing the same task is to nest
        <literal>IF-THEN-ELSE</literal> statements, as in the
        following example:
-->
同じ作業を遂行する別の方法は、以下の例のように<literal>IF-THEN-ELSE</literal>文を入れ子にすることです。

<programlisting>
IF demo_row.sex = 'm' THEN
    pretty_sex := 'man';
ELSE
    IF demo_row.sex = 'f' THEN
        pretty_sex := 'woman';
    END IF;
END IF;
</programlisting>
       </para>

       <para>
<!--
        However, this method requires writing a matching <literal>END IF</literal>
        for each <literal>IF</literal>, so it is much more cumbersome than
        using <literal>ELSIF</literal> when there are many alternatives.
-->
しかし、この方法はそれぞれの<literal>IF</literal>に対応する<literal>END IF</literal>の記述が必要です。
従って、多くの選択肢がある場合<literal>ELSIF</literal>を使用するよりも厄介です。
       </para>
     </sect3>

     <sect3>
<!--
      <title>Simple <literal>CASE</literal></title>
-->
<title>単純な<literal>CASE</literal></title>

<synopsis>
CASE <replaceable>search-expression</replaceable>
    WHEN <replaceable>expression</replaceable> <optional>, <replaceable>expression</replaceable> <optional> ... </optional></optional> THEN
      <replaceable>statements</replaceable>
  <optional> WHEN <replaceable>expression</replaceable> <optional>, <replaceable>expression</replaceable> <optional> ... </optional></optional> THEN
      <replaceable>statements</replaceable>
    ... </optional>
  <optional> ELSE
      <replaceable>statements</replaceable> </optional>
END CASE;
</synopsis>

      <para>
<!--
       The simple form of <command>CASE</command> provides conditional execution
       based on equality of operands.  The <replaceable>search-expression</replaceable>
       is evaluated (once) and successively compared to each
       <replaceable>expression</replaceable> in the <literal>WHEN</literal> clauses.
       If a match is found, then the corresponding
       <replaceable>statements</replaceable> are executed, and then control
       passes to the next statement after <literal>END CASE</literal>.  (Subsequent
       <literal>WHEN</literal> expressions are not evaluated.)  If no match is
       found, the <literal>ELSE</literal> <replaceable>statements</replaceable> are
       executed; but if <literal>ELSE</literal> is not present, then a
       <literal>CASE_NOT_FOUND</literal> exception is raised.
-->
<command>CASE</command>の単純な形式はオペランドの等価性にもとづく条件的実行を提供します。
<replaceable>search-expression</replaceable>は（一度だけ）評価され、その後<literal>WHEN</literal>句内のそれぞれの<replaceable>expression</replaceable>と比較されます。
一致するものが見つかると、関連した<replaceable>statements</replaceable>が実行され、<literal>END CASE</literal>の次の文に制御が渡されます。
（以降の<literal>WHEN</literal>式は評価されません。）
一致するものが見つからない場合、<literal>ELSE</literal> <replaceable>statements</replaceable>が実行されますが、<literal>ELSE</literal>が無いときは<literal>CASE_NOT_FOUND</literal>例外を引き起こします。
      </para>

      <para>
<!--
       Here is a simple example:
-->
以下は簡単な例です。

<programlisting>
CASE x
    WHEN 1, 2 THEN
        msg := 'one or two';
    ELSE
        msg := 'other value than one or two';
END CASE;
</programlisting>
      </para>
     </sect3>

     <sect3>
<!--
      <title>Searched <literal>CASE</literal></title>
-->
<title>検索付き<literal>CASE</literal></title>

<synopsis>
CASE
    WHEN <replaceable>boolean-expression</replaceable> THEN
      <replaceable>statements</replaceable>
  <optional> WHEN <replaceable>boolean-expression</replaceable> THEN
      <replaceable>statements</replaceable>
    ... </optional>
  <optional> ELSE
      <replaceable>statements</replaceable> </optional>
END CASE;
</synopsis>

      <para>
<!--
       The searched form of <command>CASE</command> provides conditional execution
       based on truth of Boolean expressions.  Each <literal>WHEN</literal> clause's
       <replaceable>boolean-expression</replaceable> is evaluated in turn,
       until one is found that yields <literal>true</literal>.  Then the
       corresponding <replaceable>statements</replaceable> are executed, and
       then control passes to the next statement after <literal>END CASE</literal>.
       (Subsequent <literal>WHEN</literal> expressions are not evaluated.)
       If no true result is found, the <literal>ELSE</literal>
       <replaceable>statements</replaceable> are executed;
       but if <literal>ELSE</literal> is not present, then a
       <literal>CASE_NOT_FOUND</literal> exception is raised.
-->
<command>CASE</command>の検索された形式は論理値式の真の結果に基づく条件付き実行を提供します。
それぞれの<literal>WHEN</literal>句の<replaceable>boolean-expression</replaceable>は<literal>true</literal>となる１つが見つかるまで順番に評価されます。
その後、関連する<replaceable>statements</replaceable>が実行され、その結果<literal>END CASE</literal>の次の文に制御が渡されます。
（以降の<literal>WHEN</literal>式は評価されません。）
真となる結果が見つからない場合、<literal>ELSE</literal> <replaceable>statements</replaceable>が実行されますが、<literal>ELSE</literal>が存在しないときは<literal>CASE_NOT_FOUND</literal>例外を引き起こします。
      </para>

      <para>
<!--
       Here is an example:
-->
以下は簡単な例です。

<programlisting>
CASE
    WHEN x BETWEEN 0 AND 10 THEN
        msg := 'value is between zero and ten';
    WHEN x BETWEEN 11 AND 20 THEN
        msg := 'value is between eleven and twenty';
END CASE;
</programlisting>
      </para>

      <para>
<!--
       This form of <command>CASE</command> is entirely equivalent to
       <literal>IF-THEN-ELSIF</literal>, except for the rule that reaching
       an omitted <literal>ELSE</literal> clause results in an error rather
       than doing nothing.
-->
この形式の<command>CASE</command>は、判定基準が省略された<literal>ELSE</literal>句に達した場合に何もしないのではなくエラーなる点を除き、<literal>IF-THEN-ELSIF</literal>と全く同一です。
      </para>

     </sect3>
   </sect2>

   <sect2 id="plpgsql-control-structures-loops">
<!--
    <title>Simple Loops</title>
-->
<title>単純なループ</title>

    <indexterm zone="plpgsql-control-structures-loops">
<!--
     <primary>loop</primary>
     <secondary>in PL/pgSQL</secondary>
-->
     <primary>ループ</primary>
     <secondary>PL/pgSQLにおける</secondary>
    </indexterm>

    <para>
<!--
     With the <literal>LOOP</literal>, <literal>EXIT</literal>,
     <literal>CONTINUE</literal>, <literal>WHILE</literal>, <literal>FOR</literal>,
     and <literal>FOREACH</literal> statements, you can arrange for your
     <application>PL/pgSQL</application> function to repeat a series of commands.
-->
<literal>LOOP</literal>、<literal>EXIT</literal>、<literal>CONTINUE</literal>、<literal>WHILE</literal>、<literal>FOR</literal>、<literal>FOREACH</literal>文を使用して、<application>PL/pgSQL</application>関数で、一連のコマンドを繰り返すことができます。
    </para>

    <sect3>
     <title><literal>LOOP</literal></title>

<synopsis>
<optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>
LOOP
    <replaceable>statements</replaceable>
END LOOP <optional> <replaceable>label</replaceable> </optional>;
</synopsis>

     <para>
<!--
      <literal>LOOP</literal> defines an unconditional loop that is repeated
      indefinitely until terminated by an <literal>EXIT</literal> or
      <command>RETURN</command> statement.  The optional
      <replaceable>label</replaceable> can be used by <literal>EXIT</literal>
      and <literal>CONTINUE</literal> statements within nested loops to
      specify which loop those statements refer to.
-->
<literal>LOOP</literal>は、<literal>EXIT</literal>文または<command>RETURN</command>文によって終了されるまで無限に繰り返される、条件なしのループを定義します。
省略可能な<replaceable>label</replaceable>は、ネステッドループにおいて<literal>EXIT</literal>および<literal>CONTINUE</literal>文がどのレベルの入れ子を参照するかを指定するために使用されます。
     </para>
    </sect3>

     <sect3>
      <title><literal>EXIT</literal></title>

     <indexterm>
      <primary>EXIT</primary>
<!--
      <secondary>in PL/pgSQL</secondary>
-->
<secondary>PL/pgSQLにおける</secondary>
     </indexterm>

<synopsis>
EXIT <optional> <replaceable>label</replaceable> </optional> <optional> WHEN <replaceable>boolean-expression</replaceable> </optional>;
</synopsis>

       <para>
<!--
        If no <replaceable>label</replaceable> is given, the innermost
        loop is terminated and the statement following <literal>END
        LOOP</literal> is executed next.  If <replaceable>label</replaceable>
        is given, it must be the label of the current or some outer
        level of nested loop or block. Then the named loop or block is
        terminated and control continues with the statement after the
        loop's/block's corresponding <literal>END</literal>.
-->
<replaceable>label</replaceable>が指定されない場合、最も内側のループを終わらせ、<literal>END LOOP</literal>の次の文がその後に実行されます。
<replaceable>label</replaceable>が指定された場合、それは現在またはその上位のネステッドループやブロックのラベルである必要があります。
その後、指名されたループまたはブロックを終わらせ、そのループまたはブロックの対応する<literal>END</literal>の次の文に制御を移します。
       </para>

       <para>
<!--
        If <literal>WHEN</literal> is specified, the loop exit occurs only if
        <replaceable>boolean-expression</replaceable> is true. Otherwise, control passes
        to the statement after <literal>EXIT</literal>.
-->
<literal>WHEN</literal>が指定された場合、<replaceable>boolean-expression</replaceable>が真の場合のみループの終了が起こります。
さもなければ、<literal>EXIT</literal>の後の行に制御が移ります。
       </para>

       <para>
<!--
        <literal>EXIT</literal> can be used with all types of loops; it is
        not limited to use with unconditional loops.
-->
<literal>EXIT</literal>は、すべての種類のループと共に使用できます。
条件なしのループでの使用に限定されません。
       </para>

       <para>
<!--
        When used with a
        <literal>BEGIN</literal> block, <literal>EXIT</literal> passes
        control to the next statement after the end of the block.
        Note that a label must be used for this purpose; an unlabeled
        <literal>EXIT</literal> is never considered to match a
        <literal>BEGIN</literal> block.  (This is a change from
        pre-8.4 releases of <productname>PostgreSQL</productname>, which
        would allow an unlabeled <literal>EXIT</literal> to match
        a <literal>BEGIN</literal> block.)
-->
<literal>BEGIN</literal>ブロックと共に使用した時、<literal>EXIT</literal>によりブロックの次の文に制御が移ります。
この目的のためにラベルが使用されなければならないことに注意してください。
ラベル無しの<literal>EXIT</literal>は<literal>BEGIN</literal>ブロックに対応するとは決して考えられません。
（これは、ラベル無しの<literal>EXIT</literal>が<literal>BEGIN</literal>ブロックに対応することを許容する<productname>PostgreSQL</productname>の8.4より前のリリースからの変更です。）
       </para>

       <para>
<!--
        Examples:
-->
例：
<programlisting>
LOOP
<!--
    &#045;&#045; some computations
-->
    -- 何らかの演算
    IF count &gt; 0 THEN
<!--
        EXIT;  &#045;&#045; exit loop
-->
        EXIT;  -- ループを抜け出す
    END IF;
END LOOP;

LOOP
<!--
    &#045;&#045; some computations
    EXIT WHEN count &gt; 0;  &#045;&#045; same result as previous example
-->
-- 何らかの演算
    EXIT WHEN count &gt; 0;  -- 上例と同じ結果
END LOOP;

&lt;&lt;ablock&gt;&gt;
BEGIN
<!--
    &#045;&#045; some computations
-->
    -- 何らかの演算
    IF stocks &gt; 100000 THEN
<!--
        EXIT ablock;  &#045;&#045; causes exit from the BEGIN block
-->
        EXIT ablock;  -- これによりBEGINブロックを抜け出す
    END IF;
<!--
    &#045;&#045; computations here will be skipped when stocks &gt; 100000
-->
    -- stokcs &gt; 100000 であればここでの演算は省略
END;
</programlisting>
       </para>
     </sect3>

     <sect3>
      <title><literal>CONTINUE</literal></title>

     <indexterm>
      <primary>CONTINUE</primary>
<!--
      <secondary>in PL/pgSQL</secondary>
-->
      <secondary>PL/pgSQLにおける</secondary>
     </indexterm>

<synopsis>
CONTINUE <optional> <replaceable>label</replaceable> </optional> <optional> WHEN <replaceable>boolean-expression</replaceable> </optional>;
</synopsis>

       <para>
<!--
        If no <replaceable>label</replaceable> is given, the next iteration of
        the innermost loop is begun. That is, all statements remaining
        in the loop body are skipped, and control returns
        to the loop control expression (if any) to determine whether
        another loop iteration is needed.
        If <replaceable>label</replaceable> is present, it
        specifies the label of the loop whose execution will be
        continued.
-->
<replaceable>label</replaceable>が無い場合、すぐ外側のループの次の繰り返しが開始されます。
すなわち、ループ本体の残りの文は飛ばされて、他のループの繰り返しが必要かどうかを決めるため、制御がループ制御式(もし存在すれば)に戻ります。
<replaceable>label</replaceable>が存在する場合、実行を継続するループのラベルを指定します。
       </para>

       <para>
<!--
        If <literal>WHEN</literal> is specified, the next iteration of the
        loop is begun only if <replaceable>boolean-expression</replaceable> is
        true. Otherwise, control passes to the statement after
        <literal>CONTINUE</literal>.
-->
<literal>WHEN</literal>が指定された場合、<replaceable>boolean-expression</replaceable>が真の場合のみループにおける次の繰り返しが始まります。
さもなければ、<literal>CONTINUE</literal>の後の行に制御が移ります。
       </para>

       <para>
<!--
        <literal>CONTINUE</literal> can be used with all types of loops; it
        is not limited to use with unconditional loops.
-->
<literal>CONTINUE</literal>は全ての種類のループで使用可能です。
条件なしのループに限定されません。
       </para>

       <para>
<!--
        Examples:
-->
例
<programlisting>
LOOP
<!--
    &#045;&#045; some computations
-->
    -- 何らかの演算
    EXIT WHEN count &gt; 100;
    CONTINUE WHEN count &lt; 50;
<!--
    &#045;&#045; some computations for count IN [50 .. 100]
-->
    -- 50から100を数える、何らかの演算
END LOOP;
</programlisting>
       </para>
     </sect3>


     <sect3>
      <title><literal>WHILE</literal></title>

     <indexterm>
      <primary>WHILE</primary>
<!--
      <secondary>in PL/pgSQL</secondary>
-->
<secondary>PL/pgSQLにおける</secondary>
     </indexterm>

<synopsis>
<optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>
WHILE <replaceable>boolean-expression</replaceable> LOOP
    <replaceable>statements</replaceable>
END LOOP <optional> <replaceable>label</replaceable> </optional>;
</synopsis>

       <para>
<!--
        The <literal>WHILE</literal> statement repeats a
        sequence of statements so long as the
        <replaceable>boolean-expression</replaceable>
        evaluates to true.  The expression is checked just before
        each entry to the loop body.
-->
<literal>WHILE</literal>文は<replaceable>boolean-expression</replaceable>の評価が真である間、一連の文を繰り返します。
条件式は、ループ本体に入る前にのみ検査されます。
       </para>

       <para>
<!--
        For example:
-->
以下に例を示します。
<programlisting>
WHILE amount_owed &gt; 0 AND gift_certificate_balance &gt; 0 LOOP
<!--
    &#045;&#045; some computations here
-->
    -- ここで演算をいくつか行います。
END LOOP;

WHILE NOT done LOOP
<!--
    &#045;&#045; some computations here
-->
    -- ここで演算をいくつか行います。
END LOOP;
</programlisting>
       </para>
     </sect3>

     <sect3 id="plpgsql-integer-for">
<!--
      <title><literal>FOR</literal> (Integer Variant)</title>
-->
<title>整数<literal>FOR</literal>ループ</title>

<synopsis>
<optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>
FOR <replaceable>name</replaceable> IN <optional> REVERSE </optional> <replaceable>expression</replaceable> .. <replaceable>expression</replaceable> <optional> BY <replaceable>expression</replaceable> </optional> LOOP
    <replaceable>statements</replaceable>
END LOOP <optional> <replaceable>label</replaceable> </optional>;
</synopsis>

       <para>
<!--
        This form of <literal>FOR</literal> creates a loop that iterates over a range
        of integer values. The variable
        <replaceable>name</replaceable> is automatically defined as type
        <type>integer</type> and exists only inside the loop (any existing
        definition of the variable name is ignored within the loop).
        The two expressions giving
        the lower and upper bound of the range are evaluated once when entering
        the loop. If the <literal>BY</literal> clause isn't specified the iteration
        step is 1, otherwise it's the value specified in the <literal>BY</literal>
        clause, which again is evaluated once on loop entry.
        If <literal>REVERSE</literal> is specified then the step value is
        subtracted, rather than added, after each iteration.
-->
この形式の<literal>FOR</literal>は整数値の範囲内で繰り返すループを生成します。
<replaceable>name</replaceable>変数は<type>integer</type>型として自動的に定義され、ループ内部のみで存在します
（ループ外部で定義しても、ループ内部では全て無視されます）。
範囲の下限、上限として与えられる2つの式はループに入った時に一度だけ評価されます。
<literal>BY</literal>句を指定しない時の繰り返し刻みは1ですが、<literal>BY</literal>句を用いて指定でき、ループに入った時に一度だけ評価されます。
<literal>REVERSE</literal>が指定された場合、繰り返し刻みの値は加算されるのではなく、繰り返しごとに減算されます。
       </para>

       <para>
<!--
        Some examples of integer <literal>FOR</literal> loops:
-->
整数<literal>FOR</literal>ループの例を以下に示します。
<programlisting>
FOR i IN 1..10 LOOP
<!--
    &#045;&#045; i will take on the values 1,2,3,4,5,6,7,8,9,10 within the loop
-->
    -- i はループ内で 1、2、3、4、5、6、7、8、9、10 の値を取ります。
END LOOP;

FOR i IN REVERSE 10..1 LOOP
<!--
    &#045;&#045; i will take on the values 10,9,8,7,6,5,4,3,2,1 within the loop
-->
    -- i はループ内で 10、9、8、7、6、5、4、3、2、1 の値を取ります。
END LOOP;

FOR i IN REVERSE 10..1 BY 2 LOOP
<!--
    &#045;&#045; i will take on the values 10,8,6,4,2 within the loop
-->
    -- i はループ内で 10、8、6、4、2 の値を取ります。
END LOOP;
</programlisting>
       </para>

       <para>
<!--
        If the lower bound is greater than the upper bound (or less than,
        in the <literal>REVERSE</literal> case), the loop body is not
        executed at all.  No error is raised.
-->
下限が上限よりも大きい（<literal>REVERSE</literal>の場合はより小さい）場合、ループ本体はまったく実行されません。
エラーは発生しません。
       </para>

       <para>
<!--
        If a <replaceable>label</replaceable> is attached to the
        <literal>FOR</literal> loop then the integer loop variable can be
        referenced with a qualified name, using that
        <replaceable>label</replaceable>.
-->
<replaceable>label</replaceable>を<literal>FOR</literal>ループに付加することにより、<replaceable>label</replaceable>を用いて修飾した名前の整数ループ変数を参照できます。
       </para>
     </sect3>
   </sect2>

   <sect2 id="plpgsql-records-iterating">
<!--
    <title>Looping through Query Results</title>
-->
<title>問い合わせ結果による繰り返し</title>

    <para>
<!--
     Using a different type of <literal>FOR</literal> loop, you can iterate through
     the results of a query and manipulate that data
     accordingly. The syntax is:
-->
別の種類の<literal>FOR</literal>ループを使用して、問い合わせの結果を繰り返し、そのデータを扱うことができます。
以下に構文を示します。
<synopsis>
<optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>
FOR <replaceable>target</replaceable> IN <replaceable>query</replaceable> LOOP
    <replaceable>statements</replaceable>
END LOOP <optional> <replaceable>label</replaceable> </optional>;
</synopsis>
<!--
     The <replaceable>target</replaceable> is a record variable, row variable,
     or comma-separated list of scalar variables.
     The <replaceable>target</replaceable> is successively assigned each row
     resulting from the <replaceable>query</replaceable> and the loop body is
     executed for each row. Here is an example:
-->
<replaceable>target</replaceable>は、レコード変数、行変数またはカンマで区切ったスカラ変数のリストです。
<replaceable>target</replaceable>には順次、<replaceable>query</replaceable>の結果の全ての行が代入され、各行に対してループ本体が実行されます。
以下に例を示します。
<programlisting>
CREATE FUNCTION refresh_mviews() RETURNS integer AS $$
DECLARE
    mviews RECORD;
BEGIN
    RAISE NOTICE 'Refreshing all materialized views...';

    FOR mviews IN
       SELECT n.nspname AS mv_schema,
              c.relname AS mv_name,
              pg_catalog.pg_get_userbyid(c.relowner) AS owner
         FROM pg_catalog.pg_class c
    LEFT JOIN pg_catalog.pg_namespace n ON (n.oid = c.relnamespace)
        WHERE c.relkind = 'm'
     ORDER BY 1
    LOOP

<!--
        &#045;- Now "mviews" has one record with information about the materialized view
-->
        -- ここで"mviews"はcs_materialized_viewsの1つのレコードを持ちます

        RAISE NOTICE 'Refreshing materialized view %.% (owner: %)...',
                     quote_ident(mviews.mv_schema),
                     quote_ident(mviews.mv_name),
                     quote_ident(mviews.owner);
        EXECUTE format('REFRESH MATERIALIZED VIEW %I.%I', mviews.mv_schema, mviews.mv_name);
    END LOOP;

    RAISE NOTICE 'Done refreshing materialized views.';
    RETURN 1;
END;
$$ LANGUAGE plpgsql;
</programlisting>

<!--
     If the loop is terminated by an <literal>EXIT</literal> statement, the last
     assigned row value is still accessible after the loop.
-->
このループが<literal>EXIT</literal>文で終了した場合、最後に割り当てられた行の値はループを抜けた後でもアクセスすることができます。
    </para>

    <para>
<!--
     The <replaceable>query</replaceable> used in this type of <literal>FOR</literal>
     statement can be any SQL command that returns rows to the caller:
     <command>SELECT</command> is the most common case,
     but you can also use <command>INSERT</command>, <command>UPDATE</command>, or
     <command>DELETE</command> with a <literal>RETURNING</literal> clause.  Some utility
     commands such as <command>EXPLAIN</command> will work too.
-->
この種類の<literal>FOR</literal>文の<replaceable>query</replaceable>としては、呼び出し元に行を返すSQLコマンドをすべて使用できます。
通常は<command>SELECT</command>ですが、<literal>RETURNING</literal>句を持つ<command>INSERT</command>、<command>UPDATE</command>または<command>DELETE</command>も使用できます。
<command>EXPLAIN</command>などのユーティリティコマンドも作動します。
    </para>

    <para>
<!--
     <application>PL/pgSQL</application> variables are replaced by query parameters,
     and the query plan is cached for possible re-use, as discussed in
     detail in <xref linkend="plpgsql-var-subst"/> and
     <xref linkend="plpgsql-plan-caching"/>.
-->
<application>PL/pgSQL</application>変数は問い合わせテキストに置き換えられます。
問い合わせ計画は、<xref linkend="plpgsql-var-subst"/>および<xref linkend="plpgsql-plan-caching"/>で述べたように、再利用のためにキャッシュされます。
    </para>

    <para>
<!--
     The <literal>FOR-IN-EXECUTE</literal> statement is another way to iterate over
     rows:
-->
<literal>FOR-IN-EXECUTE</literal>文は行を繰り返すもう1つの方法です。
<synopsis>
<optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>
FOR <replaceable>target</replaceable> IN EXECUTE <replaceable>text_expression</replaceable> <optional> USING <replaceable>expression</replaceable> <optional>, ... </optional> </optional> LOOP
    <replaceable>statements</replaceable>
END LOOP <optional> <replaceable>label</replaceable> </optional>;
</synopsis>
<!--
     This is like the previous form, except that the source query
     is specified as a string expression, which is evaluated and replanned
     on each entry to the <literal>FOR</literal> loop.  This allows the programmer to
     choose the speed of a preplanned query or the flexibility of a dynamic
     query, just as with a plain <command>EXECUTE</command> statement.
     As with <command>EXECUTE</command>, parameter values can be inserted
     into the dynamic command via <literal>USING</literal>.
-->
この方法は、問い合わせのソースが文字列式で指定される点を除き、前の形式と似ています。
この式は<literal>FOR</literal>ループの各項目で評価され、再計画が行われます。
これにより、プログラマは、通常の<command>EXECUTE</command>文と同じように事前に計画された問い合わせによる高速性と、動的な問い合わせの持つ柔軟性を選択することができます。
<command>EXECUTE</command>の場合と同様、パラメータ値は<literal>USING</literal>により動的コマンドに挿入できます。
    </para>

    <para>
<!--
     Another way to specify the query whose results should be iterated
     through is to declare it as a cursor.  This is described in
     <xref linkend="plpgsql-cursor-for-loop"/>.
-->
結果を通して繰り返さなければならない問い合わせを指定するもう１つの方法として、カーソルの宣言があります。
これは<xref linkend="plpgsql-cursor-for-loop"/>で説明します。
    </para>
   </sect2>

   <sect2 id="plpgsql-foreach-array">
<!--
    <title>Looping through Arrays</title>
-->
<title>配列を巡回</title>

    <para>
<!--
     The <literal>FOREACH</literal> loop is much like a <literal>FOR</literal> loop,
     but instead of iterating through the rows returned by an SQL query,
     it iterates through the elements of an array value.
     (In general, <literal>FOREACH</literal> is meant for looping through
     components of a composite-valued expression; variants for looping
     through composites besides arrays may be added in future.)
     The <literal>FOREACH</literal> statement to loop over an array is:
-->
<literal>FOREACH</literal>ループは<literal>FOR</literal>ループにとてもよく似ています。
しかし、SQL 問い合わせが抽出した行を繰り返す代わりに、配列の要素を繰り返します。
（一般的に<literal>FOREACH</literal>は、複合値で表現される構成要素の巡回を意味しますが、配列でない複合値も巡回する亜種が将来は追加されるかもしれません。）
配列を巡回する<literal>FOREACH</literal>文を示します。

<synopsis>
<optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>
FOREACH <replaceable>target</replaceable> <optional> SLICE <replaceable>number</replaceable> </optional> IN ARRAY <replaceable>expression</replaceable> LOOP
    <replaceable>statements</replaceable>
END LOOP <optional> <replaceable>label</replaceable> </optional>;
</synopsis>
    </para>

    <para>
<!--
     Without <literal>SLICE</literal>, or if <literal>SLICE 0</literal> is specified,
     the loop iterates through individual elements of the array produced
     by evaluating the <replaceable>expression</replaceable>.
     The <replaceable>target</replaceable> variable is assigned each
     element value in sequence, and the loop body is executed for each element.
     Here is an example of looping through the elements of an integer
     array:
-->
<literal>SLICE</literal>がない、または<literal>SLICE 0</literal>が指定された場合、ループは<replaceable>expression</replaceable>によって評価されて作成された配列の各要素を繰り返します。
<replaceable>target</replaceable>変数が各要素の値に順次割り当てられ、各要素に対してループ本体が実行されます。
整数配列の要素を巡回する例を示します。

<programlisting>
CREATE FUNCTION sum(int[]) RETURNS int8 AS $$
DECLARE
  s int8 := 0;
  x int;
BEGIN
  FOREACH x IN ARRAY $1
  LOOP
    s := s + x;
  END LOOP;
  RETURN s;
END;
$$ LANGUAGE plpgsql;
</programlisting>

<!--
     The elements are visited in storage order, regardless of the number of
     array dimensions.  Although the <replaceable>target</replaceable> is
     usually just a single variable, it can be a list of variables when
     looping through an array of composite values (records).  In that case,
     for each array element, the variables are assigned from successive
     columns of the composite value.
-->
配列の次元数に関係なく、要素は格納した順番で処理されます。
通常<replaceable>target</replaceable>は単一の変数ですが、複合値（レコード）の配列を巡回するときは、変数のリストも可能です。
その場合、配列の各要素に対して、変数は複合値（レコード）の列から連続的に割り当てられます。
    </para>

    <para>
<!--
     With a positive <literal>SLICE</literal> value, <literal>FOREACH</literal>
     iterates through slices of the array rather than single elements.
     The <literal>SLICE</literal> value must be an integer constant not larger
     than the number of dimensions of the array.  The
     <replaceable>target</replaceable> variable must be an array,
     and it receives successive slices of the array value, where each slice
     is of the number of dimensions specified by <literal>SLICE</literal>.
     Here is an example of iterating through one-dimensional slices:
-->
正の<literal>SLICE</literal>値を持つ場合、<literal>FOREACH</literal>は単一の要素ではなく多次元配列の低次元部分配列を通して繰り返します。
<literal>SLICE</literal>値は、配列の次元数より小さい整数定数でなければなりません。
<replaceable>target</replaceable>変数は配列でなければなりません。
この変数は、配列値から連続した部分配列を受けとります
ここで部分配列は<literal>SLICE</literal>で指定した次数となります。
以下に1次元の部分配列を通した繰り返しの例を示します。

<programlisting>
CREATE FUNCTION scan_rows(int[]) RETURNS void AS $$
DECLARE
  x int[];
BEGIN
  FOREACH x SLICE 1 IN ARRAY $1
  LOOP
    RAISE NOTICE 'row = %', x;
  END LOOP;
END;
$$ LANGUAGE plpgsql;

SELECT scan_rows(ARRAY[[1,2,3],[4,5,6],[7,8,9],[10,11,12]]);

NOTICE:  row = {1,2,3}
NOTICE:  row = {4,5,6}
NOTICE:  row = {7,8,9}
NOTICE:  row = {10,11,12}
</programlisting>
    </para>
   </sect2>

   <sect2 id="plpgsql-error-trapping">
<!--
    <title>Trapping Errors</title>
-->
<title>エラーの捕捉</title>

    <indexterm>
<!--
     <primary>exceptions</primary>
     <secondary>in PL/pgSQL</secondary>
-->
     <primary>例外</primary>
     <secondary>PL/pgSQLにおける</secondary>
    </indexterm>

    <para>
<!--
     By default, any error occurring in a <application>PL/pgSQL</application>
     function aborts execution of the function and the
     surrounding transaction.  You can trap errors and recover
     from them by using a <command>BEGIN</command> block with an
     <literal>EXCEPTION</literal> clause.  The syntax is an extension of the
     normal syntax for a <command>BEGIN</command> block:
-->
デフォルトでは、<application>PL/pgSQL</application>関数の内部でエラーが発生すると関数とそれを囲むトランザクションをアボートします。
<command>BEGIN</command>ブロックおよび<literal>EXCEPTION</literal>句を使用すれば、エラーを捕捉してその状態から回復できます。
その構文は通常の<command>BEGIN</command>ブロックの構文を拡張したものです。

<synopsis>
<optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>
<optional> DECLARE
    <replaceable>declarations</replaceable> </optional>
BEGIN
    <replaceable>statements</replaceable>
EXCEPTION
    WHEN <replaceable>condition</replaceable> <optional> OR <replaceable>condition</replaceable> ... </optional> THEN
        <replaceable>handler_statements</replaceable>
    <optional> WHEN <replaceable>condition</replaceable> <optional> OR <replaceable>condition</replaceable> ... </optional> THEN
          <replaceable>handler_statements</replaceable>
      ... </optional>
END;
</synopsis>
    </para>

    <para>
<!--
     If no error occurs, this form of block simply executes all the
     <replaceable>statements</replaceable>, and then control passes
     to the next statement after <literal>END</literal>.  But if an error
     occurs within the <replaceable>statements</replaceable>, further
     processing of the <replaceable>statements</replaceable> is
     abandoned, and control passes to the <literal>EXCEPTION</literal> list.
     The list is searched for the first <replaceable>condition</replaceable>
     matching the error that occurred.  If a match is found, the
     corresponding <replaceable>handler_statements</replaceable> are
     executed, and then control passes to the next statement after
     <literal>END</literal>.  If no match is found, the error propagates out
     as though the <literal>EXCEPTION</literal> clause were not there at all:
     the error can be caught by an enclosing block with
     <literal>EXCEPTION</literal>, or if there is none it aborts processing
     of the function.
-->
エラーが発生しない時、この形式のブロックは単に全ての<replaceable>statements</replaceable>を実行し、<literal>END</literal>の次の文に制御が移ります。
しかし、<replaceable>statements</replaceable>の内部でエラーが発生すると、それ以後の<replaceable>statements</replaceable>の処理は中断され、<literal>EXCEPTION</literal>リストに制御が移ります。
そしてリストの中から、発生したエラーと合致する最初の<replaceable>condition</replaceable>を探します。
合致するものがあれば、対応する<replaceable>handler_statements</replaceable>を実行し、<literal>END</literal>の次の文に制御が移ります。
合致するものがなければ、<literal>EXCEPTION</literal>句が存在しないのと同じで、エラーは外側に伝播します。
<literal>EXCEPTION</literal>を含んだ外側のブロックはエラーを捕捉できますが、失敗すると関数の処理は中断されます。
    </para>

    <para>
<!--
     The <replaceable>condition</replaceable> names can be any of
     those shown in <xref linkend="errcodes-appendix"/>.  A category
     name matches any error within its category.  The special
     condition name <literal>OTHERS</literal> matches every error type except
     <literal>QUERY_CANCELED</literal> and <literal>ASSERT_FAILURE</literal>.
     (It is possible, but often unwise, to trap those two error types
     by name.)  Condition names are
     not case-sensitive.  Also, an error condition can be specified
     by <literal>SQLSTATE</literal> code; for example these are equivalent:
-->
全ての<replaceable>condition</replaceable>の名前は<xref linkend="errcodes-appendix"/>に示したもののいずれかを取ることができます。
分類名はそこに分類される全てのエラーに合致します。
<literal>OTHERS</literal>という特別の状態名は<literal>QUERY_CANCELED</literal>と<literal>ASSERT_FAILURE</literal>を除く全てのエラーに合致します。
（<literal>QUERY_CANCELED</literal>と<literal>ASSERT_FAILURE</literal>を名前で捕捉することは可能ですが、賢明ではありません。）
状態名は大文字小文字を区別しません。
同時に、エラー状態は<literal>SQLSTATE</literal>コードで指定可能です。
例えば以下は等価です。
<programlisting>
WHEN division_by_zero THEN ...
WHEN SQLSTATE '22012' THEN ...
</programlisting>
    </para>

    <para>
<!--
     If a new error occurs within the selected
     <replaceable>handler_statements</replaceable>, it cannot be caught
     by this <literal>EXCEPTION</literal> clause, but is propagated out.
     A surrounding <literal>EXCEPTION</literal> clause could catch it.
-->
エラーが該当する<replaceable>handler_statements</replaceable>内部で新たに発生した時、<literal>EXCEPTION</literal>句はそのエラーを捕捉できずエラーは外側に伝播します。
なお、上位の<literal>EXCEPTION</literal>句はそのエラーを捕捉できます。
    </para>

    <para>
<!--
     When an error is caught by an <literal>EXCEPTION</literal> clause,
     the local variables of the <application>PL/pgSQL</application> function
     remain as they were when the error occurred, but all changes
     to persistent database state within the block are rolled back.
     As an example, consider this fragment:
-->
<literal>EXCEPTION</literal>句がエラーを捕捉した時、<application>PL/pgSQL</application>関数のローカル変数はエラーが起こった後の状態を保ちます。
しかし、ブロック内部における永続的なデータベースの状態は、ロールバックされます。
そのような例を以下に示します。

<programlisting>
INSERT INTO mytab(firstname, lastname) VALUES('Tom', 'Jones');
BEGIN
    UPDATE mytab SET firstname = 'Joe' WHERE lastname = 'Jones';
    x := x + 1;
    y := x / 0;
EXCEPTION
    WHEN division_by_zero THEN
        RAISE NOTICE 'caught division_by_zero';
        RETURN x;
END;
</programlisting>

<!--
     When control reaches the assignment to <literal>y</literal>, it will
     fail with a <literal>division_by_zero</literal> error.  This will be caught by
     the <literal>EXCEPTION</literal> clause.  The value returned in the
     <command>RETURN</command> statement will be the incremented value of
     <literal>x</literal>, but the effects of the <command>UPDATE</command> command will
     have been rolled back.  The <command>INSERT</command> command preceding the
     block is not rolled back, however, so the end result is that the database
     contains <literal>Tom Jones</literal> not <literal>Joe Jones</literal>.
-->
制御が変数<literal>y</literal>の代入に移ると、<literal>division_by_zero</literal>エラーとなり、<literal>EXCEPTION</literal>句がそのエラーを捕捉します。
<command>RETURN</command>文による関数の戻り値は、1を加算した後の<literal>x</literal>の値となりますが、<command>UPDATE</command>コマンドによる結果はロールバックされます。
しかし、前のブロックの<command>INSERT</command>コマンドはロールバックされません。
したがって、データベースの内容の最終結果は<literal>Tom Jones</literal>であり、<literal>Joe Jones</literal>ではありません。
    </para>

    <tip>
     <para>
<!--
      A block containing an <literal>EXCEPTION</literal> clause is significantly
      more expensive to enter and exit than a block without one.  Therefore,
      don't use <literal>EXCEPTION</literal> without need.
-->
<literal>EXCEPTION</literal>句を含んだブロックの実行に要する時間は、含まないブロックに比べてとても長くなります。
したがって、必要のない時に<literal>EXCEPTION</literal>を使用してはいけません。
     </para>
    </tip>

    <example id="plpgsql-upsert-example">
<!--
    <title>Exceptions with <command>UPDATE</command>/<command>INSERT</command></title>
-->
<title><command>UPDATE</command>/<command>INSERT</command>の例外</title>
    <para>

<!--
    This example uses exception handling to perform either
    <command>UPDATE</command> or <command>INSERT</command>, as appropriate.  It is
    recommended that applications use <command>INSERT</command> with
    <literal>ON CONFLICT DO UPDATE</literal> rather than actually using
    this pattern.  This example serves primarily to illustrate use of
    <application>PL/pgSQL</application> control flow structures:
-->
これは<command>UPDATE</command>または<command>INSERT</command>の実行における例外処理を使用した適当な例題です。
アプリケーションでは実際にこの方式を使うよりも、<literal>ON CONFLICT DO UPDATE</literal>を伴った<command>INSERT</command>を使うことが推奨されます。本例は主として<application>PL/pgSQL</application>の制御構造の使い方を示すものです。

<programlisting>
CREATE TABLE db (a INT PRIMARY KEY, b TEXT);

CREATE FUNCTION merge_db(key INT, data TEXT) RETURNS VOID AS
$$
BEGIN
    LOOP
<!--
        &#045;&#045; first try to update the key
-->
        -- 最初にキーを更新する
        UPDATE db SET b = data WHERE a = key;
        IF found THEN
            RETURN;
        END IF;
<!--
        &#045;&#045; not there, so try to insert the key
        &#045;&#045; if someone else inserts the same key concurrently,
        &#045;&#045; we could get a unique-key failure
-->
        -- キーが存在しないので、キーの挿入を試行する
        -- 他者がすでに同一のキーを挿入していたならば
        -- 一意性に違反する欠陥となります
        BEGIN
            INSERT INTO db(a,b) VALUES (key, data);
            RETURN;
        EXCEPTION WHEN unique_violation THEN
<!--
            &#045;&#045; Do nothing, and loop to try the UPDATE again.
-->
            -- 何もしないで、更新を再試行します
        END;
    END LOOP;
END;
$$
LANGUAGE plpgsql;

SELECT merge_db(1, 'david');
SELECT merge_db(1, 'dennis');
</programlisting>

<!--
     This coding assumes the <literal>unique_violation</literal> error is caused by
     the <command>INSERT</command>, and not by, say, an <command>INSERT</command> in a
     trigger function on the table.  It might also misbehave if there is
     more than one unique index on the table, since it will retry the
     operation regardless of which index caused the error.
     More safety could be had by using the
     features discussed next to check that the trapped error was the one
     expected.
-->
このコーディングでは<literal>unique_violation</literal>エラーの原因が<command>INSERT</command>によるものであり、テーブルのトリガ関数内部の<command>INSERT</command>によるものでないと仮定します。
また、テーブルに2つ以上の一意インデックスが存在した場合、どちらのインデックスがエラーの原因になろうと操作を再試行するので、誤作動となります。
捕捉したエラーが予測したものであるか検証するために、次節で記述するエラー情報を利用すれば、より安全となります。
    </para>
    </example>

   <sect3 id="plpgsql-exception-diagnostics">
<!--
    <title>Obtaining Information about an Error</title>
-->
<title>エラーに関する情報の取得</title>

    <para>
<!--
     Exception handlers frequently need to identify the specific error that
     occurred.  There are two ways to get information about the current
     exception in <application>PL/pgSQL</application>: special variables and the
     <command>GET STACKED DIAGNOSTICS</command> command.
-->
例外ハンドラはしばしば、起こった特定のエラーを識別する必要があります。
<application>PL/pgSQL</application>で現在の例外に関する情報を取得する方法は2つあります。
特殊な変数と<command>GET STACKED DIAGNOSTICS</command>コマンドです。
    </para>

    <para>
<!--
     Within an exception handler, the special variable
     <varname>SQLSTATE</varname> contains the error code that corresponds to
     the exception that was raised (refer to <xref linkend="errcodes-table"/>
     for a list of possible error codes). The special variable
     <varname>SQLERRM</varname> contains the error message associated with the
     exception. These variables are undefined outside exception handlers.
-->
例外ハンドラの内部では、特殊な変数<varname>SQLSTATE</varname>変数が起こった例外に対応したエラーコード（<xref linkend="errcodes-table"/>のエラーコード表を参照してください）を保有します。
特殊な変数<varname>SQLERRM</varname>は例外に関連したエラーメッセージを保有します。
これらの変数は、例外ハンドラの外部では定義されていません。
    </para>

    <para>
<!--
     Within an exception handler, one may also retrieve
     information about the current exception by using the
     <command>GET STACKED DIAGNOSTICS</command> command, which has the form:
-->
例外ハンドラの内部では、<command>GET STACKED DIAGNOSTICS</command>コマンドを使用して、現在の例外に関する情報を取り出すこともできます。
次のようなやり方となります。

<synopsis>
GET STACKED DIAGNOSTICS <replaceable>variable</replaceable> { = | := } <replaceable>item</replaceable> <optional> , ... </optional>;
</synopsis>

<!--
     Each <replaceable>item</replaceable> is a key word identifying a status
     value to be assigned to the specified <replaceable>variable</replaceable>
     (which should be of the right data type to receive it).  The currently
     available status items are shown
     in <xref linkend="plpgsql-exception-diagnostics-values"/>.
-->
各<replaceable>item</replaceable>は、指定された変数（これは受け取るために正しいデータ型でなければなりません）に代入される状態値を識別するキーワードです。
現在使用可能なステータス項目は<xref linkend="plpgsql-exception-diagnostics-values"/>に表示されています。
    </para>

     <table id="plpgsql-exception-diagnostics-values">
<!--
      <title>Error Diagnostics Items</title>
-->
<title>エラーの診断値</title>
      <tgroup cols="3">
       <colspec colname="col1" colwidth="2*"/>
       <colspec colname="col2" colwidth="1*"/>
       <colspec colname="col3" colwidth="2*"/>
       <thead>
        <row>
<!--
         <entry>Name</entry>
         <entry>Type</entry>
         <entry>Description</entry>
-->
<entry>名前</entry>
<entry>型</entry>
<entry>説明</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry><literal>RETURNED_SQLSTATE</literal></entry>
         <entry><type>text</type></entry>
<!--
         <entry>the SQLSTATE error code of the exception</entry>
-->
<entry>例外のSQLSTATEエラーコード</entry>
        </row>
        <row>
         <entry><literal>COLUMN_NAME</literal></entry>
         <entry><type>text</type></entry>
<!--
         <entry>the name of the column related to exception</entry>
-->
<entry>例外に関する列名</entry>
        </row>
        <row>
         <entry><literal>CONSTRAINT_NAME</literal></entry>
         <entry><type>text</type></entry>
<!--
         <entry>the name of the constraint related to exception</entry>
-->
<entry>例外に関する制約名</entry>
        </row>
        <row>
         <entry><literal>PG_DATATYPE_NAME</literal></entry>
         <entry><type>text</type></entry>
<!--
         <entry>the name of the data type related to exception</entry>
-->
<entry>例外に関するデータ型名</entry>
        </row>
        <row>
         <entry><literal>MESSAGE_TEXT</literal></entry>
         <entry><type>text</type></entry>
<!--
         <entry>the text of the exception's primary message</entry>
-->
<entry>例外の主要なメッセージのテキスト</entry>
        </row>
        <row>
         <entry><literal>TABLE_NAME</literal></entry>
         <entry><type>text</type></entry>
<!--
         <entry>the name of the table related to exception</entry>
-->
<entry>例外に関するテーブル名</entry>
        </row>
        <row>
         <entry><literal>SCHEMA_NAME</literal></entry>
         <entry><type>text</type></entry>
<!--
         <entry>the name of the schema related to exception</entry>
-->
<entry>例外に関するスキーマ名</entry>
        </row>
        <row>
         <entry><literal>PG_EXCEPTION_DETAIL</literal></entry>
         <entry><type>text</type></entry>
<!--
         <entry>the text of the exception's detail message, if any</entry>
-->
<entry>例外の詳細なメッセージのテキスト、存在する場合</entry>
        </row>
        <row>
         <entry><literal>PG_EXCEPTION_HINT</literal></entry>
         <entry><type>text</type></entry>
<!--
         <entry>the text of the exception's hint message, if any</entry>
-->
<entry>例外のヒントとなるメッセージのテキスト、存在する場合</entry>
        </row>
        <row>
         <entry><literal>PG_EXCEPTION_CONTEXT</literal></entry>
         <entry><type>text</type></entry>
<!--
         <entry>line(s) of text describing the call stack at the time of the
          exception (see <xref linkend="plpgsql-call-stack"/>)</entry>
-->
<entry>例外時における呼び出しスタックを記述するテキストの行（<xref linkend="plpgsql-call-stack"/>を参照）</entry>
        </row>
       </tbody>
      </tgroup>
     </table>

    <para>
<!--
     If the exception did not set a value for an item, an empty string
     will be returned.
-->
例外が項目の値を設定しない場合、空文字列が返されます。
    </para>

    <para>
<!--
     Here is an example:
-->
以下に例を示します。
<programlisting>
DECLARE
  text_var1 text;
  text_var2 text;
  text_var3 text;
BEGIN
<!--
  &#045;&#045; some processing which might cause an exception
-->
  -- 例外を引き起こす処理
  ...
EXCEPTION WHEN OTHERS THEN
  GET STACKED DIAGNOSTICS text_var1 = MESSAGE_TEXT,
                          text_var2 = PG_EXCEPTION_DETAIL,
                          text_var3 = PG_EXCEPTION_HINT;
END;
</programlisting>
    </para>
   </sect3>
  </sect2>

  <sect2 id="plpgsql-call-stack">
<!--
   <title>Obtaining Execution Location Information</title>
-->

<title>実行位置情報の取得</title>
   <para>
<!--
    The <command>GET DIAGNOSTICS</command> command, previously described
    in <xref linkend="plpgsql-statements-diagnostics"/>, retrieves information
    about current execution state (whereas the <command>GET STACKED
    DIAGNOSTICS</command> command discussed above reports information about
    the execution state as of a previous error).  Its <literal>PG_CONTEXT</literal>
    status item is useful for identifying the current execution
    location.  <literal>PG_CONTEXT</literal> returns a text string with line(s)
    of text describing the call stack.  The first line refers to the current
    function and currently executing <command>GET DIAGNOSTICS</command>
    command.  The second and any subsequent lines refer to calling functions
    further up the call stack.  For example:
-->
以前、<xref linkend="plpgsql-statements-diagnostics"/>に記載されていた<command>GET DIAGNOSTICS</command>コマンドは、現在の実行状態に関する情報を取得します（対して、前述の<command>GET STACKED DIAGNOSTICS</command>コマンドは一つ前のエラー時点の実行状態を報告します）。
これの<literal>PG_CONTEXT</literal>ステータス項目は現在の実行位置を識別するのに役立ちます。
<literal>PG_CONTEXT</literal>は呼び出しスタックを記述したテキスト行を含むテキスト文字列を返します。
最初の行は現在の関数と現在実行中の<command>GET DIAGNOSTICS</command>コマンドを参照します。
次行および後の行は、呼び出しスタック上の呼び出し関数を参照します。
例を示します。

<programlisting>
CREATE OR REPLACE FUNCTION outer_func() RETURNS integer AS $$
BEGIN
  RETURN inner_func();
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION inner_func() RETURNS integer AS $$
DECLARE
  stack text;
BEGIN
  GET DIAGNOSTICS stack = PG_CONTEXT;
  RAISE NOTICE E'--- Call Stack ---\n%', stack;
  RETURN 1;
END;
$$ LANGUAGE plpgsql;

SELECT outer_func();

NOTICE:  --- Call Stack ---
PL/pgSQL function inner_func() line 5 at GET DIAGNOSTICS
PL/pgSQL function outer_func() line 3 at RETURN
CONTEXT:  PL/pgSQL function outer_func() line 3 at RETURN
 outer_func
 ------------
           1
(1 row)
</programlisting>

   </para>

   <para>
<!--
    <literal>GET STACKED DIAGNOSTICS ... PG_EXCEPTION_CONTEXT</literal>
    returns the same sort of stack trace, but describing the location
    at which an error was detected, rather than the current location.
-->
    <literal>GET STACKED DIAGNOSTICS ... PG_EXCEPTION_CONTEXT</literal>は同種のスタックトレースを返しますが、現在の位置ではなく、エラーが検出されたところの位置を記述します。
   </para>
  </sect2>
  </sect1>

  <sect1 id="plpgsql-cursors">
<!--
   <title>Cursors</title>
-->
<title>カーソル</title>

   <indexterm zone="plpgsql-cursors">
<!--
    <primary>cursor</primary>
    <secondary>in PL/pgSQL</secondary>
-->
<primary>カーソル</primary>
<secondary>PL/pgSQLにおける</secondary>
   </indexterm>

   <para>
<!--
    Rather than executing a whole query at once, it is possible to set
    up a <firstterm>cursor</firstterm> that encapsulates the query, and then read
    the query result a few rows at a time. One reason for doing this is
    to avoid memory overrun when the result contains a large number of
    rows. (However, <application>PL/pgSQL</application> users do not normally need
    to worry about that, since <literal>FOR</literal> loops automatically use a cursor
    internally to avoid memory problems.) A more interesting usage is to
    return a reference to a cursor that a function has created, allowing the
    caller to read the rows. This provides an efficient way to return
    large row sets from functions.
-->
問い合わせ全体を一度に実行するのではなく、<firstterm>カーソル</firstterm>を設定して、問い合わせをカプセル化し、問い合わせの結果を一度に数行ずつ読み取ることができます。
これを行う理由の1つは、結果内に多数の行がある場合のメモリの枯渇を防ぐことです。
（しかし、<application>PL/pgSQL</application>ユーザは通常これを心配する必要はありません。
<literal>FOR</literal>ループは自動的にカーソルを内部的に使用してメモリの問題を防ぐからです。）
より興味深い使用方法として、呼び出し元が行を読み取ることをできるように、作成されたカーソルへの参照を返す方法があります。
これにより、関数から大量の行集合を返す際の効率が向上します。
   </para>

   <sect2 id="plpgsql-cursor-declarations">
<!--
    <title>Declaring Cursor Variables</title>
-->
<title>カーソル変数の宣言</title>

    <para>
<!--
     All access to cursors in <application>PL/pgSQL</application> goes through
     cursor variables, which are always of the special data type
     <type>refcursor</type>.  One way to create a cursor variable
     is just to declare it as a variable of type <type>refcursor</type>.
     Another way is to use the cursor declaration syntax,
     which in general is:
-->
<application>PL/pgSQL</application>におけるカーソルへのアクセスは全て、カーソル変数を経由します。
カーソル変数は、常に特殊な<type>refcursor</type>データ型です。
カーソル変数を作成する1つの方法は、単に<type>refcursor</type>型の変数として宣言することです。
他の方法は、カーソル宣言構文を使用することです。
以下にその一般形を示します。
<synopsis>
<replaceable>name</replaceable> <optional> <optional> NO </optional> SCROLL </optional> CURSOR <optional> ( <replaceable>arguments</replaceable> ) </optional> FOR <replaceable>query</replaceable>;
</synopsis>
<!--
     (<literal>FOR</literal> can be replaced by <literal>IS</literal> for
     <productname>Oracle</productname> compatibility.)
     If <literal>SCROLL</literal> is specified, the cursor will be capable of
     scrolling backward; if <literal>NO SCROLL</literal> is specified, backward
     fetches will be rejected; if neither specification appears, it is
     query-dependent whether backward fetches will be allowed.
     <replaceable>arguments</replaceable>, if specified, is a
     comma-separated list of pairs <literal><replaceable>name</replaceable>
     <replaceable>datatype</replaceable></literal> that define names to be
     replaced by parameter values in the given query.  The actual
     values to substitute for these names will be specified later,
     when the cursor is opened.
-->
（<productname>Oracle</productname>との互換性のため、<literal>FOR</literal>は<literal>IS</literal>に置き換えることができます。）
もし<literal>SCROLL</literal>を指定すれば、カーソルは逆方向に移動できます。
もし<literal>NO SCROLL</literal>を指定すれば、逆方向の行の取り出しはできません。
どちらも指定しない時、逆方向に取り出しできるかは問い合わせに依存します。
もし<replaceable>arguments</replaceable>があれば、<literal><replaceable>name</replaceable> <replaceable>datatype</replaceable></literal>をカンマで区切ったリストで、与えられた問い合わせ内のパラメータ値として置換される名前を定義します。
その名前に実際に置換される値は、カーソルを開いた時点より後に指定されます。
    </para>
    <para>
<!--
     Some examples:
-->
以下に例を示します。
<programlisting>
DECLARE
    curs1 refcursor;
    curs2 CURSOR FOR SELECT * FROM tenk1;
    curs3 CURSOR (key integer) FOR SELECT * FROM tenk1 WHERE unique1 = key;
</programlisting>
<!--
     All three of these variables have the data type <type>refcursor</type>,
     but the first can be used with any query, while the second has
     a fully specified query already <firstterm>bound</firstterm> to it, and the last
     has a parameterized query bound to it.  (<literal>key</literal> will be
     replaced by an integer parameter value when the cursor is opened.)
     The variable <literal>curs1</literal>
     is said to be <firstterm>unbound</firstterm> since it is not bound to
     any particular query.
-->
これら3つの変数は全て<type>refcursor</type>データ型を持ちますが、最初のものは全ての問い合わせに使用でき、2番目には完全な問い合わせが既に<firstterm>バウンド</firstterm>されています（結び付けられています）。
また、最後のものには、パラメータ付きの問い合わせがバウンドされています
（<literal>key</literal>はカーソルが開いた時に整数パラメータ値に置き換えられます）。
<literal>curs1</literal>変数は、特定の問い合わせに結び付けられていませんので、<firstterm>アンバウンド</firstterm>であると呼ばれます。
    </para>

    <para>
     The <literal>SCROLL</literal> option cannot be used when the cursor's
     query uses <literal>FOR UPDATE/SHARE</literal>.  Also, it is
     best to use <literal>NO SCROLL</literal> with a query that involves
     volatile functions.  The implementation of <literal>SCROLL</literal>
     assumes that re-reading the query's output will give consistent
     results, which a volatile function might not do.
    </para>
   </sect2>

   <sect2 id="plpgsql-cursor-opening">
<!--
    <title>Opening Cursors</title>
-->
<title>カーソルを開く</title>

    <para>
<!--
     Before a cursor can be used to retrieve rows, it must be
     <firstterm>opened</firstterm>. (This is the equivalent action to the SQL
     command <command>DECLARE CURSOR</command>.) <application>PL/pgSQL</application> has
     three forms of the <command>OPEN</command> statement, two of which use unbound
     cursor variables while the third uses a bound cursor variable.
-->
カーソルを使用して行を取り出す前に、<firstterm>開かれる</firstterm>必要があります。
（これは<command>DECLARE CURSOR</command> SQLコマンドの動作と同じです。）
<application>PL/pgSQL</application>には3種類の<command>OPEN</command>文があり、そのうちの2つはアンバウンドカーソル変数を使用し、残りの1つはバウンドカーソル変数を使用します。
    </para>

    <note>
     <para>
<!--
      Bound cursor variables can also be used without explicitly opening the cursor,
      via the <command>FOR</command> statement described in
      <xref linkend="plpgsql-cursor-for-loop"/>.
-->
バウンドカーソル変数は<xref linkend="plpgsql-cursor-for-loop"/>で説明されている<command>FOR</command>文で、明示的にカーソルを開かなくても使用することができます。
     </para>
    </note>

    <sect3>
     <title><command>OPEN FOR</command> <replaceable>query</replaceable></title>

<synopsis>
OPEN <replaceable>unbound_cursorvar</replaceable> <optional> <optional> NO </optional> SCROLL </optional> FOR <replaceable>query</replaceable>;
</synopsis>

       <para>
<!--
        The cursor variable is opened and given the specified query to
        execute.  The cursor cannot be open already, and it must have been
        declared as an unbound cursor variable (that is, as a simple
        <type>refcursor</type> variable).  The query must be a
        <command>SELECT</command>, or something else that returns rows
        (such as <command>EXPLAIN</command>).  The query
        is treated in the same way as other SQL commands in
        <application>PL/pgSQL</application>: <application>PL/pgSQL</application>
        variable names are substituted, and the query plan is cached for
        possible reuse.  When a <application>PL/pgSQL</application>
        variable is substituted into the cursor query, the value that is
        substituted is the one it has at the time of the <command>OPEN</command>;
        subsequent changes to the variable will not affect the cursor's
        behavior.
        The <literal>SCROLL</literal> and <literal>NO SCROLL</literal>
        options have the same meanings as for a bound cursor.
-->
カーソル変数は開かれ、実行するよう指定した問い合わせが付与されます。
既に開いたカーソルを開くことはできず、また、アンバウンドカーソル変数として（つまり、単なる<type>refcursor</type>変数として）宣言されていなければなりません。
この問い合わせは<command>SELECT</command>文であるか、または（<command>EXPLAIN</command>のように）何らかの行を返すものでなければなりません。
この問い合わせは、他の<application>PL/pgSQL</application>のSQL文と同様の方法で扱われます。
<application>PL/pgSQL</application>の変数名は置き換えられ、問い合わせ計画は再利用できるようにキャッシュされます。
<application>PL/pgSQL</application>変数がカーソルを使用する問い合わせに代入された時、変数は<command>OPEN</command>時の値となり、その後の変更はカーソルの動きに影響しません。
<literal>SCROLL</literal>および<literal>NO SCROLL</literal>オプションの意味はバウンドカーソルと同様です。
       </para>

       <para>
<!--
        An example:
-->
以下に例を示します。
<programlisting>
OPEN curs1 FOR SELECT * FROM foo WHERE key = mykey;
</programlisting>
       </para>
     </sect3>

    <sect3>
     <title><command>OPEN FOR EXECUTE</command></title>

<synopsis>
OPEN <replaceable>unbound_cursorvar</replaceable> <optional> <optional> NO </optional> SCROLL </optional> FOR EXECUTE <replaceable class="command">query_string</replaceable>
                                     <optional> USING <replaceable>expression</replaceable> <optional>, ... </optional> </optional>;
</synopsis>

         <para>
<!--
          The cursor variable is opened and given the specified query to
          execute.  The cursor cannot be open already, and it must have been
          declared as an unbound cursor variable (that is, as a simple
          <type>refcursor</type> variable).  The query is specified as a string
          expression, in the same way as in the <command>EXECUTE</command>
          command.  As usual, this gives flexibility so the query plan can vary
          from one run to the next (see <xref linkend="plpgsql-plan-caching"/>),
          and it also means that variable substitution is not done on the
          command string. As with <command>EXECUTE</command>, parameter values
          can be inserted into the dynamic command via
          <literal>format()</literal> and <literal>USING</literal>.
          The <literal>SCROLL</literal> and
          <literal>NO SCROLL</literal> options have the same meanings as for a bound
          cursor.
-->
カーソル変数は開かれ、実行するよう指定した問い合わせが付与されます。
既に開いたカーソルを開くことはできず、また、アンバウンドカーソル変数として（つまり、単なる<type>refcursor</type>変数として）宣言されていなければなりません。
問い合わせは、<command>EXECUTE</command>コマンドと同じ方法による文字列式として指定されます。
通常と同様に、これにより、次回に実行する際に違った問い合わせを計画できる柔軟性が得られます(<xref linkend="plpgsql-plan-caching"/>参照)。
また、変数置換がコマンド文字列上で行われないことも意味します。
<command>EXECUTE</command>と同様に<literal>format()</literal>と<literal>USING</literal>を介して動的コマンドにパラメータ値を挿入することができます。
<literal>SCROLL</literal>および<literal>NO SCROLL</literal>オプションの意味はバウンドカーソルと同様です。
         </para>

       <para>
<!--
        An example:
-->
以下に例を示します。
<programlisting>
OPEN curs1 FOR EXECUTE format('SELECT * FROM %I WHERE col1 = $1',tabname) USING keyvalue;
</programlisting>
<!--
        In this example, the table name is inserted into the query via
        <function>format()</function>.  The comparison value for <literal>col1</literal>
        is inserted via a <literal>USING</literal> parameter, so it needs
        no quoting.
-->
この例では、テーブル名は問い合わせに<function>format()</function>で挿入されています。
<literal>col1</literal>との比較値は<literal>USING</literal>経由で埋め込まれますので、引用符を付ける必要がありません。
       </para>
     </sect3>

    <sect3 id="plpgsql-open-bound-cursor">
<!--
     <title>Opening a Bound Cursor</title>
-->
<title>バウンドカーソルを開く</title>

<synopsis>
OPEN <replaceable>bound_cursorvar</replaceable> <optional> ( <optional> <replaceable>argument_name</replaceable> := </optional> <replaceable>argument_value</replaceable> <optional>, ...</optional> ) </optional>;
</synopsis>

         <para>
<!--
          This form of <command>OPEN</command> is used to open a cursor
          variable whose query was bound to it when it was declared.  The
          cursor cannot be open already.  A list of actual argument value
          expressions must appear if and only if the cursor was declared to
          take arguments.  These values will be substituted in the query.
-->
宣言時に問い合わせが結び付いたカーソル変数を開くために使用される<command>OPEN</command>の形式です。
既に開いたカーソルを開くことはできません。
実引数の式のリストはカーソルが引数を取るものと宣言された場合にのみ現れます。
これらの値は問い合わせの中で置き換えられます。
         </para>

         <para>
<!--
          The query plan for a bound cursor is always considered cacheable;
          there is no equivalent of <command>EXECUTE</command> in this case.
          Notice that <literal>SCROLL</literal> and <literal>NO SCROLL</literal> cannot be
          specified in <command>OPEN</command>, as the cursor's scrolling
          behavior was already determined.
-->
バウンドカーソルの問い合わせ計画は常にキャッシュ可能とみなされます。
この場合、<command>EXECUTE</command>と等価なものはありません。
<literal>SCROLL</literal>および<literal>NO SCROLL</literal>を<command>OPEN</command>において指定できないことに注意してください。
カーソル移動の仕様はすでに決まっているからです。
         </para>

         <para>
<!--
          Argument values can be passed using either <firstterm>positional</firstterm>
          or <firstterm>named</firstterm> notation.  In positional
          notation, all arguments are specified in order.  In named notation,
          each argument's name is specified using <literal>:=</literal> to
          separate it from the argument expression. Similar to calling
          functions, described in <xref linkend="sql-syntax-calling-funcs"/>, it
          is also allowed to mix positional and named notation.
-->
<firstterm>位置的</firstterm>表記または<firstterm>記名的</firstterm>表記を使用して、引数の値を渡すことができます。
位置的表記では、全ての引数が順番に指定されます。
記名的表記では、引数の式と区別するために<literal>:=</literal>を使用して、各々の引数の名前が指定されます。
<xref linkend="sql-syntax-calling-funcs"/>に記述した関数呼び出しと同様に、位置的表記と記名的表記を混用できます。
         </para>

         <para>
<!--
          Examples (these use the cursor declaration examples above):
-->
例を示します（ここでは上例のカーソル宣言を使用します）。
<programlisting>
OPEN curs2;
OPEN curs3(42);
OPEN curs3(key := 42);
</programlisting>
         </para>

         <para>
<!--
          Because variable substitution is done on a bound cursor's query,
          there are really two ways to pass values into the cursor: either
          with an explicit argument to <command>OPEN</command>, or implicitly by
          referencing a <application>PL/pgSQL</application> variable in the query.
          However, only variables declared before the bound cursor was
          declared will be substituted into it.  In either case the value to
          be passed is determined at the time of the <command>OPEN</command>.
          For example, another way to get the same effect as the
          <literal>curs3</literal> example above is
-->
変数の代入はバウンドカーソルの問い合わせで行われるため、カーソルへ値を渡す方法が2つあります。
<command>OPEN</command>コマンドの明確な引数とするものと、問い合わせにおける<application>PL/pgSQL</application>変数として暗黙的に参照するものです。
しかし、バウンドカーソルの宣言より前に宣言した変数だけが代入されます。
どちらの場合も、<command>OPEN</command>の実行時に変数値が決まります。
例えば、上例の<literal>curs3</literal>と同じ結果を取得する方法を、以下に示します。
<programlisting>
DECLARE
    key integer;
    curs4 CURSOR FOR SELECT * FROM tenk1 WHERE unique1 = key;
BEGIN
    key := 42;
    OPEN curs4;
</programlisting>
         </para>
     </sect3>
   </sect2>

   <sect2 id="plpgsql-cursor-using">
<!--
    <title>Using Cursors</title>
-->
<title>カーソルの使用</title>

    <para>
<!--
     Once a cursor has been opened, it can be manipulated with the
     statements described here.
-->
カーソルを開いてから、ここで説明する文を使用してカーソルを扱うことができます。
    </para>

    <para>
<!--
     These manipulations need not occur in the same function that
     opened the cursor to begin with.  You can return a <type>refcursor</type>
     value out of a function and let the caller operate on the cursor.
     (Internally, a <type>refcursor</type> value is simply the string name
     of a so-called portal containing the active query for the cursor.  This name
     can be passed around, assigned to other <type>refcursor</type> variables,
     and so on, without disturbing the portal.)
-->
これらの操作は、カーソルを開始するために開いた関数内で行う必要はありません。
関数から<type>refcursor</type>値を返し、呼び出し元でそのカーソルの操作をさせることもできます。
（内部的には<type>refcursor</type>値は、カーソルへの有効な問い合わせを持つポータルの名前を示す単なる文字列です。
この名前は、ポータルを壊すことなく、他の<type>refcursor</type>型の変数に代入することで、他に渡すことができます。）
    </para>

    <para>
<!--
     All portals are implicitly closed at transaction end.  Therefore
     a <type>refcursor</type> value is usable to reference an open cursor
     only until the end of the transaction.
-->
全てのポータルは、暗黙的にトランザクションの終わりで閉ざされます。
したがって、<type>refcursor</type>値はそのトランザクションの終わりまでの間のみ開いたカーソルへの参照として有効です。
    </para>

    <sect3>
     <title><literal>FETCH</literal></title>

<synopsis>
FETCH <optional> <replaceable>direction</replaceable> { FROM | IN } </optional> <replaceable>cursor</replaceable> INTO <replaceable>target</replaceable>;
</synopsis>

    <para>
<!--
     <command>FETCH</command> retrieves the next row from the
     cursor into a target, which might be a row variable, a record
     variable, or a comma-separated list of simple variables, just like
     <command>SELECT INTO</command>.  If there is no next row, the
     target is set to NULL(s).  As with <command>SELECT
     INTO</command>, the special variable <literal>FOUND</literal> can
     be checked to see whether a row was obtained or not.
-->
<command>FETCH</command>は<command>SELECT INTO</command>と同様に、カーソルから次の行を抽出し、対象に格納します。
対象とは、行変数、レコード変数、または単純な変数をカンマで区切ったリストです。
<command>SELECT INTO</command>の場合と同様、特殊な<literal>FOUND</literal>変数を検査することで、行が取得できたかどうかを確認することができます。
    </para>

    <para>
<!--
     The <replaceable>direction</replaceable> clause can be any of the
     variants allowed in the SQL <xref linkend="sql-fetch"/>
     command except the ones that can fetch
     more than one row; namely, it can be
-->
<replaceable>direction</replaceable>句は複数行を取り出すことができるコマンドを除き、SQL <xref linkend="sql-fetch"/>で許可されたどのようなコマンドも可能です。
すなわち、以下のものです。
     <literal>NEXT</literal>,
     <literal>PRIOR</literal>,
     <literal>FIRST</literal>,
     <literal>LAST</literal>,
     <literal>ABSOLUTE</literal> <replaceable>count</replaceable>,
     <literal>RELATIVE</literal> <replaceable>count</replaceable>,
<!--
     <literal>FORWARD</literal>, or
-->
     <literal>FORWARD</literal>または
     <literal>BACKWARD</literal>.
<!--
     Omitting <replaceable>direction</replaceable> is the same
     as specifying <literal>NEXT</literal>.
     In the forms using a <replaceable>count</replaceable>,
     the <replaceable>count</replaceable> can be any integer-valued
     expression (unlike the SQL <command>FETCH</command> command,
     which only allows an integer constant).
     <replaceable>direction</replaceable> values that require moving
     backward are likely to fail unless the cursor was declared or opened
     with the <literal>SCROLL</literal> option.
-->
<replaceable>direction</replaceable>句の省略は、<literal>NEXT</literal>の指定と同じです。
<replaceable>count</replaceable>を使う形式では、<replaceable>count</replaceable>はいかなる整数値の式も可能です。(SQL <command>FETCH</command>コマンドとは異なります。あちらは整数定数のみを受け付けます。)
<literal>SCROLL</literal>オプションを用いてカーソルを宣言または開かないと、<replaceable>direction</replaceable>の値による逆方向への移動の要求は失敗します。
    </para>

    <para>
<!--
     <replaceable>cursor</replaceable> must be the name of a <type>refcursor</type>
     variable that references an open cursor portal.
-->
<replaceable>cursor</replaceable>名は、開いているカーソルのポータルを参照する<type>refcursor</type>変数名でなければなりません。
    </para>

    <para>
<!--
     Examples:
-->
例：
<programlisting>
FETCH curs1 INTO rowvar;
FETCH curs2 INTO foo, bar, baz;
FETCH LAST FROM curs3 INTO x, y;
FETCH RELATIVE -2 FROM curs4 INTO x;
</programlisting>
       </para>
     </sect3>

    <sect3>
     <title><literal>MOVE</literal></title>

<synopsis>
MOVE <optional> <replaceable>direction</replaceable> { FROM | IN } </optional> <replaceable>cursor</replaceable>;
</synopsis>

    <para>
<!--
     <command>MOVE</command> repositions a cursor without retrieving
     any data. <command>MOVE</command> works exactly like the
     <command>FETCH</command> command, except it only repositions the
     cursor and does not return the row moved to. As with <command>SELECT
     INTO</command>, the special variable <literal>FOUND</literal> can
     be checked to see whether there was a next row to move to.
-->
<command>MOVE</command>コマンドは、データを取り出さないでカーソルの位置を変更します。
移動先の行を返さないでカーソルの位置だけを変更することを除けば、<command>FETCH</command>コマンドと同一の働きをします。
<command>SELECT INTO</command>と同様に、特殊な変数<literal>FOUND</literal>を用いて、移動先に行が存在するかどうかを検査できます。
    </para>

    <para>
<!--
     Examples:
-->
例:
<programlisting>
MOVE curs1;
MOVE LAST FROM curs3;
MOVE RELATIVE -2 FROM curs4;
MOVE FORWARD 2 FROM curs4;
</programlisting>
       </para>
     </sect3>

    <sect3>
     <title><literal>UPDATE/DELETE WHERE CURRENT OF</literal></title>

<synopsis>
UPDATE <replaceable>table</replaceable> SET ... WHERE CURRENT OF <replaceable>cursor</replaceable>;
DELETE FROM <replaceable>table</replaceable> WHERE CURRENT OF <replaceable>cursor</replaceable>;
</synopsis>

       <para>
<!--
        When a cursor is positioned on a table row, that row can be updated
        or deleted using the cursor to identify the row.  There are
        restrictions on what the cursor's query can be (in particular,
        no grouping) and it's best to use <literal>FOR UPDATE</literal> in the
        cursor.  For more information see the
        <xref linkend="sql-declare"/>
        reference page.
-->
カーソルの位置をテーブルの行に変更すれば、カーソルによって特定した行を更新または消去できます。
カーソル問い合わせは何が許されているのか（特にグループ化しないとき）についての制限があり、それはカーソル内で<literal>FOR UPDATE</literal>を使用することが最善です。
より詳細については<xref linkend="sql-declare"/>マニュアルページを参照下さい。
       </para>

       <para>
<!--
        An example:
-->
以下に例を示します。
<programlisting>
UPDATE foo SET dataval = myval WHERE CURRENT OF curs1;
</programlisting>
       </para>
     </sect3>

    <sect3>
     <title><literal>CLOSE</literal></title>

<synopsis>
CLOSE <replaceable>cursor</replaceable>;
</synopsis>

       <para>
<!--
        <command>CLOSE</command> closes the portal underlying an open
        cursor.  This can be used to release resources earlier than end of
        transaction, or to free up the cursor variable to be opened again.
-->
<command>CLOSE</command>はポータルの背後にあるカーソルを閉じます。
これを使用してトランザクションの終わりよりも前にリソースを解放することができ、また、カーソル変数を解放し、再度開くことができます。
       </para>

       <para>
<!--
        An example:
-->
例：
<programlisting>
CLOSE curs1;
</programlisting>
       </para>
     </sect3>

    <sect3>
<!--
     <title>Returning Cursors</title>
-->
<title>カーソルを返す</title>

       <para>
<!--
        <application>PL/pgSQL</application> functions can return cursors to the
        caller. This is useful to return multiple rows or columns,
        especially with very large result sets.  To do this, the function
        opens the cursor and returns the cursor name to the caller (or simply
        opens the cursor using a portal name specified by or otherwise known
        to the caller).  The caller can then fetch rows from the cursor. The
        cursor can be closed by the caller, or it will be closed automatically
        when the transaction closes.
-->
<application>PL/pgSQL</application>関数では、呼び出し元にカーソルを返すことができます。
この方法は、関数から複数行または複数列を返す場合、特にその結果集合が非常に大きい場合に有用です。
これを行うには、関数はカーソルを開き、呼び出し元にカーソル名を返します（もしくは、もし呼び出し元でポータル名がわかっていれば、単純に指定されたポータル名を使用してカーソルを開きます）。
これにより、呼び出し元はカーソルから行を取り出すことができるようになります。
カーソルは呼び出し元で閉じることができます。
または、トランザクションが終了した際に自動的に閉じられます。
       </para>

       <para>
<!--
        The portal name used for a cursor can be specified by the
        programmer or automatically generated.  To specify a portal name,
        simply assign a string to the <type>refcursor</type> variable before
        opening it.  The string value of the <type>refcursor</type> variable
        will be used by <command>OPEN</command> as the name of the underlying portal.
        However, if the <type>refcursor</type> variable is null,
        <command>OPEN</command> automatically generates a name that does not
        conflict with any existing portal, and assigns it to the
        <type>refcursor</type> variable.
-->
カーソル用のポータル名は、プログラマが指定するか、または自動的に生成されます。
ポータル名を指定するには、開く前に、単に<type>refcursor</type>変数に文字列を代入します。
<type>refcursor</type>変数の文字列値は<command>OPEN</command>によって、背後のポータル名として使用されます。
しかし、<type>refcursor</type>変数がNULLの場合、<command>OPEN</command>は自動的に既存のポータルと競合しない名前を生成し、それを<type>refcursor</type>変数に代入します。
       </para>

       <note>
        <para>
<!--
         A bound cursor variable is initialized to the string value
         representing its name, so that the portal name is the same as
         the cursor variable name, unless the programmer overrides it
         by assignment before opening the cursor.  But an unbound cursor
         variable defaults to the null value initially, so it will receive
         an automatically-generated unique name, unless overridden.
-->
バウンドカーソル変数は、その名前を表現する文字列値で初期化されます。
そのため、プログラマがカーソルを開く前に代入により上書きしない限り、ポータル名はカーソル変数と同じになります。
しかし、アンバウンドカーソル変数の初期値はデフォルトでNULLです。
そのため、上書きされていない場合に自動的に生成される一意な名前を受け取ります。
        </para>
       </note>

       <para>
<!--
        The following example shows one way a cursor name can be supplied by
        the caller:
-->
以下の例は、呼び出し元でカーソル名を指定する方法を示しています。

<programlisting>
CREATE TABLE test (col text);
INSERT INTO test VALUES ('123');

CREATE FUNCTION reffunc(refcursor) RETURNS refcursor AS '
BEGIN
    OPEN $1 FOR SELECT col FROM test;
    RETURN $1;
END;
' LANGUAGE plpgsql;

BEGIN;
SELECT reffunc('funccursor');
FETCH ALL IN funccursor;
COMMIT;
</programlisting>
       </para>

       <para>
<!--
        The following example uses automatic cursor name generation:
-->
以下の例では、自動的に生成されたカーソル名を使用しています。

<programlisting>
CREATE FUNCTION reffunc2() RETURNS refcursor AS '
DECLARE
    ref refcursor;
BEGIN
    OPEN ref FOR SELECT col FROM test;
    RETURN ref;
END;
' LANGUAGE plpgsql;

<!--
&#045;- need to be in a transaction to use cursors.
-->
-- カーソルを使用するには、トランザクション内部である必要があります。
BEGIN;
SELECT reffunc2();

      reffunc2
--------------------
 &lt;unnamed cursor 1&gt;
(1 row)

FETCH ALL IN "&lt;unnamed cursor 1&gt;";
COMMIT;
</programlisting>
       </para>

       <para>
<!--
        The following example shows one way to return multiple cursors
        from a single function:
-->
以下の例は単一関数から複数のカーソルを返す方法を示しています。

<programlisting>
CREATE FUNCTION myfunc(refcursor, refcursor) RETURNS SETOF refcursor AS $$
BEGIN
    OPEN $1 FOR SELECT * FROM table_1;
    RETURN NEXT $1;
    OPEN $2 FOR SELECT * FROM table_2;
    RETURN NEXT $2;
END;
$$ LANGUAGE plpgsql;

<!--
&#045;&#045; need to be in a transaction to use cursors.
-->
-- カーソルを使用するには、トランザクション内部である必要があります。
BEGIN;

SELECT * FROM myfunc('a', 'b');

FETCH ALL FROM a;
FETCH ALL FROM b;
COMMIT;
</programlisting>
       </para>
     </sect3>
   </sect2>

   <sect2 id="plpgsql-cursor-for-loop">
<!--
    <title>Looping through a Cursor's Result</title>
-->
<title>カーソル結果に対するループ</title>

    <para>
<!--
     There is a variant of the <command>FOR</command> statement that allows
     iterating through the rows returned by a cursor.  The syntax is:
-->
カーソルで返される行に対して反復することができる<command>FOR</command>文の亜種があります。
構文は以下のようになります。

<synopsis>
<optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>
FOR <replaceable>recordvar</replaceable> IN <replaceable>bound_cursorvar</replaceable> <optional> ( <optional> <replaceable>argument_name</replaceable> := </optional> <replaceable>argument_value</replaceable> <optional>, ...</optional> ) </optional> LOOP
    <replaceable>statements</replaceable>
END LOOP <optional> <replaceable>label</replaceable> </optional>;
</synopsis>

<!--
     The cursor variable must have been bound to some query when it was
     declared, and it <emphasis>cannot</emphasis> be open already.  The
     <command>FOR</command> statement automatically opens the cursor, and it closes
     the cursor again when the loop exits.  A list of actual argument value
     expressions must appear if and only if the cursor was declared to take
     arguments.  These values will be substituted in the query, in just
     the same way as during an <command>OPEN</command> (see <xref
     linkend="plpgsql-open-bound-cursor"/>).
-->
カーソル変数は宣言されたとき、何らかの問い合わせとバウンドされていなければならず、また既に開かれていては<emphasis>なりません</emphasis>。
<command>FOR</command>文は自動的にカーソルを開き、ループから抜けたときに再度閉じます。
実際の引数値式のリストは、カーソルが引数を取ることを宣言された場合に限ってのみ出現できます。
これらの値は、<command>OPEN</command>過程と同じ方法で、問い合わせの中で置換されます（<xref linkend="plpgsql-open-bound-cursor"/>を参照してください）。
   </para>

   <para>
<!--
     The variable <replaceable>recordvar</replaceable> is automatically
     defined as type <type>record</type> and exists only inside the loop (any
     existing definition of the variable name is ignored within the loop).
     Each row returned by the cursor is successively assigned to this
     record variable and the loop body is executed.
-->
<replaceable>recordvar</replaceable>変数は、<type>record</type>型として自動的に定義され、ループ内でのみ存在します
（存在するいかなる変数名の定義もループ内では無視されます）。
カーソルによって返されたそれぞれの行はこのレコード変数に引き続いて割り当てられ、ループ本体が実行されます。
    </para>
   </sect2>

  </sect1>

  <sect1 id="plpgsql-transactions">
<!--
   <title>Transaction Management</title>
-->
   <title>トランザクション制御</title>

   <para>
<!--
    In procedures invoked by the <command>CALL</command> command
    as well as in anonymous code blocks (<command>DO</command> command),
    it is possible to end transactions using the
    commands <command>COMMIT</command> and <command>ROLLBACK</command>.  A new
    transaction is started automatically after a transaction is ended using
    these commands, so there is no separate <command>START
    TRANSACTION</command> command.  (Note that <command>BEGIN</command> and
    <command>END</command> have different meanings in PL/pgSQL.)
-->
<command>CALL</command>コマンドで呼び出されたプロシージャ、また同様に無名コードブロック（<command>DO</command>コマンド）では、<command>COMMIT</command>および<command>ROLLBACK</command>コマンドを使ってトランザクションを終えることができます。
トランザクションをこれらコマンドで終了した後、新たなトランザクションが自動的に開始されます。そのため、別途の<command>START TRANSACTION</command>はありません。
（PL/pgSQLでは<command>BEGIN</command>と<command>END</command>は別の意味を持つことに注意してください。）
   </para>

   <para>
<!--
    Here is a simple example:
-->
以下に例を示します。
<programlisting>
CREATE PROCEDURE transaction_test1()
LANGUAGE plpgsql
AS $$
BEGIN
    FOR i IN 0..9 LOOP
        INSERT INTO test1 (a) VALUES (i);
        IF i % 2 = 0 THEN
            COMMIT;
        ELSE
            ROLLBACK;
        END IF;
    END LOOP;
END;
$$;

CALL transaction_test1();
</programlisting>
   </para>

   <indexterm zone="plpgsql-transaction-chain">
<!--
    <primary>chained transactions</primary>
    <secondary>in PL/pgSQL</secondary>
-->
    <primary>連鎖トランザクション</primary>
    <secondary>PL/pgSQLでの</secondary>
   </indexterm>

   <para id="plpgsql-transaction-chain">
<!--
    A new transaction starts out with default transaction characteristics such
    as transaction isolation level.  In cases where transactions are committed
    in a loop, it might be desirable to start new transactions automatically
    with the same characteristics as the previous one.  The commands
    <command>COMMIT AND CHAIN</command> and <command>ROLLBACK AND
    CHAIN</command> accomplish this.
-->
新しいトランザクションは、トランザクション隔離レベル等のデフォルトのトランザクションの特性で開始します。
トランザクションがループ内でコミットされた場合、新しいトランザクションは前のトランザクションと同じ特性で自動的に開始するのが好ましいかもしれません。
コマンド<command>COMMIT AND CHAIN</command>と<command>ROLLBACK AND CHAIN</command>はそのように動作します。
   </para>

   <para>
<!--
    Transaction control is only possible in <command>CALL</command> or
    <command>DO</command> invocations from the top level or nested
    <command>CALL</command> or <command>DO</command> invocations without any
    other intervening command.  For example, if the call stack is
    <command>CALL proc1()</command> &rarr; <command>CALL proc2()</command>
    &rarr; <command>CALL proc3()</command>, then the second and third
    procedures can perform transaction control actions.  But if the call stack
    is <command>CALL proc1()</command> &rarr; <command>SELECT
    func2()</command> &rarr; <command>CALL proc3()</command>, then the last
    procedure cannot do transaction control, because of the
    <command>SELECT</command> in between.
-->
トランザクション制御は、トップレベル、または、他の干渉するコマンドを伴わない入れ子の<command>CALL</command>または<command>DO</command>呼び出しからの、<command>CALL</command>または<command>DO</command>による呼び出しのみで可能です。
例えば、呼び出しスタックが<command>CALL proc1()</command> &rarr; <command>CALL proc2()</command> &rarr; <command>CALL proc3()</command>である場合、二番目と三番目のプロシージャはトランザクション制御を実行できます。
しかし、呼び出しスタックが<command>CALL proc1()</command> &rarr; <command>SELECT func2()</command> &rarr; <command>CALL proc3()</command>である場合、間の<command>SELECT</command>のため、最後のプロシージャはトランザクション制御を実行できません。
   </para>

   <para>
<!--
    Special considerations apply to cursor loops.  Consider this example:
-->
カーソルループには特別な考慮事項が当てはまります。
以下の例をよく確認してください。
<programlisting>
CREATE PROCEDURE transaction_test2()
LANGUAGE plpgsql
AS $$
DECLARE
    r RECORD;
BEGIN
    FOR r IN SELECT * FROM test2 ORDER BY x LOOP
        INSERT INTO test1 (a) VALUES (r.x);
        COMMIT;
    END LOOP;
END;
$$;

CALL transaction_test2();
</programlisting>
<!--
    Normally, cursors are automatically closed at transaction commit.
    However, a cursor created as part of a loop like this is automatically
    converted to a holdable cursor by the first <command>COMMIT</command> or
    <command>ROLLBACK</command>.  That means that the cursor is fully
    evaluated at the first <command>COMMIT</command> or
    <command>ROLLBACK</command> rather than row by row.  The cursor is still
    removed automatically after the loop, so this is mostly invisible to the
    user.
-->
通常、カーソルはトランザクションのコミット時に自動的に閉じられます。
しかしながら、このようにループの一部として作られたカーソルは、最初の<command>COMMIT</command>または<command>ROLLBACK</command>から自動的にホールドカーソルに変換されます。
このことは、今や、最初の<command>COMMIT</command>や<command>ROLLBACK</command>の時点でカーソルが行ごとではなく完全に評価されることを意味します。
従来通りカーソルはループ後に自動で削除されるので、このことはユーザにほとんど認識されません。
   </para>

   <para>
<!--
    Transaction commands are not allowed in cursor loops driven by commands
    that are not read-only (for example <command>UPDATE
    ... RETURNING</command>).
-->
トランザクションコマンドは、読み込み専用でないコマンド（例えば<command>UPDATE ... RETURNING</command>）で駆動されるカーソルループ内では許可されません。
   </para>

   <para>
<!--
    A transaction cannot be ended inside a block with exception handlers.
-->
例外ハンドラを伴うブロック内ではトランザクションを終了できません。
   </para>
  </sect1>

  <sect1 id="plpgsql-errors-and-messages">
<!--
   <title>Errors and Messages</title>
-->
<title>エラーとメッセージ</title>

  <sect2 id="plpgsql-statements-raise">
<!--
   <title>Reporting Errors and Messages</title>
-->
   <title>エラーとメッセージの報告</title>

   <indexterm>
    <primary>RAISE</primary>
<!--
    <secondary>in PL/pgSQL</secondary>
-->
    <secondary>PL/pgSQLにおける</secondary>
   </indexterm>

   <indexterm>
<!--
    <primary>reporting errors</primary>
    <secondary>in PL/pgSQL</secondary>
-->
<primary>エラー報告</primary>
<secondary>PL/pgSQLにおける</secondary>
   </indexterm>

   <para>
<!--
    Use the <command>RAISE</command> statement to report messages and
    raise errors.
-->
<command>RAISE</command>文を使用してメッセージを報告し、エラーを発生することができます。

<synopsis>
RAISE <optional> <replaceable class="parameter">level</replaceable> </optional> '<replaceable class="parameter">format</replaceable>' <optional>, <replaceable class="parameter">expression</replaceable> <optional>, ... </optional></optional> <optional> USING <replaceable class="parameter">option</replaceable> = <replaceable class="parameter">expression</replaceable> <optional>, ... </optional> </optional>;
RAISE <optional> <replaceable class="parameter">level</replaceable> </optional> <replaceable class="parameter">condition_name</replaceable> <optional> USING <replaceable class="parameter">option</replaceable> = <replaceable class="parameter">expression</replaceable> <optional>, ... </optional> </optional>;
RAISE <optional> <replaceable class="parameter">level</replaceable> </optional> SQLSTATE '<replaceable class="parameter">sqlstate</replaceable>' <optional> USING <replaceable class="parameter">option</replaceable> = <replaceable class="parameter">expression</replaceable> <optional>, ... </optional> </optional>;
RAISE <optional> <replaceable class="parameter">level</replaceable> </optional> USING <replaceable class="parameter">option</replaceable> = <replaceable class="parameter">expression</replaceable> <optional>, ... </optional>;
RAISE ;
</synopsis>

<!--
    The <replaceable class="parameter">level</replaceable> option specifies
    the error severity.  Allowed levels are <literal>DEBUG</literal>,
    <literal>LOG</literal>, <literal>INFO</literal>,
    <literal>NOTICE</literal>, <literal>WARNING</literal>,
    and <literal>EXCEPTION</literal>, with <literal>EXCEPTION</literal>
    being the default.
    <literal>EXCEPTION</literal> raises an error (which normally aborts the
    current transaction); the other levels only generate messages of different
    priority levels.
    Whether messages of a particular priority are reported to the client,
    written to the server log, or both is controlled by the
    <xref linkend="guc-log-min-messages"/> and
    <xref linkend="guc-client-min-messages"/> configuration
    variables. See <xref linkend="runtime-config"/> for more
    information.
-->
<replaceable class="parameter">level</replaceable>オプションはエラーの深刻度を指定します。
使用可能なレベルは<literal>DEBUG</literal>、<literal>LOG</literal>、<literal>INFO</literal>、<literal>NOTICE</literal>、<literal>WARNING</literal>および<literal>EXCEPTION</literal>で、<literal>EXCEPTION</literal>がデフォルトです。
<literal>EXCEPTION</literal>はエラーを発生させ、現在のトランザクションをアボートします。
他のレベルは異なる優先度レベルのメッセージを生成するだけです。
特定の優先度のエラーメッセージがクライアントに報告するか、サーバログに書き込むか、またはその両方は<xref linkend="guc-log-min-messages"/>および<xref linkend="guc-client-min-messages"/>設定変数によって制御されます。
詳細については、<xref linkend="runtime-config"/>を参照してください。
   </para>

   <para>
<!--
    After <replaceable class="parameter">level</replaceable> if any,
    you can write a <replaceable class="parameter">format</replaceable>
    (which must be a simple string literal, not an expression).  The
    format string specifies the error message text to be reported.
    The format string can be followed
    by optional argument expressions to be inserted into the message.
    Inside the format string, <literal>%</literal> is replaced by the
    string representation of the next optional argument's value. Write
    <literal>%%</literal> to emit a literal <literal>%</literal>.
    The number of arguments must match the number of <literal>%</literal>
    placeholders in the format string, or an error is raised during
    the compilation of the function.
-->
もしあれば<replaceable class="parameter">level</replaceable>の後に<replaceable class="parameter">format</replaceable>を記述することができます
（これは評価式ではなく、単純文字列リテラルでなければなりません）。
書式文字列は報告されるエラーメッセージテキストを指定します。
書式文字列内では、<literal>%</literal>は次の省略可能な引数の値の文字列表現で書き換えられます。
<literal>%%</literal>と記述することで<literal>%</literal>リテラルを表すことができます。
引数の数は書式文字列のプレースホルダ<literal>%</literal>の数と一致しなければいけません。さもなくば、関数のコンパイル時にエラーが起きます。
   </para>

   <para>
<!--
    In this example, the value of <literal>v_job_id</literal> will replace the
    <literal>%</literal> in the string:
-->
以下の例では、<literal>v_job_id</literal>の値は文字列内の<literal>%</literal>を置き換えます。
<programlisting>
RAISE NOTICE 'Calling cs_create_job(%)', v_job_id;
</programlisting>
   </para>

   <para>
<!--
    You can attach additional information to the error report by writing
    <literal>USING</literal> followed by <replaceable
    class="parameter">option</replaceable> = <replaceable
    class="parameter">expression</replaceable> items.  Each
    <replaceable class="parameter">expression</replaceable> can be any
    string-valued expression.  The allowed <replaceable
    class="parameter">option</replaceable> key words are:
-->
<literal>USING</literal>に続いて、<replaceable class="parameter">option</replaceable> = <replaceable class="parameter">expression</replaceable>項目を記載することで、エラー報告に追加の情報を加えることができます。
各<replaceable class="parameter">expression</replaceable>は、どのような文字列による式も可能です。
使用可能な<replaceable class="parameter">option</replaceable>キーワードは以下です。

    <variablelist id="raise-using-options">
     <varlistentry>
      <term><literal>MESSAGE</literal></term>
      <listitem>
<!--
       <para>Sets the error message text.  This option can't be used in the
        form of <command>RAISE</command> that includes a format string
        before <literal>USING</literal>.</para>
-->
<para>エラーメッセージテキストを設定します。
このオプションは<literal>USING</literal>の前に書式文字列を含む<command>RAISE</command>形式では使用できません。</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>DETAIL</literal></term>
      <listitem>
<!--
       <para>Supplies an error detail message.</para>
-->
<para>エラー詳細メッセージを出力します。</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>HINT</literal></term>
      <listitem>
<!--
       <para>Supplies a hint message.</para>
-->
<para>ヒントメッセージを出力します。</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ERRCODE</literal></term>
      <listitem>
<!--
       <para>Specifies the error code (SQLSTATE) to report, either by condition
        name, as shown in <xref linkend="errcodes-appendix"/>, or directly as a
        five-character SQLSTATE code.</para>
-->
<para><xref linkend="errcodes-appendix"/>で示されている状況名、または直接的に５文字によるSQLSTATEコードのいずれかで、報告すべきエラーコード（SQLSTATE）を指定します。</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>COLUMN</literal></term>
      <term><literal>CONSTRAINT</literal></term>
      <term><literal>DATATYPE</literal></term>
      <term><literal>TABLE</literal></term>
      <term><literal>SCHEMA</literal></term>
      <listitem>
<!--
       <para>Supplies the name of a related object.</para>
-->
<para>関連するオブジェクト名を出力します。</para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>

   <para>
<!--
    This example will abort the transaction with the given error message
    and hint:
-->
以下の例は、与えられたエラーメッセージとヒントを付けてトランザクションをアボートします。
<programlisting>
RAISE EXCEPTION 'Nonexistent ID --> %', user_id
      USING HINT = 'Please check your user ID';
</programlisting>
   </para>

   <para>
<!--
    These two examples show equivalent ways of setting the SQLSTATE:
-->
以下の２つの例は、SQLSTATEを設定する等価な方法を示しています。
<programlisting>
RAISE 'Duplicate user ID: %', user_id USING ERRCODE = 'unique_violation';
RAISE 'Duplicate user ID: %', user_id USING ERRCODE = '23505';
</programlisting>
   </para>

   <para>
<!--
    There is a second <command>RAISE</command> syntax in which the main argument
    is the condition name or SQLSTATE to be reported, for example:
-->
主引数が報告されるべき状況名、またはSQLSTATEである場合、２番目の<command>RAISE</command>構文があります。
例を示します。
<programlisting>
RAISE division_by_zero;
RAISE SQLSTATE '22012';
</programlisting>
<!--
    In this syntax, <literal>USING</literal> can be used to supply a custom
    error message, detail, or hint.  Another way to do the earlier
    example is
-->
この構文において、<literal>USING</literal>は独自のエラーメッセージ、詳細、またはヒントを供給するように使用できます。
先の例と同じことを行う別の方法は次のようになります。
<programlisting>
RAISE unique_violation USING MESSAGE = 'Duplicate user ID: ' || user_id;
</programlisting>
   </para>

   <para>
<!--
    Still another variant is to write <literal>RAISE USING</literal> or <literal>RAISE
    <replaceable class="parameter">level</replaceable> USING</literal> and put
    everything else into the <literal>USING</literal> list.
-->
他にも亜種があり、<literal>RAISE USING</literal> または <literal>RAISE <replaceable class="parameter">level</replaceable> USING</literal>と記述して、全て一括して<literal>USING</literal>リスト内に書き加えます。
   </para>

   <para>
<!--
    The last variant of <command>RAISE</command> has no parameters at all.
    This form can only be used inside a <literal>BEGIN</literal> block's
    <literal>EXCEPTION</literal> clause;
    it causes the error currently being handled to be re-thrown.
-->
最後の<command>RAISE</command>亜種はパラメータを全く取りません。
この形式は<literal>BEGIN</literal>ブロックの<literal>EXCEPTION</literal>句で使用されるのみです。
これは、現在処理中のエラーを再発生させます。
   </para>

   <note>
    <para>
<!--
     Before <productname>PostgreSQL</productname> 9.1, <command>RAISE</command> without
     parameters was interpreted as re-throwing the error from the block
     containing the active exception handler.  Thus an <literal>EXCEPTION</literal>
     clause nested within that handler could not catch it, even if the
     <command>RAISE</command> was within the nested <literal>EXCEPTION</literal> clause's
     block. This was deemed surprising as well as being incompatible with
     Oracle's PL/SQL.
-->
<productname>PostgreSQL</productname>9.1より前のバージョンでは、パラメータのない<command>RAISE</command>は稼動している例外ハンドラを含むブロックからのエラーの再発生と解釈されました。
したがって、例外ハンドラの中で入れ子となった<literal>EXCEPTION</literal>句は、<command>RAISE</command>が入れ子となった<literal>EXCEPTION</literal>句のブロック内にあるときでも、エラーを捕捉できないことになりました。
これは驚くべきことであり、オラクルの PL/SQLと非互換でした。
    </para>
   </note>

   <para>
<!--
    If no condition name nor SQLSTATE is specified in a
    <command>RAISE EXCEPTION</command> command, the default is to use
    <literal>ERRCODE_RAISE_EXCEPTION</literal> (<literal>P0001</literal>).
    If no message text is specified, the default is to use the condition
    name or SQLSTATE as message text.
-->
<command>RAISE EXCEPTION</command>コマンド内で状況名もSQLSTATEも指定されない場合、デフォルトは<literal>ERRCODE_RAISE_EXCEPTION</literal> (<literal>P0001</literal>)を使用します。
メッセージテキストが指定されない場合、デフォルトは状況名、またはSQLSTATEをメッセージテキストとして使用します。
   </para>

   <note>
    <para>
<!--
     When specifying an error code by SQLSTATE code, you are not
     limited to the predefined error codes, but can select any
     error code consisting of five digits and/or upper-case ASCII
     letters, other than <literal>00000</literal>.  It is recommended that
     you avoid throwing error codes that end in three zeroes, because
     these are category codes and can only be trapped by trapping
     the whole category.
-->
SQLSTATEコードでエラーコードを指定する場合、事前に定義されたエラーコードに制約されることはありません。
<literal>00000</literal>以外の５桁の数字かASCIIの大文字からなるどんなエラーコードも選択できます。
３つのゼロで終わるエラーコードの出力を避けるように推奨されています。
と言うのは、そこには分類コードがあり、それらは全ての分類から捕捉することによってのみ補足可能だからです。
    </para>
   </note>

  </sect2>

  <sect2 id="plpgsql-statements-assert">
<!--
   <title>Checking Assertions</title>
-->
   <title>アサート検査</title>

   <indexterm>
    <primary>ASSERT</primary>
<!--
    <secondary>in PL/pgSQL</secondary>
-->
    <secondary>PL/pgSQLにおける</secondary>
   </indexterm>

   <indexterm>
<!--
    <primary>assertions</primary>
    <secondary>in PL/pgSQL</secondary>
-->
    <primary>アサート</primary>
    <secondary>PL/pgSQLにおける</secondary>
   </indexterm>

   <indexterm>
<!--
    <primary><varname>plpgsql.check_asserts</varname> configuration parameter</primary>
-->
    <primary><varname>plpgsql.check_asserts</varname> 設定パラメータ</primary>
   </indexterm>

   <para>
<!--
    The <command>ASSERT</command> statement is a convenient shorthand for
    inserting debugging checks into <application>PL/pgSQL</application>
    functions.
-->
<command>ASSERT</command>文は、<application>PL/pgSQL</application>関数にデバッグ用検査を差し込むための便利な省略形です。

<synopsis>
ASSERT <replaceable class="parameter">condition</replaceable> <optional> , <replaceable class="parameter">message</replaceable> </optional>;
</synopsis>

<!--
    The <replaceable class="parameter">condition</replaceable> is a Boolean
    expression that is expected to always evaluate to true; if it does,
    the <command>ASSERT</command> statement does nothing further.  If the
    result is false or null, then an <literal>ASSERT_FAILURE</literal> exception
    is raised.  (If an error occurs while evaluating
    the <replaceable class="parameter">condition</replaceable>, it is
    reported as a normal error.)
-->
<replaceable class="parameter">condition</replaceable>は常に真と評価されると想定される論理値式で、結果が真なら<command>ASSERT</command>文がさらに何かすることはありません。
結果が偽かNULLなら、<literal>ASSERT_FAILURE</literal>例外が発生します。
（もし、<replaceable class="parameter">condition</replaceable>を評価する間にエラーが生じた場合、それは通常のエラーと同様に報告されます。）
   </para>

   <para>
<!--
    If the optional <replaceable class="parameter">message</replaceable> is
    provided, it is an expression whose result (if not null) replaces the
    default error message text <quote>assertion failed</quote>, should
    the <replaceable class="parameter">condition</replaceable> fail.
    The <replaceable class="parameter">message</replaceable> expression is
    not evaluated in the normal case where the assertion succeeds.
-->
省略可能な<replaceable class="parameter">message</replaceable>が与えられた場合、その式の結果で（NULLでないなら）、<replaceable class="parameter">condition</replaceable>に失敗した際のデフォルトエラーメッセージ文<quote>assertion failed</quote>が置き換えられます。
<replaceable class="parameter">message</replaceable>式はアサートに成功する通常の場合には評価されません。
   </para>

   <para>
<!--
    Testing of assertions can be enabled or disabled via the configuration
    parameter <literal>plpgsql.check_asserts</literal>, which takes a Boolean
    value; the default is <literal>on</literal>.  If this parameter
    is <literal>off</literal> then <command>ASSERT</command> statements do nothing.
-->
アサート検査は、設定パラメータ<literal>plpgsql.check_asserts</literal>で有効または無効にできます。設定値は真偽値で、デフォルトは<literal>on</literal>です。
<literal>off</literal>のときには、<command>ASSERT</command>文は何もしません。
   </para>

   <para>
<!--
    Note that <command>ASSERT</command> is meant for detecting program
    bugs, not for reporting ordinary error conditions.  Use
    the <command>RAISE</command> statement, described above, for that.
-->
<command>ASSERT</command>はプログラムのバグを見つけるためのものであって、通常のエラー条件を報告するものではないことに注意してください。
そのためには前述の<command>RAISE</command>を使ってください。
   </para>

  </sect2>

 </sect1>

 <sect1 id="plpgsql-trigger">
<!--
  <title>Trigger Functions</title>
-->
<title>トリガ関数</title>

  <indexterm zone="plpgsql-trigger">
<!--
   <primary>trigger</primary>
   <secondary>in PL/pgSQL</secondary>
-->
<primary>トリガ</primary>
<secondary>PL/pgSQLにおける</secondary>
  </indexterm>

  <para>
<!--
   <application>PL/pgSQL</application> can be used to define trigger
   functions on data changes or database events.
   A trigger function is created with the <command>CREATE FUNCTION</command>
   command, declaring it as a function with no arguments and a return type of
   <type>trigger</type> (for data change triggers) or
   <type>event_trigger</type> (for database event triggers).
   Special local variables named <varname>TG_<replaceable>something</replaceable></varname> are
   automatically defined to describe the condition that triggered the call.
-->
<application>PL/pgSQL</application>はデータ変更やデータベースのイベントによるトリガ関数の定義に使用できます。
トリガ関数は、<command>CREATE FUNCTION</command>コマンドを使って、(データ変更トリガには)<type>trigger</type>、(データベースイベントトリガには)<type>event_trigger</type>という戻り値の型を持った引数のない関数として作成されます。
その呼出しのトリガの原因となった条件を記述するため、<varname>TG_<replaceable>something</replaceable></varname>という名前の特別な局所変数が自動的に定義されます。
  </para>

  <sect2 id="plpgsql-dml-trigger">
<!--
   <title>Triggers on Data Changes</title>
-->
<title>データ変更によるトリガ</title>

  <para>
<!--
   A <link linkend="triggers">data change trigger</link> is declared as a
   function with no arguments and a return type of <type>trigger</type>.
   Note that the function must be declared with no arguments even if it
   expects to receive some arguments specified in <command>CREATE TRIGGER</command>
   &mdash; such arguments are passed via <varname>TG_ARGV</varname>, as described
   below.
-->
<link linkend="triggers">データ変更トリガ</link>は<type>trigger</type>という戻り値の型を持った引数のない関数として宣言されます。
その関数は、たとえ、<command>CREATE TRIGGER</command>にて引数を取るものとしていたとしても、引数を持たないものと宣言しなければならないことに注意してください。
トリガの引数は、後述する通り、<varname>TG_ARGV</varname>経由で渡されます。
  </para>

  <para>
<!--
   When a <application>PL/pgSQL</application> function is called as a
   trigger, several special variables are created automatically in the
   top-level block. They are:
-->
<application>PL/pgSQL</application>関数がトリガとして呼び出された場合、いくつかの特殊な変数が自動的に最上位レベルのブロックで作成されます。
それらを以下に示します。

   <variablelist>
    <varlistentry>
     <term><varname>NEW</varname></term>
     <listitem>
      <para>
<!--
       Data type <type>RECORD</type>; variable holding the new
       database row for <command>INSERT</command>/<command>UPDATE</command> operations in row-level
       triggers. This variable is null in statement-level triggers
       and for <command>DELETE</command> operations.
-->
<type>RECORD</type>データ型。
この変数は行レベルのトリガでの<command>INSERT</command>/<command>UPDATE</command>操作によって更新された、新しいデータベースの行を保持します。
文レベルのトリガおよび<command>DELETE</command>操作では、この変数はnullです。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>OLD</varname></term>
     <listitem>
      <para>
<!--
       Data type <type>RECORD</type>; variable holding the old
       database row for <command>UPDATE</command>/<command>DELETE</command> operations in row-level
       triggers. This variable is null in statement-level triggers
       and for <command>INSERT</command> operations.
-->
<type>RECORD</type>データ型。
この変数は、行レベルのトリガでの<command>UPDATE</command>/<command>DELETE</command>操作によって更新される前のデータベースの行を保持します。
文レベルのトリガおよび<command>INSERT</command>操作では、この変数はnullです。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_NAME</varname></term>
     <listitem>
      <para>
<!--
       Data type <type>name</type>; variable that contains the name of the trigger actually
       fired.
-->
<type>name</type>データ型。
実際に発行されたトリガの名前を持つ変数。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_WHEN</varname></term>
     <listitem>
      <para>
<!--
       Data type <type>text</type>; a string of
       <literal>BEFORE</literal>, <literal>AFTER</literal>, or
       <literal>INSTEAD OF</literal>, depending on the trigger's definition.
-->
<type>text</type>データ型。
トリガの定義に依存した<literal>BEFORE</literal>、<literal>AFTER</literal>、または<literal>INSTEAD OF</literal>という文字列。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_LEVEL</varname></term>
     <listitem>
      <para>
<!--
       Data type <type>text</type>; a string of either
       <literal>ROW</literal> or <literal>STATEMENT</literal>
       depending on the trigger's definition.
-->
<type>text</type>データ型。
トリガの定義に依存した<literal>ROW</literal> または <literal>STATEMENT</literal>という文字列。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_OP</varname></term>
     <listitem>
      <para>
<!--
       Data type <type>text</type>; a string of
       <literal>INSERT</literal>, <literal>UPDATE</literal>,
       <literal>DELETE</literal>, or <literal>TRUNCATE</literal>
       telling for which operation the trigger was fired.
-->
<type>text</type>データ型。
トリガを起動した操作を示す、<literal>INSERT</literal>、<literal>UPDATE</literal>、<literal>DELETE</literal>、または<literal>TRUNCATE</literal>という文字列。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_RELID</varname></term>
     <listitem>
      <para>
<!--
       Data type <type>oid</type>; the object ID of the table that caused the
       trigger invocation.
-->
<type>oid</type>データ型。
このトリガの呼び出し元になるテーブルのオブジェクトID。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_RELNAME</varname></term>
     <listitem>
      <para>
<!--
       Data type <type>name</type>; the name of the table that caused the trigger
       invocation. This is now deprecated, and could disappear in a future
       release. Use <literal>TG_TABLE_NAME</literal> instead.
-->
<type>name</type>データ型。
このトリガの呼び出し元になるテーブルの名前。
将来これは廃止されそうです。
代わりに<literal>TG_TABLE_NAME</literal>を使用してください。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_TABLE_NAME</varname></term>
     <listitem>
      <para>
<!--
       Data type <type>name</type>; the name of the table that
       caused the trigger invocation.
-->
<type>name</type>データ型。
このトリガの呼び出し元になるテーブルの名前。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_TABLE_SCHEMA</varname></term>
     <listitem>
      <para>
<!--
       Data type <type>name</type>; the name of the schema of the
       table that caused the trigger invocation.
-->
<type>name</type>データ型。
このトリガの呼び出し元になるテーブルのスキーマ名。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_NARGS</varname></term>
     <listitem>
      <para>
<!--
       Data type <type>integer</type>; the number of arguments given to the trigger
       function in the <command>CREATE TRIGGER</command> statement.
-->
<type>integer</type>型。
<command>CREATE TRIGGER</command>文におけるトリガ関数に与えられる引数の数。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_ARGV[]</varname></term>
     <listitem>
      <para>
<!--
       Data type array of <type>text</type>; the arguments from
       the <command>CREATE TRIGGER</command> statement.
       The index counts from 0. Invalid
       indexes (less than 0 or greater than or equal to <varname>tg_nargs</varname>)
       result in a null value.
-->
<type>text</type>型の配列型。
<command>CREATE TRIGGER</command>文での引数。
このインデックスは0から始まります。
無効なインデックス（0未満や<varname>tg_nargs</varname>以上）は、NULL値という結果になります。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

   <para>
<!--
    A trigger function must return either <symbol>NULL</symbol> or a
    record/row value having exactly the structure of the table the
    trigger was fired for.
-->
トリガ関数は<symbol>NULL</symbol>または、トリガの発行元になったテーブルの構造を正確に持ったレコード/行を返さなければなりません。
   </para>

   <para>
<!--
    Row-level triggers fired <literal>BEFORE</literal> can return null to signal the
    trigger manager to skip the rest of the operation for this row
    (i.e., subsequent triggers are not fired, and the
    <command>INSERT</command>/<command>UPDATE</command>/<command>DELETE</command> does not occur
    for this row).  If a nonnull
    value is returned then the operation proceeds with that row value.
    Returning a row value different from the original value
    of <varname>NEW</varname> alters the row that will be inserted or
    updated.  Thus, if the trigger function wants the triggering
    action to succeed normally without altering the row
    value, <varname>NEW</varname> (or a value equal thereto) has to be
    returned.  To alter the row to be stored, it is possible to
    replace single values directly in <varname>NEW</varname> and return the
    modified <varname>NEW</varname>, or to build a complete new record/row to
    return.  In the case of a before-trigger
    on <command>DELETE</command>, the returned value has no direct
    effect, but it has to be nonnull to allow the trigger action to
    proceed.  Note that <varname>NEW</varname> is null
    in <command>DELETE</command> triggers, so returning that is
    usually not sensible.  The usual idiom in <command>DELETE</command>
    triggers is to return <varname>OLD</varname>.
-->
<literal>BEFORE</literal>として発行された行レベルトリガがNULLを返す場合には、トリガマネージャに実際の行への操作を取りやめるように通知します
（つまり、その後にトリガが発行されず、その<command>INSERT</command>/<command>UPDATE</command>/<command>DELETE</command>はその行に対して実行されません）。
非NULL値を返す場合には、その操作はその行値で処理されます。
元の<varname>NEW</varname>の値と異なる行値を返すことは、挿入、更新される値を変更します。
したがってトリガ関数が行値を変更せずにトリガ処理を普通に成功させたい場合は、<varname>NEW</varname>(またはその等価な値)を返さなければなりません。
格納する行を変更するために、<varname>NEW</varname>の個々の値を直接置き換え、変更した<varname>NEW</varname>を返すことも、新しいレコード/行を完全に作成して返すことも可能です。
<command>DELETE</command>に対するBEFOREトリガの場合、返される値は直接的な影響を与えませんが、トリガ動作を継続させるためには非NULLを返さなければなりません。
<command>DELETE</command>トリガでは<varname>NEW</varname>がNULLであり、これを返すことは通常無意味であることに注意して下さい。
<command>DELETE</command>トリガにおける通常の慣例は<varname>OLD</varname>を返すことです。
   </para>

   <para>
<!--
    <literal>INSTEAD OF</literal> triggers (which are always row-level triggers,
    and may only be used on views) can return null to signal that they did
    not perform any updates, and that the rest of the operation for this
    row should be skipped (i.e., subsequent triggers are not fired, and the
    row is not counted in the rows-affected status for the surrounding
    <command>INSERT</command>/<command>UPDATE</command>/<command>DELETE</command>).
    Otherwise a nonnull value should be returned, to signal
    that the trigger performed the requested operation. For
    <command>INSERT</command> and <command>UPDATE</command> operations, the return value
    should be <varname>NEW</varname>, which the trigger function may modify to
    support <command>INSERT RETURNING</command> and <command>UPDATE RETURNING</command>
    (this will also affect the row value passed to any subsequent triggers,
    or passed to a special <varname>EXCLUDED</varname> alias reference within
    an <command>INSERT</command> statement with an <literal>ON CONFLICT DO
    UPDATE</literal> clause).  For <command>DELETE</command> operations, the return
    value should be <varname>OLD</varname>.
-->
<literal>INSTEAD OF</literal>トリガ（これは常に行レベルトリガであり、ビューに対してのみ使用可能です）は、まったく更新を行わなかったためにこの行に対する残りの操作を飛ばさなければならない（つまり後続のトリガは発行されず、 トリガの発生元の<command>INSERT</command>/<command>UPDATE</command>/<command>DELETE</command>において影響を受けた行数として数えられない）ことを通知するNULLを返すことができます。
この他の場合は、トリガが要求された操作を実行したことを通知するために、非NULLの値を返さなければなりません。
<command>INSERT</command>および<command>UPDATE</command>操作では、戻り値は、トリガ関数が<command>INSERT RETURNING</command>および<command>UPDATE RETURNING</command>をサポートするために変更しているかもしれない、<varname>NEW</varname>となるはずです
（これは後続のトリガ、または、<literal>ON CONFLICT DO UPDATE</literal>句を伴う<command>INSERT</command>文の中で特別な<varname>EXCLUDED</varname>別名参照に渡される行値にも影響します）。
<command>DELETE</command>操作では、戻り値は<varname>OLD</varname>となるはずです。
   </para>

   <para>
<!--
    The return value of a row-level trigger
    fired <literal>AFTER</literal> or a statement-level trigger
    fired <literal>BEFORE</literal> or <literal>AFTER</literal> is
    always ignored; it might as well be null. However, any of these types of
    triggers might still abort the entire operation by raising an error.
-->
行レベルの<literal>AFTER</literal>トリガ、文レベルの<literal>BEFORE</literal>または<literal>AFTER</literal>トリガの戻り値は常に無視されます。
NULLとしても構いません。
しかし、これらの種類のトリガでも、エラーを発生させることで操作全体を中断させることが可能です。
   </para>

   <para>
<!--
    <xref linkend="plpgsql-trigger-example"/> shows an example of a
    trigger function in <application>PL/pgSQL</application>.
-->
<xref linkend="plpgsql-trigger-example"/>に<application>PL/pgSQL</application>のトリガ関数の例を示します。
   </para>

   <example id="plpgsql-trigger-example">
<!--
    <title>A <application>PL/pgSQL</application> Trigger Function</title>
-->
<title><application>PL/pgSQL</application>トリガ関数</title>

    <para>
<!--
     This example trigger ensures that any time a row is inserted or updated
     in the table, the current user name and time are stamped into the
     row. And it checks that an employee's name is given and that the
     salary is a positive value.
-->
このトリガの例では、テーブルの行が挿入または更新された時には必ず、現在のユーザ名と時刻がその行に入っていることを確実にします。
そして、従業員名が与えられていることとその給料が正の値であることを確認します。
    </para>

<programlisting>
CREATE TABLE emp (
    empname text,
    salary integer,
    last_date timestamp,
    last_user text
);

CREATE FUNCTION emp_stamp() RETURNS trigger AS $emp_stamp$
    BEGIN
<!--
        &#045;&#045; Check that empname and salary are given
-->
        -- empnameとsalaryが与えられていることをチェック
        IF NEW.empname IS NULL THEN
            RAISE EXCEPTION 'empname cannot be null';
        END IF;
        IF NEW.salary IS NULL THEN
            RAISE EXCEPTION '% cannot have null salary', NEW.empname;
        END IF;

<!--
        &#045;&#045; Who works for us when they must pay for it?
-->
        -- 支払時に問題が起こらないように
        IF NEW.salary &lt; 0 THEN
            RAISE EXCEPTION '% cannot have a negative salary', NEW.empname;
        END IF;

<!--
        &#045;&#045; Remember who changed the payroll when
-->
        -- 誰がいつ変更したかを記録
        NEW.last_date := current_timestamp;
        NEW.last_user := current_user;
        RETURN NEW;
    END;
$emp_stamp$ LANGUAGE plpgsql;

CREATE TRIGGER emp_stamp BEFORE INSERT OR UPDATE ON emp
    FOR EACH ROW EXECUTE FUNCTION emp_stamp();
</programlisting>
   </example>

   <para>
<!--
    Another way to log changes to a table involves creating a new table that
    holds a row for each insert, update, or delete that occurs. This approach
    can be thought of as auditing changes to a table.
    <xref linkend="plpgsql-trigger-audit-example"/> shows an example of an
    audit trigger function in <application>PL/pgSQL</application>.
-->
テーブルにおける変更のログを取る他の方法は、挿入、更新または削除の各々に対する行を保有する新テーブルを作成することです。
この方法はテーブルにおける変更の監査と考えることができます。
<xref linkend="plpgsql-trigger-audit-example"/>は<application>PL/pgSQL</application>による監査用トリガ関数の一例を示します。
   </para>

   <example id="plpgsql-trigger-audit-example">
<!--
    <title>A <application>PL/pgSQL</application> Trigger Function for Auditing</title>
-->
<title><application>PL/pgSQL</application>による監査用のトリガ関数</title>

    <para>
<!--
     This example trigger ensures that any insert, update or delete of a row
     in the <literal>emp</literal> table is recorded (i.e., audited) in the <literal>emp_audit</literal> table.
     The current time and user name are stamped into the row, together with
     the type of operation performed on it.
-->
このトリガの例では、<literal>emp</literal>テーブルにおける行の挿入、更新または削除のどれもがemp_auditテーブルの中へ確実に記録（すなわち監査）されます。
現在時刻とユーザ名は、行った操作の種類とともに<literal>emp_audit</literal>の行の中に記録されます。
    </para>

<programlisting>
CREATE TABLE emp (
    empname           text NOT NULL,
    salary            integer
);

CREATE TABLE emp_audit(
    operation         char(1)   NOT NULL,
    stamp             timestamp NOT NULL,
    userid            text      NOT NULL,
    empname           text      NOT NULL,
    salary integer
);

CREATE OR REPLACE FUNCTION process_emp_audit() RETURNS TRIGGER AS $emp_audit$
    BEGIN
        --
<!--
        &#045;&#045; Create a row in emp_audit to reflect the operation performed on emp,
        &#045;&#045; making use of the special variable TG_OP to work out the operation.
-->
        -- empで行った操作を反映する行をemp_auditに作成
        -- 操作の種類を決定するために、特殊な変数TG_OPを活用
        --
        IF (TG_OP = 'DELETE') THEN
            INSERT INTO emp_audit SELECT 'D', now(), user, OLD.*;
        ELSIF (TG_OP = 'UPDATE') THEN
            INSERT INTO emp_audit SELECT 'U', now(), user, NEW.*;
        ELSIF (TG_OP = 'INSERT') THEN
            INSERT INTO emp_audit SELECT 'I', now(), user, NEW.*;
        END IF;
<!--
        RETURN NULL; &#045;&#045; result is ignored since this is an AFTER trigger
-->
        RETURN NULL; -- AFTERトリガですので、結果は無視されます
    END;
$emp_audit$ LANGUAGE plpgsql;

CREATE TRIGGER emp_audit
AFTER INSERT OR UPDATE OR DELETE ON emp
    FOR EACH ROW EXECUTE FUNCTION process_emp_audit();
</programlisting>
   </example>

   <para>
<!--
    A variation of the previous example uses a view joining the main table
    to the audit table, to show when each entry was last modified. This
    approach still records the full audit trail of changes to the table,
    but also presents a simplified view of the audit trail, showing just
    the last modified timestamp derived from the audit trail for each entry.
    <xref linkend="plpgsql-view-trigger-audit-example"/> shows an example
    of an audit trigger on a view in <application>PL/pgSQL</application>.
-->
前例の変形では、各エントリが最終修正された時を表示するため、主テーブルを監査テーブルに結合したビューを使用します。
この方法でもテーブルの変化の監査証跡を全て記録できますが、監査証跡から抽出した各エントリの最終修正のタイムスタンプ表示することにより、監査証跡の簡単なビューを表示することにもなります。
<xref linkend="plpgsql-view-trigger-audit-example"/>で示すものは、<application>PL/pgSQL</application>を用いたビューの監査トリガの例です。
   </para>

   <example id="plpgsql-view-trigger-audit-example">
<!--
    <title>A <application>PL/pgSQL</application> View Trigger Function for Auditing</title>
-->
<title>監査のための<application>PL/pgSQL</application>ビュートリガ関数</title>

    <para>
<!--
     This example uses a trigger on the view to make it updatable, and
     ensure that any insert, update or delete of a row in the view is
     recorded (i.e., audited) in the <literal>emp_audit</literal> table. The current time
     and user name are recorded, together with the type of operation
     performed, and the view displays the last modified time of each row.
-->
この例では、ビューを更新可能とし、その行の挿入、更新、削除を<literal>emp_audit</literal>テーブルに確実に記録（つまり監査）するためにビューに対するトリガを使用します。
現在時刻とユーザ名が実行された操作種類と一緒に記録されます。
ビューは各行の最終更新時間を表示します。
    </para>

<programlisting>
CREATE TABLE emp (
    empname           text PRIMARY KEY,
    salary            integer
);

CREATE TABLE emp_audit(
    operation         char(1)   NOT NULL,
    userid            text      NOT NULL,
    empname           text      NOT NULL,
    salary            integer,
    stamp             timestamp NOT NULL
);

CREATE VIEW emp_view AS
    SELECT e.empname,
           e.salary,
           max(ea.stamp) AS last_updated
      FROM emp e
      LEFT JOIN emp_audit ea ON ea.empname = e.empname
     GROUP BY 1, 2;

CREATE OR REPLACE FUNCTION update_emp_view() RETURNS TRIGGER AS $$
    BEGIN
        --
<!--

        &#045;&#045; Perform the required operation on emp, and create a row in emp_audit
        &#045;&#045; to reflect the change made to emp.
-->
        -- 要求された操作を emp に実行し
        -- emp_audit に行を作成し
        -- emp の変化を反映する
        --
        IF (TG_OP = 'DELETE') THEN
            DELETE FROM emp WHERE empname = OLD.empname;
            IF NOT FOUND THEN RETURN NULL; END IF;

            OLD.last_updated = now();
            INSERT INTO emp_audit VALUES('D', user, OLD.*);
            RETURN OLD;
        ELSIF (TG_OP = 'UPDATE') THEN
            UPDATE emp SET salary = NEW.salary WHERE empname = OLD.empname;
            IF NOT FOUND THEN RETURN NULL; END IF;

            NEW.last_updated = now();
            INSERT INTO emp_audit VALUES('U', user, NEW.*);
            RETURN NEW;
        ELSIF (TG_OP = 'INSERT') THEN
            INSERT INTO emp VALUES(NEW.empname, NEW.salary);

            NEW.last_updated = now();
            INSERT INTO emp_audit VALUES('I', user, NEW.*);
            RETURN NEW;
        END IF;
    END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER emp_audit
INSTEAD OF INSERT OR UPDATE OR DELETE ON emp_view
    FOR EACH ROW EXECUTE FUNCTION update_emp_view();
</programlisting>
   </example>

   <para>
<!--
    One use of triggers is to maintain a summary table
    of another table. The resulting summary can be used in place of the
    original table for certain queries &mdash; often with vastly reduced run
    times.
    This technique is commonly used in Data Warehousing, where the tables
    of measured or observed data (called fact tables) might be extremely large.
    <xref linkend="plpgsql-trigger-summary-example"/> shows an example of a
    trigger function in <application>PL/pgSQL</application> that maintains
    a summary table for a fact table in a data warehouse.
-->
トリガの使用目的の1つは、あるテーブルのサマリテーブルを維持することです。
結果のサマリテーブルは、元のテーブルに代わって、ある種の問い合わせに対して使用でき、しばしば実行時間を大幅に縮小します。
通常この手法は、計測または観測データ（ファクトテーブルと言います）が非常に大きくなるかもしれない、データウェアハウスに使用されます。
データウェアハウス内のファクトテーブルに対してサマリテーブルを維持する<application>PL/pgSQL</application>のトリガ関数の例を<xref linkend="plpgsql-trigger-summary-example"/>に示します。
   </para>


   <example id="plpgsql-trigger-summary-example">
<!--
    <title>A <application>PL/pgSQL</application> Trigger Function for Maintaining a Summary Table</title>
-->
<title>サマリテーブルを維持するための<application>PL/pgSQL</application>トリガ関数</title>

    <para>
<!--
     The schema detailed here is partly based on the <emphasis>Grocery Store
     </emphasis> example from <emphasis>The Data Warehouse Toolkit</emphasis>
     by Ralph Kimball.
-->
ここに述べるスキーマの一部はRalph Kimballによる<emphasis>The Data Warehouse Toolkit</emphasis>の<emphasis>Grocery Store</emphasis>の例に基づいています。
    </para>

<programlisting>
--
<!--
&#045;&#045; Main tables - time dimension and sales fact.
-->
-- time dimensionとsales factの主テーブル
--
CREATE TABLE time_dimension (
    time_key                    integer NOT NULL,
    day_of_week                 integer NOT NULL,
    day_of_month                integer NOT NULL,
    month                       integer NOT NULL,
    quarter                     integer NOT NULL,
    year                        integer NOT NULL
);
CREATE UNIQUE INDEX time_dimension_key ON time_dimension(time_key);

CREATE TABLE sales_fact (
    time_key                    integer NOT NULL,
    product_key                 integer NOT NULL,
    store_key                   integer NOT NULL,
    amount_sold                 numeric(12,2) NOT NULL,
    units_sold                  integer NOT NULL,
    amount_cost                 numeric(12,2) NOT NULL
);
CREATE INDEX sales_fact_time ON sales_fact(time_key);

--
<!--
&#045;&#045; Summary table - sales by time.
-->
-- sales by timeのサマリテーブル
--
CREATE TABLE sales_summary_bytime (
    time_key                    integer NOT NULL,
    amount_sold                 numeric(15,2) NOT NULL,
    units_sold                  numeric(12) NOT NULL,
    amount_cost                 numeric(15,2) NOT NULL
);
CREATE UNIQUE INDEX sales_summary_bytime_key ON sales_summary_bytime(time_key);

--
<!--
&#045;&#045; Function and trigger to amend summarized column(s) on UPDATE, INSERT, DELETE.
-->
-- 更新、挿入および削除によりサマリテーブルの列を修正する関数とトリガ
--
CREATE OR REPLACE FUNCTION maint_sales_summary_bytime() RETURNS TRIGGER
AS $maint_sales_summary_bytime$
    DECLARE
        delta_time_key          integer;
        delta_amount_sold       numeric(15,2);
        delta_units_sold        numeric(12);
        delta_amount_cost       numeric(15,2);
    BEGIN

<!--
        &#045;&#045; Work out the increment/decrement amount(s).
-->
        -- 増加または減少量を算出
        IF (TG_OP = 'DELETE') THEN

            delta_time_key = OLD.time_key;
            delta_amount_sold = -1 * OLD.amount_sold;
            delta_units_sold = -1 * OLD.units_sold;
            delta_amount_cost = -1 * OLD.amount_cost;

        ELSIF (TG_OP = 'UPDATE') THEN

<!--
            &#045;&#045; forbid updates that change the time_key -
            &#045;&#045; (probably not too onerous, as DELETE + INSERT is how most
            &#045;&#045; changes will be made).
-->
            -- time_keyを変更する更新を禁止します
            -- （削除 + 挿入の方法により大部分の変更を行うため
            -- それほど厄介ではありません）。
            IF ( OLD.time_key != NEW.time_key) THEN
                RAISE EXCEPTION 'Update of time_key : % -&gt; % not allowed',
                                                      OLD.time_key, NEW.time_key;
            END IF;

            delta_time_key = OLD.time_key;
            delta_amount_sold = NEW.amount_sold - OLD.amount_sold;
            delta_units_sold = NEW.units_sold - OLD.units_sold;
            delta_amount_cost = NEW.amount_cost - OLD.amount_cost;

        ELSIF (TG_OP = 'INSERT') THEN

            delta_time_key = NEW.time_key;
            delta_amount_sold = NEW.amount_sold;
            delta_units_sold = NEW.units_sold;
            delta_amount_cost = NEW.amount_cost;

        END IF;


<!--
        &#045;&#045; Insert or update the summary row with the new values.
-->
        -- サマリテーブルの行を挿入または新しい値で更新します。
        &lt;&lt;insert_update&gt;&gt;
        LOOP
            UPDATE sales_summary_bytime
                SET amount_sold = amount_sold + delta_amount_sold,
                    units_sold = units_sold + delta_units_sold,
                    amount_cost = amount_cost + delta_amount_cost
                WHERE time_key = delta_time_key;

            EXIT insert_update WHEN found;

            BEGIN
                INSERT INTO sales_summary_bytime (
                            time_key,
                            amount_sold,
                            units_sold,
                            amount_cost)
                    VALUES (
                            delta_time_key,
                            delta_amount_sold,
                            delta_units_sold,
                            delta_amount_cost
                           );

                EXIT insert_update;

            EXCEPTION
                WHEN UNIQUE_VIOLATION THEN
<!--
                    &#045;&#045; do nothing
-->
                    -- 何もしません
            END;
        END LOOP insert_update;

        RETURN NULL;

    END;
$maint_sales_summary_bytime$ LANGUAGE plpgsql;

CREATE TRIGGER maint_sales_summary_bytime
AFTER INSERT OR UPDATE OR DELETE ON sales_fact
    FOR EACH ROW EXECUTE FUNCTION maint_sales_summary_bytime();

INSERT INTO sales_fact VALUES(1,1,1,10,3,15);
INSERT INTO sales_fact VALUES(1,2,1,20,5,35);
INSERT INTO sales_fact VALUES(2,2,1,40,15,135);
INSERT INTO sales_fact VALUES(2,3,1,10,1,13);
SELECT * FROM sales_summary_bytime;
DELETE FROM sales_fact WHERE product_key = 1;
SELECT * FROM sales_summary_bytime;
UPDATE sales_fact SET units_sold = units_sold * 2;
SELECT * FROM sales_summary_bytime;
</programlisting>
   </example>

   <para>
<!--
    <literal>AFTER</literal> triggers can also make use of <firstterm>transition
    tables</firstterm> to inspect the entire set of rows changed by the triggering
    statement.  The <command>CREATE TRIGGER</command> command assigns names to one
    or both transition tables, and then the function can refer to those names
    as though they were read-only temporary tables.
    <xref linkend="plpgsql-trigger-audit-transition-example"/> shows an example.
-->
<literal>AFTER</literal>トリガは、トリガ文により変更された行の集合全体を調べるために<firstterm>遷移テーブル</firstterm>を使うこともできます。
<command>CREATE TRIGGER</command>コマンドで名前を1つまたは2つの遷移テーブルに割り当てると、関数はその名前を読み込み専用の一時テーブルであるかのように参照できます。
<xref linkend="plpgsql-trigger-audit-transition-example"/>に例を示します。
   </para>

   <example id="plpgsql-trigger-audit-transition-example">
<!--
    <title>Auditing with Transition Tables</title>
-->
    <title>遷移テーブルでの監査</title>

    <para>
<!--
     This example produces the same results as
     <xref linkend="plpgsql-trigger-audit-example"/>, but instead of using a
     trigger that fires for every row, it uses a trigger that fires once
     per statement, after collecting the relevant information in a transition
     table.  This can be significantly faster than the row-trigger approach
     when the invoking statement has modified many rows.  Notice that we must
     make a separate trigger declaration for each kind of event, since the
     <literal>REFERENCING</literal> clauses must be different for each case.  But
     this does not stop us from using a single trigger function if we choose.
     (In practice, it might be better to use three separate functions and
     avoid the run-time tests on <varname>TG_OP</varname>.)
-->
この例は<xref linkend="plpgsql-trigger-audit-example"/>と同じ結果になりますが、行毎に起動するトリガを使う代わりに、関係のある情報を遷移テーブルに集めた後に文毎に1回起動するトリガを使っています。
これは、呼び出された文が多くの行を変更する場合には行トリガの方法よりとても速くなる場合があります。
<literal>REFERENCING</literal>句はそれぞれの場合で異ならなければなりませんので、それぞれの種類のイベントに対して別々のトリガ宣言をしなければならないことに注意してください。
ですが、もし選ぶのなら、このために単一のトリガ関数が使えなくなることはありません。
(実際には、3つに別れた関数を使い、実行時の<varname>TG_OP</varname>の確認を避ける方が良いでしょう。)
    </para>

<programlisting>
CREATE TABLE emp (
    empname           text NOT NULL,
    salary            integer
);

CREATE TABLE emp_audit(
    operation         char(1)   NOT NULL,
    stamp             timestamp NOT NULL,
    userid            text      NOT NULL,
    empname           text      NOT NULL,
    salary integer
);

CREATE OR REPLACE FUNCTION process_emp_audit() RETURNS TRIGGER AS $emp_audit$
    BEGIN
        --
<!--
        &#045;- Create rows in emp_audit to reflect the operations performed on emp,
        &#045;- making use of the special variable TG_OP to work out the operation.
-->
        -- empで実行された操作を反映するためにemp_auditに行を作り、
        -- 操作を完了するために特殊な変数TG_OPを使う。
        --
        IF (TG_OP = 'DELETE') THEN
            INSERT INTO emp_audit
                SELECT 'D', now(), user, o.* FROM old_table o;
        ELSIF (TG_OP = 'UPDATE') THEN
            INSERT INTO emp_audit
                SELECT 'U', now(), user, n.* FROM new_table n;
        ELSIF (TG_OP = 'INSERT') THEN
            INSERT INTO emp_audit
                SELECT 'I', now(), user, n.* FROM new_table n;
        END IF;
<!--
        RETURN NULL; &#045;- result is ignored since this is an AFTER trigger
-->
        RETURN NULL; -- これはAFTERトリガなので結果は無視される
    END;
$emp_audit$ LANGUAGE plpgsql;

CREATE TRIGGER emp_audit_ins
    AFTER INSERT ON emp
    REFERENCING NEW TABLE AS new_table
    FOR EACH STATEMENT EXECUTE FUNCTION process_emp_audit();
CREATE TRIGGER emp_audit_upd
    AFTER UPDATE ON emp
    REFERENCING OLD TABLE AS old_table NEW TABLE AS new_table
    FOR EACH STATEMENT EXECUTE FUNCTION process_emp_audit();
CREATE TRIGGER emp_audit_del
    AFTER DELETE ON emp
    REFERENCING OLD TABLE AS old_table
    FOR EACH STATEMENT EXECUTE FUNCTION process_emp_audit();
</programlisting>
   </example>

</sect2>

  <sect2 id="plpgsql-event-trigger">
<!--
   <title>Triggers on Events</title>
-->
<title>イベントによるトリガ</title>

   <para>
<!--
    <application>PL/pgSQL</application> can be used to define
    <link linkend="event-triggers">event triggers</link>.
    <productname>PostgreSQL</productname> requires that a function that
    is to be called as an event trigger must be declared as a function with
    no arguments and a return type of <literal>event_trigger</literal>.
-->
<application>PL/pgSQL</application>は<link linkend="event-triggers">イベントトリガ</link>の定義に使用できます。
イベントトリガとして呼び出される関数は、引数のない関数として宣言され、戻り値の型は<literal>event_trigger</literal>となることが<productname>PostgreSQL</productname>では必須です。
   </para>

   <para>
<!--
    When a <application>PL/pgSQL</application> function is called as an
    event trigger, several special variables are created automatically
    in the top-level block. They are:
-->
<application>PL/pgSQL</application>関数がイベントトリガとして呼び出された場合、数個の特別な変数が最高レベルのブロックで自動的に作成されます。
以下に示します。

   <variablelist>
    <varlistentry>
     <term><varname>TG_EVENT</varname></term>
     <listitem>
      <para>
<!--
       Data type <type>text</type>; a string representing the event the
       trigger is fired for.
-->
<type>text</type>データ型。
トリガが発行されたイベントを示す文字列。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_TAG</varname></term>
     <listitem>
      <para>
<!--
       Data type <type>text</type>; variable that contains the command tag
       for which the trigger is fired.
-->
<type>text</type>データ型。
トリガが発行されたコマンドタグを含む変数。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

   <para>
<!--
    <xref linkend="plpgsql-event-trigger-example"/> shows an example of an
    event trigger function in <application>PL/pgSQL</application>.
-->
<xref linkend="plpgsql-event-trigger-example"/>は<application>PL/pgSQL</application>におけるイベントトリガ関数の一例を示します。
   </para>

   <example id="plpgsql-event-trigger-example">
<!--
    <title>A <application>PL/pgSQL</application> Event Trigger Function</title>
-->
<title><application>PL/pgSQL</application>イベントトリガ関数</title>

    <para>
<!--
     This example trigger simply raises a <literal>NOTICE</literal> message
     each time a supported command is executed.
-->
以下の例では、サポートされたコマンドが実行されたとき、トリガは<literal>NOTICE</literal>を発生させるだけです。
    </para>

<programlisting>
CREATE OR REPLACE FUNCTION snitch() RETURNS event_trigger AS $$
BEGIN
    RAISE NOTICE 'snitch: % %', tg_event, tg_tag;
END;
$$ LANGUAGE plpgsql;

CREATE EVENT TRIGGER snitch ON ddl_command_start EXECUTE FUNCTION snitch();
</programlisting>
   </example>
  </sect2>

  </sect1>

  <sect1 id="plpgsql-implementation">
<!--
   <title><application>PL/pgSQL</application> under the Hood</title>
-->
<title><application>PL/pgSQL</application>の秘訣</title>

   <para>
<!--
    This section discusses some implementation details that are
    frequently important for <application>PL/pgSQL</application> users to know.
-->
本節では、<application>PL/pgSQL</application>利用者の知識として重要な、実装の詳細を述べます。
   </para>

  <sect2 id="plpgsql-var-subst">
<!--
   <title>Variable Substitution</title>
-->
<title>変数置換</title>

   <para>
<!--
    SQL statements and expressions within a <application>PL/pgSQL</application> function
    can refer to variables and parameters of the function.  Behind the scenes,
    <application>PL/pgSQL</application> substitutes query parameters for such references.
    Query parameters will only be substituted in places where they are
    syntactically permissible.  As an extreme case, consider
    this example of poor programming style:
-->
<application>PL/pgSQL</application>関数内のSQL文および式は変数および関数のパラメータを参照することができます。
背後では、<application>PL/pgSQL</application>はこうした参照を問い合わせパラメータに置き換えます。
パラメータまたは列参照が文法的に許されているところでのみパラメータは置換されます。
極端な場合として、以下のよろしくないプログラミングスタイルの例を考えてみましょう。
<programlisting>
INSERT INTO foo (foo) VALUES (foo(foo));
</programlisting>
<!--
    The first occurrence of <literal>foo</literal> must syntactically be a table
    name, so it will not be substituted, even if the function has a variable
    named <literal>foo</literal>.  The second occurrence must be the name of a
    column of that table, so it will not be substituted either.  Likewise
    the third occurrence must be a function name, so it also will not be
    substituted for.  Only the last occurrence is a candidate to be a
    reference to a variable of the <application>PL/pgSQL</application>
    function.
-->
最初に現れる<literal>foo</literal>の場所は文法的にはテーブル名でなければなりません。
このため関数が<literal>foo</literal>という名前の変数を持っていたとしても、置換されません。
2番目の場所はテーブルの列名でなければなりません。
このためこれも置換されません。
3番目の場所のみが関数の変数参照の候補です。
   </para>

   <para>
    Another way to understand this is that variable substitution can only
    insert data values into an SQL command; it cannot dynamically change which
    database objects are referenced by the command.  (If you want to do
    that, you must build a command string dynamically, as explained in
    <xref linkend="plpgsql-statements-executing-dyn"/>.)
   </para>

   <para>
<!--
    Since the names of variables are syntactically no different from the names
    of table columns, there can be ambiguity in statements that also refer to
    tables: is a given name meant to refer to a table column, or a variable?
    Let's change the previous example to
-->
変数名は文法的にはテーブル列名と違いがありませんので、テーブルを参照する文の中であいまいさが出る可能性があります。
与えられた名前はテーブル列を意味するのでしょうか、それとも変数なのでしょうか。
前の例を次のように変えてみましょう。
<programlisting>
INSERT INTO dest (col) SELECT foo + bar FROM src;
</programlisting>
<!--
    Here, <literal>dest</literal> and <literal>src</literal> must be table names, and
    <literal>col</literal> must be a column of <literal>dest</literal>, but <literal>foo</literal>
    and <literal>bar</literal> might reasonably be either variables of the function
    or columns of <literal>src</literal>.
-->
ここでは、<literal>dest</literal>および<literal>src</literal>はテーブル名でなければなりません。
また、<literal>col</literal>は<literal>dest</literal>の列でなければなりませんが、<literal>foo</literal>および<literal>bar</literal>は理論上関数の変数かもしれませんし、<literal>src</literal>の列かもしれません。
   </para>

   <para>
<!--
    By default, <application>PL/pgSQL</application> will report an error if a name
    in an SQL statement could refer to either a variable or a table column.
    You can fix such a problem by renaming the variable or column,
    or by qualifying the ambiguous reference, or by telling
    <application>PL/pgSQL</application> which interpretation to prefer.
-->
デフォルトで<application>PL/pgSQL</application>はSQL文における名前が変数かテーブル列のいずれかを参照可能な場合にエラーを報告します。
変数または列の名前を変更することやあいまいな参照を修飾すること、<application>PL/pgSQL</application>にどちらを優先して解釈するかを通知することで、こうした問題を解消することができます。
   </para>

   <para>
<!--
    The simplest solution is to rename the variable or column.
    A common coding rule is to use a
    different naming convention for <application>PL/pgSQL</application>
    variables than you use for column names.  For example,
    if you consistently name function variables
    <literal>v_<replaceable>something</replaceable></literal> while none of your
    column names start with <literal>v_</literal>, no conflicts will occur.
-->
最も簡単な解法は変数名または列名を変更することです。
一般的なコーディング法として、列の命名と<application>PL/pgSQL</application>変数の命名とで規約を分ける方法があります。
例えば、一貫して関数の変数は<literal>v_<replaceable>something</replaceable></literal>という名前とし、列名は<literal>v_</literal>で始まらないようにすれば、競合は起こりません。
   </para>

   <para>
<!--
    Alternatively you can qualify ambiguous references to make them clear.
    In the above example, <literal>src.foo</literal> would be an unambiguous reference
    to the table column.  To create an unambiguous reference to a variable,
    declare it in a labeled block and use the block's label
    (see <xref linkend="plpgsql-structure"/>).  For example,
-->
その他、あいまいな参照を明確にするために修飾することができます。
上の例では、<literal>src.foo</literal>によりテーブル列への参照についてあいまいさが解消します。
あいまい性のない変数参照を行うためには、ラベル付けしたブロック内で変数を宣言し、そのブロックのラベルを使用します(<xref linkend="plpgsql-structure"/>参照)。
以下に例を示します。
<programlisting>
&lt;&lt;block&gt;&gt;
DECLARE
    foo int;
BEGIN
    foo := ...;
    INSERT INTO dest (col) SELECT block.foo + bar FROM src;
</programlisting>
<!--
    Here <literal>block.foo</literal> means the variable even if there is a column
    <literal>foo</literal> in <literal>src</literal>.  Function parameters, as well as
    special variables such as <literal>FOUND</literal>, can be qualified by the
    function's name, because they are implicitly declared in an outer block
    labeled with the function's name.
-->
ここで<literal>block.foo</literal>は<literal>src</literal>に<literal>foo</literal>列があったとしても、変数を意味することになります。
<literal>FOUND</literal>などの特別な変数を含め、関数パラメータを関数名で修飾することができます。
これらは暗黙的に関数名をラベル名とした上位ブロック内で宣言されているためです。
   </para>

   <para>
<!--
    Sometimes it is impractical to fix all the ambiguous references in a
    large body of <application>PL/pgSQL</application> code.  In such cases you can
    specify that <application>PL/pgSQL</application> should resolve ambiguous references
    as the variable (which is compatible with <application>PL/pgSQL</application>'s
    behavior before <productname>PostgreSQL</productname> 9.0), or as the
    table column (which is compatible with some other systems such as
    <productname>Oracle</productname>).
-->
<application>PL/pgSQL</application>の大規模な本体コードにおける、すべてのあいまいな参照を修正することが現実的ではない場合があります。
こうした場合、<application>PL/pgSQL</application>にあいまいな参照を変数として解決すべき(この動作は<productname>PostgreSQL</productname> 9.0より前の<application>PL/pgSQL</application>の動作と互換性を持ちます)、または、テーブル列参照として解決すべき(<productname>Oracle</productname>などの他のシステムと互換性を持ちます)と指定することができます。
   </para>

   <indexterm>
<!--
     <primary><varname>plpgsql.variable_conflict</varname> configuration parameter</primary>
-->
<primary><varname>plpgsql.variable_conflict</varname>設定パラメータ</primary>
   </indexterm>

   <para>
<!--
    To change this behavior on a system-wide basis, set the configuration
    parameter <literal>plpgsql.variable_conflict</literal> to one of
    <literal>error</literal>, <literal>use_variable</literal>, or
    <literal>use_column</literal> (where <literal>error</literal> is the factory default).
    This parameter affects subsequent compilations
    of statements in <application>PL/pgSQL</application> functions, but not statements
    already compiled in the current session.
    Because changing this setting
    can cause unexpected changes in the behavior of <application>PL/pgSQL</application>
    functions, it can only be changed by a superuser.
-->
システム全体に対してこの動作を変更するためには<literal>plpgsql.variable_conflict</literal>設定パラメータを<literal>error</literal>、<literal>use_variable</literal>、<literal>use_column</literal>のいずれかに設定します(<literal>error</literal>が標準配布におけるデフォルトです)。
このパラメータは以降の<application>PL/pgSQL</application>関数の文のコンパイルに影響しますが、現在のセッションでコンパイル済みの文には影響を与えません。
この設定を変更することで、<application>PL/pgSQL</application>の動作において予期できない変化が発生することがありますので、これはスーパーユーザのみが変更することができます。
   </para>

   <para>
<!--
    You can also set the behavior on a function-by-function basis, by
    inserting one of these special commands at the start of the function
    text:
-->
また、関数テキストの先頭に以下の特殊なコマンドの1つをいれることで、関数単位で動作を設定することもできます。
<programlisting>
#variable_conflict error
#variable_conflict use_variable
#variable_conflict use_column
</programlisting>
<!--
    These commands affect only the function they are written in, and override
    the setting of <literal>plpgsql.variable_conflict</literal>.  An example is
-->
これらのコマンドを記述した関数に対してのみ、コマンドは影響を与え、<literal>plpgsql.variable_conflict</literal>の設定を上書きします。
以下に例を示します。
<programlisting>
CREATE FUNCTION stamp_user(id int, comment text) RETURNS void AS $$
    #variable_conflict use_variable
    DECLARE
        curtime timestamp := now();
    BEGIN
        UPDATE users SET last_modified = curtime, comment = comment
          WHERE users.id = id;
    END;
$$ LANGUAGE plpgsql;
</programlisting>
<!--
    In the <literal>UPDATE</literal> command, <literal>curtime</literal>, <literal>comment</literal>,
    and <literal>id</literal> will refer to the function's variable and parameters
    whether or not <literal>users</literal> has columns of those names.  Notice
    that we had to qualify the reference to <literal>users.id</literal> in the
    <literal>WHERE</literal> clause to make it refer to the table column.
    But we did not have to qualify the reference to <literal>comment</literal>
    as a target in the <literal>UPDATE</literal> list, because syntactically
    that must be a column of <literal>users</literal>.  We could write the same
    function without depending on the <literal>variable_conflict</literal> setting
    in this way:
-->
<literal>UPDATE</literal>コマンドにおいて、<literal>curtime</literal>、<literal>comment</literal>および<literal>id</literal>は、<literal>users</literal>に同名の列があるか否かに関わらず、関数の変数またはパラメータを参照します。
テーブル列を参照させるために<literal>WHERE</literal>句において<literal>users.id</literal>と参照を修飾する必要があったことに注意して下さい。
しかし<literal>UPDATE</literal>リストの対象としての<literal>comment</literal>への参照は修飾させる必要がありませんでした。
これは文法的に<literal>users</literal>の列でなければならないためです。
以下のように<literal>variable_conflict</literal>の設定に依存せずに同じ関数を作成することもできます。
<programlisting>
CREATE FUNCTION stamp_user(id int, comment text) RETURNS void AS $$
    &lt;&lt;fn&gt;&gt;
    DECLARE
        curtime timestamp := now();
    BEGIN
        UPDATE users SET last_modified = fn.curtime, comment = stamp_user.comment
          WHERE users.id = stamp_user.id;
    END;
$$ LANGUAGE plpgsql;
</programlisting>
   </para>

   <para>
<!--
    Variable substitution does not happen in a command string given
    to <command>EXECUTE</command> or one of its variants.  If you need to
    insert a varying value into such a command, do so as part of
    constructing the string value, or use <literal>USING</literal>, as illustrated in
    <xref linkend="plpgsql-statements-executing-dyn"/>.
-->
変数置換は<command>EXECUTE</command>コマンドまたはその亜種におけるコマンド文字列の中では起こりません。
そのようなコマンドに可変値を挿入する時は、<xref linkend="plpgsql-statements-executing-dyn"/>に述べたように、文字列の値を構成するものの一部とするか<literal>USING</literal>を使用してください。
   </para>

   <para>
<!--
    Variable substitution currently works only in <command>SELECT</command>,
    <command>INSERT</command>, <command>UPDATE</command>,
    <command>DELETE</command>, and commands containing one of
    these (such as <command>EXPLAIN</command> and <command>CREATE TABLE
    ... AS SELECT</command>),
    because the main SQL engine allows query parameters only in these
    commands.  To use a non-constant name or value in other statement
    types (generically called utility statements), you must construct
    the utility statement as a string and <command>EXECUTE</command> it.
-->
今のところ変数置換は、<command>SELECT</command>と<command>INSERT</command>と<command>UPDATE</command>と<command>DELETE</command>コマンドの中だけで作動します。
メインSQLエンジンが問い合わせパラメータをこれらのコマンドでしか許可しないからです。
他の種類の文（通常ユーティリティ文といいます）において可変名または可変値を使用するには、文字列としてユーティリティ文を構成し<command>EXECUTE</command>してください。
   </para>

  </sect2>

  <sect2 id="plpgsql-plan-caching">
<!--
   <title>Plan Caching</title>
-->
<title>計画のキャッシュ</title>

   <para>
<!--
    The <application>PL/pgSQL</application> interpreter parses the function's source
    text and produces an internal binary instruction tree the first time the
    function is called (within each session).  The instruction tree
    fully translates the
    <application>PL/pgSQL</application> statement structure, but individual
    <acronym>SQL</acronym> expressions and <acronym>SQL</acronym> commands
    used in the function are not translated immediately.
-->
<application>PL/pgSQL</application>インタプリタは、初めてその関数が（各セッションで）呼び出された時に、関数のソーステキストを解析し、バイナリ形式の命令ツリーを内部で作成します。
この命令ツリーは完全に<application>PL/pgSQL</application>文構造に変換されますが、関数内部の個々の<acronym>SQL</acronym>式と<acronym>SQL</acronym>コマンドは即座に変換されません。
   </para>

   <para>
    <indexterm>
<!--
     <primary>preparing a query</primary>
     <secondary>in PL/pgSQL</secondary>
-->
<primary>問い合わせの準備</primary>
<secondary>PL/pgSQLにおける</secondary>
    </indexterm>
<!--
    As each expression and <acronym>SQL</acronym> command is first
    executed in the function, the <application>PL/pgSQL</application> interpreter
    parses and analyzes the command to create a prepared statement,
    using the <acronym>SPI</acronym> manager's
    <function>SPI_prepare</function> function.
    Subsequent visits to that expression or command
    reuse the prepared statement.  Thus, a function with conditional code
    paths that are seldom visited will never incur the overhead of
    analyzing those commands that are never executed within the current
    session.  A disadvantage is that errors
    in a specific expression or command cannot be detected until that
    part of the function is reached in execution.  (Trivial syntax
    errors will be detected during the initial parsing pass, but
    anything deeper will not be detected until execution.)
-->
各式や<acronym>SQL</acronym>コマンドが初めてその関数で実行される時に、<application>PL/pgSQL</application>インタプリタは<acronym>SPI</acronym>マネージャの<function>SPI_prepare</function>関数を使用して、プリペアドステートメントを作成するためにコマンドを解析します。
その後にその式やコマンドが行われる時には、そのプリペアドステートメントを再利用します。
こうして、めったに分岐されない条件付きコードパスを持つ関数では、現在のセッションで実行されないそれらのコマンドの解析によるオーバーヘッドを背負いこむことはありません。
欠点は特定の式や問い合わせのエラーが、関数の該当部分が実行されるまで検出されないことです。
（典型的な構文エラーは、最初の解釈において検出されますが、それより深いエラーは、実行の時まで検出されません）。
   </para>

   <para>
<!--
    <application>PL/pgSQL</application> (or more precisely, the SPI manager) can
    furthermore attempt to cache the execution plan associated with any
    particular prepared statement.  If a cached plan is not used, then
    a fresh execution plan is generated on each visit to the statement,
    and the current parameter values (that is, <application>PL/pgSQL</application>
    variable values) can be used to optimize the selected plan.  If the
    statement has no parameters, or is executed many times, the SPI manager
    will consider creating a <firstterm>generic</firstterm> plan that is not dependent
    on specific parameter values, and caching that for re-use.  Typically
    this will happen only if the execution plan is not very sensitive to
    the values of the <application>PL/pgSQL</application> variables referenced in it.
    If it is, generating a plan each time is a net win.  See <xref
    linkend="sql-prepare"/> for more information about the behavior of
    prepared statements.
-->
<application>PL/pgSQL</application>は（正確にはSPIマネージャは）さらに特定のプリペアドステートメントに関する実行計画のキャッシュを試行できます。
キャッシュした実行計画が使用されなかった場合、プリペアドステートメントが呼び出される度に新しい実行計画が作成され、選択した実行計画を最適にするために、最新のパラメータ値（すなわち<application>PL/pgSQL</application>の変数値）が使用されます。
プリペアドステートメントがパラメータを持たないか何回も使用される場合、SPIマネージャは特定のパラメータ値に依存しない<firstterm>一般的</firstterm>な実行計画の作成を考え、再使用のためにキャッシュします。
典型的には、これは参照した<application>PL/pgSQL</application>の変数値が、実行計画にさほど影響しない場合にだけ起こります。
それならば、毎回の実行計画の作成の方が優れています。
プリペアドステートメントに関する詳細は<xref linkend="sql-prepare"/>を参照してください。
   </para>

   <para>
<!--
    Because <application>PL/pgSQL</application> saves prepared statements
    and sometimes execution plans in this way,
    SQL commands that appear directly in a
    <application>PL/pgSQL</application> function must refer to the
    same tables and columns on every execution; that is, you cannot use
    a parameter as the name of a table or column in an SQL command.  To get
    around this restriction, you can construct dynamic commands using
    the <application>PL/pgSQL</application> <command>EXECUTE</command>
    statement &mdash; at the price of performing new parse analysis and
    constructing a new execution plan on every execution.
-->
このように<application>PL/pgSQL</application>はプリペアドステートメントおよび時には実行計画を保存しますので、<application>PL/pgSQL</application>関数内に直接現れるSQLコマンドは実行の度に同じテーブルとフィールドを参照しなければなりません。
つまり、SQLコマンドにて、テーブルやフィールドの名前としてパラメータを使用することができません。
実行の度に新しく実行計画を作成して解析する無駄を覚悟で、<application>PL/pgSQL</application>の<command>EXECUTE</command>文を使った動的問い合わせを構成することで、この制限を回避できます。
   </para>

    <para>
<!--
     The mutable nature of record variables presents another problem in this
     connection.  When fields of a record variable are used in
     expressions or statements, the data types of the fields must not
     change from one call of the function to the next, since each
     expression will be analyzed using the data type that is present
     when the expression is first reached.  <command>EXECUTE</command> can be
     used to get around this problem when necessary.
-->
レコード変数の変わりやすいという性質はこの接続において別の問題となります。
レコード変数のフィールドが式や文の中で使用される場合、そのフィールドのデータ型を関数を呼び出す度に変更してはいけません。
それぞれの式が最初に実行された時のデータ型を使用して、その式が解析されているからです。
必要な場合<command>EXECUTE</command>を使用してこの問題を回避することができます。
    </para>

    <para>
<!--
     If the same function is used as a trigger for more than one table,
     <application>PL/pgSQL</application> prepares and caches statements
     independently for each such table &mdash; that is, there is a cache
     for each trigger function and table combination, not just for each
     function.  This alleviates some of the problems with varying
     data types; for instance, a trigger function will be able to work
     successfully with a column named <literal>key</literal> even if it happens
     to have different types in different tables.
-->
同一の関数が2つ以上のテーブルのトリガとして使用される場合、<application>PL/pgSQL</application>はテーブルごとのプリペアドステートメントをキャッシュします。
すなわち、各々のトリガ関数とテーブルの組ごとにキャッシュするのであり、トリガ関数ごとではありません。
このため、データ型の変更に伴う問題の一部を軽減します。
例えば、別のテーブルにある異なったデータ型であっても、<literal>key</literal>と命名した列に対してトリガ関数は有効に作動します。
    </para>

    <para>
<!--
     Likewise, functions having polymorphic argument types have a separate
     statement cache for each combination of actual argument types they have
     been invoked for, so that data type differences do not cause unexpected
     failures.
-->
同様に、多様型の引数を持った関数は、実際に呼び出す引数の型の組み合わせごとに別々のプリペアドステートメントをキャッシュします。
そのため、データ型の差異が原因で予期しない失敗が起こることはありません。
    </para>

   <para>
<!--
    Statement caching can sometimes have surprising effects on the
    interpretation of time-sensitive values.  For example there
    is a difference between what these two functions do:
-->
プリペアドステートメントのキャッシュにより、時間に依存する値の解釈の結果に違いが現れることがあります。
例えば、以下の2つの関数の結果は異なります。

<programlisting>
CREATE FUNCTION logfunc1(logtxt text) RETURNS void AS $$
    BEGIN
        INSERT INTO logtable VALUES (logtxt, 'now');
    END;
$$ LANGUAGE plpgsql;
</programlisting>

<!--
     and:
-->
および

<programlisting>
CREATE FUNCTION logfunc2(logtxt text) RETURNS void AS $$
    DECLARE
        curtime timestamp;
    BEGIN
        curtime := 'now';
        INSERT INTO logtable VALUES (logtxt, curtime);
    END;
$$ LANGUAGE plpgsql;
</programlisting>
    </para>

    <para>
<!--
     In the case of <function>logfunc1</function>, the
     <productname>PostgreSQL</productname> main parser knows when
     analyzing the <command>INSERT</command> that the
     string <literal>'now'</literal> should be interpreted as
     <type>timestamp</type>, because the target column of
     <classname>logtable</classname> is of that type. Thus,
     <literal>'now'</literal> will be converted to a <type>timestamp</type>
     constant when the
     <command>INSERT</command> is analyzed, and then used in all
     invocations of <function>logfunc1</function> during the lifetime
     of the session. Needless to say, this isn't what the programmer
     wanted.  A better idea is to use the <literal>now()</literal> or
     <literal>current_timestamp</literal> function.
-->
<function>logfunc1</function>の場合では、<productname>PostgreSQL</productname>のメインパーサは、<command>INSERT</command>を解析する時に、<classname>logtable</classname>の対象列の型から<literal>'now'</literal>を<type>timestamp</type>と解釈しなければならないことを把握しています。
こうして、パーサは<command>INSERT</command>が解析された時点で<literal>'now'</literal>を<type>timestamp</type>定数に変換し、その定数値をその後のセッションの有効期間における<function>logfunc1</function>の全ての呼び出しで使用します。
言うまでもありませんが、これはプログラマが意図した動作ではありません。
<literal>now()</literal>または<literal>current_timestamp</literal>関数の使用が優れています。
    </para>

    <para>
<!--
     In the case of <function>logfunc2</function>, the
     <productname>PostgreSQL</productname> main parser does not know
     what type <literal>'now'</literal> should become and therefore
     it returns a data value of type <type>text</type> containing the string
     <literal>now</literal>. During the ensuing assignment
     to the local variable <varname>curtime</varname>, the
     <application>PL/pgSQL</application> interpreter casts this
     string to the <type>timestamp</type> type by calling the
     <function>textout</function> and <function>timestamp_in</function>
     functions for the conversion.  So, the computed time stamp is updated
     on each execution as the programmer expects.  Even though this
     happens to work as expected, it's not terribly efficient, so
     use of the <literal>now()</literal> function would still be a better idea.
-->
<function>logfunc2</function>の場合では、<productname>PostgreSQL</productname>のメインパーサは<literal>'now'</literal>の型を決定することができません。
そのため、<literal>now</literal>という文字列を持つ<type>text</type>型のデータ値を返します。
<varname>curtime</varname>ローカル変数に代入する時に、<application>PL/pgSQL</application>インタプリタはこの文字列を<function>textout</function>と<function>timestamp_in</function>関数を変換に使用して<type>timestamp</type>型にキャストします。
ですから、演算されたタイムスタンプは、プログラマが意図した通り、実行の度に更新されます。
この方法でたまたま意図した通り動くけれど、それほど効率的ではありません。
ですから、<literal>now()</literal>関数の使用の方が優れています。
    </para>

  </sect2>

  </sect1>

 <sect1 id="plpgsql-development-tips">
<!--
  <title>Tips for Developing in <application>PL/pgSQL</application></title>
-->
<title><application>PL/pgSQL</application>による開発向けのヒント</title>

   <para>
<!--
    One good way to develop in
    <application>PL/pgSQL</application> is to use the text editor of your
    choice to create your functions, and in another window, use
    <application>psql</application> to load and test those functions.
    If you are doing it this way, it
    is a good idea to write the function using <command>CREATE OR
    REPLACE FUNCTION</command>. That way you can just reload the file to update
    the function definition.  For example:
-->
<application>PL/pgSQL</application>で開発する1つの良い方法は、関数を作成するのに自分の好きなテキストエディタを使い、もう1つのウィンドウで<application>psql</application>を使用して関数を読み込ませて試験を行うことです。
この方法で行う場合には<command>CREATE OR REPLACE FUNCTION</command>を使用して関数を作成する方が良いでしょう。
この方法でファイルを再読み込みすると、関数定義を更新することができます。
例えば以下のようにします。
<programlisting>
CREATE OR REPLACE FUNCTION testfunc(integer) RETURNS integer AS $$
          ....
$$ LANGUAGE plpgsql;
</programlisting>
   </para>

   <para>
<!--
    While running <application>psql</application>, you can load or reload such
    a function definition file with:
-->
<application>psql</application>を実行し、以下のように関数定義ファイルを読み込み、または再読み込みすることができます。
<programlisting>
\i filename.sql
</programlisting>
<!--
    and then immediately issue SQL commands to test the function.
-->
その後すぐに、関数を試験するためにSQLコマンドを発行することができます。
   </para>

   <para>
<!--
    Another good way to develop in <application>PL/pgSQL</application> is with a
    GUI database access tool that facilitates development in a
    procedural language. One example of such a tool is
    <application>pgAdmin</application>, although others exist. These tools often
    provide convenient features such as escaping single quotes and
    making it easier to recreate and debug functions.
-->
<application>PL/pgSQL</application>における開発のもう1つの良い方法は、手続き言語の開発機能を持つGUIデータベースアクセスツールを使用することです。
他にもありますが、<application>pgAdmin</application>がこうしたツールの一例です。
こうしたツールは、単一引用符をエスケープさせたり、関数の作り直しやデバッグが容易に行えたりする便利な機能をよく持っています。
   </para>

  <sect2 id="plpgsql-quote-tips">
<!--
   <title>Handling of Quotation Marks</title>
-->
<title>引用符の扱い</title>

   <para>
<!--
    The code of a <application>PL/pgSQL</application> function is specified in
    <command>CREATE FUNCTION</command> as a string literal.  If you
    write the string literal in the ordinary way with surrounding
    single quotes, then any single quotes inside the function body
    must be doubled; likewise any backslashes must be doubled (assuming
    escape string syntax is used).
    Doubling quotes is at best tedious, and in more complicated cases
    the code can become downright incomprehensible, because you can
    easily find yourself needing half a dozen or more adjacent quote marks.
    It's recommended that you instead write the function body as a
    <quote>dollar-quoted</quote> string literal (see <xref
    linkend="sql-syntax-dollar-quoting"/>).  In the dollar-quoting
    approach, you never double any quote marks, but instead take care to
    choose a different dollar-quoting delimiter for each level of
    nesting you need.  For example, you might write the <command>CREATE
    FUNCTION</command> command as:
-->
<application>PL/pgSQL</application>関数のコードは<command>CREATE FUNCTION</command>内で文字列リテラルとして指定されます。
単一引用符で囲む通常のやり方で文字列リテラルを記述する時、関数本体内部の全ての単一引用符を二重化しなければなりません。
同様に、全てのバックスラッシュを二重化しなければなりません。
なお、文字列としてエスケープする構文が使用されると仮定します。
引用符を単に重ねるやり方は最も冗長であり、簡単に想像できると思いますが、複雑な状態では数個以上の隣接した引用符が必要となるため、コードを率直には理解しにくくなります。
それに代わって推奨されるのは、関数本体を<quote>ドル引用符</quote>の文字列リテラルとして記述することです（<xref linkend="sql-syntax-dollar-quoting"/>を見てください）。
ドル引用符を用いるやり方では他の引用符を二重化する必要はありませんが、それぞれの入れ子になった階層ごとに異なったドル引用符による区切り符号を用いなければなりません。
例えば、<command>CREATE FUNCTION</command>コマンドを以下のように記述しても構いません。
<programlisting>
CREATE OR REPLACE FUNCTION testfunc(integer) RETURNS integer AS $PROC$
          ....
$PROC$ LANGUAGE plpgsql;
</programlisting>
<!--
    Within this, you might use quote marks for simple literal strings in
    SQL commands and <literal>$$</literal> to delimit fragments of SQL commands
    that you are assembling as strings.  If you need to quote text that
    includes <literal>$$</literal>, you could use <literal>$Q$</literal>, and so on.
-->
このやり方では、SQLコマンドの中で単純なリテラル文字列に対して引用符を使用でき、文字列として集積したSQLコマンドの断片を区切るために<literal>$$</literal>を使用できます。
もし<literal>$$</literal>を含んだテキストを引用符で囲む時は、<literal>$Q$</literal>のような記述を使用できます。
   </para>

   <para>
<!--
    The following chart shows what you have to do when writing quote
    marks without dollar quoting.  It might be useful when translating
    pre-dollar quoting code into something more comprehensible.
-->
以下の表はドル引用符を用いない時の引用符の記述法を示したものです。
ドル引用符を用いる以前における引用符の記述を理解するのに、この表は役立つと思われます。
  </para>

  <variablelist>
   <varlistentry>
<!--
    <term>1 quotation mark</term>
-->
<term>1つの引用符</term>
    <listitem>
     <para>
<!--
      To begin and end the function body, for example:
-->
関数本体の先頭と末尾。
以下に例を示します。
<programlisting>
CREATE FUNCTION foo() RETURNS integer AS '
          ....
' LANGUAGE plpgsql;
</programlisting>
<!--
      Anywhere within a single-quoted function body, quote marks
      <emphasis>must</emphasis> appear in pairs.
-->
関数本体内部では引用符は<emphasis>必ず</emphasis>ペアで現れます。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--
    <term>2 quotation marks</term>
-->
<term>2つの引用符</term>
    <listitem>
     <para>
<!--
      For string literals inside the function body, for example:
-->
関数本体内部の文字列リテラル用。
以下に例を示します。
<programlisting>
a_output := ''Blah'';
SELECT * FROM users WHERE f_name=''foobar'';
</programlisting>
<!--
      In the dollar-quoting approach, you'd just write:
-->
ドル引用符を用いる時は、次のように記述します。
<programlisting>
a_output := 'Blah';
SELECT * FROM users WHERE f_name='foobar';
</programlisting>
<!--
      which is exactly what the <application>PL/pgSQL</application> parser would see
      in either case.
-->
どちらも<application>PL/pgSQL</application>パーサから見ると同一となります。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--
    <term>4 quotation marks</term>
-->
<term>4つの引用符</term>
    <listitem>
     <para>
<!--
      When you need a single quotation mark in a string constant inside the
      function body, for example:
-->
関数本体内部の文字列リテラル内の単一引用符がある場合。
以下に例を示します。
<programlisting>
a_output := a_output || '' AND name LIKE ''''foobar'''' AND xyz''
</programlisting>
<!--
      The value actually appended to <literal>a_output</literal> would be:
      <literal> AND name LIKE 'foobar' AND xyz</literal>.
-->
実際に<literal>a_output</literal>に追加される値は、<literal> AND name LIKE 'foobar' AND xyz</literal>です。
     </para>
     <para>
<!--
      In the dollar-quoting approach, you'd write:
-->
ドル引用符を用いる時は、次のように記述します。
<programlisting>
a_output := a_output || $$ AND name LIKE 'foobar' AND xyz$$
</programlisting>
<!--
      being careful that any dollar-quote delimiters around this are not
      just <literal>$$</literal>.
-->
なお、ドル引用符の区切り文字は<literal>$$</literal>だけとは限らないことに注意してください。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--
    <term>6 quotation marks</term>
-->
<term>6つの引用符</term>
    <listitem>
     <para>
<!--
      When a single quotation mark in a string inside the function body is
      adjacent to the end of that string constant, for example:
-->
関数本体内部の文字列内の単一引用符が、文字列定数の末尾にある場合。
以下に例を示します。
<programlisting>
a_output := a_output || '' AND name LIKE ''''foobar''''''
</programlisting>
<!--
      The value appended to <literal>a_output</literal> would then be:
      <literal> AND name LIKE 'foobar'</literal>.
-->
実際に<literal>a_output</literal>に追加される値は、<literal> AND name LIKE 'foobar'</literal>です。
     </para>
     <para>
<!--
      In the dollar-quoting approach, this becomes:
-->
ドル引用符を用いる時は、次のようになります。
<programlisting>
a_output := a_output || $$ AND name LIKE 'foobar'$$
</programlisting>
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--
    <term>10 quotation marks</term>
-->
<term>10個の引用符</term>
    <listitem>
     <para>
<!--
      When you want two single quotation marks in a string constant (which
      accounts for 8 quotation marks) and this is adjacent to the end of that
      string constant (2 more).  You will probably only need that if
      you are writing a function that generates other functions, as in
      <xref linkend="plpgsql-porting-ex2"/>.
      For example:
-->
文字列定数内に 2つの単一引用符を持たせたい場合（これで8個の単一引用符になり）、かつ、この文字列定数の末尾にある場合（これで2個追加されます）。
おそらく、他の関数を生成する関数を作成する場合（<xref linkend="plpgsql-porting-ex2"/>）のみにこれが必要になるでしょう。
以下に例を示します。
<programlisting>
a_output := a_output || '' if v_'' ||
    referrer_keys.kind || '' like ''''''''''
    || referrer_keys.key_string || ''''''''''
    then return ''''''  || referrer_keys.referrer_type
    || ''''''; end if;'';
</programlisting>
<!--
      The value of <literal>a_output</literal> would then be:
-->
<literal>a_output</literal>の値は以下のようになります。
<programlisting>
if v_... like ''...'' then return ''...''; end if;
</programlisting>
     </para>
     <para>
<!--
      In the dollar-quoting approach, this becomes:
-->
ドル引用符を用いる時は、次のようになります。
<programlisting>
a_output := a_output || $$ if v_$$ || referrer_keys.kind || $$ like '$$
    || referrer_keys.key_string || $$'
    then return '$$  || referrer_keys.referrer_type
    || $$'; end if;$$;
</programlisting>
<!--
      where we assume we only need to put single quote marks into
      <literal>a_output</literal>, because it will be re-quoted before use.
-->
ここで単一引用符は使用前に再評価されるため、<literal>a_output</literal>内部だけで必要であると仮定します。
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

  </sect2>
  <sect2 id="plpgsql-extra-checks">
<!--
   <title>Additional Compile-Time and Run-Time Checks</title>
-->
<title>コンパイル時と実行時の付加的チェック</title>

   <para>
<!--
    To aid the user in finding instances of simple but common problems before
    they cause harm, <application>PL/pgSQL</application> provides additional
    <replaceable>checks</replaceable>. When enabled, depending on the configuration, they
    can be used to emit either a <literal>WARNING</literal> or an <literal>ERROR</literal>
    during the compilation of a function. A function which has received
    a <literal>WARNING</literal> can be executed without producing further messages,
    so you are advised to test in a separate development environment.
-->
単純でありふれた問題が有害となる前の実例を発見するユーザを助けるため<application>PL/PgSQL</application>は付加的<replaceable>checks</replaceable>を提供します。
可能かどうかは設定に依存しますが、関数のコンパイルのとき<literal>WARNING</literal>または<literal>ERROR</literal>を省略して使用できます。
<literal>WARNING</literal>を指定された関数は、それ以上のメッセージを生成しないで実行できます。
したがって、分離された開発環境でテストを実行できます。
   </para>

   <para>
<!--
    Setting <varname>plpgsql.extra_warnings</varname>, or
    <varname>plpgsql.extra_errors</varname>, as appropriate, to <literal>"all"</literal>
    is encouraged in development and/or testing environments.
-->
開発環境やテスト環境では、<varname>plpgsql.extra_warnings</varname>や<varname>plpgsql.extra_errors</varname>を適切に<literal>"all"</literal>に設定することを勧めます。
   </para>

   <para>
<!--
    These additional checks are enabled through the configuration variables
    <varname>plpgsql.extra_warnings</varname> for warnings and
    <varname>plpgsql.extra_errors</varname> for errors. Both can be set either to
    a comma-separated list of checks, <literal>"none"</literal> or
    <literal>"all"</literal>. The default is <literal>"none"</literal>. Currently
    the list of available checks includes:
-->
この付加的チェックでは、設定変数<varname>plpgsql.extra_warnings</varname>を警告のために<varname>plpgsql.extra_errors</varname>をエラーのために使用できます。
どちらも、カンマで区切ったチェックリストまたは<literal>"none"</literal>または<literal>"all"</literal>と設定できます。
デフォルトは<literal>"none"</literal>です。
現在指定できるチェックの一覧は以下の通りです。
    <variablelist>
     <varlistentry>
      <term><varname>shadowed_variables</varname></term>
      <listitem>
       <para>
<!--
        Checks if a declaration shadows a previously defined variable.
-->
宣言が以前に定義した変数を隠すかどうかチェックする。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>strict_multi_assignment</varname></term>
      <listitem>
       <para>
<!--
        Some <application>PL/PgSQL</application> commands allow assigning
        values to more than one variable at a time, such as
        <command>SELECT INTO</command>.  Typically, the number of target
        variables and the number of source variables should match, though
        <application>PL/PgSQL</application> will use <literal>NULL</literal>
        for missing values and extra variables are ignored.  Enabling this
        check will cause <application>PL/PgSQL</application> to throw a
        <literal>WARNING</literal> or <literal>ERROR</literal> whenever the
        number of target variables and the number of source variables are
        different.
-->
<application>PL/PgSQL</application>コマンドのいくつかは、<command>SELECT INTO</command>のように、一度に2つ以上の変数に値を割り当てることを許しています。
<application>PL/PgSQL</application>は、ない値に対しては<literal>NULL</literal>を使い、余分な変数は無視しますが、通常は対象の変数の数と元の変数の数は一致するべきです。
このチェックを有効にすると、<application>PL/PgSQL</application>は対象の変数の数と元の変数の数が異なる場合には必ず<literal>WARNING</literal>または<literal>ERROR</literal>を発生するようになります。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>too_many_rows</varname></term>
      <listitem>
       <para>
<!--
        Enabling this check will cause <application>PL/PgSQL</application> to
        check if a given query returns more than one row when an
        <literal>INTO</literal> clause is used.  As an <literal>INTO</literal>
        statement will only ever use one row, having a query return multiple
        rows is generally either inefficient and/or nondeterministic and
        therefore is likely an error.
-->
このチェックを有効にすると、<application>PL/PgSQL</application>は<literal>INTO</literal>句が使われている場合、与えられた問い合わせが2行以上の行を返すかどうか確認します。
<literal>INTO</literal>文は必ず1行に対してのみ使われますので、複数の行を返す問い合わせがあるということは一般に非効率かつ/または非決定論的であり、そのためおそらくエラーです。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>

<!--
    The following example shows the effect of <varname>plpgsql.extra_warnings</varname>
    set to <varname>shadowed_variables</varname>:
-->
以下の例では、<varname>plpgsql.extra_warnings</varname>を<varname>shadowed_variables</varname>に設定した結果を示します。
<programlisting>
SET plpgsql.extra_warnings TO 'shadowed_variables';

CREATE FUNCTION foo(f1 int) RETURNS int AS $$
DECLARE
f1 int;
BEGIN
RETURN f1;
END;
$$ LANGUAGE plpgsql;
WARNING:  variable "f1" shadows a previously defined variable
LINE 3: f1 int;
        ^
CREATE FUNCTION
</programlisting>
<!--
    The below example shows the effects of setting
    <varname>plpgsql.extra_warnings</varname> to
    <varname>strict_multi_assignment</varname>:
-->
以下の例では、<varname>plpgsql.extra_warnings</varname>を<varname>strict_multi_assignment</varname>に設定した結果を示します。
<programlisting>
SET plpgsql.extra_warnings TO 'strict_multi_assignment';

CREATE OR REPLACE FUNCTION public.foo()
 RETURNS void
 LANGUAGE plpgsql
AS $$
DECLARE
  x int;
  y int;
BEGIN
  SELECT 1 INTO x, y;
  SELECT 1, 2 INTO x, y;
  SELECT 1, 2, 3 INTO x, y;
END;
$$;

SELECT foo();
WARNING:  number of source and target fields in assignment does not match
DETAIL:  strict_multi_assignment check of extra_warnings is active.
HINT:  Make sure the query returns the exact list of columns.
WARNING:  number of source and target fields in assignment does not match
DETAIL:  strict_multi_assignment check of extra_warnings is active.
HINT:  Make sure the query returns the exact list of columns.

 foo 
-----
 
(1 row)
</programlisting>
   </para>
  </sect2>
 </sect1>

  <!-- **** Porting from Oracle PL/SQL **** -->

 <sect1 id="plpgsql-porting">
<!--
  <title>Porting from <productname>Oracle</productname> PL/SQL</title>
-->
<title><productname>Oracle</productname> PL/SQLからの移植</title>

  <indexterm zone="plpgsql-porting">
   <primary>Oracle</primary>
<!--
   <secondary>porting from PL/SQL to PL/pgSQL</secondary>
-->
<secondary>PL/SQLからPL/pgSQLへの移植</secondary>
  </indexterm>

  <indexterm zone="plpgsql-porting">
   <primary>PL/SQL (Oracle)</primary>
<!--
   <secondary>porting to PL/pgSQL</secondary>
-->
<secondary>PL/pgSQLへの移植</secondary>
  </indexterm>

  <para>
<!--
   This section explains differences between
   <productname>PostgreSQL</productname>'s <application>PL/pgSQL</application>
   language and Oracle's <application>PL/SQL</application> language,
   to help developers who port applications from
   <trademark class="registered">Oracle</trademark> to <productname>PostgreSQL</productname>.
-->
本節では<trademark class="registered">Oracle</trademark>から<productname>PostgreSQL</productname>へアプリケーションを移植する開発者の手助けとなるように、<productname>PostgreSQL</productname>の<application>PL/pgSQL</application>言語とOracleの<application>PL/SQL</application>言語の違いについて説明します。
  </para>

  <para>
<!--
   <application>PL/pgSQL</application> is similar to PL/SQL in many
   aspects. It is a block-structured, imperative language, and all
   variables have to be declared.  Assignments, loops, and conditionals
   are similar.  The main differences you should keep in mind when
   porting from <application>PL/SQL</application> to
   <application>PL/pgSQL</application> are:
-->
<application>PL/pgSQL</application>は多くの点でPL/SQLに似ています。
それはブロックで構成されていて、厳格な言語であり、全ての変数は宣言されなければならない点です。
代入やループ、条件分岐も同様です。
<application>PL/SQL</application>から<application>PL/pgSQL</application>に移植する際に注意しなければならない、主な違いを以下に示します。

    <itemizedlist>
     <listitem>
      <para>
<!--
       If a name used in an SQL command could be either a column name of a
       table used in the command or a reference to a variable of the function,
       <application>PL/SQL</application> treats it as a column name.
       By default, <application>PL/pgSQL</application> will throw an error
       complaining that the name is ambiguous.  You can specify
       <literal>plpgsql.variable_conflict</literal> = <literal>use_column</literal>
       to change this behavior to match <application>PL/SQL</application>,
       as explained in <xref linkend="plpgsql-var-subst"/>.
       It's often best to avoid such ambiguities in the first place,
       but if you have to port a large amount of code that depends on
       this behavior, setting <literal>variable_conflict</literal> may be the
       best solution.
-->
SQLコマンド内に使用された名前が、テーブルの列名または関数の変数への参照のどちらにもなり得る場合、<application>PL/SQL</application>は列名として処理します。
これは<application>PL/pgSQL</application>における<literal>plpgsql.variable_conflict</literal> = <literal>use_column</literal>時の動作に対応しますが、<xref linkend="plpgsql-var-subst"/>の説明通り、これはデフォルトではありません。
初期段階において、そのようなあいまいさを避けることが最善です。
しかしこの動作に依存するコードの量が多いものを移植しなければならない場合、<literal>variable_conflict</literal>を使用することが最善の解法かもしれません。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       In <productname>PostgreSQL</productname> the function body must be written as
       a string literal.  Therefore you need to use dollar quoting or escape
       single quotes in the function body. (See <xref
       linkend="plpgsql-quote-tips"/>.)
-->
<productname>PostgreSQL</productname>の関数本体は文字列リテラルとして書かなければなりません。
したがって、関数本体内部でドル引用符を使用するか、単一引用符をエスケープする必要があります。
（<xref linkend="plpgsql-quote-tips"/>を参照してください）。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       Data type names often need translation.  For example, in Oracle string
       values are commonly declared as being of type <type>varchar2</type>, which
       is a non-SQL-standard type.  In <productname>PostgreSQL</productname>,
       use type <type>varchar</type> or <type>text</type> instead.  Similarly, replace
       type <type>number</type> with <type>numeric</type>, or use some other numeric
       data type if there's a more appropriate one.
-->
データ型名はしばしば翻訳が必要です。
たとえば、Oracleでは文字列の値はよく<type>varchar2</type>型と宣言されますが、それは非標準SQL型です。
<productname>PostgreSQL</productname>では、その代わりに<type>varchar</type>型または<type>text</type>型を使ってください。
同様に、<type>number</type>型は<type>numeric</type>型で置き換えるか、より適切なものがあるなら他の数値データ型を使ってください。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       Instead of packages, use schemas to organize your functions
       into groups.
-->
パッケージの代わりに、スキーマを使用して関数群をグループにまとめてください。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       Since there are no packages, there are no package-level variables
       either. This is somewhat annoying.  You can keep per-session state
       in temporary tables instead.
-->
パッケージがないため、パッケージレベルの変数もありません。
これは幾分か厄介なことです。
代わって、セッションごとの状態を一時テーブル内部に保存できます。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       Integer <command>FOR</command> loops with <literal>REVERSE</literal> work
       differently: <application>PL/SQL</application> counts down from the second
       number to the first, while <application>PL/pgSQL</application> counts down
       from the first number to the second, requiring the loop bounds
       to be swapped when porting.  This incompatibility is unfortunate
       but is unlikely to be changed. (See <xref
       linkend="plpgsql-integer-for"/>.)
-->
<literal>REVERSE</literal>を付けた整数<command>FOR</command>ループの処理は異なります。
<application>PL/SQL</application>では最後の数から最初の数へ減少しながら処理しますが、<application>PL/pgSQL</application>では最初の数から最後の数へ減少しながら処理します。
移植において、ループの両端となる最初の数と最後の数を交換する必要があります。
この非互換性は不幸なことですが、変わりそうもありません。
（<xref linkend="plpgsql-integer-for"/>を見てください。）
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       <command>FOR</command> loops over queries (other than cursors) also work
       differently: the target variable(s) must have been declared,
       whereas <application>PL/SQL</application> always declares them implicitly.
       An advantage of this is that the variable values are still accessible
       after the loop exits.
-->
問い合わせ上の<command>FOR</command>ループも（カーソルを除いて）異なって処理されます。
対象の変数は宣言されなければなりませんが、<application>PL/SQL</application>は常にそれらを暗黙的に宣言します。
この優位点は変数値をループを抜けてからでも依然としてアクセスできることです。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       There are various notational differences for the use of cursor
       variables.
-->
カーソル変数の使用に対する様々な表記上の違いがあります。
      </para>
     </listitem>

    </itemizedlist>
   </para>

  <sect2>
<!--
   <title>Porting Examples</title>
-->
<title>移植例</title>

   <para>
<!--
    <xref linkend="pgsql-porting-ex1"/> shows how to port a simple
    function from <application>PL/SQL</application> to <application>PL/pgSQL</application>.
-->
<xref linkend="pgsql-porting-ex1"/>に簡単な関数の<application>PL/SQL</application>から<application>PL/pgSQL</application>への移植方法を示します。
   </para>

   <example id="pgsql-porting-ex1">
<!--
    <title>Porting a Simple Function from <application>PL/SQL</application> to <application>PL/pgSQL</application></title>
-->
<title>簡単な関数の<application>PL/SQL</application>から<application>PL/pgSQL</application>への移植</title>

    <para>
<!--
     Here is an <productname>Oracle</productname> <application>PL/SQL</application> function:
-->
以下は<productname>Oracle</productname> <application>PL/SQL</application>の関数です。
<programlisting>
CREATE OR REPLACE FUNCTION cs_fmt_browser_version(v_name varchar2,
                                                  v_version varchar2)
RETURN varchar2 IS
BEGIN
    IF v_version IS NULL THEN
        RETURN v_name;
    END IF;
    RETURN v_name || '/' || v_version;
END;
/
show errors;
</programlisting>
    </para>

    <para>
<!--
     Let's go through this function and see the differences compared to
     <application>PL/pgSQL</application>:
-->
この関数を通じて、<application>PL/pgSQL</application>との違いを見てみましょう。

     <itemizedlist>
      <listitem>
       <para>
<!--
        The type name <type>varchar2</type> has to be changed to <type>varchar</type>
        or <type>text</type>.  In the examples in this section, we'll
        use <type>varchar</type>, but <type>text</type> is often a better choice if
        you do not need specific string length limits.
-->
型名<type>varchar2</type>は、<type>varchar</type>または<type>text</type>に変えなければなりません。
この節の例では<type>varchar</type>を使いますが、文字列を特定の長さに制限する必要がないのであれば<type>text</type>の方がたいていは良い選択です。
       </para>
      </listitem>

      <listitem>
       <para>
<!--
        The <literal>RETURN</literal> key word in the function
        prototype (not the function body) becomes
        <literal>RETURNS</literal> in
        <productname>PostgreSQL</productname>.
        Also, <literal>IS</literal> becomes <literal>AS</literal>, and you need to
        add a <literal>LANGUAGE</literal> clause because <application>PL/pgSQL</application>
        is not the only possible function language.
-->
関数プロトタイプ内の<literal>RETURN</literal>キーワード（関数本体ではありません）は<productname>PostgreSQL</productname>では<literal>RETURNS</literal>になります。
同様に<literal>IS</literal>は<literal>AS</literal>になります。
<application>PL/pgSQL</application>以外の言語でも関数を記述できるため、<literal>LANGUAGE</literal>句が必要となります。
       </para>
      </listitem>

      <listitem>
       <para>
<!--
        In <productname>PostgreSQL</productname>, the function body is considered
        to be a string literal, so you need to use quote marks or dollar
        quotes around it.  This substitutes for the terminating <literal>/</literal>
        in the Oracle approach.
-->
<productname>PostgreSQL</productname>は関数本体を文字列リテラルと考えます。
したがって、それを囲むドル引用符または他の引用符が必要です。
これは<literal>/</literal>で終了するOracleの方法の代替です。
       </para>
      </listitem>

      <listitem>
       <para>
<!--
        The <literal>show errors</literal> command does not exist in
        <productname>PostgreSQL</productname>, and is not needed since errors are
        reported automatically.
-->
<productname>PostgreSQL</productname>には<literal>show errors</literal>コマンドはありません。
また、エラーが自動的に表示されるため、必要ありません。
       </para>
      </listitem>
     </itemizedlist>
    </para>

    <para>
<!--
     This is how this function would look when ported to
     <productname>PostgreSQL</productname>:
-->
それでは<productname>PostgreSQL</productname>に移植されると、この関数がどのようになるか見てみましょう。

<programlisting>
CREATE OR REPLACE FUNCTION cs_fmt_browser_version(v_name varchar,
                                                  v_version varchar)
RETURNS varchar AS $$
BEGIN
    IF v_version IS NULL THEN
        RETURN v_name;
    END IF;
    RETURN v_name || '/' || v_version;
END;
$$ LANGUAGE plpgsql;
</programlisting>
    </para>
   </example>

   <para>
<!--
    <xref linkend="plpgsql-porting-ex2"/> shows how to port a
    function that creates another function and how to handle the
    ensuing quoting problems.
-->
<xref linkend="plpgsql-porting-ex2"/>は、他の関数を生成する関数を移植する方法、ならびに、その結果発生する引用符問題を扱う方法を示します。
   </para>

   <example id="plpgsql-porting-ex2">
<!--
    <title>Porting a Function that Creates Another Function from <application>PL/SQL</application> to <application>PL/pgSQL</application></title>
-->
<title>他の関数を生成する<application>PL/SQL</application>を<application>PL/pgSQL</application>に移植</title>

    <para>
<!--
     The following procedure grabs rows from a
     <command>SELECT</command> statement and builds a large function
     with the results in <literal>IF</literal> statements, for the
     sake of efficiency.
-->
以下の手続きは、<command>SELECT</command>文からの行を取って、効率のために<literal>IF</literal>文で結果を巨大な関数に埋め込んでいます。
    </para>

    <para>
<!--
     This is the Oracle version:
-->
以下はOracle版です。
<programlisting>
CREATE OR REPLACE PROCEDURE cs_update_referrer_type_proc IS
    CURSOR referrer_keys IS
        SELECT * FROM cs_referrer_keys
        ORDER BY try_order;
    func_cmd VARCHAR(4000);
BEGIN
    func_cmd := 'CREATE OR REPLACE FUNCTION cs_find_referrer_type(v_host IN VARCHAR2,
                 v_domain IN VARCHAR2, v_url IN VARCHAR2) RETURN VARCHAR2 IS BEGIN';

    FOR referrer_key IN referrer_keys LOOP
        func_cmd := func_cmd ||
          ' IF v_' || referrer_key.kind
          || ' LIKE ''' || referrer_key.key_string
          || ''' THEN RETURN ''' || referrer_key.referrer_type
          || '''; END IF;';
    END LOOP;

    func_cmd := func_cmd || ' RETURN NULL; END;';

    EXECUTE IMMEDIATE func_cmd;
END;
/
show errors;
</programlisting>
    </para>

    <para>
<!--
     Here is how this function would end up in <productname>PostgreSQL</productname>:
-->
この関数を<productname>PostgreSQL</productname>で記述するとこうなるでしょう。
<programlisting>
CREATE OR REPLACE PROCEDURE cs_update_referrer_type_proc() AS $func$
DECLARE
    referrer_keys CURSOR IS
        SELECT * FROM cs_referrer_keys
        ORDER BY try_order;
    func_body text;
    func_cmd text;
BEGIN
    func_body := 'BEGIN';

    FOR referrer_key IN referrer_keys LOOP
        func_body := func_body ||
          ' IF v_' || referrer_key.kind
          || ' LIKE ' || quote_literal(referrer_key.key_string)
          || ' THEN RETURN ' || quote_literal(referrer_key.referrer_type)
          || '; END IF;' ;
    END LOOP;

    func_body := func_body || ' RETURN NULL; END;';

    func_cmd :=
      'CREATE OR REPLACE FUNCTION cs_find_referrer_type(v_host varchar,
                                                        v_domain varchar,
                                                        v_url varchar)
        RETURNS varchar AS '
      || quote_literal(func_body)
      || ' LANGUAGE plpgsql;' ;

    EXECUTE func_cmd;
END;
$func$ LANGUAGE plpgsql;
</programlisting>
<!--
     Notice how the body of the function is built separately and passed
     through <literal>quote_literal</literal> to double any quote marks in it.  This
     technique is needed because we cannot safely use dollar quoting for
     defining the new function: we do not know for sure what strings will
     be interpolated from the <structfield>referrer_key.key_string</structfield> field.
     (We are assuming here that <structfield>referrer_key.kind</structfield> can be
     trusted to always be <literal>host</literal>, <literal>domain</literal>, or
     <literal>url</literal>, but <structfield>referrer_key.key_string</structfield> might be
     anything, in particular it might contain dollar signs.) This function
     is actually an improvement on the Oracle original, because it will
     not generate broken code when <structfield>referrer_key.key_string</structfield> or
     <structfield>referrer_key.referrer_type</structfield> contain quote marks.
-->
関数本体を別途作成し、それを<literal>quote_literal</literal>に渡して本体内の引用符を二重化する方法に注目してください。
新規の関数を定義する時ドル引用符の使用が安全とは限らないため、この方法が必要となります。
それは<structfield>referrer_key.key_string</structfield>の領域に、どのような文字列が書き込まれているか不明だからです。
（<structfield>referrer_key.kind</structfield>は常に信用できる<literal>host</literal>か<literal>domain</literal>か<literal>url</literal>であると仮定しますが、どんなものでも<structfield>referrer_key.key_string</structfield>になり得るので、ドル記号を含む可能性があります。）
この関数はOracle版より実際に改善されています。
それは<structfield>referrer_key.key_string</structfield>または<structfield>referrer_key.referrer_type</structfield>が引用符を含む時、おかしなコードを生成しないからです。
    </para>
   </example>

   <para>
<!--
    <xref linkend="plpgsql-porting-ex3"/> shows how to port a function
    with <literal>OUT</literal> parameters and string manipulation.
    <productname>PostgreSQL</productname> does not have a built-in
    <function>instr</function> function, but you can create one
    using a combination of other
    functions. In <xref linkend="plpgsql-porting-appendix"/> there is a
    <application>PL/pgSQL</application> implementation of
    <function>instr</function> that you can use to make your porting
    easier.
-->
<xref linkend="plpgsql-porting-ex3"/>は、<literal>OUT</literal>パラメータを持ち、文字列操作を行う関数の移植方法を示します。
<productname>PostgreSQL</productname>には組み込みの<function>instr</function>関数はありませんが、他の関数を組み合わせることで作成できます。
<xref linkend="plpgsql-porting-appendix"/>に、移植を簡略化できるように<function>instr</function>の<application>PL/pgSQL</application>による実装を示します。
   </para>

   <example id="plpgsql-porting-ex3">
<!--
    <title>Porting a Procedure With String Manipulation and
    <literal>OUT</literal> Parameters from <application>PL/SQL</application> to
    <application>PL/pgSQL</application></title>
-->
<title>文字列操作を行い、<literal>OUT</literal>パラメータを持つ<application>PL/SQL</application>プロシージャの<application>PL/pgSQL</application>への移植</title>

    <para>
<!--
     The following <productname>Oracle</productname> PL/SQL procedure is used
     to parse a URL and return several elements (host, path, and query).
-->
以下の<productname>Oracle</productname> PL/SQLプロシージャは、URLを解析していくつかの要素（ホスト、パス、問い合わせ）を返します。
    </para>

    <para>
<!--
     This is the Oracle version:
-->
以下はOracle版です。
<programlisting>
CREATE OR REPLACE PROCEDURE cs_parse_url(
    v_url IN VARCHAR2,
<!--
    v_host OUT VARCHAR2,  &#045;&#045; This will be passed back
    v_path OUT VARCHAR2,  &#045;&#045; This one too
    v_query OUT VARCHAR2) &#045;&#045; And this one
-->
    v_host OUT VARCHAR2,  -- この値は戻されます
    v_path OUT VARCHAR2,  -- この値も戻されます
    v_query OUT VARCHAR2) -- この値も戻されます
IS
    a_pos1 INTEGER;
    a_pos2 INTEGER;
BEGIN
    v_host := NULL;
    v_path := NULL;
    v_query := NULL;
    a_pos1 := instr(v_url, '//');

    IF a_pos1 = 0 THEN
        RETURN;
    END IF;
    a_pos2 := instr(v_url, '/', a_pos1 + 2);
    IF a_pos2 = 0 THEN
        v_host := substr(v_url, a_pos1 + 2);
        v_path := '/';
        RETURN;
    END IF;

    v_host := substr(v_url, a_pos1 + 2, a_pos2 - a_pos1 - 2);
    a_pos1 := instr(v_url, '?', a_pos2 + 1);

    IF a_pos1 = 0 THEN
        v_path := substr(v_url, a_pos2);
        RETURN;
    END IF;

    v_path := substr(v_url, a_pos2, a_pos1 - a_pos2);
    v_query := substr(v_url, a_pos1 + 1);
END;
/
show errors;
</programlisting>
    </para>

    <para>
<!--
     Here is a possible translation into <application>PL/pgSQL</application>:
-->
<application>PL/pgSQL</application>への可能な変換は以下のようになります。
<programlisting>
CREATE OR REPLACE FUNCTION cs_parse_url(
    v_url IN VARCHAR,
<!--
    v_host OUT VARCHAR,  &#045;&#045; This will be passed back
    v_path OUT VARCHAR,  &#045;&#045; This one too
    v_query OUT VARCHAR) &#045;&#045; And this one
-->
    v_host OUT VARCHAR,  -- この値は戻されます
    v_path OUT VARCHAR,  -- この値も戻されます
    v_query OUT VARCHAR) -- この値も戻されます
AS $$
DECLARE
    a_pos1 INTEGER;
    a_pos2 INTEGER;
BEGIN
    v_host := NULL;
    v_path := NULL;
    v_query := NULL;
    a_pos1 := instr(v_url, '//');

    IF a_pos1 = 0 THEN
        RETURN;
    END IF;
    a_pos2 := instr(v_url, '/', a_pos1 + 2);
    IF a_pos2 = 0 THEN
        v_host := substr(v_url, a_pos1 + 2);
        v_path := '/';
        RETURN;
    END IF;

    v_host := substr(v_url, a_pos1 + 2, a_pos2 - a_pos1 - 2);
    a_pos1 := instr(v_url, '?', a_pos2 + 1);

    IF a_pos1 = 0 THEN
        v_path := substr(v_url, a_pos2);
        RETURN;
    END IF;

    v_path := substr(v_url, a_pos2, a_pos1 - a_pos2);
    v_query := substr(v_url, a_pos1 + 1);
END;
$$ LANGUAGE plpgsql;
</programlisting>

<!--
     This function could be used like this:
-->
この関数は以下のように使用できます。
<programlisting>
SELECT * FROM cs_parse_url('http://foobar.com/query.cgi?baz');
</programlisting>
    </para>
   </example>

   <para>
<!--
    <xref linkend="plpgsql-porting-ex4"/> shows how to port a procedure
    that uses numerous features that are specific to Oracle.
-->
<xref linkend="plpgsql-porting-ex4"/>は、Oracleに特化した多くの機能を使用したプロシージャの移植方法を示します。
   </para>

   <example id="plpgsql-porting-ex4">
<!--
    <title>Porting a Procedure from <application>PL/SQL</application> to <application>PL/pgSQL</application></title>
-->
<title><application>PL/SQL</application>プロシージャの<application>PL/pgSQL</application>への移植</title>

    <para>
<!--
     The Oracle version:
-->
以下はOracle版です。

<programlisting>
CREATE OR REPLACE PROCEDURE cs_create_job(v_job_id IN INTEGER) IS
    a_running_job_count INTEGER;
BEGIN
    LOCK TABLE cs_jobs IN EXCLUSIVE MODE;

    SELECT count(*) INTO a_running_job_count FROM cs_jobs WHERE end_stamp IS NULL;

    IF a_running_job_count &gt; 0 THEN
<!--
        COMMIT; &#045;&#045; free lock
-->
        COMMIT; -- ロックを解放
        raise_application_error(-20000,
                 'Unable to create a new job: a job is currently running.');
    END IF;

    DELETE FROM cs_active_job;
    INSERT INTO cs_active_job(job_id) VALUES (v_job_id);

    BEGIN
        INSERT INTO cs_jobs (job_id, start_stamp) VALUES (v_job_id, now());
    EXCEPTION
<!--
        WHEN dup_val_on_index THEN NULL; &#045;&#045; don't worry if it already exists
-->
        WHEN dup_val_on_index THEN NULL; -- 既存であっても問題なし
    END;
    COMMIT;
END;
/
show errors
</programlisting>
   </para>

   <para>
<!--
    This is how we could port this procedure to <application>PL/pgSQL</application>:
-->
それでは、このプロシージャを<application>PL/pgSQL</application>に移植することができた方法を見てみましょう。

<programlisting>
CREATE OR REPLACE PROCEDURE cs_create_job(v_job_id integer) AS $$
DECLARE
    a_running_job_count integer;
BEGIN
    LOCK TABLE cs_jobs IN EXCLUSIVE MODE;

    SELECT count(*) INTO a_running_job_count FROM cs_jobs WHERE end_stamp IS NULL;

    IF a_running_job_count &gt; 0 THEN
<!--
        COMMIT; &#045;&#045; free lock
-->
        COMMIT; -- ロックを解放
        RAISE EXCEPTION 'Unable to create a new job: a job is currently running'; -- <co id="co.plpgsql-porting-raise"/>
    END IF;

    DELETE FROM cs_active_job;
    INSERT INTO cs_active_job(job_id) VALUES (v_job_id);

    BEGIN
        INSERT INTO cs_jobs (job_id, start_stamp) VALUES (v_job_id, now());
    EXCEPTION
        WHEN unique_violation THEN -- <co id="co.plpgsql-porting-exception"/>
<!--
            &#045;&#045; don't worry if it already exists
-->
            -- 既存であっても問題なし
    END;
    COMMIT;
END;
$$ LANGUAGE plpgsql;
</programlisting>

    <calloutlist>
     <callout arearefs="co.plpgsql-porting-raise">
      <para>
<!--
       The syntax of <literal>RAISE</literal> is considerably different from
       Oracle's statement, although the basic case <literal>RAISE</literal>
       <replaceable class="parameter">exception_name</replaceable> works
       similarly.
-->
基本の<literal>RAISE</literal> <replaceable class="parameter">exception_name</replaceable>である場合は同様に操作できますが、<literal>RAISE</literal>構文はOracleにおける文とかなり異なります。
      </para>
     </callout>
     <callout arearefs="co.plpgsql-porting-exception">
      <para>
<!--
       The exception names supported by <application>PL/pgSQL</application> are
       different from Oracle's.  The set of built-in exception names
       is much larger (see <xref linkend="errcodes-appendix"/>).  There
       is not currently a way to declare user-defined exception names,
       although you can throw user-chosen SQLSTATE values instead.
-->
<application>PL/pgSQL</application>がサポートする例外の名称は、Oracleと異なります。
提供する例外の名称は、はるかに広範囲です（<xref linkend="errcodes-appendix"/>を参照してください）。
今のところ、ユーザ定義の例外名称を宣言できません。
しかし代わりにユーザが選択したSQLSTATE値を返すことができます。
      </para>
     </callout>
    </calloutlist>
   </para>
   </example>
  </sect2>

  <sect2 id="plpgsql-porting-other">
<!--
   <title>Other Things to Watch For</title>
-->
<title>その他の注意事項</title>

   <para>
<!--
    This section explains a few other things to watch for when porting
    Oracle <application>PL/SQL</application> functions to
    <productname>PostgreSQL</productname>.
-->
本節では、Oracle <application>PL/SQL</application>関数の<productname>PostgreSQL</productname>への移植における、その他の注意事項を説明します。
   </para>

   <sect3 id="plpgsql-porting-exceptions">
<!--
    <title>Implicit Rollback after Exceptions</title>
-->
<title>例外後の暗黙的ロールバック</title>

    <para>
<!--
     In <application>PL/pgSQL</application>, when an exception is caught by an
     <literal>EXCEPTION</literal> clause, all database changes since the block's
     <literal>BEGIN</literal> are automatically rolled back.  That is, the behavior
     is equivalent to what you'd get in Oracle with:
-->
<application>PL/pgSQL</application>において<literal>EXCEPTION</literal>句が例外を捕捉すると、<literal>BEGIN</literal>以降のそのブロックにおけるデータベースの変更が自動的にロールバックされます。
すなわち、Oracleで以下のプログラムと同等の処理が実行されます。

<programlisting>
BEGIN
    SAVEPOINT s1;
    ... code here ...
EXCEPTION
    WHEN ... THEN
        ROLLBACK TO s1;
        ... code here ...
    WHEN ... THEN
        ROLLBACK TO s1;
        ... code here ...
END;
</programlisting>

<!--
     If you are translating an Oracle procedure that uses
     <command>SAVEPOINT</command> and <command>ROLLBACK TO</command> in this style,
     your task is easy: just omit the <command>SAVEPOINT</command> and
     <command>ROLLBACK TO</command>.  If you have a procedure that uses
     <command>SAVEPOINT</command> and <command>ROLLBACK TO</command> in a different way
     then some actual thought will be required.
-->
このような方式で<command>SAVEPOINT</command>と<command>ROLLBACK TO</command>を使用したOracleのプロシージャの書き換えは簡単です。
単に<command>SAVEPOINT</command>と<command>ROLLBACK TO</command>の処理を削除すればよいだけです。
これと異なった方式で<command>SAVEPOINT</command>と<command>ROLLBACK TO</command>を使用したプロシージャの時は、それに応じた工夫が必要になると思われます。
    </para>
   </sect3>

   <sect3>
    <title><command>EXECUTE</command></title>

    <para>
<!--
     The <application>PL/pgSQL</application> version of
     <command>EXECUTE</command> works similarly to the
     <application>PL/SQL</application> version, but you have to remember to use
     <function>quote_literal</function> and
     <function>quote_ident</function> as described in <xref
     linkend="plpgsql-statements-executing-dyn"/>.  Constructs of the
     type <literal>EXECUTE 'SELECT * FROM $1';</literal> will not work
     reliably unless you use these functions.
-->
<application>PL/pgSQL</application>の<command>EXECUTE</command>は<application>PL/SQL</application>版とよく似ています。
しかし<xref linkend="plpgsql-statements-executing-dyn"/>で説明されている<function>quote_literal</function>と<function>quote_ident</function>を使うことを覚えておかなければいけません。
これらの関数を使用しない限り<literal>EXECUTE ''SELECT * from $1'';</literal>という構文の動作には、信頼性がありません。
    </para>
   </sect3>

   <sect3 id="plpgsql-porting-optimization">
<!--
    <title>Optimizing <application>PL/pgSQL</application> Functions</title>
-->
<title><application>PL/pgSQL</application>関数の最適化</title>

    <para>
<!--
     <productname>PostgreSQL</productname> gives you two function creation
     modifiers to optimize execution: <quote>volatility</quote> (whether
     the function always returns the same result when given the same
     arguments) and <quote>strictness</quote> (whether the function
     returns null if any argument is null).  Consult the <xref
     linkend="sql-createfunction"/>
     reference page for details.
-->
<productname>PostgreSQL</productname>には実行を最適化するために2つの関数生成修飾子があります。
変動性（同じ引数が与えられた場合常に同じ結果を返します）と<quote>厳密性</quote>（引数のいずれかにNULLが含まれる場合NULLを返します）です。
詳細は<xref linkend="sql-createfunction"/>を参照してください。
    </para>

    <para>
<!--
     When making use of these optimization attributes, your
     <command>CREATE FUNCTION</command> statement might look something
     like this:
-->
これらの最適化属性を利用するためには、<command>CREATE FUNCTION</command>文を以下のようにします。

<programlisting>
CREATE FUNCTION foo(...) RETURNS integer AS $$
...
$$ LANGUAGE plpgsql STRICT IMMUTABLE;
</programlisting>
    </para>
   </sect3>
  </sect2>

  <sect2 id="plpgsql-porting-appendix">
<!--
   <title>Appendix</title>
-->
<title>付録</title>

   <para>
<!--
    This section contains the code for a set of Oracle-compatible
    <function>instr</function> functions that you can use to simplify
    your porting efforts.
-->
本節には、移植作業を簡略化するために使用できる、Oracle互換の<function>instr</function>関数のコードがあります。
   </para>

   <indexterm>
<!--
    <primary><function>instr</function> function</primary>
-->
    <primary><function>instr</function>関数</primary>
   </indexterm>

<programlisting><![CDATA[
--]]><!--
&#045;&#045; instr functions that mimic Oracle's counterpart
&#045;&#045; Syntax: instr(string1, string2 [, n [, m]])
&#045;&#045; where [] denotes optional parameters.
--><![CDATA[
-- Oracleのものと同じ動作をするinstr関数
-- 構文: instr(string1, string2 [, n [, m]]) ただし、[]は省略可能なパラメータ
--]]><!--
&#045;&#045; Search string1, beginning at the nth character, for the mth occurrence
&#045;&#045; of string2.  If n is negative, search backwards, starting at the abs(n)'th
&#045;&#045; character from the end of string1.
&#045;&#045; If n is not passed, assume 1 (search starts at first character).
&#045;&#045; If m is not passed, assume 1 (find first occurrence).
&#045;&#045; Returns starting index of string2 in string1, or 0 if string2 is not found.
--><![CDATA[
-- string1内のn番目の文字から始めて、m番目のstring2を探します。
-- nが負の場合、string1の終わりからabs(n)番目の文字から始めて、逆方向に検索します。
-- nが渡されなかった場合は、1とみなします（最初の文字から探し始めます）。
-- mが渡されなかった場合は、1とみなします（最初に一致するものを見つけます）。
-- string1内のstring2の開始位置を、string2が見つからなければ0を返します。
--

CREATE FUNCTION instr(varchar, varchar) RETURNS integer AS $$
BEGIN
    RETURN instr($1, $2, 1);
END;
$$ LANGUAGE plpgsql STRICT IMMUTABLE;


CREATE FUNCTION instr(string varchar, string_to_search_for varchar,
                      beg_index integer)
RETURNS integer AS $$
DECLARE
    pos integer NOT NULL DEFAULT 0;
    temp_str varchar;
    beg integer;
    length integer;
    ss_length integer;
BEGIN
    IF beg_index > 0 THEN
        temp_str := substring(string FROM beg_index);
        pos := position(string_to_search_for IN temp_str);

        IF pos = 0 THEN
            RETURN 0;
        ELSE
            RETURN pos + beg_index - 1;
        END IF;
    ELSIF beg_index < 0 THEN
        ss_length := char_length(string_to_search_for);
        length := char_length(string);
        beg := length + 1 + beg_index;

        WHILE beg > 0 LOOP
            temp_str := substring(string FROM beg FOR ss_length);
            IF string_to_search_for = temp_str THEN
                RETURN beg;
            END IF;

            beg := beg - 1;
        END LOOP;

        RETURN 0;
    ELSE
        RETURN 0;
    END IF;
END;
$$ LANGUAGE plpgsql STRICT IMMUTABLE;


CREATE FUNCTION instr(string varchar, string_to_search_for varchar,
                      beg_index integer, occur_index integer)
RETURNS integer AS $$
DECLARE
    pos integer NOT NULL DEFAULT 0;
    occur_number integer NOT NULL DEFAULT 0;
    temp_str varchar;
    beg integer;
    i integer;
    length integer;
    ss_length integer;
BEGIN
    IF occur_index <= 0 THEN
        RAISE 'argument ''%'' is out of range', occur_index
          USING ERRCODE = '22003';
    END IF;

    IF beg_index > 0 THEN
        beg := beg_index - 1;
        FOR i IN 1..occur_index LOOP
            temp_str := substring(string FROM beg + 1);
            pos := position(string_to_search_for IN temp_str);
            IF pos = 0 THEN
                RETURN 0;
            END IF;
            beg := beg + pos;
        END LOOP;

        RETURN beg;
    ELSIF beg_index < 0 THEN
        ss_length := char_length(string_to_search_for);
        length := char_length(string);
        beg := length + 1 + beg_index;

        WHILE beg > 0 LOOP
            temp_str := substring(string FROM beg FOR ss_length);
            IF string_to_search_for = temp_str THEN
                occur_number := occur_number + 1;
                IF occur_number = occur_index THEN
                    RETURN beg;
                END IF;
            END IF;

            beg := beg - 1;
        END LOOP;

        RETURN 0;
    ELSE
        RETURN 0;
    END IF;
END;
$$ LANGUAGE plpgsql STRICT IMMUTABLE;
]]>
</programlisting>
  </sect2>

 </sect1>

</chapter>
