<!-- doc/src/sgml/user-manag.sgml -->

<chapter id="user-manag">
<!--
 <title>Database Roles</title>
-->
<title>データベースロール</title>

 <para>
<!--
  <productname>PostgreSQL</productname> manages database access permissions
  using the concept of <firstterm>roles</>.  A role can be thought of as
  either a database user, or a group of database users, depending on how
  the role is set up.  Roles can own database objects (for example,
  tables) and can assign privileges on those objects to other roles to
  control who has access to which objects.  Furthermore, it is possible
  to grant <firstterm>membership</> in a role to another role, thus
  allowing the member role to use privileges assigned to another role.
-->
<productname>PostgreSQL</productname>は、<firstterm>ロール</>という概念を使用してデータベースへの接続承認を管理します。
ロールは、その設定方法に応じて、データベースユーザ、またはデータベースユーザのグループとみなすことができます。
ロールはデータベースオブジェクト（例えばテーブル）を所有することができます。
またロールは、どのオブジェクトに誰がアクセスできるかを制御するために、それらのオブジェクトに対しての権限を他のロールに割り当てることができます。
更に、ロールの<firstterm>メンバ資格</>を他のロールに与えることもできます。
そのため、メンバとなったロールは別のロールに割り当てられた権限を使用することができます。
 </para>

 <para>
<!--
  The concept of roles subsumes the concepts of <quote>users</> and
  <quote>groups</>.  In <productname>PostgreSQL</productname> versions
  before 8.1, users and groups were distinct kinds of entities, but now
  there are only roles.  Any role can act as a user, a group, or both.
-->
ロールの概念には、<quote>ユーザ</>という概念と<quote>グループ</>という概念が含まれます。
<productname>PostgreSQL</productname>バージョン8.1より前まででは、ユーザとグループは異なる種類の実体として扱われていました。
しかし、現在ではロールしか存在しません。
すべてのロールは、ユーザとして、グループとして、またはその両方として動作することができます。
 </para>

 <para>
<!--
  This chapter describes how to create and manage roles.
  More information about the effects of role privileges on various
  database objects can be found in <xref linkend="ddl-priv">.
-->
本章では、ロールの作成と管理の方法について説明します。
様々なデータベースオブジェクト上の権限の効果について、さらに詳細な情報は<xref linkend="ddl-priv">に記載されています。
 </para>

 <sect1 id="database-roles">
<!--
  <title>Database Roles</title>
-->
<title>データベースロール</title>

  <indexterm zone="database-roles">
<!--
   <primary>role</primary>
-->
   <primary>ロール</primary>
  </indexterm>

  <indexterm zone="database-roles">
<!--
   <primary>user</primary>
-->
   <primary>ユーザ</primary>
  </indexterm>

  <indexterm>
   <primary>CREATE ROLE</primary>
  </indexterm>

  <indexterm>
   <primary>DROP ROLE</primary>
  </indexterm>

  <para>
<!--
   Database roles are conceptually completely separate from
   operating system users. In practice it might be convenient to
   maintain a correspondence, but this is not required. Database roles
   are global across a database cluster installation (and not
   per individual database). To create a role use the <xref
   linkend="sql-createrole"> SQL command:
-->
データベースロールは概念的に、オペレーティングシステムユーザとは完全に分離されています。
実行する上でユーザ名を一致させておくと便利ですが、必須ではありません。
データベースロール名はデータベースクラスタインストレーション全体で共通です
（個別のデータベースごとではありません）。
ユーザを作成するためには<xref linkend="sql-createrole"> SQLコマンドを使います。
<synopsis>
CREATE ROLE <replaceable>name</replaceable>;
</synopsis>
<!--
   <replaceable>name</replaceable> follows the rules for SQL
   identifiers: either unadorned without special characters, or
   double-quoted.  (In practice, you will usually want to add additional
   options, such as <literal>LOGIN</>, to the command.  More details appear
   below.)  To remove an existing role, use the analogous
   <xref linkend="sql-droprole"> command:
-->
<replaceable>name</replaceable>はSQL識別子の規則に従います。
特殊な文字を持たない無装飾のものか、二重引用符に囲まれたもののどちらかです。
（現実的には、通常他のオプション、例えば<literal>LOGIN</>などをこのコマンドに付与することになるでしょう。
詳細は後で説明します。）
既存のユーザを削除するためには類似のコマンド<xref linkend="sql-droprole">を使用してください。
<synopsis>
DROP ROLE <replaceable>name</replaceable>;
</synopsis>
  </para>

  <indexterm>
   <primary>createuser</primary>
  </indexterm>

  <indexterm>
   <primary>dropuser</primary>
  </indexterm>

  <para>
<!--
   For convenience, the programs <xref linkend="app-createuser">
   and <xref linkend="app-dropuser"> are provided as wrappers
   around these SQL commands that can be called from the shell command
   line:
-->
利便性のために、これらのSQLコマンドのラッパである、シェルのコマンドラインから呼び出し可能な<xref linkend="app-createuser">プログラムと<xref linkend="app-dropuser">プログラムが提供されています。
<synopsis>
createuser <replaceable>name</replaceable>
dropuser <replaceable>name</replaceable>
</synopsis>
  </para>

  <para>
<!--
   To determine the set of existing roles, examine the <structname>pg_roles</>
   system catalog, for example
-->
既存のロール群を求めるためには、以下のように<structname>pg_roles</>システムカタログを確認してください。
<synopsis>
SELECT rolname FROM pg_roles;
</synopsis>
<!--
   The <xref linkend="app-psql"> program's <literal>\du</> meta-command
   is also useful for listing the existing roles.
-->
また、<xref linkend="app-psql">プログラムの<literal>\du</>メタコマンドも既存のロールを列挙する際に役に立ちます。
  </para>

  <para>
<!--
   In order to bootstrap the database system, a freshly initialized
   system always contains one predefined role. This role is always
   a <quote>superuser</>, and by default (unless altered when running
   <command>initdb</command>) it will have the same name as the
   operating system user that initialized the database
   cluster. Customarily, this role will be named
   <literal>postgres</literal>. In order to create more roles you
   first have to connect as this initial role.
-->
データベースシステム自身を起動するために、初期化されたばかりのシステムは常に定義済みのロールを1つ持ちます。
このロールは必ず<quote>スーパーユーザ</>であり、デフォルトでは（<command>initdb</command>実行時に変更しない限り）そのデータベースクラスタを初期化したオペレーティングシステムユーザと同じ名前となります。
習慣的にこのロールは<systemitem>postgres</systemitem>と名付けられます。
ロールを追加する場合はまずこの初期ロールで接続しなければいけません。
  </para>

  <para>
<!--
   Every connection to the database server is made using the name of some
   particular role, and this role determines the initial access privileges for
   commands issued in that connection.
   The role name to use for a particular database
   connection is indicated by the client that is initiating the
   connection request in an application-specific fashion. For example,
   the <command>psql</command> program uses the
   <option>-U</option> command line option to indicate the role to
   connect as.  Many applications assume the name of the current
   operating system user by default (including
   <command>createuser</> and <command>psql</>).  Therefore it
   is often convenient to maintain a naming correspondence between
   roles and operating system users.
-->
すべてのデータベースサーバへの接続は、特定のロールの名前を使用して確立し、そのロールによりその接続で発行されるコマンドの初期のアクセス権限が決まります。
特定のデータベース接続に使うロールは、アプリケーション固有の方式で接続要求を開始するクライアントによって指示されます。
例えば、<command>psql</command>プログラムでは、<option>-U</option>コマンドラインオプションを使って接続するロールを指示します。
多くのアプリケーション（<command>createuser</>および<command>psql</>を含む）では、オペレーティングシステムの現在のユーザ名をデフォルトと想定します。
したがって、ロールとオペレーティングシステムのユーザの組み合わせ間で名前を一致させておくと便利です。
  </para>

  <para>
<!--
   The set of database roles a given client connection can connect as
   is determined by the client authentication setup, as explained in
   <xref linkend="client-authentication">. (Thus, a client is not
   limited to connect as the role matching
   its operating system user, just as a person's login name
   need not match her real name.)  Since the role
   identity determines the set of privileges available to a connected
   client, it is important to carefully configure privileges when setting up
   a multiuser environment.
-->
<xref linkend="client-authentication">で説明されているように、あるクライアント接続で与えられたデータベースロールの集合は、クライアント認証設定で決定された内容で接続できます。
（したがって、ユーザのログイン名が本名と一致していなくても構わないのと同様に、クライアントはオペレーティングシステムのユーザ名と同じロール名で接続しなくても構いません）。
接続したクライアントに付与される権限の内容はロールIDによって決定されるため、マルチユーザ環境を設定する際には権限を注意深く設定することが重要です。
  </para>
 </sect1>

 <sect1 id="role-attributes">
<!--
  <title>Role Attributes</title>
-->
<title>ロールの属性</title>

   <para>
<!--
    A database role can have a number of attributes that define its
    privileges and interact with the client authentication system.
-->
データベースロールは、権限を定義し、クライアント認証システムと相互作用する数多くの属性を持つことができます。

    <variablelist>
     <varlistentry>
<!--
      <term>login privilege<indexterm><primary>login privilege</></></term>
-->
      <term>ログイン権限<indexterm><primary>ログイン権限</></></term>
      <listitem>
       <para>
<!--
        Only roles that have the <literal>LOGIN</> attribute can be used
        as the initial role name for a database connection.  A role with
        the <literal>LOGIN</> attribute can be considered the same
        as a <quote>database user</>.  To create a role with login privilege,
        use either:
-->
<literal>LOGIN</>属性を持つロールのみがデータベース接続の初期ロール名として使用できます。
<literal>LOGIN</> 属性を持つロールは<quote>データベースユーザ</>と同じであるとみなすことができます。
ログイン権限を持つロールの作成方法は、以下のいずれかです。
<programlisting>
CREATE ROLE <replaceable>name</replaceable> LOGIN;
CREATE USER <replaceable>name</replaceable>;
</programlisting>
<!--
        (<command>CREATE USER</> is equivalent to <command>CREATE ROLE</>
        except that <command>CREATE USER</> assumes <literal>LOGIN</> by
        default, while <command>CREATE ROLE</> does not.)
-->
（<command>CREATE USER</>はデフォルトで <literal>LOGIN</>を持ち、<command>CREATE ROLE</>は持たないという点を除き、<command>CREATE USER</>は<command>CREATE ROLE</>と同じです。）
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--
      <term>superuser status<indexterm><primary>superuser</></></term>
-->
      <term>スーパーユーザ状態<indexterm><primary>スーパーユーザ</></></term>
      <listitem>
       <para>
<!--
        A database superuser bypasses all permission checks, except the right
        to log in.  This is a dangerous privilege and should not be used
        carelessly; it is best to do most of your work as a role that is not a
        superuser.  To create a new database superuser, use <literal>CREATE
        ROLE <replaceable>name</replaceable> SUPERUSER</literal>.  You must do
        this as a role that is already a superuser.
-->
ログイン権限を除き、データベーススーパーユーザに対する権限検査は全て行われません。
これは危険な権限ですので、安易に使用してはいけません。
作業のほとんどを非スーパーユーザのロールで行うことが最善です。
新しいデータベーススーパーユーザを作成するには、<literal>CREATE ROLE <replaceable>name</replaceable> SUPERUSER</literal>を使用してください。
これはスーパーユーザのロールで実行しなければなりません。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--
      <term>database creation<indexterm><primary>database</><secondary>privilege to create</></></term>
-->
      <term>データベース作成<indexterm><primary>データベース</><secondary>を作成する権限</></></term>
      <listitem>
       <para>
<!--
        A role must be explicitly given permission to create databases
        (except for superusers, since those bypass all permission
        checks). To create such a role, use <literal>CREATE ROLE
        <replaceable>name</replaceable> CREATEDB</literal>.
-->
（全ての権限検査が行われないスーパーユーザを除き）ロールに明示的にデータベースを作成するための権限を指定しておかねばいけません。
そのようなロールを作るためには<literal>CREATE ROLE <replaceable>name</replaceable> CREATEDB</literal>を使用してください。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--
      <term>role creation<indexterm><primary>role</><secondary>privilege to create</></></term>
-->
      <term>ロールの作成<indexterm><primary>ロール</><secondary>を作成する権限</></></term>
      <listitem>
       <para>
<!--
        A role must be explicitly given permission to create more roles
        (except for superusers, since those bypass all permission
        checks). To create such a role, use <literal>CREATE ROLE
        <replaceable>name</replaceable> CREATEROLE</literal>.
        A role with <literal>CREATEROLE</> privilege can alter and drop
        other roles, too, as well as grant or revoke membership in them.
        However, to create, alter, drop, or change membership of a
        superuser role, superuser status is required;
        <literal>CREATEROLE</> is insufficient for that.
-->
あるロールがロールを作成するには、明示的な権限が付与されていなければなりません。
（スーパーユーザは、すべての権限検査を迂回しますので、例外です。）
こうしたロールを作成するには、<literal>CREATE ROLE <replaceable>name</replaceable> CREATEROLE</literal>を使用してください。
<literal>CREATEROLE</>権限を持つロールは他のロールを変更したり削除したりすることもできます。
また、他のロールのメンバ資格を付与したり取り上げたりすることもできます。
しかし、スーパーユーザロールの変更、削除、メンバ資格の変更を行うにはスーパーユーザ状態が必要です。
<literal>CREATEROLE</>だけでは不足しています。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--
      <term>initiating replication<indexterm><primary>role</><secondary>privilege to initiate replication</></></term>
-->
      <term>レプリケーションの新規接続<indexterm><primary>ロール</><secondary>レプリケーションの新規接続を行う権限</></></term>
      <listitem>
       <para>
<!--
        A role must explicitly be given permission to initiate streaming
        replication (except for superusers, since those bypass all permission
        checks). A role used for streaming replication must always
        have <literal>LOGIN</> permission as well. To create such a role, use
        <literal>CREATE ROLE <replaceable>name</replaceable> REPLICATION
        LOGIN</literal>.
-->
あるロールがストリーミングレプリケーションの新規接続を実施するには、明示的な権限が付与されていなければなりません。
（スーパーユーザは、すべての権限検査を迂回しますので、例外です。）
ストリーミングレプリケーションを行うロールは、常に<literal>LOGIN</>権限も持っていることが必要です。
こうしたロールを作成するには、<literal>CREATE ROLE <replaceable>name</replaceable> REPLICATION LOGIN</literal>を使用してください。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--
      <term>password<indexterm><primary>password</></></term>
-->
      <term>パスワード<indexterm><primary>パスワード</></></term>
      <listitem>
       <para>
<!--
        A password is only significant if the client authentication
        method requires the user to supply a password when connecting
        to the database. The <option>password</> and
        <option>md5</> authentication methods
        make use of passwords. Database passwords are separate from
        operating system passwords. Specify a password upon role
        creation with <literal>CREATE ROLE
        <replaceable>name</replaceable> PASSWORD '<replaceable>string</>'</literal>.
-->
パスワードは、クライアント認証方法においてデータベースに接続する際にユーザにパスワードを要求する場合にのみ重要になります。 
<option>password</>と<option>md5</>認証方式でパスワードが使用されます。
データベースパスワードはオペレーティングシステムのパスワードとは異なります。
ロール作成時に<literal>CREATE ROLE <replaceable>name</replaceable> PASSWORD 'string'</literal>のようにパスワードを指定します。 
       </para>
      </listitem>
     </varlistentry>
    </variablelist>

<!--
    A role's attributes can be modified after creation with
    <command>ALTER ROLE</command>.<indexterm><primary>ALTER ROLE</></>
    See the reference pages for the <xref linkend="sql-createrole">
    and <xref linkend="sql-alterrole"> commands for details.
-->
ロール属性は、ロールを作成した後でも<command>ALTER ROLE</command><indexterm><primary>ALTER ROLE</></>コマンドで変更できます。
詳細は<xref linkend="sql-createrole">と<xref linkend="sql-alterrole">のマニュアルページを参照してください。
   </para>

  <tip>
   <para>
<!--
    It is good practice to create a role that has the <literal>CREATEDB</>
    and <literal>CREATEROLE</> privileges, but is not a superuser, and then
    use this role for all routine management of databases and roles.  This
    approach avoids the dangers of operating as a superuser for tasks that
    do not really require it.
-->
スーパーユーザ以外に<literal>CREATEDB</>権限と<literal>CREATEROLE</>権限を持つロールを作成することを勧めます。
そして、このロールを使用して、データベースとロールを管理するためのすべての処理を行ってください。
この方法によって、実際には不要な処理をスーパーユーザとして行う危険性を避けることができます。
   </para>
  </tip>

  <para>
<!--
   A role can also have role-specific defaults for many of the run-time
   configuration settings described in <xref
   linkend="runtime-config">.  For example, if for some reason you
   want to disable index scans (hint: not a good idea) anytime you
   connect, you can use:
-->
ロールは、<xref linkend="runtime-config">で説明されている実行時の設定の多くをロールごとのデフォルトに設定することもできます。  
例えば何らかの理由で、自分が接続する時は常にインデックススキャンを無効にしたい場合（注:お勧めしません）、次のようにします。
<programlisting>
ALTER ROLE myname SET enable_indexscan TO off;
</programlisting>
<!--
   This will save the setting (but not set it immediately).  In
   subsequent connections by this role it will appear as though
   <literal>SET enable_indexscan TO off</literal> had been executed
   just before the session started.
   You can still alter this setting during the session; it will only
   be the default. To remove a role-specific default setting, use
   <literal>ALTER ROLE <replaceable>rolename</> RESET <replaceable>varname</></literal>.
   Note that role-specific defaults attached to roles without
   <literal>LOGIN</> privilege are fairly useless, since they will never
   be invoked.
-->
このようにして設定を保存します（ただし、すぐに反映はされません）。
以降のこのロールによる接続においては、セッションの開始の直前に<literal>SET enable_indexscan TO off;</literal>が呼び出されたのと同様になります。
これはデフォルトとする設定をするだけなので、設定をセッション途中いつでも変更できます。
ロール固有のデフォルト設定を削除するには、<literal>ALTER ROLE <replaceable>rolename</> RESET <replaceable>varname</></literal>を使用してください。
呼び出されることがありませんので、<literal>LOGIN</>権限を持たないロールにロール固有のデフォルトを持たせることに意味がないことに注意してください。
  </para>
 </sect1>

 <sect1 id="role-membership">
<!--
  <title>Role Membership</title>
-->
<title>ロールのメンバ資格</title>

  <indexterm zone="role-membership">
<!--
   <primary>role</><secondary>membership in</>
-->
   <primary>ロール</><secondary>内のメンバ資格</>
  </indexterm>

  <para>
<!--
   It is frequently convenient to group users together to ease
   management of privileges: that way, privileges can be granted to, or
   revoked from, a group as a whole.  In <productname>PostgreSQL</productname>
   this is done by creating a role that represents the group, and then
   granting <firstterm>membership</> in the group role to individual user
   roles.
-->
権限の管理を簡単にするために、ユーザをグループにまとめることはしばしば便利です。
グループ全体に対して権限を与えることも、取り消すこともできます。
<productname>PostgreSQL</productname>では、グループを表すロールを作成することで行われます。
そして、そのグループロールに個々のユーザロールの<firstterm>メンバ資格</>を与えます。
  </para>

  <para>
<!--
   To set up a group role, first create the role:
-->
グループロールを設定するには、まずロールを作成します。
<synopsis>
CREATE ROLE <replaceable>name</replaceable>;
</synopsis>
<!--
   Typically a role being used as a group would not have the <literal>LOGIN</>
   attribute, though you can set it if you wish.
-->
通常、グループとして使用されるロールには<literal>LOGIN</>属性を持たせません。
しかし、そうしたければ持たせることもできます。
  </para>

  <para>
<!--
   Once the group role exists, you can add and remove members using the
   <xref linkend="sql-grant"> and
   <xref linkend="sql-revoke"> commands:
-->
グループロールをいったん作成すれば、<xref linkend="sql-grant">および<xref linkend="sql-revoke">コマンドを使用してメンバの追加と削除を行うことができます。
<synopsis>
GRANT <replaceable>group_role</replaceable> TO <replaceable>role1</replaceable>, ... ;
REVOKE <replaceable>group_role</replaceable> FROM <replaceable>role1</replaceable>, ... ;
</synopsis>
<!--
   You can grant membership to other group roles, too (since there isn't
   really any distinction between group roles and non-group roles).  The
   database will not let you set up circular membership loops.  Also,
   it is not permitted to grant membership in a role to
   <literal>PUBLIC</literal>.
-->
他のグループロールへのメンバ資格を与えることもできます。
（グループロールと非グループロールとの間には実際には区別がないからです。）
データベースはグループのメンバ資格がループし、循環するような設定はさせません。
また、ロール内のメンバ資格を<literal>PUBLIC</literal>に付与することはできません。
  </para>

  <para>
<!--
   The members of a group role can use the privileges of the role in two
   ways.  First, every member of a group can explicitly do
   <xref linkend="sql-set-role"> to
   temporarily <quote>become</> the group role.  In this state, the
   database session has access to the privileges of the group role rather
   than the original login role, and any database objects created are
   considered owned by the group role not the login role.  Second, member
   roles that have the <literal>INHERIT</> attribute automatically have use
   of the privileges of roles of which they are members, including any
   privileges inherited by those roles.
   As an example, suppose we have done:
-->
グループロールのメンバは、2つの方法でロールの権限を使用することができます。
1つ目は、グループ内のすべてのメンバは明示的に、一時的にそのグループロールに<quote>なる</>ために<xref linkend="sql-set-role">を行うことができます。
この状態では、データベースセッションは元々のログインロールの権限ではなくグループの権限でアクセスされます。
そして、作成されたデータベースオブジェクトの所有者はログインロールではなくグループロールであるとみなされます。
2つ目は、<literal>INHERIT</>属性を持つメンバロールは、それらがメンバとなるロールの権限を自動的に使用します。これには、ロールによって継承されるいかなる権限も含んでいます。
例えば、以下の状態を想定します。
<programlisting>
CREATE ROLE joe LOGIN INHERIT;
CREATE ROLE admin NOINHERIT;
CREATE ROLE wheel NOINHERIT;
GRANT admin TO joe;
GRANT wheel TO admin;
</programlisting>
<!--
   Immediately after connecting as role <literal>joe</>, a database
   session will have use of privileges granted directly to <literal>joe</>
   plus any privileges granted to <literal>admin</>, because <literal>joe</>
   <quote>inherits</> <literal>admin</>'s privileges.  However, privileges
   granted to <literal>wheel</> are not available, because even though
   <literal>joe</> is indirectly a member of <literal>wheel</>, the
   membership is via <literal>admin</> which has the <literal>NOINHERIT</>
   attribute.  After:
-->
<literal>joe</>ロールで接続するとすぐに、<literal>joe</>は<literal>admin</>権限を<quote>継承</>しますので、そのデータベースセッションでは<literal>joe</>に直接与えられた権限に加えて、<literal>admin</>に与えられた権限を使用することができます。
しかし、<literal>wheel</>に与えられた権限は利用できません。
<literal>joe</>は間接的に<literal>wheel</>のメンバですが、<literal>admin</>経由のメンバ資格は<literal>NOINHERIT</>属性を持っているためです。
<programlisting>
SET ROLE admin;
</programlisting>
<!--
   the session would have use of only those privileges granted to
   <literal>admin</>, and not those granted to <literal>joe</>.  After:
-->
を行った後、セッションは<literal>admin</>に与えられた権限のみを使用できるようになります。
<literal>joe</>に与えられた権限は使用できなくなります。
<programlisting>
SET ROLE wheel;
</programlisting>
<!--
   the session would have use of only those privileges granted to
   <literal>wheel</>, and not those granted to either <literal>joe</>
   or <literal>admin</>.  The original privilege state can be restored
   with any of:
-->
を行った後、セッションは<literal>wheel</>に与えられた権限のみを使用できるようになり、<literal>joe</>や<literal>admin</>に与えられた権限は使用できなくなります。
元の状態の権限に戻すには、以下のいずれかを行います。
<programlisting>
SET ROLE joe;
SET ROLE NONE;
RESET ROLE;
</programlisting>
  </para>

  <note>
   <para>
<!--
    The <command>SET ROLE</> command always allows selecting any role
    that the original login role is directly or indirectly a member of.
    Thus, in the above example, it is not necessary to become
    <literal>admin</> before becoming <literal>wheel</>.
-->
<command>SET ROLE</>コマンドによりいつでも、元のログインロールが直接あるいは間接的にメンバ資格を持つすべてのロールを選ぶことができます。
従って、上の例において、<literal>wheel</>になる前に<literal>admin</>になることは必要ありません。
   </para>
  </note>

  <note>
   <para>
<!--
    In the SQL standard, there is a clear distinction between users and roles,
    and users do not automatically inherit privileges while roles do.  This
    behavior can be obtained in <productname>PostgreSQL</productname> by giving
    roles being used as SQL roles the <literal>INHERIT</> attribute, while
    giving roles being used as SQL users the <literal>NOINHERIT</> attribute.
    However, <productname>PostgreSQL</productname> defaults to giving all roles
    the <literal>INHERIT</> attribute, for backward compatibility with pre-8.1
    releases in which users always had use of permissions granted to groups
    they were members of.
-->
標準SQLでは、ユーザとロールとの間に明確な違いがあり、ユーザはロールのように自動的に権限を継承することができません。
<productname>PostgreSQL</productname>でこの振舞いを実現させるには、SQLロールとして使用するロールには<literal>INHERIT</>属性を付与し、SQLユーザとして使用するロールには<literal>NOINHERIT</>属性を付与します。
しかし、8.1リリースより前との互換性を保持するために、<productname>PostgreSQL</productname>はデフォルトで、すべてのロールに<literal>INHERIT</>属性を付与します。
以前は、ユーザは常にメンバとして属するグループに付与された権限を常に使用できました。
   </para>
  </note>

  <para>
<!--
   The role attributes <literal>LOGIN</>, <literal>SUPERUSER</>,
   <literal>CREATEDB</>, and <literal>CREATEROLE</> can be thought of as
   special privileges, but they are never inherited as ordinary privileges
   on database objects are.  You must actually <command>SET ROLE</> to a
   specific role having one of these attributes in order to make use of
   the attribute.  Continuing the above example, we might choose to
   grant <literal>CREATEDB</> and <literal>CREATEROLE</> to the
   <literal>admin</> role.  Then a session connecting as role <literal>joe</>
   would not have these privileges immediately, only after doing
   <command>SET ROLE admin</>.
-->
<literal>LOGIN</>、<literal>SUPERUSER</>、<literal>CREATEDB</>、および<literal>CREATEROLE</>ロール属性は、特別な権限とみなすことができますが、データベースオブジェクトに対する通常の権限のように継承されません。
こうした属性の1つを使用できるようにするためには、その属性を特定のロールに設定するように実際に<command>SET ROLE</>を行う必要があります。
上の例を続けると、<literal>admin</>ロールに<literal>CREATEDB</>権限と<literal>CREATEROLE</>権限を付与することを選ぶことができます。
こうすると、<literal>joe</>ロールとして接続するセッションでは、すぐさまこれらの権限を持ちません。
<command>SET ROLE admin</>を行った後で、この権限を持ちます。
  </para>

  <para>
  </para>

  <para>
<!--
   To destroy a group role, use <xref
   linkend="sql-droprole">:
-->
グループロールを削除するには、<xref linkend="sql-droprole">を使用してください。
<synopsis>
DROP ROLE <replaceable>name</replaceable>;
</synopsis>
<!--
   Any memberships in the group role are automatically revoked (but the
   member roles are not otherwise affected).  Note however that any objects
   owned by the group role must first be dropped or reassigned to other
   owners; and any permissions granted to the group role must be revoked.
-->
グループロール内のメンバ資格も自動的に取り上げられます。
（しかし、メンバロールには何も影響ありません。）
しかし、先にグループロールが所有するオブジェクトをすべて削除しておくか所有者を変更しておく必要があり、また、グループに付与された権限もすべて取り上げられることに注意してください。
  </para>
 </sect1>

 <sect1 id="perm-functions">
<!--
  <title>Function and Trigger Security</title>
-->
<title>関数とトリガのセキュリティ</title>

  <para>
<!--
   Functions and triggers allow users to insert code into the backend
   server that other users might execute unintentionally. Hence, both
   mechanisms permit users to <quote>Trojan horse</quote>
   others with relative ease. The only real protection is tight
   control over who can define functions.
-->
関数とトリガによって、ユーザは他のユーザが意識しないで実行できるようなコードを、バックエンドサーバに挿入することができます。
したがって、両機能によってユーザは比較的簡単に他のユーザにとって<quote>トロイの木馬</quote>となるものを実行することができます。
唯一の現実的保護は、誰が関数やトリガを定義できるかを厳格に管理することです。
  </para>

  <para>
<!--
   Functions run inside the backend
   server process with the operating system permissions of the
   database server daemon.  If the programming language
   used for the function allows unchecked memory accesses, it is
   possible to change the server's internal data structures.
   Hence, among many other things, such functions can circumvent any
   system access controls.  Function languages that allow such access
   are considered <quote>untrusted</>, and
   <productname>PostgreSQL</productname> allows only superusers to
   create functions written in those languages.
-->
関数は、データベースサーバデーモンのオペレーティングシステム権限で、バックエンドサーバプロセスの中で実行されます。
プログラミング言語で関数に未検査のメモリアクセスを許可している場合、サーバの内部データ構造を変更することが可能です。
したがって、その他の多数のことの中でも、そのような関数はどのようなシステムアクセスコントロールも回避することができます。
このようなアクセスを許可する関数言語は<quote>信頼されない</>ものとみなされ、<productname>PostgreSQL</productname>はこれらの言語による関数の作成をスーパーユーザのみに限定して許可しています。
  </para>
 </sect1>

</chapter>
