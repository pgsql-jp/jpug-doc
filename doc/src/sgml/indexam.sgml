<!-- doc/src/sgml/indexam.sgml -->

<chapter id="indexam">
<!--
 <title>Index Access Method Interface Definition</title>
-->
 <title>インデックスアクセスメソッドのインタフェース定義</title>

 <indexterm>
<!--
  <primary>Index Access Method</primary>
-->
  <primary>インデックスアクセスメソッド</primary>
 </indexterm>
 <indexterm>
  <primary>indexam</primary>
<!--
  <secondary>Index Access Method</secondary>
-->
  <secondary>インデックスアクセスメソッド</secondary>
 </indexterm>

  <para>
<!--
   This chapter defines the interface between the core
   <productname>PostgreSQL</productname> system and <firstterm>index access
   methods</firstterm>, which manage individual index types.  The core system
   knows nothing about indexes beyond what is specified here, so it is
   possible to develop entirely new index types by writing add-on code.
-->
本章は、<productname>PostgreSQL</productname>のコアシステムと個々のインデックス種類を管理する<firstterm>インデックスアクセスメソッド</firstterm>との間のインタフェースを定義します。
コアシステムはインデックスの仕様のみを把握しています。
したがって、追加コードを記述することで完全に新しいインデックス種類を開発することができます。
  </para>

  <para>
<!--
   All indexes in <productname>PostgreSQL</productname> are what are known
   technically as <firstterm>secondary indexes</firstterm>; that is, the index is
   physically separate from the table file that it describes.  Each index
   is stored as its own physical <firstterm>relation</firstterm> and so is described
   by an entry in the <structname>pg_class</structname> catalog.  The contents of an
   index are entirely under the control of its index access method.  In
   practice, all index access methods divide indexes into standard-size
   pages so that they can use the regular storage manager and buffer manager
   to access the index contents.  (All the existing index access methods
   furthermore use the standard page layout described in <xref
   linkend="storage-page-layout"/>, and most use the same format for index
   tuple headers; but these decisions are not forced on an access method.)
-->
<productname>PostgreSQL</productname>のインデックスはすべて、技術的には<firstterm>補助的なインデックス</firstterm>として知られるものです。
つまり、インデックスは対象となるテーブルファイルとは物理的に分かれています。
各インデックスは独自の物理的な<firstterm>リレーション</firstterm>として格納され、また、<structname>pg_class</structname>カタログ内の項目として記述されます。
インデックスの内容は完全にそのインデックスアクセスメソッドの制御下にあります。
実際、すべてのインデックスアクセスメソッドは、通常の格納マネージャとバッファマネージャを使用してインデックスの内容にアクセスできるように、インデックスを標準サイズのページに分割します。
（既存のすべてのインデックスアクセスメソッドではさらに、<xref linkend="storage-page-layout"/>で説明する標準ページレイアウトを使用し、そのほとんどは同じ書式をインデックスタプルヘッダに使用します。
しかし、これはアクセスメソッドに強制されていることではありません。）
  </para>

  <para>
<!--
   An index is effectively a mapping from some data key values to
   <firstterm>tuple identifiers</firstterm>, or <acronym>TIDs</acronym>, of row versions
   (tuples) in the index's parent table.  A TID consists of a
   block number and an item number within that block (see <xref
   linkend="storage-page-layout"/>).  This is sufficient
   information to fetch a particular row version from the table.
   Indexes are not directly aware that under MVCC, there might be multiple
   extant versions of the same logical row; to an index, each tuple is
   an independent object that needs its own index entry.  Thus, an
   update of a row always creates all-new index entries for the row, even if
   the key values did not change.  (HOT tuples are an exception to this
   statement; but indexes do not deal with those, either.)  Index entries for
   dead tuples are reclaimed (by vacuuming) when the dead tuples themselves
   are reclaimed.
-->
インデックスは効率的にあるデータキー値を、インデックスの親テーブル内の行バージョン（タプル）の<firstterm>タプル識別子</firstterm>言い換えると<acronym>TID</acronym>に関連付けます。
TIDは、ブロック番号、ブロック内の項目番号（<xref linkend="storage-page-layout"/>を参照）から構成されます。
これは、特定の行バージョンをテーブルから取り出すのに十分な情報です。
MVCCでは1つの論理的な行に複数の現在のバージョンがあることを、インデックスが直接意識することはありません。
インデックスでは、各タプルは、独自にインデックス項目を持たなければならない独立したオブジェクトです。
したがって、行を更新すると、キーの値が変わっていなかってとしても、その行に対してまったく新しいインデックス項目が作成されます。
（HOTタプルはこの説明の例外ですが、インデックスはこれらにも関与しません。）
（バキューム実行によって）無効タプル自身が回収された時に、無効タプルに対するインデックス項目は回収されます。
  </para>

 <sect1 id="index-api">
<!--
  <title>Basic API Structure for Indexes</title>
-->
  <title>インデックスの基本的API構造</title>

  <para>
<!--
   Each index access method is described by a row in the
   <link linkend="catalog-pg-am"><structname>pg_am</structname></link>
   system catalog.  The <structname>pg_am</structname> entry
   specifies a name and a <firstterm>handler function</firstterm> for the index
   access method.  These entries can be created and deleted using the
   <xref linkend="sql-create-access-method"/> and
   <xref linkend="sql-drop-access-method"/> SQL commands.
-->
各インデックスメソッドは<link linkend="catalog-pg-am"><structname>pg_am</structname></link>システムカタログの行で説明されます。
<structname>pg_am</structname>エントリはインデックスアクセスメソッドの名前と<firstterm>ハンドラ関数</firstterm>を指定します。
これらのエントリはSQLコマンド<xref linkend="sql-create-access-method"/>と<xref linkend="sql-drop-access-method"/>を使って、作成および削除することができます。
  </para>

  <para>
<!--
   An index access method handler function must be declared to accept a
   single argument of type <type>internal</type> and to return the
   pseudo-type <type>index_am_handler</type>.  The argument is a dummy value that
   simply serves to prevent handler functions from being called directly from
   SQL commands.  The result of the function must be a palloc'd struct of
   type <structname>IndexAmRoutine</structname>, which contains everything
   that the core code needs to know to make use of the index access method.
   The <structname>IndexAmRoutine</structname> struct, also called the access
   method's <firstterm>API struct</firstterm>, includes fields specifying assorted
   fixed properties of the access method, such as whether it can support
   multicolumn indexes.  More importantly, it contains pointers to support
   functions for the access method, which do all of the real work to access
   indexes.  These support functions are plain C functions and are not
   visible or callable at the SQL level.  The support functions are described
   in <xref linkend="index-functions"/>.
-->
インデックスメソッドのハンドラ関数は、<type>internal</type>型の引数を1つ取り、疑似型<type>index_am_handler</type>を返すものとして宣言しなければなりません。
引数は単にハンドラ関数がSQLコマンドから直接呼び出されるのを防ぐためのダミーの値です。
関数の結果は型<structname>IndexAmRoutine</structname>のpallocされた構造体でなければならず、そこにはインデックスアクセスメソッドを使用するためにコアコードが知っている必要のあるすべてのことが含まれています。
<structname>IndexAmRoutine</structname>構造体は、アクセスメソッドの<firstterm>API構造体</firstterm>とも呼ばれ、複数列のインデックスをサポートするかどうかなどといった、アクセスメソッドに関する様々な既定の属性を指定するフィールドが含まれます。
さらに重要なことに、この構造体にはアクセスメソッドのサポート関数へのポインタが含まれ、これによってインデックスにアクセスするためのすべての実際の処理が行われます。
これらのサポート関数は単なるCの関数で、SQLレベルでは見ることも呼び出すこともできません。
サポート関数は<xref linkend="index-functions"/>で説明されています。
  </para>

  <para>
<!--
   The structure <structname>IndexAmRoutine</structname> is defined thus:
-->
構造体<structname>IndexAmRoutine</structname>は以下のように定義されています。
<programlisting>
typedef struct IndexAmRoutine
{
    NodeTag     type;

    /*
     * Total number of strategies (operators) by which we can traverse/search
     * this AM.  Zero if AM does not have a fixed set of strategy assignments.
     */
    uint16      amstrategies;
    /* total number of support functions that this AM uses */
    uint16      amsupport;
    /* opclass options support function number or 0 */
    uint16      amoptsprocnum;
    /* does AM support ORDER BY indexed column's value? */
    bool        amcanorder;
    /* does AM support ORDER BY result of an operator on indexed column? */
    bool        amcanorderbyop;
    /* does AM support backward scanning? */
    bool        amcanbackward;
    /* does AM support UNIQUE indexes? */
    bool        amcanunique;
    /* does AM support multi-column indexes? */
    bool        amcanmulticol;
    /* does AM require scans to have a constraint on the first index column? */
    bool        amoptionalkey;
    /* does AM handle ScalarArrayOpExpr quals? */
    bool        amsearcharray;
    /* does AM handle IS NULL/IS NOT NULL quals? */
    bool        amsearchnulls;
    /* can index storage data type differ from column data type? */
    bool        amstorage;
    /* can an index of this type be clustered on? */
    bool        amclusterable;
    /* does AM handle predicate locks? */
    bool        ampredlocks;
    /* does AM support parallel scan? */
    bool        amcanparallel;
    /* does AM support columns included with clause INCLUDE? */
    bool        amcaninclude;
    /* does AM use maintenance_work_mem? */
    bool        amusemaintenanceworkmem;
    /* OR of parallel vacuum flags */
    uint8       amparallelvacuumoptions;
    /* type of data stored in index, or InvalidOid if variable */
    Oid         amkeytype;

    /* interface functions */
    ambuild_function ambuild;
    ambuildempty_function ambuildempty;
    aminsert_function aminsert;
    ambulkdelete_function ambulkdelete;
    amvacuumcleanup_function amvacuumcleanup;
    amcanreturn_function amcanreturn;   /* can be NULL */
    amcostestimate_function amcostestimate;
    amoptions_function amoptions;
    amproperty_function amproperty;     /* can be NULL */
    ambuildphasename_function ambuildphasename;   /* can be NULL */
    amvalidate_function amvalidate;
    ambeginscan_function ambeginscan;
    amrescan_function amrescan;
    amgettuple_function amgettuple;     /* can be NULL */
    amgetbitmap_function amgetbitmap;   /* can be NULL */
    amendscan_function amendscan;
    ammarkpos_function ammarkpos;       /* can be NULL */
    amrestrpos_function amrestrpos;     /* can be NULL */

    /* interface functions to support parallel index scans */
    amestimateparallelscan_function amestimateparallelscan;    /* can be NULL */
    aminitparallelscan_function aminitparallelscan;    /* can be NULL */
    amparallelrescan_function amparallelrescan;    /* can be NULL */
} IndexAmRoutine;
</programlisting>
  </para>

  <para>
<!--
   To be useful, an index access method must also have one or more
   <firstterm>operator families</firstterm> and
   <firstterm>operator classes</firstterm> defined in
   <link linkend="catalog-pg-opfamily"><structname>pg_opfamily</structname></link>,
   <link linkend="catalog-pg-opclass"><structname>pg_opclass</structname></link>,
   <link linkend="catalog-pg-amop"><structname>pg_amop</structname></link>, and
   <link linkend="catalog-pg-amproc"><structname>pg_amproc</structname></link>.
   These entries allow the planner
   to determine what kinds of query qualifications can be used with
   indexes of this access method.  Operator families and classes are described
   in <xref linkend="xindex"/>, which is prerequisite material for reading
   this chapter.
-->
使い易くするために、インデックスアクセスメソッドはまた、<link linkend="catalog-pg-opfamily"><structname>pg_opfamily</structname></link>、<link linkend="catalog-pg-opclass"><structname>pg_opclass</structname></link>、<link linkend="catalog-pg-amop"><structname>pg_amop</structname></link>および<link linkend="catalog-pg-amproc"><structname>pg_amproc</structname></link>内で定義される、複数の<firstterm>演算子族</firstterm>と<firstterm>演算子クラス</firstterm>を持ちます。
これらの項目により、プランナは、このアクセスメソッドのインデックスがどのような問い合わせ条件に対して使用できるかを決定することができます。
演算子族と演算子クラスについては、<xref linkend="xindex"/>で説明します。
これは本章を読む上で必要となる資料です。
  </para>

  <para>
<!--
   An individual index is defined by a
   <link linkend="catalog-pg-class"><structname>pg_class</structname></link>
   entry that describes it as a physical relation, plus a
   <link linkend="catalog-pg-index"><structname>pg_index</structname></link>
   entry that shows the logical content of the index &mdash; that is, the set
   of index columns it has and the semantics of those columns, as captured by
   the associated operator classes.  The index columns (key values) can be
   either simple columns of the underlying table or expressions over the table
   rows.  The index access method normally has no interest in where the index
   key values come from (it is always handed precomputed key values) but it
   will be very interested in the operator class information in
   <structname>pg_index</structname>.  Both of these catalog entries can be
   accessed as part of the <structname>Relation</structname> data structure that is
   passed to all operations on the index.
-->
個々のインデックスは、インデックスを物理的なリレーションとして記述する<link linkend="catalog-pg-class"><structname>pg_class</structname></link>項目と、インデックスの論理的な内容、つまり、インデックスが持つインデックス列の集合とその列の意味を、関連する演算子クラスで再現されたものとして表す<link linkend="catalog-pg-index"><structname>pg_index</structname></link>項目とで定義されます。
インデックス列（キー値）は、背後のテーブルの単純な列、あるいは、テーブル行に対する式とすることができます。
通常、インデックスアクセスメソッドはインデックスキー値が何を表すかについて考慮しません。
（常に計算済みのキー値として扱われます。）
しかし、<structname>pg_index</structname>内の演算子クラスの情報を深く考慮します。
この両方のカタログ項目は、インデックスに対するすべての操作に渡される<structname>Relation</structname>データ構造の一部としてアクセスすることができます。
  </para>

  <para>
<!--
   Some of the flag fields of <structname>IndexAmRoutine</structname> have nonobvious
   implications.  The requirements of <structfield>amcanunique</structfield>
   are discussed in <xref linkend="index-unique-checks"/>.
   The <structfield>amcanmulticol</structfield> flag asserts that the
   access method supports multicolumn indexes, while
   <structfield>amoptionalkey</structfield> asserts that it allows scans
   where no indexable restriction clause is given for the first index column.
   When <structfield>amcanmulticol</structfield> is false,
   <structfield>amoptionalkey</structfield> essentially says whether the
   access method supports full-index scans without any restriction clause.
   Access methods that support multiple index columns <emphasis>must</emphasis>
   support scans that omit restrictions on any or all of the columns after
   the first; however they are permitted to require some restriction to
   appear for the first index column, and this is signaled by setting
   <structfield>amoptionalkey</structfield> false.
   One reason that an index AM might set
   <structfield>amoptionalkey</structfield> false is if it doesn't index
   null values.  Since most indexable operators are
   strict and hence cannot return true for null inputs,
   it is at first sight attractive to not store index entries for null values:
   they could never be returned by an index scan anyway.  However, this
   argument fails when an index scan has no restriction clause for a given
   index column.  In practice this means that
   indexes that have <structfield>amoptionalkey</structfield> true must
   index nulls, since the planner might decide to use such an index
   with no scan keys at all.  A related restriction is that an index
   access method that supports multiple index columns <emphasis>must</emphasis>
   support indexing null values in columns after the first, because the planner
   will assume the index can be used for queries that do not restrict
   these columns.  For example, consider an index on (a,b) and a query with
   <literal>WHERE a = 4</literal>.  The system will assume the index can be
   used to scan for rows with <literal>a = 4</literal>, which is wrong if the
   index omits rows where <literal>b</literal> is null.
   It is, however, OK to omit rows where the first indexed column is null.
   An index access method that does index nulls may also set
   <structfield>amsearchnulls</structfield>, indicating that it supports
   <literal>IS NULL</literal> and <literal>IS NOT NULL</literal> clauses as search
   conditions.
-->
<structname>IndexAmRoutine</structname>のフラグフィールドの中には、意味がわかりにくいものがあります。
<structfield>amcanunique</structfield>の必要条件は<xref linkend="index-unique-checks"/>で説明されています。
<structfield>amcanmulticol</structfield>フラグはアクセスメソッドが複数列に対するインデックスをサポートすることを表し、<structfield>amoptionalkey</structfield>は、インデックス可能な制限句が最初のインデックス列に指定されていないスキャンを許可することを表します。
<structfield>amcanmulticol</structfield>が偽の場合、<structfield>amoptionalkey</structfield>は基本的に、アクセスメソッドが制限句なしで完全なインデックススキャンをサポートするかどうかを表します。
複数列に対するインデックスをサポートするアクセスメソッドは、最初の列以降のすべてまたは一部の列に関する制限がなくてもスキャンをサポート<emphasis>しなければなりません</emphasis>。
しかし、最初のインデックス列にいくつかの制限を要求することは認められています。
これは、<structfield>amoptionalkey</structfield>を偽に設定することで通知されます。
インデックスアクセスメソッドが<structfield>amoptionalkey</structfield>を偽にする１つの理由は、NULLをインデックス付けしない場合です。
ほとんどのインデックス可能な演算子は厳密で、NULL値の入力に対して真を返すことができませんので、NULLに対してインデックス項目を格納しないことは一見魅力的です。
これはインデックススキャンによって何も返しません。
しかし、最初のインデックス列に対する制限がないインデックススキャンでは、この引数は失敗します。
プランナがこうしたスキャンキーをまったく持たないインデックスを使用することを決定する可能性がありますので、実際これは、<structfield>amoptionalkey</structfield>が真のインデックスはNULLインデックスを持たなければならないことを意味します。
関連する制限として、プランナはこれらの列を制限しない問い合わせでインデックスを使用できることを前提とするため、複数のインデックス列をサポートするインデックスアクセスメソッドは1番目の後の列でNULL値のインデックスをサポート<emphasis></emphasis>しなければならないということがあります。
例えば、(a,b)に対するインデックスに、<literal>WHERE a = 4</literal>という条件で問い合わせを行うことを考えてみます。
システムは、このインデックスを<literal>a = 4</literal>を持つ行をスキャンすることに使用できるものと仮定します。
これはもし、<literal>b</literal>がNULLの場合の行をインデックスが省略する場合は間違っています。
しかし、最初のインデックス列がNULLの場合に行を省略することは問題ありません
また、NULLをインデックス付けするインデックスアクセスメソッドは<structfield>amsearchnulls</structfield>を設定する可能性があります。
これは検索条件として<literal>IS NULL</literal>および<literal>IS NOT NULL</literal>句をサポートすることを示します。
  </para>

 </sect1>

 <sect1 id="index-functions">
<!--
  <title>Index Access Method Functions</title>
-->
  <title>インデックスアクセスメソッド関数</title>

  <para>
<!--
   The index construction and maintenance functions that an index access
   method must provide in <structname>IndexAmRoutine</structname> are:
-->
インデックスアクセスメソッドが<structname>IndexAmRoutine</structname>で提供しなければならない、インデックス構築および保守関数を以下に示します。
  </para>

  <para>
<programlisting>
IndexBuildResult *
ambuild (Relation heapRelation,
         Relation indexRelation,
         IndexInfo *indexInfo);
</programlisting>
<!--
   Build a new index.  The index relation has been physically created,
   but is empty.  It must be filled in with whatever fixed data the
   access method requires, plus entries for all tuples already existing
   in the table.  Ordinarily the <function>ambuild</function> function will call
   <function>table_index_build_scan()</function> to scan the table for existing tuples
   and compute the keys that need to be inserted into the index.
   The function must return a palloc'd struct containing statistics about
   the new index.
-->
新しいインデックスを構築します。
空のインデックスリレーションが物理的に作成されます。
これは、アクセスメソッドが必要とする何らかの固定データと、テーブル内に既に存在するすべてのタプルに対応する項目が書き込まれなければなりません。
通常、<function>ambuild</function>関数は<function>table_index_build_scan()</function>を呼び出し、既存のタプルをテーブルからスキャンし、インデックスに挿入しなければならないキーを計算します。
この関数は、新しいインデックスに関する統計情報を含むpallocされた構造体を返さなければなりません。
  </para>

  <para>
<programlisting>
void
ambuildempty (Relation indexRelation);
</programlisting>
<!--
   Build an empty index, and write it to the initialization fork (<symbol>INIT_FORKNUM</symbol>)
   of the given relation.  This method is called only for unlogged indexes; the
   empty index written to the initialization fork will be copied over the main
   relation fork on each server restart.
-->
空のインデックスを構築し、それを指定されたリレーションの初期フォーク(<symbol>INIT_FORKNUM</symbol>)に書き出します。
このメソッドはログを取らないインデックスに対してのみ呼び出されます。
初期フォークに書き出された空のインデックスは、サーバの再起動の度に主リレーションフォークにコピーされます。
  </para>

  <para>
<programlisting>
bool
aminsert (Relation indexRelation,
          Datum *values,
          bool *isnull,
          ItemPointer heap_tid,
          Relation heapRelation,
          IndexUniqueCheck checkUnique,
          IndexInfo *indexInfo);
</programlisting>
<!--
   Insert a new tuple into an existing index.  The <literal>values</literal> and
   <literal>isnull</literal> arrays give the key values to be indexed, and
   <literal>heap_tid</literal> is the TID to be indexed.
   If the access method supports unique indexes (its
   <structfield>amcanunique</structfield> flag is true) then
   <literal>checkUnique</literal> indicates the type of uniqueness check to
   perform.  This varies depending on whether the unique constraint is
   deferrable; see <xref linkend="index-unique-checks"/> for details.
   Normally the access method only needs the <literal>heapRelation</literal>
   parameter when performing uniqueness checking (since then it will have to
   look into the heap to verify tuple liveness).
-->
既存のインデックスに新しいタプルを挿入します。
<literal>values</literal>配列と<literal>isnull</literal>配列がインデックスされるキー値を提供するもので、<literal>heap_tid</literal>がインデックスされるTIDです。
アクセスメソッドが一意なインデックスをサポートする場合（その<structfield>amcanunique</structfield>が真の場合）、<literal>checkUnique</literal>は実行する一意性検査の種類を示します。
これは一意性制約が遅延可能か否かによって変わります。
<xref linkend="index-unique-checks"/>を参照してください。
通常アクセスメソッドは、一意性検査を行う時に<literal>heapRelation</literal>パラメータのみを必要とします
(タプルの有効性を検証するためにヒープ内を検索しなければなりません)。
  </para>

  <para>
<!--
   The function's Boolean result value is significant only when
   <literal>checkUnique</literal> is <literal>UNIQUE_CHECK_PARTIAL</literal>.
   In this case a true result means the new entry is known unique, whereas
   false means it might be non-unique (and a deferred uniqueness check must
   be scheduled).  For other cases a constant false result is recommended.
-->
<literal>checkUnique</literal>が<literal>UNIQUE_CHECK_PARTIAL</literal>の場合、関数の論理型の結果値で十分です。
この場合、真の結果は新しい項目は一意であることが確認されたことを、一方偽の結果は一意でない可能性があること(遅延一意性検査を予定しなければならないこと)を意味します。
他の場合では、一定の偽という結果が推奨されます。
  </para>

  <para>
<!--
   Some indexes might not index all tuples.  If the tuple is not to be
   indexed, <function>aminsert</function> should just return without doing anything.
-->
一部のインデックスではすべてのタプルをインデックス付けしない可能性があります。
タプルがインデックス付けされない場合、<function>aminsert</function>は何も行わずに戻らなければなりません。
  </para>

  <para>
<!--
   If the index AM wishes to cache data across successive index insertions
   within a SQL statement, it can allocate space
   in <literal>indexInfo-&gt;ii_Context</literal> and store a pointer to the
   data in <literal>indexInfo-&gt;ii_AmCache</literal> (which will be NULL
   initially).
-->
SQL文の中で、インデックスAMがインデックスへの連続的な挿入をまたがってデータをキャッシュすることが望ましい場合は、<literal>indexInfo-&gt;ii_Context</literal>にメモリを確保し、そのデータへのポインタを<literal>indexInfo-&gt;ii_AmCache</literal>（初期値はNULLです)に格納することができます。
  </para>

  <para>
<programlisting>
IndexBulkDeleteResult *
ambulkdelete (IndexVacuumInfo *info,
              IndexBulkDeleteResult *stats,
              IndexBulkDeleteCallback callback,
              void *callback_state);
</programlisting>
<!--
   Delete tuple(s) from the index.  This is a <quote>bulk delete</quote> operation
   that is intended to be implemented by scanning the whole index and checking
   each entry to see if it should be deleted.
   The passed-in <literal>callback</literal> function must be called, in the style
   <literal>callback(<replaceable>TID</replaceable>, callback_state) returns bool</literal>,
   to determine whether any particular index entry, as identified by its
   referenced TID, is to be deleted.  Must return either NULL or a palloc'd
   struct containing statistics about the effects of the deletion operation.
   It is OK to return NULL if no information needs to be passed on to
   <function>amvacuumcleanup</function>.
-->
インデックスからタプル（複数可）を削除します。
これは<quote>一括削除</quote>操作を行いますが、インデックス全体をスキャンし、各項目に対して削除すべきかどうか検査を行うように実装されることが想定されています。
渡される<literal>callback</literal>関数は、<literal>callback(<replaceable>TID</replaceable>, callback_state) returns bool</literal>という形で、参照用TIDで識別されるインデックス項目を削除すべきかどうか決定するために呼び出さなければなりません。
NULLまたはpallocした削除操作の影響に関する統計情報を含む構造体を返さなければなりません。
<function>amvacuumcleanup</function>に渡さなければならない情報がなければ、NULLを返しても問題ありません。
  </para>

  <para>
<!--
   Because of limited <varname>maintenance_work_mem</varname>,
   <function>ambulkdelete</function> might need to be called more than once when many
   tuples are to be deleted.  The <literal>stats</literal> argument is the result
   of the previous call for this index (it is NULL for the first call within a
   <command>VACUUM</command> operation).  This allows the AM to accumulate statistics
   across the whole operation.  Typically, <function>ambulkdelete</function> will
   modify and return the same struct if the passed <literal>stats</literal> is not
   null.
-->
<varname>maintenance_work_mem</varname>の制限により、多くのタプルが削除される時、<function>ambulkdelete</function>を複数回呼び出す必要があるかもしれません。
<literal>stats</literal>引数は、このインデックスに対する前回の呼び出し結果です。
（<command>VACUUM</command>操作における最初の呼び出しではこれはNULLです。）
これにより、アクセスメソッドは操作全体に跨った統計情報を計算することができます。
典型的に、渡された<literal>stats</literal>がNULLでない場合、<function>ambulkdelete</function>は同じ構造体を変更し、返します。
  </para>

  <para>
<programlisting>
IndexBulkDeleteResult *
amvacuumcleanup (IndexVacuumInfo *info,
                 IndexBulkDeleteResult *stats);
</programlisting>
<!--
   Clean up after a <command>VACUUM</command> operation (zero or more
   <function>ambulkdelete</function> calls).  This does not have to do anything
   beyond returning index statistics, but it might perform bulk cleanup
   such as reclaiming empty index pages.  <literal>stats</literal> is whatever the
   last <function>ambulkdelete</function> call returned, or NULL if
   <function>ambulkdelete</function> was not called because no tuples needed to be
   deleted.  If the result is not NULL it must be a palloc'd struct.
   The statistics it contains will be used to update <structname>pg_class</structname>,
   and will be reported by <command>VACUUM</command> if <literal>VERBOSE</literal> is given.
   It is OK to return NULL if the index was not changed at all during the
   <command>VACUUM</command> operation, but otherwise correct stats should
   be returned.
-->
<command>VACUUM</command>操作（0回以上の<function>ambulkdelete</function>呼び出し）後の整理を行います。
これは、インデックス統計情報を返す以上の処理を行う必要はありません。
しかし、空のインデックスページの回収などの一括整理を行う可能性があります。
<literal>stats</literal>は最後の<function>ambulkdelete</function>呼び出しが返したものです。
削除する必要があるタプルが存在しなかったために<function>ambulkdelete</function>が呼び出されなかった場合はNULLとなります。
結果はNULLでなければ、pallocされた構造体でなければなりません。
含まれる統計情報は<structname>pg_class</structname>を更新するために使用され、また、<literal>VERBOSE</literal>が指定された<command>VACUUM</command>によって報告されます。
<command>VACUUM</command>操作の間にインデックスがまったく変わらなかった場合はNULLを返しても問題ありません。
しかし、そうでなければ正しい統計情報を返さなければなりません。
  </para>

  <para>
<!--
   As of <productname>PostgreSQL</productname> 8.4,
   <function>amvacuumcleanup</function> will also be called at completion of an
   <command>ANALYZE</command> operation.  In this case <literal>stats</literal> is always
   NULL and any return value will be ignored.  This case can be distinguished
   by checking <literal>info-&gt;analyze_only</literal>.  It is recommended
   that the access method do nothing except post-insert cleanup in such a
   call, and that only in an autovacuum worker process.
-->
<productname>PostgreSQL</productname> 8.4の時点で、<function>amvacuumcleanup</function>も<command>ANALYZE</command>操作の完了時点にも呼び出されます。
この場合、<literal>stats</literal>は常にNULLで、戻り値はまったく無視されます。
この事象は<literal>info-&gt;analyze_only</literal>を検査することで識別されます。
アクセスメソッドがそのような呼び出しで挿入後の整理以外何もしないように、そしてそれは自動バキュームワーカプロセスのみであるようにすることを推奨します。
  </para>

  <para>
<programlisting>
bool
amcanreturn (Relation indexRelation, int attno);
</programlisting>
<!--
   Check whether the index can support <link
   linkend="indexes-index-only-scans"><firstterm>index-only scans</firstterm></link> on
   the given column, by returning the indexed column values for an index entry
   in the form of an <structname>IndexTuple</structname>.  The attribute number
   is 1-based, i.e., the first column's attno is 1. Returns true if supported,
   else false.  If the access method does not support index-only scans at all,
   the <structfield>amcanreturn</structfield> field in its <structname>IndexAmRoutine</structname>
   struct can be set to NULL.
-->
<structname>IndexTuple</structname>形式のインデックスエントリをインデックスが設定された列の値として返すことにより、そのインデックスが指定された列で<link linkend="indexes-index-only-scans"><firstterm>インデックスオンリースキャン</firstterm></link>をサポートしているかどうかを判断します。
属性番号は1始まり、すなわち最初の列の属性番号は1です。
インデックスオンリースキャンがサポートされている場合は真が返され、サポートされていない場合は偽が返ります。
アクセスメソッドがインデックスオンリースキャンをサポートしていない場合、<structname>IndexAmRoutine</structname>構造体の<structfield>amcanreturn</structfield>フィールドをNULLにセットすることができます。
  </para>

  <para>
<programlisting>
void
amcostestimate (PlannerInfo *root,
                IndexPath *path,
                double loop_count,
                Cost *indexStartupCost,
                Cost *indexTotalCost,
                Selectivity *indexSelectivity,
                double *indexCorrelation,
                double *indexPages);
</programlisting>
<!--
   Estimate the costs of an index scan.  This function is described fully
   in <xref linkend="index-cost-estimation"/>, below.
-->
インデックススキャンのコストを推定します。
この関数については後述の<xref linkend="index-cost-estimation"/>で説明します。
  </para>

  <para>
<programlisting>
bytea *
amoptions (ArrayType *reloptions,
           bool validate);
</programlisting>
<!--
   Parse and validate the reloptions array for an index.  This is called only
   when a non-null reloptions array exists for the index.
   <parameter>reloptions</parameter> is a <type>text</type> array containing entries of the
   form <replaceable>name</replaceable><literal>=</literal><replaceable>value</replaceable>.
   The function should construct a <type>bytea</type> value, which will be copied
   into the <structfield>rd_options</structfield> field of the index's relcache entry.
   The data contents of the <type>bytea</type> value are open for the access
   method to define; most of the standard access methods use struct
   <structname>StdRdOptions</structname>.
   When <parameter>validate</parameter> is true, the function should report a suitable
   error message if any of the options are unrecognized or have invalid
   values; when <parameter>validate</parameter> is false, invalid entries should be
   silently ignored.  (<parameter>validate</parameter> is false when loading options
   already stored in <structname>pg_catalog</structname>; an invalid entry could only
   be found if the access method has changed its rules for options, and in
   that case ignoring obsolete entries is appropriate.)
   It is OK to return NULL if default behavior is wanted.
-->
インデックス用のreloptionsの解析と検証を行います。
インデックスに非NULLのreloptions配列が存在する場合にのみ呼び出されます。
<parameter>reloptions</parameter>は、<replaceable>name</replaceable><literal>=</literal><replaceable>value</replaceable>形式の項目からなる、<type>text</type>型の配列です。
この関数は<type>bytea</type>型の値を生成しなければならず、この値はインデックスのrelcache項目の<structfield>rd_options</structfield>フィールドにコピーされます。
<type>bytea</type>型の値の内容はアクセスメソッドが独自に定義できるように開放されています。
標準のアクセスメソッドのほとんどはすべて<structname>StdRdOptions</structname>構造体を使用します。
<parameter>validate</parameter>が真の場合、何らかのオプションが認識できなかった場合や無効な値が存在した場合、この関数は適切なエラーメッセージを報告しなければなりません。
<parameter>validate</parameter>が偽の場合、無効な項目は単に無視されます。
（読み込みオプションが既に<structname>pg_catalog</structname>に格納されている場合<parameter>validate</parameter>は偽です。
アクセスメソッドがそのオプション用の規則を変更した場合にのみ、無効な項目が検出されます。
そして、その場合、古い項目を無視することが適切です。）
デフォルトの動作を行わせたい場合はNULLを返しても問題ありません。
  </para>

  <para>
<programlisting>
bool
amproperty (Oid index_oid, int attno,
            IndexAMProperty prop, const char *propname,
            bool *res, bool *isnull);
</programlisting>
<!--
   The <function>amproperty</function> method allows index access methods to override
   the default behavior of <function>pg_index_column_has_property</function>
   and related functions.
   If the access method does not have any special behavior for index property
   inquiries, the <structfield>amproperty</structfield> field in
   its <structname>IndexAmRoutine</structname> struct can be set to NULL.
   Otherwise, the <function>amproperty</function> method will be called with
   <parameter>index_oid</parameter> and <parameter>attno</parameter> both zero for
   <function>pg_indexam_has_property</function> calls,
   or with <parameter>index_oid</parameter> valid and <parameter>attno</parameter> zero for
   <function>pg_index_has_property</function> calls,
   or with <parameter>index_oid</parameter> valid and <parameter>attno</parameter> greater than
   zero for <function>pg_index_column_has_property</function> calls.
   <parameter>prop</parameter> is an enum value identifying the property being tested,
   while <parameter>propname</parameter> is the original property name string.
   If the core code does not recognize the property name
   then <parameter>prop</parameter> is <literal>AMPROP_UNKNOWN</literal>.
   Access methods can define custom property names by
   checking <parameter>propname</parameter> for a match (use <function>pg_strcasecmp</function>
   to match, for consistency with the core code); for names known to the core
   code, it's better to inspect <parameter>prop</parameter>.
   If the <structfield>amproperty</structfield> method returns <literal>true</literal> then
   it has determined the property test result: it must set <literal>*res</literal>
   to the boolean value to return, or set <literal>*isnull</literal>
   to <literal>true</literal> to return a NULL.  (Both of the referenced variables
   are initialized to <literal>false</literal> before the call.)
   If the <structfield>amproperty</structfield> method returns <literal>false</literal> then
   the core code will proceed with its normal logic for determining the
   property test result.
-->
<function>amproperty</function>メソッドにより、インデックスメソッドは<function>pg_index_column_has_property</function>および関連する関数のデフォルトの動作を上書きすることができます。
インデックスアクセスメソッドがインデックスの属性の問い合わせについて特別な動作をしないのなら、<structname>IndexAmRoutine</structname>構造体の<structfield>amproperty</structfield>フィールドはNULLにすることができます。
そうでなければ、<function>amproperty</function>は<function>pg_indexam_has_property</function>の呼び出しに対し、<parameter>index_oid</parameter>と<parameter>attno</parameter>をいずれもゼロにして、<function>pg_index_has_property</function>の呼び出しに対して<parameter>index_oid</parameter>が有効、<parameter>attno</parameter>がゼロで、あるいは<function>pg_index_column_has_property</function>の呼び出しに対して<parameter>index_oid</parameter>が有効、<parameter>attno</parameter>が1以上で呼び出されます。
<parameter>prop</parameter>は検査対象の属性を指定する列挙型の値、<parameter>propname</parameter>は元の属性の名称の文字列です。
コアのコードが属性名を認識しない場合、<parameter>prop</parameter>は<literal>AMPROP_UNKNOWN</literal>になります。
アクセスメソッドはカスタム属性名を定義して、マッチするものを<parameter>propname</parameter>で確認する（コアコードとの一貫性のため、<function>pg_strcasecmp</function>を使ってください）ことができます。
コアコードに既知の名前については、<parameter>prop</parameter>を検査する方が良いです。
<structfield>amproperty</structfield>メソッドが<literal>true</literal>を返すなら、それは属性検査の結果が決定したということで、<literal>*res</literal>を返すべき論理値にセットするか、NULLを返すために<literal>*isnull</literal>を<literal>true</literal>にセットするかしなければなりません。
（どちらの参照変数も、呼び出しの前に<literal>false</literal>に初期化されます。）
<structfield>amproperty</structfield>メソッドが<literal>false</literal>を返すなら、コアコードは属性検査の結果を決定するために、通常の手続きを進めます。
  </para>

  <para>
<!--
   Access methods that support ordering operators should
   implement <literal>AMPROP_DISTANCE_ORDERABLE</literal> property testing, as the
   core code does not know how to do that and will return NULL.  It may
   also be advantageous to implement <literal>AMPROP_RETURNABLE</literal> testing,
   if that can be done more cheaply than by opening the index and calling
   <structfield>amcanreturn</structfield>, which is the core code's default behavior.
   The default behavior should be satisfactory for all other standard
   properties.
-->
順序付け演算子をサポートするアクセスメソッドは、<literal>AMPROP_DISTANCE_ORDERABLE</literal>の属性検査を実装する必要があります。
なぜなら、コアコードはそれをどうすれば良いか知らないため、NULLを返すからです。
コアコードのデフォルトの動作であるインデックスのオープンと<structfield>amcanreturn</structfield>の呼び出しよりも安価にできるのであれば、<literal>AMPROP_RETURNABLE</literal>の検査を実装するのは利点となります。
その他のすべての標準属性に対しては、デフォルトの動作が満足できるもののはずです。
  </para>

  <para>
<programlisting>
char *
ambuildphasename (int64 phasenum);
</programlisting>
<!--
   Return the textual name of the given build phase number.
   The phase numbers are those reported during an index build via the
   <function>pgstat_progress_update_param</function> interface.
   The phase names are then exposed in the
   <structname>pg_stat_progress_create_index</structname> view.
-->
指定されたビルドフェーズ番号のテキスト名を返します。
フェーズ番号は、<function>pgstat_progress_update_param</function>インタフェースを介してインデックス構築中に報告されたものです。
それから、フェーズ名は<structname>pg_stat_progress_create_index</structname>ビューで公開されます。
  </para>

  <para>
<programlisting>
bool
amvalidate (Oid opclassoid);
</programlisting>
<!--
   Validate the catalog entries for the specified operator class, so far as
   the access method can reasonably do that.  For example, this might include
   testing that all required support functions are provided.
   The <function>amvalidate</function> function must return false if the opclass is
   invalid.  Problems should be reported with <function>ereport</function> messages.
-->
指定の演算子クラスについて、アクセスメソッドが合理的にできる限りにおいて、カタログエントリを検証します。
例えば、これには必要なすべてのサポート関数が提供されていることのテストが含まれるかもしれません。
<function>amvalidate</function>関数は演算子クラスが無効なときは偽を返さなければなりません。
問題点は<function>ereport</function>メッセージにより報告されます。
  </para>


  <para>
<!--
   The purpose of an index, of course, is to support scans for tuples matching
   an indexable <literal>WHERE</literal> condition, often called a
   <firstterm>qualifier</firstterm> or <firstterm>scan key</firstterm>.  The semantics of
   index scanning are described more fully in <xref linkend="index-scanning"/>,
   below.  An index access method can support <quote>plain</quote> index scans,
   <quote>bitmap</quote> index scans, or both.  The scan-related functions that an
   index access method must or may provide are:
-->
当然ながらインデックスの目的は、よく<firstterm>修飾子</firstterm>や<firstterm>スキャンキー</firstterm>と呼ばれる、インデックス可能な<literal>WHERE</literal>条件を満たすタプルのスキャンをサポートすることです。
インデックススキャンのセマンティクスは後の<xref linkend="index-scanning"/>でより詳しく説明します。
インデックスアクセスメソッドは<quote>単純</quote>インデックススキャン、<quote>ビットマップ</quote>インデックススキャン、またはこれら双方を提供します。
インデックスアクセスメソッドが提供しなければならない、もしくは提供する可能性のあるスキャン関連の関数を以下に示します。
  </para>

  <para>
<programlisting>
IndexScanDesc
ambeginscan (Relation indexRelation,
             int nkeys,
             int norderbys);
</programlisting>
<!--
   Prepare for an index scan.  The <literal>nkeys</literal> and <literal>norderbys</literal>
   parameters indicate the number of quals and ordering operators that will be
   used in the scan; these may be useful for space allocation purposes.
   Note that the actual values of the scan keys aren't provided yet.
   The result must be a palloc'd struct.
   For implementation reasons the index access method
   <emphasis>must</emphasis> create this struct by calling
   <function>RelationGetIndexScan()</function>.  In most cases
   <function>ambeginscan</function> does little beyond making that call and perhaps
   acquiring locks;
   the interesting parts of index-scan startup are in <function>amrescan</function>.
-->
インデックススキャンを準備します。
<literal>nkeys</literal>および<literal>norderbys</literal>パラメータは、スキャンで使用される等価性演算子と順序付け演算子の個数を表します。
これらは領域を割り当てる目的で便利かもしれません。
スキャンキーの実値がまだ提供されていないことに注意してください。
結果はpallocした構造体でなければなりません。
実装上の理由により、インデックスアクセスメソッドは<function>RelationGetIndexScan()</function>呼び出しによってこの構造体を作成<emphasis>しなければなりません</emphasis>。
ほとんどの場合、<function>ambeginscan</function>はこの呼び出しとおそらくロックの獲得の他にはほとんど何も行いません。
インデックススキャンを始める際の興味深い部分は、<function>amrescan</function>にあります。
  </para>

  <para>
<programlisting>
void
amrescan (IndexScanDesc scan,
          ScanKey keys,
          int nkeys,
          ScanKey orderbys,
          int norderbys);
</programlisting>
<!--
   Start or restart an index scan, possibly with new scan keys.  (To restart
   using previously-passed keys, NULL is passed for <literal>keys</literal> and/or
   <literal>orderbys</literal>.)  Note that it is not allowed for
   the number of keys or order-by operators to be larger than
   what was passed to <function>ambeginscan</function>.  In practice the restart
   feature is used when a new outer tuple is selected by a nested-loop join
   and so a new key comparison value is needed, but the scan key structure
   remains the same.
-->
インデックススキャンを起動または再起動します。
スキャンキーを新しくすることもできます。
（過去に渡されたキーを使用して再起動するには、<literal>key</literal>、<literal>orderbys</literal>、またはその両方にNULLを渡します。)
<function>ambeginscan</function>に渡したキー演算子、順序付け演算子の個数より多くを使用することはできないことに注意してください。
実際には、ネステッドループ結合によって新しい外部タプルが選択され、同じスキャンキー構造体で新しいキー比較値が必要とされた場合に、この再起動機能は使用されます。
  </para>

  <para>
<programlisting>
boolean
amgettuple (IndexScanDesc scan,
            ScanDirection direction);
</programlisting>
<!--
   Fetch the next tuple in the given scan, moving in the given
   direction (forward or backward in the index).  Returns true if a tuple was
   obtained, false if no matching tuples remain.  In the true case the tuple
   TID is stored into the <literal>scan</literal> structure.  Note that
   <quote>success</quote> means only that the index contains an entry that matches
   the scan keys, not that the tuple necessarily still exists in the heap or
   will pass the caller's snapshot test.  On success, <function>amgettuple</function>
   must also set <literal>scan-&gt;xs_recheck</literal> to true or false.
   False means it is certain that the index entry matches the scan keys.
   True means this is not certain, and the conditions represented by the
   scan keys must be rechecked against the heap tuple after fetching it.
   This provision supports <quote>lossy</quote> index operators.
   Note that rechecking will extend only to the scan conditions; a partial
   index predicate (if any) is never rechecked by <function>amgettuple</function>
   callers.
-->
指定されたスキャン内から指定された方向（インデックス内の前方または後方）で次のタプルを取り出します。
タプルを取り出した場合は真を返します。
一致するタプルが残っていない場合は偽を返します。
真の場合、そのタプルのTIDが<literal>scan</literal>に格納されます。
<quote>成功</quote>とは、単にインデックスにスキャンキーに一致する項目があったことを意味しているだけです。
タプルが必ずヒープ内に存在することや、呼び出し元のスナップショットの試験を通過したことを意味してはいません。
成功の暁には、<function>amgettuple</function>は<literal>scan-&gt;xs_recheck</literal>を真か偽かに設定しなければなりません。
偽の意味は、インデックス項目が確実にスキャンキーに一致することです。
真の意味は、これが確かなことではなく、スキャンキーで表示された条件がヒープタプルを取り出された後で再検査されなければならないことです。
この対策は<quote>非可逆</quote>インデックス演算子をサポートします。
再検査はスキャン条件のみに拡大適用されることに注意してください。
部分インデックス述語（もしあれば）は<function>amgettuple</function>呼び出し元で決して再検査されません。
  </para>

  <para>
<!--
   If the index supports <link linkend="indexes-index-only-scans">index-only
   scans</link> (i.e., <function>amcanreturn</function> returns true for it),
   then on success the AM must also check <literal>scan-&gt;xs_want_itup</literal>,
   and if that is true it must return the originally indexed data for the
   index entry.  The data can be returned in the form of an
   <structname>IndexTuple</structname> pointer stored at <literal>scan-&gt;xs_itup</literal>,
   with tuple descriptor <literal>scan-&gt;xs_itupdesc</literal>; or in the form of
   a <structname>HeapTuple</structname> pointer stored at <literal>scan-&gt;xs_hitup</literal>,
   with tuple descriptor <literal>scan-&gt;xs_hitupdesc</literal>.  (The latter
   format should be used when reconstructing data that might possibly not fit
   into an <structname>IndexTuple</structname>.)  In either case,
   management of the data referenced by the pointer is the access method's
   responsibility.  The data must remain good at least until the next
   <function>amgettuple</function>, <function>amrescan</function>, or <function>amendscan</function>
   call for the scan.
-->
そのインデックスが<link linkend="indexes-index-only-scans">インデックスオンリースキャン</link>をサポートしている場合(つまり<function>amcanreturn</function>が真を返す場合)、そのアクセスメソッドはスキャンが成功したならば<literal>scan-&gt;xs_want_itup</literal>も確認し、それが真の場合、そのインデックスエントリに対応する元のインデックスされたデータを返さなければなりません。
返却されるデータは、<literal>scan-&gt;xs_itupdesc</literal>タプルディスクリプタとともに<literal>scan-&gt;xs_itup</literal>に格納された<structname>IndexTuple</structname>ポインタの形式か、あるいは、<literal>scan-&gt;xs_hitupdesc</literal>タプルディスクリプタとともに<literal>scan-&gt;xs_hitup</literal>に格納された<structname>HeapTuple</structname>ポインタの形式です。
（後者の形式は、再構成されたデータが<structname>IndexTuple</structname>に収まらない場合に使用するべきです。）
どちらの場合でも、そのポインタが参照するデータの管理はアクセスメソッドの責任です。
データは少なくとも<function>amgettuple</function>、<function>amrescan</function>または<function>amendscan</function>によってスキャンされるまでよい状態を保たなくてはなりません。
  </para>

  <para>
<!--
   The <function>amgettuple</function> function need only be provided if the access
   method supports <quote>plain</quote> index scans.  If it doesn't, the
   <structfield>amgettuple</structfield> field in its <structname>IndexAmRoutine</structname>
   struct must be set to NULL.
-->
<function>amgettuple</function>関数は、アクセスメソッドが<quote>単純</quote>インデックススキャンをサポートするときのみ提供される必要があります。
そうでなければ、<structname>IndexAmRoutine</structname>構造体の<structfield>amgettuple</structfield>フィールドはNULLに設定されなければなりません。
  </para>

  <para>
<programlisting>
int64
amgetbitmap (IndexScanDesc scan,
             TIDBitmap *tbm);
</programlisting>
<!--
   Fetch all tuples in the given scan and add them to the caller-supplied
   <type>TIDBitmap</type> (that is, OR the set of tuple IDs into whatever set is already
   in the bitmap).  The number of tuples fetched is returned (this might be
   just an approximate count, for instance some AMs do not detect duplicates).
   While inserting tuple IDs into the bitmap, <function>amgetbitmap</function> can
   indicate that rechecking of the scan conditions is required for specific
   tuple IDs.  This is analogous to the <literal>xs_recheck</literal> output parameter
   of <function>amgettuple</function>.  Note: in the current implementation, support
   for this feature is conflated with support for lossy storage of the bitmap
   itself, and therefore callers recheck both the scan conditions and the
   partial index predicate (if any) for recheckable tuples.  That might not
   always be true, however.
   <function>amgetbitmap</function> and
   <function>amgettuple</function> cannot be used in the same index scan; there
   are other restrictions too when using <function>amgetbitmap</function>, as explained
   in <xref linkend="index-scanning"/>.
-->
指定されたスキャンから全てのタプルを取り出し、呼び出し側が提供する<type>TIDBitmap</type>にそれらを付加します
（つまり、既にビットマップ内にある集合とタプルIDの集合とのORを取ります）。
取り出されたタプル数が返されます（例えばいくつかのAMは重複を検出しませんので、これは単なる概算です）。
タプルIDをビットマップに挿入する間、<function>amgetbitmap</function>は特定のタプルIDに必要なスキャン条件の再検査を示すことが可能です。
これは<function>amgettuple</function>の<literal>xs_recheck</literal>出力パラメータに類似しています。
注意：現在の実装においてこの機能の提供はビットマップそのものの非可逆格納を提供するのに結びついていて、したがって呼び出し側はスキャン条件と部分インデックスの述部（存在すれば）を再検査可能なタプルに対して再検査します。
とは言っても常に正しいとは限りません。
<function>amgetbitmap</function>および<function>amgettuple</function>を同じインデックススキャン内で使用することはできません。
<xref linkend="index-scanning"/>で説明した通り、<function>amgetbitmap</function>を使用する場合には他にも制限があります。
  </para>

  <para>
<!--
   The <function>amgetbitmap</function> function need only be provided if the access
   method supports <quote>bitmap</quote> index scans.  If it doesn't, the
   <structfield>amgetbitmap</structfield> field in its <structname>IndexAmRoutine</structname>
   struct must be set to NULL.
-->
<function>amgetbitmap</function>関数はアクセスメソッドが<quote>ビットマップ</quote>インデックススキャンをサポートしている場合のみ必要です。
そうでなければ、<structname>IndexAmRoutine</structname>構造体の中の<structfield>amgetbitmap</structfield>フィールドはNULLに設定されなければなりません。
  </para>

  <para>
<programlisting>
void
amendscan (IndexScanDesc scan);
</programlisting>
<!--
   End a scan and release resources.  The <literal>scan</literal> struct itself
   should not be freed, but any locks or pins taken internally by the
   access method must be released, as well as any other memory allocated
   by <function>ambeginscan</function> and other scan-related functions.
-->
スキャンを停止し、リソースを解放します。
<literal>scan</literal>構造体自体は解放すべきではありません。
アクセスメソッドで内部的に取られたロックやピンは、<function>ambeginscan</function>や他のスキャン関連の関数により確保されたメモリと同様に解放しなければなりません。
  </para>

  <para>
<programlisting>
void
ammarkpos (IndexScanDesc scan);
</programlisting>
<!--
   Mark current scan position.  The access method need only support one
   remembered scan position per scan.
-->
現在のスキャン位置を記録します。
アクセスメソッドは1スキャン当たり1つの記録済みスキャンのみをサポートしなければなりません。
  </para>

  <para>
<!--
   The <function>ammarkpos</function> function need only be provided if the access
   method supports ordered scans.  If it doesn't,
   the <structfield>ammarkpos</structfield> field in its <structname>IndexAmRoutine</structname>
   struct may be set to NULL.
-->
<function>ammarkpos</function>関数はアクセスメソッドが順序付けされたスキャンをサポートする場合にのみ提供する必要があります。
そうでなければ、その<structname>IndexAmRoutine</structname>構造体の<structfield>ammarkpos</structfield>フィールドはNULLに設定しても構いません。
  </para>

  <para>
<programlisting>
void
amrestrpos (IndexScanDesc scan);
</programlisting>
<!--
   Restore the scan to the most recently marked position.
-->
もっとも最近に記録された位置にスキャンを戻します。
  </para>

  <para>
<!--
   The <function>amrestrpos</function> function need only be provided if the access
   method supports ordered scans.  If it doesn't,
   the <structfield>amrestrpos</structfield> field in its <structname>IndexAmRoutine</structname>
   struct may be set to NULL.
-->
<function>amrestrpos</function>関数はアクセスメソッドが順序付けされたスキャンをサポートする場合にのみ提供する必要があります。
そうでなければ、その<structname>IndexAmRoutine</structname>構造体の<structfield>amrestrpos</structfield>フィールドはNULLに設定しても構いません。
  </para>

  <para>
<!--
   In addition to supporting ordinary index scans, some types of index
   may wish to support <firstterm>parallel index scans</firstterm>, which allow
   multiple backends to cooperate in performing an index scan.  The
   index access method should arrange things so that each cooperating
   process returns a subset of the tuples that would be performed by
   an ordinary, non-parallel index scan, but in such a way that the
   union of those subsets is equal to the set of tuples that would be
   returned by an ordinary, non-parallel index scan.  Furthermore, while
   there need not be any global ordering of tuples returned by a parallel
   scan, the ordering of that subset of tuples returned within each
   cooperating backend must match the requested ordering.  The following
   functions may be implemented to support parallel index scans:
-->
通常のインデックススキャンのサポートに加え、ある種のインデックスは、複数のバックエンドが協調してインデックススキャンを実行する<firstterm>パラレルインデックススキャン</firstterm>をサポートすることができます。
インデックスアクセスメソッドは、協調するプロセスが、通常の非パラレルインデックススキャンが実行対象とする行のサブセットを返しつつ、しかもそれらのサブセットの合計が、通常の非パラレルインデックススキャンが返すタプルの集合と同じになるように調整しなければなりません。
それだけでなく、パラレルスキャンが返すタプル全体の順序付けが想定されていない場合でも、協調するバックエンドが返すサブセットのタプルの順序付けは、要求された順序付けと一致しなければなりません。
パラレルインデックススキャンをサポートするために、以下の関数を実装することができます。
  </para>

  <para>
<programlisting>
Size
amestimateparallelscan (void);
</programlisting>
<!--
   Estimate and return the number of bytes of dynamic shared memory which
   the access method will be needed to perform a parallel scan.  (This number
   is in addition to, not in lieu of, the amount of space needed for
   AM-independent data in <structname>ParallelIndexScanDescData</structname>.)
-->
パラレルスキャンを実行するために、アクセスメソッドによって必要とされる動的共有メモリのバイト数を推測し、返します。
（この数値は、<structname>ParallelIndexScanDescData</structname>のAM独立データに必要となる量に追加するための値であり、それを置き換えるものではありません。）
  </para>

  <para>
<!--
   It is not necessary to implement this function for access methods which
   do not support parallel scans or for which the number of additional bytes
   of storage required is zero.
-->
パラレルスキャンをサポートしない、あるいはメモリ領域への追加のバイト数が0のアクセスメソッドでは、この関数を実装する必要はありません。
  </para>

  <para>
<programlisting>
void
aminitparallelscan (void *target);
</programlisting>
<!--
   This function will be called to initialize dynamic shared memory at the
   beginning of a parallel scan.  <parameter>target</parameter> will point to at least
   the number of bytes previously returned by
   <function>amestimateparallelscan</function>, and this function may use that
   amount of space to store whatever data it wishes.
-->
この関数は、パラレルスキャンの最初に動的共有メモリを初期化するために呼ばれます。
<parameter>target</parameter>は、前もって<function>amestimateparallelscan</function>が返したバイト数を少なくとも持つ領域を指し、この関数はその分だけのスペースを使って必要なデータを保管することができます。
  </para>

  <para>
<!--
   It is not necessary to implement this function for access methods which
   do not support parallel scans or in cases where the shared memory space
   required needs no initialization.
-->
パラレルスキャンをサポートしない、あるいは共有メモリスペースの初期化が必要ないアクセスメソッドでは、この関数を実装する必要はありません。
  </para>

  <para>
<programlisting>
void
amparallelrescan (IndexScanDesc scan);
</programlisting>
<!--
   This function, if implemented, will be called when a parallel index scan
   must be restarted.  It should reset any shared state set up by
   <function>aminitparallelscan</function> such that the scan will be restarted from
   the beginning.
-->
実装された場合、この関数はパラレルインデックススキャンを再起動しなければならない時に呼ばれます。
この関数は、<function>aminitparallelscan</function>が設定した共有状態を初期化し、スキャンが最初から再開できるようにします。
  </para>

 </sect1>

 <sect1 id="index-scanning">
<!--
  <title>Index Scanning</title>
-->
  <title>インデックススキャン</title>

  <para>
<!--
   In an index scan, the index access method is responsible for regurgitating
   the TIDs of all the tuples it has been told about that match the
   <firstterm>scan keys</firstterm>.  The access method is <emphasis>not</emphasis> involved in
   actually fetching those tuples from the index's parent table, nor in
   determining whether they pass the scan's visibility test or other
   conditions.
-->
インデックススキャンでは、<firstterm>スキャンキー</firstterm>に一致するものと示したすべてのタプルのTIDを繰り返すことに関する責任をインデックスアクセスメソッドが持ちます。
アクセスメソッドには、実際のインデックスの親テーブルからのタプルの取り出しやタプルがスキャンの可視性テストや他の条件を通過したかどうかの決定は含まれ<emphasis>ません</emphasis>。
  </para>

  <para>
<!--
   A scan key is the internal representation of a <literal>WHERE</literal> clause of
   the form <replaceable>index_key</replaceable> <replaceable>operator</replaceable>
   <replaceable>constant</replaceable>, where the index key is one of the columns of the
   index and the operator is one of the members of the operator family
   associated with that index column.  An index scan has zero or more scan
   keys, which are implicitly ANDed &mdash; the returned tuples are expected
   to satisfy all the indicated conditions.
-->
スキャンキーは、<replaceable>index_key</replaceable> <replaceable>operator</replaceable> <replaceable>constant</replaceable>という形式の<literal>WHERE</literal>句の内部的表現です。
ここで、<replaceable>index_key</replaceable>は、インデックス列の1つで、<replaceable>operator</replaceable>はインデックス列に関連した演算子族のメンバの1つです。
インデックススキャンは、暗黙的にAND演算される0個以上のスキャンキーを持ちます。
返されるタプルは指定された条件を満たすものと想定されます。
  </para>

  <para>
<!--
   The access method can report that the index is <firstterm>lossy</firstterm>, or
   requires rechecks, for a particular query.  This implies that the index
   scan will return all the entries that pass the scan key, plus possibly
   additional entries that do not.  The core system's index-scan machinery
   will then apply the index conditions again to the heap tuple to verify
   whether or not it really should be selected.  If the recheck option is not
   specified, the index scan must return exactly the set of matching entries.
-->
アクセスメソッドはインデックスがある特定の問い合わせに対し<firstterm>非可逆</firstterm>、または再検査を要求するかどうかを報告することができます。
これは、インデックススキャンがスキャンキーを満たすすべての項目と、それに加えて、満たさない可能性のある項目を返すことを意味します。
コアシステムのインデックススキャン機構はヒープタプルに対し、本当に選択されるべきかどうかを検証するためにその演算子をインデックス条件に再度適用します。
再検査オプションが指定されない場合、インデックススキャンは一致する項目の集合を返さなければなりません。
  </para>

  <para>
<!--
   Note that it is entirely up to the access method to ensure that it
   correctly finds all and only the entries passing all the given scan keys.
   Also, the core system will simply hand off all the <literal>WHERE</literal>
   clauses that match the index keys and operator families, without any
   semantic analysis to determine whether they are redundant or
   contradictory.  As an example, given
   <literal>WHERE x &gt; 4 AND x &gt; 14</literal> where <literal>x</literal> is a b-tree
   indexed column, it is left to the b-tree <function>amrescan</function> function
   to realize that the first scan key is redundant and can be discarded.
   The extent of preprocessing needed during <function>amrescan</function> will
   depend on the extent to which the index access method needs to reduce
   the scan keys to a <quote>normalized</quote> form.
-->
確実に、指定されたスキャンキーすべてに一致するもののみをすべて正しく見つけ出すことは、完全にアクセスメソッドの責任であることに注意してください。
また、コアシステムは、冗長かどうかや矛盾するかどうかを決定するための意味的な解析を行わず、単にインデックスキーと演算子族に一致する<literal>WHERE</literal>句をすべて渡します。
例えば、<literal>WHERE x &gt; 4 AND x &gt; 14</literal>があり、<literal>x</literal>がB-treeインデックス列であったとすると、これは、B-tree <function>amrescan</function>関数に任されて、最初のスキャンキーが冗長であり、無視できることが認知されます。
<function>amrescan</function>における前処理の必要性は、インデックスアクセスメソッドがスキャンキーを<quote>正規化</quote>形式にする必要があるかどうかに依存します。
  </para>

  <para>
<!--
   Some access methods return index entries in a well-defined order, others
   do not.  There are actually two different ways that an access method can
   support sorted output:
-->
一部のアクセスメソッドは、他では行いませんが、十分に定義された順序でインデックス項目を返します。
アクセスメソッドが出力の順序付けをサポートできるようにする方法は、実質２種類存在します。

    <itemizedlist>
     <listitem>
      <para>
<!--
       Access methods that always return entries in the natural ordering
       of their data (such as btree) should set
       <structfield>amcanorder</structfield> to true.
       Currently, such access methods must use btree-compatible strategy
       numbers for their equality and ordering operators.
-->
常にそのデータ（btreeなど）の自然な順序で項目を返すアクセスメソッドは<structfield>amcanorder</structfield>を真に設定しなければなりません。
現在、こうしたアクセスメソッドは、その等価性と順序付け演算子でbtree互換の戦略番号を使用しなければなりません。
      </para>
     </listitem>
     <listitem>
      <para>
<!--
       Access methods that support ordering operators should set
       <structfield>amcanorderbyop</structfield> to true.
       This indicates that the index is capable of returning entries in
       an order satisfying <literal>ORDER BY</literal> <replaceable>index_key</replaceable>
       <replaceable>operator</replaceable> <replaceable>constant</replaceable>.  Scan modifiers
       of that form can be passed to <function>amrescan</function> as described
       previously.
-->
順序付け演算子をサポートするアクセスメソッドは<structfield>amcanorderbyop</structfield>を真に設定しなければなりません。
これは、インデックスが<literal>ORDER BY</literal> <replaceable>index_key</replaceable> <replaceable>operator</replaceable> <replaceable>constant</replaceable>を満たす順序で項目を返すことができることを示します。
前述の通り、この形式のスキャン修飾子を<function>amrescan</function>に渡すことができます。
      </para>
     </listitem>
    </itemizedlist>
  </para>

  <para>
<!--
   The <function>amgettuple</function> function has a <literal>direction</literal> argument,
   which can be either <literal>ForwardScanDirection</literal> (the normal case)
   or  <literal>BackwardScanDirection</literal>.  If the first call after
   <function>amrescan</function> specifies <literal>BackwardScanDirection</literal>, then the
   set of matching index entries is to be scanned back-to-front rather than in
   the normal front-to-back direction, so <function>amgettuple</function> must return
   the last matching tuple in the index, rather than the first one as it
   normally would.  (This will only occur for access
   methods that set <structfield>amcanorder</structfield> to true.)  After the
   first call, <function>amgettuple</function> must be prepared to advance the scan in
   either direction from the most recently returned entry.  (But if
   <structfield>amcanbackward</structfield> is false, all subsequent
   calls will have the same direction as the first one.)
-->
<function>amgettuple</function>関数は<literal>direction</literal>引数を持ちます。
これは<literal>ForwardScanDirection</literal>（通常の場合）または<literal>BackwardScanDirection</literal>のいずれかを取ることができます。
<function>amrescan</function>後の最初の呼び出しが<literal>BackwardScanDirection</literal>を指定していた場合、一致したインデックス項目は通常の前から後ろという方向ではなく、後ろから前という方向でスキャンされます。
そのため、<function>amgettuple</function>は通常ならばインデックス内の最初に一致したタプルを返すところですが、最後に一致したタプルを返さなければなりません。
（これは<structfield>amcanorder</structfield>が真に設定されたアクセスメソッドでのみ発生します。）
最初の呼び出しの後、<function>amgettuple</function>は、最も最近に返された項目からどちらの方向にスキャンを進めるかを準備しなければなりません。
（しかし<structfield>amcanbackward</structfield>が偽であれば、引き続くすべての呼び出しは最初のものと同じ方向を持ちます。）
  </para>

  <para>
<!--
   Access methods that support ordered scans must support <quote>marking</quote> a
   position in a scan and later returning to the marked position.  The same
   position might be restored multiple times.  However, only one position need
   be remembered per scan; a new <function>ammarkpos</function> call overrides the
   previously marked position.  An access method that does not support ordered
   scans need not provide <function>ammarkpos</function> and <function>amrestrpos</function>
   functions in <structname>IndexAmRoutine</structname>; set those pointers to NULL
   instead.
-->
順序付けされたスキャンを提供するアクセスメソッドはスキャン内位置の<quote>記録</quote>をサポートしなければならず、また、後でその記録された位置に戻ることをサポートしなければなりません。
同じ位置が複数回記録されるかもしれません。
しかし、スキャン内の1つの位置のみを記録する必要があります。
新しい<function>ammarkpos</function>呼び出しにより前回記録された位置は上書きされます。
順序付けされたスキャンをサポートしないアクセスメソッドは<structname>IndexAmRoutine</structname>で<function>ammarkpos</function>関数および<function>amrestrpos</function>関数を提供する必要はないので、これらのポインタをNULLにセットしてください。
  </para>

  <para>
<!--
   Both the scan position and the mark position (if any) must be maintained
   consistently in the face of concurrent insertions or deletions in the
   index.  It is OK if a freshly-inserted entry is not returned by a scan that
   would have found the entry if it had existed when the scan started, or for
   the scan to return such an entry upon rescanning or backing
   up even though it had not been returned the first time through.  Similarly,
   a concurrent delete might or might not be reflected in the results of a scan.
   What is important is that insertions or deletions not cause the scan to
   miss or multiply return entries that were not themselves being inserted or
   deleted.
-->
スキャン位置と記録された位置（もしあれば）の両方は、インデックス内の同時挿入や削除という観点における一貫性を保持しなければなりません。
スキャンが始まった時に存在していた場合、項目を見つけ出したスキャンが新しく挿入された項目を返さなかったとしても問題ありません。
このような場合のスキャンでは、再スキャンやバックアップによって、あたかも最初の時点で返されたものとして項目が返されます。
同様に、同時実行削除によってスキャンの結果に影響が出るかもしれません。
重要なことは、挿入や削除によって、その項目自体が挿入・削除されていない項目がスキャンで失われたり二重になったりすることが起こらないという点です。
  </para>

  <para>
<!--
   If the index stores the original indexed data values (and not some lossy
   representation of them), it is useful to
   support <link linkend="indexes-index-only-scans">index-only scans</link>, in
   which the index returns the actual data not just the TID of the heap tuple.
   This will only avoid I/O if the visibility map shows that the TID is on an
   all-visible page; else the heap tuple must be visited anyway to check
   MVCC visibility.  But that is no concern of the access method's.
-->
インデックスが設定された列値がインデックスに格納されている(かつ、不可逆表現ではない)場合、ヒープタプルのTIDではなくインデックスに格納された実際のデータを返す<link linkend="indexes-index-only-scans">インデックスオンリースキャン</link>をサポートするのに有用です。
これは、可視性マップによってTIDが全可視のページ上にあると判断できる場合にI/Oを避けるだけのことです。
判断できない場合はMVCCを確認するためにヒープタプルにアクセスしなくてはなりません。
しかしその動作はアクセスメソッドでは考慮されていません。
  </para>

  <para>
<!--
   Instead of using <function>amgettuple</function>, an index scan can be done with
   <function>amgetbitmap</function> to fetch all tuples in one call.  This can be
   noticeably more efficient than <function>amgettuple</function> because it allows
   avoiding lock/unlock cycles within the access method.  In principle
   <function>amgetbitmap</function> should have the same effects as repeated
   <function>amgettuple</function> calls, but we impose several restrictions to
   simplify matters.  First of all, <function>amgetbitmap</function> returns all
   tuples at once and marking or restoring scan positions isn't
   supported. Secondly, the tuples are returned in a bitmap which doesn't
   have any specific ordering, which is why <function>amgetbitmap</function> doesn't
   take a <literal>direction</literal> argument.  (Ordering operators will never be
   supplied for such a scan, either.)
   Also, there is no provision for index-only scans with
   <function>amgetbitmap</function>, since there is no way to return the contents of
   index tuples.
   Finally, <function>amgetbitmap</function>
   does not guarantee any locking of the returned tuples, with implications
   spelled out in <xref linkend="index-locking"/>.
-->
<function>amgettuple</function>を使用する代わりに、<function>amgetbitmap</function>を使用して、一回の呼出しですべてのタプルを取り出してインデックススキャンを行うことができます。
これはアクセスメソッド内でのロック/ロック解除という過程を防ぐことができますので、<function>amgettuple</function>よりもかなり効率的です。
実際には、<function>amgetbitmap</function>は<function>amgettuple</function>呼び出しを繰り返すことと同じ効果を持つはずですが、物事を単純化するために複数の制限を加えています。
まず第一に、<function>amgetbitmap</function>は一回ですべてのタプルを返し、スキャン位置の記録と位置戻しをサポートしません。
第二に、特定の順序付けをまったく持たないビットマップの中にタプルが返されます。
これは<function>amgetbitmap</function>が<literal>direction</literal>引数を取らない理由です。
（順序付け演算子はこのようなスキャンでは決して与えられません。）
また、<function>amgetbitmap</function>によるインデックスオンリースキャンは提供されていません。なぜなら、インデックスタプルの内容を返す手段がないからです。
最後に、<function>amgetbitmap</function>は返されたタプルに関し、<xref linkend="index-locking"/>に記載した意味でのロックを保証しません。
  </para>

  <para>
<!--
   Note that it is permitted for an access method to implement only
   <function>amgetbitmap</function> and not <function>amgettuple</function>, or vice versa,
   if its internal implementation is unsuited to one API or the other.
-->
アクセスメソッドの内部実装がどちらか片方のAPIにそぐわない場合、<function>amgettuple</function>を実装せず<function>amgetbitmap</function>のみを実装、またはその逆も許されていることに注意してください。
  </para>

 </sect1>

 <sect1 id="index-locking">
<!--
  <title>Index Locking Considerations</title>
-->
  <title>インデックスのロック処理に関する検討</title>

  <para>
<!--
   Index access methods must handle concurrent updates
   of the index by multiple processes.
   The core <productname>PostgreSQL</productname> system obtains
   <literal>AccessShareLock</literal> on the index during an index scan, and
   <literal>RowExclusiveLock</literal> when updating the index (including plain
   <command>VACUUM</command>).  Since these lock types do not conflict, the access
   method is responsible for handling any fine-grained locking it might need.
   An exclusive lock on the index as a whole will be taken only during index
   creation, destruction, or <command>REINDEX</command>.
-->
インデックスアクセスメソッドは、複数のプロセスによるインデックスの同時更新を取り扱えなければなりません。
<productname>PostgreSQL</productname>コアシステムはインデックススキャン中にインデックスに対して<literal>AccessShareLock</literal>を獲得します。
また、（通常の<command>VACUUM</command>を含む）インデックスの更新中に<literal>RowExclusiveLock</literal>を獲得します。
これらの種類のロックは競合しませんので、アクセスメソッドは必要になるかもしれない粒度の細かなロック処理に関して責任を持ちます。
インデックスの生成、破棄、<literal>REINDEX</literal>時にインデックス全体に対する排他ロックが獲得されます。
  </para>

  <para>
<!--
   Building an index type that supports concurrent updates usually requires
   extensive and subtle analysis of the required behavior.  For the b-tree
   and hash index types, you can read about the design decisions involved in
   <filename>src/backend/access/nbtree/README</filename> and
   <filename>src/backend/access/hash/README</filename>.
-->
同時更新をサポートするインデックス種類を構築することは通常、必要な動作について広範かつ微細にわたる解析が必要です。
B-treeおよびハッシュインデックス種類では、<filename>src/backend/access/nbtree/README</filename>と <filename>src/backend/access/hash/README</filename>にある設計に関する決定事項を読むことができます。
  </para>

  <para>
<!--
   Aside from the index's own internal consistency requirements, concurrent
   updates create issues about consistency between the parent table (the
   <firstterm>heap</firstterm>) and the index.  Because
   <productname>PostgreSQL</productname> separates accesses
   and updates of the heap from those of the index, there are windows in
   which the index might be inconsistent with the heap.  We handle this problem
   with the following rules:
-->
インデックス自身の内部的な一貫性要求の他に、同時実行更新には、親テーブル（<firstterm>ヒープ</firstterm>）とインデックス間の一貫性に関する問題が発生します。
<productname>PostgreSQL</productname>はヒープへのアクセスおよび更新とインデックスへのアクセスおよび更新を分離していますので、インデックスとヒープとの間の一貫性が無くなる間隔が存在します。
以下の規則でこうした問題を扱います。

    <itemizedlist>
     <listitem>
      <para>
<!--
       A new heap entry is made before making its index entries.  (Therefore
       a concurrent index scan is likely to fail to see the heap entry.
       This is okay because the index reader would be uninterested in an
       uncommitted row anyway.  But see <xref linkend="index-unique-checks"/>.)
-->
新しいヒープ項目はインデックス項目を作成する前に作成されます。
（このため、同時実行インデックススキャンはヒープエントリを確認する時によく失敗します。
インデックスの読み取りは、未コミットの行を対象としませんので問題ありません。
しかし、<xref linkend="index-unique-checks"/>を参照してください。）
      </para>
     </listitem>
     <listitem>
      <para>
<!--
       When a heap entry is to be deleted (by <command>VACUUM</command>), all its
       index entries must be removed first.
-->
ヒープエントリが（<command>VACUUM</command>によって）削除される時、これに対するすべてのインデックス項目が先に削除されます。
      </para>
     </listitem>
     <listitem>
      <para>
<!--
       An index scan must maintain a pin
       on the index page holding the item last returned by
       <function>amgettuple</function>, and <function>ambulkdelete</function> cannot delete
       entries from pages that are pinned by other backends.  The need
       for this rule is explained below.
-->
インデックススキャンは、最後に<function>amgettuple</function>が返した項目を保持するインデックスページ上のピンを管理しなければなりません。
また、<function>ambulkdelete</function>は、他のバックエンドがピンを持つページから項目を削除することはできません。
この規則の必要性については後で説明します。
      </para>
     </listitem>
    </itemizedlist>

<!--
   Without the third rule, it is possible for an index reader to
   see an index entry just before it is removed by <command>VACUUM</command>, and
   then to arrive at the corresponding heap entry after that was removed by
   <command>VACUUM</command>.
   This creates no serious problems if that item
   number is still unused when the reader reaches it, since an empty
   item slot will be ignored by <function>heap_fetch()</function>.  But what if a
   third backend has already re-used the item slot for something else?
   When using an MVCC-compliant snapshot, there is no problem because
   the new occupant of the slot is certain to be too new to pass the
   snapshot test.  However, with a non-MVCC-compliant snapshot (such as
   <literal>SnapshotAny</literal>), it would be possible to accept and return
   a row that does not in fact match the scan keys.  We could defend
   against this scenario by requiring the scan keys to be rechecked
   against the heap row in all cases, but that is too expensive.  Instead,
   we use a pin on an index page as a proxy to indicate that the reader
   might still be <quote>in flight</quote> from the index entry to the matching
   heap entry.  Making <function>ambulkdelete</function> block on such a pin ensures
   that <command>VACUUM</command> cannot delete the heap entry before the reader
   is done with it.  This solution costs little in run time, and adds blocking
   overhead only in the rare cases where there actually is a conflict.
-->
３番目の規則がないと、<command>VACUUM</command>によって削除される直前に、インデックス読み取りがインデックス項目を見つけ、そして、<command>VACUUM</command>によって削除された後に対応するヒープ項目に達する可能性があります。
空の項目スロットは<function>heap_fetch()</function>で無視されますので、これは読み取りが達した時にその項目番号が未使用である場合でも大きな問題は起こりません。
しかし、第三のバックエンドがすでにその項目スロットを他のものに再使用した場合はどうなるでしょうか？
そのスロット内の新しいものが、スナップショット試験を通過するには新しすぎることが確実ですので、MVCCに則ったスナップショットを使用する場合は問題ありません。
しかし、MVCCに則らないスナップショット(<literal>SnapshotNow</literal>など)では、実際にはスキャンキーに合わない行を受付け、返す可能性があります。
すべての場合においてヒープ行に対しスキャンキーの再検査を行うことを必須とすることで、こうした状況から保護することができますが、これは高価すぎます。
代わりに、読み取りがまだ一致するヒープ項目へのインデックス項目の<quote>作業中</quote>であることを示す代理として、インデックスページに対するピンを使用します。
このピンに対して<function>ambulkdelete</function>がブロックするようにすることで、読み取りの作業が終わる前に<command>VACUUM</command>がそのヒープ項目を削除できないことを確実にします。
実行時におけるこの対策のコストは小さく、実際に競合が発生するごく稀な場合にのみブロックするためのオーバーヘッドが加わります。
  </para>

  <para>
<!--
   This solution requires that index scans be <quote>synchronous</quote>: we have
   to fetch each heap tuple immediately after scanning the corresponding index
   entry.  This is expensive for a number of reasons.  An
   <quote>asynchronous</quote> scan in which we collect many TIDs from the index,
   and only visit the heap tuples sometime later, requires much less index
   locking overhead and can allow a more efficient heap access pattern.
   Per the above analysis, we must use the synchronous approach for
   non-MVCC-compliant snapshots, but an asynchronous scan is workable
   for a query using an MVCC snapshot.
-->
この対策は、インデックススキャンが<quote>同期</quote>していることを要求します。
対応するインデックス項目のスキャンの後即座に各ヒープタプルを取り出さなければなりません。
多くの理由のため、これは高価です。
インデックスから多くのTIDを収集し、少し後でのみヒープタプルにアクセスする<quote>非同期</quote>スキャンでは、必要なロック処理オーバーヘッドがかなり少なくなり、また、より効率的なヒープへのアクセスパターンを取ることができます。
上の解析に従うと、MVCCに則らないスナップショットでは同期方式を使用しなければなりませんが、問い合わせがMVCCスナップショットを使用する場合は非同期スキャンを使用することができます。
  </para>

  <para>
<!--
   In an <function>amgetbitmap</function> index scan, the access method does not
   keep an index pin on any of the returned tuples.  Therefore
   it is only safe to use such scans with MVCC-compliant snapshots.
-->
<function>amgetbitmap</function>インデックススキャンでは、アクセスメソッドは返されるタプル上にインデックスピンをまったく保持しません。
したがって、MVCCに則ったスナップショットでこうしたスキャンを使用することのみが安全です。
  </para>

  <para>
<!--
   When the <structfield>ampredlocks</structfield> flag is not set, any scan using that
   index access method within a serializable transaction will acquire a
   nonblocking predicate lock on the full index.  This will generate a
   read-write conflict with the insert of any tuple into that index by a
   concurrent serializable transaction.  If certain patterns of read-write
   conflicts are detected among a set of concurrent serializable
   transactions, one of those transactions may be canceled to protect data
   integrity.  When the flag is set, it indicates that the index access
   method implements finer-grained predicate locking, which will tend to
   reduce the frequency of such transaction cancellations.
-->
<structfield>ampredlocks</structfield>フラグが設定されていない場合、シリアライザブルトランザクション内でそのインデックスアクセスメソッドを使用するスキャンはいずれもインデックス全体に対するブロックしない述語ロックを獲得します。
これは、同時実行のシリアライザブルトランザクションによるそのインデックスへの何らかのタプル挿入で、読み書きの競合が発生することがあります。
同時実行のシリアライザブルトランザクションの集合の中で特定の読み書きの競合パターンが検知された場合、データの整合性を保護するためにこれらのトランザクションの１つはキャンセルされます。
このフラグが設定されている場合、こうしたトランザクションのキャンセルの頻度を低減することになる、より粒度の細かな述語ロックをインデックスアクセスメソッドが実装していることを示します。
  </para>

 </sect1>

 <sect1 id="index-unique-checks">
<!--
  <title>Index Uniqueness Checks</title>
-->
  <title>インデックス一意性検査</title>

  <para>
<!--
   <productname>PostgreSQL</productname> enforces SQL uniqueness constraints
   using <firstterm>unique indexes</firstterm>, which are indexes that disallow
   multiple entries with identical keys.  An access method that supports this
   feature sets <structfield>amcanunique</structfield> true.
   (At present, only b-tree supports it.)  Columns listed in the
   <literal>INCLUDE</literal> clause are not considered when enforcing
   uniqueness.
-->
<productname>PostgreSQL</productname>は、SQLの一意性制約を<firstterm>一意性インデックス</firstterm>を使用して強制します。
このインデックスでは、同一キーに対し複数の項目を許しません。
この機能をサポートするアクセスメソッドは<structfield>amcanunique</structfield>を真に設定します。
（現時点ではb-treeのみがこれをサポートします。）
<literal>INCLUDE</literal>句内の列のリストは、一意性制約の強制時には考慮されません。
  </para>

  <para>
<!--
   Because of MVCC, it is always necessary to allow duplicate entries to
   exist physically in an index: the entries might refer to successive
   versions of a single logical row.  The behavior we actually want to
   enforce is that no MVCC snapshot could include two rows with equal
   index keys.  This breaks down into the following cases that must be
   checked when inserting a new row into a unique index:
-->
MVCCのため、インデックス内に物理的に重複した項目が存在できることが常に必要です。
これらの項目は１つの論理的な行の連続的なバージョンを示します。
実際に強制させたい動作は、MVCCスナップショットが同じインデックスキーを持つ行を２つ含めないことです。
一意性インデックスに新しい行を挿入する時に検査しなければならない状況を以下のように分割することができます。

    <itemizedlist>
     <listitem>
      <para>
<!--
       If a conflicting valid row has been deleted by the current transaction,
       it's okay.  (In particular, since an UPDATE always deletes the old row
       version before inserting the new version, this will allow an UPDATE on
       a row without changing the key.)
-->
競合する有効な行が現在のトランザクションで削除された場合は問題ありません。
（具体的には、UPDATEは常に新しいバージョンを挿入する前に古い行バージョンを削除します。
これによりキーを変更することなく行をUPDATEすることができます。）
      </para>
     </listitem>
     <listitem>
      <para>
<!--
       If a conflicting row has been inserted by an as-yet-uncommitted
       transaction, the would-be inserter must wait to see if that transaction
       commits.  If it rolls back then there is no conflict.  If it commits
       without deleting the conflicting row again, there is a uniqueness
       violation.  (In practice we just wait for the other transaction to
       end and then redo the visibility check in toto.)
-->
競合する行が未コミットのトランザクションで挿入された場合、挿入しようとしている方はトランザクションのコミットが分かるまで待機しなければなりません。
ロールバックした場合は競合しません。
競合する行が削除されずにコミットした場合、一意性違反となります。
（具体的には、他のトランザクションの終了をただ待機し、終了後に可視性の検査を完全に再実行します。）
      </para>
     </listitem>
     <listitem>
      <para>
<!--
       Similarly, if a conflicting valid row has been deleted by an
       as-yet-uncommitted transaction, the would-be inserter must wait
       for that transaction to commit or abort, and then repeat the test.
-->
同様に、競合する有効な行が未コミットのトランザクションで削除された場合、挿入しようとしている方はトランザクションのコミットまたはアボートを待機しなければならず、その後、試験を繰り返します。
      </para>
     </listitem>
    </itemizedlist>
  </para>

  <para>
<!--
   Furthermore, immediately before reporting a uniqueness violation
   according to the above rules, the access method must recheck the
   liveness of the row being inserted.  If it is committed dead then
   no violation should be reported.  (This case cannot occur during the
   ordinary scenario of inserting a row that's just been created by
   the current transaction.  It can happen during
   <command>CREATE UNIQUE INDEX CONCURRENTLY</command>, however.)
-->
さらに、上記規則に従った一意性違反を報告する直前に、アクセスメソッドは挿入される行の有効性を再度検査しなければなりません。
もし、無効なコミットであれば、違反を報告してはいけません。
（現在のトランザクションによって作成された通常の行の挿入という状況では、これは発生することはありません。
しかし、これは<command>CREATE UNIQUE INDEX CONCURRENTLY</command>中に発生することがあります。）
  </para>

  <para>
<!--
   We require the index access method to apply these tests itself, which
   means that it must reach into the heap to check the commit status of
   any row that is shown to have a duplicate key according to the index
   contents.  This is without a doubt ugly and non-modular, but it saves
   redundant work: if we did a separate probe then the index lookup for
   a conflicting row would be essentially repeated while finding the place to
   insert the new row's index entry.  What's more, there is no obvious way
   to avoid race conditions unless the conflict check is an integral part
   of insertion of the new index entry.
-->
インデックスアクセスメソッドにこうした試験を自身で行うことを要求します。
これは、インデックスの内容に対して重複するキーを持つことを示している任意の行のコミット状態を検査するために、ヒープまでアクセスしなければならないことを意味します。
これが醜くモジュール化されないことには疑う余地はありません。
しかし、余計な作業を防ぐことができます。
もし分離された探査を行ったとすると、新しいインデックス項目を挿入する場所を検索する時、競合する行に対するインデックス検索がどうしても繰り返されます。
さらに、競合検査がインデックス行の挿入部分で統合されて行われない限り、競合状態を防ぐ明確な方法がありません。
  </para>

  <para>
<!--
   If the unique constraint is deferrable, there is additional complexity:
   we need to be able to insert an index entry for a new row, but defer any
   uniqueness-violation error until end of statement or even later.  To
   avoid unnecessary repeat searches of the index, the index access method
   should do a preliminary uniqueness check during the initial insertion.
   If this shows that there is definitely no conflicting live tuple, we
   are done.  Otherwise, we schedule a recheck to occur when it is time to
   enforce the constraint.  If, at the time of the recheck, both the inserted
   tuple and some other tuple with the same key are live, then the error
   must be reported.  (Note that for this purpose, <quote>live</quote> actually
   means <quote>any tuple in the index entry's HOT chain is live</quote>.)
   To implement this, the <function>aminsert</function> function is passed a
   <literal>checkUnique</literal> parameter having one of the following values:
-->
一意性制約が遅延可能である場合はさらに複雑になります。
新しい行向けのインデックス項目を挿入可能にする必要があります。
しかし一意性違反エラーは文の終わりまたはそれ以降まで遅延されます。
不要なインデックス検索の繰り返しを防ぐために、インデックスアクセスメソッドは初期の挿入の間に前座の一意性検査を行わなければなりません。
これが現存するタプルとまったく競合がないことを示した場合、それで終了です。
さもなければ、制約を強制する時に再検査を行うようスケジュールします。
再検査の時点で対象のタプルと同じキーを持つ何らかの他のタプルが存在すると、エラーを報告しなければなりません。
（この目的のために<quote>存在する</quote>は実際には<quote>インデックス項目のHOTチェイン内に何らかのタプルが存在する</quote>ことを意味します。）
これを実装するために、<function>aminsert</function>は以下のいずれかの値を持つ<literal>checkUnique</literal>パラメータを渡されます。

    <itemizedlist>
     <listitem>
      <para>
<!--
       <literal>UNIQUE_CHECK_NO</literal> indicates that no uniqueness checking
       should be done (this is not a unique index).
-->
<literal>UNIQUE_CHECK_NO</literal>は、一意性検査を行うことはない(これは一意性インデックスではない)ことを示します。
      </para>
     </listitem>
     <listitem>
      <para>
<!--
       <literal>UNIQUE_CHECK_YES</literal> indicates that this is a non-deferrable
       unique index, and the uniqueness check must be done immediately, as
       described above.
-->
<literal>UNIQUE_CHECK_YES</literal>は、上述の通り遅延がない一意性インデックスであり、一意性検査を即時に行わなければならないことを示します。
      </para>
     </listitem>
     <listitem>
      <para>
<!--
       <literal>UNIQUE_CHECK_PARTIAL</literal> indicates that the unique
       constraint is deferrable. <productname>PostgreSQL</productname>
       will use this mode to insert each row's index entry.  The access
       method must allow duplicate entries into the index, and report any
       potential duplicates by returning false from <function>aminsert</function>.
       For each row for which false is returned, a deferred recheck will
       be scheduled.
-->
<literal>UNIQUE_CHECK_PARTIAL</literal>は一意性制約が遅延可能であることを示します。
<productname>PostgreSQL</productname>はこのモードを使用して、各行のインデックス項目を挿入します。
このアクセスメソッドはインデックス内の重複する項目を許さなければなりません。
そして<function>aminsert</function>から偽を返すことで重複の可能性があることを報告しなければなりません。
偽が返された行それぞれに対して、遅延再検査が予定されます。
      </para>

      <para>
<!--
       The access method must identify any rows which might violate the
       unique constraint, but it is not an error for it to report false
       positives. This allows the check to be done without waiting for other
       transactions to finish; conflicts reported here are not treated as
       errors and will be rechecked later, by which time they may no longer
       be conflicts.
-->
アクセスメソッドは一意性制約違反となるかもしれない行を識別しなければなりません。
しかし間違った偽を報告することはエラーではありません。
これにより他のトランザクションを待つことなく検査を行うことができます。
ここで報告された重複はエラーとして扱われず、後で再検査されます。
再検査時には重複しなくなっている可能性があります。
      </para>
     </listitem>
     <listitem>
      <para>
<!--
       <literal>UNIQUE_CHECK_EXISTING</literal> indicates that this is a deferred
       recheck of a row that was reported as a potential uniqueness violation.
       Although this is implemented by calling <function>aminsert</function>, the
       access method must <emphasis>not</emphasis> insert a new index entry in this
       case.  The index entry is already present.  Rather, the access method
       must check to see if there is another live index entry.  If so, and
       if the target row is also still live, report error.
-->
<literal>UNIQUE_CHECK_EXISTING</literal>は、一意性違反の可能性があると報告された行に対する遅延再検査であることを示します。
これは<function>aminsert</function>を呼び出すことで実装されますが、アクセスメソッドはこの場合に新しいインデックス項目を挿入しては<emphasis>いけません</emphasis>。
インデックス項目はすでに存在します。
それよりも、アクセスメソッドは他に存在するインデックス項目があるか検査する必要があります。
もし存在し、対象の行もまだ存在する場合エラーを報告します。
      </para>

      <para>
<!--
       It is recommended that in a <literal>UNIQUE_CHECK_EXISTING</literal> call,
       the access method further verify that the target row actually does
       have an existing entry in the index, and report error if not.  This
       is a good idea because the index tuple values passed to
       <function>aminsert</function> will have been recomputed.  If the index
       definition involves functions that are not really immutable, we
       might be checking the wrong area of the index.  Checking that the
       target row is found in the recheck verifies that we are scanning
       for the same tuple values as were used in the original insertion.
-->
<literal>UNIQUE_CHECK_EXISTING</literal>呼び出しでは、アクセスメソッドはさらに対象行が実際にインデックス内に既存の項目を持つか検証し、もしなければエラーを報告することを推奨します。
<function>aminsert</function>に渡されるインデックスタプル値が再計算されているため勧めます。
インデックス定義に実際には不変ではない関数が含まれる場合、インデックスの間違った領域を検査してしまうかもしれません。
再検査にて対象行の存在を検査することで、元の挿入で使用されたものと同じタプル値をスキャンしていることを検証します。
      </para>
     </listitem>
    </itemizedlist>
  </para>

 </sect1>

 <sect1 id="index-cost-estimation">
<!--
  <title>Index Cost Estimation Functions</title>
-->
  <title>インデックスコスト推定関数</title>

  <para>
<!--
   The <function>amcostestimate</function> function is given information describing
   a possible index scan, including lists of WHERE and ORDER BY clauses that
   have been determined to be usable with the index.  It must return estimates
   of the cost of accessing the index and the selectivity of the WHERE
   clauses (that is, the fraction of parent-table rows that will be
   retrieved during the index scan).  For simple cases, nearly all the
   work of the cost estimator can be done by calling standard routines
   in the optimizer; the point of having an <function>amcostestimate</function> function is
   to allow index access methods to provide index-type-specific knowledge,
   in case it is possible to improve on the standard estimates.
-->
<function>amcostestimate</function>関数には、インデックスと共に使用できることが決まっているWHERE句およびORDER BY句のリストを含む、インデックススキャンの可能性を記述する情報が与えられます。
この関数はインデックスにアクセスするコストの概算とWHERE句の選択度（つまりインデックススキャンにて抽出される行の親テーブルにおける割合）を返さなくてはなりません。
単純な場合だと、ほとんどすべてのコスト概算の作業は、オプティマイザの標準ルーチンを呼び出すことで行われます。
<function>amcostestimate</function>関数を持つことの意味は、標準の概算を改善することができる場合に、インデックスアクセスメソッドがインデックス型固有の知識体系を提供することができるということです。
  </para>

  <para>
<!--
   Each <function>amcostestimate</function> function must have the signature:
-->
それぞれの<function>amcostestimate</function>関数は以下のシグネチャを持たなければいけません。

<programlisting>
void
amcostestimate (PlannerInfo *root,
                IndexPath *path,
                double loop_count,
                Cost *indexStartupCost,
                Cost *indexTotalCost,
                Selectivity *indexSelectivity,
                double *indexCorrelation,
                double *indexPages);
</programlisting>

<!--
   The first three parameters are inputs:
-->
最初の3つのパラメータは入力です。

   <variablelist>
    <varlistentry>
     <term><parameter>root</parameter></term>
     <listitem>
      <para>
<!--
       The planner's information about the query being processed.
-->
処理されている問い合わせに関するプランナの情報。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>path</parameter></term>
     <listitem>
      <para>
<!--
       The index access path being considered.  All fields except cost and
       selectivity values are valid.
-->
考慮されるインデックスアクセスパス。
コストと選択性値を除くすべてのフィールドが有効です。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>loop_count</parameter></term>
     <listitem>
      <para>
<!--
       The number of repetitions of the index scan that should be factored
       into the cost estimates.  This will typically be greater than one when
       considering a parameterized scan for use in the inside of a nestloop
       join.  Note that the cost estimates should still be for just one scan;
       a larger <parameter>loop_count</parameter> means that it may be appropriate
       to allow for some caching effects across multiple scans.
-->
コスト概算の算出対象となるインデックススキャンが繰り返された回数です。
これは通常、ネステッドループ結合の内部で利用されるパラメータ化されたスキャンの回数よりも大きい値になります。
コスト概算は1回のスキャンのための値であることに注意してください。<parameter>loop_count</parameter>がより大きい場合、複数のスキャンにより得られる効果をみるには十分な値といえるでしょう。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

  <para>
<!--
   The last five parameters are pass-by-reference outputs:
-->
最後の5つのパラメータは参照渡しの出力です。

   <variablelist>
    <varlistentry>
     <term><parameter>*indexStartupCost</parameter></term>
     <listitem>
      <para>
<!--
       Set to cost of index start-up processing
-->
インデックスの起動処理にかかるコストに設定されます。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>*indexTotalCost</parameter></term>
     <listitem>
      <para>
<!--
       Set to total cost of index processing
-->
インデックス処理の全体のコストに設定されます。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>*indexSelectivity</parameter></term>
     <listitem>
      <para>
<!--
       Set to index selectivity
-->
インデックスの選択度に設定されます。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>*indexCorrelation</parameter></term>
     <listitem>
      <para>
<!--
       Set to correlation coefficient between index scan order and
       underlying table's order
-->
インデックススキャンの順番と背後のテーブルの順番間の相関係数に設定されます。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>*indexPages</parameter></term>
     <listitem>
      <para>
<!--
       Set to number of index leaf pages
-->
インデックスのリーフページ数が設定されます。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

  <para>
<!--
   Note that cost estimate functions must be written in C, not in SQL or
   any available procedural language, because they must access internal
   data structures of the planner/optimizer.
-->
コスト概算関数は、SQLやその他の手続き言語ではなく、C言語で書かれなければいけないことに注意してください。
理由はプランナ/オプティマイザの内部データ構造にアクセスしなければいけないためです。
  </para>

  <para>
<!--
   The index access costs should be computed using the parameters used by
   <filename>src/backend/optimizer/path/costsize.c</filename>: a sequential
   disk block fetch has cost <varname>seq_page_cost</varname>, a nonsequential fetch
   has cost <varname>random_page_cost</varname>, and the cost of processing one index
   row should usually be taken as <varname>cpu_index_tuple_cost</varname>.  In
   addition, an appropriate multiple of <varname>cpu_operator_cost</varname> should
   be charged for any comparison operators invoked during index processing
   (especially evaluation of the indexquals themselves).
-->
インデックスアクセスコストは<filename>src/backend/optimizer/path/costsize.c</filename>で使われる、逐次的なディスクブロックの取り出しには<varname>seq_page_cost</varname>のコストが、順不同の取り出しには<varname>random_page_cost</varname>のコストが、そして、1つのインデックス行の処理には通常<varname>cpu_index_tuple_cost</varname>というコストがかかる、というパラメータで計算されなければなりません。
さらに、インデックス処理（特にindexquals自体の評価）の間に呼び出される比較演算すべてに対して、<varname>cpu_operator_cost</varname>に適当な係数をかけたコストがかかります。
  </para>

  <para>
<!--
   The access costs should include all disk and CPU costs associated with
   scanning the index itself, but <emphasis>not</emphasis> the costs of retrieving or
   processing the parent-table rows that are identified by the index.
-->
アクセスコストは、インデックス自身のスキャンと関係するすべてのディスクとCPUコストも含むべきですが、インデックスで識別される親テーブルの行の処理や抽出にかかるコストは含めては<emphasis>いけません</emphasis>。
  </para>

  <para>
<!--
   The <quote>start-up cost</quote> is the part of the total scan cost that
   must be expended before we can begin to fetch the first row.  For most
   indexes this can be taken as zero, but an index type with a high start-up
   cost might want to set it nonzero.
-->
<quote>起動用コスト</quote>は、最初の行を取り出し始めることができるようになる前に費やされなければならない総スキャンコストの一部です。
ほとんどのインデックスでは、これはゼロとすることができます。
しかし、高い起動用コストを持つインデックス種類ではこれを非ゼロにすることを勧めます。
  </para>

  <para>
<!--
   The <parameter>indexSelectivity</parameter> should be set to the estimated fraction of the parent
   table rows that will be retrieved during the index scan.  In the case
   of a lossy query, this will typically be higher than the fraction of
   rows that actually pass the given qual conditions.
-->
<parameter>indexSelectivity</parameter>は、インデックススキャンの間に抽出される親テーブルの行の概算された割合として設定されるべきです。
非可逆問い合わせの場合はこの値が、与えられた制約条件を実際に通過する行の割合よりも高くなることがよくあります。
  </para>

  <para>
<!--
   The <parameter>indexCorrelation</parameter> should be set to the correlation (ranging between
   -1.0 and 1.0) between the index order and the table order.  This is used
   to adjust the estimate for the cost of fetching rows from the parent
   table.
-->
<parameter>indexCorrelation</parameter>は、インデックスの順番とテーブルの順番の間の（-1.0から1.0までの間の値を取る）相関として設定されるべきです。
この値は、メインテーブルから行を取り出すためのコスト概算を調整するために使用されます。
  </para>

  <para>
<!--
   The <parameter>indexPages</parameter> should be set to the number of leaf pages.
   This is used to estimate the number of workers for parallel index scan.
-->
<parameter>indexPages</parameter>は、リーフページ数が設定されるべきです。
これは、パラレルインデックススキャンのワーカー数の見積もりに使用されます。
  </para>

  <para>
<!--
   When <parameter>loop_count</parameter> is greater than one, the returned numbers
   should be averages expected for any one scan of the index.
-->
<parameter>loop_count</parameter>の値が1より大きい場合、戻り値はインデックスを利用した1回のスキャンを想定した平均値であるべきです。
  </para>

  <procedure>
<!--
   <title>Cost Estimation</title>
-->
   <title>コスト概算</title>
   <para>
<!--
    A typical cost estimator will proceed as follows:
-->
典型的なコスト概算は次のように進められます。
   </para>

   <step>
    <para>
<!--
     Estimate and return the fraction of parent-table rows that will be visited
     based on the given qual conditions.  In the absence of any index-type-specific
     knowledge, use the standard optimizer function <function>clauselist_selectivity()</function>:
-->
与えられた制約条件に基づいて訪れられるメインテーブルの行の割合を概算して返します。
インデックス型固有の知識体系を持たない場合、標準のオプティマイザの関数である<function>clauselist_selectivity()</function>を使用してください。

<programlisting>
*indexSelectivity = clauselist_selectivity(root, path-&gt;indexquals,
                                           path-&gt;indexinfo-&gt;rel-&gt;relid,
                                           JOIN_INNER, NULL);
</programlisting>
    </para>
   </step>

   <step>
    <para>
<!--
     Estimate the number of index rows that will be visited during the
     scan.  For many index types this is the same as <parameter>indexSelectivity</parameter> times
     the number of rows in the index, but it might be more.  (Note that the
     index's size in pages and rows is available from the
     <literal>path-&gt;indexinfo</literal> struct.)
-->
スキャン中に訪れられるインデックスの行数を概算します。
多くのインデックス種類では、これは<parameter>indexSelectivity</parameter>とインデックスの中にある行数を掛けたものと等しいですが、それより多い場合もあります。
（ページおよび行内のインデックスのサイズは<literal>path-&gt;indexinfo</literal>構造体から得ることができることに注意してください。）
    </para>
   </step>

   <step>
    <para>
<!--
     Estimate the number of index pages that will be retrieved during the scan.
     This might be just <parameter>indexSelectivity</parameter> times the index's size in pages.
-->
スキャン中に抽出されるインデックスページ数を概算します。
これは単に<parameter>indexSelectivity</parameter>にページ内のインデックスのサイズを掛けたものになるでしょう。
    </para>
   </step>

   <step>
    <para>
<!--
     Compute the index access cost.  A generic estimator might do this:
-->
インデックスアクセスコストを計算します。
汎用的な概算においては以下のように行うでしょう。

<programlisting>
/*
<!--
 * Our generic assumption is that the index pages will be read
 * sequentially, so they cost seq_page_cost each, not random_page_cost.
 * Also, we charge for evaluation of the indexquals at each index row.
 * All the costs are assumed to be paid incrementally during the scan.
-->
 * 一般的な仮定は、インデックスページは逐次的に読まれるので、
 * random_page_costではなく、それぞれseq_page_costが掛かるというものです。
 * 各インデックス行でのindexqualsの評価にもコストが掛かります。
 * コストはすべてスキャンの間に徐々に支払われると仮定します。
 */
cost_qual_eval(&amp;index_qual_cost, path-&gt;indexquals, root);
*indexStartupCost = index_qual_cost.startup;
*indexTotalCost = seq_page_cost * numIndexPages +
    (cpu_index_tuple_cost + index_qual_cost.per_tuple) * numIndexTuples;
</programlisting>

<!--
     However, the above does not account for amortization of index reads
     across repeated index scans.
-->
しかし、上では繰り返されるインデックススキャンにかかるインデックス読み込みについて減価償却を考慮していません。
    </para>
   </step>

   <step>
    <para>
<!--
     Estimate the index correlation.  For a simple ordered index on a single
     field, this can be retrieved from pg_statistic.  If the correlation
     is not known, the conservative estimate is zero (no correlation).
-->
インデックスの相関を概算します。
1つのフィールドに対する単純な順番のインデックスでは、これはpg_statisticから入手することができます。
相関が未知の場合、概算を用心深く考えるとゼロ（無相関）となります。
    </para>
   </step>
  </procedure>

  <para>
<!--
   Examples of cost estimator functions can be found in
   <filename>src/backend/utils/adt/selfuncs.c</filename>.
-->
コスト概算関数の例は<filename>src/backend/utils/adt/selfuncs.c</filename>にあります。
  </para>
 </sect1>
</chapter>
