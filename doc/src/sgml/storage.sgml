<!-- doc/src/sgml/storage.sgml -->

<chapter id="storage">

<!--
<title>Database Physical Storage</title>
-->
<title>データベースの物理的な格納</title>

<para>
<!--
This chapter provides an overview of the physical storage format used by
<productname>PostgreSQL</productname> databases.
-->
本章では<productname>PostgreSQL</productname>データベースで使用される物理的格納書式についての概要を説明します。
</para>

<sect1 id="storage-file-layout">

<!--
<title>Database File Layout</title>
-->
<title>データベースファイルのレイアウト</title>

<para>
<!--
This section describes the storage format at the level of files and
directories.
-->
本節ではファイルとディレクトリというレベルで格納書式について説明します。
</para>

<para>
<!--
Traditionally, the configuration and data files used by a database
cluster are stored together within the cluster's data
directory, commonly referred to as <varname>PGDATA</varname> (after the name of the
environment variable that can be used to define it).  A common location for
<varname>PGDATA</varname> is <filename>/var/lib/pgsql/data</filename>.  Multiple clusters,
managed by different server instances, can exist on the same machine.
-->
伝統的に、データベースクラスタで利用される制御ファイルとデータファイルは、クラスタのデータディレクトリ内に一緒に格納され、通常（このディレクトリを定義するために使用できる環境変数名にちなんで）<varname>PGDATA</varname>として参照されます。
通常の<varname>PGDATA</varname>の位置は<filename>/var/lib/pgsql/data</filename>です。
異なるサーバインスタンスによって管理することで、複数のクラスタを同一のマシン上に存在させることができます。
</para>

<para>
<!--
The <varname>PGDATA</varname> directory contains several subdirectories and control
files, as shown in <xref linkend="pgdata-contents-table"/>.  In addition to
these required items, the cluster configuration files
<filename>postgresql.conf</filename>, <filename>pg_hba.conf</filename>, and
<filename>pg_ident.conf</filename> are traditionally stored in
<varname>PGDATA</varname>, although it is possible to place them elsewhere.
-->
<xref linkend="pgdata-contents-table"/>に示すように、<varname>PGDATA</varname>ディレクトリには数個のサブディレクトリと制御ファイルがあります。
これら必要な項目に加え、クラスタの設定ファイルである<filename>postgresql.conf</filename>、<filename>pg_hba.conf</filename>および<filename>pg_ident.conf</filename>が、他の場所にも置くことができますが、伝統的に<varname>PGDATA</varname>内に格納されます
</para>

<table tocentry="1" id="pgdata-contents-table">
<!--
<title>Contents of <varname>PGDATA</varname></title>
-->
<title><varname>PGDATA</varname>の内容</title>
<tgroup cols="2">
<thead>
<row>
<entry>
<!--
Item
-->
項目
</entry>
<!--
<entry>Description</entry>
-->
<entry>説明</entry>
</row>
</thead>

<tbody>

<row>
 <entry><filename>PG_VERSION</filename></entry>
<!--
 <entry>A file containing the major version number of <productname>PostgreSQL</productname></entry>
-->
 <entry><productname>PostgreSQL</productname>の主バージョン番号を保有するファイル</entry>
</row>

<row>
 <entry><filename>base</filename></entry>
<!--
 <entry>Subdirectory containing per-database subdirectories</entry>
-->
 <entry>データベースごとのサブディレクトリを保有するサブディレクトリ</entry>
</row>

<row>
 <entry><filename>current_logfiles</filename></entry>
<!--
 <entry>File recording the log file(s) currently written to by the logging
  collector</entry>
-->
 <entry>ログ収集機構が現在書き込んでいるログファイルを記録するファイル</entry>
</row>

<row>
 <entry><filename>global</filename></entry>
<!--
 <entry>Subdirectory containing cluster-wide tables, such as
 <structname>pg_database</structname></entry>
-->
 <entry><structname>pg_database</structname>のようなクラスタで共有するテーブルを保有するサブディレクトリ</entry>
</row>

<row>
 <entry><filename>pg_commit_ts</filename></entry>
<!--
 <entry>Subdirectory containing transaction commit timestamp data</entry>
-->
 <entry>トランザクションのコミット時刻のデータを保有するサブディレクトリ</entry>
</row>

<row>
 <entry><filename>pg_dynshmem</filename></entry>
<!--
 <entry>Subdirectory containing files used by the dynamic shared memory
  subsystem</entry>
-->
 <entry>動的共有メモリサブシステムで使われるファイルを保有するサブディレクトリ</entry>
</row>

<row>
 <entry><filename>pg_logical</filename></entry>
<!--
 <entry>Subdirectory containing status data for logical decoding</entry>
-->
 <entry>論理デコードのための状態データを保有するサブディレクトリ</entry>
</row>

<row>
 <entry><filename>pg_multixact</filename></entry>
<!--
 <entry>Subdirectory containing multitransaction status data
  (used for shared row locks)</entry>
-->
 <entry>マルチトランザクションの状態のデータを保有するサブディレクトリ（共有行ロックで使用されます）</entry>
</row>

<row>
 <entry><filename>pg_notify</filename></entry>
<!--
 <entry>Subdirectory containing LISTEN/NOTIFY status data</entry>
-->
 <entry>LISTEN/NOTIFY状態データを保有するサブディレクトリ</entry>
</row>

<row>
 <entry><filename>pg_replslot</filename></entry>
<!--
 <entry>Subdirectory containing replication slot data</entry>
-->
 <entry>レプリケーションスロットデータを保有するサブディレクトリ</entry>
</row>

<row>
 <entry><filename>pg_serial</filename></entry>
<!--
 <entry>Subdirectory containing information about committed serializable transactions</entry>
-->
 <entry>コミットされたシリアライザブルトランザクションに関する情報を保有するサブディレクトリ</entry>
</row>

<row>
 <entry><filename>pg_snapshots</filename></entry>
<!--
 <entry>Subdirectory containing exported snapshots</entry>
-->
 <entry>エクスポートされたスナップショットを保有するサブディレクトリ</entry>
</row>

<row>
 <entry><filename>pg_stat</filename></entry>
<!--
 <entry>Subdirectory containing permanent files for the statistics
  subsystem</entry>
-->
 <entry>統計サブシステム用の永続ファイルを保有するサブディレクトリ</entry>
</row>

<row>
 <entry><filename>pg_stat_tmp</filename></entry>
 <!--
 <entry>Subdirectory containing temporary files for the statistics
  subsystem</entry>
  -->
 <entry>統計サブシステム用の一時ファイルを保有するサブディレクトリ</entry>
</row>

<row>
 <entry><filename>pg_subtrans</filename></entry>
<!--
 <entry>Subdirectory containing subtransaction status data</entry>
-->
 <entry>サブトランザクションの状態のデータを保有するサブディレクトリ</entry>
</row>

<row>
 <entry><filename>pg_tblspc</filename></entry>
<!--
 <entry>Subdirectory containing symbolic links to tablespaces</entry>
-->
 <entry>テーブル空間へのシンボリックリンクを保有するサブディレクトリ</entry>
</row>

<row>
 <entry><filename>pg_twophase</filename></entry>
<!--
 <entry>Subdirectory containing state files for prepared transactions</entry>
-->
 <entry>プリペアドトランザクション用の状態ファイルを保有するサブディレクトリ</entry>

</row>

<row>
 <entry><filename>pg_wal</filename></entry>
<!--
 <entry>Subdirectory containing WAL (Write Ahead Log) files</entry>
-->
 <entry> WAL（ログ先行書き込み）ファイルを保有するサブディレクトリ</entry>
</row>

<row>
 <entry><filename>pg_xact</filename></entry>
<!--
 <entry>Subdirectory containing transaction commit status data</entry>
-->
 <entry>トランザクションのコミット状態のデータを保有するサブディレクトリ</entry>
</row>

<row>
 <entry><filename>postgresql.auto.conf</filename></entry>
<!--
 <entry>A file used for storing configuration parameters that are set by
<command>ALTER SYSTEM</command></entry>
-->
 <entry><command>ALTER SYSTEM</command>により設定された設定パラメータを格納するのに使われるファイル</entry>
</row>

<row>
 <entry><filename>postmaster.opts</filename></entry>
<!--
 <entry>A file recording the command-line options the server was
last started with</entry>
-->
 <entry>最後にサーバを起動した時のコマンドラインオプションを記録するファイル</entry>
</row>

<row>
 <entry><filename>postmaster.pid</filename></entry>
<!--
 <entry>A lock file recording the current postmaster process ID (PID),
  cluster data directory path,
  postmaster start timestamp,
  port number,
  Unix-domain socket directory path (could be empty),
  first valid listen_address (IP address or <literal>*</literal>, or empty if
  not listening on TCP),
  and shared memory segment ID
  (this file is not present after server shutdown)</entry>
-->
 <entry>
現在のpostmasterプロセスID（PID）、クラスタのデータディレクトリパス、postmaster起動時のタイムスタンプ、ポート番号、Unixドメインソケットのディレクトリパス（空も可）、有効な監視アドレスの一番目（IPアドレスまたは<literal>*</literal>、TCPを監視していない場合は空）および共有メモリのセグメントIDを記録するロックファイル（サーバが停止した後は存在しません）
</entry>
</row>

</tbody>
</tgroup>
</table>

<para>
<!--
For each database in the cluster there is a subdirectory within
<varname>PGDATA</varname><filename>/base</filename>, named after the database's OID in
<structname>pg_database</structname>.  This subdirectory is the default location
for the database's files; in particular, its system catalogs are stored
there.
-->
クラスタ内の各データベースに対して、<varname>PGDATA</varname><filename>/base</filename>内にサブディレクトリが存在し、サブディレクトリ名は<structname>pg_database</structname>内のデータベースOIDとなります。
このサブディレクトリはデータベースファイルのデフォルトの位置であり、特にシステムカタログがそこに格納されます。
</para>

<para>
<!--
 Note that the following sections describe the behavior of the builtin
 <literal>heap</literal> <link linkend="tableam">table access method</link>,
 and the builtin <link linkend="indexam">index access methods</link>. Due
 to the extensible nature of <productname>PostgreSQL</productname>, other
 access methods might work differently.
-->
以下の節では、組み込みの<literal>heap</literal><link linkend="tableam">テーブルアクセスメソッド</link>と組み込みの<link linkend="indexam">インデックスアクセスメソッド</link>の振舞いを説明していることに注意してください。
<productname>PostgreSQL</productname>の拡張性のため、他のアクセスメソッドは異なる動作をするかもしれません。
</para>

<para>
<!--
Each table and index is stored in a separate file.  For ordinary relations,
these files are named after the table or index's <firstterm>filenode</firstterm> number,
which can be found in <structname>pg_class</structname>.<structfield>relfilenode</structfield>. But
for temporary relations, the file name is of the form
<literal>t<replaceable>BBB</replaceable>_<replaceable>FFF</replaceable></literal>, where <replaceable>BBB</replaceable>
is the backend ID of the backend which created the file, and <replaceable>FFF</replaceable>
is the filenode number.  In either case, in addition to the main file (a/k/a
main fork), each table and index has a <firstterm>free space map</firstterm> (see <xref
linkend="storage-fsm"/>), which stores information about free space available in
the relation.  The free space map is stored in a file named with the filenode
number plus the suffix <literal>_fsm</literal>.  Tables also have a
<firstterm>visibility map</firstterm>, stored in a fork with the suffix <literal>_vm</literal>,
to track which pages are known to have no dead tuples.  The visibility map is
described further in <xref linkend="storage-vm"/>.  Unlogged tables and indexes
have a third fork, known as the initialization fork, which is stored in a fork
with the suffix <literal>_init</literal> (see <xref linkend="storage-init"/>).
-->
各テーブルおよびインデックスは別個のファイルに格納されます。
通常のリレーションでは、これらのファイル名はテーブルまたはインデックスの<firstterm>ファイルノード</firstterm>番号となります。
ファイルノード番号は<structname>pg_class</structname>.<structfield>relfilenode</structfield>内で見つけられます。
しかし一時的なリレーションでは、ファイル名は<literal>t<replaceable>BBB</replaceable>_<replaceable>FFF</replaceable></literal>という形になります。
ここで<replaceable>BBB</replaceable>はファイルを生成したバックエンドのバックエンドID、<replaceable>FFF</replaceable>はファイルノード番号です。
どちらの場合でも、主ファイル（いわゆる主フォーク）に加え、それぞれのテーブルとインデックスはリレーションに利用できる空き領域についての情報を格納する<firstterm>空き領域マップ</firstterm>（<xref linkend="storage-fsm"/>参照）を持ちます。
空き領域マップはファイルノード番号に接尾辞<literal>_fsm</literal>がついた名前のファイルに格納されます。
テーブルは同時に、どのページが無効なタプルを持っていないと判断できるように追跡する<firstterm>可視性マップ</firstterm>を持ち、フォークに接尾辞<literal>_vm</literal>を付けたファイルに格納します。
可視性マップは<xref linkend="storage-vm"/>でより詳しく解説します。
ログを取らないテーブルとインデックスは、初期化フォークという第３のフォークを持ち、フォークに接尾辞<literal>_init</literal>を付けたファイルに格納します（<xref linkend="storage-init"/>参照）。
</para>

<caution>
<para>
<!--
Note that while a table's filenode often matches its OID, this is
<emphasis>not</emphasis> necessarily the case; some operations, like
<command>TRUNCATE</command>, <command>REINDEX</command>, <command>CLUSTER</command> and some forms
of <command>ALTER TABLE</command>, can change the filenode while preserving the OID.
Avoid assuming that filenode and table OID are the same.
Also, for certain system catalogs including <structname>pg_class</structname> itself,
<structname>pg_class</structname>.<structfield>relfilenode</structfield> contains zero.  The
actual filenode number of these catalogs is stored in a lower-level data
structure, and can be obtained using the <function>pg_relation_filenode()</function>
function.
-->
テーブルにおけるファイルノード番号とOIDは多くの場合一致しますが、常に一致するとは<emphasis>限らない</emphasis>ことに注意してください。
<command>TRUNCATE</command>、<command>REINDEX</command>、<command>CLUSTER</command>等のいくつかの操作、および<command>ALTER TABLE</command>におけるいくつかの構文は、OIDを保持したままファイルノード番号を変更できます。
ファイルノード番号とテーブルOIDが同一であると仮定しないでください。
また<structname>pg_class</structname>自身を含む特定のシステムカタログにおいて、<structname>pg_class</structname>.<structfield>relfilenode</structfield>はゼロを持ちます。
これらのカタログの実際のファイルノード番号は低レベルなデータ構造内に保管されており、<function>pg_relation_filenode()</function>関数を使用して入手できます。
</para>
</caution>

<para>
<!--
When a table or index exceeds 1 GB, it is divided into gigabyte-sized
<firstterm>segments</firstterm>.  The first segment's file name is the same as the
filenode; subsequent segments are named filenode.1, filenode.2, etc.
This arrangement avoids problems on platforms that have file size limitations.
(Actually, 1 GB is just the default segment size.  The segment size can be
adjusted using the configuration option <option>&#045;&#045;with-segsize</option>
when building <productname>PostgreSQL</productname>.)
In principle, free space map and visibility map forks could require multiple
segments as well, though this is unlikely to happen in practice.
-->
テーブルまたはインデックスが１ギガバイトを超えると、ギガバイト単位の<firstterm>セグメント</firstterm>に分割されます。
最初のセグメントのファイル名はファイルノード番号と同一であり、それ以降は、ファイルノード番号.1、ファイルノード番号.2等の名称になります。
この配置法によってファイル容量に制限のあるプラットフォームにおける問題を回避します。
（実際、１ギガバイトは単なるデフォルトのセグメント容量です。
セグメント容量は<productname>PostgreSQL</productname>を構築する際、<option>--with-segsize</option>設定オプションを使用して調整することができます。)
原理上、空き領域マップと可視性マップのフォークにおいても複数のセグメントも必要とする可能性がありますが、実際のところは起こりそうにありません。
</para>

<para>
<!--
A table that has columns with potentially large entries will have an
associated <firstterm>TOAST</firstterm> table, which is used for out-of-line storage of
field values that are too large to keep in the table rows proper.
<structname>pg_class</structname>.<structfield>reltoastrelid</structfield> links from a table to
its <acronym>TOAST</acronym> table, if any.
See <xref linkend="storage-toast"/> for more information.
-->
項目が大きくなりそうな列を持ったテーブルは、連携した<firstterm>TOAST</firstterm>テーブルを保有する可能性があります。
TOASTテーブルは、テーブル行の中には大き過ぎて適切に保持できないフィールド値を行の外部に格納するために使用されます。
<acronym>TOAST</acronym>テーブルが存在する時、<structname>pg_class</structname>.<structfield>reltoastrelid</structfield>は元のテーブルと<acronym>TOAST</acronym>テーブルを結びつけます。
<xref linkend="storage-toast"/>を参照してください。
</para>

<para>
<!--
The contents of tables and indexes are discussed further in
<xref linkend="storage-page-layout"/>.
-->
テーブルおよびインデックスの内容は、<xref linkend="storage-page-layout"/>においてさらに考察されています。
</para>

<para>
<!--
Tablespaces make the scenario more complicated.  Each user-defined tablespace
has a symbolic link inside the <varname>PGDATA</varname><filename>/pg_tblspc</filename>
directory, which points to the physical tablespace directory (i.e., the
location specified in the tablespace's <command>CREATE TABLESPACE</command> command).
This symbolic link is named after
the tablespace's OID.  Inside the physical tablespace directory there is
a subdirectory with a name that depends on the <productname>PostgreSQL</productname>
server version, such as <literal>PG_9.0_201008051</literal>.  (The reason for using
this subdirectory is so that successive versions of the database can use
the same <command>CREATE TABLESPACE</command> location value without conflicts.)
Within the version-specific subdirectory, there is
a subdirectory for each database that has elements in the tablespace, named
after the database's OID.  Tables and indexes are stored within that
directory, using the filenode naming scheme.
The <literal>pg_default</literal> tablespace is not accessed through
<filename>pg_tblspc</filename>, but corresponds to
<varname>PGDATA</varname><filename>/base</filename>.  Similarly, the <literal>pg_global</literal>
tablespace is not accessed through <filename>pg_tblspc</filename>, but corresponds to
<varname>PGDATA</varname><filename>/global</filename>.
-->
テーブル空間は状況をさらに複雑にします。
ユーザが定義したテーブル空間はそれぞれ、<varname>PGDATA</varname><filename>/pg_tblspc</filename>ディレクトリ内に物理的なテーブル空間ディレクトリ（つまりそのテーブル空間の<command>CREATE TABLESPACE</command>コマンドで指定された場所）を指し示す、シンボリックリンクを持ちます。
シンボリックリンクの名称はテーブル空間のOIDとなります。
物理的テーブル空間ディレクトリの内部では、<literal>PG_9.0_201008051</literal>などの<productname>PostgreSQL</productname>サーバのバージョンに依存した名前のサブディレクトリが存在します。
（このサブディレクトリを使用する理由は、競合することなく<command>CREATE TABLESPACE</command>で指定する場所と同じものを将来のバージョンのデータベースでも使用できるようにするためです。）
このバージョン固有のサブディレクトリの内部では、テーブル空間に要素を持つデータベースごとに、データベースOIDをディレクトリ名としたサブディレクトリが存在します。
テーブルとインデックスは、ファイルノードの命名の規定に従って、そのディレクトリ内に格納されます。
<literal>pg_default</literal>テーブル空間は <filename>pg_tblspc</filename>を通してアクセスされるのではなく、<varname>PGDATA</varname><filename>/base</filename>と連携します。
同様に、<literal>pg_global</literal>テーブル空間は<filename>pg_tblspc</filename>を通してアクセスされるのではなく、<varname>PGDATA</varname><filename>/global</filename>と連携します。
</para>

<para>
<!--
The <function>pg_relation_filepath()</function> function shows the entire path
(relative to <varname>PGDATA</varname>) of any relation.  It is often useful
as a substitute for remembering many of the above rules.  But keep in
mind that this function just gives the name of the first segment of the
main fork of the relation &mdash; you may need to append a segment number
and/or <literal>_fsm</literal>, <literal>_vm</literal>, or <literal>_init</literal> to find all
the files associated with the relation.
-->
<function>pg_relation_filepath()</function>関数は任意のリレーションの(<varname>PGDATA</varname>から相対的な)パス全体を示します。
これは上の規則の多くを記憶する必要がありませんので、しばしば有用です。
しかし、この関数がリレーションの主フォークの最初のセグメントの名前だけを返すことに注意して下さい。
リレーションに関したすべてのファイルを見つけるためにセグメント番号や<literal>_fsm</literal>や<literal>_vm</literal>、<literal>_init</literal>を追加する必要があるかもしれません。
</para>

<para>
<!--
Temporary files (for operations such as sorting more data than can fit in
memory) are created within <varname>PGDATA</varname><filename>/base/pgsql_tmp</filename>,
or within a <filename>pgsql_tmp</filename> subdirectory of a tablespace directory
if a tablespace other than <literal>pg_default</literal> is specified for them.
The name of a temporary file has the form
<filename>pgsql_tmp<replaceable>PPP</replaceable>.<replaceable>NNN</replaceable></filename>,
where <replaceable>PPP</replaceable> is the PID of the owning backend and
<replaceable>NNN</replaceable> distinguishes different temporary files of that backend.
-->
一時ファイル（メモリ内に収まりきらないデータのソートなどの操作用）は<varname>PGDATA</varname><filename>/base/pgsql_tmp</filename>内、または、<literal>pg_default</literal>以外のテーブル空間が指定されていた場合はテーブル空間ディレクトリ下の<filename>pgsql_tmp</filename>サブディレクトリ内に作成されます。
一時ファイルの名前は<filename>pgsql_tmp<replaceable>PPP</replaceable>.<replaceable>NNN</replaceable></filename>という形式です。
ここで、<replaceable>PPP</replaceable>は所有するバックエンドのPIDであり、<replaceable>NNN</replaceable>で同一バックエンドで作成された別の一時ファイルと区別します。
</para>

</sect1>

<sect1 id="storage-toast">

<title>TOAST</title>

    <indexterm>
     <primary>TOAST</primary>
    </indexterm>
<!--
    <indexterm><primary>sliced bread</primary><see>TOAST</see></indexterm>
-->
    <indexterm><primary>スライスパン</primary><see>TOAST</see></indexterm>

<para>
<!--
This section provides an overview of <acronym>TOAST</acronym> (The
Oversized-Attribute Storage Technique).
-->
本節では<acronym>TOAST</acronym>（過大属性格納技法：The Oversized-Attribute Storage Technique）の概要について説明します。
</para>

<para>
<!--
<productname>PostgreSQL</productname> uses a fixed page size (commonly
8 kB), and does not allow tuples to span multiple pages.  Therefore, it is
not possible to store very large field values directly.  To overcome
this limitation, large field values are compressed and/or broken up into
multiple physical rows.  This happens transparently to the user, with only
small impact on most of the backend code.  The technique is affectionately
known as <acronym>TOAST</acronym> (or <quote>the best thing since sliced bread</quote>).
The <acronym>TOAST</acronym> infrastructure is also used to improve handling of
large data values in-memory.
-->
<productname>PostgreSQL</productname>は固定長のページサイズ（通常8キロバイト）を使用し、複数ページにまたがるタプルを許しません。
そのため、大規模なフィールド値を直接格納できません。
この限界を克服するため、大規模なフィールド値を圧縮したり、複数の物理的な行に分割したりしています。
これはユーザからは透過的に発生し、また、バックエンドのコード全体には小さな影響しか与えません。
この技法は<acronym>TOAST</acronym>（または<quote>パンをスライスして以来最善のもの</quote>）という愛称で呼ばれます。
[訳注：TOASTはパンのトーストと綴りが同じなので、スライスしたパンを美味しく食べる方法に掛けて洒落ています。]
<acronym>TOAST</acronym>の基盤は大きなデータ値のインメモリで処理の改善にも使用されています。
</para>

<para>
<!--
Only certain data types support <acronym>TOAST</acronym> &mdash; there is no need to
impose the overhead on data types that cannot produce large field values.
To support <acronym>TOAST</acronym>, a data type must have a variable-length
(<firstterm>varlena</firstterm>) representation, in which, ordinarily, the first
four-byte word of any stored value contains the total length of the value in
bytes (including itself).  <acronym>TOAST</acronym> does not constrain the rest
of the data type's representation.  The special representations collectively
called <firstterm><acronym>TOAST</acronym>ed values</firstterm> work by modifying or
reinterpreting this initial length word.  Therefore, the C-level functions
supporting a <acronym>TOAST</acronym>-able data type must be careful about how they
handle potentially <acronym>TOAST</acronym>ed input values: an input might not
actually consist of a four-byte length word and contents until after it's
been <firstterm>detoasted</firstterm>.  (This is normally done by invoking
<function>PG_DETOAST_DATUM</function> before doing anything with an input value,
but in some cases more efficient approaches are possible.
See <xref linkend="xtypes-toast"/> for more detail.)
-->
一部のデータ型のみが<acronym>TOAST</acronym>をサポートします。
大規模なフィールド値を生成することがないデータ型にオーバーヘッドを負わせる必要はありません。
<acronym>TOAST</acronym>をサポートするためには、データ型は可変長（<firstterm>varlena</firstterm>）表現を持たなければなりません。
通常は、格納する値の最初の4バイトワードには値の長さ（このワード自体を含む）がバイト単位で含まれます。
<acronym>TOAST</acronym>は残りのデータ型の表現について制限しません。
<firstterm><acronym>TOAST</acronym>化された値</firstterm>として集合的に呼ばれる特別な表現は、この先頭の長さのワードを更新または再解釈することで動作します。
したがって、<acronym>TOAST</acronym>可能なデータ型をサポートするC言語関数は、潜在的に<acronym>TOAST</acronym>化されている入力値の扱い方に注意しなければなりません。
つまり、入力が<firstterm>TOAST解除</firstterm>されなければ、それは実際には4バイトの長さのワードと内容から構成されていないかもしれないのです。
（通常これは、入力に対して何か作業をする前に<function>PG_DETOAST_DATUM</function>を呼び出すことで行われますが、もっと効率的な方法が可能な場合もあります
詳しくは<xref linkend="xtypes-toast"/>を参照してください）。
</para>

<para>
<!--
<acronym>TOAST</acronym> usurps two bits of the varlena length word (the high-order
bits on big-endian machines, the low-order bits on little-endian machines),
thereby limiting the logical size of any value of a <acronym>TOAST</acronym>-able
data type to 1 GB (2<superscript>30</superscript> - 1 bytes).  When both bits are zero,
the value is an ordinary un-<acronym>TOAST</acronym>ed value of the data type, and
the remaining bits of the length word give the total datum size (including
length word) in bytes.  When the highest-order or lowest-order bit is set,
the value has only a single-byte header instead of the normal four-byte
header, and the remaining bits of that byte give the total datum size
(including length byte) in bytes.  This alternative supports space-efficient
storage of values shorter than 127 bytes, while still allowing the data type
to grow to 1 GB at need.  Values with single-byte headers aren't aligned on
any particular boundary, whereas values with four-byte headers are aligned on
at least a four-byte boundary; this omission of alignment padding provides
additional space savings that is significant compared to short values.
As a special case, if the remaining bits of a single-byte header are all
zero (which would be impossible for a self-inclusive length), the value is
a pointer to out-of-line data, with several possible alternatives as
described below.  The type and size of such a <firstterm>TOAST pointer</firstterm>
are determined by a code stored in the second byte of the datum.
Lastly, when the highest-order or lowest-order bit is clear but the adjacent
bit is set, the content of the datum has been compressed and must be
decompressed before use.  In this case the remaining bits of the four-byte
length word give the total size of the compressed datum, not the
original data.  Note that compression is also possible for out-of-line data
but the varlena header does not tell whether it has occurred &mdash;
the content of the <acronym>TOAST</acronym> pointer tells that, instead.
-->
<acronym>TOAST</acronym>はvarlenaの長さワードの2ビット(ビッグエンディアンのマシンでは上位ビット、リトルエンディアンのマシンでは下位ビット)を勝手に使用します。
そのため、すべての<acronym>TOAST</acronym>可能なデータ型の値の論理サイズは1ギガバイト（2<superscript>30</superscript> - 1バイト）までになります。
両ビットが0の場合、値はそのデータ型の普通の<acronym>TOAST</acronym>化されていない値となり、長さワードの残りのビットはデータの（長さワードを含む）総サイズ（バイト単位）となります。
上位側または下位側のどちらか片方のビットが設定された場合、値は通常の4バイトのヘッダを持たず1バイトのヘッダを持ちます。
また、そのバイトの残りビットはデータの（長さワードを含む）総サイズ（バイト単位）となります。
この方式により、127バイトより短い値の効率的な格納をサポートする一方で、データ型が必要なら1GBにまで大きくなることを可能にしています。
1バイトのヘッダを持つ値は特定の境界に整列されませんが、4バイトのヘッダを持つ値は少なくとも4バイト境界の上に整列されます。
このように整列のためのパディングを省略することで、短い値と比べて重要な追加のスペース節約ができます。
特殊な状況として、1バイトのヘッダの残りビットがすべて0（自身の長さを含む場合はありえません）の場合、その値は行外データへのポインタで、以下に述べるようにいくつかの可能性があります。
そのような<firstterm>TOASTポインタ</firstterm>の型とサイズはデータの2番目のバイトに格納されるコードによって決定されます。
最後に上位側または下位側のビットが0で隣のビットが設定されている場合、データの内容は圧縮され、使用前に伸長しなければなりません。
この場合、4バイトの長さワードの残りビットは元データのサイズではなく圧縮したデータの総サイズになります。
圧縮が行外データでも起こりえますが、varlenaヘッダには圧縮されているかどうかについての情報がないことに注意してください。
その代わり<acronym>TOAST</acronym>ポインタの内容にこの情報が含まれています。
</para>

<para>
The compression technique used for either in-line or out-of-line compressed
data can be selected for each column by setting
the <literal>COMPRESSION</literal> column option in <command>CREATE
TABLE</command> or <command>ALTER TABLE</command>.  The default for columns
with no explicit setting is to consult the
<xref linkend="guc-default-toast-compression"/> parameter at the time data is
inserted.
</para>

<para>
<!--
As mentioned, there are multiple types of <acronym>TOAST</acronym> pointer datums.
The oldest and most common type is a pointer to out-of-line data stored in
a <firstterm><acronym>TOAST</acronym> table</firstterm> that is separate from, but
associated with, the table containing the <acronym>TOAST</acronym> pointer datum
itself.  These <firstterm>on-disk</firstterm> pointer datums are created by the
<acronym>TOAST</acronym> management code (in <filename>access/common/toast_internals.c</filename>)
when a tuple to be stored on disk is too large to be stored as-is.
Further details appear in <xref linkend="storage-toast-ondisk"/>.
Alternatively, a <acronym>TOAST</acronym> pointer datum can contain a pointer to
out-of-line data that appears elsewhere in memory.  Such datums are
necessarily short-lived, and will never appear on-disk, but they are very
useful for avoiding copying and redundant processing of large data values.
Further details appear in <xref linkend="storage-toast-inmemory"/>.
-->
前に触れたように、<acronym>TOAST</acronym>ポインタデータにはいくつかの型があります。
最も古くて一般的な型は<firstterm><acronym>TOAST</acronym>テーブル</firstterm>に格納されている行外データへのポインタです。
<acronym>TOAST</acronym>テーブルは、<acronym>TOAST</acronym>ポインタデータ自体を含むテーブルとは別の、しかし関連付けられるテーブルです。
これらの<firstterm>ディスク上</firstterm>のポインタデータは、ディスク上に格納されるタプルが、そのまま格納するには大きすぎる時に、<acronym>TOAST</acronym>管理コード（<filename>access/common/toast_internals.c</filename>にあります）によって作られます。
更なる詳細は<xref linkend="storage-toast-ondisk"/>に記述されています。
あるいは<acronym>TOAST</acronym>ポインタデータは、メモリ内のどこかにある行外データへのポインタのこともあります。
そのようなデータは短命で、ディスク上に現れることは決してありませんが、大きなデータ値を複製し、余分な処理をするのを避けるために有用です。
更なる詳細は<xref linkend="storage-toast-inmemory"/>に記述されています。
</para>

<sect2 id="storage-toast-ondisk">
<!--
 <title>Out-of-Line, On-Disk TOAST Storage</title>
-->
 <title>行外ディスク上のTOAST格納</title>

<para>
<!--
If any of the columns of a table are <acronym>TOAST</acronym>-able, the table will
have an associated <acronym>TOAST</acronym> table, whose OID is stored in the table's
<structname>pg_class</structname>.<structfield>reltoastrelid</structfield> entry.  On-disk
<acronym>TOAST</acronym>ed values are kept in the <acronym>TOAST</acronym> table, as
described in more detail below.
-->
テーブルの列に1つでも<acronym>TOAST</acronym>可能なものがあれば、そのテーブルには連携した<acronym>TOAST</acronym>テーブルがあり、そのOIDがテーブルの<structname>pg_class</structname>.<structfield>reltoastrelid</structfield>エントリに格納されます。
ディスク上の<acronym>TOAST</acronym>化された値は以下で詳しく説明する通り、<acronym>TOAST</acronym>テーブルに保持されます。
</para>

<para>
<!--
Out-of-line values are divided (after compression if used) into chunks of at
most <symbol>TOAST_MAX_CHUNK_SIZE</symbol> bytes (by default this value is chosen
so that four chunk rows will fit on a page, making it about 2000 bytes).
Each chunk is stored as a separate row in the <acronym>TOAST</acronym> table
belonging to the owning table.  Every
<acronym>TOAST</acronym> table has the columns <structfield>chunk_id</structfield> (an OID
identifying the particular <acronym>TOAST</acronym>ed value),
<structfield>chunk_seq</structfield> (a sequence number for the chunk within its value),
and <structfield>chunk_data</structfield> (the actual data of the chunk).  A unique index
on <structfield>chunk_id</structfield> and <structfield>chunk_seq</structfield> provides fast
retrieval of the values.  A pointer datum representing an out-of-line on-disk
<acronym>TOAST</acronym>ed value therefore needs to store the OID of the
<acronym>TOAST</acronym> table in which to look and the OID of the specific value
(its <structfield>chunk_id</structfield>).  For convenience, pointer datums also store the
logical datum size (original uncompressed data length), physical stored size
(different if compression was applied), and the compression method used, if
any.  Allowing for the varlena header bytes,
the total size of an on-disk <acronym>TOAST</acronym> pointer datum is therefore 18
bytes regardless of the actual size of the represented value.
-->
行外の値は（圧縮される場合は圧縮後に）最大<symbol>TOAST_MAX_CHUNK_SIZE</symbol>バイトの塊に分割されます
（デフォルトではこの値は4チャンク行が1ページに収まり、およそ2000バイトになるように選ばれます）。
各塊は、データを持つテーブルと連携する<acronym>TOAST</acronym>テーブル内に個別の行として格納されます。
すべての<acronym>TOAST</acronym>テーブルは<structfield>chunk_id</structfield>列（特定の<acronym>TOAST</acronym>化された値を識別するOID）、<structfield>chunk_seq</structfield>列（値の塊に対する連番）、<structfield>chunk_data</structfield>（塊の実際のデータ）列を持ちます。
<structfield>chunk_id</structfield>と<structfield>chunk_seq</structfield>に対する一意性インデックスは値の抽出を高速化します。
したがって、行外のディスク上の<acronym>TOAST</acronym>化された値を示すポインタデータには、検索先となる<acronym>TOAST</acronym>テーブルのOIDと指定した値のOID(<structfield>chunk_id</structfield>)を格納しなければなりません。
簡便性のために、ポインタデータには論理データサイズ（元々の非圧縮のデータ長）と物理的な格納サイズ（圧縮時には異なります）も格納されます。
varlenaヘッダバイトに収納するためにディスク上の<acronym>TOAST</acronym>ポインタデータの総サイズは、表現される値の実サイズに関係なく、18バイトになります。
</para>

<para>
<!--
The <acronym>TOAST</acronym> management code is triggered only
when a row value to be stored in a table is wider than
<symbol>TOAST_TUPLE_THRESHOLD</symbol> bytes (normally 2 kB).
The <acronym>TOAST</acronym> code will compress and/or move
field values out-of-line until the row value is shorter than
<symbol>TOAST_TUPLE_TARGET</symbol> bytes (also normally 2 kB, adjustable)
or no more gains can be had.  During an UPDATE
operation, values of unchanged fields are normally preserved as-is; so an
UPDATE of a row with out-of-line values incurs no <acronym>TOAST</acronym> costs if
none of the out-of-line values change.
-->
<acronym>TOAST</acronym>管理のコードは、テーブル内に格納される値が<symbol>TOAST_TUPLE_THRESHOLD</symbol>バイト（通常2キロバイト）を超える時にのみ実行されます。
<acronym>TOAST</acronym>コードは、行の値が<symbol>TOAST_TUPLE_TARGET</symbol>バイト（こちらも通常2キロバイト、調整可能）より小さくなるかそれ以上の縮小ができなくなるまで、フィールド値の圧縮や行外への移動を行います。
更新操作中、変更されない値は通常そのまま残ります。
行外の値を持つ行の更新では、行外の値の変更がなければ<acronym>TOAST</acronym>するコストはかかりません。
</para>

<para>
<!--
The <acronym>TOAST</acronym> management code recognizes four different strategies
for storing <acronym>TOAST</acronym>-able columns on disk:
-->
<acronym>TOAST</acronym>管理のコードでは、ディスク上に<acronym>TOAST</acronym>可能な列を格納するために、以下の4つの異なる戦略を認識します。

   <itemizedlist>
    <listitem>
     <para>
<!--
      <literal>PLAIN</literal> prevents either compression or
      out-of-line storage; furthermore it disables use of single-byte headers
      for varlena types.
      This is the only possible strategy for
      columns of non-<acronym>TOAST</acronym>-able data types.
-->
<literal>PLAIN</literal>は圧縮や行外の格納を防止します。
さらにvarlena型での単一バイトヘッダの使用を無効にします。
これは<acronym>TOAST</acronym>化不可能のデータ型の列に対してのみ取り得る戦略です。
     </para>
    </listitem>
    <listitem>
     <para>
<!--
      <literal>EXTENDED</literal> allows both compression and out-of-line
      storage.  This is the default for most <acronym>TOAST</acronym>-able data types.
      Compression will be attempted first, then out-of-line storage if
      the row is still too big.
-->
<literal>EXTENDED</literal>では、圧縮と行外の格納を許します。
これはほとんどの<acronym>TOAST</acronym>可能のデータ型のデフォルトです。
圧縮がまず行われ、それでも行が大き過ぎるのであれば行外に格納します。
     </para>
    </listitem>
    <listitem>
     <para>
<!--
      <literal>EXTERNAL</literal> allows out-of-line storage but not
      compression.  Use of <literal>EXTERNAL</literal> will
      make substring operations on wide <type>text</type> and
      <type>bytea</type> columns faster (at the penalty of increased storage
      space) because these operations are optimized to fetch only the
      required parts of the out-of-line value when it is not compressed.
-->
<literal>EXTERNAL</literal>は非圧縮の行外格納を許します。
<literal>EXTERNAL</literal>を使用すると、<type>text</type>と<type>bytea</type>列全体に対する部分文字列操作が高速化されます。
こうした操作は非圧縮の行外の値から必要な部分を取り出す時に最適化されるためです
（格納領域が増加するという欠点があります）。
     </para>
    </listitem>
    <listitem>
     <para>
<!--
      <literal>MAIN</literal> allows compression but not out-of-line
      storage.  (Actually, out-of-line storage will still be performed
      for such columns, but only as a last resort when there is no other
      way to make the row small enough to fit on a page.)
-->
<literal>MAIN</literal>は圧縮を許しますが、行外の格納はできません
（実際にはこうした列についても行外の格納は行われます。
しかし、他に行を縮小させページに合わせる方法がない場合の最後の手段としてのみです）。
     </para>
    </listitem>
   </itemizedlist>

<!--
Each <acronym>TOAST</acronym>-able data type specifies a default strategy for columns
of that data type, but the strategy for a given table column can be altered
with <link linkend="sql-altertable"><command>ALTER TABLE ... SET STORAGE</command></link>.
-->
<acronym>TOAST</acronym>可能なデータ型はそれぞれ、そのデータ型の列用のデフォルトの戦略を指定します。
しかし<link linkend="sql-altertable"><command>ALTER TABLE ... SET STORAGE</command></link>を使用して、あるテーブル列の戦略を変更することができます。
</para>

<para>
<!--
<symbol>TOAST_TUPLE_TARGET</symbol> can be adjusted for each table using
<link linkend="sql-altertable"><command>ALTER TABLE ... SET (toast_tuple_target = N)</command></link>
-->
<symbol>TOAST_TUPLE_TARGET</symbol>は<link linkend="sql-altertable"><command>ALTER TABLE ... SET (toast_tuple_target = N)</command></link>を使って各テーブルで調整できます。
</para>

<para>
<!--
This scheme has a number of advantages compared to a more straightforward
approach such as allowing row values to span pages.  Assuming that queries are
usually qualified by comparisons against relatively small key values, most of
the work of the executor will be done using the main row entry. The big values
of <acronym>TOAST</acronym>ed attributes will only be pulled out (if selected at all)
at the time the result set is sent to the client. Thus, the main table is much
smaller and more of its rows fit in the shared buffer cache than would be the
case without any out-of-line storage. Sort sets shrink also, and sorts will
more often be done entirely in memory. A little test showed that a table
containing typical HTML pages and their URLs was stored in about half of the
raw data size including the <acronym>TOAST</acronym> table, and that the main table
contained only about 10% of the entire data (the URLs and some small HTML
pages). There was no run time difference compared to an un-<acronym>TOAST</acronym>ed
comparison table, in which all the HTML pages were cut down to 7 kB to fit.
-->
この機構には、ページをまたがる行の値を許可するといった素直な手法に比べて多くの利点があります。
通常問い合わせは比較的小さなキー値に対する比較で条件付けされるものと仮定すると、エクゼキュータの仕事のほとんどは主だった行の項目を使用して行われることになります。
<acronym>TOAST</acronym>化属性の大規模な値は、（それが選択されている時）結果集合をクライアントに戻す時に引き出されるだけです。
このため、主テーブルは行外の格納を使用しない場合に比べて、かなり小さくなり、その行は共有バッファキャッシュにより合うようになります。
ソート集合もまた小さくなり、ソートが完全にメモリ内で行われる頻度が高くなります。
小規模な試験結果ですが、典型的なHTMLページとそのURLを持つテーブルでは、<acronym>TOAST</acronym>テーブルを含め、元々のデータサイズのおよそ半分で格納でき、さらに、主テーブルには全体のデータのおよそ10%のみ（URLと一部の小さなHTMLページ）が格納されました。
すべてのHTMLページを7キロバイト程度に切り詰めた<acronym>TOAST</acronym>化されない比較用テーブルと比べ、実行時間に違いはありませんでした。
</para>

</sect2>

<sect2 id="storage-toast-inmemory">
<!--
 <title>Out-of-Line, In-Memory TOAST Storage</title>
-->
 <title>行外インメモリのTOAST格納</title>

<para>
<!--
<acronym>TOAST</acronym> pointers can point to data that is not on disk, but is
elsewhere in the memory of the current server process.  Such pointers
obviously cannot be long-lived, but they are nonetheless useful.  There
are currently two sub-cases:
pointers to <firstterm>indirect</firstterm> data and
pointers to <firstterm>expanded</firstterm> data.
-->
<acronym>TOAST</acronym>ポインタは、ディスク上にあるデータだけでなく、現在のサーバプロセスのメモリ内の場所を指すこともできます。
そのようなポインタは明らかに短命ですが、それでも有用です。
現在のところ、<firstterm>間接</firstterm>データへのポインタと、<firstterm>展開</firstterm>データへのポインタの2つのケースがあります。
</para>

<para>
<!--
Indirect <acronym>TOAST</acronym> pointers simply point at a non-indirect varlena
value stored somewhere in memory.  This case was originally created merely
as a proof of concept, but it is currently used during logical decoding to
avoid possibly having to create physical tuples exceeding 1 GB (as pulling
all out-of-line field values into the tuple might do).  The case is of
limited use since the creator of the pointer datum is entirely responsible
that the referenced data survives for as long as the pointer could exist,
and there is no infrastructure to help with this.
-->
間接<acronym>TOAST</acronym>ポインタは、単にメモリ上のどこかに格納されている間接的でないvarlena値を指すだけです。
このケースは元々は単なる概念実証として作られたのですが、現在はロジカルデコーディング時に1GBを越える物理的タプルを作成する可能性を防ぐために使用されています。
（すべての行外フィールド値をタプルに持ってこようとすると、そうなるかもしれません。）
このケースでは、ポインタデータの作成者はポインタが存在可能な限り参照データが存在し続けることに全責任を負うため、利用が限られ、またこれを支援するための基盤もありません。
</para>

<para>
<!--
Expanded <acronym>TOAST</acronym> pointers are useful for complex data types
whose on-disk representation is not especially suited for computational
purposes.  As an example, the standard varlena representation of a
<productname>PostgreSQL</productname> array includes dimensionality information, a
nulls bitmap if there are any null elements, then the values of all the
elements in order.  When the element type itself is variable-length, the
only way to find the <replaceable>N</replaceable>'th element is to scan through all the
preceding elements.  This representation is appropriate for on-disk storage
because of its compactness, but for computations with the array it's much
nicer to have an <quote>expanded</quote> or <quote>deconstructed</quote>
representation in which all the element starting locations have been
identified.  The <acronym>TOAST</acronym> pointer mechanism supports this need by
allowing a pass-by-reference Datum to point to either a standard varlena
value (the on-disk representation) or a <acronym>TOAST</acronym> pointer that
points to an expanded representation somewhere in memory.  The details of
this expanded representation are up to the data type, though it must have
a standard header and meet the other API requirements given
in <filename>src/include/utils/expandeddatum.h</filename>.  C-level functions
working with the data type can choose to handle either representation.
Functions that do not know about the expanded representation, but simply
apply <function>PG_DETOAST_DATUM</function> to their inputs, will automatically
receive the traditional varlena representation; so support for an expanded
representation can be introduced incrementally, one function at a time.
-->
展開<acronym>TOAST</acronym>ポインタは、ディスク上の表現が計算目的にあまり適さない複雑なデータ型で有用です。
例えば<productname>PostgreSQL</productname>の配列の標準varlena表現には、次元の情報、NULLの要素があればNULLのビットマップ、そしてすべての要素の値が順番どおりに含まれます。
要素型自体が可変長だと、<replaceable>N</replaceable>番目の要素を探す唯一の方法は前にある要素のすべてをスキャンすることです。
この表現は、そのサイズの小ささからディスク上の記録には適していますが、配列を使った計算では、すべての要素の開始位置が特定されている<quote>展開</quote>または<quote>解体</quote>された表現があるとずっと良いです。
<acronym>TOAST</acronym>ポインタの機構では、参照渡しのデータが、標準のvarlena値（ディスク上の表現）あるいはメモリ上のどこかにある展開表現を指す<acronym>TOAST</acronym>ポインタを指すことを許すことで、このニーズに応えています。
この展開表現の詳細はデータ型に依存しますが、標準ヘッダを持ち、<filename>src/include/utils/expandeddatum.h</filename>にある他のAPIの要求を満たす必要があります。
データ型を処理するc言語の関数は、どちらかの表現を扱うことを選ぶことができます。
展開表現を認識せず、入力データに単に<function>PG_DETOAST_DATUM</function>を適用するだけの関数は、自動的に伝統的なvarlena表現を受け取ります。
従って、展開表現のサポートは徐々に、1回に1つの関数だけ導入することができます。
</para>

<para>
<!--
<acronym>TOAST</acronym> pointers to expanded values are further broken down
into <firstterm>read-write</firstterm> and <firstterm>read-only</firstterm> pointers.
The pointed-to representation is the same either way, but a function that
receives a read-write pointer is allowed to modify the referenced value
in-place, whereas one that receives a read-only pointer must not; it must
first create a copy if it wants to make a modified version of the value.
This distinction and some associated conventions make it possible to avoid
unnecessary copying of expanded values during query execution.
-->
展開された値への<acronym>TOAST</acronym>ポインタは、さらに<firstterm>読み書き</firstterm>のポインタと<firstterm>読み取りのみ</firstterm>のポインタに分類されます。
指された先の表現はどちらでも同じですが、読み書きのポインタを受け取った関数は、そこにある参照値を変更できるのに対し、読み取りのみのポインタを受け取った関数では変更が許されないため、値を変更したバージョンを作りたければ、まずその複製を作る必要があります。
この区別と、関連したいくつかの慣習により、問い合わせの実行時に展開された値を不必要に複製するのを避けることが可能になります。
</para>

<para>
<!--
For all types of in-memory <acronym>TOAST</acronym> pointer, the <acronym>TOAST</acronym>
management code ensures that no such pointer datum can accidentally get
stored on disk.  In-memory <acronym>TOAST</acronym> pointers are automatically
expanded to normal in-line varlena values before storage &mdash; and then
possibly converted to on-disk <acronym>TOAST</acronym> pointers, if the containing
tuple would otherwise be too big.
-->
すべてのタイプのインメモリの<acronym>TOAST</acronym>ポインタについて、<acronym>TOAST</acronym>管理のコードはそのようなポインタデータが偶然、ディスクに保存されてしまうことが決して起こらないようにします。
インメモリの<acronym>TOAST</acronym>ポインタは保存される前に自動的に展開されて通常の行内のvarlena値になります。
その後、含んでいるタプルが大きすぎるような時には、ディスク上の<acronym>TOAST</acronym>ポインタに変換されることもあります。
</para>

</sect2>

</sect1>

<sect1 id="storage-fsm">

<!--
<title>Free Space Map</title>
-->
<title>空き領域マップ</title>

<indexterm>
<!--
 <primary>Free Space Map</primary>
-->
 <primary>空き領域マップ</primary>
</indexterm>
<!--
<indexterm><primary>FSM</primary><see>Free Space Map</see></indexterm>
-->
<indexterm><primary>FSM</primary><see>空き領域マップ</see></indexterm>

<para>
<!--
Each heap and index relation, except for hash indexes, has a Free Space Map
(FSM) to keep track of available space in the relation. It's stored
alongside the main relation data in a separate relation fork, named after the
filenode number of the relation, plus a <literal>_fsm</literal> suffix. For example,
if the filenode of a relation is 12345, the FSM is stored in a file called
<filename>12345_fsm</filename>, in the same directory as the main relation file.
-->
ヒープとハッシュインデックス以外のインデックスリレーションはそれぞれ、そのリレーション内で利用可能な領域を継続して追跡するために、空き領域マップ（FSM）を持ちます。
これは、個々のリレーションのフォーク内の主リレーションデータに沿って、リレーションのファイルノード番号に<literal>_fsm</literal>という接尾辞を付けた名前のファイルに格納されます。
例えばリレーションのファイルノードが12345であれば、FSMは主リレーションファイルと同じディレクトリ内の<filename>12345_fsm</filename>という名前のファイルに格納されます。
</para>

<para>
<!--
The Free Space Map is organized as a tree of <acronym>FSM</acronym> pages. The
bottom level <acronym>FSM</acronym> pages store the free space available on each
heap (or index) page, using one byte to represent each such page. The upper
levels aggregate information from the lower levels.
-->
空き領域マップは<acronym>FSM</acronym>ページのツリーとして編成されます。
最下位レベルの<acronym>FSM</acronym>ページはすべてのヒープ（またはインデックス）ページで利用可能な空き領域を、各ページ毎に1バイト使用して格納します。
上位レベルは下位レベルからの情報を集約します。
</para>

<para>
<!--
Within each <acronym>FSM</acronym> page is a binary tree, stored in an array with
one byte per node. Each leaf node represents a heap page, or a lower level
<acronym>FSM</acronym> page. In each non-leaf node, the higher of its children's
values is stored. The maximum value in the leaf nodes is therefore stored
at the root.
-->
各<acronym>FSM</acronym>ページの内部はノード当たり1バイトを持つ配列内に格納されたバイナリツリーです。
各リーフノードはヒープページ、または下位レベルの<acronym>FSM</acronym>ページを表現します。
各非リーフノード内には、子の値より大きな値が格納されます。
したがってリーフノード内の最大値がルートに格納されます。
</para>

<para>
<!--
See <filename>src/backend/storage/freespace/README</filename> for more details on
how the <acronym>FSM</acronym> is structured, and how it's updated and searched.
The <xref linkend="pgfreespacemap"/> module
can be used to examine the information stored in free space maps.
-->
<acronym>FSM</acronym>がどのように構築されるか、そしてどのように更新、検索されるかに関する詳細は<filename>src/backend/storage/freespace/README</filename>を参照してください。
<xref linkend="pgfreespacemap"/>モジュールを使用して、空き領域マップに格納された情報を調べることができます。
</para>

</sect1>

<sect1 id="storage-vm">

<!--
<title>Visibility Map</title>
-->
<title>可視性マップ</title>

<indexterm>
<!--
 <primary>Visibility Map</primary>
-->
 <primary>可視性マップ</primary>
</indexterm>
<!--
<indexterm><primary>VM</primary><see>Visibility Map</see></indexterm>
-->
<indexterm><primary>VM</primary><see>可視性マップ</see></indexterm>

<para>
<!--
Each heap relation has a Visibility Map
(VM) to keep track of which pages contain only tuples that are known to be
visible to all active transactions; it also keeps track of which pages contain
only frozen tuples.  It's stored
alongside the main relation data in a separate relation fork, named after the
filenode number of the relation, plus a <literal>_vm</literal> suffix. For example,
if the filenode of a relation is 12345, the VM is stored in a file called
<filename>12345_vm</filename>, in the same directory as the main relation file.
Note that indexes do not have VMs.
-->
各ヒープリレーションは、どのページがすべての実行中のトランザクションから可視であることが分かっているタプルだけを含むかを追跡する、可視性マップ（VM）を持ちます。どのページが凍結状態のタプルだけを含むのかも追跡します。
これは、リレーションのファイルノード番号に<literal>_vm</literal>という接尾辞を付与した名前の別のリレーションフォーク内に主リレーションデータと並行して格納されます。
例えばリレーションのファイルノードが12345の場合、VMは主リレーションファイルと同じディレクトリ内の<filename>12345_vm</filename>というファイル内に格納されます。
インデックスはVMを持たないことに注意してください。
</para>

<para>
<!--
The visibility map stores two bits per heap page.  The first bit, if set,
indicates that the page is all-visible, or in other words that the page does
not contain any tuples that need to be vacuumed.
This information can also be used
by <link linkend="indexes-index-only-scans"><firstterm>index-only
scans</firstterm></link> to answer queries using only the index tuple.
The second bit, if set, means that all tuples on the page have been frozen.
That means that even an anti-wraparound vacuum need not revisit the page.
-->
可視性マップはヒープページ当たり2ビットを保持します。
最初のビットがセットされていれば、ページはすべて可視であること、すなわち、そのページにはバキュームが必要なタプルをまったく含んでいないことを示しています。
またこの情報は、インデックスタプルのみを使用して問い合わせに答えるために<link linkend="indexes-index-only-scans"><firstterm>インデックスオンリースキャン</firstterm></link>によっても使用されます。
2番目のビットがセットされていれば、そのページのタプルはすべて凍結状態であることを意味します。
これは、周回対策のバキュームすらそのページを再び訪れる必要はないことを意味します。
</para>

<para>
<!--
The map is conservative in the sense that we make sure that whenever a bit is
set, we know the condition is true, but if a bit is not set, it might or
might not be true. Visibility map bits are only set by vacuum, but are
cleared by any data-modifying operations on a page.
-->
このマップは、ビットがセットされている時は常にこの条件が真であることを確実に把握できるという点で保守的ですが、ビットがセットされていない場合は、真かもしれませんし偽かもしれません。
可視性マップのビットはバキュームによってのみで設定されます。
しかしページに対する任意のデータ編集操作によってクリアされます。
</para>

<para>
<!--
The <xref linkend="pgvisibility"/> module can be used to examine the
information stored in the visibility map.
-->
<xref linkend="pgvisibility"/>モジュールは可視性マップに入っている情報を確かめるのに使えます。
</para>

</sect1>

<sect1 id="storage-init">

<!--
<title>The Initialization Fork</title>
-->
<title>初期化フォーク</title>

<indexterm>
<!--
 <primary>Initialization Fork</primary>
-->
 <primary>初期化フォーク</primary>
</indexterm>

<para>
<!--
Each unlogged table, and each index on an unlogged table, has an initialization
fork.  The initialization fork is an empty table or index of the appropriate
type.  When an unlogged table must be reset to empty due to a crash, the
initialization fork is copied over the main fork, and any other forks are
erased (they will be recreated automatically as needed).
-->
ログを取らないテーブルと、ログを取らないテーブルに対するインデックスは、それぞれ初期化フォークを持ちます。
初期化フォークとは適切な種類の空テーブルと空インデックスです。
ログを取らないテーブルをクラッシュのために再度空にしなければならない場合、初期化フォークで主フォーク全体をコピーし、その他のフォークは消去されます（これらは必要に応じて自動的に再作成されます）。
</para>

</sect1>

<sect1 id="storage-page-layout">

<!--
<title>Database Page Layout</title>
-->
<title>データベースページのレイアウト</title>

<para>
<!--
This section provides an overview of the page format used within
<productname>PostgreSQL</productname> tables and indexes.<footnote>
  <para>
    Actually, use of this page format is not required for either table or
    index access methods. The <literal>heap</literal> table access method
    always uses this format.  All the existing index methods also use the
    basic format, but the data kept on index metapages usually doesn't follow
    the item layout rules.
  </para>
</footnote>
Sequences and <acronym>TOAST</acronym> tables are formatted just like a regular table.
-->
本節では<productname>PostgreSQL</productname>のテーブルおよびインデックスで使われるページ書式の概略について説明します。
<footnote>
<para>
実際には、テーブルアクセスメソッドもインデックスアクセスメソッドも、このページ書式を使用する必要はありません。
<literal>heap</literal>テーブルアクセスメソッドは常にこの書式を使用します。
既存のすべてのインデックスメソッドも、この基本書式を使用しています。しかし、インデックスメタページに保持されるデータは通常、アイテムレイアウト規則に従っていません。
  </para>
</footnote>
<acronym>TOAST</acronym>のテーブルとシーケンスは、通常のテーブルと同様に整形されています。
</para>

<para>
<!--
In the following explanation, a
<firstterm>byte</firstterm>
is assumed to contain 8 bits.  In addition, the term
<firstterm>item</firstterm>
refers to an individual data value that is stored on a page.  In a table,
an item is a row; in an index, an item is an index entry.
-->
以下の説明では1<firstterm>バイト</firstterm>は8ビットからなることを前提としています。
さらに、<firstterm>アイテム</firstterm>という単語は、ページに格納される個別のデータ値のことを指しています。
テーブル内ではアイテムは行であり、インデックス内ではアイテムはインデックスのエントリです。
</para>

<para>
<!--
Every table and index is stored as an array of <firstterm>pages</firstterm> of a
fixed size (usually 8 kB, although a different page size can be selected
when compiling the server).  In a table, all the pages are logically
equivalent, so a particular item (row) can be stored in any page.  In
indexes, the first page is generally reserved as a <firstterm>metapage</firstterm>
holding control information, and there can be different types of pages
within the index, depending on the index access method.
-->
テーブルとインデックスはすべて、固定サイズ（通常8キロバイト。サーバのコンパイル時に異なるサイズを設定可能）の<firstterm>ページ</firstterm>の集まりとして格納されます。
テーブルでは、すべてのページは論理上等価です。
したがって、あるアイテム（行）はどのページにでも格納することができます。
インデックスでは、初めのページは通常、制御用の情報を保持する<firstterm>メタページ</firstterm>として予約されます。
また、インデックスではインデックスアクセスメソッドに依存した様々なページ種類があります。
</para>

<para>
<!--
<xref linkend="page-table"/> shows the overall layout of a page.
There are five parts to each page.
-->
<xref linkend="page-table"/>はページの全体的なレイアウトを示しています。
各ページには5つの部分があります。
</para>

<table tocentry="1" id="page-table">
<!--
<title>Overall Page Layout</title>
<titleabbrev>Page Layout</titleabbrev>
-->
<title>ページレイアウト全体</title>
<titleabbrev>ページレイアウト</titleabbrev>
<tgroup cols="2">
<thead>
<row>
<entry>
<!--
Item
-->
アイテム
</entry>
<!--
<entry>Description</entry>
-->
<entry>説明</entry>
</row>
</thead>

<tbody>

<row>
 <entry>PageHeaderData</entry>
<!--
 <entry>24 bytes long. Contains general information about the page, including
free space pointers.</entry>
-->
 <entry>長さは24バイト。空き領域ポインタを含む、ページについての一般情報です。</entry>
</row>

<row>
<entry>ItemIdData</entry>
<!--
<entry>Array of item identifiers pointing to the actual items. Each
entry is an (offset,length) pair. 4 bytes per item.</entry>
-->
<entry>実際のアイテムを指すアイテム識別子の配列です。
各項目は（オフセットと長さの）ペアです。
1アイテムにつき4バイトです。</entry>
</row>

<row>
<!--
<entry>Free space</entry>
<entry>The unallocated space. New item identifiers are allocated from
the start of this area, new items from the end.</entry>
-->
<entry>空き領域</entry>
<entry>割り当てられていない空間です。
新規のアイテム識別子はこの領域の先頭から、新規のアイテムは最後から割り当てられます。
</entry>
</row>

<row>
<!--
<entry>Items</entry>
<entry>The actual items themselves.</entry>
-->
<entry>アイテム</entry>
<entry>実際のアイテムそのものです。</entry>
</row>

<row>
<!--
<entry>Special space</entry>
<entry>Index access method specific data. Different methods store different
data. Empty in ordinary tables.</entry>
-->
<entry>特別な空間</entry>
<entry>インデックスアクセスメソッド特有のデータです。異なるメソッドは異なるデータを格納します。通常のテーブルでは空です。</entry>
</row>

</tbody>
</tgroup>
</table>

 <para>

<!--
  The first 24 bytes of each page consists of a page header
  (<structname>PageHeaderData</structname>). Its format is detailed in <xref
  linkend="pageheaderdata-table"/>. The first field tracks the most
  recent WAL entry related to this page. The second field contains
  the page checksum if <xref linkend="app-initdb-data-checksums"/> are
  enabled.  Next is a 2-byte field containing flag bits. This is followed
  by three 2-byte integer fields (<structfield>pd_lower</structfield>,
  <structfield>pd_upper</structfield>, and
  <structfield>pd_special</structfield>).  These contain byte offsets
  from the page start to the start of unallocated space, to the end of
  unallocated space, and to the start of the special space.  The next 2
  bytes of the page header, <structfield>pd_pagesize_version</structfield>,
  store both the page size and a version indicator.  Beginning with
  <productname>PostgreSQL</productname> 8.3 the version number is 4;
  <productname>PostgreSQL</productname> 8.1 and 8.2 used version number 3;
  <productname>PostgreSQL</productname> 8.0 used version number 2;
  <productname>PostgreSQL</productname> 7.3 and 7.4 used version number 1;
  prior releases used version number 0.
  (The basic page layout and header format has not changed in most of these
  versions, but the layout of heap row headers has.)  The page size
  is basically only present as a cross-check; there is no support for having
  more than one page size in an installation.
  The last field is a hint that shows whether pruning the page is likely
  to be profitable: it tracks the oldest un-pruned XMAX on the page.
-->
それぞれのページの最初の24バイトはページヘッダ(<structname>PageHeaderData</structname>)から構成されています。
その書式を<xref linkend="pageheaderdata-table"/>にて説明します。
最初のフィールドは、このページに関連する最も最近のWAL項目を表しています。
2番目のフィールドには<xref linkend="app-initdb-data-checksums"/>が有効な場合にページチェックサムが格納されています。
次にフラグビットを含む2バイトのフィールドがあります。
その後に2バイトの整数フィールドが3つ続きます（<structfield>pd_lower</structfield>、<structfield>pd_upper</structfield>、<structfield>pd_special</structfield>）。
これらには、割り当てられていない空間の始まり、割り当てられていない空間の終わり、そして特別な空間の始まりのバイトオフセットが格納されています。
ページヘッダの次の2バイトである<structfield>pd_pagesize_version</structfield>は、ページサイズとバージョン指示子の両方を格納します。
<productname>PostgreSQL</productname> 8.3以降のバージョン番号は4、<productname>PostgreSQL</productname> 8.1と8.2のバージョン番号は3、<productname>PostgreSQL</productname> 8.0のバージョン番号は2、<productname>PostgreSQL</productname> 7.3と7.4のバージョン番号は1です。
それより前のリリースのバージョン番号は0です
（ほとんどのバージョン間で基本的なページレイアウトやヘッダの書式は変更されていませんが、ヒープ行ヘッダのレイアウトが変更されました）。
ページサイズは基本的に照合用としてのみ存在しています。
同一インストレーションでの複数のページサイズはサポートされていません。
最後のフィールドはそのページの切り詰めが有益かどうかを示すヒントです。
これはページ上で切り詰められていないもっとも古いXMAXが追跡するものです。

 </para>

 <table tocentry="1" id="pageheaderdata-table">
<!--
 <title>PageHeaderData Layout</title>
 <titleabbrev>PageHeaderData Layout</titleabbrev>
-->
 <title>PageHeaderDataのレイアウト</title>
 <titleabbrev>PageHeaderDataのレイアウト</titleabbrev>
 <tgroup cols="4">
 <thead>
  <row>
<!--
   <entry>Field</entry>
   <entry>Type</entry>
   <entry>Length</entry>
   <entry>Description</entry>
-->
<entry>フィールド</entry>
<entry>型</entry>
<entry>長さ</entry>
<entry>説明</entry>
  </row>
 </thead>
 <tbody>
  <row>
   <entry>pd_lsn</entry>
   <entry>PageXLogRecPtr</entry>
<!--
   <entry>8 bytes</entry>
   <entry>LSN: next byte after last byte of WAL record for last change
   to this page</entry>
-->
   <entry>8バイト</entry>
   <entry>LSN: このページへの最終変更に対応するWALレコードの最後のバイトの次のバイト</entry>
  </row>
  <row>
   <entry>pd_checksum</entry>
   <entry>uint16</entry>
<!--
   <entry>2 bytes</entry>
   <entry>Page checksum</entry>
-->
   <entry>2バイト</entry>
   <entry>ページチェックサム</entry>
  </row>
  <row>
   <entry>pd_flags</entry>
   <entry>uint16</entry>
<!--
   <entry>2 bytes</entry>
   <entry>Flag bits</entry>
-->
   <entry>2バイト</entry>
   <entry>フラグビット</entry>
  </row>
  <row>
   <entry>pd_lower</entry>
   <entry>LocationIndex</entry>
<!--
   <entry>2 bytes</entry>
   <entry>Offset to start of free space</entry>
-->
   <entry>2 バイト</entry>
   <entry>空き領域の始まりに対するオフセット</entry>
  </row>
  <row>
   <entry>pd_upper</entry>
   <entry>LocationIndex</entry>
<!--
   <entry>2 bytes</entry>
   <entry>Offset to end of free space</entry>
-->
   <entry>2バイト</entry>
   <entry>空き領域の終わりに対するオフセット</entry>
  </row>
  <row>
   <entry>pd_special</entry>
   <entry>LocationIndex</entry>
<!--
   <entry>2 bytes</entry>
   <entry>Offset to start of special space</entry>
-->
   <entry>2バイト</entry>
   <entry>特別な空間の始まりに対するオフセット</entry>
  </row>
  <row>
   <entry>pd_pagesize_version</entry>
   <entry>uint16</entry>
<!--
   <entry>2 bytes</entry>
   <entry>Page size and layout version number information</entry>
-->
   <entry>2バイト</entry>
   <entry>ページサイズおよびレイアウトのバージョン番号の情報</entry>
  </row>
  <row>
   <entry>pd_prune_xid</entry>
   <entry>TransactionId</entry>
<!--
   <entry>4 bytes</entry>
   <entry>Oldest unpruned XMAX on page, or zero if none</entry>
-->
   <entry>4バイト</entry>
   <entry>ページ上でもっとも古い切り詰められていないXMAX。存在しなければゼロ。</entry>
  </row>
 </tbody>
 </tgroup>
 </table>

 <para>
<!--
  All the details can be found in
  <filename>src/include/storage/bufpage.h</filename>.
-->
詳細情報については<filename>src/include/storage/bufpage.h</filename>を参照してください。
 </para>

 <para>

<!--
  Following the page header are item identifiers
  (<type>ItemIdData</type>), each requiring four bytes.
  An item identifier contains a byte-offset to
  the start of an item, its length in bytes, and a few attribute bits
  which affect its interpretation.
  New item identifiers are allocated
  as needed from the beginning of the unallocated space.
  The number of item identifiers present can be determined by looking at
  <structfield>pd_lower</structfield>, which is increased to allocate a new identifier.
  Because an item
  identifier is never moved until it is freed, its index can be used on a
  long-term basis to reference an item, even when the item itself is moved
  around on the page to compact free space.  In fact, every pointer to an
  item (<type>ItemPointer</type>, also known as
  <type>CTID</type>) created by
  <productname>PostgreSQL</productname> consists of a page number and the
  index of an item identifier.
-->
ページヘッダに続くのはアイテム識別子（<type>ItemIdData</type>）です。
識別子ごとに4バイトを必要とします。
アイテム識別子は、アイテムが開始されるバイトオフセット、バイト単位の長さ、そしてその解釈に影響する属性ビット群を持っています。
新しいアイテム識別子は必要に応じて、未割当て空間の最初から割り当てられます。
アイテム識別子の数は、新しい識別子を割り当てるために増加される<structfield>pd_lower</structfield>を見ることで決定できます。
アイテム識別子は解放されるまで動かされることがないので、アイテム自体が空き領域をまとめるためにページ上で移動される場合でも、そのインデックスはアイテムを参照するために長期にわたって使うことができます。
実際、<productname>PostgreSQL</productname>が作る、アイテムへのポインタ（<type>ItemPointer</type>、<type>CTID</type>とも言います）はページ番号とアイテム識別子のインデックスによって構成されています。

 </para>

 <para>

<!--
  The items themselves are stored in space allocated backwards from the end
  of unallocated space.  The exact structure varies depending on what the
  table is to contain. Tables and sequences both use a structure named
  <type>HeapTupleHeaderData</type>, described below.
-->
アイテム自体は、未割り当て空間の最後から順番に割り当てられた空間に格納されます。
正確な構造は、テーブルに何を含めるかによって異なります。
テーブルとシーケンスの両方が、以下で説明する<type>HeapTupleHeaderData</type>という構造を使用します。

 </para>

 <para>

<!--
  The final section is the <quote>special section</quote> which can
  contain anything the access method wishes to store.  For example,
  b-tree indexes store links to the page's left and right siblings,
  as well as some other data relevant to the index structure.
  Ordinary tables do not use a special section at all (indicated by setting
  <structfield>pd_special</structfield> to equal the page size).
-->
最後のセクションは、アクセスメソッドが格納しようとするものを何でも含めることのできる<quote>特別なセクション</quote>です。
例えば、B-treeインデックスは、そのページの両隣のページへのリンク、ならびに、インデックス構造体に関連したその他の何らかのデータを持ちます。
通常のテーブルではこれはまったく使用されません（ページサイズを同じにするために<structfield>pd_special</structfield>を設定することで示されます）。

 </para>

 <para>
<!--
  <xref linkend="storage-page-layout-figure"/> illustrates how these parts are
  laid out in a page.
-->
<xref linkend="storage-page-layout-figure"/>は、これらの部分がページ内でどのようにレイアウトされているかを図解しています。
 </para>

 <figure id="storage-page-layout-figure">
<!--
  <title>Page Layout</title>
-->
  <title>ページレイアウト</title>
  <mediaobject>
   <imageobject>
    <imagedata fileref="images/pagelayout.svg" format="SVG" width="100%"/>
   </imageobject>
  </mediaobject>
 </figure>

 <sect2 id="storage-tuple-layout">

<!--
 <title>Table Row Layout</title>
-->
 <title>テーブル行のレイアウト</title>

 <para>

<!--
  All table rows are structured in the same way. There is a fixed-size
  header (occupying 23 bytes on most machines), followed by an optional null
  bitmap, an optional object ID field, and the user data. The header is
  detailed
  in <xref linkend="heaptupleheaderdata-table"/>.  The actual user data
  (columns of the row) begins at the offset indicated by
  <structfield>t_hoff</structfield>, which must always be a multiple of the MAXALIGN
  distance for the platform.
  The null bitmap is
  only present if the <firstterm>HEAP_HASNULL</firstterm> bit is set in
  <structfield>t_infomask</structfield>. If it is present it begins just after
  the fixed header and occupies enough bytes to have one bit per data column
  (that is, the number of bits that equals the attribute count in
  <structfield>t_infomask2</structfield>). In this list of bits, a
  1 bit indicates not-null, a 0 bit is a null.  When the bitmap is not
  present, all columns are assumed not-null.
  The object ID is only present if the <firstterm>HEAP_HASOID_OLD</firstterm> bit
  is set in <structfield>t_infomask</structfield>.  If present, it appears just
  before the <structfield>t_hoff</structfield> boundary.  Any padding needed to make
  <structfield>t_hoff</structfield> a MAXALIGN multiple will appear between the null
  bitmap and the object ID.  (This in turn ensures that the object ID is
  suitably aligned.)
-->
テーブル行はすべて同じ方法で構成されています。
固定サイズのヘッダ（ほとんどのマシンで23バイトを占有します）があり、その後にオプションのNULLビットマップ、オプションのオブジェクトIDフィールド、およびユーザデータが続きます。
ヘッダについては<xref linkend="heaptupleheaderdata-table"/>で説明します。
実際のユーザデータ（行内の列）は、常にプラットフォームのMAXALIGN距離の倍数である<structfield>t_hoff</structfield>で示されるオフセットから始まります。
NULLビットマップは<firstterm>HEAP_HASNULL</firstterm>ビットが<structfield>t_infomask</structfield>で設定されている場合にのみ存在します。
存在する場合は、固定ヘッダのすぐ後ろから始まり、データ列ごとに1ビットとするのに十分なバイト数を占有します（すなわち、<structfield>t_infomask2</structfield>内の属性の個数と等しいビット数です）。
このビットのリスト内では、1ビットは非NULLを、0ビットはNULLを示します。
このビットマップが存在しない場合、すべての列が非NULLとみなされます。
オブジェクトIDは<firstterm>HEAP_HASOID_OLD</firstterm>ビットが<structfield>t_infomask</structfield>で設定されている場合にのみ存在します。
存在する場合、これは<structfield>t_hoff</structfield>境界の直前に現れます。
<structfield>t_hoff</structfield>をMAXALIGNの倍数とするために必要なパッドは全て、NULLビットマップとオブジェクトIDの間に現れます
（このことにより、オブジェクトIDの位置揃えが確実に適切になります）。

 </para>

 <table tocentry="1" id="heaptupleheaderdata-table">
<!--
 <title>HeapTupleHeaderData Layout</title>
 <titleabbrev>HeapTupleHeaderData Layout</titleabbrev>
-->
 <title>HeapTupleHeaderDataのレイアウト</title>
 <titleabbrev>HeapTupleHeaderDataのレイアウト</titleabbrev>
 <tgroup cols="4">
 <thead>
  <row>
<!--
   <entry>Field</entry>
   <entry>Type</entry>
   <entry>Length</entry>
   <entry>Description</entry>
-->
<entry>フィールド</entry>
<entry>型</entry>
<entry>長さ</entry>
<entry>説明</entry>
  </row>
 </thead>
 <tbody>
  <row>
   <entry>t_xmin</entry>
   <entry>TransactionId</entry>
<!--
   <entry>4 bytes</entry>
   <entry>insert XID stamp</entry>
-->
   <entry>4バイト</entry>
   <entry>挿入XIDスタンプ</entry>
  </row>
  <row>
   <entry>t_xmax</entry>
   <entry>TransactionId</entry>
<!--
   <entry>4 bytes</entry>
   <entry>delete XID stamp</entry>
-->
   <entry>4バイト</entry>
   <entry>削除XIDスタンプ</entry>
  </row>
  <row>
   <entry>t_cid</entry>
   <entry>CommandId</entry>
<!--
   <entry>4 bytes</entry>
   <entry>insert and/or delete CID stamp (overlays with t_xvac)</entry>
-->
   <entry>4バイト</entry>
   <entry>挿入、削除の両方または片方のCIDスタンプ（t_xvacと共有）</entry>
  </row>
  <row>
   <entry>t_xvac</entry>
   <entry>TransactionId</entry>
<!--
   <entry>4 bytes</entry>
   <entry>XID for VACUUM operation moving a row version</entry>
-->
   <entry>4バイト</entry>
   <entry>行バージョンを移すVACUUM操作用XID</entry>
  </row>
  <row>
   <entry>t_ctid</entry>
   <entry>ItemPointerData</entry>
<!--
   <entry>6 bytes</entry>
   <entry>current TID of this or newer row version</entry>
-->
   <entry>6バイト</entry>
   <entry>この行または最新バージョンの行の現在のTID</entry>
  </row>
  <row>
   <entry>t_infomask2</entry>
   <entry>uint16</entry>
<!--
   <entry>2 bytes</entry>
   <entry>number of attributes, plus various flag bits</entry>
-->
   <entry>2バイト</entry>
   <entry>属性の数と各種フラグビット</entry>
  </row>
  <row>
   <entry>t_infomask</entry>
   <entry>uint16</entry>
<!--
   <entry>2 bytes</entry>
   <entry>various flag bits</entry>
-->
   <entry>2バイト</entry>
   <entry>様々なフラグビット</entry>
  </row>
  <row>
   <entry>t_hoff</entry>
   <entry>uint8</entry>
<!--
   <entry>1 byte</entry>
   <entry>offset to user data</entry>
-->
   <entry>1バイト</entry>
   <entry>ユーザデータに対するオフセット</entry>
  </row>
 </tbody>
 </tgroup>
 </table>

 <para>
<!--
   All the details can be found in
   <filename>src/include/access/htup_details.h</filename>.
-->
詳細情報については<filename>src/include/access/htup_details.h</filename>を参照してください。
 </para>

 <para>

<!--
  Interpreting the actual data can only be done with information obtained
  from other tables, mostly <structname>pg_attribute</structname>. The
  key values needed to identify field locations are
  <structfield>attlen</structfield> and <structfield>attalign</structfield>.
  There is no way to directly get a
  particular attribute, except when there are only fixed width fields and no
  null values. All this trickery is wrapped up in the functions
  <firstterm>heap_getattr</firstterm>, <firstterm>fastgetattr</firstterm>
  and <firstterm>heap_getsysattr</firstterm>.
-->
実際のデータの解釈は、他のテーブル、ほとんどの場合、<structname>pg_attribute</structname>から取得された情報でのみ行うことができます。
フィールド位置を識別するために必要なキー値は、<structfield>attlen</structfield>および<structfield>attalign</structfield>です。
フィールドの幅が固定されていてNULL値が存在しない場合を除き、特定の属性を直接取得する方法はありません。
この仕組みはすべて、<firstterm>heap_getattr</firstterm>、<firstterm>fastgetattr</firstterm>および<firstterm>heap_getsysattr</firstterm>関数にラップされています。

 </para>
 <para>

<!--
  To read the data you need to examine each attribute in turn. First check
  whether the field is NULL according to the null bitmap. If it is, go to
  the next. Then make sure you have the right alignment.  If the field is a
  fixed width field, then all the bytes are simply placed. If it's a
  variable length field (attlen = -1) then it's a bit more complicated.
  All variable-length data types share the common header structure
  <type>struct varlena</type>, which includes the total length of the stored
  value and some flag bits.  Depending on the flags, the data can be either
  inline or in a <acronym>TOAST</acronym> table;
  it might be compressed, too (see <xref linkend="storage-toast"/>).
-->
データを読むためには、それぞれの属性を順番に検査する必要があります。
まず、NULLビットマップに従ってフィールドがNULLかどうかを検査します。
もしNULLであれば、次に進みます。
次に、位置揃えが正しいことを確認してください。
フィールドの幅が固定されていれば、すべてのバイトが単純に配置されます。
可変長のフィールド（attlen == -1）の場合はもう少し複雑です。
可変長のデータ型はすべて、格納する値の長さといくつかのフラグビットを持つ<type>struct varlena</type>という共通ヘッダ構造体を共有します。
フラグによって、データは行内、または別のテーブル（<acronym>TOAST</acronym>）のいずれかとなったり、圧縮済みとなったりします
（<xref linkend="storage-toast"/>を参照してください）。

 </para>
 </sect2>
</sect1>

</chapter>
