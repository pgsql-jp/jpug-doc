<!-- 警告：このファイルは直接編集しないでください！
1. func.sgmlを編集したら、split.shを起動します。
2. するとfunc[0-4].sgmlが生成されます。
3. func.sgmlとともにfunc[0-4].sgmlのうち変更されたファイルをcommit/pushしてpull requestを作成してください。
4. レビューはfunc[0-4].sgmlに対して行います。
5. 指摘された点があればfunc.sgmlに反映し、1に戻ります。
6. func.sgmlの変更がなければ、pull requestをマージして終了です。お疲れ様でした！
-->
<!-- split-func3-start -->
 <sect1 id="functions-json">
<!--
  <title>JSON Functions and Operators</title>
-->
  <title>JSON関数と演算子</title>

  <indexterm zone="functions-json">
   <primary>JSON</primary>
   <secondary>functions and operators</secondary>
  </indexterm>
 <indexterm zone="functions-json"> <!-- diff誤作動を防ぐためインデント変更 -->
  <primary>JSON</primary>
  <secondary>関数と演算子</secondary>
 </indexterm>
   <indexterm zone="functions-json">
    <primary>SQL/JSON</primary>
    <secondary>functions and expressions</secondary>
   </indexterm>
 <indexterm zone="functions-json">  <!-- diff誤作動を防ぐためインデント変更 -->
  <primary>SQL/JSON</primary>
  <secondary>関数と式</secondary>
 </indexterm>

  <para>
<!--
   This section describes:
-->
この節では次のことを説明します。

   <itemizedlist>
    <listitem>
     <para>
<!--
      functions and operators for processing and creating JSON data
-->
JSONデータを処理、生成する関数と演算子
     </para>
    </listitem>
    <listitem>
     <para>
<!--
      the SQL/JSON path language
-->
SQL/JSONパス言語
     </para>
    </listitem>
   </itemizedlist>
  </para>

  <para>
<!--
   To provide native support for JSON data types within the SQL environment,
   <productname>PostgreSQL</productname> implements the
   <firstterm>SQL/JSON data model</firstterm>.
   This model comprises sequences of items. Each item can hold SQL scalar
   values, with an additional SQL/JSON null value, and composite data structures
   that use JSON arrays and objects. The model is a formalization of the implied
   data model in the JSON specification
   <ulink url="https://datatracker.ietf.org/doc/html/rfc7159">RFC 7159</ulink>.
-->
SQL環境内のJSONデータ型にネイティブサポートを提供するために、<productname>PostgreSQL</productname><firstterm>SQL/JSONデータモデル</firstterm>を実装しています。
このモデルは、一連の項目で構成されます。
各項目は、SQLスカラ値、追加のSQL/JSON NULL値、およびJSON配列とオブジェクトを使用する複合データ構造を保持できます。
モデルは、JSON規格<ulink url="https://datatracker.ietf.org/doc/html/rfc7159">RFC 7159</ulink>で暗黙的に指定されているデータモデルを形式化したものです。
  </para>

  <para>
<!--
   SQL/JSON allows you to handle JSON data alongside regular SQL data,
   with transaction support, including:
-->
SQL/JSONでは、トランザクションをサポートをしながら、通常のSQLデータと一緒にJSONデータをハンドルすることができます。以下のものが含まれます：

  <itemizedlist>
   <listitem>
    <para>
<!--
     Uploading JSON data into the database and storing it in
     regular SQL columns as character or binary strings.
-->
JSONデータをデータベースにアップロードし、それを文字またはバイナリ文字列として通常のSQL列に保存します。
    </para>
   </listitem>
   <listitem>
    <para>
<!--
     Generating JSON objects and arrays from relational data.
-->
リレーショナルデータからJSONオブジェクトと配列を生成します。
    </para>
   </listitem>
   <listitem>
    <para>
<!--
     Querying JSON data using SQL/JSON query functions and
     SQL/JSON path language expressions.
-->
SQL/JSON問い合わせ関数およびSQL/JSONパス言語式を使用してJSONデータを照会します。
    </para>
   </listitem>
  </itemizedlist>
  </para>

  <para>
<!--
   To learn more about the SQL/JSON standard, see
   <xref linkend="sqltr-19075-6"/>. For details on JSON types
   supported in <productname>PostgreSQL</productname>,
   see <xref linkend="datatype-json"/>.
-->
SQL/JSON標準を更に学ぶためには、<xref linkend="sqltr-19075-6"/>をご覧ください。
<productname>PostgreSQL</productname>でサポートされているJSON型の詳細に関しては、<xref linkend="datatype-json"/>をご覧ください。
  </para>

  <sect2 id="functions-json-processing">
<!--
   <title>Processing and Creating JSON Data</title>
-->
   <title>JSONデータの処理と生成</title>

  <para>
<!--
   <xref linkend="functions-json-op-table"/> shows the operators that
   are available for use with JSON data types (see <xref
   linkend="datatype-json"/>).
   In addition, the usual comparison operators shown in <xref
   linkend="functions-comparison-op-table"/> are available for
   <type>jsonb</type>, though not for <type>json</type>.  The comparison
   operators follow the ordering rules for B-tree operations outlined in
   <xref linkend="json-indexing"/>.
   See also <xref linkend="functions-aggregate"/> for the aggregate
   function <function>json_agg</function> which aggregates record
   values as JSON, the aggregate function
   <function>json_object_agg</function> which aggregates pairs of values
   into a JSON object, and their <type>jsonb</type> equivalents,
   <function>jsonb_agg</function> and <function>jsonb_object_agg</function>.
-->
<xref linkend="functions-json-op-table"/>にJSONデータ型(<xref linkend="datatype-json"/>を参照)で使用可能な演算子を示します。
加えて<xref linkend="functions-comparison-op-table"/>で示す通常の比較演算子が<type>jsonb</type>で利用できますが、<type>json</type>では利用できません。
比較演算子は<xref linkend="json-indexing"/>で概要が示されているように示すBツリー操作用の順序付け規則にしたがいます。
レコードの値をJSONに集約する<function>json_agg</function>集約関数、値の対をJSONオブジェクトに集約する<function>json_object_agg</function>集約関数、およびそれらの<type>jsonb</type>版の<function>jsonb_agg</function>と<function>jsonb_object_agg</function>については<xref linkend="functions-aggregate"/>も参照して下さい。
  </para>

  <table id="functions-json-op-table">
<!--
    <title><type>json</type> and <type>jsonb</type> Operators</title>
-->
    <title><type>json</type>と<type>jsonb</type>演算子</title>
    <tgroup cols="1">
     <thead>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
<!--
        Operator
-->
演算子
       </para>
       <para>
<!--
        Description
-->
説明
       </para>
       <para>
<!--
        Example(s)
-->
例
       </para></entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>json</type> <literal>-&gt;</literal> <type>integer</type>
        <returnvalue>json</returnvalue>
       </para>
       <para role="func_signature">
        <type>jsonb</type> <literal>-&gt;</literal> <type>integer</type>
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
<!--
        Extracts <parameter>n</parameter>'th element of JSON array
        (array elements are indexed from zero, but negative integers count
        from the end).
-->
JSON配列の<parameter>n</parameter>番目の要素を取り出します。
（配列要素はゼロから始まりますが、負の整数は最後から数えられます。）
       </para>
       <para>
        <literal>'[{"a":"foo"},{"b":"bar"},{"c":"baz"}]'::json -&gt; 2</literal>
        <returnvalue>{"c":"baz"}</returnvalue>
       </para>
       <para>
        <literal>'[{"a":"foo"},{"b":"bar"},{"c":"baz"}]'::json -&gt; -3</literal>
        <returnvalue>{"a":"foo"}</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>json</type> <literal>-&gt;</literal> <type>text</type>
        <returnvalue>json</returnvalue>
       </para>
       <para role="func_signature">
        <type>jsonb</type> <literal>-&gt;</literal> <type>text</type>
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
<!--
        Extracts JSON object field with the given key.
-->
与えられたキーでJSONオブジェクトフィールドを取り出します。
       </para>
       <para>
        <literal>'{"a": {"b":"foo"}}'::json -&gt; 'a'</literal>
        <returnvalue>{"b":"foo"}</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>json</type> <literal>-&gt;&gt;</literal> <type>integer</type>
        <returnvalue>text</returnvalue>
       </para>
       <para role="func_signature">
        <type>jsonb</type> <literal>-&gt;&gt;</literal> <type>integer</type>
        <returnvalue>text</returnvalue>
       </para>
       <para>
<!--
        Extracts <parameter>n</parameter>'th element of JSON array,
        as <type>text</type>.
-->
JSON配列の<parameter>n</parameter>番目の要素を<type>text</type>として取り出します。
       </para>
       <para>
        <literal>'[1,2,3]'::json -&gt;&gt; 2</literal>
        <returnvalue>3</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>json</type> <literal>-&gt;&gt;</literal> <type>text</type>
        <returnvalue>text</returnvalue>
       </para>
       <para role="func_signature">
        <type>jsonb</type> <literal>-&gt;&gt;</literal> <type>text</type>
        <returnvalue>text</returnvalue>
       </para>
       <para>
<!--
        Extracts JSON object field with the given key, as <type>text</type>.
-->
与えられたキーでJSONオブジェクトフィールドを<type>text</type>として取り出します。
       </para>
       <para>
        <literal>'{"a":1,"b":2}'::json -&gt;&gt; 'b'</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>json</type> <literal>#&gt;</literal> <type>text[]</type>
        <returnvalue>json</returnvalue>
       </para>
       <para role="func_signature">
        <type>jsonb</type> <literal>#&gt;</literal> <type>text[]</type>
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
<!--
        Extracts JSON sub-object at the specified path, where path elements
        can be either field keys or array indexes.
-->
指定したパスにおけるJSONの副オブジェクトを取り出します。パス要素はフィールドキーあるいは配列のインデックスでも構いません。
       </para>
       <para>
        <literal>'{"a": {"b": ["foo","bar"]}}'::json #&gt; '{a,b,1}'</literal>
        <returnvalue>"bar"</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>json</type> <literal>#&gt;&gt;</literal> <type>text[]</type>
        <returnvalue>text</returnvalue>
       </para>
       <para role="func_signature">
        <type>jsonb</type> <literal>#&gt;&gt;</literal> <type>text[]</type>
        <returnvalue>text</returnvalue>
       </para>
       <para>
<!--
        Extracts JSON sub-object at the specified path as <type>text</type>.
-->
指定したパスにおけるJSONの副オブジェクトを<type>text</type>として取り出します。
       </para>
       <para>
        <literal>'{"a": {"b": ["foo","bar"]}}'::json #&gt;&gt; '{a,b,1}'</literal>
        <returnvalue>bar</returnvalue>
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <note>
   <para>
<!--
    The field/element/path extraction operators return NULL, rather than
    failing, if the JSON input does not have the right structure to match
    the request; for example if no such key or array element exists.
-->
JSON入力が要求と一致する正しい構造をしていなければ、フィールド/要素/パス抽出演算子は失敗するのではなくNULLを返します。例えばそのような要素が存在しない場合です。
   </para>
  </note>

  <para>
<!--
   Some further operators exist only for <type>jsonb</type>, as shown
   in <xref linkend="functions-jsonb-op-table"/>.
   <xref linkend="json-indexing"/>
   describes how these operators can be used to effectively search indexed
   <type>jsonb</type> data.
-->
ほかに<type>jsonb</type>だけで利用可能な演算子もいくつか存在します。
それらを<xref linkend="functions-jsonb-op-table"/>に示します。
<xref linkend="json-indexing"/>には、インデックス付された<type>jsonb</type>データを効率的に検索するためにこれらの演算子をどのように利用できるかについて書いてあります。
  </para>

  <table id="functions-jsonb-op-table">
<!--
    <title>Additional <type>jsonb</type> Operators</title>
-->
    <title>追加<type>jsonb</type>演算子</title>
    <tgroup cols="1">
     <thead>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
<!--
        Operator
-->
演算子
       </para>
       <para>
<!--
        Description
-->
説明
       </para>
       <para>
<!--
        Example(s)
-->
例
       </para></entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>jsonb</type> <literal>@&gt;</literal> <type>jsonb</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Does the first JSON value contain the second?
        (See <xref linkend="json-containment"/> for details about containment.)
-->
最初のJSON値は二番目を含んでいるか？
（包含の詳細は<xref linkend="json-containment"/>を参照してください。）
       </para>
       <para>
        <literal>'{"a":1, "b":2}'::jsonb &#64;&gt; '{"b":2}'::jsonb</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>jsonb</type> <literal>&lt;@</literal> <type>jsonb</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Is the first JSON value contained in the second?
-->
最初のJSON値は二番目に含まれているか？
       </para>
       <para>
        <literal>'{"b":2}'::jsonb &lt;@ '{"a":1, "b":2}'::jsonb</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>jsonb</type> <literal>?</literal> <type>text</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Does the text string exist as a top-level key or array element within
        the JSON value?
-->
そのテキスト文字列はトップレベルのキーあるいは配列要素としてJSON値中に存在しているか？
       </para>
       <para>
        <literal>'{"a":1, "b":2}'::jsonb ? 'b'</literal>
        <returnvalue>t</returnvalue>
       </para>
       <para>
        <literal>'["a", "b", "c"]'::jsonb ? 'b'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>jsonb</type> <literal>?|</literal> <type>text[]</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Do any of the strings in the text array exist as top-level keys or
        array elements?
-->
テキスト配列中のどれかの文字列がトップレベルのキーあるいは配列要素として存在しているか？
       </para>
       <para>
        <literal>'{"a":1, "b":2, "c":3}'::jsonb ?| array['b', 'd']</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>jsonb</type> <literal>?&amp;</literal> <type>text[]</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Do all of the strings in the text array exist as top-level keys or
        array elements?
-->
テキスト配列のすべての文字列がトップレベルのキーあるいは配列要素として存在しているか？
       </para>
       <para>
        <literal>'["a", "b", "c"]'::jsonb ?&amp; array['a', 'b']</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>jsonb</type> <literal>||</literal> <type>jsonb</type>
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
<!--
        Concatenates two <type>jsonb</type> values.
        Concatenating two arrays generates an array containing all the
        elements of each input.  Concatenating two objects generates an
        object containing the union of their
        keys, taking the second object's value when there are duplicate keys.
        All other cases are treated by converting a non-array input into a
        single-element array, and then proceeding as for two arrays.
        Does not operate recursively: only the top-level array or object
        structure is merged.
-->
2つの<type>jsonb</type>値を結合します。
2つの配列を結合するとそれらのキーの和を持つ配列を生成します。
キーが重複している場合は2番目のオブジェクトの値が使用されます。
それ以外の場合には非配列入力を単一の要素を持つ配列に変換し、次に2つの配列として取り扱います。
再帰操作は行いません。トップレベルの配列あるいはオブジェクト構造だけがマージされます。
       </para>
       <para>
        <literal>'["a", "b"]'::jsonb || '["a", "d"]'::jsonb</literal>
        <returnvalue>["a", "b", "a", "d"]</returnvalue>
       </para>
       <para>
        <literal>'{"a": "b"}'::jsonb || '{"c": "d"}'::jsonb</literal>
        <returnvalue>{"a": "b", "c": "d"}</returnvalue>
       </para>
       <para>
        <literal>'[1, 2]'::jsonb || '3'::jsonb</literal>
        <returnvalue>[1, 2, 3]</returnvalue>
       </para>
       <para>
        <literal>'{"a": "b"}'::jsonb || '42'::jsonb</literal>
        <returnvalue>[{"a": "b"}, 42]</returnvalue>
       </para>
       <para>
<!--
        To append an array to another array as a single entry, wrap it
        in an additional layer of array, for example:
-->
一つの要素を持つとして配列を他の配列に追加するには、例のように配列の追加のレイヤ中に含めてください。
       </para>
       <para>
        <literal>'[1, 2]'::jsonb || jsonb_build_array('[3, 4]'::jsonb)</literal>
        <returnvalue>[1, 2, [3, 4]]</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>jsonb</type> <literal>-</literal> <type>text</type>
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
<!--
        Deletes a key (and its value) from a JSON object, or matching string
        value(s) from a JSON array.
-->
キー（及びその値）をJSONオブジェクトから削除します。あるいはマッチする文字列値をJSON配列から削除します。
       </para>
       <para>
        <literal>'{"a": "b", "c": "d"}'::jsonb - 'a'</literal>
        <returnvalue>{"c": "d"}</returnvalue>
       </para>
       <para>
        <literal>'["a", "b", "c", "b"]'::jsonb - 'b'</literal>
        <returnvalue>["a", "c"]</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>jsonb</type> <literal>-</literal> <type>text[]</type>
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
<!--
        Deletes all matching keys or array elements from the left operand.
-->
左のオペランドからマッチするすべてのキーあるいは配列要素を削除します。
       </para>
       <para>
        <literal>'{"a": "b", "c": "d"}'::jsonb - '{a,c}'::text[]</literal>
        <returnvalue>{}</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>jsonb</type> <literal>-</literal> <type>integer</type>
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
<!--
        Deletes the array element with specified index (negative
        integers count from the end).  Throws an error if JSON value
        is not an array.
-->
指定したインデックス（負の整数は最後から数えます）の配列要素を削除します。
JSON値が配列でなければエラーが生じます。
       </para>
       <para>
        <literal>'["a", "b"]'::jsonb - 1 </literal>
        <returnvalue>["a"]</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>jsonb</type> <literal>#-</literal> <type>text[]</type>
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
<!--
        Deletes the field or array element at the specified path, where path
        elements can be either field keys or array indexes.
-->
指定パスのフィールドあるいは配列要素を削除します。パス要素はフィールドキーあるいは配列インデックスが指定できます。
       </para>
       <para>
        <literal>'["a", {"b":1}]'::jsonb #- '{1,b}'</literal>
        <returnvalue>["a", {}]</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>jsonb</type> <literal>@?</literal> <type>jsonpath</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Does JSON path return any item for the specified JSON value?
-->
JSONパスは指定したJSON値の要素を返すか？
       </para>
       <para>
        <literal>'{"a":[1,2,3,4,5]}'::jsonb @? '$.a[*] ? (@ > 2)'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>jsonb</type> <literal>@@</literal> <type>jsonpath</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Returns the result of a JSON path predicate check for the
        specified JSON value.  Only the first item of the result is taken into
        account.  If the result is not Boolean, then <literal>NULL</literal>
        is returned.
-->
指定したJSON値に対するJSONパス述語チェックの結果を返します。
結果の最初の項目だけが考慮されます。
結果が論理値でなければ<literal>NULL</literal>が返ります。
       </para>
       <para>
        <literal>'{"a":[1,2,3,4,5]}'::jsonb @@ '$.a[*] > 2'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <note>
   <para>
<!--
    The <type>jsonpath</type> operators <literal>@?</literal>
    and <literal>@@</literal> suppress the following errors: missing object
    field or array element, unexpected JSON item type, datetime and numeric
    errors.  The <type>jsonpath</type>-related functions described below can
    also be told to suppress these types of errors.  This behavior might be
    helpful when searching JSON document collections of varying structure.
-->
<type>jsonpath</type>演算子の<literal>@?</literal>および<literal>@@</literal>演算子は以下のエラーを抑止します。
オブジェクトフィールドあるいは配列要素の欠如、期待しないJSON要素型、日付時刻及び数値エラー。
以下に示す<type>jsonpath</type>関連の関数もこれらのエラーを抑止するようにすることもできます。
この振る舞いは、異なる構造のJSON文書集合を検索する際に役に立つかも知れません。
   </para>
  </note>

  <para>
<!--
   <xref linkend="functions-json-creation-table"/> shows the functions that are
   available for constructing <type>json</type> and <type>jsonb</type> values.
-->
<xref linkend="functions-json-creation-table"/>に、<type>json</type>値および<type>jsonb</type>値を作成するために利用可能な関数を示します。
<!--
   Some functions in this table have a <literal>RETURNING</literal> clause,
   which specifies the data type returned.  It must be one of <type>json</type>,
   <type>jsonb</type>, <type>bytea</type>, a character string type (<type>text</type>,
   <type>char</type>, or <type>varchar</type>), or a type
   for which there is a cast from <type>json</type> to that type.
   By default, the <type>json</type> type is returned.
-->
このテーブルの一部の関数は、返されるデータ型を指定する<literal>RETURNING</literal>句を持っています。
これは<type>json</type>、<type>jsonb</type>、<type>bytea</type>、文字列型（<type>text</type>、<type>char</type>、<type>varchar</type>）、あるいは<type>json</type>からその型へのキャストがある型のいずれかでなければなりません。
デフォルトでは<type>json</type>型が返されます。
  </para>

  <table id="functions-json-creation-table">
<!--
    <title>JSON Creation Functions</title>
-->
    <title>JSON作成関数</title>
    <tgroup cols="1">
     <thead>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
<!--
        Function
-->
関数
       </para>
       <para>
<!--
        Description
-->
説明
       </para>
       <para>
<!--
        Example(s)
-->
例
       </para></entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>to_json</primary>
        </indexterm>
        <function>to_json</function> ( <type>anyelement</type> )
        <returnvalue>json</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>to_jsonb</primary>
        </indexterm>
        <function>to_jsonb</function> ( <type>anyelement</type> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
<!--
        Converts any SQL value to <type>json</type> or <type>jsonb</type>.
        Arrays and composites are converted recursively to arrays and
        objects (multidimensional arrays become arrays of arrays in JSON).
        Otherwise, if there is a cast from the SQL data type
        to <type>json</type>, the cast function will be used to perform the
        conversion;<footnote>
-->
SQL値を<type>json</type>あるいは<type>jsonb</type>に変換します。
配列と複合型は再帰的に配列とオブジェクトに変換されます。（多次元配列はJSONにおける配列の配列になります。）
それ以外は、そのSQLデータ型から<type>json</type>にキャストがあれば、キャスト関数が変換のために用いられます。<footnote>
         <para>
<!--
          For example, the <xref linkend="hstore"/> extension has a cast
          from <type>hstore</type> to <type>json</type>, so that
          <type>hstore</type> values converted via the JSON creation functions
          will be represented as JSON objects, not as primitive string values.
-->
たとえば<xref linkend="hstore"/>拡張には<type>hstore</type>から<type>json</type>へのキャストがあり、JSON生成関数で変換された<type>hstore</type>値は、原始的な文字列値としてではなく、JSONオブジェクトとして表示されます。
         </para>
        </footnote>
<!--
        otherwise, a scalar JSON value is produced.  For any scalar other than
        a number, a Boolean, or a null value, the text representation will be
        used, with escaping as necessary to make it a valid JSON string value.
-->
そうでなければスカラJSON値が生成されます。
数値、論理値、NULL以外のスカラには、有効なJSON文字列値にするための必要なエスケープ処理が施されたテキスト表現が使われます。
       </para>
       <para>
        <literal>to_json('Fred said "Hi."'::text)</literal>
        <returnvalue>"Fred said \"Hi.\""</returnvalue>
       </para>
       <para>
        <literal>to_jsonb(row(42, 'Fred said "Hi."'::text))</literal>
        <returnvalue>{"f1": 42, "f2": "Fred said \"Hi.\""}</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_to_json</primary>
        </indexterm>
        <function>array_to_json</function> ( <type>anyarray</type> <optional>, <type>boolean</type> </optional> )
        <returnvalue>json</returnvalue>
       </para>
       <para>
<!--
        Converts an SQL array to a JSON array.  The behavior is the same
        as <function>to_json</function> except that line feeds will be added
        between top-level array elements if the optional boolean parameter is
        true.
-->
SQL配列をJSON配列に変換します。
追加の論理引数が真であるときに改行がトップレベルの配列要素の間に加えられる以外は、その振る舞いは<function>to_json</function>と同じです。
       </para>
       <para>
        <literal>array_to_json('{{1,5},{99,100}}'::int[])</literal>
        <returnvalue>[[1,5],[99,100]]</returnvalue>
       </para></entry>
      </row>

      <row>
       <!--
           Note that this is barely legible in the output; it looks like a
           salad of braces and brackets.  It would be better to split it out
           in multiple lines, but that's surprisingly hard to do in a way that
           matches in HTML and PDF output.  Other standard SQL/JSON functions
           have the same problem.
これは出力中で辛うじて読めるものであることに注意してください。まるで中括弧と大括弧の混ぜ合わせのように見えます。
複数行に分割したほうが良いのかも知れませんが、HTMLやPDF出力でそれを行うのは驚くほど難しいのです。
他の標準SQL/JSON関数も同じ問題を抱えています。
         -->
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm><primary>json_array</primary></indexterm>
         <function>json_array</function> (
         <optional> { <replaceable>value_expression</replaceable> <optional> <literal>FORMAT JSON</literal> </optional> } <optional>, ...</optional> </optional>
         <optional> { <literal>NULL</literal> | <literal>ABSENT</literal> } <literal>ON NULL</literal> </optional>
         <optional> <literal>RETURNING</literal> <replaceable>data_type</replaceable> <optional> <literal>FORMAT JSON</literal> <optional> <literal>ENCODING UTF8</literal> </optional> </optional> </optional>)
        </para>
        <para role="func_signature">
         <function>json_array</function> (
         <optional> <replaceable>query_expression</replaceable> </optional>
         <optional> <literal>RETURNING</literal> <replaceable>data_type</replaceable> <optional> <literal>FORMAT JSON</literal> <optional> <literal>ENCODING UTF8</literal> </optional> </optional> </optional>)
        </para>
        <para>
<!--
         Constructs a JSON array from either a series of
         <replaceable>value_expression</replaceable> parameters or from the results
         of <replaceable>query_expression</replaceable>,
         which must be a SELECT query returning a single column. If
         <literal>ABSENT ON NULL</literal> is specified, NULL values are ignored.
         This is always the case if a
         <replaceable>query_expression</replaceable> is used.
-->
JSON配列を、一連の<replaceable>value_expression</replaceable>引数、または<replaceable>query_expression</replaceable>の結果のいずれかから構成します。
<replaceable>query_expression</replaceable>は、単一の列を返すSELECT問い合わせである必要があります。
<literal>ABSENT ON NULL</literal>が指定されている場合、NULL値は無視されます。
<replaceable>query_expression</replaceable>が使用されている場合、常にそうなります。
        </para>
        <para>
         <literal>json_array(1,true,json '{"a":null}')</literal>
         <returnvalue>[1, true, {"a":null}]</returnvalue>
        </para>
        <para>
         <literal>json_array(SELECT * FROM (VALUES(1),(2)) t)</literal>
         <returnvalue>[1, 2]</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>row_to_json</primary>
        </indexterm>
        <function>row_to_json</function> ( <type>record</type> <optional>, <type>boolean</type> </optional> )
        <returnvalue>json</returnvalue>
       </para>
       <para>
<!--
        Converts an SQL composite value to a JSON object.  The behavior is the
        same as <function>to_json</function> except that line feeds will be
        added between top-level elements if the optional boolean parameter is
        true.
-->
SQL複合値をJSONオブジェクトに変換します。
追加の論理引数が真であるときに改行がトップレベルの配列要素の間に加えられる以外は、その振る舞いは<function>to_json</function>と同じです。
       </para>
       <para>
        <literal>row_to_json(row(1,'foo'))</literal>
        <returnvalue>{"f1":1,"f2":"foo"}</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_build_array</primary>
        </indexterm>
        <function>json_build_array</function> ( <literal>VARIADIC</literal> <type>"any"</type> )
        <returnvalue>json</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_build_array</primary>
        </indexterm>
        <function>jsonb_build_array</function> ( <literal>VARIADIC</literal> <type>"any"</type> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
<!--
        Builds a possibly-heterogeneously-typed JSON array out of a variadic
        argument list.  Each argument is converted as
        per <function>to_json</function> or <function>to_jsonb</function>.
-->
異なる型から構成される可能性のあるJSON配列をvariadic引数リストから作成します。
各々の引数は<function>to_json</function>あるいは<function>to_jsonb</function>に従って変換されます。
       </para>
       <para>
        <literal>json_build_array(1, 2, 'foo', 4, 5)</literal>
        <returnvalue>[1, 2, "foo", 4, 5]</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_build_object</primary>
        </indexterm>
        <function>json_build_object</function> ( <literal>VARIADIC</literal> <type>"any"</type> )
        <returnvalue>json</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_build_object</primary>
        </indexterm>
        <function>jsonb_build_object</function> ( <literal>VARIADIC</literal> <type>"any"</type> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
<!--
        Builds a JSON object out of a variadic argument list.  By convention,
        the argument list consists of alternating keys and values.  Key
        arguments are coerced to text; value arguments are converted as
        per <function>to_json</function> or <function>to_jsonb</function>.
-->
variadic引数リストからJSONオブジェクトを作成します。
慣例により引数リストは代替キーと値が交互に並んだものです。
キー引数はテキストに強制的に変換されます。
値引数は<function>to_json</function>あるいは<function>to_jsonb</function>に従って変換されます。
       </para>
       <para>
        <literal>json_build_object('foo', 1, 2, row(3,'bar'))</literal>
        <returnvalue>{"foo" : 1, "2" : {"f1":3,"f2":"bar"}}</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
         <indexterm><primary>json_object</primary></indexterm>
         <function>json_object</function> (
         <optional> { <replaceable>key_expression</replaceable> { <literal>VALUE</literal> | ':' }
          <replaceable>value_expression</replaceable> <optional> <literal>FORMAT JSON</literal> <optional> <literal>ENCODING UTF8</literal> </optional> </optional> }<optional>, ...</optional> </optional>
         <optional> { <literal>NULL</literal> | <literal>ABSENT</literal> } <literal>ON NULL</literal> </optional>
         <optional> { <literal>WITH</literal> | <literal>WITHOUT</literal> } <literal>UNIQUE</literal> <optional> <literal>KEYS</literal> </optional> </optional>
         <optional> <literal>RETURNING</literal> <replaceable>data_type</replaceable> <optional> <literal>FORMAT JSON</literal> <optional> <literal>ENCODING UTF8</literal> </optional> </optional> </optional>)
        </para>
        <para>
<!--
         Constructs a JSON object of all the key/value pairs given,
         or an empty object if none are given.
         <replaceable>key_expression</replaceable> is a scalar expression
         defining the <acronym>JSON</acronym> key, which is
         converted to the <type>text</type> type.
         It cannot be <literal>NULL</literal> nor can it
         belong to a type that has a cast to the <type>json</type> type.
         If <literal>WITH UNIQUE KEYS</literal> is specified, there must not
         be any duplicate <replaceable>key_expression</replaceable>.
         Any pair for which the <replaceable>value_expression</replaceable>
         evaluates to <literal>NULL</literal> is omitted from the output
         if <literal>ABSENT ON NULL</literal> is specified;
         if <literal>NULL ON NULL</literal> is specified or the clause
         omitted, the key is included with value <literal>NULL</literal>.
-->
指定されたすべてのキー/値ペアのJSONオブジェクトを構築します。
キー/値ペアが指定されていない場合は、空のオブジェクトを構築します。
<replaceable>key_expression</replaceable>は、<type>text</type>タイプに変換される<acronym>JSON</acronym>キーを定義するスカラ式です。
<literal>NULL</literal>にすることも、<type>JSON</type>タイプにキャストを持つタイプに属することもできません。
<literal>WITH UNIQUE KEYS</literal>が指定されている場合は、重複<replaceable>key_expression</replaceable>があってはなりません。
<literal>ABSENT ON NULL</literal>が指定されている場合、<literal>NULL</literal>と評価される<replaceable>value_expression</replaceable>は出力から除外されます。
<literal>NULL ON NULL</literal>が指定されているか、その句が省略されている場合、キーは<literal>NULL</literal>の値で含まれます。
        </para>
        <para>
         <literal>json_object('code' VALUE 'P123', 'title': 'Jaws')</literal>
         <returnvalue>{"code" : "P123", "title" : "Jaws"}</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_object</primary>
        </indexterm>
        <function>json_object</function> ( <type>text[]</type> )
        <returnvalue>json</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_object</primary>
        </indexterm>
        <function>jsonb_object</function> ( <type>text[]</type> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
<!--
        Builds a JSON object out of a text array.  The array must have either
        exactly one dimension with an even number of members, in which case
        they are taken as alternating key/value pairs, or two dimensions
        such that each inner array has exactly two elements, which
        are taken as a key/value pair.  All values are converted to JSON
        strings.
-->
テキスト配列からJSONオブジェクトを作成します。
配列は、偶数個の要素からなる1次元（キー／値の対が交互に並んでいるものと扱われます）あるいは内側の配列が2つの要素を持つ2次元（2つの要素がキー／値のペアとして扱われます）のいずれかでなければなりません。
すべての値はJSON文字列に変換されます。
       </para>
       <para>
        <literal>json_object('{a, 1, b, "def", c, 3.5}')</literal>
        <returnvalue>{"a" : "1", "b" : "def", "c" : "3.5"}</returnvalue>
       </para>
        <para><literal>json_object('{{a, 1}, {b, "def"}, {c, 3.5}}')</literal>
        <returnvalue>{"a" : "1", "b" : "def", "c" : "3.5"}</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>json_object</function> ( <parameter>keys</parameter> <type>text[]</type>, <parameter>values</parameter> <type>text[]</type> )
        <returnvalue>json</returnvalue>
       </para>
       <para role="func_signature">
        <function>jsonb_object</function> ( <parameter>keys</parameter> <type>text[]</type>, <parameter>values</parameter> <type>text[]</type> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
<!--
        This form of <function>json_object</function> takes keys and values
        pairwise from separate text arrays.  Otherwise it is identical to
        the one-argument form.
-->
この形の<function>json_object</function>は2つの別々の配列からキーと値の対を取ります。
他の点ではすべて、引数1つの形と同じです。
       </para>
       <para>
        <literal>json_object('{a,b}', '{1,2}')</literal>
        <returnvalue>{"a": "1", "b": "2"}</returnvalue>
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <para>
<!--
   <xref linkend="functions-sqljson-misc" /> details SQL/JSON
   facilities for testing JSON.
-->
<xref linkend="functions-sqljson-misc" />には、JSONをテストするためのSQL/JSON機能の詳細が記載されています。
  </para>

  <table id="functions-sqljson-misc">
<!--
   <title>SQL/JSON Testing Functions</title>
-->
   <title>SQL/JSONテスト用関数</title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="func_table_entry"><para role="func_signature">
<!--
        Function signature
-->
関数の呼び出し形式
       </para>
       <para>
<!--
        Description
-->
説明
       </para>
       <para>
<!--
        Example(s)
-->
例
      </para></entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry role="func_table_entry"><para role="func_signature">
        <indexterm><primary>IS JSON</primary></indexterm>
        <replaceable>expression</replaceable> <literal>IS</literal> <optional> <literal>NOT</literal> </optional> <literal>JSON</literal>
        <optional> { <literal>VALUE</literal> | <literal>SCALAR</literal> | <literal>ARRAY</literal> | <literal>OBJECT</literal> } </optional>
        <optional> { <literal>WITH</literal> | <literal>WITHOUT</literal> } <literal>UNIQUE</literal> <optional> <literal>KEYS</literal> </optional> </optional>
       </para>
       <para>
<!--
        This predicate tests whether <replaceable>expression</replaceable> can be
        parsed as JSON, possibly of a specified type.
        If <literal>SCALAR</literal> or <literal>ARRAY</literal> or
        <literal>OBJECT</literal> is specified, the
        test is whether or not the JSON is of that particular type. If
        <literal>WITH UNIQUE KEYS</literal> is specified, then any object in the
        <replaceable>expression</replaceable> is also tested to see if it
        has duplicate keys.
-->
この述語は、<replaceable>expression</replaceable>が指定された型のJSONとして解析できるかどうかをテストします。
<literal>SCALAR</literal>、<literal>ARRAY</literal>、または<literal>OBJECT</literal>が指定されている場合、テストはJSONがその特定の型のものであるかどうかを示します。
<literal>WITH UNIQUE KEYS</literal>が指定されている場合、<replaceable>expression</replaceable>のオブジェクトもテストされ、重複キーがあるかどうかが確認されます。
       </para>
       <para>
<programlisting>
SELECT js,
  js IS JSON "json?",
  js IS JSON SCALAR "scalar?",
  js IS JSON OBJECT "object?",
  js IS JSON ARRAY "array?"
FROM (VALUES
      ('123'), ('"abc"'), ('{"a": "b"}'), ('[1,2]'),('abc')) foo(js);
     js     | json? | scalar? | object? | array?
------------+-------+---------+---------+--------
 123        | t     | t       | f       | f
 "abc"      | t     | t       | f       | f
 {"a": "b"} | t     | f       | t       | f
 [1,2]      | t     | f       | f       | t
 abc        | f     | f       | f       | f
</programlisting>
       </para>
       <para>
<programlisting>
SELECT js,
  js IS JSON OBJECT "object?",
  js IS JSON ARRAY "array?",
  js IS JSON ARRAY WITH UNIQUE KEYS "array w. UK?",
  js IS JSON ARRAY WITHOUT UNIQUE KEYS "array w/o UK?"
FROM (VALUES ('[{"a":"1"},
 {"b":"2","b":"3"}]')) foo(js);
-[ RECORD 1 ]-+--------------------
js            | [{"a":"1"},        +
              |  {"b":"2","b":"3"}]
object?       | f
array?        | t
array w. UK?  | f
array w/o UK? | t
</programlisting>
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
<!--
   <xref linkend="functions-json-processing-table"/> shows the functions that
   are available for processing <type>json</type> and <type>jsonb</type> values.
-->
<xref linkend="functions-json-processing-table"/>に<type>json</type>と<type>jsonb</type>値を処理するのに使える関数を示します。
  </para>

  <table id="functions-json-processing-table">
<!--
    <title>JSON Processing Functions</title>
-->
    <title>JSON処理関数</title>
    <tgroup cols="1">
     <thead>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
<!--
        Function
-->
関数
       </para>
       <para>
<!--
        Description
-->
説明
       </para>
       <para>
<!--
        Example(s)
-->
例
       </para></entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_array_elements</primary>
        </indexterm>
        <function>json_array_elements</function> ( <type>json</type> )
        <returnvalue>setof json</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_array_elements</primary>
        </indexterm>
        <function>jsonb_array_elements</function> ( <type>jsonb</type> )
        <returnvalue>setof jsonb</returnvalue>
       </para>
       <para>
<!--
        Expands the top-level JSON array into a set of JSON values.
-->
トップレベルのJSON配列をJSON値の集合に展開します。
       </para>
       <para>
        <literal>select * from json_array_elements('[1,true, [2,false]]')</literal>
        <returnvalue></returnvalue>
<programlisting>
   value
-----------
 1
 true
 [2,false]
</programlisting>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_array_elements_text</primary>
        </indexterm>
        <function>json_array_elements_text</function> ( <type>json</type> )
        <returnvalue>setof text</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_array_elements_text</primary>
        </indexterm>
        <function>jsonb_array_elements_text</function> ( <type>jsonb</type> )
        <returnvalue>setof text</returnvalue>
       </para>
       <para>
<!--
        Expands the top-level JSON array into a set of <type>text</type> values.
-->
トップレベルのJSON配列を<type>text</type>値の集合に展開します。
       </para>
       <para>
        <literal>select * from json_array_elements_text('["foo", "bar"]')</literal>
        <returnvalue></returnvalue>
<programlisting>
   value
-----------
 foo
 bar
</programlisting>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_array_length</primary>
        </indexterm>
        <function>json_array_length</function> ( <type>json</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_array_length</primary>
        </indexterm>
        <function>jsonb_array_length</function> ( <type>jsonb</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
<!--
        Returns the number of elements in the top-level JSON array.
-->
トップレベルのJSON配列の要素数を返します。
       </para>
       <para>
        <literal>json_array_length('[1,2,3,{"f1":1,"f2":[5,6]},4]')</literal>
        <returnvalue>5</returnvalue>
       </para>
       <para>
        <literal>jsonb_array_length('[]')</literal>
        <returnvalue>0</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_each</primary>
        </indexterm>
        <function>json_each</function> ( <type>json</type> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>key</parameter> <type>text</type>,
        <parameter>value</parameter> <type>json</type> )
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_each</primary>
        </indexterm>
        <function>jsonb_each</function> ( <type>jsonb</type> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>key</parameter> <type>text</type>,
        <parameter>value</parameter> <type>jsonb</type> )
       </para>
       <para>
<!--
        Expands the top-level JSON object into a set of key/value pairs.
-->
トップレベルのJSONオブジェクトをキー／値のペアの集合に展開します。
       </para>
       <para>
        <literal>select * from json_each('{"a":"foo", "b":"bar"}')</literal>
        <returnvalue></returnvalue>
<programlisting>
 key | value
-----+-------
 a   | "foo"
 b   | "bar"
</programlisting>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_each_text</primary>
        </indexterm>
        <function>json_each_text</function> ( <type>json</type> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>key</parameter> <type>text</type>,
        <parameter>value</parameter> <type>text</type> )
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_each_text</primary>
        </indexterm>
        <function>jsonb_each_text</function> ( <type>jsonb</type> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>key</parameter> <type>text</type>,
        <parameter>value</parameter> <type>text</type> )
       </para>
       <para>
<!--
        Expands the top-level JSON object into a set of key/value pairs.
        The returned <parameter>value</parameter>s will be of
        type <type>text</type>.
-->
トップレベルのJSONオブジェクトをキー／値のペアの集合に展開します。
返り値の<parameter>value</parameter>は<type>text</type>型です。
       </para>
       <para>
        <literal>select * from json_each_text('{"a":"foo", "b":"bar"}')</literal>
        <returnvalue></returnvalue>
<programlisting>
 key | value
-----+-------
 a   | foo
 b   | bar
</programlisting>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_extract_path</primary>
        </indexterm>
        <function>json_extract_path</function> ( <parameter>from_json</parameter> <type>json</type>, <literal>VARIADIC</literal> <parameter>path_elems</parameter> <type>text[]</type> )
        <returnvalue>json</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_extract_path</primary>
        </indexterm>
        <function>jsonb_extract_path</function> ( <parameter>from_json</parameter> <type>jsonb</type>, <literal>VARIADIC</literal> <parameter>path_elems</parameter> <type>text[]</type> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
<!--
        Extracts JSON sub-object at the specified path.
        (This is functionally equivalent to the <literal>#&gt;</literal>
        operator, but writing the path out as a variadic list can be more
        convenient in some cases.)
-->
指定したパスにおけるJSONの副オブジェクトを取り出します。
（これは<literal>#&gt;</literal>演算子と機能的に同じですが、パスをvariadicリストで書き出す方がより便利な場合があります。）
       </para>
       <para>
        <literal>json_extract_path('{"f2":{"f3":1},"f4":{"f5":99,"f6":"foo"}}', 'f4', 'f6')</literal>
        <returnvalue>"foo"</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_extract_path_text</primary>
        </indexterm>
        <function>json_extract_path_text</function> ( <parameter>from_json</parameter> <type>json</type>, <literal>VARIADIC</literal> <parameter>path_elems</parameter> <type>text[]</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_extract_path_text</primary>
        </indexterm>
        <function>jsonb_extract_path_text</function> ( <parameter>from_json</parameter> <type>jsonb</type>, <literal>VARIADIC</literal> <parameter>path_elems</parameter> <type>text[]</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
<!--
        Extracts JSON sub-object at the specified path as <type>text</type>.
        (This is functionally equivalent to the <literal>#&gt;&gt;</literal>
        operator.)
-->
指定したパスにおけるJSONの副オブジェクトを<type>text</type>として取り出します。
（これは機能的には<literal>#&gt;&gt;</literal>演算子と同じです。）
       </para>
       <para>
        <literal>json_extract_path_text('{"f2":{"f3":1},"f4":{"f5":99,"f6":"foo"}}', 'f4', 'f6')</literal>
        <returnvalue>foo</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_object_keys</primary>
        </indexterm>
        <function>json_object_keys</function> ( <type>json</type> )
        <returnvalue>setof text</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_object_keys</primary>
        </indexterm>
        <function>jsonb_object_keys</function> ( <type>jsonb</type> )
        <returnvalue>setof text</returnvalue>
       </para>
       <para>
<!--
        Returns the set of keys in the top-level JSON object.
-->
トップレベルのJSONオブジェクト中のキーの集合を返します。
       </para>
       <para>
        <literal>select * from json_object_keys('{"f1":"abc","f2":{"f3":"a", "f4":"b"}}')</literal>
        <returnvalue></returnvalue>
<programlisting>
 json_object_keys
------------------
 f1
 f2
</programlisting>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_populate_record</primary>
        </indexterm>
        <function>json_populate_record</function> ( <parameter>base</parameter> <type>anyelement</type>, <parameter>from_json</parameter> <type>json</type> )
        <returnvalue>anyelement</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_populate_record</primary>
        </indexterm>
        <function>jsonb_populate_record</function> ( <parameter>base</parameter> <type>anyelement</type>, <parameter>from_json</parameter> <type>jsonb</type> )
        <returnvalue>anyelement</returnvalue>
       </para>
       <para>
<!--
        Expands the top-level JSON object to a row having the composite type
        of the <parameter>base</parameter> argument.  The JSON object
        is scanned for fields whose names match column names of the output row
        type, and their values are inserted into those columns of the output.
        (Fields that do not correspond to any output column name are ignored.)
        In typical use, the value of <parameter>base</parameter> is just
        <literal>NULL</literal>, which means that any output columns that do
        not match any object field will be filled with nulls.  However,
        if <parameter>base</parameter> isn't <literal>NULL</literal> then
        the values it contains will be used for unmatched columns.
-->
トップレベルのJSONオブジェクトを<parameter>base</parameter>引数である複合型を持つ行に展開します。
JSONオブジェクトは出力行型の列名と一致するフィールドが検査されます。
（出力列名と関連のないフィールドは無視されます。）
典型的な使い方としては、<parameter>base</parameter>の値が単に<literal>NULL</literal>で、これはオブジェクトフィールドと一致しない出力列にはNULLがセットされることを意味します。
しかし、<parameter>base</parameter>が<literal>NULL</literal>でないなら、それが持つ値が一致しない列に使われます。
       </para>
       <para>
<!--
        To convert a JSON value to the SQL type of an output column, the
        following rules are applied in sequence:
-->
JSON値を出力列のSQL型に変換する際に以下のルールが順に適用されます。
        <itemizedlist spacing="compact">
         <listitem>
          <para>
<!--
           A JSON null value is converted to an SQL null in all cases.
-->
すべての場合にJSONのNULL値はSQLのNULLに変換されます。
          </para>
         </listitem>
         <listitem>
          <para>
<!--
           If the output column is of type <type>json</type>
           or <type>jsonb</type>, the JSON value is just reproduced exactly.
-->
出力列が<type>json</type>型あるいは<type>jsonb</type>型なら、JSON値は単にそのまま複製されます。
          </para>
         </listitem>
         <listitem>
          <para>
<!--
           If the output column is a composite (row) type, and the JSON value
           is a JSON object, the fields of the object are converted to columns
           of the output row type by recursive application of these rules.
-->
出力行が複合(行)型でJSON値がJSONオブジェクトなら、これらのルールを再帰的に適用することによって、オブジェクトのフィールドが出力行型の列に変換されます。
          </para>
         </listitem>
         <listitem>
          <para>
<!--
           Likewise, if the output column is an array type and the JSON value
           is a JSON array, the elements of the JSON array are converted to
           elements of the output array by recursive application of these
           rules.
-->
同様に、出力行が配列型でJSON値がJSON配列なら、これらのルールを再帰的に適用することによって、JSON配列の要素が出力配列の要素に変換されます。
          </para>
         </listitem>
         <listitem>
          <para>
<!--
           Otherwise, if the JSON value is a string, the contents of the
           string are fed to the input conversion function for the column's
           data type.
-->
それ以外の場合で、JSON値が文字列なら、その文字列の内容が列のデータ型に対応する入力変換関数に送られます。
          </para>
         </listitem>
         <listitem>
          <para>
<!--
           Otherwise, the ordinary text representation of the JSON value is
           fed to the input conversion function for the column's data type.
-->
さもなければ、通常のJSON値のテキスト表現が列のデータ型に対応する入力変換関数に送られます。
          </para>
         </listitem>
        </itemizedlist>
       </para>
       <para>
<!--
        While the example below uses a constant JSON value, typical use would
        be to reference a <type>json</type> or <type>jsonb</type> column
        laterally from another table in the query's <literal>FROM</literal>
        clause.  Writing <function>json_populate_record</function> in
        the <literal>FROM</literal> clause is good practice, since all of the
        extracted columns are available for use without duplicate function
        calls.
-->
これらの関数の例ではJSON定数を使用していますが、典型的な使用法はその<type>json</type>または<type>jsonb</type>列を<literal>FROM</literal>句の別のテーブルから外側に参照することです。
<literal>FROM</literal>句で<function>json_populate_record</function>を書くのは良い練習になります。
すべての取り出された列を重複した関数呼び出しなしに利用できるからです。
       </para>
       <para>
        <literal>create type subrowtype as (d int, e text);</literal>
        <literal>create type myrowtype as (a int, b text[], c subrowtype);</literal>
       </para>
       <para>
        <literal>select * from json_populate_record(null::myrowtype,
         '{"a": 1, "b": ["2", "a b"], "c": {"d": 4, "e": "a  b c"}, "x": "foo"}')</literal>
        <returnvalue></returnvalue>
<programlisting>
 a |   b       |      c
---+-----------+-------------
 1 | {2,"a b"} | (4,"a b c")
</programlisting>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_populate_recordset</primary>
        </indexterm>
        <function>json_populate_recordset</function> ( <parameter>base</parameter> <type>anyelement</type>, <parameter>from_json</parameter> <type>json</type> )
        <returnvalue>setof anyelement</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_populate_recordset</primary>
        </indexterm>
        <function>jsonb_populate_recordset</function> ( <parameter>base</parameter> <type>anyelement</type>, <parameter>from_json</parameter> <type>jsonb</type> )
        <returnvalue>setof anyelement</returnvalue>
       </para>
       <para>
<!--
        Expands the top-level JSON array of objects to a set of rows having
        the composite type of the <parameter>base</parameter> argument.
        Each element of the JSON array is processed as described above
        for <function>json[b]_populate_record</function>.
-->
トップレベルのJSONオブジェクトを<parameter>base</parameter>引数である複合型を持つ行の集合に展開します。
JSON配列の個々の要素は上の<function>json[b]_populate_record</function>で説明したように処理されます。
       </para>
       <para>
        <literal>create type twoints as (a int, b int);</literal>
       </para>
       <para>
        <literal>select * from json_populate_recordset(null::twoints, '[{"a":1,"b":2}, {"a":3,"b":4}]')</literal>
        <returnvalue></returnvalue>
<programlisting>
 a | b
---+---
 1 | 2
 3 | 4
</programlisting>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_to_record</primary>
        </indexterm>
        <function>json_to_record</function> ( <type>json</type> )
        <returnvalue>record</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_to_record</primary>
        </indexterm>
        <function>jsonb_to_record</function> ( <type>jsonb</type> )
        <returnvalue>record</returnvalue>
       </para>
       <para>
<!--
        Expands the top-level JSON object to a row having the composite type
        defined by an <literal>AS</literal> clause.  (As with all functions
        returning <type>record</type>, the calling query must explicitly
        define the structure of the record with an <literal>AS</literal>
        clause.)  The output record is filled from fields of the JSON object,
        in the same way as described above
        for <function>json[b]_populate_record</function>.  Since there is no
        input record value, unmatched columns are always filled with nulls.
-->
トップレベルのJSONオブジェクトを<literal>AS</literal>句で定義した複合型を持つ行に展開します。
（<type>record</type>を返すすべての関数では、呼び出す問い合わせは明示的に<literal>AS</literal>句でレコードの構造を定義しなければなりません。）
上の<function>json[b]_populate_record</function>で説明した方法で、出力レコードはJSONオブジェクトのフィールドで満たされます。
入力レコード値がないので、一致しない列は常にNULLで満たされます。
       </para>
       <para>
        <literal>create type myrowtype as (a int, b text);</literal>
       </para>
       <para>
        <literal>select * from json_to_record('{"a":1,"b":[1,2,3],"c":[1,2,3],"e":"bar","r": {"a": 123, "b": "a b c"}}') as x(a int, b text, c int[], d text, r myrowtype)</literal>
        <returnvalue></returnvalue>
<programlisting>
 a |    b    |    c    | d |       r
---+---------+---------+---+---------------
 1 | [1,2,3] | {1,2,3} |   | (123,"a b c")
</programlisting>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_to_recordset</primary>
        </indexterm>
        <function>json_to_recordset</function> ( <type>json</type> )
        <returnvalue>setof record</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_to_recordset</primary>
        </indexterm>
        <function>jsonb_to_recordset</function> ( <type>jsonb</type> )
        <returnvalue>setof record</returnvalue>
       </para>
       <para>
<!--
        Expands the top-level JSON array of objects to a set of rows having
        the composite type defined by an <literal>AS</literal> clause.  (As
        with all functions returning <type>record</type>, the calling query
        must explicitly define the structure of the record with
        an <literal>AS</literal> clause.)  Each element of the JSON array is
        processed as described above
        for <function>json[b]_populate_record</function>.
-->
トップレベルのJSON配列を<literal>AS</literal>句で定義した複合型を持つ行に展開します。
（<type>record</type>を返すすべての関数では、呼び出す問い合わせは明示的に<literal>AS</literal>句でレコードの構造を定義しなければなりません。）
上の<function>json[b]_populate_record</function>で説明した方法で、JSON配列の要素は処理されます。
       </para>
       <para>
        <literal>select * from json_to_recordset('[{"a":1,"b":"foo"}, {"a":"2","c":"bar"}]') as x(a int, b text)</literal>
        <returnvalue></returnvalue>
<programlisting>
 a |  b
---+-----
 1 | foo
 2 |
</programlisting>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>jsonb_set</primary>
        </indexterm>
        <function>jsonb_set</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>text[]</type>, <parameter>new_value</parameter> <type>jsonb</type> <optional>, <parameter>create_if_missing</parameter> <type>boolean</type> </optional> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
<!--
        Returns <parameter>target</parameter>
        with the item designated by <parameter>path</parameter>
        replaced by <parameter>new_value</parameter>, or with
        <parameter>new_value</parameter> added if
        <parameter>create_if_missing</parameter> is true (which is the
        default) and the item designated by <parameter>path</parameter>
        does not exist.
        All earlier steps in the path must exist, or
        the <parameter>target</parameter> is returned unchanged.
        As with the path oriented operators, negative integers that
        appear in the <parameter>path</parameter> count from the end
        of JSON arrays.
        If the last path step is an array index that is out of range,
        and <parameter>create_if_missing</parameter> is true, the new
        value is added at the beginning of the array if the index is negative,
        or at the end of the array if it is positive.
-->
<parameter>path</parameter>で指定された要素を<parameter>new_value</parameter>で置き換えて<parameter>target</parameter>を返します。
<parameter>create_if_missing</parameter>が真なら（デフォルトです）、<parameter>path</parameter>で指定された項目が無い時に<parameter>new_value</parameter>が追加されます。
パス中のすべての初期のステップは存在しなければならず、さもなければ<parameter>target</parameter>は変わらないままに返却されます。
パスの位置についての演算子については、<parameter>path</parameter>の中にある負の整数はJSON配列の終わりから数えます。
パスの最後のステップが範囲外の配列のインデックスで、<parameter>create_if_missing</parameter>が真のときは、インデックスが負なら配列の最初に、正なら配列の最後に新しい値が追加されます。
       </para>
       <para>
        <literal>jsonb_set('[{"f1":1,"f2":null},2,null,3]', '{0,f1}', '[2,3,4]', false)</literal>
        <returnvalue>[{"f1": [2, 3, 4], "f2": null}, 2, null, 3]</returnvalue>
       </para>
       <para>
        <literal>jsonb_set('[{"f1":1,"f2":null},2]', '{0,f3}', '[2,3,4]')</literal>
        <returnvalue>[{"f1": 1, "f2": null, "f3": [2, 3, 4]}, 2]</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>jsonb_set_lax</primary>
        </indexterm>
        <function>jsonb_set_lax</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>text[]</type>, <parameter>new_value</parameter> <type>jsonb</type> <optional>, <parameter>create_if_missing</parameter> <type>boolean</type> <optional>, <parameter>null_value_treatment</parameter> <type>text</type> </optional></optional> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
<!--
        If <parameter>new_value</parameter> is not <literal>NULL</literal>,
        behaves identically to <literal>jsonb_set</literal>. Otherwise behaves
        according to the value
        of <parameter>null_value_treatment</parameter> which must be one
        of <literal>'raise_exception'</literal>,
        <literal>'use_json_null'</literal>, <literal>'delete_key'</literal>, or
        <literal>'return_target'</literal>. The default is
        <literal>'use_json_null'</literal>.
-->
<parameter>new_value</parameter>が<literal>NULL</literal>でないなら、<literal>jsonb_set</literal>と同じ振る舞いをします。
そうでなければ<parameter>null_value_treatment</parameter>にしたがいます。
<parameter>null_value_treatment</parameter>は、<literal>'raise_exception'</literal>、<literal>'use_json_null'</literal>、<literal>'delete_key'</literal>、<literal>'return_target'</literal>のいずれかでなければなりません。
デフォルトは<literal>'use_json_null'</literal>です。
       </para>
       <para>
        <literal>jsonb_set_lax('[{"f1":1,"f2":null},2,null,3]', '{0,f1}', null)</literal>
        <returnvalue>[{"f1": null, "f2": null}, 2, null, 3]</returnvalue>
       </para>
       <para>
        <literal>jsonb_set_lax('[{"f1":99,"f2":null},2]', '{0,f3}', null, true, 'return_target')</literal>
        <returnvalue>[{"f1": 99, "f2": null}, 2]</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>jsonb_insert</primary>
        </indexterm>
        <function>jsonb_insert</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>text[]</type>, <parameter>new_value</parameter> <type>jsonb</type> <optional>, <parameter>insert_after</parameter> <type>boolean</type> </optional> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
<!--
        Returns <parameter>target</parameter>
        with <parameter>new_value</parameter> inserted.  If the item
        designated by the <parameter>path</parameter> is an array
        element, <parameter>new_value</parameter> will be inserted before
        that item if <parameter>insert_after</parameter> is false (which
        is the default), or after it
        if <parameter>insert_after</parameter> is true.  If the item
        designated by the <parameter>path</parameter> is an object
        field, <parameter>new_value</parameter> will be inserted only if
        the object does not already contain that key.
        All earlier steps in the path must exist, or
        the <parameter>target</parameter> is returned unchanged.
        As with the path oriented operators, negative integers that
        appear in the <parameter>path</parameter> count from the end
        of JSON arrays.
        If the last path step is an array index that is out of range, the new
        value is added at the beginning of the array if the index is negative,
        or at the end of the array if it is positive.
-->
<parameter>new_value</parameter>を挿入して<parameter>target</parameter>を返します。
<parameter>path</parameter>で指定した項目が配列要素で、<parameter>insert_after</parameter>が偽（デフォルトです）ならば<parameter>new_value</parameter>はその項目の前に挿入され、<parameter>insert_after</parameter>が真であれば後に挿入されます。
<parameter>path</parameter>で指定した項目がオブジェクトフィールドならば、オブジェクトがすでにそのキーを含んでいない場合にのみ<parameter>new_value</parameter>が挿入されます。
パス中のすべての初期のステップは存在しなければならず、さもなければ<parameter>target</parameter>は変わらないままに返却されます。
pathについての演算子について言うと、<parameter>path</parameter>内の負の整数はJSON配列の終わりから数えます。
パスの最後のステップが範囲外の配列のインデックスで、インデックスが負なら配列の最初に、正なら配列の最後に新しい値が追加されます。
       </para>
       <para>
        <literal>jsonb_insert('{"a": [0,1,2]}', '{a, 1}', '"new_value"')</literal>
        <returnvalue>{"a": [0, "new_value", 1, 2]}</returnvalue>
       </para>
       <para>
        <literal>jsonb_insert('{"a": [0,1,2]}', '{a, 1}', '"new_value"', true)</literal>
        <returnvalue>{"a": [0, 1, "new_value", 2]}</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_strip_nulls</primary>
        </indexterm>
        <function>json_strip_nulls</function> ( <type>json</type> )
        <returnvalue>json</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_strip_nulls</primary>
        </indexterm>
        <function>jsonb_strip_nulls</function> ( <type>jsonb</type> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
<!--
        Deletes all object fields that have null values from the given JSON
        value, recursively.  Null values that are not object fields are
        untouched.
-->
与えられたJSON値からNULLを持つオブジェクトフィールドをすべて削除します。
オブジェクトフィールドではないNULL値は変わりません。
       </para>
       <para>
        <literal>json_strip_nulls('[{"f1":1, "f2":null}, 2, null, 3]')</literal>
        <returnvalue>[{"f1":1},2,null,3]</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>jsonb_path_exists</primary>
        </indexterm>
        <function>jsonb_path_exists</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>jsonpath</type> <optional>, <parameter>vars</parameter> <type>jsonb</type> <optional>, <parameter>silent</parameter> <type>boolean</type> </optional></optional> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Checks whether the JSON path returns any item for the specified JSON
        value.
        If the <parameter>vars</parameter> argument is specified, it must
        be a JSON object, and its fields provide named values to be
        substituted into the <type>jsonpath</type> expression.
        If the <parameter>silent</parameter> argument is specified and
        is <literal>true</literal>, the function suppresses the same errors
        as the <literal>@?</literal> and <literal>@@</literal> operators do.
-->
JSONパスが指定したJSON値に対して項目を返すかどうかをチェックします。
<parameter>vars</parameter>が指定されるなら、それはJSONオブジェクトでなければならず、そのフィールドは<type>jsonpath</type>式に置き換えられる名前を持つ値を提供します。
<parameter>silent</parameter>引数が指定されていて<literal>true</literal>なら、この関数は<literal>@?</literal>と<literal>@@</literal>演算子が生成するのと同じエラーを抑止します。
       </para>
       <para>
        <literal>jsonb_path_exists('{"a":[1,2,3,4,5]}', '$.a[*] ? (@ >= $min &amp;&amp; @ &lt;= $max)', '{"min":2, "max":4}')</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>jsonb_path_match</primary>
        </indexterm>
        <function>jsonb_path_match</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>jsonpath</type> <optional>, <parameter>vars</parameter> <type>jsonb</type> <optional>, <parameter>silent</parameter> <type>boolean</type> </optional></optional> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Returns the result of a JSON path predicate check for the specified
        JSON value.  Only the first item of the result is taken into account.
        If the result is not Boolean, then <literal>NULL</literal> is returned.
        The optional <parameter>vars</parameter>
        and <parameter>silent</parameter> arguments act the same as
        for <function>jsonb_path_exists</function>.
-->
指定したJSON値のJSONパス述語チェックの結果を返します。
結果の最初の項目だけが考慮されます。
結果がBooleanでないなら、<literal>null</literal>が返ります。
オプションの<parameter>vars</parameter>と<parameter>silent</parameter>引数は<function>jsonb_path_exists</function>と同じように働きます。
       </para>
       <para>
        <literal>jsonb_path_match('{"a":[1,2,3,4,5]}', 'exists($.a[*] ? (@ >= $min &amp;&amp; @ &lt;= $max))', '{"min":2, "max":4}')</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>jsonb_path_query</primary>
        </indexterm>
        <function>jsonb_path_query</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>jsonpath</type> <optional>, <parameter>vars</parameter> <type>jsonb</type> <optional>, <parameter>silent</parameter> <type>boolean</type> </optional></optional> )
        <returnvalue>setof jsonb</returnvalue>
       </para>
       <para>
<!--
        Returns all JSON items returned by the JSON path for the specified
        JSON value.
        The optional <parameter>vars</parameter>
        and <parameter>silent</parameter> arguments act the same as
        for <function>jsonb_path_exists</function>.
-->
JSON値に対するJSONパスによって返されるすべてのJSON項目を返します。
オプションの<parameter>vars</parameter>と<parameter>silent</parameter>引数は<function>jsonb_path_exists</function>と同じように働きます。
       </para>
       <para>
        <literal>select * from jsonb_path_query('{"a":[1,2,3,4,5]}', '$.a[*] ? (@ >= $min &amp;&amp; @ &lt;= $max)', '{"min":2, "max":4}')</literal>
        <returnvalue></returnvalue>
<programlisting>
 jsonb_path_query
------------------
 2
 3
 4
</programlisting>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>jsonb_path_query_array</primary>
        </indexterm>
        <function>jsonb_path_query_array</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>jsonpath</type> <optional>, <parameter>vars</parameter> <type>jsonb</type> <optional>, <parameter>silent</parameter> <type>boolean</type> </optional></optional> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
<!--
        Returns all JSON items returned by the JSON path for the specified
        JSON value, as a JSON array.
        The optional <parameter>vars</parameter>
        and <parameter>silent</parameter> arguments act the same as
        for <function>jsonb_path_exists</function>.
-->
JSON値に対するJSONパスによって返されるすべてのJSON項目をJSON配列として返します。
オプションの<parameter>vars</parameter>と<parameter>silent</parameter>引数は<function>jsonb_path_exists</function>と同じように働きます。
       </para>
       <para>
        <literal>jsonb_path_query_array('{"a":[1,2,3,4,5]}', '$.a[*] ? (@ >= $min &amp;&amp; @ &lt;= $max)', '{"min":2, "max":4}')</literal>
        <returnvalue>[2, 3, 4]</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>jsonb_path_query_first</primary>
        </indexterm>
        <function>jsonb_path_query_first</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>jsonpath</type> <optional>, <parameter>vars</parameter> <type>jsonb</type> <optional>, <parameter>silent</parameter> <type>boolean</type> </optional></optional> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
<!--
        Returns the first JSON item returned by the JSON path for the
        specified JSON value.  Returns <literal>NULL</literal> if there are no
        results.
        The optional <parameter>vars</parameter>
        and <parameter>silent</parameter> arguments act the same as
        for <function>jsonb_path_exists</function>.
-->
JSON値に対するJSONパスによって返される最初のJSON項目を返します。
結果がなければ<literal>NULL</literal>が返ります。
オプションの<parameter>vars</parameter>と<parameter>silent</parameter>引数は<function>jsonb_path_exists</function>と同じように働きます。
       </para>
       <para>
        <literal>jsonb_path_query_first('{"a":[1,2,3,4,5]}', '$.a[*] ? (@ >= $min &amp;&amp; @ &lt;= $max)', '{"min":2, "max":4}')</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>jsonb_path_exists_tz</primary>
        </indexterm>
        <function>jsonb_path_exists_tz</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>jsonpath</type> <optional>, <parameter>vars</parameter> <type>jsonb</type> <optional>, <parameter>silent</parameter> <type>boolean</type> </optional></optional> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_path_match_tz</primary>
        </indexterm>
        <function>jsonb_path_match_tz</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>jsonpath</type> <optional>, <parameter>vars</parameter> <type>jsonb</type> <optional>, <parameter>silent</parameter> <type>boolean</type> </optional></optional> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_path_query_tz</primary>
        </indexterm>
        <function>jsonb_path_query_tz</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>jsonpath</type> <optional>, <parameter>vars</parameter> <type>jsonb</type> <optional>, <parameter>silent</parameter> <type>boolean</type> </optional></optional> )
        <returnvalue>setof jsonb</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_path_query_array_tz</primary>
        </indexterm>
        <function>jsonb_path_query_array_tz</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>jsonpath</type> <optional>, <parameter>vars</parameter> <type>jsonb</type> <optional>, <parameter>silent</parameter> <type>boolean</type> </optional></optional> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_path_query_first_tz</primary>
        </indexterm>
        <function>jsonb_path_query_first_tz</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>jsonpath</type> <optional>, <parameter>vars</parameter> <type>jsonb</type> <optional>, <parameter>silent</parameter> <type>boolean</type> </optional></optional> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
<!--
        These functions act like their counterparts described above without
        the <literal>_tz</literal> suffix, except that these functions support
        comparisons of date/time values that require timezone-aware
        conversions.  The example below requires interpretation of the
        date-only value <literal>2015-08-02</literal> as a timestamp with time
        zone, so the result depends on the current
        <xref linkend="guc-timezone"/> setting.  Due to this dependency, these
        functions are marked as stable, which means these functions cannot be
        used in indexes.  Their counterparts are immutable, and so can be used
        in indexes; but they will throw errors if asked to make such
        comparisons.
-->
これらの関数は、時間帯を考慮する日時値の比較をサポートすることを除いて、上で述べた、<literal>_tz</literal>接尾を除いた片割れの関数のように動作します。
以下の例では日付のみの値<literal>2015-08-02</literal>を時間帯付きタイムスタンプとして解釈することが必要で、結果は<xref linkend="guc-timezone"/>設定に依存します。
この依存性のために、これらの関数は安定(stable)、として印付けされており、インデックスにはこれらの関数は使えないことを意味します。
これらの関数の片割れは不変(immutable)なので、インデックスで使えます。しかし、そうした比較を要求されるとエラーを吐きます。
       </para>
       <para>
        <literal>jsonb_path_exists_tz('["2015-08-01 12:00:00-05"]', '$[*] ? (@.datetime() &lt; "2015-08-02".datetime())')</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>jsonb_pretty</primary>
        </indexterm>
        <function>jsonb_pretty</function> ( <type>jsonb</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
<!--
        Converts the given JSON value to pretty-printed, indented text.
-->
与えられたJSON値を整形されたインデント付きテキストに変換します。
       </para>
       <para>
        <literal>jsonb_pretty('[{"f1":1,"f2":null}, 2]')</literal>
        <returnvalue></returnvalue>
<programlisting>
[
    {
        "f1": 1,
        "f2": null
    },
    2
]
</programlisting>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_typeof</primary>
        </indexterm>
        <function>json_typeof</function> ( <type>json</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_typeof</primary>
        </indexterm>
        <function>jsonb_typeof</function> ( <type>jsonb</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
<!--
        Returns the type of the top-level JSON value as a text string.
        Possible types are
        <literal>object</literal>, <literal>array</literal>,
        <literal>string</literal>, <literal>number</literal>,
        <literal>boolean</literal>, and <literal>null</literal>.
        (The <literal>null</literal> result should not be confused
        with an SQL NULL; see the examples.)
-->
トップレベルのJSON値の型をテキスト文字列として返します。
可能な型は次のとおりです。
<literal>object</literal>、<literal>array</literal>、<literal>string</literal>、<literal>number</literal>、<literal>boolean</literal>、<literal>null</literal>。
（<literal>null</literal>の結果をSQLのNULLと混同してはいけません。以下の例をご覧ください。）
       </para>
       <para>
        <literal>json_typeof('-123.4')</literal>
        <returnvalue>number</returnvalue>
       </para>
       <para>
        <literal>json_typeof('null'::json)</literal>
        <returnvalue>null</returnvalue>
       </para>
       <para>
        <literal>json_typeof(NULL::json) IS NULL</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>
 </sect2>

 <sect2 id="functions-sqljson-path">
<!--
  <title>The SQL/JSON Path Language</title>
-->
  <title>SQL/JSONパス言語</title>

  <indexterm zone="functions-sqljson-path">
   <primary>SQL/JSON path language</primary>
  </indexterm>
  <indexterm zone="functions-sqljson-path">
   <primary>SQL/JSONパス言語</primary>
  </indexterm>

  <para>
<!--
   SQL/JSON path expressions specify the items to be retrieved
   from the JSON data, similar to XPath expressions used
   for SQL access to XML. In <productname>PostgreSQL</productname>,
   path expressions are implemented as the <type>jsonpath</type>
   data type and can use any elements described in
   <xref linkend="datatype-jsonpath"/>.
-->
SQL/JSONパス式は、XMLへのSQLアクセスで使用されるXPath同様、JSONデータから取り出す項目を指定します。
<productname>PostgreSQL</productname>ではパス式は<type>jsonpath</type>データ型として実装されており、<xref linkend="datatype-jsonpath"/>で説明されているすべての要素を使うことができます。
  </para>

  <para>
<!--
   JSON query functions and operators
   pass the provided path expression to the <firstterm>path engine</firstterm>
   for evaluation. If the expression matches the queried JSON data,
   the corresponding JSON item, or set of items, is returned.
   Path expressions are written in the SQL/JSON path language
   and can include arithmetic expressions and functions.
-->
JSON問い合わせ関数と演算子は与えられたパス式を<firstterm>path engine</firstterm>に渡して評価します。
式が問い合わせ対象のJSONデータにマッチすれば、関連するSQL/JSON項目が返却されます。
パス式はSQL/JSONパス言語で書かれ、算術式と関数を含むことができます。
  </para>

  <para>
<!--
   A path expression consists of a sequence of elements allowed
   by the <type>jsonpath</type> data type.
   The path expression is normally evaluated from left to right, but
   you can use parentheses to change the order of operations.
   If the evaluation is successful, a sequence of JSON items is produced,
   and the evaluation result is returned to the JSON query function
   that completes the specified computation.
-->
パス式は<type>jsonpath</type>データ型で認められた一連の要素からなります。
パス式は通常左から右へと評価されますが、括弧を使って演算の順序を変更することができます。
評価が成功すれば、一連のJSON項目が生成され、評価結果が指定した計算を完了したJSON問い合わせ関数に戻されます。
  </para>

  <para>
<!--
   To refer to the JSON value being queried (the
   <firstterm>context item</firstterm>), use the <literal>$</literal> variable
   in the path expression. It can be followed by one or more
   <link linkend="type-jsonpath-accessors">accessor operators</link>,
   which go down the JSON structure level by level to retrieve sub-items
   of the context item. Each operator that follows deals with the
   result of the previous evaluation step.
-->
問い合わせ対象（<firstterm>context item</firstterm>）のJSONデータを参照するには、パス式内で<literal>$</literal>値を使います。
複数の<link linkend="type-jsonpath-accessors">アクセサ演算子</link>をその後に記述することもできます。
それによってJSON構造をレベル順に訪れて文脈項目の副項目の内容を取り出します。
後続の個々の演算子はその前の評価段階の結果を処理します。
  </para>

  <para>
<!--
   For example, suppose you have some JSON data from a GPS tracker that you
   would like to parse, such as:
-->
たとえば、次のようなパースしたいGPSトラッカーからのJSONデータがあるとします。
<programlisting>
{
  "track": {
    "segments": [
      {
        "location":   [ 47.763, 13.4034 ],
        "start time": "2018-10-14 10:05:14",
        "HR": 73
      },
      {
        "location":   [ 47.706, 13.2635 ],
        "start time": "2018-10-14 10:39:21",
        "HR": 135
      }
    ]
  }
}
</programlisting>
  </para>

  <para>
<!--
   To retrieve the available track segments, you need to use the
   <literal>.<replaceable>key</replaceable></literal> accessor
   operator to descend through surrounding JSON objects:
-->
存在するトラックセグメントを取り出すには、<literal>.<replaceable>key</replaceable></literal>アクセサ演算子を使用して、周辺のJSONオブジェクトを下っていく必要があります。
<programlisting>
$.track.segments
</programlisting>
  </para>

  <para>
<!--
   To retrieve the contents of an array, you typically use the
   <literal>[*]</literal> operator. For example,
   the following path will return the location coordinates for all
   the available track segments:
-->
配列の内容を取り出すには、典型的には<literal>[*]</literal>演算子を使います。
たとえば次のパスはすべての存在するトラックセグメントの位置座標を返します。
<programlisting>
$.track.segments[*].location
</programlisting>
  </para>

  <para>
<!--
   To return the coordinates of the first segment only, you can
   specify the corresponding subscript in the <literal>[]</literal>
   accessor operator. Recall that JSON array indexes are 0-relative:
-->
最初のセグメントの座標だけを返すには、<literal>[]</literal>アクセサ演算子の中で対応する添え字を指定することができます。
JSON配列インデックスは0スタートであることに注意してください。
<programlisting>
$.track.segments[0].location
</programlisting>
  </para>

  <para>
<!--
   The result of each path evaluation step can be processed
   by one or more <type>jsonpath</type> operators and methods
   listed in <xref linkend="functions-sqljson-path-operators"/>.
   Each method name must be preceded by a dot. For example,
   you can get the size of an array:
-->
各段階でのパス評価結果は<xref linkend="functions-sqljson-path-operators"/>に列挙されている一つ以上の<type>jsonpath</type>演算子とメソッドで処理することができます。
各々のメソッド名の前にピリオドを付けなければなりません。
たとえば配列の大きさを得ることができます。
<programlisting>
$.track.segments.size()
</programlisting>
<!--
   More examples of using <type>jsonpath</type> operators
   and methods within path expressions appear below in
   <xref linkend="functions-sqljson-path-operators"/>.
-->
パス式内の<type>jsonpath</type>演算子とメソッドを使用する他の例については以下の<xref linkend="functions-sqljson-path-operators"/>を参照してください。
  </para>

  <para>
<!--
   When defining a path, you can also use one or more
   <firstterm>filter expressions</firstterm> that work similarly to the
   <literal>WHERE</literal> clause in SQL. A filter expression begins with
   a question mark and provides a condition in parentheses:
-->
パスを定義する際にはSQLの<literal>WHERE</literal>句のように働く一つ以上の<firstterm>フィルタ式</firstterm>が利用できます。
フィルタ式は疑問符で始まり、カッコ内に条件を記述します。

<programlisting>
? (<replaceable>condition</replaceable>)
</programlisting>
  </para>

  <para>
<!--
   Filter expressions must be written just after the path evaluation step
   to which they should apply. The result of that step is filtered to include
   only those items that satisfy the provided condition. SQL/JSON defines
   three-valued logic, so the condition can be <literal>true</literal>, <literal>false</literal>,
   or <literal>unknown</literal>. The <literal>unknown</literal> value
   plays the same role as SQL <literal>NULL</literal> and can be tested
   for with the <literal>is unknown</literal> predicate. Further path
   evaluation steps use only those items for which the filter expression
   returned <literal>true</literal>.
-->
フィルタ式はそれを適用するパス評価段階の直後に指定しなければなりません。
この段階の結果は、指定した条件を満たす項目だけが含まれるようにフィルタされます。
SQL/JSONは3値論理を定義しており、条件は<literal>true</literal>、<literal>false</literal>、<literal>unknown</literal>のどれかです。
<literal>unknown</literal>は値はSQLの<literal>NULL</literal>と同じ役割を果たし、<literal>is unknown</literal>述語で評価できます。
その後の評価段階では<literal>true</literal>を返すフィルタ式に対応する項目だけが使われます。
  </para>

  <para>
<!--
   The functions and operators that can be used in filter expressions are
   listed in <xref linkend="functions-sqljson-filter-ex-table"/>.  Within a
   filter expression, the <literal>@</literal> variable denotes the value
   being filtered (i.e., one result of the preceding path step).  You can
   write accessor operators after <literal>@</literal> to retrieve component
   items.
-->
フィルタ式内で利用できる関数と演算子は<xref linkend="functions-sqljson-filter-ex-table"/>にリストされています。
フィルタ式内では、フィルタする必要のある値は<literal>@</literal>変数で示します。（つまり以前のパスステップの結果の一つです。）
コンポーネント項目を取得するためにアクセサ演算子を<literal>@</literal>の後に記述することができます。
  </para>

  <para>
<!--
   For example, suppose you would like to retrieve all heart rate values higher
   than 130. You can achieve this using the following expression:
-->
たとえば130より高いすべての心拍数を取り出したいとします。次の式を使ってそれを得ることができます。
<programlisting>
$.track.segments[*].HR ? (@ &gt; 130)
</programlisting>
  </para>

  <para>
<!--
   To get the start times of segments with such values, you have to
   filter out irrelevant segments before returning the start times, so the
   filter expression is applied to the previous step, and the path used
   in the condition is different:
-->
そうした値を持つセグメントの開始時刻を得たい場合は、開始時刻を返す前に無関係のセグメントを取り除く必要があります。
そうすることにより前の段階にフィルタ式が適用されるので、その条件で適用されるパスは異なります。
<programlisting>
$.track.segments[*] ? (@.HR &gt; 130)."start time"
</programlisting>
  </para>

  <para>
<!--
   You can use several filter expressions in sequence, if required. For
   example, the following expression selects start times of all segments that
   contain locations with relevant coordinates and high heart rate values:
-->
必要なら複数のフィルタ式を順に使用することができます。
たとえば次の式は指定した座標と高い心拍数値を持つ位置を持つすべてのセグメントを選択します。
<programlisting>
$.track.segments[*] ? (@.location[1] &lt; 13.4) ? (@.HR &gt; 130)."start time"
</programlisting>
  </para>

  <para>
<!--
   Using filter expressions at different nesting levels is also allowed.
   The following example first filters all segments by location, and then
   returns high heart rate values for these segments, if available:
-->
異なる入れ子レベルに対してフィルタ式を適用することもできます。
次の例では、まず位置ですべてのセグメントをフィルタし、もしあれば高い心拍数値を返します。
<programlisting>
$.track.segments[*] ? (@.location[1] &lt; 13.4).HR ? (@ &gt; 130)
</programlisting>
  </para>

  <para>
<!--
   You can also nest filter expressions within each other:
-->
フィルタ式をお互いに入れ子にすることもできます。
<programlisting>
$.track ? (exists(@.segments[*] ? (@.HR &gt; 130))).segments.size()
</programlisting>
<!--
   This expression returns the size of the track if it contains any
   segments with high heart rate values, or an empty sequence otherwise.
-->
この式は高い心拍数値を含むトラックがあればそのすべてのサイズを返します。もしなければ空のシーケンスが返ります。
  </para>

  <para>
<!--
   <productname>PostgreSQL</productname>'s implementation of the SQL/JSON path
   language has the following deviations from the SQL/JSON standard:
-->
<productname>PostgreSQL</productname>のSQL/JSONパス言語の実装はSQL/JSON標準と次の点が異なります。
  </para>

  <itemizedlist>
   <listitem>
    <para>
<!--
     A path expression can be a Boolean predicate, although the SQL/JSON
     standard allows predicates only in filters.  This is necessary for
     implementation of the <literal>@@</literal> operator. For example,
     the following <type>jsonpath</type> expression is valid in
     <productname>PostgreSQL</productname>:
-->
SQL/JSON標準ではフィルタ内でのみ述語が使えますが、パス式はBoolean述語でも構いません。
これは<literal>@@</literal>演算子を実装するために必要です。
たとえば、次の<type>jsonpath</type>式は<productname>PostgreSQL</productname>では有効です。
<programlisting>
$.track.segments[*].HR &lt; 70
</programlisting>
    </para>
   </listitem>

   <listitem>
    <para>
<!--
     There are minor differences in the interpretation of regular
     expression patterns used in <literal>like_regex</literal> filters, as
     described in <xref linkend="jsonpath-regular-expressions"/>.
-->
<xref linkend="jsonpath-regular-expressions"/>で述べるように、<literal>like_regex</literal>フィルタで使用される正規表現パターンの解釈には些細な違いがあります。
    </para>
   </listitem>
  </itemizedlist>

   <sect3 id="strict-and-lax-modes">
<!--
   <title>Strict and Lax Modes</title>
-->
   <title>厳密モードと非厳密モード</title>
    <para>
<!--
     When you query JSON data, the path expression may not match the
     actual JSON data structure. An attempt to access a non-existent
     member of an object or element of an array results in a
     structural error. SQL/JSON path expressions have two modes
     of handling structural errors:
-->
JSONデータを問い合わせる際、パス式は実際のJSONデータ構造に一致しないかも知れません。
存在しないオブジェクトのメンバあるいは配列要素にアクセスしようとすると、構造上のエラーとなります。
SQL/JSONパス式には構造上のエラーを扱うための2つのモードがあります。
    </para>

   <itemizedlist>
    <listitem>
     <para>
<!--
      lax (default) &mdash; the path engine implicitly adapts
      the queried data to the specified path.
      Any remaining structural errors are suppressed and converted
      to empty SQL/JSON sequences.
-->
非厳密(lax)モード（デフォルト）&mdash; パスエンジンは指定したパスを問い合わせデータに暗黙的に適合させます。
構造上のエラーは抑止され、空のSQL/JSONシーケンスへと変換されます。
     </para>
    </listitem>
    <listitem>
     <para>
<!--
      strict &mdash; if a structural error occurs, an error is raised.
-->
厳密(strict)モード &mdash; 構造上のエラーがあるとエラーが発生します。
     </para>
    </listitem>
   </itemizedlist>

   <para>
<!--
    The lax mode facilitates matching of a JSON document structure and path
    expression if the JSON data does not conform to the expected schema.
    If an operand does not match the requirements of a particular operation,
    it can be automatically wrapped as an SQL/JSON array or unwrapped by
    converting its elements into an SQL/JSON sequence before performing
    this operation. Besides, comparison operators automatically unwrap their
    operands in the lax mode, so you can compare SQL/JSON arrays
    out-of-the-box. An array of size 1 is considered equal to its sole element.
    Automatic unwrapping is not performed only when:
-->
非厳密モードは、JSONデータが期待されるスキーマに沿わないときにJSON文書構造とパス式のマッチングを助けます。
あるオペランドが操作の要件に合わないときにはそれをSQL/JSON配列にまとめたり、あるいは操作を行う前にそれをSQL/JSONシーケンスに展開することもできます。
また非厳密モードにおいては、比較演算子は自動的にオペランドを展開し、SQL/JSON配列をそのまま比較することができます。
大きさ1の配列はその単独要素と同じものとして扱われます。
自動展開は以下の場合にのみ行われません。
    <itemizedlist>
     <listitem>
      <para>
<!--
       The path expression contains <literal>type()</literal> or
       <literal>size()</literal> methods that return the type
       and the number of elements in the array, respectively.
-->
それぞれ配列の型、要素数を返す<literal>type()</literal>、<literal>size()</literal>をパス式が含む。
      </para>
     </listitem>
     <listitem>
      <para>
<!--
       The queried JSON data contain nested arrays. In this case, only
       the outermost array is unwrapped, while all the inner arrays
       remain unchanged. Thus, implicit unwrapping can only go one
       level down within each path evaluation step.
-->
問い合わせ対象のJSONデータが入れ子の配列を含む。
この場合はもっとも外側の配列のみが展開され、内側の配列は変わりません。
ですから、それぞれの評価段階において1レベルのみに暗黙的な展開が行われます。
      </para>
     </listitem>
    </itemizedlist>
   </para>

   <para>
<!--
    For example, when querying the GPS data listed above, you can
    abstract from the fact that it stores an array of segments
    when using the lax mode:
-->
たとえば、上述のGPSデータに問い合わせする際、非厳密モードでは配列のセグメントを含んでいることを抽象化できます。
<programlisting>
lax $.track.segments.location
</programlisting>
   </para>

   <para>
<!--
    In the strict mode, the specified path must exactly match the structure of
    the queried JSON document to return an SQL/JSON item, so using this
    path expression will cause an error. To get the same result as in
    the lax mode, you have to explicitly unwrap the
    <literal>segments</literal> array:
-->
厳密モードでは、指定したパスはSQL/JSON項目を返す問い合わせ対象のJSON文書の構造に正確に一致していなければなりません。ですから、このパス式を使うとエラーになります。
非厳密モードと同じ結果を得るためには、<literal>segments</literal>配列を明示的に展開する必要があります。
<programlisting>
strict $.track.segments[*].location
</programlisting>
   </para>

   <para>
<!--
    The <literal>.**</literal> accessor can lead to surprising results
    when using the lax mode. For instance, the following query selects every
    <literal>HR</literal> value twice:
-->
<literal>.**</literal>アクセサを非厳密モードで使うと驚くべき結果をもたらすことがあります。
たとえば、次の問い合わせはすべての<literal>HR</literal>値を2回検索します。
<programlisting>
lax $.**.HR
</programlisting>
<!--
    This happens because the <literal>.**</literal> accessor selects both
    the <literal>segments</literal> array and each of its elements, while
    the <literal>.HR</literal> accessor automatically unwraps arrays when
    using the lax mode. To avoid surprising results, we recommend using
    the <literal>.**</literal> accessor only in the strict mode. The
    following query selects each <literal>HR</literal> value just once:
-->
これは<literal>.**</literal>アクセサが<literal>segments</literal>とその各々の要素の両方を検索するからです。
一方、<literal>.HR</literal>アクセサは非厳密モードでは自動的に配列を展開します。
予期しない結果を避けるには、<literal>.**</literal>アクセサを厳密モードでのみ使うことをお勧めします。
次の問い合わせは<literal>HR</literal>の各値を一度だけ検索します。
<programlisting>
strict $.**.HR
</programlisting>
   </para>

   </sect3>

   <sect3 id="functions-sqljson-path-operators">
<!--
   <title>SQL/JSON Path Operators and Methods</title>
-->
   <title>SQL/JSONパス演算子とメソッド</title>

   <para>
<!--
    <xref linkend="functions-sqljson-op-table"/> shows the operators and
    methods available in <type>jsonpath</type>.  Note that while the unary
    operators and methods can be applied to multiple values resulting from a
    preceding path step, the binary operators (addition etc.) can only be
    applied to single values.
-->
<xref linkend="functions-sqljson-op-table"/>に<type>jsonpath</type>で利用可能な演算子とメソッドを示します。
単項演算子とメソッドは以前のパスステップから生じた複数の値に適用できますが、二項演算子（加算など）は単一の値にしか適用できないことに注意してください。
   </para>

   <table id="functions-sqljson-op-table">
<!--
    <title><type>jsonpath</type> Operators and Methods</title>
-->
    <title><type>jsonpath</type>演算子とメソッド</title>
    <tgroup cols="1">
     <thead>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
<!--
        Operator/Method
-->
演算子/メソッド
       </para>
       <para>
<!--
        Description
-->
説明
       </para>
       <para>
<!--
        Example(s)
-->
例
       </para></entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>number</replaceable> <literal>+</literal> <replaceable>number</replaceable>
        <returnvalue><replaceable>number</replaceable></returnvalue>
       </para>
       <para>
<!--
        Addition
-->
加算
       </para>
       <para>
        <literal>jsonb_path_query('[2]', '$[0] + 3')</literal>
        <returnvalue>5</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>+</literal> <replaceable>number</replaceable>
        <returnvalue><replaceable>number</replaceable></returnvalue>
       </para>
       <para>
<!--
        Unary plus (no operation); unlike addition, this can iterate over
        multiple values
-->
単項のプラス（演算なし）。加算と違って、複数の値に渡って適用できます。
       </para>
       <para>
        <literal>jsonb_path_query_array('{"x": [2,3,4]}', '+ $.x')</literal>
        <returnvalue>[2, 3, 4]</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>number</replaceable> <literal>-</literal> <replaceable>number</replaceable>
        <returnvalue><replaceable>number</replaceable></returnvalue>
       </para>
       <para>
<!--
        Subtraction
-->
減算
       </para>
       <para>
        <literal>jsonb_path_query('[2]', '7 - $[0]')</literal>
        <returnvalue>5</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>-</literal> <replaceable>number</replaceable>
        <returnvalue><replaceable>number</replaceable></returnvalue>
       </para>
       <para>
<!--
        Negation; unlike subtraction, this can iterate over
        multiple values
-->
負符号。減算と違って、複数の値に渡って適用できます。
       </para>
       <para>
        <literal>jsonb_path_query_array('{"x": [2,3,4]}', '- $.x')</literal>
        <returnvalue>[-2, -3, -4]</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>number</replaceable> <literal>*</literal> <replaceable>number</replaceable>
        <returnvalue><replaceable>number</replaceable></returnvalue>
       </para>
       <para>
<!--
        Multiplication
-->
乗算
       </para>
       <para>
        <literal>jsonb_path_query('[4]', '2 * $[0]')</literal>
        <returnvalue>8</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>number</replaceable> <literal>/</literal> <replaceable>number</replaceable>
        <returnvalue><replaceable>number</replaceable></returnvalue>
       </para>
       <para>
<!--
        Division
-->
除算
       </para>
       <para>
        <literal>jsonb_path_query('[8.5]', '$[0] / 2')</literal>
        <returnvalue>4.2500000000000000</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>number</replaceable> <literal>%</literal> <replaceable>number</replaceable>
        <returnvalue><replaceable>number</replaceable></returnvalue>
       </para>
       <para>
<!--
        Modulo (remainder)
-->
剰余（残り）
       </para>
       <para>
        <literal>jsonb_path_query('[32]', '$[0] % 10')</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>value</replaceable> <literal>.</literal> <literal>type()</literal>
        <returnvalue><replaceable>string</replaceable></returnvalue>
       </para>
       <para>
<!--
        Type of the JSON item (see <function>json_typeof</function>)
-->
JSON項目の型（<function>json_typeof</function>を参照）
       </para>
       <para>
        <literal>jsonb_path_query_array('[1, "2", {}]', '$[*].type()')</literal>
        <returnvalue>["number", "string", "object"]</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>value</replaceable> <literal>.</literal> <literal>size()</literal>
        <returnvalue><replaceable>number</replaceable></returnvalue>
       </para>
       <para>
<!--
        Size of the JSON item (number of array elements, or 1 if not an
        array)
-->
JSON項目の大きさ（配列の要素数。配列でなければ1）
       </para>
       <para>
        <literal>jsonb_path_query('{"m": [11, 15]}', '$.m.size()')</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>value</replaceable> <literal>.</literal> <literal>double()</literal>
        <returnvalue><replaceable>number</replaceable></returnvalue>
       </para>
       <para>
<!--
        Approximate floating-point number converted from a JSON number or
        string
-->
JSON数値あるいは文字列から変換した概算の浮動小数点数
       </para>
       <para>
        <literal>jsonb_path_query('{"len": "1.9"}', '$.len.double() * 2')</literal>
        <returnvalue>3.8</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>number</replaceable> <literal>.</literal> <literal>ceiling()</literal>
        <returnvalue><replaceable>number</replaceable></returnvalue>
       </para>
       <para>
<!--
        Nearest integer greater than or equal to the given number
-->
引数より大きいか等しく、与えられた数に最も近い整数
       </para>
       <para>
        <literal>jsonb_path_query('{"h": 1.3}', '$.h.ceiling()')</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>number</replaceable> <literal>.</literal> <literal>floor()</literal>
        <returnvalue><replaceable>number</replaceable></returnvalue>
       </para>
       <para>
<!--
        Nearest integer less than or equal to the given number
-->
引数より小さいか等しく、与えられた数に最も近い整数
       </para>
       <para>
        <literal>jsonb_path_query('{"h": 1.7}', '$.h.floor()')</literal>
        <returnvalue>1</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>number</replaceable> <literal>.</literal> <literal>abs()</literal>
        <returnvalue><replaceable>number</replaceable></returnvalue>
       </para>
       <para>
<!--
        Absolute value of the given number
-->
与えられた数の絶対値
       </para>
       <para>
        <literal>jsonb_path_query('{"z": -0.3}', '$.z.abs()')</literal>
        <returnvalue>0.3</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>string</replaceable> <literal>.</literal> <literal>datetime()</literal>
        <returnvalue><replaceable>datetime_type</replaceable></returnvalue>
<!--
        (see note)
-->
（注記を参照）
       </para>
       <para>
<!--
        Date/time value converted from a string
-->
文字列から変換した日時値
       </para>
       <para>
        <literal>jsonb_path_query('["2015-8-1", "2015-08-12"]', '$[*] ? (@.datetime() &lt; "2015-08-2".datetime())')</literal>
        <returnvalue>"2015-8-1"</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>string</replaceable> <literal>.</literal> <literal>datetime(<replaceable>template</replaceable>)</literal>
        <returnvalue><replaceable>datetime_type</replaceable></returnvalue>
<!--
        (see note)
-->
（注記を参照）
       </para>
       <para>
<!--
        Date/time value converted from a string using the
        specified <function>to_timestamp</function> template
-->
指定の<function>to_timestamp</function>テンプレートを使って文字列から変換した日時値
       </para>
       <para>
        <literal>jsonb_path_query_array('["12:30", "18:40"]', '$[*].datetime("HH24:MI")')</literal>
        <returnvalue>["12:30:00", "18:40:00"]</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>object</replaceable> <literal>.</literal> <literal>keyvalue()</literal>
        <returnvalue><replaceable>array</replaceable></returnvalue>
       </para>
       <para>
<!--
        The object's key-value pairs, represented as an array of objects
        containing three fields: <literal>"key"</literal>,
        <literal>"value"</literal>, and <literal>"id"</literal>;
        <literal>"id"</literal> is a unique identifier of the object the
        key-value pair belongs to
-->
以下の3つのフィールドを含むオブジェクトの配列で表現したオブジェクトのキー/値ペア。
<literal>"key"</literal>、<literal>"value"</literal>、<literal>"id"</literal>。
<literal>"id"</literal>はキー/値ペアが属するオブジェクトのユニーク識別子です。
       </para>
       <para>
        <literal>jsonb_path_query_array('{"x": "20", "y": 32}', '$.keyvalue()')</literal>
        <returnvalue>[{"id": 0, "key": "x", "value": "20"}, {"id": 0, "key": "y", "value": 32}]</returnvalue>
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

    <note>
     <para>
<!--
      The result type of the <literal>datetime()</literal> and
      <literal>datetime(<replaceable>template</replaceable>)</literal>
      methods can be <type>date</type>, <type>timetz</type>, <type>time</type>,
      <type>timestamptz</type>, or <type>timestamp</type>.
      Both methods determine their result type dynamically.
-->
<literal>datetime()</literal>と<literal>datetime(<replaceable>template</replaceable>)</literal>の結果型は<type>date</type>、<type>timetz</type>、<type>time</type>、<type>timestamptz</type>、あるいは<type>timestamp</type>です。
両方のメソッドは結果型を動的に決定します。
     </para>
     <para>
<!--
      The <literal>datetime()</literal> method sequentially tries to
      match its input string to the ISO formats
      for <type>date</type>, <type>timetz</type>, <type>time</type>,
      <type>timestamptz</type>, and <type>timestamp</type>. It stops on
      the first matching format and emits the corresponding data type.
-->
<literal>datetime()</literal>メソッドは入力文字列を<type>date</type>、<type>timetz</type>、<type>time</type>、<type>timestamptz</type>、<type>timestamp</type>のISO形式に対して順にマッチを試みます。
最初にマッチした形式で停止し、関連するデータ型を出力します。
     </para>
     <para>
<!--
      The <literal>datetime(<replaceable>template</replaceable>)</literal>
      method determines the result type according to the fields used in the
      provided template string.
-->
<literal>datetime(<replaceable>template</replaceable>)</literal>メソッドは与えられたテンプレート文字列にあるフィールドに従って結果型を決定します。
     </para>
     <para>
<!--
      The <literal>datetime()</literal> and
      <literal>datetime(<replaceable>template</replaceable>)</literal> methods
      use the same parsing rules as the <literal>to_timestamp</literal> SQL
      function does (see <xref linkend="functions-formatting"/>), with three
      exceptions.  First, these methods don't allow unmatched template
      patterns.  Second, only the following separators are allowed in the
      template string: minus sign, period, solidus (slash), comma, apostrophe,
      semicolon, colon and space.  Third, separators in the template string
      must exactly match the input string.
-->
<literal>datetime()</literal>と<literal>datetime(<replaceable>template</replaceable>)</literal>は<literal>to_timestamp</literal>SQL関数と同じ解析ルール(参照<xref linkend="functions-formatting"/>)を用いますが、3つの例外があります。
一番目に、これらのメソッドは一致しないテンプレートパターンを許容しません。二番目に次の区切り文字のみを許容します。負符号、ピリオド、斜線（スラッシュ）、カンマ、アポストロフィー、セミコロン、コロン、空白、です。
三番目にテンプレート文字列中の区切り文字は正確に入力文字列と一致しなければなりません。
     </para>
     <para>
<!--
      If different date/time types need to be compared, an implicit cast is
      applied. A <type>date</type> value can be cast to <type>timestamp</type>
      or <type>timestamptz</type>, <type>timestamp</type> can be cast to
      <type>timestamptz</type>, and <type>time</type> to <type>timetz</type>.
      However, all but the first of these conversions depend on the current
      <xref linkend="guc-timezone"/> setting, and thus can only be performed
      within timezone-aware <type>jsonpath</type> functions.
-->
異なる日時型の比較が必要なら、暗黙的なキャストが適用されます。
<type>date</type>値は<type>timestamp</type>あるいは<type>timestamptz</type>にキャストできます。
<type>timestamp</type>は<type>timestamptz</type>に、<type>time</type>は<type>timetz</type>にキャストできます。
しかし、これらの変換の最初のものは現在の<xref linkend="guc-timezone"/>設定に依存します。ですから時間帯を認識する<type>jsonpath</type>関数中でのみ実行可能です。
     </para>
    </note>

   <para>
<!--
    <xref linkend="functions-sqljson-filter-ex-table"/> shows the available
    filter expression elements.
-->
<xref linkend="functions-sqljson-filter-ex-table"/>に利用可能なフィルタ式要素を示します。
   </para>

   <table id="functions-sqljson-filter-ex-table">
<!--
    <title><type>jsonpath</type> Filter Expression Elements</title>
-->
    <title><type>jsonpath</type>フィルタ式要素</title>
    <tgroup cols="1">
     <thead>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
<!--
        Predicate/Value
-->
述語/値
       </para>
       <para>
<!--
        Description
-->
説明
       </para>
       <para>
<!--
        Example(s)
-->
例
       </para></entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>value</replaceable> <literal>==</literal> <replaceable>value</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Equality comparison (this, and the other comparison operators, work on
        all JSON scalar values)
-->
等値比較（これと他の比較演算子はすべてのJSONスカラ値で使えます）
       </para>
       <para>
        <literal>jsonb_path_query_array('[1, "a", 1, 3]', '$[*] ? (@ == 1)')</literal>
        <returnvalue>[1, 1]</returnvalue>
       </para>
       <para>
        <literal>jsonb_path_query_array('[1, "a", 1, 3]', '$[*] ? (@ == "a")')</literal>
        <returnvalue>["a"]</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>value</replaceable> <literal>!=</literal> <replaceable>value</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para role="func_signature">
        <replaceable>value</replaceable> <literal>&lt;&gt;</literal> <replaceable>value</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Non-equality comparison
-->
非等値比較
       </para>
       <para>
        <literal>jsonb_path_query_array('[1, 2, 1, 3]', '$[*] ? (@ != 1)')</literal>
        <returnvalue>[2, 3]</returnvalue>
       </para>
       <para>
        <literal>jsonb_path_query_array('["a", "b", "c"]', '$[*] ? (@ &lt;&gt; "b")')</literal>
        <returnvalue>["a", "c"]</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>value</replaceable> <literal>&lt;</literal> <replaceable>value</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Less-than comparison
-->
未満比較
       </para>
       <para>
        <literal>jsonb_path_query_array('[1, 2, 3]', '$[*] ? (@ &lt; 2)')</literal>
        <returnvalue>[1]</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>value</replaceable> <literal>&lt;=</literal> <replaceable>value</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Less-than-or-equal-to comparison
-->
以下比較
       </para>
       <para>
        <literal>jsonb_path_query_array('["a", "b", "c"]', '$[*] ? (@ &lt;= "b")')</literal>
        <returnvalue>["a", "b"]</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>value</replaceable> <literal>&gt;</literal> <replaceable>value</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Greater-than comparison
-->
より大きい比較
       </para>
       <para>
        <literal>jsonb_path_query_array('[1, 2, 3]', '$[*] ? (@ &gt; 2)')</literal>
        <returnvalue>[3]</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>value</replaceable> <literal>&gt;=</literal> <replaceable>value</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Greater-than-or-equal-to comparison
-->
以上比較
       </para>
       <para>
        <literal>jsonb_path_query_array('[1, 2, 3]', '$[*] ? (@ &gt;= 2)')</literal>
        <returnvalue>[2, 3]</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>true</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        JSON constant <literal>true</literal>
-->
JSON定数<literal>真</literal>
       </para>
       <para>
        <literal>jsonb_path_query('[{"name": "John", "parent": false}, {"name": "Chris", "parent": true}]', '$[*] ? (@.parent == true)')</literal>
        <returnvalue>{"name": "Chris", "parent": true}</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>false</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        JSON constant <literal>false</literal>
-->
JSON定数<literal>偽</literal>
       </para>
       <para>
        <literal>jsonb_path_query('[{"name": "John", "parent": false}, {"name": "Chris", "parent": true}]', '$[*] ? (@.parent == false)')</literal>
        <returnvalue>{"name": "John", "parent": false}</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>null</literal>
        <returnvalue><replaceable>value</replaceable></returnvalue>
       </para>
       <para>
<!--
        JSON constant <literal>null</literal> (note that, unlike in SQL,
        comparison to <literal>null</literal> works normally)
-->
JSON定数<literal>null</literal>（SQLとは違って<literal>null</literal>との比較は通常通り動作することに注意してください。）
       </para>
       <para>
        <literal>jsonb_path_query('[{"name": "Mary", "job": null}, {"name": "Michael", "job": "driver"}]', '$[*] ? (@.job == null) .name')</literal>
        <returnvalue>"Mary"</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>boolean</replaceable> <literal>&amp;&amp;</literal> <replaceable>boolean</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Boolean AND
-->
論理AND
       </para>
       <para>
        <literal>jsonb_path_query('[1, 3, 7]', '$[*] ? (@ &gt; 1 &amp;&amp; @ &lt; 5)')</literal>
        <returnvalue>3</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>boolean</replaceable> <literal>||</literal> <replaceable>boolean</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Boolean OR
-->
論理OR
       </para>
       <para>
        <literal>jsonb_path_query('[1, 3, 7]', '$[*] ? (@ &lt; 1 || @ &gt; 5)')</literal>
        <returnvalue>7</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>!</literal> <replaceable>boolean</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Boolean NOT
-->
論理NOT
       </para>
       <para>
        <literal>jsonb_path_query('[1, 3, 7]', '$[*] ? (!(@ &lt; 5))')</literal>
        <returnvalue>7</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>boolean</replaceable> <literal>is unknown</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Tests whether a Boolean condition is <literal>unknown</literal>.
-->
論理条件が<literal>unknown</literal>であるかどうかを検査します。
       </para>
       <para>
        <literal>jsonb_path_query('[-1, 2, 7, "foo"]', '$[*] ? ((@ > 0) is unknown)')</literal>
        <returnvalue>"foo"</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>string</replaceable> <literal>like_regex</literal> <replaceable>string</replaceable> <optional> <literal>flag</literal> <replaceable>string</replaceable> </optional>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Tests whether the first operand matches the regular expression
        given by the second operand, optionally with modifications
        described by a string of <literal>flag</literal> characters (see
        <xref linkend="jsonpath-regular-expressions"/>).
-->
最初のオペランドが2番目のオペランドで与えられる正規表現にマッチするかどうか検査します。
オプションで<literal>flag</literal>文字列で記述される変更を伴います。（<xref linkend="jsonpath-regular-expressions"/>を参照してください。）
       </para>
       <para>
        <literal>jsonb_path_query_array('["abc", "abd", "aBdC", "abdacb", "babc"]', '$[*] ? (@ like_regex "^ab.*c")')</literal>
        <returnvalue>["abc", "abdacb"]</returnvalue>
       </para>
       <para>
        <literal>jsonb_path_query_array('["abc", "abd", "aBdC", "abdacb", "babc"]', '$[*] ? (@ like_regex "^ab.*c" flag "i")')</literal>
        <returnvalue>["abc", "aBdC", "abdacb"]</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>string</replaceable> <literal>starts with</literal> <replaceable>string</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Tests whether the second operand is an initial substring of the first
        operand.
-->
2番目の文字列が1番目のオペランドの最初の部分文字列かどうかを検査します。
       </para>
       <para>
        <literal>jsonb_path_query('["John Smith", "Mary Stone", "Bob Johnson"]', '$[*] ? (@ starts with "John")')</literal>
        <returnvalue>"John Smith"</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>exists</literal> <literal>(</literal> <replaceable>path_expression</replaceable> <literal>)</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Tests whether a path expression matches at least one SQL/JSON item.
        Returns <literal>unknown</literal> if the path expression would result
        in an error; the second example uses this to avoid a no-such-key error
        in strict mode.
-->
パス式が少なくとも一つのSQL/JSON項目とマッチするかどうかを検査します。
パス式がエラーとなる場合は<literal>unknown</literal>を返します。2番目の例は厳密モードでキーが存在しないエラーを回避するためにこれを使っています。
       </para>
       <para>
        <literal>jsonb_path_query('{"x": [1, 2], "y": [2, 4]}', 'strict $.* ? (exists (@ ? (@[*] &gt; 2)))')</literal>
        <returnvalue>[2, 4]</returnvalue>
       </para>
       <para>
        <literal>jsonb_path_query_array('{"value": 41}', 'strict $ ? (exists (@.name)) .name')</literal>
        <returnvalue>[]</returnvalue>
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   </sect3>

   <sect3 id="jsonpath-regular-expressions">
<!--
    <title>SQL/JSON Regular Expressions</title>
-->
    <title>SQL/JSON正規表現</title>

    <indexterm zone="jsonpath-regular-expressions">
     <primary><literal>LIKE_REGEX</literal></primary>
     <secondary>in SQL/JSON</secondary>
    </indexterm>
    <indexterm zone="jsonpath-regular-expressions">
     <primary><literal>LIKE_REGEX</literal></primary>
     <secondary>SQL/JSONにおける</secondary>
    </indexterm>

    <para>
<!--
     SQL/JSON path expressions allow matching text to a regular expression
     with the <literal>like_regex</literal> filter.  For example, the
     following SQL/JSON path query would case-insensitively match all
     strings in an array that start with an English vowel:
-->
SQL/JSONパス式では<literal>like_regex</literal>フィルタを使ってテキストを正規表現にマッチさせることができます。
たとえば、次のSQL/JSONパス式問い合わせは、英語の母音で始まる配列内のすべての文字列に大文字小文字を無視してマッチするでしょう。
<programlisting>
$[*] ? (@ like_regex "^[aeiou]" flag "i")
</programlisting>
    </para>

    <para>
<!--
     The optional <literal>flag</literal> string may include one or more of
     the characters
     <literal>i</literal> for case-insensitive match,
     <literal>m</literal> to allow <literal>^</literal>
     and <literal>$</literal> to match at newlines,
     <literal>s</literal> to allow <literal>.</literal> to match a newline,
     and <literal>q</literal> to quote the whole pattern (reducing the
     behavior to a simple substring match).
-->
オプションの<literal>flag</literal>文字列は一つ以上の文字を含むことができます。
<literal>i</literal>は大文字小文字を無視したマッチ、<literal>m</literal>は<literal>^</literal>と<literal>$</literal>で改行にマッチ、<literal>s</literal>は<literal>.</literal>が改行にマッチ、<literal>q</literal>はパターン全体を参照します。（振る舞いを単純な部分文字列マッチとします）
    </para>

    <para>
<!--
     The SQL/JSON standard borrows its definition for regular expressions
     from the <literal>LIKE_REGEX</literal> operator, which in turn uses the
     XQuery standard.  PostgreSQL does not currently support the
     <literal>LIKE_REGEX</literal> operator.  Therefore,
     the <literal>like_regex</literal> filter is implemented using the
     POSIX regular expression engine described in
     <xref linkend="functions-posix-regexp"/>.  This leads to various minor
     discrepancies from standard SQL/JSON behavior, which are cataloged in
     <xref linkend="posix-vs-xquery"/>.
     Note, however, that the flag-letter incompatibilities described there
     do not apply to SQL/JSON, as it translates the XQuery flag letters to
     match what the POSIX engine expects.
-->
SQL/JSON標準は正規表現の定義を、XQuery標準を使用する<literal>LIKE_REGEX</literal>演算子から借りています。
PostgreSQLは今の所<literal>LIKE_REGEX</literal>演算子をサポートしていません。
ですから、<literal>like_regex</literal>フィルタは<xref linkend="functions-posix-regexp"/>で説明されているPOSIX正規表現で実装されています。
このことにより、<xref linkend="posix-vs-xquery"/>で列挙されているSQL/JSON標準の振る舞いとの小さな違いが生じます。
しかし、ここで述べているフラグ文字の非互換性はSQL/JSONには適用されないことに注意してください。SQL/JSONは、XQueryのフラグ文字をPOSIXエンジンが期待するのと一致するように解釈するからです。
    </para>

    <para>
<!--
     Keep in mind that the pattern argument of <literal>like_regex</literal>
     is a JSON path string literal, written according to the rules given in
     <xref linkend="datatype-jsonpath"/>.  This means in particular that any
     backslashes you want to use in the regular expression must be doubled.
     For example, to match string values of the root document that contain
     only digits:
-->
<literal>like_regex</literal>のパターン引数は<xref linkend="datatype-jsonpath"/>で説明されているルールにしたがって書かれたJSONパス文字列リテラルであることに注意してください。
これは、正規表現で使用するすべてのバックスラッシュを二重に書かなければならないことを意味します。
たとえば、数字のみを含むroot文書の文字列値にマッチさせるには以下のようにします。
<programlisting>
$.* ? (@ like_regex "^\\d+$")
</programlisting>
    </para>
   </sect3>
  </sect2>
 </sect1>

 <sect1 id="functions-sequence">
<!--
  <title>Sequence Manipulation Functions</title>
-->
  <title>シーケンス操作関数</title>

  <indexterm>
   <primary>sequence</primary>
  </indexterm>

  <para>
<!--
   This section describes functions for operating on <firstterm>sequence
   objects</firstterm>, also called sequence generators or just sequences.
   Sequence objects are special single-row tables created with <xref
   linkend="sql-createsequence"/>.
   Sequence objects are commonly used to generate unique identifiers
   for rows of a table.  The sequence functions, listed in <xref
   linkend="functions-sequence-table"/>, provide simple, multiuser-safe
   methods for obtaining successive sequence values from sequence
   objects.
-->
本節では<firstterm>シーケンスオブジェクト</firstterm>に対し演算を行う関数について説明します。
シーケンスオブジェクトは、シーケンスジェネレータ、あるいは単にシーケンスとも呼ばれます。
シーケンスオブジェクトは特殊な一行だけのテーブルで、<xref linkend="sql-createsequence"/>で作成されます。
シーケンスオブジェクトは一般的にテーブルの行に一意の識別子を生成するために使用されます。
<xref linkend="functions-sequence-table"/>に列挙されているシーケンス関数は、シーケンスオブジェクトから連続したシーケンス値を取得するための、簡易でマルチユーザに対応した関数です。
  </para>

   <table id="functions-sequence-table">
<!--
    <title>Sequence Functions</title>
-->
    <title>シーケンス関数</title>
    <tgroup cols="1">
     <thead>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
<!--
        Function
-->
関数
       </para>
       <para>
<!--
        Description
-->
説明
       </para></entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>nextval</primary>
        </indexterm>
        <function>nextval</function> ( <type>regclass</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
<!--
        Advances the sequence object to its next value and returns that value.
        This is done atomically: even if multiple sessions
        execute <function>nextval</function> concurrently, each will safely
        receive a distinct sequence value.
        If the sequence object has been created with default parameters,
        successive <function>nextval</function> calls will return successive
        values beginning with 1.  Other behaviors can be obtained by using
        appropriate parameters in the <xref linkend="sql-createsequence"/>
        command.
-->
シーケンスを次の値に進めてその値を返します。
これは原子的に行われます。複数のセッションが<function>nextval</function>を同時に実行しても、各々のシーケンスは異なったシーケンス値を安全に返します。
シーケンスオブジェクトがデフォルト値を伴って作成されると、後続の<function>nextval</function>呼び出しは1から始まる次の値を返します。
それ以外の動作は適切なパラメータを<xref linkend="sql-createsequence"/>コマンドで使うことによって得られます。
      </para>
       <para>
<!--
        This function requires <literal>USAGE</literal>
        or <literal>UPDATE</literal> privilege on the sequence.
-->
この関数はシーケンスオブジェクトの<literal>USAGE</literal>あるいは<literal>UPDATE</literal>権限が必要です。
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>setval</primary>
        </indexterm>
        <function>setval</function> ( <type>regclass</type>, <type>bigint</type> <optional>, <type>boolean</type> </optional> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
<!--
        Sets the sequence object's current value, and optionally
        its <literal>is_called</literal> flag.  The two-parameter
        form sets the sequence's <literal>last_value</literal> field to the
        specified value and sets its <literal>is_called</literal> field to
        <literal>true</literal>, meaning that the next
        <function>nextval</function> will advance the sequence before
        returning a value.  The value that will be reported
        by <function>currval</function> is also set to the specified value.
        In the three-parameter form, <literal>is_called</literal> can be set
        to either <literal>true</literal>
        or <literal>false</literal>.  <literal>true</literal> has the same
        effect as the two-parameter form. If it is set
        to <literal>false</literal>, the next <function>nextval</function>
        will return exactly the specified value, and sequence advancement
        commences with the following <function>nextval</function>.
        Furthermore, the value reported by <function>currval</function> is not
        changed in this case.  For example,
-->
シーケンスオブジェクトの現在の値をセットします。オプションで<literal>is_called</literal>をセットします。
2つのパラメータを持つ形式では、シーケンスの<literal>last_value</literal>フィールドを指定した値にセットし、<literal>is_called</literal>フィールドを<literal>true</literal>に設定します。これは次の<function>nextval</function>が値を返す前にシーケンスを増分することを意味します。
<function>currval</function>で報告される値も指定した値に設定されます。
3つのパラメータを持つ形式では、<literal>is_called</literal>は<literal>true</literal>あるいは<literal>false</literal>に設定されます。
<literal>true</literal>は2つのパラメータを持つ形式と同じ効果を持ちます。
<literal>false</literal>に設定されていると、次の<function>nextval</function>はまさに指定した値を返し、後続の<function>nextval</function>がシーケンスの増加を開始します。
更に、この場合は<function>currval</function>が報告する値は変化しません。たとえば次ようになります。
<!--
<programlisting>
SELECT setval('myseq', 42);           <lineannotation>Next <function>nextval</function> will return 43</lineannotation>
SELECT setval('myseq', 42, true);     <lineannotation>Same as above</lineannotation>
SELECT setval('myseq', 42, false);    <lineannotation>Next <function>nextval</function> will return 42</lineannotation>
</programlisting>
-->
<programlisting>
SELECT setval('myseq', 42);           <lineannotation>次の<function>nextval</function>は43を返す</lineannotation>
SELECT setval('myseq', 42, true);     <lineannotation>同上</lineannotation>
SELECT setval('myseq', 42, false);    <lineannotation>次の<function>nextval</function>は42を返す</lineannotation>
</programlisting>
<!--
        The result returned by <function>setval</function> is just the value of its
        second argument.
-->
<function>setval</function>が返した値はその2番目の引数と単に同じです。
       </para>
       <para>
<!--
        This function requires <literal>UPDATE</literal> privilege on the
        sequence.
-->
この関数はシーケンスの<literal>UPDATE</literal>権限が必要です。
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>currval</primary>
        </indexterm>
        <function>currval</function> ( <type>regclass</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
<!--
        Returns the value most recently obtained
        by <function>nextval</function> for this sequence in the current
        session.  (An error is reported if <function>nextval</function> has
        never been called for this sequence in this session.)  Because this is
        returning a session-local value, it gives a predictable answer whether
        or not other sessions have executed <function>nextval</function> since
        the current session did.
-->
現在のセッションでこのシーケンスに対して直近の<function>nextval</function>によって得られた値を返します。
（このセッションで<function>nextval</function>が呼ばれていなければエラーが報告されます。）
これはセッションローカルな値を返すので、他のセッションが<function>nextval</function>を呼び出したかどうかに関わらず予測可能な値を返します。
       </para>
       <para>
<!--
        This function requires <literal>USAGE</literal>
        or <literal>SELECT</literal> privilege on the sequence.
-->
この関数はシーケンスの<literal>USAGE</literal>あるいは<literal>SELECT</literal>権限が必要です。
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>lastval</primary>
        </indexterm>
        <function>lastval</function> ()
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
<!--
        Returns the value most recently returned by
        <function>nextval</function> in the current session. This function is
        identical to <function>currval</function>, except that instead
        of taking the sequence name as an argument it refers to whichever
        sequence <function>nextval</function> was most recently applied to
        in the current session. It is an error to call
        <function>lastval</function> if <function>nextval</function>
        has not yet been called in the current session.
-->
現在のセッションでこのシーケンスに対して直近の<function>nextval</function>によって得られた値を返します。
この関数は、現在のセッションで<function>nextval</function>が直近に適用されたシーケンス名を参照する引数を取ることを除き、<function>currval</function>と同じです。
このセッションで<function>nextval</function>が呼ばれていないのに<function>lastval</function>を呼び出すのはエラーです。
       </para>
       <para>
<!--
        This function requires <literal>USAGE</literal>
        or <literal>SELECT</literal> privilege on the last used sequence.
-->
この関数はシーケンスの<literal>USAGE</literal>あるいは<literal>SELECT</literal>権限が必要です。
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <caution>
   <para>
<!--
    To avoid blocking concurrent transactions that obtain numbers from
    the same sequence, the value obtained by <function>nextval</function>
    is not reclaimed for re-use if the calling transaction later aborts.
    This means that transaction aborts or database crashes can result in
    gaps in the sequence of assigned values.  That can happen without a
    transaction abort, too.  For example an <command>INSERT</command> with
    an <literal>ON CONFLICT</literal> clause will compute the to-be-inserted
    tuple, including doing any required <function>nextval</function>
    calls, before detecting any conflict that would cause it to follow
    the <literal>ON CONFLICT</literal> rule instead.
    Thus, <productname>PostgreSQL</productname> sequence
    objects <emphasis>cannot be used to obtain <quote>gapless</quote>
    sequences</emphasis>.
-->
同一のシーケンスから数値を取得する同時実行トランザクション同士のブロックを防止するため、<function>nextval</function>で得られる値は、呼び出しているトランザクションが後でアボートした際に再利用目的での回収は行われません。
これは、トランザクションのアボートあるいはデータベースのクラッシュによって、割り当てられるシーケンスの値に欠番ができることがある、ということを意味します。
これはトランザクションのアボートがなくても起こります。
例えば<literal>ON CONFLICT</literal>句のある<command>INSERT</command>では、挿入される予定のタプルについて、必要となるすべての<function>nextval</function>の呼び出しも含めて計算し、その後で<literal>ON CONFLICT</literal>のルールを代わりに使用することになる競合について検知します。
従って、<productname>PostgreSQL</productname>のシーケンスオブジェクトは<emphasis><quote>欠番のない</quote>シーケンスを得るために使うことはできません</emphasis>。
   </para>

   <para>
<!--
    Likewise, sequence state changes made by <function>setval</function>
    are immediately visible to other transactions, and are not undone if
    the calling transaction rolls back.
-->
同様に、<function>setval</function>が行ったシーケンス状態の変更は直ちに他のトランザクションから可視になり、トランザクションがロールバックしても元には戻りません。
   </para>

   <para>
<!--
    If the database cluster crashes before committing a transaction
    containing a <function>nextval</function>
    or <function>setval</function> call, the sequence state change might
    not have made its way to persistent storage, so that it is uncertain
    whether the sequence will have its original or updated state after the
    cluster restarts.  This is harmless for usage of the sequence within
    the database, since other effects of uncommitted transactions will not
    be visible either.  However, if you wish to use a sequence value for
    persistent outside-the-database purposes, make sure that the
    <function>nextval</function> call has been committed before doing so.
-->
<function>nextval</function>や<function>setval</function>の呼び出しを含むトランザクションがコミットする前にデータベースクラスタがクラッシュすると、そのシーケンスの状態は永続的な記憶装置に格納されないかもしれず、クラスタが再起動した後にそのシーケンスが元の状態のままなのか、更新された状態になっているのかは定かではありません。
コミットされていないトランザクションは可視ではないので、これはデータベース内のシーケンスの利用に関して言えば無害です。
しかし、シーケンス値をデータベースの外での永続的な利用を目的として使う場合は、<function>nextval</function>の呼び出しが確実にコミットされてから利用してください。
   </para>
  </caution>

  <para>
<!--
   The sequence to be operated on by a sequence function is specified by
   a <type>regclass</type> argument, which is simply the OID of the sequence in the
   <structname>pg_class</structname> system catalog.  You do not have to look up the
   OID by hand, however, since the <type>regclass</type> data type's input
   converter will do the work for you.  See <xref linkend="datatype-oid"/>
   for details.
-->
シーケンス関数により操作されるシーケンスは<type>regclass</type>引数で指定されますが、それは<structname>pg_class</structname>システムカタログ内にある、そのシーケンスの単なるOIDです。
しかしながら、手作業でOIDを検索する必要はなく、<type>regclass</type>データ型の入力変換器が代わってその作業を行ってくれます。
詳細は<xref linkend="datatype-oid"/>を見てください。
  </para>
 </sect1>


 <sect1 id="functions-conditional">
<!--
  <title>Conditional Expressions</title>
-->
  <title>条件式</title>

  <indexterm>
   <primary>CASE</primary>
  </indexterm>

  <indexterm>
   <primary>conditional expression</primary>
  </indexterm>
  <indexterm>
   <primary>条件式</primary>
  </indexterm>

  <para>
<!--
   This section describes the <acronym>SQL</acronym>-compliant conditional expressions
   available in <productname>PostgreSQL</productname>.
-->
本節では<productname>PostgreSQL</productname>で使用可能な<acronym>SQL</acronym>準拠の条件式について説明します。
  </para>

  <tip>
   <para>
<!--
    If your needs go beyond the capabilities of these conditional
    expressions, you might want to consider writing a server-side function
    in a more expressive programming language.
-->
ここで説明する条件式より発展した機能を求める場合は、より表現の豊富なプログラム言語でストアドプロシージャを記述することで解決されます。
   </para>
  </tip>

   <note>
    <para>
<!--
     Although <token>COALESCE</token>, <token>GREATEST</token>, and
     <token>LEAST</token> are syntactically similar to functions, they are
     not ordinary functions, and thus cannot be used with explicit
     <token>VARIADIC</token> array arguments.
-->
<token>COALESCE</token>、<token>GREATEST</token>、<token>LEAST</token>は構文的には関数に似ていますが通常の関数ではなく、明示的な<token>VARIADIC</token>配列引数と一緒には使えません。
    </para>
   </note>

  <sect2 id="functions-case">
   <title><literal>CASE</literal></title>

  <para>
<!--
   The <acronym>SQL</acronym> <token>CASE</token> expression is a
   generic conditional expression, similar to if/else statements in
   other programming languages:
-->
<acronym>SQL</acronym>の<token>CASE</token>式は他のプログラミング言語のif/else構文に類似した汎用条件式です。

<synopsis>
CASE WHEN <replaceable>condition</replaceable> THEN <replaceable>result</replaceable>
     <optional>WHEN ...</optional>
     <optional>ELSE <replaceable>result</replaceable></optional>
END
</synopsis>

<!--
   <token>CASE</token> clauses can be used wherever
   an expression is valid.  Each <replaceable>condition</replaceable> is an
   expression that returns a <type>boolean</type> result.  If the condition's
   result is true, the value of the <token>CASE</token> expression is the
   <replaceable>result</replaceable> that follows the condition, and the
   remainder of the <token>CASE</token> expression is not processed.  If the
   condition's result is not true, any subsequent <token>WHEN</token> clauses
   are examined in the same manner.  If no <token>WHEN</token>
   <replaceable>condition</replaceable> yields true, the value of the
   <token>CASE</token> expression is the <replaceable>result</replaceable> of the
   <token>ELSE</token> clause.  If the <token>ELSE</token> clause is
   omitted and no condition is true, the result is null.
-->
<token>CASE</token>句は式が有効な位置であればどこでも使用可能です。
それぞれの<replaceable>condition</replaceable>とは<type>boolean</type>型の結果を返す式です。
もしconditionの結果が真であれば、<token>CASE</token>式の値は、conditionに続く<replaceable>result</replaceable>となります。そして、<token>CASE</token>式の残りは処理されません。
もしconditionの結果が偽であれば後に続く全ての<token>WHEN</token>句が同じようにして調べられます。
<token>WHEN</token>の<replaceable>condition</replaceable>の1つも真でない場合、<token>CASE</token>式の値は<token>ELSE</token>句の<replaceable>result</replaceable>になります。
<token>ELSE</token>句が省略され、どのconditionも真でない場合、結果はNULLです。
  </para>

   <para>
<!--
    An example:
-->
以下に例を示します。
<screen>
SELECT * FROM test;

 a
---
 1
 2
 3


SELECT a,
       CASE WHEN a=1 THEN 'one'
            WHEN a=2 THEN 'two'
            ELSE 'other'
       END
    FROM test;

 a | case
---+-------
 1 | one
 2 | two
 3 | other
</screen>
   </para>

  <para>
<!--
   The data types of all the <replaceable>result</replaceable>
   expressions must be convertible to a single output type.
   See <xref linkend="typeconv-union-case"/> for more details.
-->
全ての<replaceable>result</replaceable>式のデータ型は単一の出力型に変換可能でなければなりません。
詳細は<xref linkend="typeconv-union-case"/>を参照してください。
  </para>

  <para>
<!--
   There is a <quote>simple</quote> form of <token>CASE</token> expression
   that is a variant of the general form above:
-->
以下のように、上記の一般的な形式と異なる<token>CASE</token>式の<quote>単純な</quote>形式が存在します。

<synopsis>
CASE <replaceable>expression</replaceable>
    WHEN <replaceable>value</replaceable> THEN <replaceable>result</replaceable>
    <optional>WHEN ...</optional>
    <optional>ELSE <replaceable>result</replaceable></optional>
END
</synopsis>

<!--
   The first
   <replaceable>expression</replaceable> is computed, then compared to
   each of the <replaceable>value</replaceable> expressions in the
   <token>WHEN</token> clauses until one is found that is equal to it.  If
   no match is found, the <replaceable>result</replaceable> of the
   <token>ELSE</token> clause (or a null value) is returned.  This is similar
   to the <function>switch</function> statement in C.
-->
最初の<replaceable>expression</replaceable>が計算され、そしてそれに等しいものが見つかるまで<token>WHEN</token>句のそれぞれの<replaceable>value</replaceable>式と比較されます。
等しいものが見つからない場合、<token>ELSE</token>句の<replaceable>result</replaceable>（もしくはNULL値）が返されます。
これはC言語の<function>switch</function>文に似ています。
  </para>

   <para>
<!--
    The example above can be written using the simple
    <token>CASE</token> syntax:
-->
上の例は簡略形<token>CASE</token>構文を使って次のように書くことができます。
<screen>
SELECT a,
       CASE a WHEN 1 THEN 'one'
              WHEN 2 THEN 'two'
              ELSE 'other'
       END
    FROM test;

 a | case
---+-------
 1 | one
 2 | two
 3 | other
</screen>
   </para>

   <para>
<!--
    A <token>CASE</token> expression does not evaluate any subexpressions
    that are not needed to determine the result.  For example, this is a
    possible way of avoiding a division-by-zero failure:
-->
<token>CASE</token>式は、結果を決定するために不必要などんな副式をも評価しません。
例えば、以下は0除算エラーを防ぐための方法です。
<programlisting>
SELECT ... WHERE CASE WHEN x &lt;&gt; 0 THEN y/x &gt; 1.5 ELSE false END;
</programlisting>
   </para>

   <note>
    <para>
<!--
     As described in <xref linkend="syntax-express-eval"/>, there are various
     situations in which subexpressions of an expression are evaluated at
     different times, so that the principle that <quote><token>CASE</token>
     evaluates only necessary subexpressions</quote> is not ironclad.  For
     example a constant <literal>1/0</literal> subexpression will usually result in
     a division-by-zero failure at planning time, even if it's within
     a <token>CASE</token> arm that would never be entered at run time.
-->
<xref linkend="syntax-express-eval"/>で説明したとおり、式の副式が異なる時点で評価される様々な状況があります。そのため<quote><token>CASE</token>は必要な副式のみを評価する</quote>という原則は厳格なものではありません。
例えば、定数<literal>1/0</literal>副式は、実行時には決して入らない<token>CASE</token>節の中にあったとしても、通常は計画時にゼロによる除算での失敗という結果に終わります。
    </para>
   </note>
  </sect2>

  <sect2 id="functions-coalesce-nvl-ifnull">
   <title><literal>COALESCE</literal></title>

  <indexterm>
   <primary>COALESCE</primary>
  </indexterm>

  <indexterm>
   <primary>NVL</primary>
  </indexterm>

  <indexterm>
   <primary>IFNULL</primary>
  </indexterm>

<synopsis>
<function>COALESCE</function>(<replaceable>value</replaceable> <optional>, ...</optional>)
</synopsis>

  <para>
<!--
   The <function>COALESCE</function> function returns the first of its
   arguments that is not null.  Null is returned only if all arguments
   are null.  It is often used to substitute a default value for
   null values when data is retrieved for display, for example:
-->
<function>COALESCE</function>関数は、NULLでない自身の最初の引数を返します。
全ての引数がNULLの場合にのみNULLが返されます。データを表示目的で取り出す際、NULL値をデフォルト値で置き換えるためによく使用されています。以下に例を示します。
<programlisting>
SELECT COALESCE(description, short_description, '(none)') ...
</programlisting>
<!--
   This returns <varname>description</varname> if it is not null, otherwise
   <varname>short_description</varname> if it is not null, otherwise <literal>(none)</literal>.
-->
これは<varname>description</varname>がNULLでなければそれを返します。
そうでない場合（NULLの場合）は、<varname>short_description</varname>がNULLでなければそれを返します。
それ以外の場合（short_descriptionもNULLの場合）は<literal>(none)</literal>が返ります。
  </para>

   <para>
<!--
    The arguments must all be convertible to a common data type, which
    will be the type of the result (see
    <xref linkend="typeconv-union-case"/> for details).
-->
引数はすべて共通の型に変換できる必要があり、それが結果の型になります。（詳細は<xref linkend="typeconv-union-case"/>を参照してください。）
   </para>

   <para>
<!--
    Like a <token>CASE</token> expression, <function>COALESCE</function> only
    evaluates the arguments that are needed to determine the result;
    that is, arguments to the right of the first non-null argument are
    not evaluated.  This SQL-standard function provides capabilities similar
    to <function>NVL</function> and <function>IFNULL</function>, which are used in some other
    database systems.
-->
<token>CASE</token>式同様、<function>COALESCE</function>は結果を決定するために必要な引数のみを評価します。つまり、非NULL引数が見つかれば、その右側にある引数は評価されません。
この標準SQL関数は、他のいくつかのデータベースで使用されている<function>NVL</function>および<function>IFNULL</function>と類似の機能を提供します。
   </para>
  </sect2>

  <sect2 id="functions-nullif">
   <title><literal>NULLIF</literal></title>

  <indexterm>
   <primary>NULLIF</primary>
  </indexterm>

<synopsis>
<function>NULLIF</function>(<replaceable>value1</replaceable>, <replaceable>value2</replaceable>)
</synopsis>

  <para>
<!--
   The <function>NULLIF</function> function returns a null value if
   <replaceable>value1</replaceable> equals <replaceable>value2</replaceable>;
   otherwise it returns <replaceable>value1</replaceable>.
   This can be used to perform the inverse operation of the
   <function>COALESCE</function> example given above:
-->
<function>NULLIF</function>関数は、<replaceable>value1</replaceable>が<replaceable>value2</replaceable>と等しい場合、NULL値を返します。
その他の場合は<replaceable>value1</replaceable>を返します。
これを使って、上記の<function>COALESCE</function>の例の逆演算を実行できます
<programlisting>
SELECT NULLIF(value, '(none)') ...
</programlisting>
<!--
   In this example, if <literal>value</literal> is <literal>(none)</literal>,
   null is returned, otherwise the value of <literal>value</literal>
   is returned.
-->
この例では、<literal>value</literal>が<literal>(none)</literal>ならばNULLが返ります。
さもなくば<literal>value</literal>を返します
  </para>

  <para>
<!--
   The two arguments must be of comparable types.
   To be specific, they are compared exactly as if you had
   written <literal><replaceable>value1</replaceable>
   = <replaceable>value2</replaceable></literal>, so there must be a
   suitable <literal>=</literal> operator available.
-->
2つの引数は比較可能な型でなければなりません。
具体的には、あたかも<literal><replaceable>value1</replaceable> = <replaceable>value2</replaceable></literal>と書いたように比較されるので、適当な<literal>=</literal>演算子が使用できなければなりません。
  </para>

  <para>
<!--
   The result has the same type as the first argument &mdash; but there is
   a subtlety.  What is actually returned is the first argument of the
   implied <literal>=</literal> operator, and in some cases that will have
   been promoted to match the second argument's type.  For
   example, <literal>NULLIF(1, 2.2)</literal> yields <type>numeric</type>,
   because there is no <type>integer</type> <literal>=</literal>
   <type>numeric</type> operator,
   only <type>numeric</type> <literal>=</literal> <type>numeric</type>.
-->
結果は最初の引数と同じ型ですが、微妙な場合があります。
実際に返却されるのは<literal>=</literal>演算子が暗示する最初の引数で、場合によっては2番目の引数にマッチするように昇格されています。
たとえば<literal>NULLIF(1, 2.2)</literal>は<type>numeric</type>を出力します。なぜなら<type>integer</type> <literal>=</literal> <type>numeric</type>演算子はなく、<type>numeric</type> <literal>=</literal> <type>numeric</type>があるだけだからです。
  </para>

  </sect2>

  <sect2 id="functions-greatest-least">
<!--
   <title><literal>GREATEST</literal> and <literal>LEAST</literal></title>
-->
   <title><literal>GREATEST</literal>および<literal>LEAST</literal></title>

  <indexterm>
   <primary>GREATEST</primary>
  </indexterm>
  <indexterm>
   <primary>LEAST</primary>
  </indexterm>

<synopsis>
<function>GREATEST</function>(<replaceable>value</replaceable> <optional>, ...</optional>)
</synopsis>
<synopsis>
<function>LEAST</function>(<replaceable>value</replaceable> <optional>, ...</optional>)
</synopsis>

   <para>
<!--
    The <function>GREATEST</function> and <function>LEAST</function> functions select the
    largest or smallest value from a list of any number of expressions.
    The expressions must all be convertible to a common data type, which
    will be the type of the result
    (see <xref linkend="typeconv-union-case"/> for details).
-->
<function>GREATEST</function>と<function>LEAST</function>関数は任意の数の式のリストから最大値もしくは最小値を選択します。
評価される全ての式は共通の型に変換できる必要があり、それが結果の型になります（詳細は<xref linkend="typeconv-union-case"/>を参照してください）。
   </para>

   <para>
<!--
    NULL values in the argument list are ignored.  The result will be NULL
    only if all the expressions evaluate to NULL.  (This is a deviation from
    the SQL standard.  According to the standard, the return value is NULL if
    any argument is NULL.  Some other databases behave this way.)
-->
引数リストの中のNULL値は無視されます。
全ての式がNULLと評価された場合に限って結果はNULLになります。
（これは標準SQLからの逸脱です。
標準によれば、結果値は、いずれかの引数がNULLの場合はNULLになります。
他の一部のデータベースでは、このように動作します。）
   </para>
  </sect2>
 </sect1>

 <sect1 id="functions-array">
<!--
  <title>Array Functions and Operators</title>
-->
  <title>配列関数と演算子</title>

  <para>
<!--
   <xref linkend="array-operators-table"/> shows the specialized operators
   available for array types.
   In addition to those, the usual comparison operators shown in <xref
   linkend="functions-comparison-op-table"/> are available for
   arrays.  The comparison operators compare the array contents
   element-by-element, using the default B-tree comparison function for
   the element data type, and sort based on the first difference.
   In multidimensional arrays the elements are visited in row-major order
   (last subscript varies most rapidly).
   If the contents of two arrays are equal but the dimensionality is
   different, the first difference in the dimensionality information
   determines the sort order.
-->
<xref linkend="array-operators-table"/>に、配列型専用に利用可能な演算子を示します。
これらに加えて<xref linkend="functions-comparison-op-table"/>で示す通常の比較演算子が配列で利用できます。
比較演算子は配列の内容をその要素のデータ型用のデフォルトのB-tree比較関数を要素単位で比較し、最初にどの要素に違いがあったかに基づいてソートします。
多次元配列では配列の要素は行優先順にアクセスされます。（最後の添字が最初に変化します。）
2つの配列の内容が同じで次元数が異なる場合は、どの次元で最初に違いがあったかによってソート順が決まります。
  </para>

   <table id="array-operators-table">
<!--
    <title>Array Operators</title>
-->
    <title>配列演算子</title>
    <tgroup cols="1">
     <thead>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
<!--
        Operator
-->
演算子
       </para>
       <para>
<!--
        Description
-->
説明
       </para>
       <para>
<!--
        Example(s)
-->
例
       </para></entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyarray</type> <literal>@&gt;</literal> <type>anyarray</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Does the first array contain the second, that is, does each element
        appearing in the second array equal some element of the first array?
        (Duplicates are not treated specially,
        thus <literal>ARRAY[1]</literal> and <literal>ARRAY[1,1]</literal> are
        each considered to contain the other.)
-->
最初の配列が2番目を含んでいるか？すなわち、2番目の配列の各要素は最初の配列のいくつかの要素と同じであるか？
（重複は特に考慮されないので、<literal>ARRAY[1]</literal>と<literal>ARRAY[1,1]</literal>はそれぞれがお互いに相手を含んでいると見なされます。）
       </para>
       <para>
        <literal>ARRAY[1,4,3] @&gt; ARRAY[3,1,3]</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyarray</type> <literal>&lt;@</literal> <type>anyarray</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Is the first array contained by the second?
-->
最初の配列は2番目に含まれているか？
       </para>
       <para>
        <literal>ARRAY[2,2,7] &lt;@ ARRAY[1,7,4,2,6]</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyarray</type> <literal>&amp;&amp;</literal> <type>anyarray</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Do the arrays overlap, that is, have any elements in common?
-->
配列は重なり合っているか？すなわち、共通の要素を持っているか？
       </para>
       <para>
        <literal>ARRAY[1,4,3] &amp;&amp; ARRAY[2,1]</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anycompatiblearray</type> <literal>||</literal> <type>anycompatiblearray</type>
        <returnvalue>anycompatiblearray</returnvalue>
       </para>
       <para>
<!--
        Concatenates the two arrays.  Concatenating a null or empty array is a
        no-op; otherwise the arrays must have the same number of dimensions
        (as illustrated by the first example) or differ in number of
        dimensions by one (as illustrated by the second).
        If the arrays are not of identical element types, they will be coerced
        to a common type (see <xref linkend="typeconv-union-case"/>).
-->
2つの配列を結合します。
nullあるいは空の配列の結合は無処理です。そうでない場合は、配列は同じ次元数を持っていなければなりません。
（最初の例にあるように）。さもなければ次元数でひとつ違わなければなりません（2番目の例にあるように）。
配列の要素型が異なる場合は、共通の型へと置き換えられます（<xref linkend="typeconv-union-case"/>参照）。
       </para>
       <para>
        <literal>ARRAY[1,2,3] || ARRAY[4,5,6,7]</literal>
        <returnvalue>{1,2,3,4,5,6,7}</returnvalue>
       </para>
       <para>
        <literal>ARRAY[1,2,3] || ARRAY[[4,5,6],[7,8,9.9]]</literal>
        <returnvalue>{{1,2,3},{4,5,6},{7,8,9.9}}</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anycompatible</type> <literal>||</literal> <type>anycompatiblearray</type>
        <returnvalue>anycompatiblearray</returnvalue>
       </para>
       <para>
<!--
        Concatenates an element onto the front of an array (which must be
        empty or one-dimensional).
-->
配列（空か一次元の配列でなければなりません）の先頭に要素を結合します。
       </para>
       <para>
        <literal>3 || ARRAY[4,5,6]</literal>
        <returnvalue>{3,4,5,6}</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anycompatiblearray</type> <literal>||</literal> <type>anycompatible</type>
        <returnvalue>anycompatiblearray</returnvalue>
       </para>
       <para>
<!--
        Concatenates an element onto the end of an array (which must be
        empty or one-dimensional).
-->
配列（空か一次元の配列でなければなりません）の最後に要素を結合します。
       </para>
       <para>
        <literal>ARRAY[4,5,6] || 7</literal>
        <returnvalue>{4,5,6,7}</returnvalue>
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <para>
<!--
   See <xref linkend="arrays"/> for more details about array operator
   behavior.  See <xref linkend="indexes-types"/> for more details about
   which operators support indexed operations.
-->
配列演算子の振舞いの詳細は<xref linkend="arrays"/>を参照してください。
どの演算子がインデックス付きの操作をサポートしているかのより詳細については<xref linkend="indexes-types"/>を参照してください。
  </para>

  <para>
<!--
   <xref linkend="array-functions-table"/> shows the functions
   available for use with array types. See <xref linkend="arrays"/>
   for more information  and examples of the use of these functions.
-->
<xref linkend="array-functions-table"/>に配列型で使用可能な関数を示します。
これらの関数の情報と例については<xref linkend="arrays"/>を参照してください。
  </para>

   <table id="array-functions-table">
<!--
    <title>Array Functions</title>
-->
    <title>配列関数</title>
    <tgroup cols="1">
     <thead>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
<!--
        Function
-->
関数
       </para>
       <para>
<!--
        Description
-->
説明
       </para>
       <para>
<!--
        Example(s)
-->
例
       </para></entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_append</primary>
        </indexterm>
        <function>array_append</function> ( <type>anycompatiblearray</type>, <type>anycompatible</type> )
        <returnvalue>anycompatiblearray</returnvalue>
       </para>
       <para>
<!--
        Appends an element to the end of an array (same as
        the <type>anycompatiblearray</type> <literal>||</literal> <type>anycompatible</type>
        operator).
-->
配列の最後に要素を追加します。（<type>anycompatiblearray</type> <literal>||</literal> <type>anycompatible</type>演算子と同じです。）
       </para>
       <para>
        <literal>array_append(ARRAY[1,2], 3)</literal>
        <returnvalue>{1,2,3}</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_cat</primary>
        </indexterm>
        <function>array_cat</function> ( <type>anycompatiblearray</type>, <type>anycompatiblearray</type> )
        <returnvalue>anycompatiblearray</returnvalue>
       </para>
       <para>
<!--
        Concatenates two arrays (same as
        the <type>anycompatiblearray</type> <literal>||</literal> <type>anycompatiblearray</type>
        operator).
-->
2つの配列を結合します。（<type>anycompatiblearray</type> <literal>||</literal> <type>anycompatiblearray</type>演算子と同じです。）
       </para>
       <para>
        <literal>array_cat(ARRAY[1,2,3], ARRAY[4,5])</literal>
        <returnvalue>{1,2,3,4,5}</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_dims</primary>
        </indexterm>
        <function>array_dims</function> ( <type>anyarray</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
<!--
        Returns a text representation of the array's dimensions.
-->
配列の次元をテキスト表現で返します。
       </para>
       <para>
        <literal>array_dims(ARRAY[[1,2,3], [4,5,6]])</literal>
        <returnvalue>[1:2][1:3]</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_fill</primary>
        </indexterm>
        <function>array_fill</function> ( <type>anyelement</type>, <type>integer[]</type>
          <optional>, <type>integer[]</type> </optional> )
        <returnvalue>anyarray</returnvalue>
       </para>
       <para>
<!--
        Returns an array filled with copies of the given value, having
        dimensions of the lengths specified by the second argument.
        The optional third argument supplies lower-bound values for each
        dimension (which default to all <literal>1</literal>).
-->
与えられた値のコピーで満たされた2番目の引数で指定した次元の長さを持つ配列を返します。
オプションの3番目の引数は各次元の下限値を与えます（デフォルトはすべて<literal>1</literal>です）。
       </para>
       <para>
        <literal>array_fill(11, ARRAY[2,3])</literal>
        <returnvalue>{{11,11,11},{11,11,11}}</returnvalue>
       </para>
       <para>
        <literal>array_fill(7, ARRAY[3], ARRAY[2])</literal>
        <returnvalue>[2:4]={7,7,7}</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_length</primary>
        </indexterm>
        <function>array_length</function> ( <type>anyarray</type>, <type>integer</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
<!--
        Returns the length of the requested array dimension.
        (Produces NULL instead of 0 for empty or missing array dimensions.)
-->
要求された配列の次元の大きさを返します。
（空、あるいは配列の次元が見つからない場合は0ではなくNULLを生成します。）
       </para>
       <para>
        <literal>array_length(array[1,2,3], 1)</literal>
        <returnvalue>3</returnvalue>
       </para>
       <para>
        <literal>array_length(array[]::int[], 1)</literal>
        <returnvalue>NULL</returnvalue>
       </para>
       <para>
        <literal>array_length(array['text'], 2)</literal>
        <returnvalue>NULL</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_lower</primary>
        </indexterm>
        <function>array_lower</function> ( <type>anyarray</type>, <type>integer</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
<!--
        Returns the lower bound of the requested array dimension.
-->
要求された配列の次元の下限を返します。
       </para>
       <para>
        <literal>array_lower('[0:2]={1,2,3}'::integer[], 1)</literal>
        <returnvalue>0</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_ndims</primary>
        </indexterm>
        <function>array_ndims</function> ( <type>anyarray</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
<!--
        Returns the number of dimensions of the array.
-->
配列の次元数を返します。
       </para>
       <para>
        <literal>array_ndims(ARRAY[[1,2,3], [4,5,6]])</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_position</primary>
        </indexterm>
        <function>array_position</function> ( <type>anycompatiblearray</type>, <type>anycompatible</type> <optional>, <type>integer</type> </optional> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
<!--
        Returns the subscript of the first occurrence of the second argument
        in the array, or <literal>NULL</literal> if it's not present.
        If the third argument is given, the search begins at that subscript.
        The array must be one-dimensional.
        Comparisons are done using <literal>IS NOT DISTINCT FROM</literal>
        semantics, so it is possible to search for <literal>NULL</literal>.
-->
2番目の引数が最初に配列に現れた添字を返します。存在しなければ<literal>NULL</literal>を返します。
3番目の引数が与えられるとその添字から検索が始まります。
配列は一次元でなければなりません。
比較は<literal>IS NOT DISTINCT FROM</literal>の意味論で行われるので、<literal>NULL</literal>を検索することができます。
       </para>
       <para>
        <literal>array_position(ARRAY['sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat'], 'mon')</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_positions</primary>
        </indexterm>
        <function>array_positions</function> ( <type>anycompatiblearray</type>, <type>anycompatible</type> )
        <returnvalue>integer[]</returnvalue>
       </para>
       <para>
<!--
        Returns an array of the subscripts of all occurrences of the second
        argument in the array given as first argument.
        The array must be one-dimensional.
        Comparisons are done using <literal>IS NOT DISTINCT FROM</literal>
        semantics, so it is possible to search for <literal>NULL</literal>.
        <literal>NULL</literal> is returned only if the array
        is <literal>NULL</literal>; if the value is not found in the array, an
        empty array is returned.
-->
2番目の引数が最初の引数として与えられた配列に現れるすべての添字を配列で返します。
配列は一次元でなければなりません。
比較は<literal>IS NOT DISTINCT FROM</literal>の意味論で行われるので、<literal>NULL</literal>を検索することができます。
配列が<literal>NULL</literal>のときのみ<literal>NULL</literal>が返ります。
値が配列中に見つからなければ空の配列が返ります。
       </para>
       <para>
        <literal>array_positions(ARRAY['A','A','B','A'], 'A')</literal>
        <returnvalue>{1,2,4}</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_prepend</primary>
        </indexterm>
        <function>array_prepend</function> ( <type>anycompatible</type>, <type>anycompatiblearray</type> )
        <returnvalue>anycompatiblearray</returnvalue>
       </para>
       <para>
<!--
        Prepends an element to the beginning of an array (same as
        the <type>anycompatible</type> <literal>||</literal> <type>anycompatiblearray</type>
        operator).
-->
配列の先頭に要素を追加します。（<type>anycompatible</type> <literal>||</literal> <type>anycompatiblearray</type>演算子と同じです。）
       </para>
       <para>
        <literal>array_prepend(1, ARRAY[2,3])</literal>
        <returnvalue>{1,2,3}</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_remove</primary>
        </indexterm>
        <function>array_remove</function> ( <type>anycompatiblearray</type>, <type>anycompatible</type> )
        <returnvalue>anycompatiblearray</returnvalue>
       </para>
       <para>
<!--
        Removes all elements equal to the given value from the array.
        The array must be one-dimensional.
        Comparisons are done using <literal>IS NOT DISTINCT FROM</literal>
        semantics, so it is possible to remove <literal>NULL</literal>s.
-->
与えられた値と等しい要素を配列から削除します。
配列は一次元でなければなりません。
比較は<literal>IS NOT DISTINCT FROM</literal>の意味論で行われるので、<literal>NULL</literal>を削除することができます。
       </para>
       <para>
        <literal>array_remove(ARRAY[1,2,3,2], 2)</literal>
        <returnvalue>{1,3}</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_replace</primary>
        </indexterm>
        <function>array_replace</function> ( <type>anycompatiblearray</type>, <type>anycompatible</type>, <type>anycompatible</type> )
        <returnvalue>anycompatiblearray</returnvalue>
       </para>
       <para>
<!--
        Replaces each array element equal to the second argument with the
        third argument.
-->
2番目の引数と等しい要素を3番目の引数で置き換えます。
       </para>
       <para>
        <literal>array_replace(ARRAY[1,2,5,4], 5, 3)</literal>
        <returnvalue>{1,2,3,4}</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_sample</primary>
        </indexterm>
        <function>array_sample</function> ( <parameter>array</parameter> <type>anyarray</type>, <parameter>n</parameter> <type>integer</type> )
        <returnvalue>anyarray</returnvalue>
       </para>
       <para>
<!--
        Returns an array of <parameter>n</parameter> items randomly selected
        from <parameter>array</parameter>.  <parameter>n</parameter> may not
        exceed the length of <parameter>array</parameter>'s first dimension.
        If <parameter>array</parameter> is multi-dimensional,
        an <quote>item</quote> is a slice having a given first subscript.
-->
<parameter>array</parameter>からランダムに選択された<parameter>n</parameter>個のアイテムの配列を返します。
<parameter>n</parameter>は<parameter>array</parameter>の最初の次元の長さを超えることはできません。
<parameter>array</parameter>が多次元の場合、<quote>item</quote>は指定された最初の添字を持つスライスです。
       </para>
       <para>
        <literal>array_sample(ARRAY[1,2,3,4,5,6], 3)</literal>
        <returnvalue>{2,6,1}</returnvalue>
       </para>
       <para>
        <literal>array_sample(ARRAY[[1,2],[3,4],[5,6]], 2)</literal>
        <returnvalue>{{5,6},{1,2}}</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_shuffle</primary>
        </indexterm>
        <function>array_shuffle</function> ( <type>anyarray</type> )
        <returnvalue>anyarray</returnvalue>
       </para>
       <para>
<!--
        Randomly shuffles the first dimension of the array.
-->
配列の1次元目をランダムにシャッフルします。
       </para>
       <para>
        <literal>array_shuffle(ARRAY[[1,2],[3,4],[5,6]])</literal>
        <returnvalue>{{5,6},{1,2},{3,4}}</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm id="function-array-to-string">
         <primary>array_to_string</primary>
        </indexterm>
        <function>array_to_string</function> ( <parameter>array</parameter> <type>anyarray</type>, <parameter>delimiter</parameter> <type>text</type> <optional>, <parameter>null_string</parameter> <type>text</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
<!--
        Converts each array element to its text representation, and
        concatenates those separated by
        the <parameter>delimiter</parameter> string.
        If <parameter>null_string</parameter> is given and is
        not <literal>NULL</literal>, then <literal>NULL</literal> array
        entries are represented by that string; otherwise, they are omitted.
        See also <link linkend="function-string-to-array"><function>string_to_array</function></link>.
-->
配列要素をテキスト表現に変換し<parameter>delimiter</parameter>文字列で区切って結合します。
<literal>NULL</literal>でない<parameter>null_string</parameter>が与えられると、<literal>NULL</literal>配列要素をその文字列で表現します。さもなければ無視されます。
<link linkend="function-string-to-array"><function>string_to_array</function></link>も参照してください。
       </para>
       <para>
        <literal>array_to_string(ARRAY[1, 2, 3, NULL, 5], ',', '*')</literal>
        <returnvalue>1,2,3,*,5</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_upper</primary>
        </indexterm>
        <function>array_upper</function> ( <type>anyarray</type>, <type>integer</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
<!--
        Returns the upper bound of the requested array dimension.
-->
要求された配列の次元の上限を返します。
       </para>
       <para>
        <literal>array_upper(ARRAY[1,8,3,7], 1)</literal>
        <returnvalue>4</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>cardinality</primary>
        </indexterm>
        <function>cardinality</function> ( <type>anyarray</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
<!--
        Returns the total number of elements in the array, or 0 if the array
        is empty.
-->
配列中の要素数を返します。配列が空なら0が返ります。
       </para>
       <para>
        <literal>cardinality(ARRAY[[1,2],[3,4]])</literal>
        <returnvalue>4</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>trim_array</primary>
        </indexterm>
        <function>trim_array</function> ( <parameter>array</parameter> <type>anyarray</type>, <parameter>n</parameter> <type>integer</type> )
        <returnvalue>anyarray</returnvalue>
       </para>
       <para>
<!--
        Trims an array by removing the last <parameter>n</parameter> elements.
        If the array is multidimensional, only the first dimension is trimmed.
-->
最後の<parameter>n</parameter>要素を削除して配列を短縮します。
配列が複数次元なら、最初の次元だけが短縮されます。
       </para>
       <para>
        <literal>trim_array(ARRAY[1,2,3,4,5,6], 2)</literal>
        <returnvalue>{1,2,3,4}</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>unnest</primary>
        </indexterm>
        <function>unnest</function> ( <type>anyarray</type> )
        <returnvalue>setof anyelement</returnvalue>
       </para>
       <para>
<!--
        Expands an array into a set of rows.
        The array's elements are read out in storage order.
-->
配列を行の集合に展開します。
配列要素は格納順に読み出されます。
       </para>
       <para>
        <literal>unnest(ARRAY[1,2])</literal>
        <returnvalue></returnvalue>
<programlisting>
 1
 2
</programlisting>
       </para>
       <para>
        <literal>unnest(ARRAY[['foo','bar'],['baz','quux']])</literal>
        <returnvalue></returnvalue>
<programlisting>
 foo
 bar
 baz
 quux
</programlisting>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>unnest</function> ( <type>anyarray</type>, <type>anyarray</type> <optional>, ... </optional> )
        <returnvalue>setof anyelement, anyelement [, ... ]</returnvalue>
       </para>
       <para>
<!--
        Expands multiple arrays (possibly of different data types) into a set of
        rows.  If the arrays are not all the same length then the shorter ones
        are padded with <literal>NULL</literal>s.  This form is only allowed
        in a query's FROM clause; see <xref linkend="queries-tablefunctions"/>.
-->
複数の配列（異なるデータ型の可能性があります）を行の集合に展開します。
配列の長さが同じでなければ、短い配列には<literal>NULL</literal>が詰められます。
これは問い合わせのFROM句でのみ許されます。<xref linkend="queries-tablefunctions"/>を参照してください。
       </para>
       <para>
        <literal>select * from unnest(ARRAY[1,2], ARRAY['foo','bar','baz']) as x(a,b)</literal>
        <returnvalue></returnvalue>
<programlisting>
 a |  b
---+-----
 1 | foo
 2 | bar
   | baz
</programlisting>
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
<!--
    See also <xref linkend="functions-aggregate"/> about the aggregate
    function <function>array_agg</function> for use with arrays.
-->
配列を使用する集約関数<function>array_agg</function>について、<xref linkend="functions-aggregate"/>も参照してください。
   </para>
  </sect1>

 <sect1 id="functions-range">
<!--
  <title>Range/Multirange Functions and Operators</title>
-->
  <title>範囲／多重範囲関数と演算子</title>

  <para>
<!--
   See <xref linkend="rangetypes"/> for an overview of range types.
-->
範囲型の概要については<xref linkend="rangetypes"/>をご覧ください。
  </para>

  <para>
<!--
   <xref linkend="range-operators-table"/> shows the specialized operators
   available for range types.
   <xref linkend="multirange-operators-table"/> shows the specialized operators
   available for multirange types.
   In addition to those, the usual comparison operators shown in
   <xref linkend="functions-comparison-op-table"/> are available for range
   and multirange types.  The comparison operators order first by the range lower
   bounds, and only if those are equal do they compare the upper bounds.  The
   multirange operators compare each range until one is unequal. This
   does not usually result in a useful overall ordering, but the operators are
   provided to allow unique indexes to be constructed on ranges.
-->
<xref linkend="range-operators-table"/>に、範囲型専用に利用可能な演算子を示します。
<xref linkend="multirange-operators-table"/>に、多重範囲(multirange)型専用に利用可能な演算子を示します。
これらに加えて<xref linkend="functions-comparison-op-table"/>で示す通常の比較演算子が範囲型と多重範囲型で利用できます。
この比較演算子は最初に範囲の下限で順序付けし、それが等しい場合にのみ上限を比較します。
多重範囲型の演算子は各範囲を、等しくならなくなるまで比較します。
これは通常有用な全順序付けにはなりませんが、範囲に対して一意インデックスを構成することができる演算子が提供されます。
  </para>

   <table id="range-operators-table">
<!--
    <title>Range Operators</title>
-->
    <title>範囲演算子</title>
    <tgroup cols="1">
     <thead>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
<!--
        Operator
-->
演算子
       </para>
       <para>
<!--
        Description
-->
説明
       </para>
       <para>
<!--
        Example(s)
-->
例
       </para></entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyrange</type> <literal>@&gt;</literal> <type>anyrange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Does the first range contain the second?
-->
最初の範囲は2番目を含んでいるか？
       </para>
       <para>
        <literal>int4range(2,4) @&gt; int4range(2,3)</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyrange</type> <literal>@&gt;</literal> <type>anyelement</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Does the range contain the element?
-->
範囲はその要素を含んでいるか？
       </para>
       <para>
        <literal>'[2011-01-01,2011-03-01)'::tsrange @&gt; '2011-01-10'::timestamp</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyrange</type> <literal>&lt;@</literal> <type>anyrange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Is the first range contained by the second?
-->
最初の範囲は2番目に含まれるか？
       </para>
       <para>
        <literal>int4range(2,4) &lt;@ int4range(1,7)</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyelement</type> <literal>&lt;@</literal> <type>anyrange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Is the element contained in the range?
-->
その要素は範囲に含まれるか？
       </para>
       <para>
        <literal>42 &lt;@ int4range(1,7)</literal>
        <returnvalue>f</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyrange</type> <literal>&amp;&amp;</literal> <type>anyrange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Do the ranges overlap, that is, have any elements in common?
-->
範囲は重なり合っているか？すなわち共通の要素があるか？
       </para>
       <para>
        <literal>int8range(3,7) &amp;&amp; int8range(4,12)</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyrange</type> <literal>&lt;&lt;</literal> <type>anyrange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Is the first range strictly left of the second?
-->
最初の範囲は厳密に2番目の左か？
       </para>
       <para>
        <literal>int8range(1,10) &lt;&lt; int8range(100,110)</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyrange</type> <literal>&gt;&gt;</literal> <type>anyrange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Is the first range strictly right of the second?
-->
最初の範囲は厳密に2番目の右か？
       </para>
       <para>
        <literal>int8range(50,60) &gt;&gt; int8range(20,30)</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyrange</type> <literal>&amp;&lt;</literal> <type>anyrange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Does the first range not extend to the right of the second?
-->
最初の範囲は2番目の右を被覆していないか？
       </para>
       <para>
        <literal>int8range(1,20) &amp;&lt; int8range(18,20)</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyrange</type> <literal>&amp;&gt;</literal> <type>anyrange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Does the first range not extend to the left of the second?
-->
最初の範囲は2番目の左を被覆していないか？
       </para>
       <para>
        <literal>int8range(7,20) &amp;&gt; int8range(5,10)</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyrange</type> <literal>-|-</literal> <type>anyrange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Are the ranges adjacent?
-->
範囲は隣接しているか？
       </para>
       <para>
        <literal>numrange(1.1,2.2) -|- numrange(2.2,3.3)</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyrange</type> <literal>+</literal> <type>anyrange</type>
        <returnvalue>anyrange</returnvalue>
       </para>
       <para>
<!--
        Computes the union of the ranges.  The ranges must overlap or be
        adjacent, so that the union is a single range (but
        see <function>range_merge()</function>).
-->
範囲の和を計算します。範囲は和の結果が単一の範囲になるように、重なり合っているか、隣接していなければなりません。（ただし<function>range_merge()</function>を参照してください。）
       </para>
       <para>
        <literal>numrange(5,15) + numrange(10,20)</literal>
        <returnvalue>[5,20)</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyrange</type> <literal>*</literal> <type>anyrange</type>
        <returnvalue>anyrange</returnvalue>
       </para>
       <para>
<!--
        Computes the intersection of the ranges.
-->
範囲の共通部分を計算します。
       </para>
       <para>
        <literal>int8range(5,15) * int8range(10,20)</literal>
        <returnvalue>[10,15)</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyrange</type> <literal>-</literal> <type>anyrange</type>
        <returnvalue>anyrange</returnvalue>
       </para>
       <para>
<!--
        Computes the difference of the ranges.  The second range must not be
        contained in the first in such a way that the difference would not be
        a single range.
-->
範囲の差を計算します。
差が単一の範囲にならないように、2番目の範囲は最初の範囲に含まれていてはいけません。
       </para>
       <para>
        <literal>int8range(5,15) - int8range(10,20)</literal>
        <returnvalue>[5,10)</returnvalue>
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <table id="multirange-operators-table">
<!--
    <title>Multirange Operators</title>
-->
    <title>多重範囲演算子</title>
    <tgroup cols="1">
     <thead>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
<!--
        Operator
-->
演算子
       </para>
       <para>
<!--
        Description
-->
説明
       </para>
       <para>
<!--
        Example(s)
-->
例
       </para></entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anymultirange</type> <literal>@&gt;</literal> <type>anymultirange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Does the first multirange contain the second?
-->
最初の多重範囲は2番目を含んでいるか？
       </para>
       <para>
        <literal>'{[2,4)}'::int4multirange @&gt; '{[2,3)}'::int4multirange</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anymultirange</type> <literal>@&gt;</literal> <type>anyrange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Does the multirange contain the range?
-->
多重範囲は範囲を含んでいるか？
       </para>
       <para>
        <literal>'{[2,4)}'::int4multirange @&gt; int4range(2,3)</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anymultirange</type> <literal>@&gt;</literal> <type>anyelement</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Does the multirange contain the element?
-->
多重範囲は要素を含んでいるか？
       </para>
       <para>
        <literal>'{[2011-01-01,2011-03-01)}'::tsmultirange @&gt; '2011-01-10'::timestamp</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyrange</type> <literal>@&gt;</literal> <type>anymultirange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Does the range contain the multirange?
-->
範囲は多重範囲を含んでいるか？
       </para>
       <para>
        <literal>'[2,4)'::int4range @&gt; '{[2,3)}'::int4multirange</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anymultirange</type> <literal>&lt;@</literal> <type>anymultirange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Is the first multirange contained by the second?
-->
最初の多重範囲は2番目に含まれているか？
       </para>
       <para>
        <literal>'{[2,4)}'::int4multirange &lt;@ '{[1,7)}'::int4multirange</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anymultirange</type> <literal>&lt;@</literal> <type>anyrange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Is the multirange contained by the range?
-->
多重範囲は範囲に含まれているか？
       </para>
       <para>
        <literal>'{[2,4)}'::int4multirange &lt;@ int4range(1,7)</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyrange</type> <literal>&lt;@</literal> <type>anymultirange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Is the range contained by the multirange?
-->
範囲は多重範囲に含まれているか？
       </para>
       <para>
        <literal>int4range(2,4) &lt;@ '{[1,7)}'::int4multirange</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyelement</type> <literal>&lt;@</literal> <type>anymultirange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Is the element contained by the multirange?
-->
要素は多重範囲に含まれているか？
       </para>
       <para>
        <literal>4 &lt;@ '{[1,7)}'::int4multirange</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anymultirange</type> <literal>&amp;&amp;</literal> <type>anymultirange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Do the multiranges overlap, that is, have any elements in common?
-->
多重範囲は重なっているか？すなわち、共通に持つ要素があるか？
       </para>
       <para>
        <literal>'{[3,7)}'::int8multirange &amp;&amp; '{[4,12)}'::int8multirange</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anymultirange</type> <literal>&amp;&amp;</literal> <type>anyrange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Does the multirange overlap the range?
-->
多重範囲は範囲と重なり合うか？
       </para>
       <para>
        <literal>'{[3,7)}'::int8multirange &amp;&amp; int8range(4,12)</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyrange</type> <literal>&amp;&amp;</literal> <type>anymultirange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Does the range overlap the multirange?
-->
範囲は多重範囲と重なり合うか？
       </para>
       <para>
        <literal>int8range(3,7) &amp;&amp; '{[4,12)}'::int8multirange</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anymultirange</type> <literal>&lt;&lt;</literal> <type>anymultirange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Is the first multirange strictly left of the second?
-->
最初の多重範囲は厳密に2番目の左か？
       </para>
       <para>
        <literal>'{[1,10)}'::int8multirange &lt;&lt; '{[100,110)}'::int8multirange</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anymultirange</type> <literal>&lt;&lt;</literal> <type>anyrange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Is the multirange strictly left of the range?
-->
多重範囲は厳密に範囲の左か？
       </para>
       <para>
        <literal>'{[1,10)}'::int8multirange &lt;&lt; int8range(100,110)</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyrange</type> <literal>&lt;&lt;</literal> <type>anymultirange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Is the range strictly left of the multirange?
-->
範囲は厳密に多重範囲の左か？
       </para>
       <para>
        <literal>int8range(1,10) &lt;&lt; '{[100,110)}'::int8multirange</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anymultirange</type> <literal>&gt;&gt;</literal> <type>anymultirange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Is the first multirange strictly right of the second?
-->
最初の多重範囲は厳密に2番目の右か？
       </para>
       <para>
        <literal>'{[50,60)}'::int8multirange &gt;&gt; '{[20,30)}'::int8multirange</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anymultirange</type> <literal>&gt;&gt;</literal> <type>anyrange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Is the multirange strictly right of the range?
-->
多重範囲は厳密に範囲の右か？
       </para>
       <para>
        <literal>'{[50,60)}'::int8multirange &gt;&gt; int8range(20,30)</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyrange</type> <literal>&gt;&gt;</literal> <type>anymultirange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Is the range strictly right of the multirange?
-->
範囲は厳密に多重範囲の右か？
       </para>
       <para>
        <literal>int8range(50,60) &gt;&gt; '{[20,30)}'::int8multirange</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anymultirange</type> <literal>&amp;&lt;</literal> <type>anymultirange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Does the first multirange not extend to the right of the second?
-->
最初の多重範囲は2番目の右を被覆していないか？
       </para>
       <para>
        <literal>'{[1,20)}'::int8multirange &amp;&lt; '{[18,20)}'::int8multirange</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anymultirange</type> <literal>&amp;&lt;</literal> <type>anyrange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Does the multirange not extend to the right of the range?
-->
多重範囲は範囲の右を被覆していないか？
       </para>
       <para>
        <literal>'{[1,20)}'::int8multirange &amp;&lt; int8range(18,20)</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyrange</type> <literal>&amp;&lt;</literal> <type>anymultirange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Does the range not extend to the right of the multirange?
-->
範囲は多重範囲の右を被覆していないか？
       </para>
       <para>
        <literal>int8range(1,20) &amp;&lt; '{[18,20)}'::int8multirange</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anymultirange</type> <literal>&amp;&gt;</literal> <type>anymultirange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Does the first multirange not extend to the left of the second?
-->
最初の多重範囲は2番目の左を被覆していないか？
       </para>
       <para>
        <literal>'{[7,20)}'::int8multirange &amp;&gt; '{[5,10)}'::int8multirange</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anymultirange</type> <literal>&amp;&gt;</literal> <type>anyrange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Does the multirange not extend to the left of the range?
-->
多重範囲は範囲の左を被覆していないか？
       </para>
       <para>
        <literal>'{[7,20)}'::int8multirange &amp;&gt; int8range(5,10)</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyrange</type> <literal>&amp;&gt;</literal> <type>anymultirange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Does the range not extend to the left of the multirange?
-->
範囲は多重範囲の左を被覆していないか？
       </para>
       <para>
        <literal>int8range(7,20) &amp;&gt; '{[5,10)}'::int8multirange</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anymultirange</type> <literal>-|-</literal> <type>anymultirange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Are the multiranges adjacent?
-->
それらの多重範囲は隣接しているか？
       </para>
       <para>
        <literal>'{[1.1,2.2)}'::nummultirange -|- '{[2.2,3.3)}'::nummultirange</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anymultirange</type> <literal>-|-</literal> <type>anyrange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Is the multirange adjacent to the range?
-->
多重範囲は範囲に連接しているか？
       </para>
       <para>
        <literal>'{[1.1,2.2)}'::nummultirange -|- numrange(2.2,3.3)</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyrange</type> <literal>-|-</literal> <type>anymultirange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Is the range adjacent to the multirange?
-->
範囲は多重範囲に連接しているか？
       </para>
       <para>
        <literal>numrange(1.1,2.2) -|- '{[2.2,3.3)}'::nummultirange</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anymultirange</type> <literal>+</literal> <type>anymultirange</type>
        <returnvalue>anymultirange</returnvalue>
       </para>
       <para>
<!--
        Computes the union of the multiranges.  The multiranges need not overlap
        or be adjacent.
-->
多重範囲の和を計算します。
多重範囲は重なり合っている必要も、隣接している必要もありません。
       </para>
       <para>
        <literal>'{[5,10)}'::nummultirange + '{[15,20)}'::nummultirange</literal>
        <returnvalue>{[5,10), [15,20)}</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anymultirange</type> <literal>*</literal> <type>anymultirange</type>
        <returnvalue>anymultirange</returnvalue>
       </para>
       <para>
<!--
        Computes the intersection of the multiranges.
-->
多重範囲の間の共通部分を計算します。
       </para>
       <para>
        <literal>'{[5,15)}'::int8multirange * '{[10,20)}'::int8multirange</literal>
        <returnvalue>{[10,15)}</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anymultirange</type> <literal>-</literal> <type>anymultirange</type>
        <returnvalue>anymultirange</returnvalue>
       </para>
       <para>
<!--
        Computes the difference of the multiranges.
-->
多重範囲の間の差を計算します。
       </para>
       <para>
        <literal>'{[5,20)}'::int8multirange - '{[10,15)}'::int8multirange</literal>
        <returnvalue>{[5,10), [15,20)}</returnvalue>
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <para>
<!--
   The left-of/right-of/adjacent operators always return false when an empty
   range or multirange is involved; that is, an empty range is not considered to
   be either before or after any other range.
-->
空の範囲あるいは多重範囲が含まれる場合、「左」「右」「隣接」演算子は常に偽を返します。つまり、空の範囲は他の範囲の前でも後ろでもないと見なされます。
  </para>

  <para>
<!--
   Elsewhere empty ranges and multiranges are treated as the additive identity:
   anything unioned with an empty value is itself. Anything minus an empty
   value is itself. An empty multirange has exactly the same points as an empty
   range. Every range contains the empty range. Every multirange contains as many
   empty ranges as you like.
-->
他の場所では、空の範囲と多重範囲は加法単位元として扱われます。
空の値との和は自分自身です。
空の値を引いたものは自分自身です。
空の多重範囲は空の範囲と正確に同じ特徴を持ちます。
すべての範囲は空の範囲を含みます。
すべての多重範囲はいくらでも空の範囲を含むことができます。
  </para>

  <para>
<!--
   The range union and difference operators will fail if the resulting range would
   need to contain two disjoint sub-ranges, as such a range cannot be
   represented. There are separate operators for union and difference that take
   multirange parameters and return a multirange, and they do not fail even if
   their arguments are disjoint. So if you need a union or difference operation
   for ranges that may be disjoint, you can avoid errors by first casting your
   ranges to multiranges.
-->
範囲の和と差演算子は、結果の範囲に2つの隣接しない副範囲が含まれる場合には失敗します。
そのような範囲は表現できないからです。
多重範囲引数を取り、多重範囲を返す別の和と差の演算子があり、引数が隣接していなくても失敗しません。
隣接しないかもしれない範囲の和あるいは差の演算が必要なら、まず範囲を多重範囲にキャストすることによってエラーを避けることができます。
  </para>

  <para>
<!--
   <xref linkend="range-functions-table"/> shows the functions
   available for use with range types.
   <xref linkend="multirange-functions-table"/> shows the functions
   available for use with multirange types.
-->
<xref linkend="range-functions-table"/>に範囲型で利用可能な関数を示します。
<xref linkend="multirange-functions-table"/>に多重範囲型で利用可能な関数を示します。
  </para>

   <table id="range-functions-table">
<!--
    <title>Range Functions</title>
-->
    <title>範囲関数</title>
    <tgroup cols="1">
     <thead>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
<!--
        Function
-->
関数
       </para>
       <para>
<!--
        Description
-->
説明
       </para>
       <para>
<!--
        Example(s)
-->
例
       </para></entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>lower</primary>
        </indexterm>
        <function>lower</function> ( <type>anyrange</type> )
        <returnvalue>anyelement</returnvalue>
       </para>
       <para>
<!--
        Extracts the lower bound of the range (<literal>NULL</literal> if the
        range is empty or has no lower bound).
-->
範囲の下限を取り出します。（範囲が空か下限がない場合<literal>NULL</literal>となります。）
       </para>
       <para>
        <literal>lower(numrange(1.1,2.2))</literal>
        <returnvalue>1.1</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>upper</primary>
        </indexterm>
        <function>upper</function> ( <type>anyrange</type> )
        <returnvalue>anyelement</returnvalue>
       </para>
       <para>
<!--
        Extracts the upper bound of the range (<literal>NULL</literal> if the
        range is empty or has no upper bound).
-->
範囲の上限を取り出します。（範囲が空か上限がない場合は<literal>NULL</literal>となります。）
       </para>
       <para>
        <literal>upper(numrange(1.1,2.2))</literal>
        <returnvalue>2.2</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>isempty</primary>
        </indexterm>
        <function>isempty</function> ( <type>anyrange</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Is the range empty?
-->
範囲は空か？
       </para>
       <para>
        <literal>isempty(numrange(1.1,2.2))</literal>
        <returnvalue>f</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>lower_inc</primary>
        </indexterm>
        <function>lower_inc</function> ( <type>anyrange</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Is the range's lower bound inclusive?
-->
範囲の下限は境界を含むか？
       </para>
       <para>
        <literal>lower_inc(numrange(1.1,2.2))</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>upper_inc</primary>
        </indexterm>
        <function>upper_inc</function> ( <type>anyrange</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Is the range's upper bound inclusive?
-->
範囲の上限は境界を含むか？
       </para>
       <para>
        <literal>upper_inc(numrange(1.1,2.2))</literal>
        <returnvalue>f</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>lower_inf</primary>
        </indexterm>
        <function>lower_inf</function> ( <type>anyrange</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Does the range have no lower bound?  (A lower bound of
        <literal>-Infinity</literal> returns false.)
-->
範囲に下限があるか? （<literal>-Infinity</literal>の下限は偽を返します。）
       </para>
       <para>
        <literal>lower_inf('(,)'::daterange)</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>upper_inf</primary>
        </indexterm>
        <function>upper_inf</function> ( <type>anyrange</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Does the range have no upper bound?  (An upper bound of
        <literal>Infinity</literal> returns false.)
-->
範囲に上限はあるか? （<literal>Infinity</literal>の上限は偽を返します。）
       </para>
       <para>
        <literal>upper_inf('(,)'::daterange)</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>range_merge</primary>
        </indexterm>
        <function>range_merge</function> ( <type>anyrange</type>, <type>anyrange</type> )
        <returnvalue>anyrange</returnvalue>
       </para>
       <para>
<!--
        Computes the smallest range that includes both of the given ranges.
-->
与えられた両方の範囲を含む最小の範囲を計算します。
       </para>
       <para>
        <literal>range_merge('[1,2)'::int4range, '[3,4)'::int4range)</literal>
        <returnvalue>[1,4)</returnvalue>
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <table id="multirange-functions-table">
<!--
    <title>Multirange Functions</title>
-->
    <title>多重範囲関数</title>
    <tgroup cols="1">
     <thead>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
<!--
        Function
-->
関数
       </para>
       <para>
<!--
        Description
-->
説明
       </para>
       <para>
<!--
        Example(s)
-->
例
       </para></entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>lower</primary>
        </indexterm>
        <function>lower</function> ( <type>anymultirange</type> )
        <returnvalue>anyelement</returnvalue>
       </para>
       <para>
<!--
        Extracts the lower bound of the multirange (<literal>NULL</literal> if the
        multirange is empty has no lower bound).
-->
多重範囲の下限を取り出します。（多重範囲が空か下限がない場合は<literal>NULL</literal>となります。）
       </para>
       <para>
        <literal>lower('{[1.1,2.2)}'::nummultirange)</literal>
        <returnvalue>1.1</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>upper</primary>
        </indexterm>
        <function>upper</function> ( <type>anymultirange</type> )
        <returnvalue>anyelement</returnvalue>
       </para>
       <para>
<!--
        Extracts the upper bound of the multirange (<literal>NULL</literal> if the
        multirange is empty or has no upper bound).
-->
多重範囲の上限を取り出します。（多重範囲が空か上限がない場合は<literal>NULL</literal>となります。）
       </para>
       <para>
        <literal>upper('{[1.1,2.2)}'::nummultirange)</literal>
        <returnvalue>2.2</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>isempty</primary>
        </indexterm>
        <function>isempty</function> ( <type>anymultirange</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Is the multirange empty?
-->
多重範囲は空か？
       </para>
       <para>
        <literal>isempty('{[1.1,2.2)}'::nummultirange)</literal>
        <returnvalue>f</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>lower_inc</primary>
        </indexterm>
        <function>lower_inc</function> ( <type>anymultirange</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Is the multirange's lower bound inclusive?
-->
多重範囲の下限は境界を含むか？
       </para>
       <para>
        <literal>lower_inc('{[1.1,2.2)}'::nummultirange)</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>upper_inc</primary>
        </indexterm>
        <function>upper_inc</function> ( <type>anymultirange</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Is the multirange's upper bound inclusive?
-->
多重範囲の上限は境界を含むか？
       </para>
       <para>
        <literal>upper_inc('{[1.1,2.2)}'::nummultirange)</literal>
        <returnvalue>f</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>lower_inf</primary>
        </indexterm>
        <function>lower_inf</function> ( <type>anymultirange</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Does the multirange have no lower bound?  (A lower bound of
        <literal>-Infinity</literal> returns false.)
-->
多重範囲は下限があるか? （<literal>-Infinity</literal>の下限は偽を返します。）
       </para>
       <para>
        <literal>lower_inf('{(,)}'::datemultirange)</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>upper_inf</primary>
        </indexterm>
        <function>upper_inf</function> ( <type>anymultirange</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Does the multirange have no upper bound?  (An upper bound of
        <literal>Infinity</literal> returns false.)
-->
多重範囲は上限があるか? （<literal>Infinity</literal>の上限は偽を返します。）
       </para>
       <para>
        <literal>upper_inf('{(,)}'::datemultirange)</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>range_merge</primary>
        </indexterm>
        <function>range_merge</function> ( <type>anymultirange</type> )
        <returnvalue>anyrange</returnvalue>
       </para>
       <para>
<!--
        Computes the smallest range that includes the entire multirange.
-->
与えられた多重範囲全体を含む最小の範囲を計算します。
       </para>
       <para>
        <literal>range_merge('{[1,2), [3,4)}'::int4multirange)</literal>
        <returnvalue>[1,4)</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>multirange (function)</primary>
        </indexterm>
        <function>multirange</function> ( <type>anyrange</type> )
        <returnvalue>anymultirange</returnvalue>
       </para>
       <para>
<!--
        Returns a multirange containing just the given range.
-->
ちょうど与えられた範囲を含む多重範囲を返す。
       </para>
       <para>
        <literal>multirange('[1,2)'::int4range)</literal>
        <returnvalue>{[1,2)}</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>unnest</primary>
         <secondary>for multirange</secondary>
        </indexterm>
        <function>unnest</function> ( <type>anymultirange</type> )
        <returnvalue>setof anyrange</returnvalue>
       </para>
       <para>
<!--
        Expands a multirange into a set of ranges.
        The ranges are read out in storage order (ascending).
-->
多重範囲を範囲の集合に拡張します。
範囲は格納順で読み出されます（昇順）。
       </para>
       <para>
        <literal>unnest('{[1,2), [3,4)}'::int4multirange)</literal>
        <returnvalue></returnvalue>
<programlisting>
 [1,2)
 [3,4)
</programlisting>
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <para>
<!--
   The <function>lower_inc</function>, <function>upper_inc</function>,
   <function>lower_inf</function>, and <function>upper_inf</function>
   functions all return false for an empty range or multirange.
-->
<function>lower_inc</function>、<function>upper_inc</function>、<function>lower_inf</function>、<function>upper_inf</function>はすべて空の多重範囲に対して偽を返します。
  </para>
  </sect1>

 <sect1 id="functions-aggregate">
<!--
  <title>Aggregate Functions</title>
-->
  <title>集約関数</title>

  <indexterm zone="functions-aggregate">
   <primary>aggregate function</primary>
   <secondary>built-in</secondary>
  </indexterm>
  <indexterm zone="functions-aggregate">
   <primary>集約関数</primary>
   <secondary>組み込み</secondary>
  </indexterm>

  <para>
<!--
   <firstterm>Aggregate functions</firstterm> compute a single result
   from a set of input values.  The built-in general-purpose aggregate
   functions are listed in <xref linkend="functions-aggregate-table"/>
   while statistical aggregates are in <xref
   linkend="functions-aggregate-statistics-table"/>.
   The built-in within-group ordered-set aggregate functions
   are listed in <xref linkend="functions-orderedset-table"/>
   while the built-in within-group hypothetical-set ones are in <xref
   linkend="functions-hypothetical-table"/>.  Grouping operations,
   which are closely related to aggregate functions, are listed in
   <xref linkend="functions-grouping-table"/>.
   The special syntax considerations for aggregate
   functions are explained in <xref linkend="syntax-aggregates"/>.
   Consult <xref linkend="tutorial-agg"/> for additional introductory
   information.
-->
<firstterm>集約関数</firstterm>は入力値の集合から単一の結果を計算します。
<xref linkend="functions-aggregate-table"/>に組み込みの汎用的な集約関数を、<xref linkend="functions-aggregate-statistics-table"/>に統計集約関数を示します。
<xref linkend="functions-orderedset-table"/>には組み込みのグループ内順序集合集約関数を、一方<xref linkend="functions-hypothetical-table"/>には組み込みのグループ内仮想集合用の順序集約関数を示します。
<xref linkend="functions-grouping-table"/>には、集約関数と密接に関係するグループ化演算を示します。
集約関数の特殊な構文に関する考察は<xref linkend="syntax-aggregates"/>で説明されています。
また、初歩的な情報については<xref linkend="tutorial-agg"/>を参照して下さい。
  </para>

  <para>
<!--
   Aggregate functions that support <firstterm>Partial Mode</firstterm>
   are eligible to participate in various optimizations, such as parallel
   aggregation.
-->
<firstterm>部分モード</firstterm>をサポートする集約関数は並列集約など、様々な最適化に有用です。
  </para>

   <table id="functions-aggregate-table">
<!--
    <title>General-Purpose Aggregate Functions</title>
-->
    <title>汎用集約関数</title>
    <tgroup cols="2">
     <colspec colname="col1" colwidth="10*"/>
     <colspec colname="col2" colwidth="1*"/>
     <thead>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
<!--
        Function
-->
関数
       </para>
       <para>
<!--
        Description
-->
説明
       </para></entry>
<!--
       <entry>Partial Mode</entry>
-->
       <entry>部分モード</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>any_value</primary>
        </indexterm>
        <function>any_value</function> ( <type>anyelement</type> )
        <returnvalue><replaceable>same as input type</replaceable></returnvalue>
       </para>
       <para>
<!--
        Returns an arbitrary value from the non-null input values.
-->
NULL以外の入力値から任意の値を返します。
       </para></entry>
<!--
       <entry>Yes</entry>
-->
       <entry>可</entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_agg</primary>
        </indexterm>
        <function>array_agg</function> ( <type>anynonarray</type> )
        <returnvalue>anyarray</returnvalue>
       </para>
       <para>
<!--
        Collects all the input values, including nulls, into an array.
-->
NULLも含めてすべての入力値を収集して配列に格納します。
       </para></entry>
<!--
       <entry>Yes</entry>
-->
       <entry>可</entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>array_agg</function> ( <type>anyarray</type> )
        <returnvalue>anyarray</returnvalue>
       </para>
       <para>
<!--
        Concatenates all the input arrays into an array of one higher
        dimension.  (The inputs must all have the same dimensionality, and
        cannot be empty or null.)
-->
すべての入力配列を結合して次元が1高い配列に格納します。
（入力配列はすべて同じ次元数を持ち、空もしくはNULLであってはいけません。）
       </para></entry>
<!--
       <entry>Yes</entry>
-->
       <entry>可</entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>average</primary>
        </indexterm>
        <indexterm>
         <primary>avg</primary>
        </indexterm>
        <function>avg</function> ( <type>smallint</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>avg</function> ( <type>integer</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>avg</function> ( <type>bigint</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>avg</function> ( <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>avg</function> ( <type>real</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para role="func_signature">
        <function>avg</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para role="func_signature">
        <function>avg</function> ( <type>interval</type> )
        <returnvalue>interval</returnvalue>
       </para>
       <para>
<!--
        Computes the average (arithmetic mean) of all the non-null input
        values.
-->
すべての非NULL入力値の平均（算術平均）を計算します。
       </para></entry>
<!--
       <entry>Yes</entry>
-->
       <entry>可</entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>bit_and</primary>
        </indexterm>
        <function>bit_and</function> ( <type>smallint</type> )
        <returnvalue>smallint</returnvalue>
       </para>
       <para role="func_signature">
        <function>bit_and</function> ( <type>integer</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para role="func_signature">
        <function>bit_and</function> ( <type>bigint</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para role="func_signature">
        <function>bit_and</function> ( <type>bit</type> )
        <returnvalue>bit</returnvalue>
       </para>
       <para>
<!--
        Computes the bitwise AND of all non-null input values.
-->
全ての非NULLの入力値のビット積を計算します。
       </para></entry>
<!--
       <entry>Yes</entry>
-->
       <entry>可</entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>bit_or</primary>
        </indexterm>
        <function>bit_or</function> ( <type>smallint</type> )
        <returnvalue>smallint</returnvalue>
       </para>
       <para role="func_signature">
        <function>bit_or</function> ( <type>integer</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para role="func_signature">
        <function>bit_or</function> ( <type>bigint</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para role="func_signature">
        <function>bit_or</function> ( <type>bit</type> )
        <returnvalue>bit</returnvalue>
       </para>
       <para>
<!--
        Computes the bitwise OR of all non-null input values.
-->
全ての非NULLの入力値のビット和を計算します。
       </para></entry>
<!--
       <entry>Yes</entry>
-->
       <entry>可</entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>bit_xor</primary>
        </indexterm>
        <function>bit_xor</function> ( <type>smallint</type> )
        <returnvalue>smallint</returnvalue>
       </para>
       <para role="func_signature">
        <function>bit_xor</function> ( <type>integer</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para role="func_signature">
        <function>bit_xor</function> ( <type>bigint</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para role="func_signature">
        <function>bit_xor</function> ( <type>bit</type> )
        <returnvalue>bit</returnvalue>
       </para>
       <para>
<!--
        Computes the bitwise exclusive OR of all non-null input values.
        Can be useful as a checksum for an unordered set of values.
-->
すべての非NULL入力値のビット毎の排他的論理和を計算します。
順序付けられない値の集合のチェックサムとして有用かもしれません。
       </para></entry>
<!--
       <entry>Yes</entry>
-->
       <entry>可</entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>bool_and</primary>
        </indexterm>
        <function>bool_and</function> ( <type>boolean</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Returns true if all non-null input values are true, otherwise false.
-->
全ての入力が真ならば真、そうでなければ偽を返します。
       </para></entry>
<!--
       <entry>Yes</entry>
-->
       <entry>可</entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>bool_or</primary>
        </indexterm>
        <function>bool_or</function> ( <type>boolean</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Returns true if any non-null input value is true, otherwise false.
-->
入力のどれかが真ならば真、そうでなければ偽を返します。
       </para></entry>
<!--
       <entry>Yes</entry>
-->
       <entry>可</entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>count</primary>
        </indexterm>
        <function>count</function> ( <literal>*</literal> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
<!--
        Computes the number of input rows.
-->
入力行数を返します。
       </para></entry>
<!--
       <entry>Yes</entry>
-->
       <entry>可</entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>count</function> ( <type>"any"</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
<!--
        Computes the number of input rows in which the input value is not
        null.
-->
非NULLの入力行数を返します。
       </para></entry>
<!--
       <entry>Yes</entry>
-->
       <entry>可</entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>every</primary>
        </indexterm>
        <function>every</function> ( <type>boolean</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        This is the SQL standard's equivalent to <function>bool_and</function>.
-->
これは標準SQLの<function>bool_and</function>と等価です。
       </para></entry>
<!--
       <entry>Yes</entry>
-->
       <entry>可</entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_agg</primary>
        </indexterm>
        <function>json_agg</function> ( <type>anyelement</type> )
        <returnvalue>json</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_agg</primary>
        </indexterm>
        <function>jsonb_agg</function> ( <type>anyelement</type> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
<!--
        Collects all the input values, including nulls, into a JSON array.
        Values are converted to JSON as per <function>to_json</function>
        or <function>to_jsonb</function>.
-->
NULLも含めてすべての入力値を収集し、JSON配列に格納します。
入力は<function>to_json</function>あるいは<function>to_jsonb</function>でJSONに変換されます。
       </para></entry>
<!--
       <entry>No</entry>
-->
       <entry>非</entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
         <indexterm><primary>json_objectagg</primary></indexterm>
         <function>json_objectagg</function> (
         <optional> { <replaceable>key_expression</replaceable> { <literal>VALUE</literal> | ':' } <replaceable>value_expression</replaceable> } </optional>
         <optional> { <literal>NULL</literal> | <literal>ABSENT</literal> } <literal>ON NULL</literal> </optional>
        <optional> { <literal>WITH</literal> | <literal>WITHOUT</literal> } <literal>UNIQUE</literal> <optional> <literal>KEYS</literal> </optional> </optional>
        <optional> <literal>RETURNING</literal> <replaceable>data_type</replaceable> <optional> <literal>FORMAT JSON</literal> <optional> <literal>ENCODING UTF8</literal> </optional> </optional> </optional>)
        </para>
        <para>
<!--
         Behaves like <function>json_object</function><!&#45;- xref &#45;->, but as an
         aggregate function, so it only takes one
         <replaceable>key_expression</replaceable> and one
         <replaceable>value_expression</replaceable> parameter.
-->
<function>json_object</function><!-- xref -->のように動作しますが、集約関数として動作するため、1つの<replaceable>key_expression</replaceable>と1つの<replaceable>value_expression</replaceable>引数のみを使用します。
        </para>
        <para>
         <literal>SELECT json_objectagg(k:v) FROM (VALUES ('a'::text,current_date),('b',current_date + 1)) AS t(k,v)</literal>
         <returnvalue>{ "a" : "2022-05-10", "b" : "2022-05-11" }</returnvalue>
       </para></entry>
<!--
       <entry>No</entry>
-->
       <entry>非</entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_object_agg</primary>
        </indexterm>
        <function>json_object_agg</function> ( <parameter>key</parameter>
         <type>"any"</type>, <parameter>value</parameter>
         <type>"any"</type> )
        <returnvalue>json</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_object_agg</primary>
        </indexterm>
        <function>jsonb_object_agg</function> ( <parameter>key</parameter>
         <type>"any"</type>, <parameter>value</parameter>
         <type>"any"</type> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
<!--
        Collects all the key/value pairs into a JSON object.  Key arguments
        are coerced to text; value arguments are converted as per
        <function>to_json</function> or <function>to_jsonb</function>.
        Values can be null, but keys cannot.
-->
すべてのキー／値ペアをJSONオブジェクトに格納します。
キー引数はテキストに変換されます。値引数は<function>to_json</function>あるいは<function>to_jsonb</function>にしたがって変換されます。
値はNULLでも構いませんが、キーはNULLにはできません。
       </para></entry>
<!--
       <entry>No</entry>
-->
       <entry>非</entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_object_agg_strict</primary>
        </indexterm>
        <function>json_object_agg_strict</function> (
         <parameter>key</parameter> <type>"any"</type>,
         <parameter>value</parameter> <type>"any"</type> )
        <returnvalue>json</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_object_agg_strict</primary>
        </indexterm>
        <function>jsonb_object_agg_strict</function> (
         <parameter>key</parameter> <type>"any"</type>,
         <parameter>value</parameter> <type>"any"</type> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
<!--
        Collects all the key/value pairs into a JSON object.  Key arguments
        are coerced to text; value arguments are converted as per
        <function>to_json</function> or <function>to_jsonb</function>.
        The <parameter>key</parameter> can not be null. If the
        <parameter>value</parameter> is null then the entry is skipped,
-->
すべてのキー／値ペアをJSONオブジェクトに格納します。
キー引数はテキストに変換されます。値は<function>to_json</function>あるいは<function>to_jsonb</function>にしたがって変換されます。
<parameter>key</parameter>はNULLにはできません。
<parameter>value</parameter>がNULLなら、そのエントリはスキップされます。
       </para></entry>
<!--
       <entry>No</entry>
-->
       <entry>非</entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_object_agg_unique</primary>
        </indexterm>
        <function>json_object_agg_unique</function> (
         <parameter>key</parameter> <type>"any"</type>,
         <parameter>value</parameter> <type>"any"</type> )
        <returnvalue>json</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_object_agg_unique</primary>
        </indexterm>
        <function>jsonb_object_agg_unique</function> (
         <parameter>key</parameter> <type>"any"</type>,
         <parameter>value</parameter> <type>"any"</type> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
<!--
        Collects all the key/value pairs into a JSON object.  Key arguments
        are coerced to text; value arguments are converted as per
        <function>to_json</function> or <function>to_jsonb</function>.
        Values can be null, but keys cannot.
        If there is a duplicate key an error is thrown.
-->
すべてのキー／値ペアをJSONオブジェクトに格納します。
キー引数はテキストに変換されます。値は<function>to_json</function>あるいは<function>to_jsonb</function>にしたがって変換されます。
値はNULLでも構いませんが、キーはNULLにはできません。
重複キーがある場合、エラーが発生します。
       </para></entry>
<!--
       <entry>No</entry>
-->
       <entry>非</entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm><primary>json_arrayagg</primary></indexterm>
        <function>json_arrayagg</function> (
        <optional> <replaceable>value_expression</replaceable> </optional>
        <optional> <literal>ORDER BY</literal> <replaceable>sort_expression</replaceable> </optional>
        <optional> { <literal>NULL</literal> | <literal>ABSENT</literal> } <literal>ON NULL</literal> </optional>
        <optional> <literal>RETURNING</literal> <replaceable>data_type</replaceable> <optional> <literal>FORMAT JSON</literal> <optional> <literal>ENCODING UTF8</literal> </optional> </optional> </optional>)
       </para>
       <para>
<!--
        Behaves in the same way as <function>json_array</function>
        but as an aggregate function so it only takes one
        <replaceable>value_expression</replaceable> parameter.
        If <literal>ABSENT ON NULL</literal> is specified, any NULL
        values are omitted.
        If <literal>ORDER BY</literal> is specified, the elements will
        appear in the array in that order rather than in the input order.
-->
<function>json_array</function>と同じように動作しますが、集約関数として動作するため、1つの<replaceable>value_expression</replaceable>パラメータのみを使用します。
<literal>ABSENT ON NULL</literal>が指定されている場合、NULL値は無視されます。
<literal>ORDER BY</literal>が指定されている場合、要素は入力順ではなく、配列の順に表示されます。
       </para>
       <para>
        <literal>SELECT json_arrayagg(v) FROM (VALUES(2),(1)) t(v)</literal>
        <returnvalue>[2, 1]</returnvalue>
       </para></entry>
<!--
       <entry>No</entry>
-->
       <entry>非</entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_object_agg_unique_strict</primary>
        </indexterm>
        <function>json_object_agg_unique_strict</function> (
         <parameter>key</parameter> <type>"any"</type>,
         <parameter>value</parameter> <type>"any"</type> )
        <returnvalue>json</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_object_agg_unique_strict</primary>
        </indexterm>
        <function>jsonb_object_agg_unique_strict</function> (
         <parameter>key</parameter> <type>"any"</type>,
         <parameter>value</parameter> <type>"any"</type> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
<!--
        Collects all the key/value pairs into a JSON object.  Key arguments
        are coerced to text; value arguments are converted as per
        <function>to_json</function> or <function>to_jsonb</function>.
        The <parameter>key</parameter> can not be null. If the
        <parameter>value</parameter> is null then the entry is skipped.
        If there is a duplicate key an error is thrown.
-->
すべてのキー／値ペアをJSONオブジェクトに格納します。
キー引数はテキストに変換されます。値は<function>to_json</function>あるいは<function>to_jsonb</function>にしたがって変換されます。
<parameter>key</parameter>はNULLにはできません。
<parameter>value</parameter>がNULLなら、そのエントリはスキップされます。
重複キーがある場合、エラーが発生します。
       </para></entry>
<!--
       <entry>No</entry>
-->
       <entry>非</entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>max</primary>
        </indexterm>
        <function>max</function> ( <replaceable>see text</replaceable> )
        <returnvalue><replaceable>same as input type</replaceable></returnvalue>
       </para>
       <para>
<!--
        Computes the maximum of the non-null input
        values.  Available for any numeric, string, date/time, or enum type,
        as well as <type>inet</type>, <type>interval</type>,
        <type>money</type>, <type>oid</type>, <type>pg_lsn</type>,
        <type>tid</type>, <type>xid8</type>,
        and arrays of any of these types.
-->
非NULL入力値の最大を計算します。
数値、文字列、日時、列挙型および<type>inet</type>、<type>interval</type>、<type>money</type>、<type>oid</type>、<type>pg_lsn</type>、<type>tid</type>、<type>xid8</type>、およびこれらすべての配列でも同様に利用できます。
       </para></entry>
<!--
       <entry>Yes</entry>
-->
       <entry>可</entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>min</primary>
        </indexterm>
        <function>min</function> ( <replaceable>see text</replaceable> )
        <returnvalue><replaceable>same as input type</replaceable></returnvalue>
       </para>
       <para>
<!--
        Computes the minimum of the non-null input
        values.  Available for any numeric, string, date/time, or enum type,
        as well as <type>inet</type>, <type>interval</type>,
        <type>money</type>, <type>oid</type>, <type>pg_lsn</type>,
        <type>tid</type>, <type>xid8</type>,
        and arrays of any of these types.
-->
非NULL入力値の最小を計算します。
数値、文字列、日時、列挙型および<type>inet</type>、<type>interval</type>、<type>money</type>、<type>oid</type>、<type>pg_lsn</type>、<type>tid</type>、<type>xid8</type>、およびこれらすべての配列でも同様に利用できます。
       </para></entry>
<!--
       <entry>Yes</entry>
-->
       <entry>可</entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>range_agg</primary>
        </indexterm>
        <function>range_agg</function> ( <parameter>value</parameter>
         <type>anyrange</type> )
        <returnvalue>anymultirange</returnvalue>
       </para>
       <para role="func_signature">
        <function>range_agg</function> ( <parameter>value</parameter>
         <type>anymultirange</type> )
        <returnvalue>anymultirange</returnvalue>
       </para>
       <para>
<!--
        Computes the union of the non-null input values.
-->
非NULL入力の和を計算します。
       </para></entry>
<!--
       <entry>No</entry>
-->
       <entry>非</entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>range_intersect_agg</primary>
        </indexterm>
        <function>range_intersect_agg</function> ( <parameter>value</parameter>
         <type>anyrange</type> )
        <returnvalue>anyrange</returnvalue>
       </para>
       <para role="func_signature">
        <function>range_intersect_agg</function> ( <parameter>value</parameter>
         <type>anymultirange</type> )
        <returnvalue>anymultirange</returnvalue>
       </para>
       <para>
<!--
        Computes the intersection of the non-null input values.
-->
非NULL入力の共通部分を計算します。
       </para></entry>
<!--
       <entry>No</entry>
-->
       <entry>非</entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_agg_strict</primary>
        </indexterm>
        <function>json_agg_strict</function> ( <type>anyelement</type> )
        <returnvalue>json</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_agg_strict</primary>
        </indexterm>
        <function>jsonb_agg_strict</function> ( <type>anyelement</type> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
<!--
        Collects all the input values, skipping nulls, into a JSON array.
        Values are converted to JSON as per <function>to_json</function>
        or <function>to_jsonb</function>.
-->
NULLをスキップして、すべての入力値をJSON配列に収集します。
値は<function>to_JSON</function>または<function>to_JSON</function>に従ってjsonbに変換されます。
       </para></entry>
<!--
       <entry>No</entry>
-->
       <entry>非</entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>string_agg</primary>
        </indexterm>
        <function>string_agg</function> ( <parameter>value</parameter>
         <type>text</type>, <parameter>delimiter</parameter> <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para role="func_signature">
        <function>string_agg</function> ( <parameter>value</parameter>
         <type>bytea</type>, <parameter>delimiter</parameter> <type>bytea</type> )
        <returnvalue>bytea</returnvalue>
       </para>
       <para>
<!--
        Concatenates the non-null input values into a string.  Each value
        after the first is preceded by the
        corresponding <parameter>delimiter</parameter> (if it's not null).
-->
非NULL入力を結合して文字列に格納します。
最初の値以降、各値の前に<parameter>delimiter</parameter>で指定した値が（NULLでなければ）追加されます。
       </para></entry>
<!--
       <entry>Yes</entry>
-->
       <entry>可</entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>sum</primary>
        </indexterm>
        <function>sum</function> ( <type>smallint</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para role="func_signature">
        <function>sum</function> ( <type>integer</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para role="func_signature">
        <function>sum</function> ( <type>bigint</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>sum</function> ( <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>sum</function> ( <type>real</type> )
        <returnvalue>real</returnvalue>
       </para>
       <para role="func_signature">
        <function>sum</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para role="func_signature">
        <function>sum</function> ( <type>interval</type> )
        <returnvalue>interval</returnvalue>
       </para>
       <para role="func_signature">
        <function>sum</function> ( <type>money</type> )
        <returnvalue>money</returnvalue>
       </para>
       <para>
<!--
        Computes the sum of the non-null input values.
-->
非NULL入力値の合計を計算します。
       </para></entry>
<!--
       <entry>Yes</entry>
-->
       <entry>可</entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>xmlagg</primary>
        </indexterm>
        <function>xmlagg</function> ( <type>xml</type> )
        <returnvalue>xml</returnvalue>
       </para>
       <para>
<!--
        Concatenates the non-null XML input values (see
        <xref linkend="functions-xml-xmlagg"/>).
-->
非NULLのXML入力値を結合します。（<xref linkend="functions-xml-xmlagg"/>参照。）
       </para></entry>
<!--
       <entry>No</entry>
-->
       <entry>非</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <para>
<!--
   It should be noted that except for <function>count</function>,
   these functions return a null value when no rows are selected.  In
   particular, <function>sum</function> of no rows returns null, not
   zero as one might expect, and <function>array_agg</function>
   returns null rather than an empty array when there are no input
   rows.  The <function>coalesce</function> function can be used to
   substitute zero or an empty array for null when necessary.
-->
上記の関数は、<function>count</function>関数を除き、1行も選択されなかった場合NULL値を返すことに注意してください。
特に、行の選択がない<function>sum</function>関数は、予想されるであろうゼロではなくNULLを返し、そして<function>array_agg</function>は、入力行が存在しない場合に、空配列ではなくNULLを返します。
必要であれば、NULLをゼロまたは空配列と置換する目的で<function>coalesce</function>関数を使うことができます。
  </para>

  <para>
<!--
   The aggregate functions <function>array_agg</function>,
   <function>json_agg</function>, <function>jsonb_agg</function>,
   <function>json_agg_strict</function>, <function>jsonb_agg_strict</function>,
   <function>json_object_agg</function>, <function>jsonb_object_agg</function>,
   <function>json_object_agg_strict</function>, <function>jsonb_object_agg_strict</function>,
   <function>json_object_agg_unique</function>, <function>jsonb_object_agg_unique</function>,
   <function>json_object_agg_unique_strict</function>,
   <function>jsonb_object_agg_unique_strict</function>,
   <function>string_agg</function>,
   and <function>xmlagg</function>, as well as similar user-defined
   aggregate functions, produce meaningfully different result values
   depending on the order of the input values.  This ordering is
   unspecified by default, but can be controlled by writing an
   <literal>ORDER BY</literal> clause within the aggregate call, as shown in
   <xref linkend="syntax-aggregates"/>.
   Alternatively, supplying the input values from a sorted subquery
   will usually work.  For example:
-->
集約関数<function>array_agg</function>、<function>json_agg</function>、<function>jsonb_agg</function>、<function>json_agg_strict</function>、<function>jsonb_agg_strict</function>、<function>json_object_agg</function>、<function>jsonb_object_agg</function>、<function>json_object_agg_strict</function>、<function>jsonb_object_agg_strict</function>、<function>json_object_agg_unique</function>、<function>jsonb_object_agg_unique</function>、<function>json_object_agg_unique_strict</function>、<function>jsonb_object_agg_unique_strict</function>、<function>string_agg</function>、および<function>xmlagg</function>、そして類似のユーザ定義の集約関数は、入力値の順序に依存した意味のある別の結果値を生成します。
この並び順はデフォルトでは指定されませんが、<xref linkend="syntax-aggregates"/>に記述されているように、集計呼び出し中に<literal>ORDER BY</literal>句を書くことで制御可能となります。別の方法として、並べ替えられた副問い合わせから入力値を供給することでも上手くいきます。
例をあげます。

<screen><![CDATA[
SELECT xmlagg(x) FROM (SELECT x FROM test ORDER BY y DESC) AS tab;
]]></screen>

<!--
   Beware that this approach can fail if the outer query level contains
   additional processing, such as a join, because that might cause the
   subquery's output to be reordered before the aggregate is computed.
-->
外側の問い合わせのレベルで結合などの追加処理がある場合、この方法は失敗するかもしれないことに注意して下さい。
なぜなら、集約の計算の前に副問い合わせの出力を並べ替える必要があるかも知れないからです。
  </para>

  <note>
    <indexterm>
      <primary>ANY</primary>
    </indexterm>
    <indexterm>
      <primary>SOME</primary>
    </indexterm>
    <para>
<!--
      The boolean aggregates <function>bool_and</function> and
      <function>bool_or</function> correspond to the standard SQL aggregates
      <function>every</function> and <function>any</function> or
      <function>some</function>.
      <productname>PostgreSQL</productname>
      supports <function>every</function>, but not <function>any</function>
      or <function>some</function>, because there is an ambiguity built into
      the standard syntax:
-->
<function>bool_and</function>、<function>bool_or</function>論理集約関数は標準SQLの集約関数<function>every</function>、<function>any</function>または<function>some</function>に対応します。
<productname>PostgreSQL</productname>は<function>every</function>をサポートしますが、<function>any</function>、あるいは<function>some</function>はサポートしません。
<function>any</function>と<function>some</function>の標準の構文には曖昧さがあるからです。
<programlisting>
SELECT b1 = ANY((SELECT b2 FROM t2 ...)) FROM t1 ...;
</programlisting>
<!--
      Here <function>ANY</function> can be considered either as introducing
      a subquery, or as being an aggregate function, if the subquery
      returns one row with a Boolean value.
      Thus the standard name cannot be given to these aggregates.
-->
ここで、副問い合わせが論理値での１行を返す場合、<function>ANY</function>は副問い合わせを導入するもの、もしくは集約関数であるものいずれかとみなすことができます。
従って、これらの集約関数に標準の名前を付けることはできません。
    </para>
  </note>

  <note>
   <para>
<!--
    Users accustomed to working with other SQL database management
    systems might be disappointed by the performance of the
    <function>count</function> aggregate when it is applied to the
    entire table. A query like:
-->
他のSQLデータベース管理システムでの作業に親しんだユーザは、<function>count</function>集約関数がテーブル全体に適用される場合の性能に失望するかも知れません。
次のような問い合わせ：
<programlisting>
SELECT count(*) FROM sometable;
</programlisting>
<!--
    will require effort proportional to the size of the table:
    <productname>PostgreSQL</productname> will need to scan either the
    entire table or the entirety of an index that includes all rows in
    the table.
-->
はテーブルサイズに比例した労力が必要です。
<productname>PostgreSQL</productname>はテーブル全体か、そのテーブルの全ての行を含んだインデックス全体のスキャンを必要とします。
   </para>
  </note>

  <para>
<!--
   <xref linkend="functions-aggregate-statistics-table"/> shows
   aggregate functions typically used in statistical analysis.
   (These are separated out merely to avoid cluttering the listing
   of more-commonly-used aggregates.)  Functions shown as
   accepting <replaceable>numeric_type</replaceable> are available for all
   the types <type>smallint</type>, <type>integer</type>,
   <type>bigint</type>, <type>numeric</type>, <type>real</type>,
   and <type>double precision</type>.
   Where the description mentions
   <parameter>N</parameter>, it means the
   number of input rows for which all the input expressions are non-null.
   In all cases, null is returned if the computation is meaningless,
   for example when <parameter>N</parameter> is zero.
-->
統計解析処理によく使用される集約関数を<xref linkend="functions-aggregate-statistics-table"/>に示します。
（これらは、より一般的に使用される集約関数との混乱を防ぐために別出ししました。）
<replaceable>numeric_type</replaceable>を受け付けると表示されている関数は、<type>smallint</type>、<type>integer</type>、<type>bigint</type>、<type>numeric</type>、<type>real</type>、<type>double precision</type>のすべての型で利用可能です。
説明の部分における<parameter>N</parameter>は、すべての入力式が非NULLの入力行の個数を表します。
すべての場合にて、例えば<parameter>N</parameter>が0の時など計算が無意味である場合にはNULLが返されます。
  </para>

  <indexterm>
   <primary>statistics</primary>
  </indexterm>
  <indexterm>
   <primary>linear regression</primary>
  </indexterm>

   <table id="functions-aggregate-statistics-table">
<!--
    <title>Aggregate Functions for Statistics</title>
-->
    <title>統計処理用の集約関数</title>
    <tgroup cols="2">
     <colspec colname="col1" colwidth="10*"/>
     <colspec colname="col2" colwidth="1*"/>
     <thead>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
<!--
        Function
-->
関数
       </para>
       <para>
<!--
        Description
-->
説明
       </para></entry>
<!--
       <entry>Partial Mode</entry>
-->
       <entry>部分モード</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>correlation</primary>
        </indexterm>
        <indexterm>
         <primary>相関</primary>
        </indexterm>
        <indexterm>
         <primary>corr</primary>
        </indexterm>
        <function>corr</function> ( <parameter>Y</parameter> <type>double precision</type>, <parameter>X</parameter> <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
<!--
        Computes the correlation coefficient.
-->
相関係数を計算します。
       </para></entry>
<!--
       <entry>Yes</entry>
-->
       <entry>可</entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>covariance</primary>
         <secondary>population</secondary>
        </indexterm>
        <indexterm>
         <primary>共分散</primary>
         <secondary>母集団</secondary>
        </indexterm>
        <indexterm>
         <primary>covar_pop</primary>
        </indexterm>
        <function>covar_pop</function> ( <parameter>Y</parameter> <type>double precision</type>, <parameter>X</parameter> <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
<!--
        Computes the population covariance.
-->
母共分散を計算します。
       </para></entry>
<!--
       <entry>Yes</entry>
-->
       <entry>可</entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>covariance</primary>
         <secondary>sample</secondary>
        </indexterm>
        <indexterm>
         <primary>共分散</primary>
         <secondary>標本</secondary>
        </indexterm>
        <indexterm>
         <primary>covar_samp</primary>
        </indexterm>
        <function>covar_samp</function> ( <parameter>Y</parameter> <type>double precision</type>, <parameter>X</parameter> <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
<!--
        Computes the sample covariance.
-->
標本の共分散を計算します。
       </para></entry>
<!--
       <entry>Yes</entry>
-->
       <entry>可</entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>regr_avgx</primary>
        </indexterm>
        <function>regr_avgx</function> ( <parameter>Y</parameter> <type>double precision</type>, <parameter>X</parameter> <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
<!--
        Computes the average of the independent variable,
        <literal>sum(<parameter>X</parameter>)/<parameter>N</parameter></literal>.
-->
独立変数の平均値を計算します。
        <literal>sum(<parameter>X</parameter>)/<parameter>N</parameter></literal>.
       </para></entry>
<!--
       <entry>Yes</entry>
-->
       <entry>可</entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>regr_avgy</primary>
        </indexterm>
        <function>regr_avgy</function> ( <parameter>Y</parameter> <type>double precision</type>, <parameter>X</parameter> <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
<!--
        Computes the average of the dependent variable,
        <literal>sum(<parameter>Y</parameter>)/<parameter>N</parameter></literal>.
-->
従属変数の平均値を計算します。
        <literal>sum(<parameter>Y</parameter>)/<parameter>N</parameter></literal>.
       </para></entry>
<!--
       <entry>Yes</entry>
-->
       <entry>可</entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>regr_count</primary>
        </indexterm>
        <function>regr_count</function> ( <parameter>Y</parameter> <type>double precision</type>, <parameter>X</parameter> <type>double precision</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
<!--
        Computes the number of rows in which both inputs are non-null.
-->
両方の入力が非NULLとなる行数を計算します。
       </para></entry>
<!--
       <entry>Yes</entry>
-->
       <entry>可</entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>regression intercept</primary>
        </indexterm>
        <indexterm>
         <primary>回帰切片</primary>
        </indexterm>
        <indexterm>
         <primary>regr_intercept</primary>
        </indexterm>
        <function>regr_intercept</function> ( <parameter>Y</parameter> <type>double precision</type>, <parameter>X</parameter> <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
<!--
        Computes the y-intercept of the least-squares-fit linear equation
        determined by the
        (<parameter>X</parameter>, <parameter>Y</parameter>) pairs.
-->
(<parameter>X</parameter>, <parameter>Y</parameter>)の組み合わせで決まる、最小二乗法による線形方程式のY切片を計算します。
       </para></entry>
<!--
       <entry>Yes</entry>
-->
       <entry>可</entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>regr_r2</primary>
        </indexterm>
        <function>regr_r2</function> ( <parameter>Y</parameter> <type>double precision</type>, <parameter>X</parameter> <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
<!--
        Computes the square of the correlation coefficient.
-->
相関係数の二乗を計算します。
       </para></entry>
<!--
       <entry>Yes</entry>
-->
       <entry>可</entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>regression slope</primary>
        </indexterm>
        <indexterm>
         <primary>回帰勾配</primary>
        </indexterm>
        <indexterm>
         <primary>regr_slope</primary>
        </indexterm>
        <function>regr_slope</function> ( <parameter>Y</parameter> <type>double precision</type>, <parameter>X</parameter> <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
<!--
        Computes the slope of the least-squares-fit linear equation determined
        by the (<parameter>X</parameter>, <parameter>Y</parameter>)
        pairs.
-->
(<parameter>X</parameter>, <parameter>Y</parameter>)の組み合わせで決まる、最小二乗法による線型方程式の勾配を計算します。
       </para></entry>
<!--
       <entry>Yes</entry>
-->
       <entry>可</entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>regr_sxx</primary>
        </indexterm>
        <function>regr_sxx</function> ( <parameter>Y</parameter> <type>double precision</type>, <parameter>X</parameter> <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
<!--
        Computes the <quote>sum of squares</quote> of the independent
        variable,
        <literal>sum(<parameter>X</parameter>^2) - sum(<parameter>X</parameter>)^2/<parameter>N</parameter></literal>.
-->
独立変数の<quote>二乗和</quote>、<literal>sum(<parameter>X</parameter>^2) - sum(<parameter>X</parameter>)^2/<parameter>N</parameter></literal>を計算します。
       </para></entry>
<!--
       <entry>Yes</entry>
-->
       <entry>可</entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>regr_sxy</primary>
        </indexterm>
        <function>regr_sxy</function> ( <parameter>Y</parameter> <type>double precision</type>, <parameter>X</parameter> <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
<!--
        Computes the <quote>sum of products</quote> of independent times
        dependent variables,
        <literal>sum(<parameter>X</parameter>*<parameter>Y</parameter>) - sum(<parameter>X</parameter>) * sum(<parameter>Y</parameter>)/<parameter>N</parameter></literal>.
-->
独立変数と従属変数の<quote>積の和</quote>、<literal>sum(<parameter>X</parameter>*<parameter>Y</parameter>) - sum(<parameter>X</parameter>) * sum(<parameter>Y</parameter>)/<parameter>N</parameter></literal>を計算します。
       </para></entry>
<!--
       <entry>Yes</entry>
-->
       <entry>可</entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>regr_syy</primary>
        </indexterm>
        <function>regr_syy</function> ( <parameter>Y</parameter> <type>double precision</type>, <parameter>X</parameter> <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
<!--
        Computes the <quote>sum of squares</quote> of the dependent
        variable,
        <literal>sum(<parameter>Y</parameter>^2) - sum(<parameter>Y</parameter>)^2/<parameter>N</parameter></literal>.
-->
従属変数の<quote>積の和</quote>、<literal>sum(<parameter>Y</parameter>^2) - sum(<parameter>Y</parameter>)^2/<parameter>N</parameter></literal>を計算します。
       </para></entry>
<!--
       <entry>Yes</entry>
-->
       <entry>可</entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>standard deviation</primary>
        </indexterm>
        <indexterm>
         <primary>標準偏差</primary>
        </indexterm>
        <indexterm>
         <primary>stddev</primary>
        </indexterm>
        <function>stddev</function> ( <replaceable>numeric_type</replaceable> )
<!--
        <returnvalue></returnvalue> <type>double precision</type>
        for <type>real</type> or <type>double precision</type>,
        otherwise <type>numeric</type>
-->
        <returnvalue></returnvalue> 引数が<type>double precision</type>あるいは<type>real</type>に対しては<type>double precision</type>、それ以外は<type>numeric</type>
       </para>
       <para>
<!--
        This is a historical alias for <function>stddev_samp</function>.
-->
これは<function>stddev_samp</function>の歴史的な別名です。
       </para></entry>
<!--
       <entry>Yes</entry>
-->
       <entry>可</entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>standard deviation</primary>
         <secondary>population</secondary>
        </indexterm>
        <indexterm>
         <primary>標準偏差</primary>
         <secondary>母集団</secondary>
        </indexterm>
        <indexterm>
         <primary>stddev_pop</primary>
        </indexterm>
        <function>stddev_pop</function> ( <replaceable>numeric_type</replaceable> )
<!--
        <returnvalue></returnvalue> <type>double precision</type>
        for <type>real</type> or <type>double precision</type>,
        otherwise <type>numeric</type>
-->
        <returnvalue></returnvalue> 引数が<type>double precision</type>あるいは<type>real</type>に対しては<type>double precision</type>、それ以外は<type>numeric</type>
       </para>
       <para>
<!--
        Computes the population standard deviation of the input values.
-->
入力値の母標準偏差を計算します。
       </para></entry>
<!--
       <entry>Yes</entry>
-->
       <entry>可</entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>standard deviation</primary>
         <secondary>sample</secondary>
        </indexterm>
        <indexterm>
         <primary>標準偏差</primary>
         <secondary>標本</secondary>
        </indexterm>
        <indexterm>
         <primary>stddev_samp</primary>
        </indexterm>
        <function>stddev_samp</function> ( <replaceable>numeric_type</replaceable> )
<!--
        <returnvalue></returnvalue> <type>double precision</type>
        for <type>real</type> or <type>double precision</type>,
        otherwise <type>numeric</type>
-->
        <returnvalue></returnvalue> 引数が<type>double precision</type>あるいは<type>real</type>に対しては<type>double precision</type>、それ以外は<type>numeric</type>
       </para>
       <para>
<!--
        Computes the sample standard deviation of the input values.
-->
入力値の標本標準偏差を計算します。
       </para></entry>
<!--
       <entry>Yes</entry>
-->
       <entry>可</entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>variance</primary>
        </indexterm>
        <function>variance</function> ( <replaceable>numeric_type</replaceable> )
<!--
        <returnvalue></returnvalue> <type>double precision</type>
        for <type>real</type> or <type>double precision</type>,
        otherwise <type>numeric</type>
-->
        <returnvalue></returnvalue> 引数が<type>double precision</type>あるいは<type>real</type>に対しては<type>double precision</type>、それ以外は<type>numeric</type>
       </para>
       <para>
<!--
        This is a historical alias for <function>var_samp</function>.
-->
これは<function>var_samp</function>の歴史的な別名です。
       </para></entry>
<!--
       <entry>Yes</entry>
-->
       <entry>可</entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>variance</primary>
         <secondary>population</secondary>
        </indexterm>
        <indexterm>
         <primary>分散</primary>
         <secondary>母集団</secondary>
        </indexterm>
        <indexterm>
         <primary>var_pop</primary>
        </indexterm>
        <function>var_pop</function> ( <replaceable>numeric_type</replaceable> )
<!--
        <returnvalue></returnvalue> <type>double precision</type>
        for <type>real</type> or <type>double precision</type>,
        otherwise <type>numeric</type>
-->
        <returnvalue></returnvalue> 引数が<type>double precision</type>あるいは<type>real</type>に対しては<type>double precision</type>、それ以外は<type>numeric</type>
       </para>
       <para>
<!--
        Computes the population variance of the input values (square of the
        population standard deviation).
-->
入力値の母分散（母標準偏差の二乗）を計算します。
       </para></entry>
<!--
       <entry>Yes</entry>
-->
       <entry>可</entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>variance</primary>
         <secondary>sample</secondary>
        </indexterm>
        <indexterm>
         <primary>分散</primary>
         <secondary>標本</secondary>
        </indexterm>
        <indexterm>
         <primary>var_samp</primary>
        </indexterm>
        <function>var_samp</function> ( <replaceable>numeric_type</replaceable> )
<!--
        <returnvalue></returnvalue> <type>double precision</type>
        for <type>real</type> or <type>double precision</type>,
        otherwise <type>numeric</type>
-->
        <returnvalue></returnvalue> 引数が<type>double precision</type>あるいは<type>real</type>に対しては<type>double precision</type>、それ以外は<type>numeric</type>
       </para>
       <para>
<!--
        Computes the sample variance of the input values (square of the sample
        standard deviation).
-->
入力値の標本分散（標本標準偏差の二乗）を計算します。
       </para></entry>
<!--
       <entry>Yes</entry>
-->
       <entry>可</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <para>
<!--
   <xref linkend="functions-orderedset-table"/> shows some
   aggregate functions that use the <firstterm>ordered-set aggregate</firstterm>
   syntax.  These functions are sometimes referred to as <quote>inverse
   distribution</quote> functions.  Their aggregated input is introduced by
   <literal>ORDER BY</literal>, and they may also take a <firstterm>direct
   argument</firstterm> that is not aggregated, but is computed only once.
   All these functions ignore null values in their aggregated input.
   For those that take a <parameter>fraction</parameter> parameter, the
   fraction value must be between 0 and 1; an error is thrown if not.
   However, a null <parameter>fraction</parameter> value simply produces a
   null result.
-->
<xref linkend="functions-orderedset-table"/>に<firstterm>順序集合集約</firstterm>構文を使う集約関数を示します。
これらの関数は<quote>逆分散</quote>関数として参照されることがあります。
これらの集約入力は<literal>ORDER BY</literal>で導入され、集約ではない<firstterm>direct argument</firstterm>を取ることもでき、一度だけ計算されます。
これらの関数は集約入力のNULL値を無視します。
<parameter>fraction</parameter>パラメータを取る関数では、その値は0と1の間でなければなりません。そうでなければエラーが生じます。
ただしNULLの<parameter>fraction</parameter>値は単にNULLの結果をもたらします。
  </para>

  <indexterm>
   <primary>ordered-set aggregate</primary>
   <secondary>built-in</secondary>
  </indexterm>
  <indexterm>
   <primary>順序集合集約</primary>
   <secondary>組み込み</secondary>
  </indexterm>
  <indexterm>
   <primary>inverse distribution</primary>
  </indexterm>
  <indexterm>
   <primary>逆分散</primary>
  </indexterm>

   <table id="functions-orderedset-table">
<!--
    <title>Ordered-Set Aggregate Functions</title>
-->
    <title>順序集合集約関数</title>
    <tgroup cols="2">
     <colspec colname="col1" colwidth="10*"/>
     <colspec colname="col2" colwidth="1*"/>
     <thead>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
<!--
        Function
-->
関数
       </para>
       <para>
<!--
        Description
-->
説明
       </para></entry>
<!--
       <entry>Partial Mode</entry>
-->
       <entry>部分モード</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>mode</primary>
         <secondary>statistical</secondary>
        </indexterm>
        <indexterm>
         <primary>最頻値(モード)</primary>
         <secondary>統計</secondary>
        </indexterm>
        <function>mode</function> () <literal>WITHIN GROUP</literal> ( <literal>ORDER BY</literal> <type>anyelement</type> )
        <returnvalue>anyelement</returnvalue>
       </para>
       <para>
<!--
        Computes the <firstterm>mode</firstterm>, the most frequent
        value of the aggregated argument (arbitrarily choosing the first one
        if there are multiple equally-frequent values).  The aggregated
        argument must be of a sortable type.
-->
集約引数の<firstterm>最頻値</firstterm>、最も頻出する値（複数の同じ度数の結果があれば、任意に選んだ最初のもの）を計算します。
集約引数はソート可能な型でなければなりません。
       </para></entry>
<!--
       <entry>No</entry>
-->
       <entry>非</entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>percentile</primary>
         <secondary>continuous</secondary>
        </indexterm>
        <indexterm>
         <primary>百分位数</primary>
         <secondary>連続</secondary>
        </indexterm>
        <function>percentile_cont</function> ( <parameter>fraction</parameter> <type>double precision</type> ) <literal>WITHIN GROUP</literal> ( <literal>ORDER BY</literal> <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para role="func_signature">
        <function>percentile_cont</function> ( <parameter>fraction</parameter> <type>double precision</type> ) <literal>WITHIN GROUP</literal> ( <literal>ORDER BY</literal> <type>interval</type> )
        <returnvalue>interval</returnvalue>
       </para>
       <para>
<!--
        Computes the <firstterm>continuous percentile</firstterm>, a value
        corresponding to the specified <parameter>fraction</parameter>
        within the ordered set of aggregated argument values.  This will
        interpolate between adjacent input items if needed.
-->
<firstterm>連続百分位数</firstterm>、引数の値の順序付け集合中で指定された<parameter>fraction</parameter>に対応する値を計算します。
これは必要なら隣り合う入力項目を補間します。
       </para></entry>
<!--
       <entry>No</entry>
-->
       <entry>非</entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>percentile_cont</function> ( <parameter>fractions</parameter> <type>double precision[]</type> ) <literal>WITHIN GROUP</literal> ( <literal>ORDER BY</literal> <type>double precision</type> )
        <returnvalue>double precision[]</returnvalue>
       </para>
       <para role="func_signature">
        <function>percentile_cont</function> ( <parameter>fractions</parameter> <type>double precision[]</type> ) <literal>WITHIN GROUP</literal> ( <literal>ORDER BY</literal> <type>interval</type> )
        <returnvalue>interval[]</returnvalue>
       </para>
       <para>
<!--
        Computes multiple continuous percentiles.  The result is an array of
        the same dimensions as the <parameter>fractions</parameter>
        parameter, with each non-null element replaced by the (possibly
        interpolated) value corresponding to that percentile.
-->
複数の連続百分位数を計算します。
結果は<parameter>fractions</parameter>パラメータと同じ次元数の配列です。各非NULL要素は（必要なら隣り合う入力項目を補間して）その百分位数に対応する値で置き換えられます。
       </para></entry>
<!--
       <entry>No</entry>
-->
       <entry>非</entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>percentile</primary>
         <secondary>discrete</secondary>
        </indexterm>
        <indexterm>
         <primary>百分位数</primary>
         <secondary>離散</secondary>
        </indexterm>
        <function>percentile_disc</function> ( <parameter>fraction</parameter> <type>double precision</type> ) <literal>WITHIN GROUP</literal> ( <literal>ORDER BY</literal> <type>anyelement</type> )
        <returnvalue>anyelement</returnvalue>
       </para>
       <para>
<!--
        Computes the <firstterm>discrete percentile</firstterm>, the first
        value within the ordered set of aggregated argument values whose
        position in the ordering equals or exceeds the
        specified <parameter>fraction</parameter>.  The aggregated
        argument must be of a sortable type.
-->
<firstterm>離散百分位数</firstterm>を計算します。集約引数の順序付け集合中で、その位置が指定した<parameter>fraction</parameter>と等しいか越えた最初の値です。
集約引数はソート可能な型でなければなりません。
       </para></entry>
<!--
       <entry>No</entry>
-->
       <entry>非</entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>percentile_disc</function> ( <parameter>fractions</parameter> <type>double precision[]</type> ) <literal>WITHIN GROUP</literal> ( <literal>ORDER BY</literal> <type>anyelement</type> )
        <returnvalue>anyarray</returnvalue>
       </para>
       <para>
<!--
        Computes multiple discrete percentiles.  The result is an array of the
        same dimensions as the <parameter>fractions</parameter> parameter,
        with each non-null element replaced by the input value corresponding
        to that percentile.
        The aggregated argument must be of a sortable type.
-->
複数の離散百分位数を計算します。
結果は<parameter>fractions</parameter>パラメータと同じ次元数の配列です。各非NULL要素はその百分位数に対応する値で置き換えられます。
集約引数はソート可能な型でなければなりません。
       </para></entry>
<!--
       <entry>No</entry>
-->
       <entry>非</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <indexterm>
   <primary>hypothetical-set aggregate</primary>
   <secondary>built-in</secondary>
  </indexterm>
  <indexterm>
   <primary>仮想集合集約</primary>
   <secondary>組み込み</secondary>
  </indexterm>

  <para>
<!--
   Each of the <quote>hypothetical-set</quote> aggregates listed in
   <xref linkend="functions-hypothetical-table"/> is associated with a
   window function of the same name defined in
   <xref linkend="functions-window"/>.  In each case, the aggregate's result
   is the value that the associated window function would have
   returned for the <quote>hypothetical</quote> row constructed from
   <replaceable>args</replaceable>, if such a row had been added to the sorted
   group of rows represented by the <replaceable>sorted_args</replaceable>.
   For each of these functions, the list of direct arguments
   given in <replaceable>args</replaceable> must match the number and types of
   the aggregated arguments given in <replaceable>sorted_args</replaceable>.
   Unlike most built-in aggregates, these aggregates are not strict, that is
   they do not drop input rows containing nulls.  Null values sort according
   to the rule specified in the <literal>ORDER BY</literal> clause.
-->
<xref linkend="functions-hypothetical-table"/>に列挙されている<quote>仮想集合</quote>集約は、それぞれ<xref linkend="functions-window"/>で定義されている同じ名前のウィンドウ関数と関連します。
どの場合も、集約結果は、<replaceable>args</replaceable>から構築される<quote>仮想的な</quote>行に対して、関連するウィンドウ関数が返す値で、そのような行が<replaceable>sorted_args</replaceable>から計算されるソートされた行のグループに追加される場合を想定します。
これらの関数に対して<replaceable>args</replaceable>で与えられる直接引数のリストは、<replaceable>sorted_args</replaceable>で与えられる集約された引数の数と型に一致しなければなりません。
ほとんどの組み込み集約とは異なり、この集約はSTRICTではありません、すなわち、NULLを含む入力行を落としません。
NULL値は<literal>ORDER BY</literal>節で指定されるルールに従って並べられます。
  </para>

   <table id="functions-hypothetical-table">
<!--
    <title>Hypothetical-Set Aggregate Functions</title>
-->
    <title>仮想集合集約関数</title>
    <tgroup cols="2">
     <colspec colname="col1" colwidth="10*"/>
     <colspec colname="col2" colwidth="1*"/>
     <thead>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
<!--
        Function
-->
関数
       </para>
       <para>
<!--
        Description
-->
説明
       </para></entry>
<!--
       <entry>Partial Mode</entry>
-->
       <entry>部分モード</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>rank</primary>
         <secondary>hypothetical</secondary>
        </indexterm>
        <indexterm>
         <primary>rank</primary>
         <secondary>仮想の</secondary>
        </indexterm>
        <function>rank</function> ( <replaceable>args</replaceable> ) <literal>WITHIN GROUP</literal> ( <literal>ORDER BY</literal> <replaceable>sorted_args</replaceable> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
<!--
        Computes the rank of the hypothetical row, with gaps; that is, the row
        number of the first row in its peer group.
-->
重複する行のギャップを含む仮想の行の順位を計算します。すなわち、ピアグループの先頭の行の番号です。
       </para></entry>
<!--
       <entry>No</entry>
-->
       <entry>非</entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>dense_rank</primary>
         <secondary>hypothetical</secondary>
        </indexterm>
        <indexterm>
         <primary>dense_rank</primary> 
         <secondary>仮想の</secondary>
        </indexterm>
        <function>dense_rank</function> ( <replaceable>args</replaceable> ) <literal>WITHIN GROUP</literal> ( <literal>ORDER BY</literal> <replaceable>sorted_args</replaceable> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
<!--
        Computes the rank of the hypothetical row, without gaps; this function
        effectively counts peer groups.
-->
重複する行のギャップなしの仮想の行の順位を計算します。この関数は実効的にピアグループを数えます。
       </para></entry>
<!--
       <entry>No</entry>
-->
       <entry>非</entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>percent_rank</primary>
         <secondary>hypothetical</secondary>
        </indexterm>
        <indexterm>
         <primary>percent_rank</primary>
         <secondary>仮想の</secondary>
        </indexterm>
        <function>percent_rank</function> ( <replaceable>args</replaceable> ) <literal>WITHIN GROUP</literal> ( <literal>ORDER BY</literal> <replaceable>sorted_args</replaceable> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
<!--
        Computes the relative rank of the hypothetical row, that is
        (<function>rank</function> - 1) / (total rows - 1).
        The value thus ranges from 0 to 1 inclusive.
-->
仮想行の相対的な順位を計算します。すなわち、(<function>rank</function> - 1) / (total rows - 1)です。
ですから値の範囲は境界を含んで0から1までです。
       </para></entry>
<!--
       <entry>No</entry>
-->
       <entry>非</entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>cume_dist</primary>
         <secondary>hypothetical</secondary>
        </indexterm>
        <indexterm>
         <primary>cume_dist</primary>
         <secondary>仮想の</secondary>
        </indexterm>
        <function>cume_dist</function> ( <replaceable>args</replaceable> ) <literal>WITHIN GROUP</literal> ( <literal>ORDER BY</literal> <replaceable>sorted_args</replaceable> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
<!--
        Computes the cumulative distribution, that is (number of rows
        preceding or peers with hypothetical row) / (total rows).  The value
        thus ranges from 1/<parameter>N</parameter> to 1.
-->
現在行の相対順位を計算します。すなわち、(仮想行より先行する、あるいはピアの行数) / (合計行数)です。
ですから範囲は1/<parameter>N</parameter>から1です。
       </para></entry>
<!--
       <entry>No</entry>
-->
       <entry>非</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <table id="functions-grouping-table">
<!--
   <title>Grouping Operations</title>
-->
   <title>グループ化演算</title>
    <tgroup cols="1">
     <thead>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
<!--
        Function
-->
関数
       </para>
       <para>
<!--
        Description
-->
説明
       </para></entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>GROUPING</primary>
        </indexterm>
        <function>GROUPING</function> ( <replaceable>group_by_expression(s)</replaceable> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
<!--
        Returns a bit mask indicating which <literal>GROUP BY</literal>
        expressions are not included in the current grouping set.
        Bits are assigned with the rightmost argument corresponding to the
        least-significant bit; each bit is 0 if the corresponding expression
        is included in the grouping criteria of the grouping set generating
        the current result row, and 1 if it is not included.
-->
どの<literal>GROUP BY</literal>式が現在のグループ化セットに含まれないかを示す整数のビットマスクを返します。
最も右側の引数が最下位ビットになるようにビットが割り当てられます。
各ビットは対応する式が結果の行を生成するグループ化セットのグループ化条件に含まれていれば0、そうでなければ1です。
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
<!--
    The grouping operations shown in
    <xref linkend="functions-grouping-table"/> are used in conjunction with
    grouping sets (see <xref linkend="queries-grouping-sets"/>) to distinguish
    result rows.  The arguments to the <literal>GROUPING</literal> function
    are not actually evaluated, but they must exactly match expressions given
    in the <literal>GROUP BY</literal> clause of the associated query level.
    For example:
-->
<xref linkend="functions-grouping-table"/>で示すグループ化演算はグループ化セット（<xref linkend="queries-grouping-sets"/>参照）と一緒に使われ、結果の行を区別するものです。
<literal>GROUPING</literal>関数の引数は実際には評価されませんが、関連する問い合わせの<literal>GROUP BY</literal>句にある式と正確に一致する必要があります。
例えば以下のようになります。
<screen>
<prompt>=&gt;</prompt> <userinput>SELECT * FROM items_sold;</userinput>
 make  | model | sales
-------+-------+-------
 Foo   | GT    |  10
 Foo   | Tour  |  20
 Bar   | City  |  15
 Bar   | Sport |  5
(4 rows)

<prompt>=&gt;</prompt> <userinput>SELECT make, model, GROUPING(make,model), sum(sales) FROM items_sold GROUP BY ROLLUP(make,model);</userinput>
 make  | model | grouping | sum
-------+-------+----------+-----
 Foo   | GT    |        0 | 10
 Foo   | Tour  |        0 | 20
 Bar   | City  |        0 | 15
 Bar   | Sport |        0 | 5
 Foo   |       |        1 | 30
 Bar   |       |        1 | 20
       |       |        3 | 50
(7 rows)
</screen>
<!--
    Here, the <literal>grouping</literal> value <literal>0</literal> in the
    first four rows shows that those have been grouped normally, over both the
    grouping columns.  The value <literal>1</literal> indicates
    that <literal>model</literal> was not grouped by in the next-to-last two
    rows, and the value <literal>3</literal> indicates that
    neither <literal>make</literal> nor <literal>model</literal> was grouped
    by in the last row (which therefore is an aggregate over all the input
    rows).
-->
ここで、最初の4行の<literal>グループ化</literal>値<literal>0</literal>はこれらがグループ化列に対して正常にグループ化されたことを示します。
値<literal>1</literal>は<literal>model</literal>が最後とその一つ前の行ではグループ化されなかったことを、値<literal>3</literal>は<literal>make</literal>も<literal>model</literal>も最後の行でグループ化されなかったことを意味します（ですから最後の行はすべての入力行に対する集約になっています）。
   </para>

 </sect1>

 <sect1 id="functions-window">
<!--
  <title>Window Functions</title>
-->
  <title>ウィンドウ関数</title>

  <indexterm zone="functions-window">
   <primary>window function</primary>
   <secondary>built-in</secondary>
  </indexterm>
  <indexterm zone="functions-window">
   <primary>ウィンドウ関数</primary>
   <secondary>組み込み</secondary>
  </indexterm>

  <para>
<!--
   <firstterm>Window functions</firstterm> provide the ability to perform
   calculations across sets of rows that are related to the current query
   row.  See <xref linkend="tutorial-window"/> for an introduction to this
   feature, and <xref linkend="syntax-window-functions"/> for syntax
   details.
-->
<firstterm>ウィンドウ関数</firstterm>は現在の問い合わせ行に関連した行集合に渡っての計算処理機能を提供します。
この機能の手引きは<xref linkend="tutorial-window"/>を、文法の詳細は<xref linkend="syntax-window-functions"/>を参照してください。
  </para>

  <para>
<!--
   The built-in window functions are listed in
   <xref linkend="functions-window-table"/>.  Note that these functions
   <emphasis>must</emphasis> be invoked using window function syntax, i.e., an
   <literal>OVER</literal> clause is required.
-->
組み込みウィンドウ関数は<xref linkend="functions-window-table"/>に一覧されています。
これらの関数は<emphasis>必ず</emphasis>ウィンドウ関数構文で呼び出されなければなりません。つまり、<literal>OVER</literal>句が必要です。
  </para>

  <para>
<!--
   In addition to these functions, any built-in or user-defined
   ordinary aggregate (i.e., not ordered-set or hypothetical-set aggregates)
   can be used as a window function; see
   <xref linkend="functions-aggregate"/> for a list of the built-in aggregates.
   Aggregate functions act as window functions only when an <literal>OVER</literal>
   clause follows the call; otherwise they act as plain aggregates
   and return a single row for the entire set.
-->
これらの関数に加え、すべての組み込み、またはユーザ定義の汎用集約関数または統計集約関数もウィンドウ関数として使用できます(ただし順序集合や仮想集合集約はそうではありません)。組み込み集約関数一覧は<xref linkend="functions-aggregate"/>を参照してください。
集約関数は、呼び出しの後に<literal>OVER</literal>句が続いた場合のみウィンドウ関数として動作します。それ以外の場合は、非ウィンドウの集約関数として動作し、集合全体に対して1行だけを返します。
  </para>

   <table id="functions-window-table">
<!--
    <title>General-Purpose Window Functions</title>
-->
    <title>汎用ウィンドウ関数</title>
    <tgroup cols="1">
     <thead>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
<!--
        Function
-->
関数
       </para>
       <para>
<!--
        Description
-->
説明
       </para></entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>row_number</primary>
        </indexterm>
        <function>row_number</function> ()
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
<!--
        Returns the number of the current row within its partition, counting
        from 1.
-->
１から数える現在行のパーティション内での行番号を返します。
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>rank</primary>
        </indexterm>
        <function>rank</function> ()
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
<!--
        Returns the rank of the current row, with gaps; that is,
        the <function>row_number</function> of the first row in its peer
        group.
-->
ギャップを含んだ現在行の順位を返します。すなわちピアグループの先頭行の<function>row_number</function>と同じになります。
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>dense_rank</primary>
        </indexterm>
        <function>dense_rank</function> ()
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
<!--
        Returns the rank of the current row, without gaps; this function
        effectively counts peer groups.
-->
ギャップを含まない現在行の順位。この関数は実質的にピアのグループ数を数えます。
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>percent_rank</primary>
        </indexterm>
        <function>percent_rank</function> ()
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
<!--
        Returns the relative rank of the current row, that is
        (<function>rank</function> - 1) / (total partition rows - 1).
        The value thus ranges from 0 to 1 inclusive.
-->
現在行の相対順位、すなわち (<function>rank</function> - 1) / (パーティションの総行数 - 1)を返します。
したがってこの値は境界を含み0から1となります。
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>cume_dist</primary>
        </indexterm>
        <function>cume_dist</function> ()
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
<!--
        Returns the cumulative distribution, that is (number of partition rows
        preceding or peers with current row) / (total partition rows).
        The value thus ranges from 1/<parameter>N</parameter> to 1.
-->
現在行の相対順位、すなわち (現在行より先行する行およびピアの行数) / (パーティションの総行数)を返します。
したがってこの値は1/<parameter>N</parameter>から1となります。
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ntile</primary>
        </indexterm>
        <function>ntile</function> ( <parameter>num_buckets</parameter> <type>integer</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
<!--
        Returns an integer ranging from 1 to the argument value, dividing the
        partition as equally as possible.
-->
できるだけ等価にパーティションを分割した、1から引数値までの整数を返します。
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>lag</primary>
        </indexterm>
        <function>lag</function> ( <parameter>value</parameter> <type>anycompatible</type>
          <optional>, <parameter>offset</parameter> <type>integer</type>
          <optional>, <parameter>default</parameter> <type>anycompatible</type> </optional></optional> )
        <returnvalue>anycompatible</returnvalue>
       </para>
       <para>
<!--
        Returns <parameter>value</parameter> evaluated at
        the row that is <parameter>offset</parameter>
        rows before the current row within the partition; if there is no such
        row, instead returns <parameter>default</parameter>
        (which must be of a type compatible with
        <parameter>value</parameter>).
        Both <parameter>offset</parameter> and
        <parameter>default</parameter> are evaluated
        with respect to the current row.  If omitted,
        <parameter>offset</parameter> defaults to 1 and
        <parameter>default</parameter> to <literal>NULL</literal>.
-->
パーティション内の現在行より<parameter>offset</parameter>行だけ前の行で評価された<parameter>value</parameter>を返します。
該当する行がない場合、その代わりとして<parameter>default</parameter>(<parameter>value</parameter>と互換性のある型でなければなりません)を返します。
<parameter>offset</parameter>と<parameter>default</parameter>は共に現在行について評価されます。
省略された場合、<parameter>offset</parameter>はデフォルトで1となり、<parameter>default</parameter>は<literal>NULL</literal>になります。
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>lead</primary>
        </indexterm>
        <function>lead</function> ( <parameter>value</parameter> <type>anycompatible</type>
          <optional>, <parameter>offset</parameter> <type>integer</type>
          <optional>, <parameter>default</parameter> <type>anycompatible</type> </optional></optional> )
        <returnvalue>anycompatible</returnvalue>
       </para>
       <para>
<!--
        Returns <parameter>value</parameter> evaluated at
        the row that is <parameter>offset</parameter>
        rows after the current row within the partition; if there is no such
        row, instead returns <parameter>default</parameter>
        (which must be of a type compatible with
        <parameter>value</parameter>).
        Both <parameter>offset</parameter> and
        <parameter>default</parameter> are evaluated
        with respect to the current row.  If omitted,
        <parameter>offset</parameter> defaults to 1 and
        <parameter>default</parameter> to <literal>NULL</literal>.
-->
パーティション内の現在行より<parameter>offset</parameter>行だけ後の行で評価された<parameter>value</parameter>を返します。
該当する行がない場合、その代わりとして<parameter>default</parameter>(<parameter>value</parameter>と互換性のある型でなければなりません)を返します。
<parameter>offset</parameter>と<parameter>default</parameter>は共に現在行について評価されます。
省略された場合、<parameter>offset</parameter>はデフォルトで1となり、<parameter>default</parameter>は<literal>NULL</literal>になります。
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>first_value</primary>
        </indexterm>
        <function>first_value</function> ( <parameter>value</parameter> <type>anyelement</type> )
        <returnvalue>anyelement</returnvalue>
       </para>
       <para>
<!--
        Returns <parameter>value</parameter> evaluated
        at the row that is the first row of the window frame.
-->
ウィンドウフレームの最初の行である行で評価された<parameter>value</parameter>を返します。
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>last_value</primary>
        </indexterm>
        <function>last_value</function> ( <parameter>value</parameter> <type>anyelement</type> )
        <returnvalue>anyelement</returnvalue>
       </para>
       <para>
<!--
        Returns <parameter>value</parameter> evaluated
        at the row that is the last row of the window frame.
-->
ウィンドウフレームの最後の行である行で評価された<parameter>value</parameter>を返します。
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>nth_value</primary>
        </indexterm>
        <function>nth_value</function> ( <parameter>value</parameter> <type>anyelement</type>, <parameter>n</parameter> <type>integer</type> )
        <returnvalue>anyelement</returnvalue>
       </para>
       <para>
<!--
        Returns <parameter>value</parameter> evaluated
        at the row that is the <parameter>n</parameter>'th
        row of the window frame (counting from 1);
        returns <literal>NULL</literal> if there is no such row.
-->
ウィンドウフレームの（１から数えて）<parameter>n</parameter>番目の行である行で評価された<parameter>value</parameter>を返します。行が存在しない場合は<literal>NULL</literal>を返します。
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <para>
<!--
   All of the functions listed in
   <xref linkend="functions-window-table"/> depend on the sort ordering
   specified by the <literal>ORDER BY</literal> clause of the associated window
   definition.  Rows that are not distinct when considering only the
   <literal>ORDER BY</literal> columns are said to be <firstterm>peers</firstterm>.
   The four ranking functions (including <function>cume_dist</function>) are
   defined so that they give the same answer for all rows of a peer group.
-->
<xref linkend="functions-window-table"/>に列挙された関数はすべて、対応するウィンドウ定義の<literal>ORDER BY</literal>句で指定されるソート順に依存します。
<literal>ORDER BY</literal>の列だけを考慮した場合に重複する行は<firstterm>ピア</firstterm>と呼ばれます。
4つの順位付け関数（<function>cume_dist</function>を含む）は、すべてのピア行に対して同じ答えになるように定義されています。
  </para>

  <para>
<!--
   Note that <function>first_value</function>, <function>last_value</function>, and
   <function>nth_value</function> consider only the rows within the <quote>window
   frame</quote>, which by default contains the rows from the start of the
   partition through the last peer of the current row.  This is
   likely to give unhelpful results for <function>last_value</function> and
   sometimes also <function>nth_value</function>.  You can redefine the frame by
   adding a suitable frame specification (<literal>RANGE</literal>,
   <literal>ROWS</literal> or <literal>GROUPS</literal>) to
   the <literal>OVER</literal> clause.
   See <xref linkend="syntax-window-functions"/> for more information
   about frame specifications.
-->
<function>first_value</function>、<function>last_value</function>、<function>nth_value</function>関数は<quote>ウィンドウフレーム</quote>内の行のみを考慮することに注意してください。
デフォルトで、ウィンドウフレームにはパーティションの先頭から現在の行の最終ピアまでの行が含まれます。
これは<function>last_value</function>、または時々<function>nth_value</function>では有用ではない結果を得ることになりがちです。
<literal>OVER</literal>句に適切なフレーム指定(<literal>RANGE</literal>、<literal>GROUP</literal>、もしくは<literal>ROWS</literal>)を加えることで、フレームを再定義することができます。
フレーム指定についての詳細は<xref linkend="syntax-window-functions"/>を参照してください。
  </para>

  <para>
<!--
   When an aggregate function is used as a window function, it aggregates
   over the rows within the current row's window frame.
   An aggregate used with <literal>ORDER BY</literal> and the default window frame
   definition produces a <quote>running sum</quote> type of behavior, which may or
   may not be what's wanted.  To obtain
   aggregation over the whole partition, omit <literal>ORDER BY</literal> or use
   <literal>ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING</literal>.
   Other frame specifications can be used to obtain other effects.
-->
集約関数をウィンドウ関数として使用する場合、現在の行のウィンドウフレーム内の行に渡って集約処理を行います。
<literal>ORDER BY</literal>および、デフォルトのウィンドウフレーム定義を使用した集約では、<quote>中間和</quote>のような動作を行います。これが望まれる場合もあれば、望まれない場合もあります。
パーティション全体に渡る集約処理を行うためには、<literal>ORDER BY</literal>を省略するか<literal>ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING</literal>を使用してください。
他のフレーム指定を使用することで様々な結果を得ることができます。
  </para>

  <note>
   <para>
<!--
    The SQL standard defines a <literal>RESPECT NULLS</literal> or
    <literal>IGNORE NULLS</literal> option for <function>lead</function>, <function>lag</function>,
    <function>first_value</function>, <function>last_value</function>, and
    <function>nth_value</function>.  This is not implemented in
    <productname>PostgreSQL</productname>: the behavior is always the
    same as the standard's default, namely <literal>RESPECT NULLS</literal>.
    Likewise, the standard's <literal>FROM FIRST</literal> or <literal>FROM LAST</literal>
    option for <function>nth_value</function> is not implemented: only the
    default <literal>FROM FIRST</literal> behavior is supported.  (You can achieve
    the result of <literal>FROM LAST</literal> by reversing the <literal>ORDER BY</literal>
    ordering.)
-->
標準SQLは、<function>lead</function>、<function>lag</function>、<function>first_value</function>、<function>last_value</function>、および<function>nth_value</function>に対し<literal>RESPECT NULLS</literal>、または<literal>IGNORE NULLS</literal>オプションを定義します。
これは<productname>PostgreSQL</productname>に実装されていません。動作は常に標準のデフォルトと同一です。つまり、<literal>RESPECT NULLS</literal>です。
同様にして、標準の<function>nth_value</function>に対する<literal>FROM FIRST</literal>、または<literal>FROM LAST</literal>オプションは実装されていません。デフォルトの<literal>FROM FIRST</literal>動作のみに対応しています。
（<literal>ORDER BY</literal>順序付けを逆に行うことで、<literal>FROM LAST</literal>の結果を得ることができます。）
   </para>
  </note>

 </sect1>

<!-- split-func3-end -->
