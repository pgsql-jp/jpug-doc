<!-- doc/src/sgml/pltcl.sgml -->

 <chapter id="pltcl">
<!--
  <title>PL/Tcl - Tcl Procedural Language</title>
-->
<title>PL/Tcl - Tcl手続き言語</title>

  <indexterm zone="pltcl">
   <primary>PL/Tcl</primary>
  </indexterm>

  <indexterm zone="pltcl">
   <primary>Tcl</primary>
  </indexterm>

  <para>
<!--
   PL/Tcl is a loadable procedural language for the
   <productname>PostgreSQL</productname> database system
   that enables the <ulink url="http://www.tcl.tk/">
   Tcl language</ulink> to be used to write functions and
   trigger procedures.
-->
PL/Tclとは、<productname>PostgreSQL</productname>データベースシステムにロード可能な手続き言語で、<ulink url="http://www.tcl.tk/">Tcl言語</ulink>を使った関数とトリガプロシージャを作成できます。
  </para>

  <!-- 原文コメント**** PL/Tcl overview **** -->

  <sect1 id="pltcl-overview">
<!--
   <title>Overview</title>
-->
<title>概要</title>

   <para>
<!--
    PL/Tcl offers most of the capabilities a function writer has in
    the C language, with a few restrictions, and with the addition of
    the powerful string processing libraries that are available for
    Tcl.
-->
PL/Tclは、いくつか制限がありますが、C言語で書かれた関数と同じような能力を提供します。
さらに、Tclで利用できる、強力な文字列処理ライブラリを持っています。
   </para>
   <para>
<!--
    One compelling <emphasis>good</emphasis> restriction is that
    everything is executed from within the safety of the context of a
    Tcl interpreter.  In addition to the limited command set of safe
    Tcl, only a few commands are available to access the database via
    SPI and to raise messages via <function>elog()</>.  PL/Tcl
    provides no way to access internals of the database server or to
    gain OS-level access under the permissions of the
    <productname>PostgreSQL</productname> server process, as a C
    function can do.  Thus, unprivileged database users can be trusted
    to use this language; it does not give them unlimited authority.
-->
すべてがTclインタプリタの安全なコンテキスト内で実行されるという制約はやむを得ないものですが、逆に<emphasis>良い</emphasis>制約でもあります。
安全なTclの制約付きのコマンドセットに、SPIを使ってデータベースにアクセスするコマンドと、<function>elog()</>を使ってメッセージを処理するためのコマンドなどの、わずかなコマンドが追加されています。
C関数では可能ですが、PL/Tclにはデータベースサーバ内部にアクセスする方法や、<productname>PostgreSQL</productname>サーバプロセスの権限によるOSレベルのアクセスを行う方法はありません。
この結果、非特権データベースユーザがこの言語を信頼して使用することができます。
つまり、無制限の権限は与えられません。
   </para>
   <para>
<!--
    The other notable implementation restriction is that Tcl functions
    cannot be used to create input/output functions for new data
    types.
-->
その他の注意すべき実装上の制約として、Tcl関数を使用して新しいデータ型用の入出力関数を作成することはできません。
   </para>
   <para>
<!--
    Sometimes it is desirable to write Tcl functions that are not restricted
    to safe Tcl.  For example, one might want a Tcl function that sends
    email.  To handle these cases, there is a variant of <application>PL/Tcl</> called <literal>PL/TclU</>
    (for untrusted Tcl).  This is exactly the same language except that a full
    Tcl interpreter is used.  <emphasis>If <application>PL/TclU</> is used, it must be
    installed as an untrusted procedural language</emphasis> so that only
    database superusers can create functions in it.  The writer of a <application>PL/TclU</>
    function must take care that the function cannot be used to do anything
    unwanted, since it will be able to do anything that could be done by
    a user logged in as the database administrator.
-->
例えば、メールを送るTcl関数が必要な場合など、安全なTclに制約されないTcl関数を書くことが望ましい場合があります。
このような場合、<literal>PL/TclU</>（信頼されないTcl）という<application>PL/Tcl</>の亜種を使用します。
これは、完全なTclインタプリタが使用されているという点以外の違いはありません。
<emphasis><application>PL/TclU</>を使用する場合は、信頼されていない手続き言語としてインストールする必要があります</emphasis>。
そうすることによって、データベースのスーパーユーザのみが関数を作成することができるようになります。
<application>PL/TclU</>関数ではデータベース管理者としてログインしたユーザができるあらゆることの実行が可能となるので、作成する際に、この関数が意図された以外のことを行わないように細心の注意を払う必要があります。
   </para>
   <para>
<!--
    The shared object code for the <application>PL/Tcl</> and
    <application>PL/TclU</> call handlers is automatically built and
    installed in the <productname>PostgreSQL</productname> library
    directory if Tcl support is specified in the configuration step of
    the installation procedure.  To install <application>PL/Tcl</>
    and/or <application>PL/TclU</> in a particular database, use the
    <command>CREATE EXTENSION</> command or the
    <command>createlang</command> program, for example
    <literal>createlang pltcl <replaceable>dbname</></literal> or
    <literal>createlang pltclu <replaceable>dbname</></literal>.
-->
インストール時にTclサポートの設定が指定されていれば、<application>PL/Tcl</>と<application>PL/TclU</>呼び出しハンドラの共有オブジェクトコードは自動的に作成され、<productname>PostgreSQL</productname>のライブラリディレクトリにインストールされます。
<application>PL/Tcl</>または<application>PL/TclU</>の一方あるいは両方を特定のデータベースにインストールしたい場合は、<command>CREATE EXTENSION</>または<filename>createlang</filename>プログラムを使用してください。
例えば、<literal>createlang pltcl <replaceable>dbname</></literal>または<literal>createlang pltclu <replaceable>dbname</></literal>です。
   </para>
  </sect1>

  <!-- 原文コメント**** PL/Tcl description **** -->

   <sect1 id="pltcl-functions">
<!--
    <title>PL/Tcl Functions and Arguments</title>
-->
<title>PL/Tcl関数と引数</title>

    <para>
<!--
     To create a function in the <application>PL/Tcl</> language, use
     the standard <xref linkend="sql-createfunction"> syntax:
-->
<application>PL/Tcl</>言語で関数を作成するには、以下の標準的な<xref linkend="sql-createfunction">構文を使用してください。

<programlisting>
CREATE FUNCTION <replaceable>funcname</replaceable> (<replaceable>argument-types</replaceable>) RETURNS <replaceable>return-type</replaceable> AS $$
<!--
    # PL/Tcl function body
-->
    # PL/Tcl関数本体
$$ LANGUAGE pltcl;
</programlisting>

<!--
     <application>PL/TclU</> is the same, except that the language has to be specified as
     <literal>pltclu</>.
-->
<application>PL/TclU</>でも、言語に<literal>pltclu</>を指定しなければならない点以外は同様です。
    </para>

    <para>
<!--
     The body of the function is simply a piece of Tcl script.
     When the function is called, the argument values are passed as
     variables <literal>$1</literal> ... <literal>$<replaceable>n</replaceable></literal> to the
     Tcl script.  The result is returned
     from the Tcl code in the usual way, with a <literal>return</literal>
     statement.
-->
関数本体は、単なる小さなTclスクリプトです。
関数が呼び出された時、引数の値はTclスクリプトに<literal>$1</literal> ... <literal>$<replaceable>n</replaceable></literal>という変数として渡されます。
結果は通常通り<literal>return</literal>文を使用してTclのコードから返されます。
    </para>

    <para>
<!--
     For example, a function
     returning the greater of two integer values could be defined as:
-->
例えば、2つの整数のうち大きな方を返す関数は以下のように定義できます。

<programlisting>
CREATE FUNCTION tcl_max(integer, integer) RETURNS integer AS $$
    if {$1 &gt; $2} {return $1}
    return $2
$$ LANGUAGE pltcl STRICT;
</programlisting>

<!--
     Note the clause <literal>STRICT</>, which saves us from
     having to think about null input values: if a null value is passed, the
     function will not be called at all, but will just return a null
     result automatically.
-->
<literal>STRICT</>句に注意してください。
これによりプログラマは、入力にNULL値が与えられた場合を検討する手間を省くことができます。
NULLが渡された場合、関数はまったく呼び出されず、単にNULLという結果が自動的に返されます。
    </para>

    <para>
<!--
     In a nonstrict function,
     if the actual value of an argument is null, the corresponding
     <literal>$<replaceable>n</replaceable></literal> variable will be set to an empty string.
     To detect whether a particular argument is null, use the function
     <literal>argisnull</>.  For example, suppose that we wanted <function>tcl_max</function>
     with one null and one nonnull argument to return the nonnull
     argument, rather than null:
-->
厳密（strict）でない関数では、引数の実際の値がNULLである場合、対応する<literal>$<replaceable>n</replaceable></literal>変数は空文字列に設定されます。
ある引数がNULLかどうかを検出するためには、<literal>argisnull</>関数を使用してください。
例えば、引数の片方がNULL、もう片方が非NULLであって、NULLではなく、非NULLの引数の方を返す<function>tcl_max</function>を考えると、以下のようになります。

<programlisting>
CREATE FUNCTION tcl_max(integer, integer) RETURNS integer AS $$
    if {[argisnull 1]} {
        if {[argisnull 2]} { return_null }
        return $2
    }
    if {[argisnull 2]} { return $1 }
    if {$1 &gt; $2} {return $1}
    return $2
$$ LANGUAGE pltcl;
</programlisting>
    </para>

    <para>
<!--
     As shown above,
     to return a null value from a PL/Tcl function, execute
     <literal>return_null</literal>.  This can be done whether the
     function is strict or not.
-->
上で示した通り、NULL値をPL/Tcl関数から返すためには、<literal>return_null</literal>を実行してください。
これは、関数が厳密かどうかに関係なく、実行することができます。
    </para>

    <para>
<!--
     Composite-type arguments are passed to the function as Tcl
     arrays.  The element names of the array are the attribute names
     of the composite type. If an attribute in the passed row has the
     null value, it will not appear in the array. Here is an example:
-->
複合型の引数は、Tcl配列として関数に渡されます。
配列の要素名は複合型の属性名です。
渡された行の属性がNULL値の場合、その属性は配列内には現れません。
以下に例を示します。

<programlisting>
CREATE TABLE employee (
    name text,
    salary integer,
    age integer
);

CREATE FUNCTION overpaid(employee) RETURNS boolean AS $$
    if {200000.0 &lt; $1(salary)} {
        return "t"
    }
    if {$1(age) &lt; 30 &amp;&amp; 100000.0 &lt; $1(salary)} {
        return "t"
    }
    return "f"
$$ LANGUAGE pltcl;
</programlisting>
    </para>

    <para>
<!--
     There is currently no support for returning a composite-type
     result value, nor for returning sets.
-->
今のところ、複合型の戻り値を返す機能や集合を返す機能はサポートされていません。
    </para>
    <para>
<!--
     <application>PL/Tcl</> does not currently have full support for
     domain types: it treats a domain the same as the underlying scalar
     type.  This means that constraints associated with the domain will
     not be enforced.  This is not an issue for function arguments, but
     it is a hazard if you declare a <application>PL/Tcl</> function
     as returning a domain type.
-->
今のところ<application>PL/Tcl</>はドメイン型を完全にサポートしていません。
ドメインをその背後にあるスカラ型と同様に扱います。
これは、ドメインに関連する制約が強制されないことを意味しています。
これは関数の引数では問題ありませんが、<application>PL/Tcl</>関数をドメイン型を返すように宣言した場合は危険です。
    </para>
   </sect1>

   <sect1 id="pltcl-data">
<!--
    <title>Data Values in PL/Tcl</title>
-->
<title>PL/Tclにおけるデータの値</title>

    <para>
<!--
     The argument values supplied to a PL/Tcl function's code are simply
     the input arguments converted to text form (just as if they had been
     displayed by a <command>SELECT</> statement).  Conversely, the
     <literal>return</>
     command will accept any string that is acceptable input format for
     the function's declared return type.  So, within the PL/Tcl function,
     all values are just text strings.
-->
PL/Tcl関数コードに与えられる引数の値は、単に、テキスト形式（<command>SELECT</>文によりそれを表示した場合と同じ形式）に変換された入力引数です。
逆に、<literal>return</>コマンドは、その関数宣言における戻り値の型の入力書式として受け付けることができる、任意の文字列を受け付けます。
このようにPL/Tcl関数ではすべての値は単なるテキスト文字列です。
    </para>

   </sect1>

   <sect1 id="pltcl-global">
<!--
    <title>Global Data in PL/Tcl</title>
-->
<title>PL/Tclにおけるグローバルデータ</title>

    <indexterm zone="pltcl-global">
<!--
     <primary>global data</primary>
     <secondary>in PL/Tcl</secondary>
-->
     <primary>グローバルデータ</primary>
     <secondary>PL/Tclにおける</secondary>
    </indexterm>

    <para>
<!--
     Sometimes it
     is useful to have some global data that is held between two
     calls to a function or is shared between different functions.
     This is easily done in PL/Tcl, but there are some restrictions that
     must be understood.
-->
ある関数の複数の呼び出し間で保持される、もしくは、異なる関数間で共有されるような、いくつかのグローバルデータを持つことが有意な場合があります。
これはPL/Tclで簡単に実現できますが、理解する必要がある制限がいくつかあります。
    </para>

    <para>
<!--
     For security reasons, PL/Tcl executes functions called by any one SQL
     role in a separate Tcl interpreter for that role.  This prevents
     accidental or malicious interference by one user with the behavior of
     another user's PL/Tcl functions.  Each such interpreter will have its own
     values for any <quote>global</> Tcl variables.  Thus, two PL/Tcl
     functions will share the same global variables if and only if they are
     executed by the same SQL role.  In an application wherein a single
     session executes code under multiple SQL roles (via <literal>SECURITY
     DEFINER</> functions, use of <command>SET ROLE</>, etc) you may need to
     take explicit steps to ensure that PL/Tcl functions can share data.  To
     do that, make sure that functions that should communicate are owned by
     the same user, and mark them <literal>SECURITY DEFINER</>.  You must of
     course take care that such functions can't be used to do anything
     unintended.
-->
セキュリティ上の理由のため、PL/Tclは、任意のSQLロールによって呼び出された関数をそのロール用の別のTclインタプリタで実行します。
これにより、他のユーザのPL/Tcl関数の処理によってあるユーザへの事故または悪意の干渉を防止します。
こうしたインタプリタはそれぞれ任意の<quote>グローバル</>なTcl変数を持ちます。
したがって、同じSQLロールにより実行されていれば、２つのPL/Tcl関数は同じグローバル変数を共有します。
単一セッション内で（<literal>SECURITY DEFINER</>関数または<command>SET ROLE</>などを通して）複数のSQLロールでコードを実行するアプリケーションでは、PL/Tcl関数が確実にデータを共有できるように明示的な処理を行う必要があるかもしれません。
このためには、通信しなければならない関数が同一ユーザで所有されていること、および、それが<literal>SECURITY DEFINER</>として印がついていることを確実にしてください。
当然ながら、こうした関数が意図しない動作を行うために使われることのないよう注意しなければなりません。
    </para>

    <para>
<!--
     All PL/TclU functions used in a session execute in the same Tcl
     interpreter, which of course is distinct from the interpreter(s)
     used for PL/Tcl functions.  So global data is automatically shared
     between PL/TclU functions.  This is not considered a security risk
     because all PL/TclU functions execute at the same trust level,
     namely that of a database superuser.
-->
セッション内で使用されるすべてのPL/TclU関数は、当然ながらPL/Tcl関数とは別のインタプリタですが、同一のTclインタプリタ内で実行されます。
このためPL/TclU関数間ではグローバルデータは自動的に共有されます。
すべてのPL/TclU関数は同じ信頼レベル、すなわちデータベーススーパーユーザで実行されますので、これはセキュリティ上危険とはみなされません。
    </para>

    <para>
<!--
     To help protect PL/Tcl functions from unintentionally interfering
     with each other, a global
     array is made available to each function via the <function>upvar</>
     command. The global name of this variable is the function's internal
     name, and the local name is <literal>GD</>.  It is recommended that
     <literal>GD</> be used
     for persistent private data of a function.  Use regular Tcl global
     variables only for values that you specifically intend to be shared among
     multiple functions.  (Note that the <literal>GD</> arrays are only
     global within a particular interpreter, so they do not bypass the
     security restrictions mentioned above.)
-->
PL/Tcl関数が予期しない相互作用に巻き込まれないようにするために、<function>upvar</>コマンドを使用することによって、各関数でアクセスできるグローバルな配列を作成することができます。
この変数のグローバル名は関数の内部名で、ローカル名は<literal>GD</>となります。
関数の永続局所データでは<literal>GD</>を使用することを推奨します。
複数の関数で共用させる予定の値に対してのみ、通常のTclのグローバル変数を使用してください。
（<literal>GD</>配列が特定のインタプリタ内のみでグローバルであることに注意してください。
このため、これらは上記のセキュリティ制限を迂回することはありません。）
    </para>

    <para>
<!--
     An example of using <literal>GD</> appears in the
     <function>spi_execp</function> example below.
-->
後述の<function>spi_execp</function>の例の中に<literal>GD</>の使用例があります。
    </para>
   </sect1>

   <sect1 id="pltcl-dbaccess">
<!--
    <title>Database Access from PL/Tcl</title>
-->
<title>PL/Tclからのデータベースアクセス</title>

    <para>
<!--
     The following commands are available to access the database from
     the body of a PL/Tcl function:
-->
下記のコマンドは、PL/Tcl関数内からデータベースアクセスを行う時に使用できるコマンドです。

    <variablelist>

     <varlistentry>
      <term><literal><function>spi_exec</function> <optional role="tcl">-count <replaceable>n</replaceable></optional> <optional role="tcl">-array <replaceable>name</replaceable></optional> <replaceable>command</replaceable> <optional role="tcl"><replaceable>loop-body</replaceable></optional></literal></term>
      <listitem>
       <para>
<!--
        Executes an SQL command given as a string.  An error in the command
        causes an error to be raised.  Otherwise, the return value of <function>spi_exec</function>
        is the number of rows processed (selected, inserted, updated, or
        deleted) by the command, or zero if the command is a utility
        statement.  In addition, if the command is a <command>SELECT</> statement, the
        values of the selected columns are placed in Tcl variables as
        described below.
-->
文字列として与えられたSQL問い合わせを実行します。
コマンド内のエラーは、エラーの発生となります。
さもなければ、この<function>spi_exec</function>の戻り値はコマンドによって処理（選択、挿入、更新、削除）された行数、または、コマンドがユーティリティ文の場合はゼロとなります。
さらに、コマンドが<command>SELECT</>文の場合、選択された列の値は以下のようにTclの変数に格納されます。
       </para>
       <para>
<!--
        The optional <literal>-count</> value tells
        <function>spi_exec</function> the maximum number of rows
        to process in the command.  The effect of this is comparable to
        setting up a query as a cursor and then saying <literal>FETCH <replaceable>n</></>.
-->
<literal>-count</>オプションの値は、<function>spi_exec</function>に対し、そのコマンドで処理する最大行数を指示します。
これにより、問い合わせをカーソルとして設定し、<literal>FETCH <replaceable>n</></>を実行することと同じことができます。
       </para>
       <para>
<!--
        If the command is a <command>SELECT</> statement, the values of the
        result columns are placed into Tcl variables named after the columns.
        If the <literal>-array</> option is given, the column values are
        instead stored into the named associative array, with the
        column names used as array indexes.
-->
コマンドが<command>SELECT</>文の場合、その結果得られた列の値は、列名にちなんだ名前のTcl変数に格納されます。
<literal>-array</>オプションが付与された場合は、列の値は指定した名前の連想配列に格納され、その配列のインデックスとして列名が使用されます。
       </para>
       <para>
<!--
        If the command is a <command>SELECT</> statement and no <replaceable>loop-body</>
        script is given, then only the first row of results are stored into
        Tcl variables; remaining rows, if any, are ignored.  No storing occurs
        if the
        query returns no rows.  (This case can be detected by checking the
        result of <function>spi_exec</function>.)  For example:
-->
問い合わせ文が<command>SELECT</>文、かつ、<replaceable>loop-body</>スクリプトが付与されなかった場合、結果のうち最初の行だけがTcl変数に格納されます。
他にも行があったとしても、それらは無視されます。
問い合わせが行を返さなかった場合は、変数への格納は発生しません
（<function>spi_exec</function>の戻り値を検査することで、これを検出することができます）。
以下に例を示します。

<programlisting>
spi_exec "SELECT count(*) AS cnt FROM pg_proc"
</programlisting>

<!--
        will set the Tcl variable <literal>$cnt</> to the number of rows in
        the <structname>pg_proc</> system catalog.
-->
これは、<literal>$cnt</> Tcl変数を、<structname>pg_proc</>システムカタログの行数に設定します。
       </para>
       <para>
<!--
        If the optional <replaceable>loop-body</> argument is given, it is
        a piece of Tcl script that is executed once for each row in the
        query result.  (<replaceable>loop-body</> is ignored if the given
        command is not a <command>SELECT</>.)  The values of the current row's columns
        are stored into Tcl variables before each iteration.  For example:
-->
<replaceable>loop-body</>オプション引数が付与された場合、それは、問い合わせの結果内の行それぞれに対して一度だけ実行される小さなTclスクリプトです
（<replaceable>loop-body</>は<command>SELECT</>以外の問い合わせで付与された場合は無視されます）。
処理中の行の列値は、各繰り返しの前にTcl変数に格納されます。
以下に例を示します。

<programlisting>
spi_exec -array C "SELECT * FROM pg_class" {
    elog DEBUG "have table $C(relname)"
}
</programlisting>

<!--
        will print a log message for every row of <literal>pg_class</>.  This
        feature works similarly to other Tcl looping constructs; in
        particular <literal>continue</> and <literal>break</> work in the
        usual way inside the loop body.
-->
これは、<literal>pg_class</>の各行に対してログメッセージを出力します。
この機能は他のTclの繰り返し構文でも同様に動作します。
特にループ本体内の<literal>continue</>と<literal>break</>は通常通り動作します。
       </para>
       <para>
<!--
        If a column of a query result is null, the target
        variable for it is <quote>unset</> rather than being set.
-->
問い合わせの結果、列がNULLであった場合、対象となる変数は代入されずに、<quote>未設定状態</>になります。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>spi_prepare</function> <replaceable>query</replaceable> <replaceable>typelist</replaceable></term>
      <listitem>
       <para>
<!--
        Prepares and saves a query plan for later execution.  The
        saved plan will be retained for the life of the current
        session.<indexterm><primary>preparing a query</>
        <secondary>in PL/Tcl</></>
-->
後の実行のために問い合わせ計画の準備、保存を行います。
保存された計画は現在のセッションが終了するまで保持されます。
<indexterm><primary>問い合わせの準備</><secondary>PL/Tclにおける</></>
       </para>
       <para>
<!--
        The query can use parameters, that is, placeholders for
        values to be supplied whenever the plan is actually executed.
        In the query string, refer to parameters
        by the symbols <literal>$1</literal> ... <literal>$<replaceable>n</replaceable></literal>.
        If the query uses parameters, the names of the parameter types
        must be given as a Tcl list.  (Write an empty list for
        <replaceable>typelist</replaceable> if no parameters are used.)
-->
問い合わせはパラメータ、つまり、計画が実際に実行される時に常に与えられる値用のプレースホルダを持つことができます。
問い合わせ文字列の中では、<literal>$1</literal> ... <literal>$<replaceable>n</replaceable></literal>というシンボルを使用して引数を参照してください。
問い合わせがパラメータを使用する場合、Tclのリストとしてパラメータの型名を指定する必要があります。
（パラメータを使用しない場合は<replaceable>typelist</replaceable>には空のリストを指定してください。）
       </para>
       <para>
<!--
        The return value from <function>spi_prepare</function> is a query ID
        to be used in subsequent calls to <function>spi_execp</function>. See
        <function>spi_execp</function> for an example.
-->
<function>spi_prepare</function>の戻り値は問い合わせIDです。
このIDは後に<function>spi_execp</function>を呼び出す時に使用されます。
使用例については<function>spi_execp</function>を参照してください。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal><function>spi_execp</> <optional role="tcl">-count <replaceable>n</replaceable></optional> <optional role="tcl">-array <replaceable>name</replaceable></optional> <optional role="tcl">-nulls <replaceable>string</replaceable></optional> <replaceable>queryid</replaceable> <optional role="tcl"><replaceable>value-list</replaceable></optional> <optional role="tcl"><replaceable>loop-body</replaceable></optional></literal></term>
      <listitem>
       <para>
<!--
        Executes a query previously prepared with <function>spi_prepare</>.
        <replaceable>queryid</replaceable> is the ID returned by
        <function>spi_prepare</>.  If the query references parameters,
        a <replaceable>value-list</replaceable> must be supplied.  This
        is a Tcl list of actual values for the parameters.  The list must be
        the same length as the parameter type list previously given to
        <function>spi_prepare</>.  Omit <replaceable>value-list</replaceable>
        if the query has no parameters.
-->
<function>spi_prepare</>により事前に準備された問い合わせを実行します。
<replaceable>queryid</replaceable>は<function>spi_prepare</>により返されたIDです。
その問い合わせがパラメータを参照する場合、<replaceable>value-list</replaceable>を与える必要があります。
これは、そのパラメータの実際の値を持つTclのリストです。
このリストの長さは、事前に<function>spi_prepare</>で指定した引数型のリストの長さと同じでなければなりません。
問い合わせにパラメータがない場合は、<replaceable>value-list</replaceable>を省略してください。
       </para>
       <para>
<!--
        The optional value for <literal>-nulls</> is a string of spaces and
        <literal>'n'</> characters telling <function>spi_execp</function>
        which of the parameters are null values. If given, it must have exactly the
        same length as the <replaceable>value-list</replaceable>.  If it
        is not given, all the parameter values are nonnull.
-->
<literal>-nulls</>オプションの値は、空白文字と<literal>'n'</>という文字からなる文字列で、<function>spi_execp</function>に対し、どの引数がNULL値かを示します。
指定された場合、その文字列の長さは<replaceable>value-list</replaceable>の長さと正確に一致していなければなりません。
指定されない場合は、すべてのパラメータの値は非NULLです。
       </para>
       <para>
<!--
        Except for the way in which the query and its parameters are specified,
        <function>spi_execp</> works just like <function>spi_exec</>.
        The <literal>-count</>, <literal>-array</>, and
        <replaceable>loop-body</replaceable> options are the same,
        and so is the result value.
-->
問い合わせとそのパラメータをどこで指定するのかという点を除き、<function>spi_execp</>は<function>spi_exec</>と同様に動作します。
<literal>-count</>、<literal>-array</>、<replaceable>loop-body</replaceable>オプションも、そして、結果の値も同じです。
       </para>
       <para>
<!--
        Here's an example of a PL/Tcl function using a prepared plan:
-->
ここで、プリペアド計画を使用した、PL/Tcl関数の例を示します。

<programlisting>
CREATE FUNCTION t1_count(integer, integer) RETURNS integer AS $$
    if {![ info exists GD(plan) ]} {
<!--
        # prepare the saved plan on the first call
-->
        # 最初の呼び出しでは保存する計画を準備します。
        set GD(plan) [ spi_prepare \
                "SELECT count(*) AS cnt FROM t1 WHERE num &gt;= \$1 AND num &lt;= \$2" \
                [ list int4 int4 ] ]
    }
    spi_execp -count 1 $GD(plan) [ list $1 $2 ]
    return $cnt
$$ LANGUAGE pltcl;
</programlisting>

<!--
        We need backslashes inside the query string given to
        <function>spi_prepare</> to ensure that the
        <literal>$<replaceable>n</replaceable></> markers will be passed
        through to <function>spi_prepare</> as-is, and not replaced by Tcl
        variable substitution.
-->
<function>spi_prepare</>に与える問い合わせ文字列の内側では、<literal>$<replaceable>n</replaceable></>記号が確実にそのまま<function>spi_prepare</>に渡され、Tcl変数の代入による置き換えが起こらないようにバックスラッシュが必要です。

       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>
       <function>spi_lastoid</>
       <indexterm>
        <primary>spi_lastoid</primary>
<!--
        <secondary>in PL/Tcl</secondary>
-->
        <secondary>PL/Tclにおける</secondary>
       </indexterm>
      </term>
      <listitem>
       <para>
<!--
        Returns the OID of the row inserted by the last
        <function>spi_exec</> or <function>spi_execp</>, if the
        command was a single-row <command>INSERT</> and the modified
        table contained OIDs.  (If not, you get zero.)
-->
直前の<function>spi_exec</>または<function>spi_execp</>によるコマンドが単一行の<command>INSERT</>文であり、かつ、更新されるテーブルがOIDを持つ場合、そのコマンドによって挿入された行のOIDを返します。
（さもなければ、ゼロを返します。）
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>quote</> <replaceable>string</replaceable></term>
      <listitem>
       <para>
<!--
        Doubles all occurrences of single quote and backslash characters
        in the given string.  This can be used to safely quote strings
        that are to be inserted into SQL commands given
        to <function>spi_exec</function> or
        <function>spi_prepare</function>.
        For example, think about an SQL command string like:
-->
指定された文字列内のすべての単一引用符とバックスラッシュ文字を二重化します。
<function>spi_exec</function>や<function>spi_prepare</function>で与えられたSQL問い合わせに挿入される予定の文字列を安全に引用符付けするために、これを使用することができます。
例えば、以下のような問い合わせ文字列を考えます。

<programlisting>
"SELECT '$val' AS ret"
</programlisting>

<!--
        where the Tcl variable <literal>val</> actually contains
        <literal>doesn't</literal>. This would result
        in the final command string:
-->
ここで、<literal>val</> Tcl変数に<literal>doesn't</literal>が実際に含まれているものとします。
これは最終的に以下の問い合わせ文字列になってしまいます。

<programlisting>
SELECT 'doesn't' AS ret
</programlisting>

<!--
        which would cause a parse error during
        <function>spi_exec</function> or
        <function>spi_prepare</function>.
        To work properly, the submitted command should contain:
-->
これでは、<function>spi_exec</function>または<function>spi_prepare</function>の実行中に解析エラーが発生してしまいます。
正しく稼動させるには、実行したい問い合わせは以下のようにしなければなりません。

<programlisting>
SELECT 'doesn''t' AS ret
</programlisting>

<!--
        which can be formed in PL/Tcl using:
-->
これは、PL/Tclでは以下により形成することができます。

<programlisting>
"SELECT '[ quote $val ]' AS ret"
</programlisting>

<!--
        One advantage of <function>spi_execp</function> is that you don't
        have to quote parameter values like this, since the parameters are never
        parsed as part of an SQL command string.
-->
<function>spi_execp</function>の持つ1つの利点は、パラメータはSQL問い合わせ文字列の一部として解析されることがありませんので、このようにパラメータの値を引用符付けする必要がないことです。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>
       <function>elog</> <replaceable>level</replaceable> <replaceable>msg</replaceable>
       <indexterm>
        <primary>elog</primary>
<!--
        <secondary>in PL/Tcl</secondary>
-->
        <secondary>PL/Tclにおける</secondary>
       </indexterm>
      </term>
      <listitem>
       <para>
<!--
        Emits a log or error message. Possible levels are
        <literal>DEBUG</>, <literal>LOG</>, <literal>INFO</>,
        <literal>NOTICE</>, <literal>WARNING</>, <literal>ERROR</>, and
        <literal>FATAL</>. <literal>ERROR</>
        raises an error condition; if this is not trapped by the surrounding
        Tcl code, the error propagates out to the calling query, causing
        the current transaction or subtransaction to be aborted.  This
        is effectively the same as the Tcl <literal>error</> command.
        <literal>FATAL</> aborts the transaction and causes the current
        session to shut down.  (There is probably no good reason to use
        this error level in PL/Tcl functions, but it's provided for
        completeness.)  The other levels only generate messages of different
        priority levels.
        Whether messages of a particular priority are reported to the client,
        written to the server log, or both is controlled by the
        <xref linkend="guc-log-min-messages"> and
        <xref linkend="guc-client-min-messages"> configuration
        variables. See <xref linkend="runtime-config"> for more
        information.
-->
ログまたはエラーメッセージを発行します。
使用できるレベルは、<literal>DEBUG</>、<literal>LOG</>、<literal>INFO</>、<literal>NOTICE</>、<literal>WARNING</>、<literal>ERROR</>、および<literal>FATAL</>です。
<literal>ERROR</>はエラー状態を発生します。
その上位レベルのTclコードで例外が捕捉されなければ、このエラーは問い合わせ呼び出し処理の外部へ伝播され、その結果、現在のトランザクションもしくはサブトランザクションはアボートされます。
これは実質的にTclの<literal>error</>コマンドと同一です。
<literal>FATAL</>はトランザクションをアボートし、現在のセッションを停止させます。
（PL/Tcl関数においてこのエラーレベルを使用すべき理由はおそらく存在しませんが、完全性のために用意されています。）
他のレベルは、異なる重要度のメッセージを生成するだけです。
<xref linkend="guc-log-min-messages">と<xref linkend="guc-client-min-messages">設定パラメータは、特定の重要度のメッセージをクライアントに報告するか、サーバのログに書き出すか、あるいはその両方かを制御します。
詳細については<xref linkend="runtime-config">を参照してください。
       </para>
      </listitem>
     </varlistentry>

    </variablelist>
    </para>

   </sect1>

   <sect1 id="pltcl-trigger">
<!--
    <title>Trigger Procedures in PL/Tcl</title>
-->
<title>PL/Tclのトリガプロシージャ</title>

    <indexterm>
<!--
     <primary>trigger</primary>
     <secondary>in PL/Tcl</secondary>
-->
     <primary>トリガ</primary>
     <secondary>PL/Tclにおける</secondary>
    </indexterm>

    <para>
<!--
     Trigger procedures can be written in PL/Tcl.
     <productname>PostgreSQL</productname> requires that a procedure that is to be called
     as a trigger must be declared as a function with no arguments
     and a return type of <literal>trigger</>.
-->
トリガプロシージャをPL/Tclで作成することができます。
<productname>PostgreSQL</productname>では、トリガとして呼び出されるプロシージャは、<literal>trigger</>型の戻り値を返す引数のない関数として宣言する必要があります。
    </para>
    <para>
<!--
     The information from the trigger manager is passed to the procedure body
     in the following variables:
-->
トリガマネージャからの情報は、以下の変数内に格納されてプロシージャ本体に渡されます。

     <variablelist>

      <varlistentry>
       <term><varname>$TG_name</varname></term>
       <listitem>
        <para>
<!--
         The name of the trigger from the <command>CREATE TRIGGER</command> statement.
-->
<command>CREATE TRIGGER</command>文によるトリガ名。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><varname>$TG_relid</varname></term>
       <listitem>
        <para>
<!--
         The object ID of the table that caused the trigger procedure
         to be invoked.
-->
そのトリガプロシージャ呼び出しが発生したテーブルのオブジェクトID。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><varname>$TG_table_name</varname></term>
       <listitem>
        <para>
<!--
         The name of the table that caused the trigger procedure
         to be invoked.
-->
そのトリガプロシージャ呼び出しが発生したテーブルの名前。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><varname>$TG_table_schema</varname></term>
       <listitem>
        <para>
<!--
         The schema of the table that caused the trigger procedure
         to be invoked.
-->
そのトリガプロシージャ呼び出しが発生したテーブルのスキーマ。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><varname>$TG_relatts</varname></term>
       <listitem>
        <para>
<!--
         A Tcl list of the table column names, prefixed with an empty list
         element. So looking up a column name in the list with <application>Tcl</>'s
         <function>lsearch</> command returns the element's number starting
         with 1 for the first column, the same way the columns are customarily
         numbered in <productname>PostgreSQL</productname>.  (Empty list
         elements also appear in the positions of columns that have been
         dropped, so that the attribute numbering is correct for columns
         to their right.)
-->
先頭に空のリスト要素を持つ、テーブルの列名のTclリスト。
<application>Tcl</>の<function>lsearch</>コマンドを使用して、そのリストから列名を検索することで、最初の列を1とした要素番号が返されます。
これは、<productname>PostgreSQL</productname>での通常の列の番号付けと同じです。
（また空のリスト要素は、右側の列の属性番号を正しくするために、削除された列の位置に現れます。）
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><varname>$TG_when</varname></term>
       <listitem>
        <para>
<!--
         The string <literal>BEFORE</>, <literal>AFTER</>, or
         <literal>INSTEAD OF</>, depending on the type of trigger event.
-->
トリガイベントの種類に応じた、<literal>BEFORE</>、<literal>AFTER</>または<literal>INSTEAD OF</>という文字列。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><varname>$TG_level</varname></term>
       <listitem>
        <para>
<!--
         The string <literal>ROW</> or <literal>STATEMENT</> depending on the
         type of trigger event.
-->
トリガイベントの種類に応じた、<literal>ROW</>または<literal>STATEMENT</>という文字列。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><varname>$TG_op</varname></term>
       <listitem>
        <para>
<!--
         The string <literal>INSERT</>, <literal>UPDATE</>,
         <literal>DELETE</>, or <literal>TRUNCATE</> depending on the type of
         trigger event.
-->
トリガイベントの種類に応じた、<literal>INSERT</>、<literal>UPDATE</>、<literal>DELETE</>、または<literal>TRUNCATE</>の文字列。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><varname>$NEW</varname></term>
       <listitem>
        <para>
<!--
         An associative array containing the values of the new table
         row for <command>INSERT</> or <command>UPDATE</> actions, or
         empty for <command>DELETE</>.  The array is indexed by column
         name.  Columns that are null will not appear in the array.
         This is not set for statement-level triggers.
-->
<command>INSERT</>/<command>UPDATE</>動作の場合は新しいテーブル行の値を、<command>DELETE</>動作の場合は空を持つ連想配列。
配列のインデックスは列名です。
NULLの列はこの配列内には現れません。
文レベルのトリガに対しては設定されません。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><varname>$OLD</varname></term>
       <listitem>
        <para>
<!--
         An associative array containing the values of the old table
         row for <command>UPDATE</> or <command>DELETE</> actions, or
         empty for <command>INSERT</>.  The array is indexed by column
         name.  Columns that are null will not appear in the array.
         This is not set for statement-level triggers.
-->
<command>UPDATE</>/<command>DELETE</>動作の場合は古いテーブル行の値を、<command>INSERT</>動作の場合は空を持つ連想配列。
配列のインデックスは列名です。
NULLの列はこの配列内には現れません。
文レベルのトリガに対しては設定されません。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><varname>$args</varname></term>
       <listitem>
        <para>
<!--
         A Tcl list of the arguments to the procedure as given in the
         <command>CREATE TRIGGER</command> statement. These arguments are also accessible as
         <literal>$1</literal> ... <literal>$<replaceable>n</replaceable></literal> in the procedure body.
-->
<command>CREATE TRIGGER</command>文で指定された、プロシージャへの引数のTclリスト。
この引数は、プロシージャ本体から<literal>$1</literal> ... <literal>$<replaceable>n</replaceable></literal>としてもアクセスすることができます。
        </para>
       </listitem>
      </varlistentry>

     </variablelist>
    </para>

    <para>
<!--
     The return value from a trigger procedure can be one of the strings
     <literal>OK</> or <literal>SKIP</>, or a list as returned by the
     <literal>array get</> Tcl command. If the return value is <literal>OK</>,
     the operation (<command>INSERT</>/<command>UPDATE</>/<command>DELETE</>) that fired the trigger will proceed
     normally. <literal>SKIP</> tells the trigger manager to silently suppress
     the operation for this row. If a list is returned, it tells PL/Tcl to
     return a modified row to the trigger manager. This is only meaningful
     for row-level <literal>BEFORE</> <command>INSERT</> or <command>UPDATE</>
     triggers for which the modified row will be inserted instead of the one
     given in <varname>$NEW</>; or for row-level <literal>INSTEAD OF</>
     <command>INSERT</> or <command>UPDATE</> triggers where the returned row
     is used to support <command>INSERT RETURNING</> and
     <command>UPDATE RETURNING</> commands. The return value is ignored for
     other types of triggers.
-->
トリガプロシージャからの戻り値は、<literal>OK</>という文字列、<literal>SKIP</>という文字列、<literal>array get</> Tclコマンドによって返されるリストの内の1つを取ることができます。
戻り値が<literal>OK</>の場合、トリガを発行した操作（<command>INSERT</>/<command>UPDATE</>/<command>DELETE</>）は正常に処理されます。
<literal>SKIP</>はトリガマネージャにこの行に対する操作を何も出力せずに中止するように通知します。
リストが返された場合は、PL/Tclに対し、変更した行を挿入するようにトリガマネージャに返すことを通知します。
これは、<varname>$NEW</>内で与えられる行ではなく変更された行が挿入される、行レベルの<literal>BEFORE</> <command>INSERT</>または<command>UPDATE</>トリガ、または、返される行が<command>INSERT RETURNING</>および<command>UPDATE RETURNING</>コマンドをサポートするために使用される、行レベルの<literal>INSTEAD OF</> <command>INSERT</>または<command>UPDATE</>トリガでのみ有意です。
この他の種類のトリガでは戻り値は無視されます。
    </para>

    <para>
<!--
     Here's a little example trigger procedure that forces an integer value
     in a table to keep track of the number of updates that are performed on the
     row. For new rows inserted, the value is initialized to 0 and then
     incremented on every update operation.
-->
ここで、テーブル内の整数値としてその行に対する更新数を記録させる、小さめのトリガプロシージャの例を示します。
新規の行が挿入された場合は、その値はゼロに初期化され、その後の各更新操作時に1が加算されます。

<programlisting>
CREATE FUNCTION trigfunc_modcount() RETURNS trigger AS $$
    switch $TG_op {
        INSERT {
            set NEW($1) 0
        }
        UPDATE {
            set NEW($1) $OLD($1)
            incr NEW($1)
        }
        default {
            return OK
        }
    }
    return [array get NEW]
$$ LANGUAGE pltcl;

CREATE TABLE mytab (num integer, description text, modcnt integer);

CREATE TRIGGER trig_mytab_modcount BEFORE INSERT OR UPDATE ON mytab
    FOR EACH ROW EXECUTE PROCEDURE trigfunc_modcount('modcnt');
</programlisting>

<!--
     Notice that the trigger procedure itself does not know the column
     name; that's supplied from the trigger arguments.  This lets the
     trigger procedure be reused with different tables.
-->
トリガプロシージャ自身は列名を認識していない点に注目してください。
これはトリガの引数として与えられます。
これにより、このトリガプロシージャを別のテーブルで再利用することができます。
    </para>
   </sect1>

   <sect1 id="pltcl-event-trigger">
<!--
    <title>Event Trigger Procedures in PL/Tcl</title>
-->
    <title>PL/Tclにおけるイベントトリガプロシージャ</title>

    <indexterm>
     <primary>event trigger</primary>
<!--
     <secondary>in PL/Tcl</secondary>
-->
     <secondary>PL/Tclにおける</secondary>
    </indexterm>

    <para>
<!--
     Event trigger procedures can be written in PL/Tcl.
     <productname>PostgreSQL</productname> requires that a procedure that is
     to be called as an event trigger must be declared as a function with no
     arguments and a return type of <literal>event_trigger</>.
-->
イベントトリガプロシージャをPL/Tclで作成することができます。
<productname>PostgreSQL</productname>では、イベントトリガとして呼び出されるプロシージャは、<literal>event_trigger</>型の戻り値を返す引数のない関数として宣言する必要があります。
    </para>
    <para>
<!--
     The information from the trigger manager is passed to the procedure body
     in the following variables:
-->
トリガマネージャからの情報は、以下の変数内に格納されてプロシージャ本体に渡されます。

     <variablelist>

      <varlistentry>
       <term><varname>$TG_event</varname></term>
       <listitem>
        <para>
<!--
         The name of the event the trigger is fired for.
-->
トリガが発行されたイベント名
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><varname>$TG_tag</varname></term>
       <listitem>
        <para>
<!--
         The command tag for which the trigger is fired.
-->
トリガが発行されたコマンドタグ
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>

    <para>
<!--
     The return value of the trigger procedure is ignored.
-->
トリガプロシージャの戻り値は無視されます。
    </para>

    <para>
<!--
     Here's a little example event trigger procedure that simply raises
     a <literal>NOTICE</literal> message each time a supported command is
     executed:
-->
サポートするコマンドが実行される度に、単に<literal>NOTICE</literal>メッセージを発行するイベントトリガプロシージャの例を、以下に示します。

<programlisting>
CREATE OR REPLACE FUNCTION tclsnitch() RETURNS event_trigger AS $$
  elog NOTICE "tclsnitch: $TG_event $TG_tag"
$$ LANGUAGE pltcl;

CREATE EVENT TRIGGER tcl_a_snitch ON ddl_command_start EXECUTE PROCEDURE tclsnitch();
</programlisting>
    </para>
   </sect1>

   <sect1 id="pltcl-unknown">
<!--
       <title>Modules and the <function>unknown</> Command</title>
-->
<title>モジュールと<function>unknown</>コマンド</title>
       <para>
<!--
        PL/Tcl has support for autoloading Tcl code when used.
        It recognizes a special table, <literal>pltcl_modules</>, which
        is presumed to contain modules of Tcl code.  If this table
        exists, the module <literal>unknown</> is fetched from the table
        and loaded into the Tcl interpreter immediately before the first
        execution of a PL/Tcl function in a database session.  (This
        happens separately for each Tcl interpreter, if more than one is
        used in a session; see <xref linkend="pltcl-global">.)
-->
PL/Tclでは、使用時に自動的にTclのコードを読み込む機能があります。
これは、Tclコードのモジュールを含むと仮定される<literal>pltcl_modules</>という特殊なテーブルを認識します。
このテーブルが存在する場合、そのテーブルから<literal>unknown</>モジュールが取り出され、データベースセッション内でPL/Tclが最初に実行される直前にTclインタプリタに読み込まれます。
（セッション内で複数のインタプリタが使用される場合、これは個々のTclインタプリタそれぞれで起こります。<xref linkend="pltcl-global">を参照してください。）
       </para>
       <para>
<!--
        While the <literal>unknown</> module could actually contain any
        initialization script you need, it normally defines a Tcl
        <function>unknown</> procedure that is invoked whenever Tcl does
        not recognize an invoked procedure name.  <application>PL/Tcl</>'s standard version
        of this procedure tries to find a module in <literal>pltcl_modules</>
        that will define the required procedure.  If one is found, it is
        loaded into the interpreter, and then execution is allowed to
        proceed with the originally attempted procedure call.  A
        secondary table <literal>pltcl_modfuncs</> provides an index of
        which functions are defined by which modules, so that the lookup
        is reasonably quick.
-->
実際、<literal>unknown</>モジュールには必要な任意の初期化コードを含めることができますが、通常は、そこにTcl <quote>unknown</>プロシージャを定義します。
このプロシージャはTclが呼び出されたプロシージャ名を認識できなかった場合に常に呼び出されます。
このプロシージャの<application>PL/Tcl</>標準バージョンでは、必要なプロシージャを定義している<literal>pltcl_modules</>からのモジュール検索を試みます。
プロシージャが検出された場合、インタプリタに読み込まれ、その後、元々試みられたプロシージャ呼び出しを実行することが許されます。
二次的な<literal>pltcl_modfuncs</>テーブルは、どの関数がどのモジュールで定義されているかに関するインデックスを提供します。
これにより検索がかなり高速になります。
       </para>
       <para>
<!--
        The <productname>PostgreSQL</productname> distribution includes
        support scripts to maintain these tables:
        <command>pltcl_loadmod</>, <command>pltcl_listmod</>,
        <command>pltcl_delmod</>, as well as source for the standard
        <literal>unknown</> module in <filename>share/unknown.pltcl</>.  This module
        must be loaded
        into each database initially to support the autoloading mechanism.
-->
<productname>PostgreSQL</productname>の配布には、これらのテーブル管理用のサポートスクリプト、<command>pltcl_loadmod</>、<command>pltcl_listmod</>および<command>pltcl_delmod</>が含まれています。
同様に標準の<literal>unknown</>モジュールのソースが<filename>share/unknown.pltcl</>に含まれています。
自動読み込み機構をサポートさせるためには、あらかじめ各データベースにこのモジュールを読み込ませる必要があります。
       </para>
       <para>
<!--
        The tables <literal>pltcl_modules</> and <literal>pltcl_modfuncs</>
        must be readable by all, but it is wise to make them owned and
        writable only by the database administrator.  As a security
        precaution, PL/Tcl will ignore <literal>pltcl_modules</> (and thus,
        not attempt to load the <literal>unknown</> module) unless it is
        owned by a superuser.  But update privileges on this table can be
        granted to other users, if you trust them sufficiently.
-->
<literal>pltcl_modules</>および<literal>pltcl_modfuncs</>テーブルは全ユーザから読み取り可能でなければなりません。
しかし、その所有者をデータベース管理者とし、データベース管理者のみが書き込み可能とする方が良いでしょう。
セキュリティ対策としてPL/Tclは<literal>pltcl_modules</>をスーパーユーザが所有していない限りそれを無視します(このため<literal>unknown</>モジュールの読み込みを行いません)。
しかし、十分信頼できるのであればこのテーブル上の更新権限を他のユーザに付与することができます。
       </para>
   </sect1>

   <sect1 id="pltcl-procnames">
<!--
    <title>Tcl Procedure Names</title>
-->
<title>Tclプロシージャ名</title>

    <para>
<!--
     In <productname>PostgreSQL</productname>, the same function name can be used for
     different function definitions as long as the number of arguments or their types
     differ. Tcl, however, requires all procedure names to be distinct.
     PL/Tcl deals with this by making the internal Tcl procedure names contain
     the object
     ID of the function from the system table <structname>pg_proc</> as part of their name. Thus,
     <productname>PostgreSQL</productname> functions with the same name
     and different argument types will be different Tcl procedures, too.  This
     is not normally a concern for a PL/Tcl programmer, but it might be visible
     when debugging.
-->
<productname>PostgreSQL</productname>では、その関数の引数の数または引数の型が異なっていれば、同じ関数名を異なる関数定義に使用することが可能です。
しかし、Tclではプロシージャ名の重複は許されません。
PL/Tclでは、プロシージャ名の一部に<structname>pg_proc</>システムテーブルにあるその関数のオブジェクトIDを持たせた内部的なTclプロシージャ名を作成することでこれに対応しています。
したがって、こういった異なる引数の型を持つ同じ名前の<productname>PostgreSQL</productname>関数は、異なるTclプロシージャになります。
PL/Tclプログラマから見ますと、通常は問題にはなりませんが、デバッグの際に表面に現れます。
    </para>

   </sect1>
 </chapter>
