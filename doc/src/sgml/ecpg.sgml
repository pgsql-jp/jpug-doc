<!-- doc/src/sgml/ecpg.sgml -->

<chapter id="ecpg">
<!--
 <title><application>ECPG</application> - Embedded <acronym>SQL</acronym> in C</title>
-->
 <title><application>ECPG</application> - C言語による埋め込み<acronym>SQL</acronym></title>

<!--
 <indexterm zone="ecpg"><primary>embedded SQL</primary><secondary>in C</secondary></indexterm>
-->
 <indexterm zone="ecpg"><primary>埋め込みSQL</primary><secondary>C言語による</secondary></indexterm>
 <indexterm zone="ecpg"><primary>C</primary></indexterm>
 <indexterm zone="ecpg"><primary>ECPG</primary></indexterm>

 <para>
<!--
  This chapter describes the embedded <acronym>SQL</acronym> package
  for <productname>PostgreSQL</productname>. It was written by
  Linus Tolke (<email>linus@epact.se</email>) and Michael Meskes
  (<email>meskes@postgresql.org</email>). Originally it was written to work with
  <acronym>C</acronym>. It also works with <acronym>C++</acronym>, but
  it does not recognize all <acronym>C++</acronym> constructs yet.
-->
本章では、<productname>PostgreSQL</productname>の埋め込み<acronym>SQL</acronym>パッケージについて説明します。
このパッケージは<acronym>C</acronym>と<acronym>C++</acronym>言語で作成されました。
作者はLinus Tolke（<email>linus@epact.se</email>）とMichael Meskes（<email>meskes@postgresql.org</email>）です。
元々これは<acronym>C</acronym>で動作するように作成されました。
<acronym>C++</acronym>でも動作しますが、<acronym>C++</acronym>の構文すべてはまだ認識できません。
 </para>

 <para>
<!--
  This documentation is quite incomplete.  But since this
  interface is standardized, additional information can be found in
  many resources about SQL.
-->
本書は完全なものではありません。
しかし、このインタフェースは標準化されているので、SQLに関するその他の資料から追加情報を入手できます。
 </para>

 <sect1 id="ecpg-concept">
<!--
  <title>The Concept</title>
-->
  <title>概念</title>

  <para>
<!--
   An embedded SQL program consists of code written in an ordinary
   programming language, in this case C, mixed with SQL commands in
   specially marked sections.  To build the program, the source code (<filename>*.pgc</filename>)
   is first passed through the embedded SQL preprocessor, which converts it
   to an ordinary C program (<filename>*.c</filename>), and afterwards it can be processed by a C
   compiler.  (For details about the compiling and linking see <xref linkend="ecpg-process">).
   Converted ECPG applications call functions in the libpq library
   through the embedded SQL library (ecpglib), and communicate with
   the PostgreSQL server using the normal frontend-backend protocol.
-->
埋め込みSQLプログラムは通常のプログラミング言語（ここではC）で記述されたコードで、特別にマークされたセクション内のSQLコマンドとともに使用されます。
このプログラムを構築するには、まずソースコード (<filename>*.pgc</filename>) を埋め込みSQLプリプロセッサに渡します。
ソースコードは、プリプロセッサによって通常のCプログラム (<filename>*.c</filename>) に変換され、その後Cコンパイラによって処理されます。(コンパイルとリンクの詳細については <xref linkend="ecpg-process"> を参照してください)
変換されたECPGアプリケーションは、libpqライブラリにある関数を埋め込みSQLライブラリ (ecpglib) を介して呼び出し、通常のフロントエンド・バックエンドプロトコルを使ってPostgreSQLサーバと通信します。
  </para>

  <para>
<!--
   Embedded <acronym>SQL</acronym> has advantages over other methods
   for handling <acronym>SQL</acronym> commands from C code. First, it
   takes care of the tedious passing of information to and from
   variables in your <acronym>C</acronym> program.  Second, the SQL
   code in the program is checked at build time for syntactical
   correctness.  Third, embedded <acronym>SQL</acronym> in C is
   specified in the <acronym>SQL</acronym> standard and supported by
   many other <acronym>SQL</acronym> database systems.  The
   <productname>PostgreSQL</> implementation is designed to match this
   standard as much as possible, and it is usually possible to port
   embedded <acronym>SQL</acronym> programs written for other SQL
   databases to <productname>PostgreSQL</productname> with relative
   ease.
-->
Cコードから<acronym>SQL</acronym>コマンドを扱う場合は、埋め込み<acronym>SQL</acronym>の方が他の手法よりも有効です。
まず、埋め込みSQLは<acronym>C</acronym>プログラムの変数との面倒な双方間の情報移行を処理してくれます。
さらに、プログラム内のSQLコードは構築時に正確な構文になっているかどうか検査されます。
また、C言語での埋め込み<acronym>SQL</acronym>は標準SQLで既に定義されており、他の様々な<acronym>SQL</acronym>データベースシステムでサポートされています。
<productname>PostgreSQL</>の実装は可能な限りこの標準に準拠するよう設計されています。
また通常の場合、他のSQLデータベース用に作成された埋め込み<acronym>SQL</acronym>プログラムを比較的簡単に<productname>PostgreSQL</productname>へ移植することができます。
  </para>

  <para>
<!--
   As already stated, programs written for the embedded
   <acronym>SQL</acronym> interface are normal C programs with special
   code inserted to perform database-related actions.  This special
   code always has the form:
-->
先に述べた通り、埋め込み<acronym>SQL</acronym>インタフェース用のプログラムは、通常のCプログラムに、データベース関連処理を行うための特別なコードを加えたものです。
この特別なコードは、常に、次のような形式になっています。
<programlisting>
EXEC SQL ...;
</programlisting>
<!--
   These statements syntactically take the place of a C statement.
   Depending on the particular statement, they can appear at the
   global level or within a function.  Embedded
   <acronym>SQL</acronym> statements follow the case-sensitivity rules of
   normal <acronym>SQL</acronym> code, and not those of C. Also they allow nested
   C-style comments that are part of the SQL standard. The C part of the
   program, however, follows the C standard of not accepting nested comments.
-->
このSQL文は、構文上でC言語の文の置き換えとなります。
SQL文によりますが、グローバルレベル、または関数内で記述することができます。
埋め込み<acronym>SQL</acronym>文における大文字小文字の区別の有無は、Cコードではなく、通常の<acronym>SQL</acronym>コードの規則に従います。
また、SQL標準の部分にある入れ子のC形式のコメントを許します。
しかし、プログラムのCの部分では、入れ子のコメントを受け付けないというC標準に従います。
  </para>

  <para>
<!--
   The following sections explain all the embedded SQL statements.
-->
以下の節で、すべての埋め込みSQL文について説明します。
  </para>
 </sect1>

 <sect1 id="ecpg-connect">
<!--
  <title>Managing Database Connections</title>
-->
  <title>データベース接続の管理</title>

  <para>
<!--
   This section describes how to open, close, and switch database
   connections.
-->
この節では、データベース接続の開始、終了、および切り替え方について解説します。
  </para>

  <sect2 id="ecpg-connecting">
<!--
   <title>Connecting to the Database Server</title>
-->
   <title>データベースサーバへの接続</title>

  <para>
<!--
   One connects to a database using the following statement:
-->
以下のSQL文を使用して、データベースへ接続します。
<programlisting>
EXEC SQL CONNECT TO <replaceable>target</replaceable> <optional>AS <replaceable>connection-name</replaceable></optional> <optional>USER <replaceable>user-name</replaceable></optional>;
</programlisting>
<!--
   The <replaceable>target</replaceable> can be specified in the
   following ways:
-->
<replaceable>target</replaceable>は以下の方法で指定されます。

   <itemizedlist>
    <listitem>
     <simpara>
      <literal><replaceable>dbname</><optional>@<replaceable>hostname</></optional><optional>:<replaceable>port</></optional></literal>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <literal>tcp:postgresql://<replaceable>hostname</><optional>:<replaceable>port</></optional><optional>/<replaceable>dbname</></optional><optional>?<replaceable>options</></optional></literal>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <literal>unix:postgresql://<replaceable>hostname</><optional>:<replaceable>port</></optional><optional>/<replaceable>dbname</></optional><optional>?<replaceable>options</></optional></literal>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
<!--
      an SQL string literal containing one of the above forms
-->
上の形式のいずれかを含むSQL文字列リテラル。
     </simpara>
    </listitem>

    <listitem>
     <simpara>
<!--
      a reference to a character variable containing one of the above forms (see examples)
-->
上の形式のいずれかを含む文字変数への参照。
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <literal>DEFAULT</literal>
     </simpara>
    </listitem>
   </itemizedlist>

<!--
   If you specify the connection target literally (that is, not
   through a variable reference) and you don't quote the value, then
   the case-insensitivity rules of normal SQL are applied.  In that
   case you can also double-quote the individual parameters separately
   as needed.  In practice, it is probably less error-prone to use a
   (single-quoted) string literal or a variable reference.  The
   connection target <literal>DEFAULT</literal> initiates a connection
   to the default database under the default user name.  No separate
   user name or connection name can be specified in that case.
-->
接続対象をリテラル（つまり、変数を参照しない形）で指定し、その値を引用符でくくらなかった場合、大文字小文字の区別に関して通常のSQLの規則が適用されます。
また、この場合、必要に応じて個々のパラメータを二重引用符で別々にくくることもできます。
実際には、おそらく（単一引用符でくくられた）文字列リテラルもしくは変数の参照を使用した方がエラーをより防止することができます。
<literal>DEFAULT</literal>接続対象は、デフォルトデータベース、デフォルトのユーザ名で接続を初期化します。
この場合は、ユーザ名と接続名を分けて指定することができません。
  </para>

  <para>
<!--
   There are also different ways to specify the user name:
-->
ユーザ名を指定するには、別の方法もあります。

   <itemizedlist>
    <listitem>
     <simpara>
      <literal><replaceable>username</replaceable></literal>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <literal><replaceable>username</replaceable>/<replaceable>password</replaceable></literal>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <literal><replaceable>username</replaceable> IDENTIFIED BY <replaceable>password</replaceable></literal>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <literal><replaceable>username</replaceable> USING <replaceable>password</replaceable></literal>
     </simpara>
    </listitem>
   </itemizedlist>

<!--
   As above, the parameters <replaceable>username</replaceable> and
   <replaceable>password</replaceable> can be an SQL identifier, an
   SQL string literal, or a reference to a character variable.
-->
これまで同様、<replaceable>username</replaceable>と<replaceable>password</replaceable>は、SQL識別子、SQL文字列リテラル、文字型変数への参照を取ることができます。
  </para>

  <para>
<!--
   The <replaceable>connection-name</replaceable> is used to handle
   multiple connections in one program.  It can be omitted if a
   program uses only one connection.  The most recently opened
   connection becomes the current connection, which is used by default
   when an SQL statement is to be executed (see later in this
   chapter).
-->
1つのプログラム内で複数の接続を処理する場合には、<replaceable>connection-name</replaceable>を使用します。
プログラムで1つしか接続を使わない場合は省略して構いません。
最も最近に開かれた接続が現在の接続になり、SQL文を実行しようとする時にデフォルトでこの接続が使用されます（本章の後で説明します）。
  </para>

  <para>
<!--
   Here are some examples of <command>CONNECT</command> statements:
-->
以下に<command>CONNECT</command>文について、数例を示します。
<programlisting>
EXEC SQL CONNECT TO mydb@sql.mydomain.com;

EXEC SQL CONNECT TO unix:postgresql://sql.mydomain.com/mydb AS myconnection USER john;

EXEC SQL BEGIN DECLARE SECTION;
const char *target = "mydb@sql.mydomain.com";
const char *user = "john";
const char *passwd = "secret";
EXEC SQL END DECLARE SECTION;
 ...
EXEC SQL CONNECT TO :target USER :user USING :passwd;
<!--
/* or EXEC SQL CONNECT TO :target USER :user/:passwd; */
-->
/* もしくは EXEC SQL CONNECT TO :target USER :user/:passwd; */
</programlisting>
<!--
   The last form makes use of the variant referred to above as
   character variable reference.  You will see in later sections how C
   variables can be used in SQL statements when you prefix them with a
   colon.
-->
最後の形式では、文字変数参照として上を参照する変数を使用しています。
後の節で、接頭辞にコロンを持つ場合のSQL文内でのC変数の使用方法について説明します。
  </para>

  <para>
<!--
   Be advised that the format of the connection target is not
   specified in the SQL standard.  So if you want to develop portable
   applications, you might want to use something based on the last
   example above to encapsulate the connection target string
   somewhere.
-->
接続対象の書式は標準SQLでは規定されていないことに注意してください。
そのため、移植可能なアプリケーションを開発したいのであれば、上の例の最後の方法を基にして、接続対象文字列をどこかにカプセル化してください。
  </para>
  </sect2>

  <sect2 id="ecpg-set-connection">
<!--
   <title>Choosing a Connection</title>
-->
   <title>接続の選択</title>

  <para>
<!--
   SQL statements in embedded SQL programs are by default executed on
   the current connection, that is, the most recently opened one.  If
   an application needs to manage multiple connections, then there are
   two ways to handle this.
-->
前節で示したSQL文は現在の接続、つまり、最も最近に開いた接続上で実行されます。
複数の接続を管理する必要があるアプリケーションでは、これを処理する2つの方法があります。
  </para>

  <para>
<!--
   The first option is to explicitly choose a connection for each SQL
   statement, for example:
-->
1つ目の選択肢は、各SQL文で明示的に接続を選択することです。
以下に例を示します。
<programlisting>
EXEC SQL AT <replaceable>connection-name</replaceable> SELECT ...;
</programlisting>
<!--
   This option is particularly suitable if the application needs to
   use several connections in mixed order.
-->
アプリケーションが複数の接続を不特定な順番で使用する必要がある場合、この選択肢は特に適しています。
  </para>

  <para>
<!--
   If your application uses multiple threads of execution, they cannot share a
   connection concurrently. You must either explicitly control access to the connection
   (using mutexes) or use a connection for each thread. If each thread uses its own connection,
   you will need to use the AT clause to specify which connection the thread will use.
-->
アプリケーションの実行に複数スレッドを使用する場合、スレッド間で接続を同時に共有できません。
接続へのアクセスを（ミューテクスを使用して）明示的に制御するか、または各スレッド用の接続を使用するかを行わなければなりません。
各スレッドが個別の接続を使用する場合、AT句を使用してそのスレッドが使用する接続を指定する必要があります。
  </para>

  <para>
<!--
   The second option is to execute a statement to switch the current
   connection.  That statement is:
-->
2番目の選択肢は、現在の接続を切り替えるSQL文を実行することです。
以下のSQL文です。
<programlisting>
EXEC SQL SET CONNECTION <replaceable>connection-name</replaceable>;
</programlisting>
<!--
   This option is particularly convenient if many statements are to be
   executed on the same connection.  It is not thread-aware.
-->
多くのSQL文を同一接続に対して使用する場合、この選択肢は特に便利です。
これはスレッドを考慮していません。
  </para>

  <para>
<!--
   Here is an example program managing multiple database connections:
-->
以下に複数のデータベースコネクションを管理しているプログラムの例を示します。
<programlisting><![CDATA[
#include <stdio.h>

EXEC SQL BEGIN DECLARE SECTION;
    char dbname[1024];
EXEC SQL END DECLARE SECTION;

int
main()
{
    EXEC SQL CONNECT TO testdb1 AS con1 USER testuser;
    EXEC SQL CONNECT TO testdb2 AS con2 USER testuser;
    EXEC SQL CONNECT TO testdb3 AS con3 USER testuser;

]]><!--
    /* This query would be executed in the last opened database "testdb3". */
--><![CDATA[
    /* この問い合わせは最後に開いたデータベース"testdb3"で実行される。 */
    EXEC SQL SELECT current_database() INTO :dbname;
    printf("current=%s (should be testdb3)\n", dbname);

]]><!--
    /* Using "AT" to run a query in "testdb2" */
--><![CDATA[
    /* "testdb2"で問い合わせを実行するには"AT"を使う */
    EXEC SQL AT con2 SELECT current_database() INTO :dbname;
    printf("current=%s (should be testdb2)\n", dbname);

]]><!--
    /* Switch the current connection to "testdb1". */
--><![CDATA[
    /* 現在の接続を"testdb1"に切り替える。 */
    EXEC SQL SET CONNECTION con1;

    EXEC SQL SELECT current_database() INTO :dbname;
    printf("current=%s (should be testdb1)\n", dbname);

    EXEC SQL DISCONNECT ALL;
    return 0;
}
]]></programlisting>

<!--
   This example would produce this output:
-->
   この例は、次のような出力を生成します。
<screen>
current=testdb3 (should be testdb3)
current=testdb2 (should be testdb2)
current=testdb1 (should be testdb1)
</screen>
  </para>
  </sect2>

  <sect2 id="ecpg-disconnect">
<!--
   <title>Closing a Connection</title>
-->
   <title>接続を閉じる</title>

  <para>
<!--
   To close a connection, use the following statement:
-->
接続を閉じるには以下のSQL文を使用します。
<programlisting>
EXEC SQL DISCONNECT <optional><replaceable>connection</replaceable></optional>;
</programlisting>
<!--
   The <replaceable>connection</replaceable> can be specified
   in the following ways:
-->
<replaceable>connection</replaceable>は以下の方法で指定されます。

   <itemizedlist>
    <listitem>
     <simpara>
      <literal><replaceable>connection-name</replaceable></literal>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <literal>DEFAULT</literal>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <literal>CURRENT</literal>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <literal>ALL</literal>
     </simpara>
    </listitem>
   </itemizedlist>

<!--
   If no connection name is specified, the current connection is
   closed.
-->
接続名の指定がなければ、現在の接続が閉じられます。
  </para>

  <para>
<!--
   It is good style that an application always explicitly disconnect
   from every connection it opened.
-->
アプリケーションでは、過去に開いたすべての接続を明示的に閉じることを推奨します。
  </para>
  </sect2>

 </sect1>

 <sect1 id="ecpg-commands">
<!--
  <title>Running SQL Commands</title>
-->
  <title>SQLコマンドの実行</title>

  <para>
<!--
   Any SQL command can be run from within an embedded SQL application.
   Below are some examples of how to do that.
-->
すべてのSQLコマンドは、埋め込みSQLアプリケーション内で実行できます。
以下に例をいくつか示します。
  </para>

  <sect2 id="ecpg-executing">
<!--
   <title>Executing SQL Statements</title>
-->
   <title>SQL文の実行</title>

  <para>
<!--
   Creating a table:
-->
テーブルの作成:
<programlisting>
EXEC SQL CREATE TABLE foo (number integer, ascii char(16));
EXEC SQL CREATE UNIQUE INDEX num1 ON foo(number);
EXEC SQL COMMIT;
</programlisting>
  </para>

  <para>
<!--
   Inserting rows:
-->
行の挿入:
<programlisting>
EXEC SQL INSERT INTO foo (number, ascii) VALUES (9999, 'doodad');
EXEC SQL COMMIT;
</programlisting>
  </para>

  <para>
<!--
   Deleting rows:
-->
行の削除:
<programlisting>
EXEC SQL DELETE FROM foo WHERE number = 9999;
EXEC SQL COMMIT;
</programlisting>
  </para>

  <para>
<!--
   Updates:
-->
行の更新:
<programlisting>
EXEC SQL UPDATE foo
    SET ascii = 'foobar'
    WHERE number = 9999;
EXEC SQL COMMIT;
</programlisting>
  </para>

  <para>
<!--
   <literal>SELECT</literal> statements that return a single result
   row can also be executed using
   <literal>EXEC SQL</literal> directly.  To handle result sets with
   multiple rows, an application has to use a cursor;
   see <xref linkend="ecpg-cursors"> below.  (As a special case, an
   application can fetch multiple rows at once into an array host
   variable; see <xref linkend="ecpg-variables-arrays">.)
-->
   単一の行を返す<literal>SELECT</literal>文は、同様に <literal>EXEC SQL</literal> を用いて直接実行することができます。複数の行を扱うためには、アプリケーションはカーソルを使わなければなりません; <xref linkend="ecpg-cursors"> を参照してください。
(特殊なケースでは、アプリケーションは複数の行をホスト変数の配列に一度に読み込むことができます; <xref linkend="ecpg-variables-arrays"> を参照してください)
  </para>

  <para>
<!--
   Single-row select:
-->
   単一行の検索:
<programlisting>
EXEC SQL SELECT foo INTO :FooBar FROM table1 WHERE ascii = 'doodad';
</programlisting>
  </para>

  <para>
<!--
   Also, a configuration parameter can be retrieved with the
   <literal>SHOW</literal> command:
-->
   同様に、設定パラメータは <literal>SHOW</literal> コマンドによって取得することができます:
<programlisting>
EXEC SQL SHOW search_path INTO :var;
</programlisting>
  </para>

  <para>
<!--
   The tokens of the form
   <literal>:<replaceable>something</replaceable></literal> are
   <firstterm>host variables</firstterm>, that is, they refer to
   variables in the C program.  They are explained in <xref
   linkend="ecpg-variables">.
-->
<literal>:<replaceable>something</replaceable></literal>という形のトークンは<firstterm>ホスト変数</firstterm>です。
つまり、Cプログラム内の変数を参照するものです。
これについては<xref linkend="ecpg-variables">で説明します。
  </para>
  </sect2>

  <sect2 id="ecpg-cursors">
<!--
   <title>Using Cursors</title>
-->
   <title>カーソルの使用</title>

  <para>
<!--
   To retrieve a result set holding multiple rows, an application has
   to declare a cursor and fetch each row from the cursor.  The steps
   to use a cursor are the following: declare a cursor, open it, fetch
   a row from the cursor, repeat, and finally close it.
-->
複数行の結果セットを受け取るためには、アプリケーションはカーソルを定義し、必要に応じてレコードを一行ずつ取り込む必要があります。カーソルを使った処理は、カーソルの宣言、カーソルのオープン、カーソルからのFETCH、カーソルのクローズという流れになります。
  </para>

  <para>
<!--
   Select using cursors:
-->
カーソルを用いたSELECT:
<programlisting>
EXEC SQL DECLARE foo_bar CURSOR FOR
    SELECT number, ascii FROM foo
    ORDER BY ascii;
EXEC SQL OPEN foo_bar;
EXEC SQL FETCH foo_bar INTO :FooBar, DooDad;
...
EXEC SQL CLOSE foo_bar;
EXEC SQL COMMIT;
</programlisting>
  </para>

  <para>
<!--
   For more details about declaration of the cursor,
   see <xref linkend="ecpg-sql-declare">, and
   see <xref linkend="sql-fetch"> for <literal>FETCH</literal> command
   details.
-->
カーソルの宣言の詳細については <xref linkend="ecpg-sql-declare"> を、<literal>FETCH</literal> コマンドの詳細については <xref linkend="sql-fetch"> を参照してください。
  </para>

   <note>
    <para>
<!--
     The ECPG <command>DECLARE</command> command does not actually
     cause a statement to be sent to the PostgreSQL backend.  The
     cursor is opened in the backend (using the
     backend's <command>DECLARE</command> command) at the point when
     the <command>OPEN</command> command is executed.
-->
     ECPGの <command>DECLARE</command> コマンド自身は、PostgreSQLバックエンドに送られるSQL文を実行しません。<command>OPEN</command> コマンドが実行された段階で、バックエンド内部で（<command>DECLARE</command>コマンドで宣言された）カーソルが開かれます。
    </para>
   </note>
  </sect2>

  <sect2 id="ecpg-transactions">
<!--
   <title>Managing Transactions</title>
-->
   <title>トランザクションの管理</title>

  <para>
<!--
   In the default mode, statements are committed only when
   <command>EXEC SQL COMMIT</command> is issued. The embedded SQL
   interface also supports autocommit of transactions (similar to
   <application>psql</>'s default behavior) via the <option>-t</option>
   command-line option to <command>ecpg</command> (see <xref
   linkend="app-ecpg">) or via the <literal>EXEC SQL SET AUTOCOMMIT TO
   ON</literal> statement. In autocommit mode, each command is
   automatically committed unless it is inside an explicit transaction
   block. This mode can be explicitly turned off using <literal>EXEC
   SQL SET AUTOCOMMIT TO OFF</literal>.
-->
デフォルトモードでは、SQL文は<command>EXEC SQL COMMIT</command>が発行されることによってのみコミットされます。
埋め込みSQLインタフェースでも、<command>ecpg</command>コマンド（以下を参照）の<option>-t</option>コマンドラインオプション、あるいは <literal>EXEC SQL SET AUTOCOMMIT TO ON</literal>文によって（<application>psql</>のデフォルトの振舞いに似た）トランザクションの自動コミットをサポートしています。
自動コミットモードでは、問い合わせが明示的なトランザクションブロックの内部にある場合を除き、すべての問い合わせが自動的にコミットされます。
自動コミットモードは、<literal>EXEC SQL SET AUTOCOMMIT TO OFF</literal>を使用して明示的に無効にすることができます。
  </para>

   <para>
<!--
    The following transaction management commands are available:
-->
以下のトランザクション管理コマンドを使用することができます:

    <variablelist>
     <varlistentry>
      <term><literal>EXEC SQL COMMIT</literal></term>
      <listitem>
       <para>
<!--
        Commit an in-progress transaction.
-->
        実行中のトランザクションのコミット。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>EXEC SQL ROLLBACK</literal></term>
      <listitem>
       <para>
<!--
        Roll back an in-progress transaction.
-->
        実行中のトランザクションのロールバック。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>EXEC SQL SET AUTOCOMMIT TO ON</literal></term>
      <listitem>
       <para>
<!--
        Enable autocommit mode.
-->
        自動コミットモードの有効化。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>SET AUTOCOMMIT TO OFF</literal></term>
      <listitem>
       <para>
<!--
        Disable autocommit mode.  This is the default.
-->
        自動コミットモードの無効化。デフォルト状態。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </sect2>

  <sect2 id="ecpg-prepared">
<!--
   <title>Prepared Statements</title>
-->
   <title>プリペアド文</title>

   <para>
<!--
    When the values to be passed to an SQL statement are not known at
    compile time, or the same statement is going to be used many
    times, then prepared statements can be useful.
-->
SQL文に渡す値がコンパイル時に決まらない場合、または同じSQL文を何度も実行する場合、プリペアド文が便利です。
   </para>

   <para>
<!--
    The statement is prepared using the
    command <literal>PREPARE</literal>.  For the values that are not
    known yet, use the
    placeholder <quote><literal>?</literal></quote>:
-->
SQL文は<literal>PREPARE</literal>コマンドを使ってプリペアします。
まだ決まっていない値については、プレースホルダ <quote><literal>?</literal></quote> を使います:
<programlisting>
EXEC SQL PREPARE stmt1 FROM "SELECT oid, datname FROM pg_database WHERE oid = ?";
</programlisting>
   </para>

   <para>
<!--
    If a statement returns a single row, the application can
    call <literal>EXECUTE</literal> after
    <literal>PREPARE</literal> to execute the statement, supplying the
    actual values for the placeholders with a <literal>USING</literal>
    clause:
-->
SQL文が一行のみの結果を返却する場合には、アプリケーションはSQL文を<literal>PREPARE</literal>した後、<literal>USING</literal>を用いてプレースホルダに実際の値を与えて<literal>EXECUTE</literal>を実行することができます。
<programlisting>
EXEC SQL EXECUTE stmt1 INTO :dboid, :dbname USING 1;
</programlisting>
   </para>

   <para>
<!--
    If a statement returns multiple rows, the application can use a
    cursor declared based on the prepared statement.  To bind input
    parameters, the cursor must be opened with
    a <literal>USING</literal> clause:
-->
SQL文が複数の行を返却する場合には、アプリケーションはプリペアド文の宣言に対応したカーソルを利用することができます。
入力パラメータを設定するために、カーソルは<literal>USING</literal>とともに開かれなければなりません:
<programlisting>
EXEC SQL PREPARE stmt1 FROM "SELECT oid,datname FROM pg_database WHERE oid &gt; ?";
EXEC SQL DECLARE foo_bar CURSOR FOR stmt1;

<!--
/* when end of result set reached, break out of while loop */
-->
/* 結果集合の最後に到達したら、whileループから抜ける */
EXEC SQL WHENEVER NOT FOUND DO BREAK;

EXEC SQL OPEN foo_bar USING 100;
...
while (1)
{
    EXEC SQL FETCH NEXT FROM foo_bar INTO :dboid, :dbname;
    ...
}
EXEC SQL CLOSE foo_bar;
</programlisting>
   </para>

   <para>
<!--
    When you don't need the prepared statement anymore, you should
    deallocate it:
-->
プリペアド文をこれ以上必要としなくなったら、解放処理をしなければなりません:
<programlisting>
EXEC SQL DEALLOCATE PREPARE <replaceable>name</replaceable>;
</programlisting>
   </para>

   <para>
<!--
    For more details about <literal>PREPARE</literal>,
    see <xref linkend="ecpg-sql-prepare">. Also
    see <xref linkend="ecpg-dynamic"> for more details about using
    placeholders and input parameters.
-->
    <literal>PREPARE</literal> についての詳細は <xref linkend="ecpg-sql-prepare"> を参照してください。
    また、プレースホルダと入力パラメータの利用についての詳細は <xref linkend="ecpg-dynamic"> を参照してください。
   </para>
  </sect2>
 </sect1>

 <sect1 id="ecpg-variables">
<!--
  <title>Using Host Variables</title>
-->
  <title>ホスト変数の使用</title>

  <para>
<!--
   In <xref linkend="ecpg-commands"> you saw how you can execute SQL
   statements from an embedded SQL program.  Some of those statements
   only used fixed values and did not provide a way to insert
   user-supplied values into statements or have the program process
   the values returned by the query.  Those kinds of statements are
   not really useful in real applications.  This section explains in
   detail how you can pass data between your C program and the
   embedded SQL statements using a simple mechanism called
   <firstterm>host variables</firstterm>. In an embedded SQL program  we
   consider the SQL statements to be <firstterm>guests</firstterm> in the C
   program code which is the <firstterm>host language</firstterm>. Therefore
   the variables of the C program are called <firstterm>host
   variables</firstterm>.
-->
<xref linkend="ecpg-commands">では、埋め込みSQLプログラムでどのようにSQL文を実行するのかについて説明しました。
このSQL文の中には固定値しか使用しないものや、ユーザが指定する値をSQL文の中に挿入する手段を提供しないもの、問い合わせが返す値をプログラムで処理する手段を提供しないものがありました。
この種のSQL文は実際のアプリケーションでは役に立ちません。
本節では、<firstterm>ホスト変数</firstterm>という単純な機構を使用した、Cプログラムと埋め込みSQL文との間でデータをやり取りする方法を詳細に説明します。
埋め込みSQLプログラムでは、SQL文を<firstterm>ホスト言語</firstterm>となるCプログラムコードにおける<firstterm>ゲスト</firstterm>とみなします。
したがって、Cプログラムの変数は<firstterm>ホスト変数</firstterm>と呼ばれます。
  </para>

  <para>
<!--
   Another way to exchange values between PostgreSQL backends and ECPG
   applications is the use of SQL descriptors, described
   in <xref linkend="ecpg-descriptors">.
-->
   PostgreSQLバックエンドとECPGアプリケーションの間で値をやり取りするその他の方法は、 <xref linkend="ecpg-descriptors"> で説明されているSQLデスクリプタを使う方法です。
  </para>

  <sect2 id="ecpg-variables-overview">
<!--
   <title>Overview</title>
-->
   <title>概要</title>

   <para>
<!--
    Passing data between the C program and the SQL statements is
    particularly simple in embedded SQL.  Instead of having the
    program paste the data into the statement, which entails various
    complications, such as properly quoting the value, you can simply
    write the name of a C variable into the SQL statement, prefixed by
    a colon.  For example:
-->
埋め込みSQLにおけるCプログラムとSQL文との間でのデータのやり取りは特に単純です。
値に適切な引用符を付与するといった、様々な複雑な処理を伴う、プログラムにデータを文中に貼り付けさせるという方法はなく、単にSQL文の中に、先頭にコロンを付けたC変数名を書くだけです。
以下に例を示します。
<programlisting>
EXEC SQL INSERT INTO sometable VALUES (:v1, 'foo', :v2);
</programlisting>
<!--
    This statement refers to two C variables named
    <varname>v1</varname> and <varname>v2</varname> and also uses a
    regular SQL string literal, to illustrate that you are not
    restricted to use one kind of data or the other.
-->
このSQL文は、<varname>v1</varname>と<varname>v2</varname>という2つのC変数を参照し、また、通常のSQL文字列リテラルも使用しています。
これは、使用できるデータの種類は1つだけという制限がないことを表しています。
   </para>

   <para>
<!--
    This style of inserting C variables in SQL statements works
    anywhere a value expression is expected in an SQL statement.
-->
SQL文内にCの変数を挿入するこの様式は、SQL文で値式が想定されている所であればどこでも動作します。
   </para>
  </sect2>

  <sect2 id="ecpg-declare-sections">
<!--
   <title>Declare Sections</title>
-->
   <title>宣言セクション</title>

   <para>
<!--
    To pass data from the program to the database, for example as
    parameters in a query, or to pass data from the database back to
    the program, the C variables that are intended to contain this
    data need to be declared in specially marked sections, so the
    embedded SQL preprocessor is made aware of them.
-->
例えば問い合わせ内のパラメータとして、プログラムからデータベースへデータを渡す、もしくは、データベースからプログラムへデータを渡すためには、このようなデータを含むように意図されたC変数を、埋め込みSQLプリプロセッサが管理できるように、特殊な印のついたセクションで宣言する必要があります。
   </para>

   <para>
<!--
    This section starts with:
-->
このセクションは以下で始まります。
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
</programlisting>
<!--
    and ends with:
-->
そして、以下で終わります。
<programlisting>
EXEC SQL END DECLARE SECTION;
</programlisting>
<!--
    Between those lines, there must be normal C variable declarations,
    such as:
-->
この行の間は、以下のような通常のC変数宣言でなければなりません。
<programlisting>
int   x = 4;
char  foo[16], bar[16];
</programlisting>
<!--
    As you can see, you can optionally assign an initial value to the variable.
    The variable's scope is determined by the location of its declaring
    section within the program.
    You can also declare variables with the following syntax which implicitly
    creates a declare section:
-->
見てわかるとおり、省略可能ですが、変数に初期値を代入することができます。
変数のスコープはプログラム内の宣言セクションの場所により決まります。
また、以下のような暗黙的に宣言セクションを生成する構文を使って変数を宣言することもできます。
<programlisting>
EXEC SQL int i = 4;
</programlisting>
<!--
    You can have as many declare sections in a program as you like.
-->
プログラム内に複数の宣言セクションを持たせることができます。
   </para>

   <para>
<!--
    The declarations are also echoed to the output file as normal C
    variables, so there's no need to declare them again.  Variables
    that are not intended to be used in SQL commands can be declared
    normally outside these special sections.
-->
また、宣言は普通のC変数としてそのまま出力ファイルに出力されます。
ですので、これらを再度宣言する必要はありません。
通常、SQLコマンドで使用する予定がない変数はこの特別なセクションの外側で宣言されます。
   </para>

   <para>
<!--
    The definition of a structure or union also must be listed inside
    a <literal>DECLARE</> section. Otherwise the preprocessor cannot
    handle these types since it does not know the definition.
-->
構造体や共用体の定義もまた、<literal>DECLARE</>セクションの内側で表す必要があります。
さもないと、プリプロセッサはその定義が不明であるために、これらの型を扱うことができません。
   </para>
  </sect2>

  <sect2 id="ecpg-retrieving">
<!--
   <title>Retrieving Query Results</title>
-->
   <title>クエリ実行結果の受け取り</title>

   <para>
<!--
    Now you should be able to pass data generated by your program into
    an SQL command.  But how do you retrieve the results of a query?
    For that purpose, embedded SQL provides special variants of the
    usual commands <command>SELECT</command> and
    <command>FETCH</command>.  These commands have a special
    <literal>INTO</literal> clause that specifies which host variables
    the retrieved values are to be stored in.
    <command>SELECT</command> is used for a query that returns only
    single row, and <command>FETCH</command> is used for a query that
    returns multiple rows, using a cursor.
-->
ここまでで、プログラムで生成したデータをSQLコマンドに渡すことができるようになりました。
しかし、どのように問い合わせの結果を取り出すのでしょうか？
この目的のために、埋め込みSQLでは、通常の<command>SELECT</command>と<command>FETCH</command>を派生した、特殊なコマンドを提供しています。
これらのコマンドは特別な<literal>INTO</literal>句を持ち、ここで返された値をどのホスト変数に格納すればよいかを指定します。
<command>SELECT</command> は単一行を返却する問い合わせに使用され、<command>FETCH</command> は複数の行を返却する問い合わせにおいてカーソルととともに使用されます。
   </para>

   <para>
<!--
    Here is an example:
-->
以下にサンプルを示します。
<programlisting>
/*
<!--
 * assume this table:
-->
 * 以下のテーブルを前提とする
 * CREATE TABLE test1 (a int, b varchar(50));
 */

EXEC SQL BEGIN DECLARE SECTION;
int v1;
VARCHAR v2;
EXEC SQL END DECLARE SECTION;

 ...

EXEC SQL SELECT a, b INTO :v1, :v2 FROM test;
</programlisting>
<!--
    So the <literal>INTO</literal> clause appears between the select
    list and the <literal>FROM</literal> clause.  The number of
    elements in the select list and the list after
    <literal>INTO</literal> (also called the target list) must be
    equal.
-->
<literal>INTO</literal>句が選択リストと<literal>FROM</literal>句の間に現れます。
選択リスト内の要素数と<literal>INTO</literal>直後のリスト（目的リストとも呼ばれます）の要素数は等しくなければなりません。
   </para>

   <para>
<!--
    Here is an example using the command <command>FETCH</command>:
-->
以下に<command>FETCH</command>コマンドの使用例を示します。
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
int v1;
VARCHAR v2;
EXEC SQL END DECLARE SECTION;

 ...

EXEC SQL DECLARE foo CURSOR FOR SELECT a, b FROM test;

 ...

do
{
    ...
    EXEC SQL FETCH NEXT FROM foo INTO :v1, :v2;
    ...
} while (...);
</programlisting>
<!--
    Here the <literal>INTO</literal> clause appears after all the
    normal clauses.
-->
ここでは、<literal>INTO</literal>句が通常のすべての句の後ろに現れています。
   </para>

  </sect2>

  <sect2 id="ecpg-variables-type-mapping">
<!--
   <title>Type Mapping</title>
-->
   <title>データ型の対応</title>

   <para>
<!--
    When ECPG applications exchange values between the PostgreSQL
    server and the C application, such as when retrieving query
    results from the server or executing SQL statements with input
    parameters, the values need to be converted between PostgreSQL
    data types and host language variable types (C language data
    types, concretely).  One of the main points of ECPG is that it
    takes care of this automatically in most cases.
-->
    ECPGアプリケーションがPostgreSQLバックエンドとCアプリケーションの間で値をやり取りする際、例えばサーバからクエリの結果を受け取る、または入力パラメータとともにSQL文を実行する場合、それらの値はPostgreSQLのデータ型とホスト言語の変数の型（具体的にはC言語のデータ型）の間で変換される必要があります。
    ECPGの重要な点のひとつは、ほとんどの場合においてECPGがこれらを自動的に扱うということです。
   </para>

   <para>
<!--
    In this respect, there are two kinds of data types: Some simple
    PostgreSQL data types, such as <type>integer</type>
    and <type>text</type>, can be read and written by the application
    directly.  Other PostgreSQL data types, such
    as <type>timestamp</type> and <type>numeric</type> can only be
    accessed through special library functions; see
    <xref linkend="ecpg-special-types">.
-->
    この点において、2つのデータ型があります: いくつかの単純なPostgreSQLのデータ型、<type>integer</type> や <type>text</type> などは、アプリケーションから直接読んだり書いたりすることができます。
    その他のPostgreSQLのデータ型、<type>timestamp</type> や <type>numeric</type> などは、特別なライブラリ関数によってしかアクセスすることができません; <xref linkend="ecpg-special-types"> を参照してください。
   </para>

   <para>
<!--
    <xref linkend="ecpg-datatype-hostvars-table"> shows which PostgreSQL
    data types correspond to which C data types.  When you wish to
    send or receive a value of a given PostgreSQL data type, you
    should declare a C variable of the corresponding C data type in
    the declare section.
-->
<xref linkend="ecpg-datatype-hostvars-table">には、PostgreSQLのどのデータ型がC言語のデータ型に対応するかが示されています。
与えられたPostgreSQLのデータ型へ値を書き込みまたは読み込みしたい場合には、対応するC言語のデータ型の変数を宣言セクションにおいて宣言しなければなりません。
   </para>

   <table id="ecpg-datatype-hostvars-table">
<!--
    <title>Mapping Between PostgreSQL Data Types and C Variable Types</title>
-->
    <title>PostgreSQLデータ型とC言語変数型の対応</title>
    <tgroup cols="2">
     <thead>
      <row>
<!--
       <entry>PostgreSQL data type</entry>
       <entry>Host variable type</entry>
-->
       <entry>PostgreSQLデータ型</entry>
       <entry>ホスト変数型</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry><type>smallint</type></entry>
       <entry><type>short</type></entry>
      </row>

      <row>
       <entry><type>integer</type></entry>
       <entry><type>int</type></entry>
      </row>

      <row>
       <entry><type>bigint</type></entry>
       <entry><type>long long int</type></entry>
      </row>

      <row>
       <entry><type>decimal</type></entry>
<!--
       <entry><type>decimal</type><footnote id="ecpg-datatype-table-fn"><para>This type can only be accessed through special library functions; see <xref linkend="ecpg-special-types">.</para></footnote></entry>
-->
       <entry><type>decimal</type><footnote id="ecpg-datatype-table-fn"><para>この型は特別なライブラリ関数を通してのみアクセスできます; <xref linkend="ecpg-special-types"> を参照。</para></footnote></entry>
      </row>

      <row>
       <entry><type>numeric</type></entry>
       <entry><type>numeric</type><footnoteref linkend="ecpg-datatype-table-fn"></entry>
      </row>

      <row>
       <entry><type>real</type></entry>
       <entry><type>float</type></entry>
      </row>

      <row>
       <entry><type>double precision</type></entry>
       <entry><type>double</type></entry>
      </row>

      <row>
       <entry><type>smallserial</type></entry>
       <entry><type>short</type></entry>
      </row>

      <row>
       <entry><type>serial</type></entry>
       <entry><type>int</type></entry>
      </row>

      <row>
       <entry><type>bigserial</type></entry>
       <entry><type>long long int</type></entry>
      </row>

      <row>
       <entry><type>oid</type></entry>
       <entry><type>unsigned int</type></entry>
      </row>

      <row>
       <entry><type>character(<replaceable>n</>)</type>, <type>varchar(<replaceable>n</>)</type>, <type>text</type></entry>
<!--
       <entry><type>char[<replaceable>n</>+1]</type>, <type>VARCHAR[<replaceable>n</>+1]</type><footnote><para>declared in <filename>ecpglib.h</filename></para></footnote></entry>
-->
       <entry><type>char[<replaceable>n</>+1]</type>, <type>VARCHAR[<replaceable>n</>+1]</type><footnote><para><filename>ecpglib.h</filename> で宣言。</para></footnote></entry>
      </row>

      <row>
       <entry><type>name</type></entry>
       <entry><type>char[NAMEDATALEN]</type></entry>
      </row>

      <row>
       <entry><type>timestamp</type></entry>
       <entry><type>timestamp</type><footnoteref linkend="ecpg-datatype-table-fn"></entry>
      </row>

      <row>
       <entry><type>interval</type></entry>
       <entry><type>interval</type><footnoteref linkend="ecpg-datatype-table-fn"></entry>
      </row>

      <row>
       <entry><type>date</type></entry>
       <entry><type>date</type><footnoteref linkend="ecpg-datatype-table-fn"></entry>
      </row>

      <row>
       <entry><type>boolean</type></entry>
<!--
       <entry><type>bool</type><footnote><para>declared in <filename>ecpglib.h</filename> if not native</para></footnote></entry>
-->
       <entry><type>bool</type><footnote><para>ネイティブでなければ <filename>ecpglib.h</filename> で宣言。</para></footnote></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <sect3 id="ecpg-char">
<!--
    <title>Handling Character Strings</title>
-->
    <title>文字列の処理</title>

    <para>
<!--
     To handle SQL character string data types, such
     as <type>varchar</type> and <type>text</type>, there are two
     possible ways to declare the host variables.
-->
<type>varchar</type>や<type>text</type>のような文字列のデータ型を扱うため、ホスト変数を宣言するための2つの方法があります。
    </para>

    <para>
<!--
     One way is using <type>char[]</type>, an array
     of <type>char</type>, which is the most common way to handle
     character data in C.
-->
     ひとつは <type>char</type> の配列 <type>char[]</type> を使うことで、C言語において文字列データを扱うもっとも一般的な方法です。
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
    char str[50];
EXEC SQL END DECLARE SECTION;
</programlisting>
<!--
     Note that you have to take care of the length yourself.  If you
     use this host variable as the target variable of a query which
     returns a string with more than 49 characters, a buffer overflow
     occurs.
-->
     文字列の長さについて、自分自身で気を付けておく必要があります。
     上記のホスト変数を49文字以上の文字列を返すクエリのターゲット変数として使った場合、バッファオーバーフローが発生します。
    </para>

    <para>
<!--
     The other way is using the <type>VARCHAR</type> type, which is a
     special type provided by ECPG.  The definition on an array of
     type <type>VARCHAR</type> is converted into a
     named <type>struct</> for every variable. A declaration like:
-->
     その他の方法は、ECPGによって提供される特殊なデータ型 <type>VARCHAR</type> を使う方法です。
     <type>VARCHAR</type> の配列の定義は、すべての変数が名前の付いた <type>struct</> に変換されます。
     以下のような宣言は:
<programlisting>
VARCHAR var[180];
</programlisting>
<!--
     is converted into:
-->
     次のように変換されます:
<programlisting>
struct varchar_var { int len; char arr[180]; } var;
</programlisting>
<!--
     The member <structfield>arr</structfield> hosts the string
     including a terminating zero byte.  Thus, to store a string in
     a <type>VARCHAR</type> host variable, the host variable has to be
     declared with the length including the zero byte terminator.  The
     member <structfield>len</structfield> holds the length of the
     string stored in the <structfield>arr</structfield> without the
     terminating zero byte.  When a host variable is used as input for
     a query, if <literal>strlen(arr)</literal>
     and <structfield>len</structfield> are different, the shorter one
     is used.
-->
     メンバー変数 <structfield>arr</structfield> は終端のゼロの1バイトを含む文字列を保持します。
     よって、文字列を <type>VARCHAR</type> ホスト変数に格納する場合には、ホスト変数はゼロ終端を含んだ長さで宣言されなければなりません。
     メンバー変数 <structfield>len</structfield> は <structfield>arr</structfield> に格納された文字列のゼロ終端を含まない長さを保持します。
     ホスト変数をクエリの入力として使用する際、<literal>strlen(arr)</literal> と <structfield>len</structfield> が違った場合には短いものが使用されます。
    </para>

    <para>
<!--
     <type>VARCHAR</type> can be written in upper or lower case, but
     not in mixed case.
-->
     <type>VARCHAR</type> は大文字でも小文字でも記述することができますが、混在して記述することはできません。
    </para>

    <para>
<!--
     <type>char</type> and <type>VARCHAR</type> host variables can
     also hold values of other SQL types, which will be stored in
     their string forms.
-->
     <type>char</type> と <type>VARCHAR</type> ホスト変数は、他のSQLのデータ型の値を文字列表現として保持することもできます。
    </para>
   </sect3>

   <sect3 id="ecpg-special-types">
<!--
    <title>Accessing Special Data Types</title>
-->
    <title>特殊なデータ型へのアクセス</title>

    <para>
<!--
     ECPG contains some special types that help you to interact easily
     with some special data types from the PostgreSQL server. In
     particular, it has implemented support for the
     <type>numeric</>, <type>decimal</type>, <type>date</>, <type>timestamp</>,
     and <type>interval</> types.  These data types cannot usefully be
     mapped to primitive host variable types (such
     as <type>int</>, <type>long long int</type>,
     or <type>char[]</type>), because they have a complex internal
     structure.  Applications deal with these types by declaring host
     variables in special types and accessing them using functions in
     the pgtypes library.  The pgtypes library, described in detail
     in <xref linkend="ecpg-pgtypes"> contains basic functions to deal
     with those types, such that you do not need to send a query to
     the SQL server just for adding an interval to a time stamp for
     example.
-->
     ECPGには、PostgreSQLサーバからのいくつかの特殊なデータ型とやりとりするための特殊なデータ型があります。
     特に、<type>numeric</>, <type>decimal</type>, <type>date</>, <type>timestamp</>, <type>interval</> 型へのサポートを実装しています。
     これらのデータ型は複雑な内部構造を持つため、ホスト変数のプリミティブ型（<type>int</>, <type>long long int</type>, または <type>char[]</type>）に対応させることはできません。
     アプリケーションは特別な型としてホスト変数を宣言し、pgtypesライブラリ内の関数を使ってアクセスすることで、これらの型を扱います。
     <xref linkend="ecpg-pgtypes"> で詳細を解説されるpgtypesライブラリは、例えばタイムスタンプにインターバルを加算する際にクエリをSQLサーバに送らずに済ますような、これらの型を扱うための基本的な関数を含んでいます。
    </para>

    <para>
<!--
     The follow subsections describe these special data types. For
     more details about pgtypes library functions,
     see <xref linkend="ecpg-pgtypes">.
-->
以降のサブセクションは、これらの特殊なデータ型を説明します。
pgtypesライブラリ関数についての詳細は<xref linkend="ecpg-pgtypes">を参照してください。
    </para>

    <sect4>
     <title id="ecpg-type-timestamp-date">timestamp, date</title>

     <para>
<!--
      Here is a pattern for handling <type>timestamp</type> variables
      in the ECPG host application.
-->
      以下は、<type>timestamp</type> 変数をECPGホストアプリケーションで扱う典型的なパターンです。
     </para>

     <para>
<!--
      First, the program has to include the header file for the
      <type>timestamp</type> type:
-->
      最初に、プログラムは <type>timestamp</type> 型のためのヘッダファイルをインクルードする必要があります:
<programlisting>
#include &lt;pgtypes_timestamp.h>
</programlisting>
     </para>

     <para>
<!--
      Next, declare a host variable as type <type>timestamp</type> in
      the declare section:
-->
      次に、宣言セクションで <type>timestamp</type> 型のホスト変数を宣言します:
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
timestamp ts;
EXEC SQL END DECLARE SECTION;
</programlisting>
     </para>

     <para>
<!--
      And after reading a value into the host variable, process it
      using pgtypes library functions. In following example, the
      <type>timestamp</type> value is converted into text (ASCII) form
      with the <function>PGTYPEStimestamp_to_asc()</function>
      function:
-->
      そして、ホスト変数へ値を読み込んだら、pgtypesライブラリ関数を使って処理をします。
      以降の例では、<type>timestamp</type> の値は <function>PGTYPEStimestamp_to_asc()</function> 関数によって text (ASCII) 形式に変換されます:
<programlisting>
EXEC SQL SELECT now()::timestamp INTO :ts;

printf("ts = %s\n", PGTYPEStimestamp_to_asc(ts));
</programlisting>
      This example will show some result like following:
<screen>
ts = 2010-06-27 18:03:56.949343
</screen>
     </para>

     <para>
<!--
      In addition, the DATE type can be handled in the same way. The
      program has to include <filename>pgtypes_date.h</filename>, declare a host variable
      as the date type and convert a DATE value into a text form using
      <function>PGTYPESdate_to_asc()</function> function. For more details about the
      pgtypes library functions, see <xref linkend="ecpg-pgtypes">.
-->
      また、DATE型も同じ方法で扱うことができます。
      プログラムは <filename>pgtypes_date.h</filename> をインクルードし、ホスト変数を date 型として宣言し、<function>PGTYPESdate_to_asc()</function> 関数によって DATE の値を text 形式に変換します。
      pgtypesライブラリ関数についての詳細は、<xref linkend="ecpg-pgtypes"> を参照してください。
     </para>
    </sect4>

    <sect4 id="ecpg-type-interval">
     <title>interval</title>

     <para>
<!--
      The handling of the <type>interval</type> type is also similar
      to the <type>timestamp</type> and <type>date</type> types.  It
      is required, however, to allocate memory for
      an <type>interval</type> type value explicitly.  In other words,
      the memory space for the variable has to be allocated in the
      heap memory, not in the stack memory.
-->
      <type>interval</type> 型の扱い方は <type>timestamp</type> や <type>date</type> 型と似ています。
      但し、<type>interval</type> 型の値のために明示的にメモリを確保する必要があります。
      言い換えると、この変数のためのメモリ領域はスタックではなくヒープ上に確保されます。
     </para>

     <para>
<!--
      Here is an example program:
-->
      以下にプログラム例を示します:
<programlisting>
#include &lt;stdio.h>
#include &lt;stdlib.h>
#include &lt;pgtypes_interval.h>

int
main(void)
{
EXEC SQL BEGIN DECLARE SECTION;
    interval *in;
EXEC SQL END DECLARE SECTION;

    EXEC SQL CONNECT TO testdb;

    in = PGTYPESinterval_new();
    EXEC SQL SELECT '1 min'::interval INTO :in;
    printf("interval = %s\n", PGTYPESinterval_to_asc(in));
    PGTYPESinterval_free(in);

    EXEC SQL COMMIT;
    EXEC SQL DISCONNECT ALL;
    return 0;
}
</programlisting>
     </para>
    </sect4>

    <sect4 id="ecpg-type-numeric-decimal">
     <title>numeric, decimal</title>

     <para>
<!--
      The handling of the <type>numeric</type>
      and <type>decimal</type> types is similar to the
      <type>interval</type> type: It requires defining a pointer,
      allocating some memory space on the heap, and accessing the
      variable using the pgtypes library functions.  For more details
      about the pgtypes library functions,
      see <xref linkend="ecpg-pgtypes">.
-->
      <type>numeric</type> と <type>decimal</type> 型の扱い方は <type>interval</type> 型と似ています: ポインタ宣言を必要とし、ヒープメモリを確保する必要があり、pgtypesライブラリ関数を使って変数にアクセスします。
      pgtypesライブラリ関数の詳細については、<xref linkend="ecpg-pgtypes"> を参照してください。
     </para>

     <para>
<!--
      No functions are provided specifically for
      the <type>decimal</type> type.  An application has to convert it
      to a <type>numeric</type> variable using a pgtypes library
      function to do further processing.
-->
      <type>decimal</type> 型に対する専用の関数は提供されていません。
      アプリケーションは処理を行うために pgtypesライブラリ関数を使って <type>numeric</type> 変数に変換する必要があります。
     </para>

     <para>
<!--
      Here is an example program handling <type>numeric</type>
      and <type>decimal</type> type variables.
-->
      以下に <type>numeric</type> および <type>decimal</type> 型の変数の処理の例を示します。
<programlisting>
#include &lt;stdio.h>
#include &lt;stdlib.h>
#include &lt;pgtypes_numeric.h>

EXEC SQL WHENEVER SQLERROR STOP;

int
main(void)
{
EXEC SQL BEGIN DECLARE SECTION;
    numeric *num;
    numeric *num2;
    decimal *dec;
EXEC SQL END DECLARE SECTION;

    EXEC SQL CONNECT TO testdb;

    num = PGTYPESnumeric_new();
    dec = PGTYPESdecimal_new();

    EXEC SQL SELECT 12.345::numeric(4,2), 23.456::decimal(4,2) INTO :num, :dec;

    printf("numeric = %s\n", PGTYPESnumeric_to_asc(num, 0));
    printf("numeric = %s\n", PGTYPESnumeric_to_asc(num, 1));
    printf("numeric = %s\n", PGTYPESnumeric_to_asc(num, 2));

<!--
    /* Convert decimal to numeric to show a decimal value. */
-->
    /* decimalの値を表示するためdecimalをnumericに変換する。 */
    num2 = PGTYPESnumeric_new();
    PGTYPESnumeric_from_decimal(dec, num2);

    printf("decimal = %s\n", PGTYPESnumeric_to_asc(num2, 0));
    printf("decimal = %s\n", PGTYPESnumeric_to_asc(num2, 1));
    printf("decimal = %s\n", PGTYPESnumeric_to_asc(num2, 2));

    PGTYPESnumeric_free(num2);
    PGTYPESdecimal_free(dec);
    PGTYPESnumeric_free(num);

    EXEC SQL COMMIT;
    EXEC SQL DISCONNECT ALL;
    return 0;
}
</programlisting>
     </para>
    </sect4>
   </sect3>

   <sect3 id="ecpg-variables-nonprimitive-c">
<!--
    <title>Host Variables with Nonprimitive Types</title>
-->
    <title>非プリミティブ型のホスト変数</title>

    <para>
<!--
     As a host variable you can also use arrays, typedefs, structs, and
     pointers.
-->
     ホスト変数として、配列、typedef、構造体およびポインタも使うことができます。
    </para>

    <sect4 id="ecpg-variables-arrays">
<!--
     <title>Arrays</title>
-->
     <title>配列</title>

     <para>
<!--
      There are two use cases for arrays as host variables.  The first
      is a way to store some text string in <type>char[]</type>
      or <type>VARCHAR[]</type>, as
      explained <xref linkend="ecpg-char">.  The second use case is to
      retrieve multiple rows from a query result without using a
      cursor.  Without an array, to process a query result consisting
      of multiple rows, it is required to use a cursor and
      the <command>FETCH</command> command.  But with array host
      variables, multiple rows can be received at once.  The length of
      the array has to be defined to be able to accommodate all rows,
      otherwise a buffer overflow will likely occur.
-->
      ホスト変数としての配列の使い方には二通りの利用方法があります。
      一つ目の使い方は、<xref linkend="ecpg-char"> で説明されたように <type>char[]</type> または <type>VARCHAR[]</type> の何らかのテキスト文字列を保持するための方法です。
      二つ目の使い方は、カーソルを用いずに複数行を返却するクエリ結果を受け取るために使う方法です。
      配列を使わない場合、複数行からなるクエリの実行結果を処理するには、カーソルと <command>FETCH</command> コマンドを使用する必要があります。
      しかし、配列のホスト変数を使うと、複数行を一括して受け取ることができます。
      配列の長さはすべての行を受け入れられるように定義されなければなりません。でなければバッファーオーバーフローが発生するでしょう。
     </para>

     <para>
<!--
      Following example scans the <literal>pg_database</literal>
      system table and shows all OIDs and names of the available
      databases:
-->
      以下の例は <literal>pg_database</literal> システムテーブルをスキャンし、利用可能なデータベースのすべてのOIDとデータベース名を表示します:
<programlisting>
int
main(void)
{
EXEC SQL BEGIN DECLARE SECTION;
    int dbid[8];
    char dbname[8][16];
    int i;
EXEC SQL END DECLARE SECTION;

    memset(dbname, 0, sizeof(char)* 16 * 8);
    memset(dbid, 0, sizeof(int) * 8);

    EXEC SQL CONNECT TO testdb;

<!--
    /* Retrieve multiple rows into arrays at once. */
-->
    /* 複数行を一度に配列へと取り出す。 */
    EXEC SQL SELECT oid,datname INTO :dbid, :dbname FROM pg_database;

    for (i = 0; i &lt; 8; i++)
        printf("oid=%d, dbname=%s\n", dbid[i], dbname[i]);

    EXEC SQL COMMIT;
    EXEC SQL DISCONNECT ALL;
    return 0;
}
</programlisting>

<!--
    This example shows following result. (The exact values depend on
    local circumstances.)
-->
    この例は、以下の結果を表示します。（実際の値はローカルな環境に依存します）
<screen>
oid=1, dbname=template1
oid=11510, dbname=template0
oid=11511, dbname=postgres
oid=313780, dbname=testdb
oid=0, dbname=
oid=0, dbname=
oid=0, dbname=
</screen>
     </para>
    </sect4>

    <sect4 id="ecpg-variables-struct">
<!--
     <title>Structures</title>
-->
     <title>構造体</title>

     <para>
<!--
      A structure whose member names match the column names of a query
      result, can be used to retrieve multiple columns at once.  The
      structure enables handling multiple column values in a single
      host variable.
-->
      メンバー変数の名前がクエリ結果のカラム名に合致する構造体は、複数のカラムを一括して受け取るために利用することができます。
      構造体は複数のカラムの値を単一のホスト変数で扱うことを可能にします。
     </para>

     <para>
<!--
      The following example retrieves OIDs, names, and sizes of the
      available databases from the <literal>pg_database</literal>
      system table and using
      the <function>pg_database_size()</function> function.  In this
      example, a structure variable <varname>dbinfo_t</varname> with
      members whose names match each column in
      the <literal>SELECT</literal> result is used to retrieve one
      result row without putting multiple host variables in
      the <literal>FETCH</literal> statement.
-->
以下の例は、<literal>pg_database</literal>システムテーブルおよび<function>pg_database_size()</function>関数を使って、利用可能なデータベースのOID、名前、サイズを取得します。
この例では、メンバー変数の名前が<literal>SELECT</literal>結果の各カラムに合致する構造体<varname>dbinfo_t</varname>が、複数のホスト変数に格納することなく<literal>FETCH</literal>文の一行の結果を受け取るために使用されています。
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
    typedef struct
    {
       int oid;
       char datname[65];
       long long int size;
    } dbinfo_t;

    dbinfo_t dbval;
EXEC SQL END DECLARE SECTION;

    memset(&amp;dbval, 0, sizeof(dbinfo_t));

    EXEC SQL DECLARE cur1 CURSOR FOR SELECT oid, datname, pg_database_size(oid) AS size FROM pg_database;
    EXEC SQL OPEN cur1;

<!--
    /* when end of result set reached, break out of while loop */
-->
    /* 結果集合の最後に到達したら、whileループから抜ける */
    EXEC SQL WHENEVER NOT FOUND DO BREAK;

    while (1)
    {
<!--
        /* Fetch multiple columns into one structure. */
-->
        /* 複数列を1つの構造体に取り込む。 */
        EXEC SQL FETCH FROM cur1 INTO :dbval;

<!--
        /* Print members of the structure. */
-->
        /* 構造体のメンバを表示する。 */
        printf("oid=%d, datname=%s, size=%lld\n", dbval.oid, dbval.datname, dbval.size);
    }

    EXEC SQL CLOSE cur1;
</programlisting>
     </para>

     <para>
<!--
      This example shows following result. (The exact values depend on
      local circumstances.)
-->
      この例は、次の結果を示します（実際の値はローカルな環境に依存します）
<screen>
oid=1, datname=template1, size=4324580
oid=11510, datname=template0, size=4243460
oid=11511, datname=postgres, size=4324580
oid=313780, datname=testdb, size=8183012
</screen>
     </para>

     <para>
<!--
      Structure host variables <quote>absorb</quote> as many columns
      as the structure as fields.  Additional columns can be assigned
      to other host variables. For example, the above program could
      also be restructured like this, with the <varname>size</varname>
      variable outside the structure:
-->
      構造体のホスト変数は、多数のカラムを構造体のフィールドとして<quote>吸収</quote>します。
      追加のカラムは他のホスト変数に割り当てることができます。
      例えば、上記のプログラムは構造体に含まれない <varname>size</varname> 変数を使って以下のように書き換えることができます。
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
    typedef struct
    {
       int oid;
       char datname[65];
    } dbinfo_t;

    dbinfo_t dbval;
    long long int size;
EXEC SQL END DECLARE SECTION;

    memset(&amp;dbval, 0, sizeof(dbinfo_t));

    EXEC SQL DECLARE cur1 CURSOR FOR SELECT oid, datname, pg_database_size(oid) AS size FROM pg_database;
    EXEC SQL OPEN cur1;

<!--
    /* when end of result set reached, break out of while loop */
-->
    /* 結果集合の最後に到達したら、whileループから抜ける */
    EXEC SQL WHENEVER NOT FOUND DO BREAK;

    while (1)
    {
<!--
        /* Fetch multiple columns into one structure. */
-->
        /* 複数列を1つの構造体に取り込む。 */
        EXEC SQL FETCH FROM cur1 INTO :dbval, :size;

<!--
        /* Print members of the structure. */
-->
        /* 構造体のメンバを表示する。 */
        printf("oid=%d, datname=%s, size=%lld\n", dbval.oid, dbval.datname, size);
    }

    EXEC SQL CLOSE cur1;
</programlisting>
     </para>
    </sect4>

    <sect4>
<!--
     <title>Typedefs</title>
-->
     <title>typedef</title>

     <para>
<!--
      Use the <literal>typedef</literal> keyword to map new types to already
      existing types.
-->
      新しい型と既存の型を対応付けるためには <literal>typedef</literal> キーワードを使ってください。
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
    typedef char mychartype[40];
    typedef long serial_t;
EXEC SQL END DECLARE SECTION;
</programlisting>
<!--
      Note that you could also use:
-->
      また、同様に以下を使うこともできます:
<programlisting>
EXEC SQL TYPE serial_t IS long;
</programlisting>
<!--
      This declaration does not need to be part of a declare section.
-->
      この宣言は、宣言セクションの一部である必要はありません。
     </para>
    </sect4>

    <sect4>
<!--
     <title>Pointers</title>
-->
     <title>ポインタ</title>

     <para>
<!--
      You can declare pointers to the most common types. Note however
      that you cannot use pointers as target variables of queries
      without auto-allocation. See <xref linkend="ecpg-descriptors">
      for more information on auto-allocation.
-->
      ほとんどの一般的な型のポインタを宣言することができます。
      但し、自動メモリ確保を使わずにクエリのターゲット変数として使うことはできません。
      自動メモリ確保については <xref linkend="ecpg-descriptors"> を参照してください。
     </para>

     <para>
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
    int   *intp;
    char **charp;
EXEC SQL END DECLARE SECTION;
</programlisting>
     </para>
    </sect4>
   </sect3>
  </sect2>

  <sect2 id="ecpg-variables-nonprimitive-sql">
<!--
   <title>Handling Nonprimitive SQL Data Types</title>
-->
   <title>非プリミティブSQLデータ型の扱い方</title>

   <para>
<!--
    This section contains information on how to handle nonscalar and
    user-defined SQL-level data types in ECPG applications.  Note that
    this is distinct from the handling of host variables of
    nonprimitive types, described in the previous section.
-->
    本節では、非スカラー型およびユーザ定義のSQLデータ型をECPGアプリケーションで扱う方法を示します。
    この内容は、前の説で説明した非プリミティブ型のホスト変数の扱い方とは別のものです。
   </para>

   <sect3>
<!--
    <title>Arrays</title>
-->
    <title>配列</title>

    <para>
<!--
     Multi-dimensional SQL-level arrays are not directly supported in ECPG.
     One-dimensional SQL-level arrays can be mapped into C array host
     variables and vice-versa.  However, when creating a statement ecpg does
     not know the types of the columns, so that it cannot check if a C array
     is input into a corresponding SQL-level array.  When processing the
     output of a SQL statement, ecpg has the necessary information and thus
     checks if both are arrays.
-->
SQLの多次元配列は、ECPGにおいては直接的にはサポートされていません。
SQLの1次元配列をC言語の配列のホスト変数に対応させることはできますし、その逆もできます。
しかし、文の作成時にはecpgがその列の型を知らないので、C言語の配列を対応するSQLの配列に入力できるか確かめられません。
SQL文の出力を処理する時には、ecpgは必要な情報を持っていますので、どちらも配列であるか確かめます。
    </para>

    <para>
<!--
     If a query accesses <emphasis>elements</emphasis> of an array
     separately, then this avoids the use of arrays in ECPG.  Then, a
     host variable with a type that can be mapped to the element type
     should be used.  For example, if a column type is array of
     <type>integer</type>, a host variable of type <type>int</type>
     can be used.  Also if the element type is <type>varchar</type>
     or <type>text</type>, a host variable of type <type>char[]</type>
     or <type>VARCHAR[]</type> can be used.
-->
     もし、クエリが配列の <emphasis>要素</emphasis> に対して個別にアクセスした場合、ECPGにおける配列の利用を避けることができます。
     その際、要素に対応させることができる型のホスト変数を利用しなければなりません。
     例えば、カラムの型が <type>integer</type> の配列の場合、<type>int</type> 型のホスト変数を使用することができます。
     同様に、要素の型が <type>varchar</type> または <type>text</type> の場合、 <type>char[]</type> ないし <type>VARCHAR[]</type> 型のホスト変数を使用することができます。
    </para>

    <para>
<!--
     Here is an example.  Assume the following table:
-->
     以下に例を示します。次のようなテーブルを仮定します:
<programlisting>
CREATE TABLE t3 (
    ii integer[]
);

testdb=&gt; SELECT * FROM t3;
     ii
-------------
 {1,2,3,4,5}
(1 row)
</programlisting>

<!--
     The following example program retrieves the 4th element of the
     array and stores it into a host variable of
     type <type>int</type>:
-->
     以下のプログラム例は、配列の4番目の要素を取得し、それを <type>int</type> 型のホスト変数に保存します:
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
int ii;
EXEC SQL END DECLARE SECTION;

EXEC SQL DECLARE cur1 CURSOR FOR SELECT ii[4] FROM t3;
EXEC SQL OPEN cur1;

EXEC SQL WHENEVER NOT FOUND DO BREAK;

while (1)
{
    EXEC SQL FETCH FROM cur1 INTO :ii ;
    printf("ii=%d\n", ii);
}

EXEC SQL CLOSE cur1;
</programlisting>

<!--
     This example shows the following result:
-->
     この例は以下のような結果を示します:
<screen>
ii=4
</screen>
    </para>

    <para>
<!--
     To map multiple array elements to the multiple elements in an
     array type host variables each element of array column and each
     element of the host variable array have to be managed separately,
     for example:
-->
     複数の配列の要素を、配列型のホスト変数の複数の要素にマッピングするためには、配列型のカラムの各要素とホスト変数配列の各要素は、以下の例のように別々に管理されなければなりません:
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
int ii_a[8];
EXEC SQL END DECLARE SECTION;

EXEC SQL DECLARE cur1 CURSOR FOR SELECT ii[1], ii[2], ii[3], ii[4] FROM t3;
EXEC SQL OPEN cur1;

EXEC SQL WHENEVER NOT FOUND DO BREAK;

while (1)
{
    EXEC SQL FETCH FROM cur1 INTO :ii_a[0], :ii_a[1], :ii_a[2], :ii_a[3];
    ...
}
</programlisting>
    </para>

    <para>
<!--
     Note again that
-->
     繰り返しになりますが、以下の例は
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
int ii_a[8];
EXEC SQL END DECLARE SECTION;

EXEC SQL DECLARE cur1 CURSOR FOR SELECT ii FROM t3;
EXEC SQL OPEN cur1;

EXEC SQL WHENEVER NOT FOUND DO BREAK;

while (1)
{
<!--
    /* WRONG */
-->
    /* 間違い */
    EXEC SQL FETCH FROM cur1 INTO :ii_a;
    ...
}
</programlisting>
<!--
     would not work correctly in this case, because you cannot map an
     array type column to an array host variable directly.
-->
     この場合は正しく動作しません。なぜなら、配列型のカラムをホストの配列変数に直接対応させることはできないからです。
    </para>

    <para>
<!--
     Another workaround is to store arrays in their external string
     representation in host variables of type <type>char[]</type>
     or <type>VARCHAR[]</type>.  For more details about this
     representation, see <xref linkend="arrays-input">.  Note that
     this means that the array cannot be accessed naturally as an
     array in the host program (without further processing that parses
     the text representation).
-->
     もうひとつの回避策は、配列をホスト変数の <type>char[]</type> または <type>VARCHAR[]</type> 型に文字列表現として保存することです。
     この表現方法についての詳細は <xref linkend="arrays-input"> を参照してください。
     このことは、配列にはホストプログラム内で自然な形ではアクセスできないことを意味しています（文字列表現を解析する追加処理が無ければ）。
    </para>
   </sect3>

   <sect3>
<!--
    <title>Composite Types</title>
-->
    <title>複合型</title>

    <para>
<!--
     Composite types are not directly supported in ECPG, but an easy workaround is possible.
  The
     available workarounds are similar to the ones described for
     arrays above: Either access each attribute separately or use the
     external string representation.
-->
複合型はECPGでは直接はサポートされていませんが、簡単な回避方法が利用可能です。
利用可能なワークアラウンドは、先に配列において説明されたものと似ています: 各属性に個別にアクセスするか、外部の文字列表現を使います。
    </para>

    <para>
<!--
     For the following examples, assume the following type and table:
-->
以降の例のため、以下の型とテーブルを仮定します:
<programlisting>
CREATE TYPE comp_t AS (intval integer, textval varchar(32));
CREATE TABLE t4 (compval comp_t);
INSERT INTO t4 VALUES ( (256, 'PostgreSQL') );
</programlisting>

<!--
     The most obvious solution is to access each attribute separately.
     The following program retrieves data from the example table by
     selecting each attribute of the type <type>comp_t</type>
     separately:
-->
もっとも分かりやすい解決法は、各属性に個別にアクセスすることです。
以下のプログラムは、<type>comp_t</type>型の各要素を個別に選択することによってサンプルのテーブルからデータを受け取ります:
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
int intval;
varchar textval[33];
EXEC SQL END DECLARE SECTION;

<!--
/* Put each element of the composite type column in the SELECT list. */
-->
/* SELECTリストに複合型の列の各要素を書く。 */
EXEC SQL DECLARE cur1 CURSOR FOR SELECT (compval).intval, (compval).textval FROM t4;
EXEC SQL OPEN cur1;

EXEC SQL WHENEVER NOT FOUND DO BREAK;

while (1)
{
<!--
    /* Fetch each element of the composite type column into host variables. */
-->
    /* 複合型の列の各要素をホスト変数に取り出す。 */
    EXEC SQL FETCH FROM cur1 INTO :intval, :textval;

    printf("intval=%d, textval=%s\n", intval, textval.arr);
}

EXEC SQL CLOSE cur1;
</programlisting>
    </para>

    <para>
<!--
     To enhance this example, the host variables to store values in
     the <command>FETCH</command> command can be gathered into one
     structure.  For more details about the host variable in the
     structure form, see <xref linkend="ecpg-variables-struct">.
     To switch to the structure, the example can be modified as below.
     The two host variables, <varname>intval</varname>
     and <varname>textval</varname>, become members of
     the <structname>comp_t</structname> structure, and the structure
     is specified on the <command>FETCH</command> command.
-->
     この例を拡張して、 <command>FETCH</command> コマンドの値を格納するホスト変数を一つの構造体にまとめることができます。
     構造体の形のホスト変数の詳細については <xref linkend="ecpg-variables-struct"> を参照してください。
     構造体に変更するために、この例は以下のように変更することができます。
     二つのホスト変数 <varname>intval</varname> と <varname>textval</varname> を <structname>comp_t</structname> 構造体のメンバー変数とし、構造体を <command>FETCH</command> コマンドで指定します。
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
typedef struct
{
    int intval;
    varchar textval[33];
} comp_t;

comp_t compval;
EXEC SQL END DECLARE SECTION;

<!--
/* Put each element of the composite type column in the SELECT list. */
-->
/* SELECTリストに複合型の列の各要素を書く。 */
EXEC SQL DECLARE cur1 CURSOR FOR SELECT (compval).intval, (compval).textval FROM t4;
EXEC SQL OPEN cur1;

EXEC SQL WHENEVER NOT FOUND DO BREAK;

while (1)
{
 <!--
    /* Put all values in the SELECT list into one structure. */
-->
    /* SELECTリストの値をすべて1つの構造体に取り込む。 */
    EXEC SQL FETCH FROM cur1 INTO :compval;

    printf("intval=%d, textval=%s\n", compval.intval, compval.textval.arr);
}

EXEC SQL CLOSE cur1;
</programlisting>

<!--
     Although a structure is used in the <command>FETCH</command>
     command, the attribute names in the <command>SELECT</command>
     clause are specified one by one.  This can be enhanced by using
     a <literal>*</literal> to ask for all attributes of the composite
     type value.
-->
     構造体が <command>FETCH</command> コマンドで使われていますが、属性名は <command>SELECT</command> 句において各々が指定されています。
     これは、複合型の値のすべての属性を示す <literal>*</literal> を用いることで拡張することができます。
<programlisting>
...
EXEC SQL DECLARE cur1 CURSOR FOR SELECT (compval).* FROM t4;
EXEC SQL OPEN cur1;

EXEC SQL WHENEVER NOT FOUND DO BREAK;

while (1)
{
<!--
    /* Put all values in the SELECT list into one structure. */
-->
    /* SELECTリストの値をすべて1つの構造体に取り込む。 */
    EXEC SQL FETCH FROM cur1 INTO :compval;

    printf("intval=%d, textval=%s\n", compval.intval, compval.textval.arr);
}
...
</programlisting>
<!--
     This way, composite types can be mapped into structures almost
     seamlessly, even though ECPG does not understand the composite
     type itself.
-->
     この方法であれば、ECPGが複合型そのものを理解できないとしても、複合型はほぼシームレスに構造体に対応させることができます。
    </para>

    <para>
<!--
     Finally, it is also possible to store composite type values in
     their external string representation in host variables of
     type <type>char[]</type> or <type>VARCHAR[]</type>.  But that
     way, it is not easily possible to access the fields of the value
     from the host program.
-->
     最後に、<type>char[]</type> または <type>VARCHAR[]</type> 型のホスト変数に外部の文字列表現として複合型の値を格納することもできます。
     しかし、この方法ではホストプログラムから値のフィールドにアクセスするのは簡単ではありません。
    </para>
   </sect3>

   <sect3>
<!--
    <title>User-defined Base Types</title>
-->
    <title>ユーザ定義の基本型</title>

    <para>
<!--
     New user-defined base types are not directly supported by ECPG.
     You can use the external string representation and host variables
     of type <type>char[]</type> or <type>VARCHAR[]</type>, and this
     solution is indeed appropriate and sufficient for many types.
-->
     新しいユーザ定義の基本型は、ECPGでは直接的にはサポートされていません。
     外部の文字列表現、<type>char[]</type>または<type>VARCHAR[]</type> 型のホスト変数を使うことができ、この解決法は多くの型について確かに適切かつ十分です。
    </para>

    <para>
<!--
     Here is an example using the data type <type>complex</type> from
     the example in <xref linkend="xtypes">.  The external string
     representation of that type is <literal>(%lf,%lf)</literal>,
     which is defined in the
     functions <function>complex_in()</function>
     and <function>complex_out()</function> functions
     in <xref linkend="xtypes">.  The following example inserts the
     complex type values <literal>(1,1)</literal>
     and <literal>(3,3)</literal> into the
     columns <literal>a</literal> and <literal>b</literal>, and select
     them from the table after that.
-->
以下に<xref linkend="xtypes">に含まれる<type>complex</type>型を使った例を示します。
この型の外部文字列表現は<literal>(%lf,%lf)</literal>で、<xref linkend="xtypes">の<function>complex_in()</function>関数および<function>complex_out()</function>関数で定義されています。
以下の例は、カラム<literal>a</literal>と<literal>b</literal>に、complex型の値<literal>(1,1)</literal>および<literal>(3,3)</literal>を挿入し、その後、それらをテーブルからSELECTします。

<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
    varchar a[64];
    varchar b[64];
EXEC SQL END DECLARE SECTION;

    EXEC SQL INSERT INTO test_complex VALUES ('(1,1)', '(3,3)');

    EXEC SQL DECLARE cur1 CURSOR FOR SELECT a, b FROM test_complex;
    EXEC SQL OPEN cur1;

    EXEC SQL WHENEVER NOT FOUND DO BREAK;

    while (1)
    {
        EXEC SQL FETCH FROM cur1 INTO :a, :b;
        printf("a=%s, b=%s\n", a.arr, b.arr);
    }

    EXEC SQL CLOSE cur1;
</programlisting>

<!--
     This example shows following result:
-->
     この例は、以下の結果を示します。
<screen>
a=(1,1), b=(3,3)
</screen>
   </para>

    <para>
<!--
     Another workaround is avoiding the direct use of the user-defined
     types in ECPG and instead create a function or cast that converts
     between the user-defined type and a primitive type that ECPG can
     handle.  Note, however, that type casts, especially implicit
     ones, should be introduced into the type system very carefully.
-->
     その他の回避方法は、ユーザ定義型をECPGにおいて直接的に使うことを避けることであり、ユーザ定義型とECPGが扱えるプリミティブ型を変換する関数またはキャストを作成することです。
     ただし、型のキャスト、特に暗黙のものは型システムにおいて慎重に導入されなければなりません。
    </para>

    <para>
<!--
     For example,
-->
     例を示します。
<programlisting>
CREATE FUNCTION create_complex(r double, i double) RETURNS complex
LANGUAGE SQL
IMMUTABLE
AS $$ SELECT $1 * complex '(1,0')' + $2 * complex '(0,1)' $$;
</programlisting>
<!--
    After this definition, the following
-->
    この定義の後、以下の例は
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
double a, b, c, d;
EXEC SQL END DECLARE SECTION;

a = 1;
b = 2;
c = 3;
d = 4;

EXEC SQL INSERT INTO test_complex VALUES (create_complex(:a, :b), create_complex(:c, :d));
</programlisting>
<!--
    has the same effect as
-->
    以下と同じ効果をもたらします。
<programlisting>
EXEC SQL INSERT INTO test_complex VALUES ('(1,2)', '(3,4)');
</programlisting>
    </para>
   </sect3>
  </sect2>

  <sect2 id="ecpg-indicators">
<!--
   <title>Indicators</title>
-->
   <title>指示子</title>

   <para>
<!--
    The examples above do not handle null values.  In fact, the
    retrieval examples will raise an error if they fetch a null value
    from the database.  To be able to pass null values to the database
    or retrieve null values from the database, you need to append a
    second host variable specification to each host variable that
    contains data.  This second host variable is called the
    <firstterm>indicator</firstterm> and contains a flag that tells
    whether the datum is null, in which case the value of the real
    host variable is ignored.  Here is an example that handles the
    retrieval of null values correctly:
-->
上の例ではNULL値を扱いません。
実際、取り出し例では、もしデータベースからNULL値が取り出された場合にはエラーが発生します。
データベースへNULL値を渡す、または、データベースからNULL値を取り出すためには、第二のホスト変数指定をデータを格納するホスト変数それぞれに追加しなければなりません。
第二のホスト変数は<firstterm>指示子</firstterm>と呼ばれ、データがNULLかどうかを表すフラグが含まれます。
NULLの場合、実際のホスト変数の値は無視されます。
以下に、NULL値の取り出しを正しく扱う例を示します。
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
VARCHAR val;
int val_ind;
EXEC SQL END DECLARE SECTION:

 ...

EXEC SQL SELECT b INTO :val :val_ind FROM test1;
</programlisting>
<!--
    The indicator variable <varname>val_ind</varname> will be zero if
    the value was not null, and it will be negative if the value was
    null.
-->
値がNULLでなければ、指示子変数<varname>val_ind</varname>は0となります。
値がNULLならば負の値となります。
   </para>

   <para>
<!--
    The indicator has another function: if the indicator value is
    positive, it means that the value is not null, but it was
    truncated when it was stored in the host variable.
-->
指示子は他の機能を持ちます。
指示子の値が正ならば、値がNULLではありませんが、ホスト変数に格納する際に一部切り詰められたことを示します。
   </para>

   <para>
<!--
    If the argument <literal>-r no_indicator</literal> is passed to
    the preprocessor <command>ecpg</command>, it works in
    <quote>no-indicator</quote> mode. In no-indicator mode, if no
    indicator variable is specified, null values are signaled (on
    input and output) for character string types as empty string and
    for integer types as the lowest possible value for type (for
    example, <symbol>INT_MIN</symbol> for <type>int</type>).
-->
    プリプロセッサ <command>ecpg</command> に引数 <literal>-r no_indicator</literal> が渡された場合、<quote>no-indicator</quote> モードで動作します。
    no-indicator モードでは、指示子変数が指定されなかった場合、（入力および出力において）文字列型に対して空の文字列としてnull値が、整数型に対してはもっとも小さな値が割り当てられます（例えば、<type>int</type> の場合 <symbol>INT_MIN</symbol> です）。
   </para>
  </sect2>
 </sect1>

 <sect1 id="ecpg-dynamic">
<!--
  <title>Dynamic SQL</title>
-->
  <title>動的SQL</title>

  <para>
<!--
   In many cases, the particular SQL statements that an application
   has to execute are known at the time the application is written.
   In some cases, however, the SQL statements are composed at run time
   or provided by an external source.  In these cases you cannot embed
   the SQL statements directly into the C source code, but there is a
   facility that allows you to call arbitrary SQL statements that you
   provide in a string variable.
-->
多くの場合、アプリケーションが実行しなければならないSQL文は、アプリケーションを作成する段階で決まります。
しかし、中には、SQL文が実行時に構成されることや外部ソースで提供されることがあります。
このような場合、SQL文を直接Cソースコードに埋め込むことはできません。
しかし、文字列変数として提供される任意のSQL文を呼び出すことができる機能が存在します。
  </para>

  <sect2 id="ecpg-dynamic-without-result">
<!--
   <title>Executing Statements without a Result Set</title>
-->
   <title>結果セットを伴わないSQL文の実行</title>

   <para>
<!--
    The simplest way to execute an arbitrary SQL statement is to use
    the command <command>EXECUTE IMMEDIATE</command>.  For example:
-->
    任意のSQL文を実行するもっとも簡単な方法は、<command>EXECUTE IMMEDIATE</command> コマンドを使用することです。
    例を示します:
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
const char *stmt = "CREATE TABLE test1 (...);";
EXEC SQL END DECLARE SECTION;

EXEC SQL EXECUTE IMMEDIATE :stmt;
</programlisting>
<!--
    <command>EXECUTE IMMEDIATE</command> can be used for SQL
    statements that do not return a result set (e.g.,
    DDL, <command>INSERT</command>, <command>UPDATE</command>,
    <command>DELETE</command>).  You cannot execute statements that
    retrieve data (e.g., <command>SELECT</command>) this way.  The
    next section describes how to do that.
-->
<command>EXECUTE IMMEDIATE</command>は結果セットを返却しないSQL文（例えば、DDL、<command>INSERT</command>、<command>UPDATE</command>、<command>DELETE</command>)に使用することができます。
結果を受け取るSQL文（例えば、<command>SELECT</command>）をこの方法で実行することはできません。
次の節で、その実行方法を説明します。
   </para>
  </sect2>

  <sect2 id="ecpg-dynamic-input">
<!--
   <title>Executing a Statement with Input Parameters</title>
-->
   <title>入力パラメータを伴うSQL文の実行</title>

   <para>
<!--
    A more powerful way to execute arbitrary SQL statements is to
    prepare them once and execute the prepared statement as often as
    you like.  It is also possible to prepare a generalized version of
    a statement and then execute specific versions of it by
    substituting parameters.  When preparing the statement, write
    question marks where you want to substitute parameters later.  For
    example:
-->
任意のSQL文を実行するより強力な方法は、一度プリペアをし、その後でプリペアド文を実行したいところで実行することです。
また、SQL文を汎用化した形でプリペアし、パラメータを置き換えることで特定のSQL文を実行させることも可能です。
SQL文をプリペアする時、後でパラメータとして置き換えたいところには疑問符を記述してください。
以下に例を示します。
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
const char *stmt = "INSERT INTO test1 VALUES(?, ?);";
EXEC SQL END DECLARE SECTION;

EXEC SQL PREPARE mystmt FROM :stmt;
 ...
EXEC SQL EXECUTE mystmt USING 42, 'foobar';
</programlisting>
   </para>

   <para>
<!--
    When you don't need the prepared statement anymore, you should
    deallocate it:
-->
プリペアド文が必要なくなった時、割当てを解除しなければなりません。
<programlisting>
EXEC SQL DEALLOCATE PREPARE <replaceable>name</replaceable>;
</programlisting>
   </para>
  </sect2>

  <sect2 id="ecpg-dynamic-with-result">
<!--
   <title>Executing a Statement with a Result Set</title>
-->
   <title>結果セットを返却するSQL文の実行</title>

   <para>
<!--
    To execute an SQL statement with a single result row,
    <command>EXECUTE</command> can be used.  To save the result, add
    an <literal>INTO</literal> clause.
-->
    単一行を編訳するSQL文を実行するには、<command>EXECUTE</command> を使うことができます。
    結果を保存するには、<literal>INTO</literal> 句を追加します。
<programlisting><![CDATA[
EXEC SQL BEGIN DECLARE SECTION;
const char *stmt = "SELECT a, b, c FROM test1 WHERE a > ?";
int v1, v2;
VARCHAR v3[50];
EXEC SQL END DECLARE SECTION;

EXEC SQL PREPARE mystmt FROM :stmt;
 ...
EXEC SQL EXECUTE mystmt INTO :v1, :v2, :v3 USING 37;
]]>
</programlisting>
<!--
    An <command>EXECUTE</command> command can have an
    <literal>INTO</literal> clause, a <literal>USING</literal> clause,
    both, or neither.
-->
<command>EXECUTE</command>コマンドは<literal>INTO</literal>句、<literal>USING</literal>句、この両方を持つことも、どちらも持たないこともできます。
   </para>

   <para>
<!--
    If a query is expected to return more than one result row, a
    cursor should be used, as in the following example.
    (See <xref linkend="ecpg-cursors"> for more details about the
    cursor.)
-->
    クエリが2行以上の結果を返すことが想定される場合、以下の例のようにカーソルを使う必要があります。
    （カーソルの詳細については <xref linkend="ecpg-cursors"> を参照してください）
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
char dbaname[128];
char datname[128];
char *stmt = "SELECT u.usename as dbaname, d.datname "
             "  FROM pg_database d, pg_user u "
             "  WHERE d.datdba = u.usesysid";
EXEC SQL END DECLARE SECTION;

EXEC SQL CONNECT TO testdb AS con1 USER testuser;

EXEC SQL PREPARE stmt1 FROM :stmt;

EXEC SQL DECLARE cursor1 CURSOR FOR stmt1;
EXEC SQL OPEN cursor1;

EXEC SQL WHENEVER NOT FOUND DO BREAK;

while (1)
{
    EXEC SQL FETCH cursor1 INTO :dbaname,:datname;
    printf("dbaname=%s, datname=%s\n", dbaname, datname);
}

EXEC SQL CLOSE cursor1;

EXEC SQL COMMIT;
EXEC SQL DISCONNECT ALL;
</programlisting>
   </para>
  </sect2>
 </sect1>

 <sect1 id="ecpg-pgtypes">
<!--
  <title>pgtypes Library</title>
-->
  <title>pgtypes ライブラリ</title>

  <para>
<!--
   The pgtypes library maps <productname>PostgreSQL</productname> database
   types to C equivalents that can be used in C programs. It also offers
   functions to do basic calculations with those types within C, i.e., without
   the help of the <productname>PostgreSQL</productname> server. See the
   following example:
-->
pgtypesライブラリは<productname>PostgreSQL</productname>データベースの型をCプログラムで使用できるようにC言語に対応させます。
また、これらの型を使用したCの基本的な計算を行う関数も提供します。
この計算には、<productname>PostgreSQL</productname>サーバを使用しません。
以下の例を参照してください。
<programlisting><![CDATA[
EXEC SQL BEGIN DECLARE SECTION;
   date date1;
   timestamp ts1, tsout;
   interval iv1;
   char *out;
EXEC SQL END DECLARE SECTION;

PGTYPESdate_today(&date1);
EXEC SQL SELECT started, duration INTO :ts1, :iv1 FROM datetbl WHERE d=:date1;
PGTYPEStimestamp_add_interval(&ts1, &iv1, &tsout);
out = PGTYPEStimestamp_to_asc(&tsout);
printf("Started + duration: %s\n", out);
free(out);
]]>
</programlisting>
  </para>

  <sect2 id="ecpg-pgtypes-numeric">
<!--
   <title>The numeric Type</title>
-->
   <title>numeric 型</title>
   <para>
<!--
    The numeric type offers to do calculations with arbitrary precision. See
    <xref linkend="datatype-numeric"> for the equivalent type in the
    <productname>PostgreSQL</> server. Because of the arbitrary precision this
    variable needs to be able to expand and shrink dynamically. That's why you
    can only create numeric variables on the heap, by means of the
    <function>PGTYPESnumeric_new</> and <function>PGTYPESnumeric_free</>
    functions. The decimal type, which is similar but limited in precision,
    can be created on the stack as well as on the heap.
-->
numeric 型では任意の精度での計算機能を提供します。
<productname>PostgreSQL</>サーバにおける対応する型については<xref linkend="datatype-numeric">を参照してください。
任意の精度を持つために、この変数は動的に拡張、縮小できなければなりません。
これが、<function>PGTYPESnumeric_new</>や<function>PGTYPESnumeric_free</>関数では、ヒープ領域上にのみしか numeric 変数を作成できない理由です。
decimal 型も似ていますが精度が限定されていますので、ヒープ領域以外にスタック領域上でも作成可能です。
   </para>
   <para>
<!--
   The following functions can be used to work with the numeric type:
-->
以下の関数は numeric 型で使用することができます:
   <variablelist>
    <varlistentry>
     <term><function>PGTYPESnumeric_new</function></term>
     <listitem>
      <para>
<!--
      Request a pointer to a newly allocated numeric variable.
-->
新規割当ての numeric 型へのポインタを要求します。
<synopsis>
numeric *PGTYPESnumeric_new(void);
</synopsis>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_free</function></term>
     <listitem>
      <para>
<!--
      Free a numeric type, release all of its memory.
-->
numeric 型を解放し、そのメモリをすべて解放します。
<synopsis>
void PGTYPESnumeric_free(numeric *var);
</synopsis>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_from_asc</function></term>
     <listitem>
      <para>
<!--
       Parse a numeric type from its string notation.
-->
文字列表記から numeric 型に変換します。
<synopsis>
numeric *PGTYPESnumeric_from_asc(char *str, char **endptr);
</synopsis>
<!--
       Valid formats are for example:
        <literal>-2</literal>,
        <literal>.794</literal>,
        <literal>+3.44</literal>,
        <literal>592.49E07</literal> or
        <literal>-32.84e-4</literal>.
       If the value could be parsed successfully, a valid pointer is returned,
       else the NULL pointer. At the moment ECPG always parses the complete
       string and so it currently does not support to store the address of the
       first invalid character in <literal>*endptr</literal>. You can safely
       set <literal>endptr</literal> to NULL.
-->
有効な書式の例を示します。
<literal>-2</literal>、<literal>.794</literal>、<literal>+3.44</literal>、<literal>592.49E07</literal>、<literal>-32.84e-4</literal>。
値への変換に成功した場合、有効なポインタが返されます。
失敗した場合は NULL ポインタが返されます。
現在ECPGは文字列全体を解析しますので、現時点では<literal>*endptr</literal>内に最初の無効な文字のアドレスを格納することをサポートしません。
このため<literal>endptr</literal>を安全に NULL にすることができます。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_to_asc</function></term>
     <listitem>
      <para>
<!--
       Returns a pointer to a string allocated by <function>malloc</function> that contains the string
       representation of the numeric type <literal>num</literal>.
-->
numeric 型<literal>num</literal>の文字列表現を持つ、<function>malloc</function>で割り当てられた文字列へのポインタを返します。
<synopsis>
char *PGTYPESnumeric_to_asc(numeric *num, int dscale);
</synopsis>
<!--
       The numeric value will be printed with <literal>dscale</literal> decimal
       digits, with rounding applied if necessary.
-->
numeric の値は、必要に応じて四捨五入され、<literal>dscale</literal> 桁の十進数で出力されます。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_add</function></term>
     <listitem>
      <para>
<!--
       Add two numeric variables into a third one.
-->
2つの numeric 変数を加算し、3番目の numeric 変数に格納します。
<synopsis>
int PGTYPESnumeric_add(numeric *var1, numeric *var2, numeric *result);
</synopsis>
<!--
       The function adds the variables <literal>var1</literal> and
       <literal>var2</literal> into the result variable
       <literal>result</literal>.
       The function returns 0 on success and -1 in case of error.
-->
この関数は変数<literal>var1</literal>と変数<literal>var2</literal>を加算し、その結果を<literal>result</literal>に格納します。
成功時0を、エラー時-1を返します。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_sub</function></term>
     <listitem>
      <para>
<!--
       Subtract two numeric variables and return the result in a third one.
-->
2つの numeric 型変数を減算し、3番目の numeric 型変数に結果を格納します。
<synopsis>
int PGTYPESnumeric_sub(numeric *var1, numeric *var2, numeric *result);
</synopsis>
<!--
       The function subtracts the variable <literal>var2</literal> from
       the variable <literal>var1</literal>. The result of the operation is
       stored in the variable <literal>result</literal>.
       The function returns 0 on success and -1 in case of error.
-->
この関数は変数<literal>var1</literal>から変数<literal>var2</literal>を差し引きます。
演算結果を変数<literal>result</literal>に格納します。
成功時0を、エラー時-1を返します。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_mul</function></term>
     <listitem>
      <para>
<!--
       Multiply two numeric variables and return the result in a third one.
-->
2つの numeric 型変数を乗算し、3番目の numeric 型変数に結果を格納します。
<synopsis>
int PGTYPESnumeric_mul(numeric *var1, numeric *var2, numeric *result);
</synopsis>
<!--
       The function multiplies the variables <literal>var1</literal> and
       <literal>var2</literal>. The result of the operation is stored in the
       variable <literal>result</literal>.
       The function returns 0 on success and -1 in case of error.
-->
この関数は変数<literal>var1</literal>と変数<literal>var2</literal>を掛け合わせます。
演算結果を変数<literal>result</literal>に格納します。
成功時0を、エラー時-1を返します。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_div</function></term>
     <listitem>
      <para>
<!--
       Divide two numeric variables and return the result in a third one.
-->
2つの numeric 型変数で除算し、3番目の numeric 型変数に結果を格納します。
<synopsis>
int PGTYPESnumeric_div(numeric *var1, numeric *var2, numeric *result);
</synopsis>
<!--
       The function divides the variables <literal>var1</literal> by
       <literal>var2</literal>. The result of the operation is stored in the
       variable <literal>result</literal>.
       The function returns 0 on success and -1 in case of error.
-->
この関数は変数<literal>var1</literal>を変数<literal>var2</literal>で割ります。
演算結果を変数<literal>result</literal>に格納します。
成功時0を、エラー時-1を返します。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_cmp</function></term>
     <listitem>
      <para>
<!--
       Compare two numeric variables.
-->
2つのnumeric型変数を比較します。
<synopsis>
int PGTYPESnumeric_cmp(numeric *var1, numeric *var2)
</synopsis>
<!--
       This function compares two numeric variables. In case of error,
       <literal>INT_MAX</literal> is returned. On success, the function
       returns one of three possible results:
-->
この関数は2つのnumeric型変数を比較します。
エラーの場合<literal>INT_MAX</literal>が返ります。
成功時、この関数は以下のいずれかを返します:
       <itemizedlist>
        <listitem>
         <para>
<!--
          1, if <literal>var1</> is bigger than <literal>var2</>
-->
          <literal>var1</>が<literal>var2</>より大きければ1。
         </para>
        </listitem>
        <listitem>
         <para>
<!--
          -1, if <literal>var1</> is smaller than <literal>var2</>
-->
          <literal>var1</>が<literal>var2</>より小さければ-1。
         </para>
        </listitem>
        <listitem>
         <para>
<!--
          0, if <literal>var1</> and <literal>var2</> are equal
-->
          <literal>var1</>が<literal>var2</>と等しければ0。
         </para>
        </listitem>
       </itemizedlist>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_from_int</function></term>
     <listitem>
      <para>
<!--
       Convert an int variable to a numeric variable.
-->
int型変数をnumeric型変数に変換します。
<synopsis>
int PGTYPESnumeric_from_int(signed int int_val, numeric *var);
</synopsis>
<!--
       This function accepts a variable of type signed int and stores it
       in the numeric variable <literal>var</>. Upon success, 0 is returned and
       -1 in case of a failure.
-->
この関数はsigned int型の変数を受付け、numeric型変数<literal>var</>内に格納します。
成功時0、失敗時-1が返ります。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_from_long</function></term>
     <listitem>
      <para>
<!--
       Convert a long int variable to a numeric variable.
-->
long int型変数をnumeric型変数に変換します。
<synopsis>
int PGTYPESnumeric_from_long(signed long int long_val, numeric *var);
</synopsis>
<!--
       This function accepts a variable of type signed long int and stores it
       in the numeric variable <literal>var</>. Upon success, 0 is returned and
       -1 in case of a failure.
-->
この関数は符号付long int型の変数を受付け、numeric 型変数<literal>var</>内に格納します。
成功時0、失敗時-1が返ります。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_copy</function></term>
     <listitem>
      <para>
<!--
       Copy over one numeric variable into another one.
-->
numeric 型変数を他の numeric 型変数にコピーします。
<synopsis>
int PGTYPESnumeric_copy(numeric *src, numeric *dst);
</synopsis>
<!--
       This function copies over the value of the variable that
       <literal>src</literal> points to into the variable that <literal>dst</>
       points to. It returns 0 on success and -1 if an error occurs.
-->
この関数は、<literal>src</literal>が指し示す変数の値を<literal>dst</>が指し示す変数にコピーします。
成功時0、失敗時-1が返ります。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_from_double</function></term>
     <listitem>
      <para>
<!--
       Convert a variable of type double to a numeric.
-->
double型の変数を numeric 型変数に変換します。
<synopsis>
int  PGTYPESnumeric_from_double(double d, numeric *dst);
</synopsis>
<!--
       This function accepts a variable of type double and stores the result
       in the variable that <literal>dst</> points to. It returns 0 on success
       and -1 if an error occurs.
-->
この関数はdouble型の変数を受付け、変換結果を<literal>dst</>が指し示す変数内に格納します。
成功時0、失敗時-1が返ります。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_to_double</function></term>
     <listitem>
      <para>
<!--
       Convert a variable of type numeric to double.
-->
numeric 型変数をdouble型に変換します。
<synopsis>
int PGTYPESnumeric_to_double(numeric *nv, double *dp)
</synopsis>
<!--
       The function converts the numeric value from the variable that
       <literal>nv</> points to into the double variable that <literal>dp</> points
       to. It returns 0 on success and -1 if an error occurs, including
       overflow. On overflow, the global variable <literal>errno</> will be set
       to <literal>PGTYPES_NUM_OVERFLOW</> additionally.
-->
この関数は<literal>nv</>が指し示す numeric 型変数の値を<literal>dp</>が指し示すdouble型変数に変換します。
成功時0、オーバーフローを含むエラーが発生した時-1が返ります。
オーバーフローが発生した場合はさらに、グローバル変数<literal>errno</>は<literal>PGTYPES_NUM_OVERFLOW</>に設定されます。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_to_int</function></term>
     <listitem>
      <para>
<!--
       Convert a variable of type numeric to int.
-->
numeric 型変数をint型に変換します。
<synopsis>
int PGTYPESnumeric_to_int(numeric *nv, int *ip);
</synopsis>
<!--
       The function converts the numeric value from the variable that
       <literal>nv</> points to into the integer variable that <literal>ip</>
       points to. It returns 0 on success and -1 if an error occurs, including
       overflow. On overflow, the global variable <literal>errno</> will be set
       to <literal>PGTYPES_NUM_OVERFLOW</> additionally.
-->
この関数は<literal>nv</>が指し示す numeric 型変数の値を<literal>ip</>が指し示す整数型変数に変換します。
成功時0、オーバーフローを含むエラーが発生した時-1が返ります。
オーバーフローが発生した場合はさらに、グローバル変数<literal>errno</>は<literal>PGTYPES_NUM_OVERFLOW</>に設定されます。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_to_long</function></term>
     <listitem>
      <para>
<!--
       Convert a variable of type numeric to long.
-->
numeric 型変数をlong型に変換します。
<synopsis>
int PGTYPESnumeric_to_long(numeric *nv, long *lp);
</synopsis>
<!--
       The function converts the numeric value from the variable that
       <literal>nv</> points to into the long integer variable that
       <literal>lp</> points to. It returns 0 on success and -1 if an error
       occurs, including overflow. On overflow, the global variable
       <literal>errno</> will be set to <literal>PGTYPES_NUM_OVERFLOW</>
       additionally.
-->
この関数は<literal>nv</>が指し示す numeric 型変数の値を<literal>lp</>が指し示すlong変数に変換します。
成功時0、オーバーフローを含むエラーが発生した時-1が返ります。
オーバーフローが発生した場合はさらに、グローバル変数<literal>errno</>は<literal>PGTYPES_NUM_OVERFLOW</>に設定されます。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_to_decimal</function></term>
     <listitem>
      <para>
<!--
       Convert a variable of type numeric to decimal.
-->
numeric 型変数を decimal 型に変換します。
<synopsis>
int PGTYPESnumeric_to_decimal(numeric *src, decimal *dst);
</synopsis>
<!--
       The function converts the numeric value from the variable that
       <literal>src</> points to into the decimal variable that
       <literal>dst</> points to. It returns 0 on success and -1 if an error
       occurs, including overflow. On overflow, the global variable
       <literal>errno</> will be set to <literal>PGTYPES_NUM_OVERFLOW</>
       additionally.
-->
この関数は<literal>src</>が指し示す numeric 型変数の値を<literal>dst</>が指し示す decimal 型変数に変換します。
成功時0、オーバーフローを含むエラーが発生した時-1が返ります。
オーバーフローが発生した場合はさらに、グローバル変数<literal>errno</>は<literal>PGTYPES_NUM_OVERFLOW</>に設定されます。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_from_decimal</function></term>
     <listitem>
      <para>
<!--
       Convert a variable of type decimal to numeric.
-->
decimal 型変数を numeric 型に変換します。
<synopsis>
int PGTYPESnumeric_from_decimal(decimal *src, numeric *dst);
</synopsis>
<!--
       The function converts the decimal value from the variable that
       <literal>src</> points to into the numeric variable that
       <literal>dst</> points to. It returns 0 on success and -1 if an error
       occurs. Since the decimal type is implemented as a limited version of
       the numeric type, overflow cannot occur with this conversion.
-->
この関数は<literal>src</>が指し示す decimal 型変数の値を<literal>dst</>が指し示す numeric 型変数に変換します。
成功時0、エラーが発生した時-1が返ります。
decimal 型は制限付の numeric 型として実装されていますので、この変換ではオーバーフローは起きません。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   </para>
  </sect2>

  <sect2 id="ecpg-pgtypes-date">
<!--
   <title>The date Type</title>
-->
   <title>日付型</title>
   <para>
<!--
    The date type in C enables your programs to deal with data of the SQL type
    date. See <xref linkend="datatype-datetime"> for the equivalent type in the
    <productname>PostgreSQL</> server.
-->
Cの日付型を使用して、プログラムからSQLの日付型を取り扱うことができます。
<productname>PostgreSQL</>サーバにおける対応する型については<xref linkend="datatype-datetime">を参照してください。
   </para>
   <para>
<!--
    The following functions can be used to work with the date type:
-->
日付型を操作するために以下の関数を使用することができます:
    <variablelist>
     <varlistentry id="PGTYPESdatefromtimestamp">
      <term><function>PGTYPESdate_from_timestamp</function></term>
      <listitem>
       <para>
<!--
        Extract the date part from a timestamp.
-->
タイムスタンプから日付部分を取り出します。
<synopsis>
date PGTYPESdate_from_timestamp(timestamp dt);
</synopsis>
<!--
        The function receives a timestamp as its only argument and returns the
        extracted date part from this timestamp.
-->
この関数は唯一の引数としてタイムスタンプを受付け、そこから日付部分を取り出します。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPESdatefromasc">
      <term><function>PGTYPESdate_from_asc</function></term>
      <listitem>
       <para>
<!--
       Parse a date from its textual representation.
-->
テキスト表現から日付型に変換します。
<synopsis>
date PGTYPESdate_from_asc(char *str, char **endptr);
</synopsis>
<!--
        The function receives a C char* string <literal>str</> and a pointer to
        a C char* string <literal>endptr</>. At the moment ECPG always parses
        the complete string and so it currently does not support to store the
        address of the first invalid character in <literal>*endptr</literal>.
        You can safely set <literal>endptr</literal> to NULL.
-->
この関数はCのchar*型文字列<literal>str</>とCのchar*型文字列<literal>endptr</>へのポインタを受付けます。
現在ECPGは文字列全体を解析しますので、現時点では<literal>*endptr</literal>に最初の無効な文字のアドレスを格納することをサポートしません。
このため<literal>endptr</literal>を安全にNULLにすることができます。
       </para>
       <para>
<!--
        Note that the function always assumes MDY-formatted dates and there is
        currently no variable to change that within ECPG.
-->
この関数が常にMDY書式の日付を前提としている点に注意してください。
現在ECPGにはこれを変更するための変数がありません。
       </para>
       <para>
<!--
        <xref linkend="ecpg-pgtypesdate-from-asc-table"> shows the allowed input formats.
-->
        <xref linkend="ecpg-pgtypesdate-from-asc-table">に許される入力書式を示します。
       </para>
        <table id="ecpg-pgtypesdate-from-asc-table">
<!--
         <title>Valid Input Formats for <function>PGTYPESdate_from_asc</function></title>
-->
         <title>有効な<function>PGTYPESdate_from_asc</function>の入力書式</title>
         <tgroup cols="2">
          <thead>
           <row>
<!--
            <entry>Input</entry>
            <entry>Result</entry>
-->
            <entry>入力</entry>
            <entry>結果</entry>
           </row>
          </thead>
          <tbody>
           <row>
            <entry><literal>January 8, 1999</literal></entry>
            <entry><literal>January 8, 1999</literal></entry>
           </row>
           <row>
            <entry><literal>1999-01-08</literal></entry>
            <entry><literal>January 8, 1999</literal></entry>
           </row>
           <row>
            <entry><literal>1/8/1999</literal></entry>
            <entry><literal>January 8, 1999</literal></entry>
           </row>
           <row>
            <entry><literal>1/18/1999</literal></entry>
            <entry><literal>January 18, 1999</literal></entry>
           </row>
           <row>
            <entry><literal>01/02/03</literal></entry>
            <entry><literal>February 1, 2003</literal></entry>
           </row>
           <row>
            <entry><literal>1999-Jan-08</literal></entry>
            <entry><literal>January 8, 1999</literal></entry>
           </row>
           <row>
            <entry><literal>Jan-08-1999</literal></entry>
            <entry><literal>January 8, 1999</literal></entry>
           </row>
           <row>
            <entry><literal>08-Jan-1999</literal></entry>
            <entry><literal>January 8, 1999</literal></entry>
           </row>
           <row>
            <entry><literal>99-Jan-08</literal></entry>
            <entry><literal>January 8, 1999</literal></entry>
           </row>
           <row>
            <entry><literal>08-Jan-99</literal></entry>
            <entry><literal>January 8, 1999</literal></entry>
           </row>
           <row>
            <entry><literal>08-Jan-06</literal></entry>
            <entry><literal>January 8, 2006</literal></entry>
           </row>
           <row>
            <entry><literal>Jan-08-99</literal></entry>
            <entry><literal>January 8, 1999</literal></entry>
           </row>
           <row>
            <entry><literal>19990108</literal></entry>
            <entry><literal>ISO 8601; January 8, 1999</literal></entry>
           </row>
           <row>
            <entry><literal>990108</literal></entry>
            <entry><literal>ISO 8601; January 8, 1999</literal></entry>
           </row>
           <row>
            <entry><literal>1999.008</literal></entry>
<!--
            <entry><literal>year and day of year</literal></entry>
-->
            <entry><literal>年と年内日数</literal></entry>
           </row>
           <row>
            <entry><literal>J2451187</literal></entry>
<!--
            <entry><literal>Julian day</literal></entry>
-->
            <entry><literal>Jユリウス日</literal></entry>
           </row>
           <row>
            <entry><literal>January 8, 99 BC</literal></entry>
<!--
            <entry><literal>year 99 before the Common Era</literal></entry>
-->
            <entry><literal>紀元前99年</literal></entry>
           </row>
          </tbody>
         </tgroup>
        </table>
      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPESdatetoasc">
      <term><function>PGTYPESdate_to_asc</function></term>
      <listitem>
       <para>
<!--
        Return the textual representation of a date variable.
-->
        日付型変数のテキスト表現を返します。
<synopsis>
char *PGTYPESdate_to_asc(date dDate);
</synopsis>
<!--
        The function receives the date <literal>dDate</> as its only parameter.
        It will output the date in the form <literal>1999-01-18</>, i.e., in the
        <literal>YYYY-MM-DD</> format.
-->
この関数は唯一の引数として日付型<literal>dDate</>を受付けます。
この関数は<literal>1999-01-18</>、つまり<literal>YYYY-MM-DD</>書式で日付を出力します。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPESdatejulmdy">
      <term><function>PGTYPESdate_julmdy</function></term>
      <listitem>
       <para>
<!--
        Extract the values for the day, the month and the year from a variable
        of type date.
-->
        日付型の変数から、日、月、年の値を取り出します。
<synopsis>
void PGTYPESdate_julmdy(date d, int *mdy);
</synopsis>
       <!-- almost same description as for rjulmdy() -->
<!--
        The function receives the date <literal>d</> and a pointer to an array
        of 3 integer values <literal>mdy</>. The variable name indicates
        the sequential order: <literal>mdy[0]</> will be set to contain the
        number of the month, <literal>mdy[1]</> will be set to the value of the
        day and <literal>mdy[2]</> will contain the year.
-->
この関数は日付型の<literal>d</>と、3つの整数値を持つ配列<literal>mdy</>へのポインタを受付けます。
この変数名はその並びを表し、<literal>mdy[0]</>には月数、<literal>mdy[1]</>には日数が、<literal>mdy[2]</>には年が入ります。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPESdatemdyjul">
      <term><function>PGTYPESdate_mdyjul</function></term>
      <listitem>
       <para>
<!--
        Create a date value from an array of 3 integers that specify the
        day, the month and the year of the date.
-->
日付の日、月、年を指定した3つの整数からなる配列から日付値を作成します。
<synopsis>
void PGTYPESdate_mdyjul(int *mdy, date *jdate);
</synopsis>
<!--
        The function receives the array of the 3 integers (<literal>mdy</>) as
        its first argument and as its second argument a pointer to a variable
        of type date that should hold the result of the operation.
-->
この関数は、1番目の引数として3つの整数からなる配列(<literal>mdy</>)、2番目の引数として処理結果を格納する日付型の変数へのポインタを受付けます。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPESdatedayofweek">
      <term><function>PGTYPESdate_dayofweek</function></term>
      <listitem>
       <para>
<!--
        Return a number representing the day of the week for a date value.
-->
日付値から週内日数を表す数を返します。
<synopsis>
int PGTYPESdate_dayofweek(date d);
</synopsis>
<!--
        The function receives the date variable <literal>d</> as its only
        argument and returns an integer that indicates the day of the week for
        this date.
-->
この関数は唯一の引数としてdate型変数<literal>d</>を受付け、その日付の週内日数を表す整数を返します。
        <itemizedlist>
         <listitem>
          <para>
<!--
           0 - Sunday
-->
           0 - 日曜
          </para>
         </listitem>
         <listitem>
          <para>
<!--
           1 - Monday
-->
           1 - 月曜
          </para>
         </listitem>
         <listitem>
          <para>
<!--
           2 - Tuesday
-->
           2 - 火曜
          </para>
         </listitem>
         <listitem>
          <para>
<!--
           3 - Wednesday
-->
           3 - 水曜
          </para>
         </listitem>
         <listitem>
          <para>
<!--
           4 - Thursday
-->
           4 - 木曜
          </para>
         </listitem>
         <listitem>
          <para>
<!--
           5 - Friday
-->
           5 - 金曜
          </para>
         </listitem>
         <listitem>
          <para>
<!--
           6 - Saturday
-->
           6 - 土曜
          </para>
         </listitem>
        </itemizedlist>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPESdatetoday">
      <term><function>PGTYPESdate_today</function></term>
      <listitem>
       <para>
<!--
        Get the current date.
-->
現在の日付を取得します。
<synopsis>
void PGTYPESdate_today(date *d);
</synopsis>
<!--
        The function receives a pointer to a date variable (<literal>d</>)
        that it sets to the current date.
-->
この関数は現在の日付に設定されるdate型変数(<literal>d</>)を指し示すポインタを受付けます。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPESdatefmtasc">
      <term><function>PGTYPESdate_fmt_asc</function></term>
      <listitem>
       <para>
<!--
        Convert a variable of type date to its textual representation using a
        format mask.
-->
date型変数を書式マスクを使用したテキスト表現に変換します。
<synopsis>
int PGTYPESdate_fmt_asc(date dDate, char *fmtstring, char *outbuf);
</synopsis>
<!--
        The function receives the date to convert (<literal>dDate</>), the
        format mask (<literal>fmtstring</>) and the string that will hold the
        textual representation of the date (<literal>outbuf</>).
-->
この関数は変換対象のdate型(<literal>dDate</>)、書式マスク(<literal>fmtstring</>)、日付のテキスト表現を格納するための文字列(<literal>outbuf</>)を受付けます。
       </para>
       <para>
<!--
        On success, 0 is returned and a negative value if an error occurred.
-->
成功時に0、エラーが発生した場合は負の値が返ります。
       </para>
       <para>
<!--
        The following literals are the field specifiers you can use:
-->
以下のリテラルを使用して、フィールドを指定することができます。
        <itemizedlist>
         <listitem>
          <para>
<!--
           <literal>dd</literal> - The number of the day of the month.
-->
           <literal>dd</literal> - 月内の日数。
          </para>
         </listitem>
         <listitem>
          <para>
<!--
           <literal>mm</literal> - The number of the month of the year.
-->
           <literal>mm</literal> - 年内の月数。
          </para>
         </listitem>
         <listitem>
          <para>
<!--
           <literal>yy</literal> - The number of the year as a two digit number.
-->
           <literal>yy</literal> - 二桁表記の年数
          </para>
         </listitem>
         <listitem>
          <para>
<!--
           <literal>yyyy</literal> - The number of the year as a four digit number.
-->
           <literal>yyyy</literal> - 四桁表記の年数
          </para>
         </listitem>
         <listitem>
          <para>
<!--
           <literal>ddd</literal> - The name of the day (abbreviated).
-->
           <literal>ddd</literal> - 曜日の名前（省略形）
          </para>
         </listitem>
         <listitem>
          <para>
<!--
           <literal>mmm</literal> - The name of the month (abbreviated).
-->
           <literal>mmm</literal> - 月の名前（省略形）
          </para>
         </listitem>
        </itemizedlist>
<!--
        All other characters are copied 1:1 to the output string.
-->
他の文字はすべて出力文字列にそのままコピーされます。
       </para>
       <para>
<!--
        <xref linkend="ecpg-pgtypesdate-fmt-asc-example-table"> indicates a few possible formats. This will give
        you an idea of how to use this function. All output lines are based on
        the same date: November 23, 1959.
-->
<xref linkend="ecpg-pgtypesdate-fmt-asc-example-table">にいくつかの可能性のある書式を示します。
この関数の使用方法に関するアイディアを提供しています。
出力行はすべて同じ日付、1959年11月23日に基づいています。
       </para>
        <table id="ecpg-pgtypesdate-fmt-asc-example-table">
<!--
         <title>Valid Input Formats for <function>PGTYPESdate_fmt_asc</function></title>
-->
         <title>有効な<function>PGTYPESdate_fmt_asc</function>の入力書式</title>
         <tgroup cols="2">
          <thead>
           <row>
<!--
            <entry>Format</entry>
            <entry>Result</entry>
-->
            <entry>書式</entry>
            <entry>結果</entry>
           </row>
          </thead>
          <tbody>
           <row>
            <entry><literal>mmddyy</literal></entry>
            <entry><literal>112359</literal></entry>
           </row>
           <row>
            <entry><literal>ddmmyy</literal></entry>
            <entry><literal>231159</literal></entry>
           </row>
           <row>
            <entry><literal>yymmdd</literal></entry>
            <entry><literal>591123</literal></entry>
           </row>
           <row>
            <entry><literal>yy/mm/dd</literal></entry>
            <entry><literal>59/11/23</literal></entry>
           </row>
           <row>
            <entry><literal>yy mm dd</literal></entry>
            <entry><literal>59 11 23</literal></entry>
           </row>
           <row>
            <entry><literal>yy.mm.dd</literal></entry>
            <entry><literal>59.11.23</literal></entry>
           </row>
           <row>
            <entry><literal>.mm.yyyy.dd.</literal></entry>
            <entry><literal>.11.1959.23.</literal></entry>
           </row>
           <row>
            <entry><literal>mmm. dd, yyyy</literal></entry>
            <entry><literal>Nov. 23, 1959</literal></entry>
           </row>
           <row>
            <entry><literal>mmm dd yyyy</literal></entry>
            <entry><literal>Nov 23 1959</literal></entry>
           </row>
           <row>
            <entry><literal>yyyy dd mm</literal></entry>
            <entry><literal>1959 23 11</literal></entry>
           </row>
           <row>
            <entry><literal>ddd, mmm. dd, yyyy</literal></entry>
            <entry><literal>Mon, Nov. 23, 1959</literal></entry>
           </row>
           <row>
            <entry><literal>(ddd) mmm. dd, yyyy</literal></entry>
            <entry><literal>(Mon) Nov. 23, 1959</literal></entry>
           </row>
          </tbody>
         </tgroup>
        </table>
      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPESdatedefmtasc">
      <term><function>PGTYPESdate_defmt_asc</function></term>
      <listitem>
       <para>
<!--
        Use a format mask to convert a C <type>char*</type> string to a value of type
        date.
-->
書式マスクを使用してCの<type>char*</type>文字列からdate型の値に変換します。
<synopsis>
int PGTYPESdate_defmt_asc(date *d, char *fmt, char *str);
</synopsis>
        <!-- same description as rdefmtdate -->
<!--
        The function receives a pointer to the date value that should hold the
        result of the operation (<literal>d</>), the format mask to use for
        parsing the date (<literal>fmt</>) and the C char* string containing
        the textual representation of the date (<literal>str</>). The textual
        representation is expected to match the format mask. However you do not
        need to have a 1:1 mapping of the string to the format mask. The
        function only analyzes the sequential order and looks for the literals
        <literal>yy</literal> or <literal>yyyy</literal> that indicate the
        position of the year, <literal>mm</literal> to indicate the position of
        the month and <literal>dd</literal> to indicate the position of the
        day.
-->
この関数は、処理結果を格納するための日付型へのポインタ(<literal>d</>)、日付を解析するための書式マスク(<literal>fmt</>)、日付のテキスト表現を含むCのchar*文字列(<literal>str</>)を受付けます。
テキスト表現は書式マスクに合った表現であることが仮定されています。
しかし、文字列と書式マスクを1:1に対応付けする必要はありません。
この関数は並んだ順番に解析し、年の位置を表す<literal>yy</literal>または<literal>yyyy</literal>を、月の位置を表す<literal>mm</literal>を、日の位置を表す<literal>dd</literal>を検索します。
       </para>
       <para>
<!--
        <xref linkend="ecpg-rdefmtdate-example-table"> indicates a few possible formats. This will give
        you an idea of how to use this function.
-->
<xref linkend="ecpg-rdefmtdate-example-table">はいくつかの可能性のある書式を示します。
これはこの関数の使用方法に関するアイディアを提供します。
       </para>
        <table id="ecpg-rdefmtdate-example-table">
<!--
         <title>Valid Input Formats for <function>rdefmtdate</function></title>
-->
         <title>有効な<function>rdefmtdate</function>の入力書式</title>
         <tgroup cols="3">
          <thead>
           <row>
<!--
            <entry>Format</entry>
            <entry>String</entry>
            <entry>Result</entry>
-->
            <entry>書式</entry>
            <entry>文字列</entry>
            <entry>結果</entry>
           </row>
          </thead>
          <tbody>
           <row>
            <entry><literal>ddmmyy</literal></entry>
            <entry><literal>21-2-54</literal></entry>
            <entry><literal>1954-02-21</literal></entry>
           </row>
           <row>
            <entry><literal>ddmmyy</literal></entry>
            <entry><literal>2-12-54</literal></entry>
            <entry><literal>1954-12-02</literal></entry>
           </row>
           <row>
            <entry><literal>ddmmyy</literal></entry>
            <entry><literal>20111954</literal></entry>
            <entry><literal>1954-11-20</literal></entry>
           </row>
           <row>
            <entry><literal>ddmmyy</literal></entry>
            <entry><literal>130464</literal></entry>
            <entry><literal>1964-04-13</literal></entry>
           </row>
           <row>
            <entry><literal>mmm.dd.yyyy</literal></entry>
            <entry><literal>MAR-12-1967</literal></entry>
            <entry><literal>1967-03-12</literal></entry>
           </row>
           <row>
            <entry><literal>yy/mm/dd</literal></entry>
            <entry><literal>1954, February 3rd</literal></entry>
            <entry><literal>1954-02-03</literal></entry>
           </row>
           <row>
            <entry><literal>mmm.dd.yyyy</literal></entry>
            <entry><literal>041269</literal></entry>
            <entry><literal>1969-04-12</literal></entry>
           </row>
           <row>
            <entry><literal>yy/mm/dd</literal></entry>
            <entry><literal>In the year 2525, in the month of July, mankind will be alive on the 28th day</literal></entry>
            <entry><literal>2525-07-28</literal></entry>
           </row>
           <row>
            <entry><literal>dd-mm-yy</literal></entry>
            <entry><literal>I said on the 28th of July in the year 2525</literal></entry>
            <entry><literal>2525-07-28</literal></entry>
           </row>
           <row>
            <entry><literal>mmm.dd.yyyy</literal></entry>
            <entry><literal>9/14/58</literal></entry>
            <entry><literal>1958-09-14</literal></entry>
           </row>
           <row>
            <entry><literal>yy/mm/dd</literal></entry>
            <entry><literal>47/03/29</literal></entry>
            <entry><literal>1947-03-29</literal></entry>
           </row>
           <row>
            <entry><literal>mmm.dd.yyyy</literal></entry>
            <entry><literal>oct 28 1975</literal></entry>
            <entry><literal>1975-10-28</literal></entry>
           </row>
           <row>
            <entry><literal>mmddyy</literal></entry>
            <entry><literal>Nov 14th, 1985</literal></entry>
            <entry><literal>1985-11-14</literal></entry>
           </row>
          </tbody>
         </tgroup>
        </table>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </sect2>

  <sect2 id="ecpg-pgtypes-timestamp">
<!--
   <title>The timestamp Type</title>
-->
   <title>timestamp型</title>
   <para>
<!--
    The timestamp type in C enables your programs to deal with data of the SQL
    type timestamp. See <xref linkend="datatype-datetime"> for the equivalent
    type in the <productname>PostgreSQL</> server.
-->
Cのタイムスタンプ型を使用してプログラムからSQLのタイムスタンプ型データを扱うことができます。
<productname>PostgreSQL</>における対応する型については<xref linkend="datatype-datetime">を参照してください。
   </para>
   <para>
<!--
    The following functions can be used to work with the timestamp type:
-->
以下の関数を使用してタイムスタンプ型を扱うことができます:
    <variablelist>
     <varlistentry id="PGTYPEStimestampfromasc">
      <term><function>PGTYPEStimestamp_from_asc</function></term>
      <listitem>
       <para>
<!--
        Parse a timestamp from its textual representation into a timestamp
        variable.
-->
テキスト表現のタイムスタンプをタイムスタンプ型変数に変換します。
<synopsis>
timestamp PGTYPEStimestamp_from_asc(char *str, char **endptr);
</synopsis>
<!--
        The function receives the string to parse (<literal>str</>) and a
        pointer to a C char* (<literal>endptr</>).
        At the moment ECPG always parses
        the complete string and so it currently does not support to store the
        address of the first invalid character in <literal>*endptr</literal>.
        You can safely set <literal>endptr</literal> to NULL.
-->
この関数は変換対象の文字列(<literal>str</>)とC char*へのポインタ(<literal>endptr</>)を受付けます。
現在ECPGは文字列全体を解析しますので、現時点では<literal>*endptr</literal>に最初の無効な文字の場所を格納をすることサポートしません。
このため<literal>endptr</literal>を安全に NULL にすることができます。
       </para>
       <para>
<!--
        The function returns the parsed timestamp on success. On error,
        <literal>PGTYPESInvalidTimestamp</literal> is returned and <varname>errno</> is
        set to <literal>PGTYPES_TS_BAD_TIMESTAMP</>. See <xref linkend="PGTYPESInvalidTimestamp"> for important notes on this value.
-->
この関数は成功時変換後のタイムスタンプを返します。
エラー時、<literal>PGTYPESInvalidTimestamp</literal>が返され、<varname>errno</>が<literal>PGTYPES_TS_BAD_TIMESTAMP</>に設定されます。
この値についての重要な注意書きについて<xref linkend="PGTYPESInvalidTimestamp">を参照してください。
       </para>
       <para>
<!--
        In general, the input string can contain any combination of an allowed
        date specification, a whitespace character and an allowed time
        specification. Note that time zones are not supported by ECPG. It can
        parse them but does not apply any calculation as the
        <productname>PostgreSQL</> server does for example. Timezone
        specifiers are silently discarded.
-->
通常、入力文字列には許される日付指定の任意の組み合わせ、空白文字、許される時間指定を含むことができます。
時間帯はECPGでサポートされていない点に注意してください。
変換することはできますが、例えば<productname>PostgreSQL</>サーバが行うような計算を行うことはできません。
時間帯指定は警告無しに無視されます。
       </para>
       <para>
<!--
        <xref linkend="ecpg-pgtypestimestamp-from-asc-example-table"> contains a few examples for input strings.
-->
<xref linkend="ecpg-pgtypestimestamp-from-asc-example-table">に入力文字列の例をいくつか示します。
       </para>
        <table id="ecpg-pgtypestimestamp-from-asc-example-table">
<!--
         <title>Valid Input Formats for <function>PGTYPEStimestamp_from_asc</function></title>
-->
         <title>有効な<function>PGTYPEStimestamp_from_asc</function>の入力書式</title>
         <tgroup cols="2">
          <thead>
           <row>
<!--
            <entry>Input</entry>
            <entry>Result</entry>
-->
            <entry>入力</entry>
            <entry>結果</entry>
           </row>
          </thead>
          <tbody>
           <row>
            <entry><literal>1999-01-08 04:05:06</literal></entry>
            <entry><literal>1999-01-08 04:05:06</literal></entry>
           </row>
           <row>
            <entry><literal>January 8 04:05:06 1999 PST</literal></entry>
            <entry><literal>1999-01-08 04:05:06</literal></entry>
           </row>
           <row>
            <entry><literal>1999-Jan-08 04:05:06.789-8</literal></entry>
<!--
            <entry><literal>1999-01-08 04:05:06.789 (time zone specifier ignored)</literal></entry>
-->
            <entry><literal>1999-01-08 04:05:06.789 (時間帯指定は無視されます。)</literal></entry>
           </row>
           <row>
            <entry><literal>J2451187 04:05-08:00</literal></entry>
<!--
            <entry><literal>1999-01-08 04:05:00 (time zone specifier ignored)</literal></entry>
-->
            <entry><literal>1999-01-08 04:05:00 (時間帯指定は無視されます。)</literal></entry>
           </row>
          </tbody>
         </tgroup>
        </table>
      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPEStimestamptoasc">
      <term><function>PGTYPEStimestamp_to_asc</function></term>
      <listitem>
       <para>
<!--
        Converts a date to a C char* string.
-->
date型をC char*文字列に変換します。
<synopsis>
char *PGTYPEStimestamp_to_asc(timestamp tstamp);
</synopsis>
<!--
        The function receives the timestamp <literal>tstamp</> as
        its only argument and returns an allocated string that contains the
        textual representation of the timestamp.
-->
この関数はtimestamp型の<literal>tstamp</>を唯一の引数として受付け、timestamp型のテキスト表現を含む割り当てられた文字列を返します。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPEStimestampcurrent">
      <term><function>PGTYPEStimestamp_current</function></term>
      <listitem>
       <para>
<!--
        Retrieve the current timestamp.
-->
現在のタイムスタンプを取り出します。
<synopsis>
void PGTYPEStimestamp_current(timestamp *ts);
</synopsis>
<!--
        The function retrieves the current timestamp and saves it into the
        timestamp variable that <literal>ts</> points to.
-->
この関数は現在のタイムスタンプを取り出し、<literal>ts</>が指し示すtimestamp型変数に格納します。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPEStimestampfmtasc">
      <term><function>PGTYPEStimestamp_fmt_asc</function></term>
      <listitem>
       <para>
<!--
        Convert a timestamp variable to a C char* using a format mask.
-->
書式マスクを使用してtimestamp型変数をC char*に変換します。
<synopsis>
int PGTYPEStimestamp_fmt_asc(timestamp *ts, char *output, int str_len, char *fmtstr);
</synopsis>
<!--
        The function receives a pointer to the timestamp to convert as its
        first argument (<literal>ts</>), a pointer to the output buffer
        (<literal>output</>), the maximal length that has been allocated for
        the output buffer (<literal>str_len</literal>) and the format mask to
        use for the conversion (<literal>fmtstr</literal>).
-->
この関数は、最初の引数として変換対象のtimestamp型 (<literal>ts</>)を、出力バッファのポインタ(<literal>output</>)、出力バッファで割当て可能な最大長 (<literal>str_len</literal>)、変換に使用する書式マスク(<literal>fmtstr</literal>)を受付けます。
       </para>
       <para>
<!--
        Upon success, the function returns 0 and a negative value if an
        error occurred.
-->
成功するとこの関数は0を返します。
エラーが発生した場合は負の値が返ります。
       </para>
       <para>
<!--
        You can use the following format specifiers for the format mask. The
        format specifiers are the same ones that are used in the
        <function>strftime</> function in <productname>libc</productname>. Any
        non-format specifier will be copied into the output buffer.
-->
書式マスクには以下の書式指定を使用することができます。
書式指定は<productname>libc</productname>の<function>strftime</>関数で使用されるものと同じです。
書式指定以外は出力バッファにコピーされます。
        <!-- This is from the FreeBSD man page:
             http://www.freebsd.org/cgi/man.cgi?query=strftime&apropos=0&sektion=3&manpath=FreeBSD+7.0-current&format=html
        -->
        <itemizedlist>
         <listitem>
          <para>
<!--
           <literal>%A</literal> - is replaced by national representation of
           the full weekday name.
-->
<literal>%A</literal> - 各言語の曜日名称に置換されます。
          </para>
         </listitem>
         <listitem>
          <para>
<!--
           <literal>%a</literal> - is replaced by national representation of
           the abbreviated weekday name.
-->
<literal>%a</literal> - 各言語の曜日略称に置換されます。
          </para>
         </listitem>
         <listitem>
          <para>
<!--
           <literal>%B</literal> - is replaced by national representation of
           the full month name.
-->
<literal>%B</literal> - 各言語の月名称に置換されます。
          </para>
         </listitem>
         <listitem>
          <para>
<!--
           <literal>%b</literal> - is replaced by national representation of
           the abbreviated month name.
-->
<literal>%b</literal> - 各言語の月略称に置換されます。
          </para>
         </listitem>
         <listitem>
          <para>
<!--
           <literal>%C</literal> - is replaced by (year / 100) as decimal
           number; single digits are preceded by a zero.
-->
<literal>%C</literal> - 年を100で割った10進数に置換されます。1桁の場合は先頭に0が付与されます。
          </para>
         </listitem>
         <listitem>
          <para>
<!--
           <literal>%c</literal> - is replaced by national representation of
           time and date.
-->
<literal>%c</literal> - 各言語の日付時刻表現に置換されます。
          </para>
         </listitem>
         <listitem>
          <para>
<!--
           <literal>%D</literal> - is equivalent to
           <literal>%m/%d/%y</literal>.
-->
<literal>%D</literal> - <literal>%m/%d/%y</literal>と同じです。
          </para>
         </listitem>
         <listitem>
          <para>
<!--
           <literal>%d</literal> - is replaced by the day of the month as a
           decimal number (01-31).
-->
<literal>%d</literal> - 月内の10進日数(01-31)に置換されます。
          </para>
         </listitem>
         <listitem>
          <para>
<!--
           <literal>%E*</literal> <literal>%O*</literal> -  POSIX locale
           extensions. The sequences
           <literal>%Ec</literal>
           <literal>%EC</literal>
           <literal>%Ex</literal>
           <literal>%EX</literal>
           <literal>%Ey</literal>
           <literal>%EY</literal>
           <literal>%Od</literal>
           <literal>%Oe</literal>
           <literal>%OH</literal>
           <literal>%OI</literal>
           <literal>%Om</literal>
           <literal>%OM</literal>
           <literal>%OS</literal>
           <literal>%Ou</literal>
           <literal>%OU</literal>
           <literal>%OV</literal>
           <literal>%Ow</literal>
           <literal>%OW</literal>
           <literal>%Oy</literal>
           are supposed to provide alternative representations.
-->
<literal>%E*</literal> <literal>%O*</literal> - POSIXロケール拡張です。
           <literal>%Ec</literal>
           <literal>%EC</literal> 
           <literal>%Ex</literal> 
           <literal>%EX</literal> 
           <literal>%Ey</literal> 
           <literal>%EY</literal> 
           <literal>%Od</literal> 
           <literal>%Oe</literal>
           <literal>%OH</literal> 
           <literal>%OI</literal> 
           <literal>%Om</literal> 
           <literal>%OM</literal> 
           <literal>%OS</literal> 
           <literal>%Ou</literal> 
           <literal>%OU</literal> 
           <literal>%OV</literal> 
           <literal>%Ow</literal> 
           <literal>%OW</literal> 
           <literal>%Oy</literal> 
という並びは別の表現を提供するものと仮定されています。
          </para>
          <para>
<!--
           Additionally <literal>%OB</literal> implemented to represent
           alternative months names (used standalone, without day mentioned).
-->
さらに、<literal>%OB</literal>は、（日に関する仕様がない単体で使用される）別の月名を表すものとして実装されています。
          </para>
         </listitem>
         <listitem>
          <para>
<!--
           <literal>%e</literal> - is replaced by the day of month as a decimal
           number (1-31); single digits are preceded by a blank.
-->
<literal>%e</literal> - 月内10進日数(1-31)に置換されます。1桁の場合は前に空白が付けられます。
          </para>
         </listitem>
         <listitem>
          <para>
<!--
           <literal>%F</literal> - is equivalent to <literal>%Y-%m-%d</literal>.
-->
<literal>%F</literal> - <literal>%Y-%m-%d</literal>と同じです。
          </para>
         </listitem>
         <listitem>
          <para>
<!--
           <literal>%G</literal> - is replaced by a year as a decimal number
           with century. This year is the one that contains the greater part of
           the week (Monday as the first day of the week).
-->
<literal>%G</literal> - 世紀付の10進数として年に置換されます。
この年は週の部分がより多く含まれます。（月曜が週の最初の日です。）
          </para>
         </listitem>
         <listitem>
          <para>
<!--
           <literal>%g</literal> - is replaced by the same year as in
           <literal>%G</literal>, but as a decimal number without century
           (00-99).
-->
<literal>%g</literal> -<literal>%G</literal>同様に年に置換されますが、世紀の部分を除く10進数(00-99)になります。
          </para>
         </listitem>
         <listitem>
          <para>
<!--
           <literal>%H</literal> - is replaced by the hour (24-hour clock) as a
           decimal number (00-23).
-->
<literal>%H</literal> - 10進の時間(24時間単位)に置換されます(00-23)。
          </para>
         </listitem>
         <listitem>
          <para>
<!--
           <literal>%h</literal> - the same as <literal>%b</literal>.
-->
           <literal>%h</literal> - <literal>%b</literal>と同じです。
          </para>
         </listitem>
         <listitem>
          <para>
<!--
           <literal>%I</literal> - is replaced by the hour (12-hour clock) as a
           decimal number (01-12).
-->
<literal>%I</literal> - 10進の時間（12時間単位）に置換されます(01-12)。
          </para>
         </listitem>
         <listitem>
          <para>
<!--
           <literal>%j</literal> - is replaced by the day of the year as a
           decimal number (001-366).
-->
<literal>%j</literal> - 10進の年内日数に置換されます(001-366)。
          </para>
         </listitem>
         <listitem>
          <para>
<!--
           <literal>%k</literal> - is replaced by the hour (24-hour clock) as a
           decimal number (0-23); single digits are preceded by a blank.
-->
<literal>%k</literal> - 10進の時間(24時間単位)に置換されます(0-23)。1桁の場合は先頭に空白が付けられます。
          </para>
         </listitem>
         <listitem>
          <para>
<!--
           <literal>%l</literal> - is replaced by the hour (12-hour clock) as a
           decimal number (1-12); single digits are preceded by a blank.
-->
<literal>%l</literal> - 10進の時間（12時間単位）に置換されます(1-12)。1桁の場合は先頭に空白が付けられます。
          </para>
         </listitem>
         <listitem>
          <para>
<!--
           <literal>%M</literal> - is replaced by the minute as a decimal
           number (00-59).
-->
<literal>%M</literal> - 10進の分数に置換されます(00-59)。
          </para>
         </listitem>
         <listitem>
          <para>
<!--
           <literal>%m</literal> - is replaced by the month as a decimal number
           (01-12).
-->
<literal>%m</literal> -10進の月数に置換されます(01-12)。
          </para>
         </listitem>
         <listitem>
          <para>
<!--
          <literal>%n</literal> - is replaced by a newline.
-->
<literal>%n</literal> - 改行に置換されます。
          </para>
         </listitem>
         <listitem>
          <para>
<!--
           <literal>%O*</literal> - the same as <literal>%E*</literal>.
-->
<literal>%O*</literal> - <literal>%E*</literal>と同じです。
          </para>
         </listitem>
         <listitem>
          <para>
<!--
           <literal>%p</literal> - is replaced by national representation of
           either <quote>ante meridiem</quote> or <quote>post meridiem</quote> as appropriate.
-->
<literal>%p</literal> - 各言語の"午前"または"午後"に適切に置換されます。
          </para>
         </listitem>
         <listitem>
          <para>
<!--
           <literal>%R</literal> - is equivalent to <literal>%H:%M</literal>.
-->
<literal>%R</literal> - <literal>%H:%M</literal>と同じです。
          </para>
         </listitem>
         <listitem>
          <para>
<!--
           <literal>%r</literal> - is equivalent to <literal>%I:%M:%S
           %p</literal>.
-->
           <literal>%r</literal> - <literal>%I:%M:%S %p</literal>と同じです。
          </para>
         </listitem>
         <listitem>
          <para>
<!--
           <literal>%S</literal> - is replaced by the second as a decimal
           number (00-60).
-->
<literal>%S</literal> - 10進の秒数に置換されます(00-60)。
          </para>
         </listitem>
         <listitem>
          <para>
<!--
           <literal>%s</literal> - is replaced by the number of seconds since
           the Epoch, UTC.
-->
<literal>%s</literal> - エポック、UTCからの秒数に置換されます。
          </para>
         </listitem>
         <listitem>
          <para>
<!--
           <literal>%T</literal> - is equivalent to <literal>%H:%M:%S</literal>
-->
           <literal>%T</literal> - <literal>%H:%M:%S</literal>と同じです。
          </para>
         </listitem>
         <listitem>
          <para>
<!--
           <literal>%t</literal> - is replaced by a tab.
-->
<literal>%t</literal> - タブに置換されます。
          </para>
         </listitem>
         <listitem>
          <para>
<!--
           <literal>%U</literal> - is replaced by the week number of the year
           (Sunday as the first day of the week) as a decimal number (00-53).
-->
           <literal>%U</literal> - 10進の週番号（日曜が週の先頭です）に置換されます。
          </para>
         </listitem>
         <listitem>
          <para>
<!--
           <literal>%u</literal> - is replaced by the weekday (Monday as the
           first day of the week) as a decimal number (1-7).
-->
           <literal>%u</literal> - 10進の週番号（月曜が週の先頭です）に置換されます。
          </para>
         </listitem>
         <listitem>
          <para>
<!--
           <literal>%V</literal> - is replaced by the week number of the year
           (Monday as the first day of the week) as a decimal number (01-53).
           If the week containing January 1 has four or more days in the new
           year, then it is week 1; otherwise it is the last week of the
           previous year, and the next week is week 1.
-->
<literal>%V</literal> - 10進の年内の週番号（月曜が週の先頭です）に置換されます(01-53)。
新しい年で、1月1日を含む週が4日以上存在する場合、その週が1となります。
さもなくば、この週は前年の週となり、次の週が1となります。
          </para>
         </listitem>
         <listitem>
          <para>
<!--
           <literal>%v</literal> - is equivalent to
           <literal>%e-%b-%Y</literal>.
-->
           <literal>%v</literal> - <literal>%e-%b-%Y</literal>と同じです。
          </para>
         </listitem>
         <listitem>
          <para>
<!--
           <literal>%W</literal> - is replaced by the week number of the year
           (Monday as the first day of the week) as a decimal number (00-53).
-->
<literal>%W</literal> - 10進の年内の週番号（月曜が週の先頭です）に置換されます(00-53)。
          </para>
         </listitem>
         <listitem>
          <para>
<!--
           <literal>%w</literal> - is replaced by the weekday (Sunday as the
           first day of the week) as a decimal number (0-6).
-->
<literal>%w</literal> - 10進の週内日数（日曜が週の先頭です）に置換されます(0-6)。
          </para>
         </listitem>
         <listitem>
          <para>
<!--
           <literal>%X</literal> - is replaced by national representation of
           the time.
-->
<literal>%X</literal> - 各言語の時間表現に置換されます。
          </para>
         </listitem>
         <listitem>
          <para>
<!--
           <literal>%x</literal> - is replaced by national representation of
           the date.
-->
<literal>%x</literal> - 各言語の日付表現に置換されます。
          </para>
         </listitem>
         <listitem>
          <para>
<!--
           <literal>%Y</literal> - is replaced by the year with century as a
           decimal number.
-->
<literal>%Y</literal> - 10進の世紀付年に置換されます。
          </para>
         </listitem>
         <listitem>
          <para>
<!--
           <literal>%y</literal> - is replaced by the year without century as a
           decimal number (00-99).
-->
<literal>%y</literal> - 10進の世紀なし年に置換されます(00-99)。
          </para>
         </listitem>
         <listitem>
          <para>
<!--
           <literal>%Z</literal> - is replaced by the time zone name.
-->
<literal>%Z</literal> - 時間帯名称に置換されます。
          </para>
         </listitem>
         <listitem>
          <para>
<!--
           <literal>%z</literal> - is replaced by the time zone offset from
           UTC; a leading plus sign stands for east of UTC, a minus sign for
           west of UTC, hours and minutes follow with two digits each and no
           delimiter between them (common form for RFC 822 date headers).
-->
<literal>%z</literal> - UTCからの時間帯オフセットに置換されます。
UTCより東では正符号が先頭に付き、西では負符号が付きます。
それぞれ2桁の時間と分がその後に続きますが、その区切りはありません。（この形式はRFC 822の日付ヘッダでよく使用されます。）
          </para>
         </listitem>
         <listitem>
          <para>
<!--
           <literal>%+</literal> - is replaced by national representation of
           the date and time.
-->
<literal>%+</literal> - 各言語の日付時刻表現に置換されます。
          </para>
         </listitem>
         <listitem>
          <para>
<!--
           <literal>%-*</literal> - GNU libc extension. Do not do any padding
           when performing numerical outputs.
-->
<literal>%-*</literal> - GNU libc拡張です。数値出力を行う際に何も文字を詰めません。
          </para>
         </listitem>
         <listitem>
          <para>
<!--
           $_* - GNU libc extension.    Explicitly specify space for padding.
-->
$_* - GNU libcの拡張です。明示的に空白文字を使用して文字を詰めます。
          </para>
         </listitem>
         <listitem>
          <para>
<!--
           <literal>%0*</literal> - GNU libc extension. Explicitly specify zero
           for padding.
-->
<literal>%0*</literal> - GNU libcの拡張です。明示的に0を使用して文字を詰めます。
          </para>
         </listitem>
         <listitem>
          <para>
<!--
           <literal>%%</literal> - is replaced by <literal>%</literal>.
-->
           <literal>%%</literal> - <literal>%</literal>に置換されます。
          </para>
         </listitem>
        </itemizedlist>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPEStimestampsub">
      <term><function>PGTYPEStimestamp_sub</function></term>
      <listitem>
       <para>
<!--
        Subtract one timestamp from another one and save the result in a
        variable of type interval.
-->
タイムスタンプの減算を行い、その結果をinterval型の変数に格納します。
<synopsis>
int PGTYPEStimestamp_sub(timestamp *ts1, timestamp *ts2, interval *iv);
</synopsis>
<!--
        The function will subtract the timestamp variable that <literal>ts2</>
        points to from the timestamp variable that <literal>ts1</> points to
        and will store the result in the interval variable that <literal>iv</>
        points to.
-->
この関数は<literal>ts1</>が指し示すタイムスタンプ型変数から<literal>ts2</>が指し示すタイムスタンプ型変数を差し引き、<literal>iv</>が指し示すinterval型変数に結果を格納します。
       </para>
       <para>
<!--
        Upon success, the function returns 0 and a negative value if an
        error occurred.
-->
成功すると、この関数は0を返し、エラーが発生した場合は負の値を返します。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPEStimestampdefmtasc">
      <term><function>PGTYPEStimestamp_defmt_asc</function></term>
      <listitem>
       <para>
<!--
        Parse a timestamp value from its textual representation using a
        formatting mask.
-->
書式マスクを使用して、テキスト表現からtimestamp値へ変換します。
<synopsis>
int PGTYPEStimestamp_defmt_asc(char *str, char *fmt, timestamp *d);
</synopsis>
<!--
        The function receives the textual representation of a timestamp in the
        variable <literal>str</> as well as the formatting mask to use in the
        variable <literal>fmt</>. The result will be stored in the variable
        that <literal>d</> points to.
-->
この関数は<literal>str</>変数内に格納されたタイムスタンプのテキスト表現、<literal>fmt</>変数内に格納された使用される書式マスクを受付けます。
結果は<literal>d</>が指し示す変数内に格納されます。
       </para>
       <para>
<!--
        If the formatting mask <literal>fmt</> is NULL, the function will fall
        back to the default formatting mask which is <literal>%Y-%m-%d
        %H:%M:%S</literal>.
-->
書式マスク<literal>fmt</>が NULL ならば、この関数はデフォルトの書式マスク<literal>%Y-%m-%d %H:%M:%S</literal>を使用するようになります。
       </para>
       <para>
<!--
        This is the reverse function to <xref
        linkend="PGTYPEStimestampfmtasc">.  See the documentation there in
        order to find out about the possible formatting mask entries.
-->
これは<xref linkend="PGTYPEStimestampfmtasc">関数の逆です。
使用できる書式マスク項目についてはその文書を参照してください。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPEStimestampaddinterval">
      <term><function>PGTYPEStimestamp_add_interval</function></term>
      <listitem>
       <para>
<!--
        Add an interval variable to a timestamp variable.
-->
timestamp型変数にinterval型変数を加算します。
<synopsis>
int PGTYPEStimestamp_add_interval(timestamp *tin, interval *span, timestamp *tout);
</synopsis>
<!--
        The function receives a pointer to a timestamp variable <literal>tin</>
        and a pointer to an interval variable <literal>span</>. It adds the
        interval to the timestamp and saves the resulting timestamp in the
        variable that <literal>tout</> points to.
-->
この関数はtimestamp型変数<literal>tin</>へのポインタとinterval型変数<literal>span</>へのポインタを受付けます。
これは、interval値をtimestamp値に加算し、その結果のtimestamp値を<literal>tout</>が指し示す変数に格納します。
       </para>
       <para>
<!--
        Upon success, the function returns 0 and a negative value if an
        error occurred.
-->
成功するとこの関数は0を返します。
エラーが発生した場合は負の値を返します。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPEStimestampsubinterval">
      <term><function>PGTYPEStimestamp_sub_interval</function></term>
      <listitem>
       <para>
<!--
        Subtract an interval variable from a timestamp variable.
-->
timestamp型変数からinterval型変数の値を引きます。
<synopsis>
int PGTYPEStimestamp_sub_interval(timestamp *tin, interval *span, timestamp *tout);
</synopsis>
<!--
        The function subtracts the interval variable that <literal>span</>
        points to from the timestamp variable that <literal>tin</> points to
        and saves the result into the variable that <literal>tout</> points
        to.
-->
この関数は<literal>tin</>が指し示すtimestamp型変数から<literal>span</>が指し示すinterval型変数を引きます。
結果は<literal>tout</>が指し示す変数に保存されます。
       </para>
       <para>
<!--
        Upon success, the function returns 0 and a negative value if an
        error occurred.
-->
成功するとこの関数は0を、エラーが発生した場合は負の値を返します。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </sect2>

  <sect2 id="ecpg-pgtypes-interval">
<!--
   <title>The interval Type</title>
-->
   <title>interval型</title>
   <para>
<!--
    The interval type in C enables your programs to deal with data of the SQL
    type interval. See <xref linkend="datatype-datetime"> for the equivalent
    type in the <productname>PostgreSQL</> server.
-->
Cにおけるinterval型を用いることにより、プログラムからSQLのinterval型のデータを扱うことができます。
<productname>PostgreSQL</>サーバにおける対応する型については<xref linkend="datatype-datetime">を参照してください。
   </para>
   <para>
<!--
    The following functions can be used to work with the interval type:
-->
以下の関数を使用して、interval型を扱うことができます。
    <variablelist>

     <varlistentry id="PGTYPESintervalnew">
      <term><function>PGTYPESinterval_new</function></term>
      <listitem>
       <para>
<!--
        Return a pointer to a newly allocated interval variable.
-->
新しく割り当てたinterval型変数へのポインタを返します。
<synopsis>
interval *PGTYPESinterval_new(void);
</synopsis>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPESintervalfree">
      <term><function>PGTYPESinterval_free</function></term>
      <listitem>
       <para>
<!--
        Release the memory of a previously allocated interval variable.
-->
以前に割り当てられたinterval型変数のメモリを解放します。
<synopsis>
void PGTYPESinterval_new(interval *intvl);
</synopsis>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPESintervalfromasc">
      <term><function>PGTYPESinterval_from_asc</function></term>
      <listitem>
       <para>
<!--
        Parse an interval from its textual representation.
-->
テキスト表現からinterval型に変換します。
<synopsis>
interval *PGTYPESinterval_from_asc(char *str, char **endptr);
</synopsis>
<!--
        The function parses the input string <literal>str</> and returns a
        pointer to an allocated interval variable.
        At the moment ECPG always parses
        the complete string and so it currently does not support to store the
        address of the first invalid character in <literal>*endptr</literal>.
        You can safely set <literal>endptr</literal> to NULL.
-->
この関数は入力文字列<literal>str</>を変換し、割当てられたinterval型へのポインタを返します。
現在ECPGは文字列全体を解析しますので、現時点では<literal>*endptr</literal>に最初の無効な文字のアドレスを格納することをサポートしません。
このため<literal>endptr</literal>を安全に NULL にすることができます。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPESintervaltoasc">
      <term><function>PGTYPESinterval_to_asc</function></term>
      <listitem>
       <para>
<!--
        Convert a variable of type interval to its textual representation.
-->
interval型変数をテキスト表現に変換します。
<synopsis>
char *PGTYPESinterval_to_asc(interval *span);
</synopsis>
<!--
        The function converts the interval variable that <literal>span</>
        points to into a C char*. The output looks like this example:
        <literal>@ 1 day 12 hours 59 mins 10 secs</literal>.
-->
この関数は<literal>span</>が指し示すinterval型変数をC char*に変換します。
出力は<literal>@ 1 day 12 hours 59 mins 10 secs</literal>のようになります。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="PGTYPESintervalcopy">
      <term><function>PGTYPESinterval_copy</function></term>
      <listitem>
       <para>
<!--
        Copy a variable of type interval.
-->
interval型変数をコピーします。
<synopsis>
int PGTYPESinterval_copy(interval *intvlsrc, interval *intvldest);
</synopsis>
<!--
        The function copies the interval variable that <literal>intvlsrc</>
        points to into the variable that <literal>intvldest</> points to. Note
        that you need to allocate the memory for the destination variable
        before.
-->
この関数は、<literal>intvlsrc</>が指し示すinterval型変数を <literal>intvldest</>が指し示す変数にコピーします。
事前に格納先の変数用のメモリを割り当てる必要があることに注意してください。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </sect2>

  <sect2 id="ecpg-pgtypes-decimal">
<!--
   <title>The decimal Type</title>
-->
   <title>decimal型</title>
   <para>
<!--
     The decimal type is similar to the numeric type. However it is limited to
     a maximum precision of 30 significant digits. In contrast to the numeric
     type which can be created on the heap only, the decimal type can be
     created either on the stack or on the heap (by means of the functions
     <function>PGTYPESdecimal_new</> and
     <function>PGTYPESdecimal_free</>).
     There are a lot of other functions that deal with the decimal type in the
     <productname>Informix</productname> compatibility mode described in <xref
     linkend="ecpg-informix-compat">.
-->
decimal型はnumeric型に似ています。
しかし、その最大精度は30有効桁に制限されています。
ヒープ上にしか作成できないnumeric型と比べ、decimal型はスタックまたはヒープ上に作成することができます。
（このためには<function>PGTYPESdecimal_new</>および<function>PGTYPESdecimal_free</>関数を使用します。）
<xref linkend="ecpg-informix-compat">で説明する<productname>Informix</productname>互換モードではdecimal型を扱う関数がより多く存在します。
   </para>
   <para>
<!--
    The following functions can be used to work with the decimal type and are
    not only contained in the <literal>libcompat</> library.
-->
以下の関数を使用してdecimal型を扱うことができます。
これらは<literal>libcompat</>ライブラリに含まれるものだけではありません。
    <variablelist>
     <varlistentry>
      <term><function>PGTYPESdecimal_new</function></term>
      <listitem>
       <para>
<!--
       Request a pointer to a newly allocated decimal variable.
-->
新しく割り当てられたdecimal型変数へのポインタを要求します。
<synopsis>
decimal *PGTYPESdecimal_new(void);
</synopsis>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>PGTYPESdecimal_free</function></term>
      <listitem>
       <para>
<!--
       Free a decimal type, release all of its memory.
-->
decimal型を解放し、そのメモリをすべて解放します。
<synopsis>
void PGTYPESdecimal_free(decimal *var);
</synopsis>
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </sect2>

   <sect2 id="ecpg-pgtypes-errno">
<!--
    <title>errno Values of pgtypeslib</title>
-->
    <title>pgtypeslibのerrno値</title>
   <para>
    <variablelist>
     <varlistentry>
      <term><literal>PGTYPES_NUM_BAD_NUMERIC</literal></term>
      <listitem>
       <para>
<!--
        An argument should contain a numeric variable (or point to a numeric
        variable) but in fact its in-memory representation was invalid.
-->
引数はnumeric型変数（またはnumeric型変数へのポインタ）を含んでいるはずですが、実際のメモリ上の表現は無効でした。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_NUM_OVERFLOW</literal></term>
      <listitem>
       <para>
<!--
        An overflow occurred. Since the numeric type can deal with almost
        arbitrary precision, converting a numeric variable into other types
        might cause overflow.
-->
オーバーフローが発生しました。
numeric型はほぼ任意の精度を扱うことができますので、numeric型変数から他の型への変換ではオーバーフローが発生する可能性があります。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_NUM_UNDERFLOW</literal></term>
      <listitem>
       <para>
<!--
        An underflow occurred. Since the numeric type can deal with almost
        arbitrary precision, converting a numeric variable into other types
        might cause underflow.
-->
アンダーフローが発生しました。
numeric型はほぼ任意の精度を扱うことができますので、numeric型変数から他の型への変換ではアンダーフローが発生する可能性があります。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_NUM_DIVIDE_ZERO</literal></term>
      <listitem>
       <para>
<!--
        A division by zero has been attempted.
-->
ゼロ除算をしようとしました。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_DATE_BAD_DATE</literal></term>
      <listitem>
       <para>
<!--
        An invalid date string was passed to
        the <function>PGTYPESdate_from_asc</function> function.
-->
<function>PGTYPESdate_from_asc</function>関数に無効な日付文字列が渡されました。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_DATE_ERR_EARGS</literal></term>
      <listitem>
       <para>
<!--
        Invalid arguments were passed to the
        <function>PGTYPESdate_defmt_asc</function> function.
-->
<function>PGTYPESdate_defmt_asc</function>関数に無効な引数が渡されました。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_DATE_ERR_ENOSHORTDATE</literal></term>
      <listitem>
       <para>
<!--
        An invalid token in the input string was found by the
        <function>PGTYPESdate_defmt_asc</function> function.
-->
<function>PGTYPESdate_defmt_asc</function>関数により入力文字列内に無効なトークンが見つかりました。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_INTVL_BAD_INTERVAL</literal></term>
      <listitem>
       <para>
<!--
        An invalid interval string was passed to the
        <function>PGTYPESinterval_from_asc</function> function, or an
        invalid interval value was passed to the
        <function>PGTYPESinterval_to_asc</function> function.
-->
<function>PGTYPESinterval_from_asc</function>関数に無効な内部文字列が渡されました。
もしくは<function>PGTYPESinterval_to_asc</function>関数に無効な内部値が渡されました。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_DATE_ERR_ENOTDMY</literal></term>
      <listitem>
       <para>
<!--
        There was a mismatch in the day/month/year assignment in the
        <function>PGTYPESdate_defmt_asc</function> function.
-->
<function>PGTYPESdate_defmt_asc</function>関数内の日/月/年の代入において不整合がありました。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_DATE_BAD_DAY</literal></term>
      <listitem>
       <para>
<!--
        An invalid day of the month value was found by
        the <function>PGTYPESdate_defmt_asc</function> function.
-->
<function>PGTYPESdate_defmt_asc</function>関数により無効な月内日数が見つかりました。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_DATE_BAD_MONTH</literal></term>
      <listitem>
       <para>
<!--
        An invalid month value was found by
        the <function>PGTYPESdate_defmt_asc</function> function.
-->
<function>PGTYPESdate_defmt_asc</function>関数によって無効な月値が見つかりました。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_TS_BAD_TIMESTAMP</literal></term>
      <listitem>
       <para>
<!--
        An invalid timestamp string pass passed to
        the <function>PGTYPEStimestamp_from_asc</function> function,
        or an invalid timestamp value was passed to
        the <function>PGTYPEStimestamp_to_asc</function> function.
-->
<function>PGTYPEStimestamp_from_asc</function>関数に無効なタイムスタンプ文字列が渡されました。
もしくは<function>PGTYPEStimestamp_to_asc</function>関数に無効なtimestamp値が渡されました。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_TS_ERR_EINFTIME</literal></term>
      <listitem>
       <para>
<!--
        An infinite timestamp value was encountered in a context that
        cannot handle it.
-->
コンテキスト内で扱うことができない、無限なタイムスタンプ値がありました。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </sect2>

   <sect2 id="ecpg-pgtypes-constants">
<!--
    <title>Special Constants of pgtypeslib</title>
-->
    <title>pgtypeslibの特殊な定数</title>
   <para>
    <variablelist>
     <varlistentry id="PGTYPESInvalidTimestamp">
      <term><literal>PGTYPESInvalidTimestamp</literal></term>
      <listitem>
       <para>
<!--
        A value of type timestamp representing an invalid time stamp. This is
        returned by the function <function>PGTYPEStimestamp_from_asc</> on
        parse error.
        Note that due to the internal representation of the <type>timestamp</type> data type,
        <literal>PGTYPESInvalidTimestamp</literal> is also a valid timestamp at
        the same time. It is set to <literal>1899-12-31 23:59:59</>. In order
        to detect errors, make sure that your application does not only test
        for <literal>PGTYPESInvalidTimestamp</literal> but also for
        <literal>errno != 0</> after each call to
        <function>PGTYPEStimestamp_from_asc</>.
-->
無効なタイムスタンプを表すtimestamp型の値です。
これは解析エラーの場合に<function>PGTYPEStimestamp_from_asc</>関数によって返されます。
<type>timestamp</type>データ型の内部表現のため、<literal>PGTYPESInvalidTimestamp</literal>はまた同時に有効なタイムスタンプでもあります。
これは<literal>1899-12-31 23:59:59</>に設定されます。
エラーを検知するためには、<function>PGTYPEStimestamp_from_asc</>を呼び出す度にその後、<literal>PGTYPESInvalidTimestamp</literal>を試験するだけではなく、<literal>errno != 0</>も試験してください。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </sect2>
 </sect1>

 <sect1 id="ecpg-descriptors">
<!--
  <title>Using Descriptor Areas</title>
-->
  <title>記述子領域の使用</title>

  <para>
<!--
   An SQL descriptor area is a more sophisticated method for processing
   the result of a <command>SELECT</command>, <command>FETCH</command> or
   a <command>DESCRIBE</command> statement. An SQL descriptor area groups
   the data of one row of data together with metadata items into one
   data structure.  The metadata is particularly useful when executing
   dynamic SQL statements, where the nature of the result columns might
   not be known ahead of time. PostgreSQL provides two ways to use
   Descriptor Areas: the named SQL Descriptor Areas and the C-structure
   SQLDAs.
-->
SQL記述子領域は<command>SELECT</command>、<command>FETCH</command>、<command>DESCRIBE</command>文の結果を処理する、より洗練された手法です。
SQL記述子領域は1行のデータをメタデータ項目と一緒に1つのデータ構造体としてグループ化します。
特に動的SQL文を実行する場合は結果列の性質が前もってわかりませんので、メタデータが有用です。
PostgreSQLは記述子領域を使用するための2つの方法、名前付きSQL記述子領域とC構造化SQLDA、を提供します。
  </para>

  <sect2 id="ecpg-named-descriptors">
<!--
   <title>Named SQL Descriptor Areas</title>
-->
   <title>名前付きSQL記述子領域</title>

   <para>
<!--
    A named SQL descriptor area consists of a header, which contains
    information concerning the entire descriptor, and one or more item
    descriptor areas, which basically each describe one column in the
    result row.
-->
名前付きSQL記述子領域は、記述子全体に関する情報を持つヘッダと、基本的に結果行内の1つの列を記述する、1つ以上の項目記述子領域から構成されます。
   </para>

   <para>
<!--
    Before you can use an SQL descriptor area, you need to allocate one:
-->
SQL記述子領域を使用可能にするためには、それを以下のように割り当てなければなりません。
<programlisting>
EXEC SQL ALLOCATE DESCRIPTOR <replaceable>identifier</replaceable>;
</programlisting>
<!--
    The identifier serves as the <quote>variable name</quote> of the
    descriptor area.  <remark>The scope of the allocated descriptor is WHAT?.</remark>
    When you don't need the descriptor anymore, you should deallocate
    it:
-->
この識別子は記述子領域の<quote>変数名</quote>として使用されます。
<remark>割り当てられた記述子のスコープは何でしょう?</remark>
記述子が不要になったら、以下のように解放してください。
<programlisting>
EXEC SQL DEALLOCATE DESCRIPTOR <replaceable>identifier</replaceable>;
</programlisting>
   </para>

   <para>
<!--
    To use a descriptor area, specify it as the storage target in an
    <literal>INTO</literal> clause, instead of listing host variables:
-->
記述子領域を使用するには、<literal>INTO</literal>句内の格納対象として、ホスト変数を列挙するのではなく、記述子領域を指定してください。
<programlisting>
EXEC SQL FETCH NEXT FROM mycursor INTO SQL DESCRIPTOR mydesc;
</programlisting>
<!--
    If the result set is empty, the Descriptor Area will still contain
    the metadata from the query, i.e. the field names.
-->
結果セットが空の場合であっても、記述子領域には問い合わせのメタデータ、つまりフィールド名、が含まれます。
   </para>

   <para>
<!--
    For not yet executed prepared queries, the <command>DESCRIBE</command>
    statement can be used to get the metadata of the result set:
-->
まだ実行されていないプリペアド問い合わせでは、結果セットのメタデータを入手するために<command>DESCRIBE</command>を使用することができます。
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
char *sql_stmt = "SELECT * FROM table1";
EXEC SQL END DECLARE SECTION;

EXEC SQL PREPARE stmt1 FROM :sql_stmt;
EXEC SQL DESCRIBE stmt1 INTO SQL DESCRIPTOR mydesc;
</programlisting>
   </para>

   <para>
<!--
    Before PostgreSQL 9.0, the <literal>SQL</literal> keyword was optional,
    so using <literal>DESCRIPTOR</literal> and <literal>SQL DESCRIPTOR</literal>
    produced named SQL Descriptor Areas. Now it is mandatory, omitting
    the <literal>SQL</literal> keyword produces SQLDA Descriptor Areas,
    see <xref linkend="ecpg-sqlda-descriptors">.
-->
PostgreSQL 9.0より前では、<literal>SQL</literal>キーワードは省略可能でした。
このため<literal>DESCRIPTOR</literal>および<literal>SQL DESCRIPTOR</literal>は名前付きSQL記述子領域を生成しました。
これは強制事項になり、<literal>SQL</literal>キーワードを省略すると、SQLDA記述子領域を生成します。
<xref linkend="ecpg-sqlda-descriptors">を参照してください。
   </para>

   <para>
<!--
    In <command>DESCRIBE</command> and <command>FETCH</command> statements,
    the <literal>INTO</literal> and <literal>USING</literal> keywords can be
    used to similarly: they produce the result set and the metadata in a
    Descriptor Area.
-->
<command>DESCRIBE</command>および<command>FETCH</command>文では、<literal>INTO</literal>および<literal>USING</literal>キーワードを同じように使用することができます。
これらは結果セットと記述子領域内のメタデータを生成します。
   </para>

   <para>
<!--
    Now how do you get the data out of the descriptor area?  You can
    think of the descriptor area as a structure with named fields.  To
    retrieve the value of a field from the header and store it into a
    host variable, use the following command:
-->
さて、どうやって記述子領域からデータを取り出すのでしょうか。
この記述子領域を名前付きフィールドを持つ構造体とみなすことができます。
ヘッダからフィールド値を取り出し、それをホスト変数に格納するには、以下のコマンドを使用します。
<programlisting>
EXEC SQL GET DESCRIPTOR <replaceable>name</replaceable> :<replaceable>hostvar</replaceable> = <replaceable>field</replaceable>;
</programlisting>
<!--
    Currently, there is only one header field defined:
    <replaceable>COUNT</replaceable>, which tells how many item
    descriptor areas exist (that is, how many columns are contained in
    the result).  The host variable needs to be of an integer type.  To
    get a field from the item descriptor area, use the following
    command:
-->
今のところ、<replaceable>COUNT</replaceable>というヘッダフィールドが1つだけ定義されています。
これは、記述子領域に存在する項目数を表すものです
（つまり、結果内に含まれる列数です）。
このホスト変数は整数型でなければなりません。
項目記述子領域からフィールドを取り出すには、以下のコマンドを使用します。
<programlisting>
EXEC SQL GET DESCRIPTOR <replaceable>name</replaceable> VALUE <replaceable>num</replaceable> :<replaceable>hostvar</replaceable> = <replaceable>field</replaceable>;
</programlisting>
<!--
    <replaceable>num</replaceable> can be a literal integer or a host
    variable containing an integer. Possible fields are:
-->
<replaceable>num</replaceable>はリテラル整数、もしくは整数を持つホスト変数を取ることができます。
取り得るフィールドは以下の通りです。

    <variablelist>
     <varlistentry>
<!--
      <term><literal>CARDINALITY</literal> (integer)</term>
-->
      <term><literal>CARDINALITY</literal> (整数)</term>
      <listitem>
       <para>
<!--
        number of rows in the result set
-->
結果セット内の行数です。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>DATA</literal></term>
      <listitem>
       <para>
<!--
        actual data item (therefore, the data type of this field
        depends on the query)
-->
実際のデータ項目です
（したがってこのフィールドのデータ型は問い合わせに依存します）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--
      <term><literal>DATETIME_INTERVAL_CODE</literal> (integer)</term>
-->
      <term><literal>DATETIME_INTERVAL_CODE</literal> (整数)</term>
      <listitem>
       <para>
<!--
        When <literal>TYPE</literal> is <literal>9</literal>,
        <literal>DATETIME_INTERVAL_CODE</literal> will have a value of
        <literal>1</literal> for <literal>DATE</literal>,
        <literal>2</literal> for <literal>TIME</literal>,
        <literal>3</literal> for <literal>TIMESTAMP</literal>,
        <literal>4</literal> for <literal>TIME WITH TIME ZONE</literal>, or
        <literal>5</literal> for <literal>TIMESTAMP WITH TIME ZONE</literal>.
-->
<literal>TYPE</literal>が<literal>9</literal>の場合、<literal>DATETIME_INTERVAL_CODE</literal>は、<literal>DATE</literal>では<literal>1</literal>、<literal>TIME</literal>では<literal>2</literal>、<literal>TIMESTAMP</literal>では<literal>3</literal>、<literal>TIME WITH TIME ZONE</literal>では<literal>4</literal>、<literal>TIMESTAMP WITH TIME ZONE</literal>では<literal>5</literal>という値を取ります。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--
      <term><literal>DATETIME_INTERVAL_PRECISION</literal> (integer)</term>
-->
      <term><literal>DATETIME_INTERVAL_PRECISION</literal> (整数)</term>
      <listitem>
       <para>
<!--
        not implemented
-->
未実装です。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--
      <term><literal>INDICATOR</literal> (integer)</term>
-->
      <term><literal>INDICATOR</literal> (整数)</term>
      <listitem>
       <para>
<!--
        the indicator (indicating a null value or a value truncation)
-->
（NULL値や値の切り詰めを示す）指示子です。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--
      <term><literal>KEY_MEMBER</literal> (integer)</term>
-->
      <term><literal>KEY_MEMBER</literal> (整数)</term>
      <listitem>
       <para>
<!--
        not implemented
-->
実装されていません。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--
      <term><literal>LENGTH</literal> (integer)</term>
-->
      <term><literal>LENGTH</literal> (整数)</term>
      <listitem>
       <para>
<!--
        length of the datum in characters
-->
データの文字列の長さです。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--
      <term><literal>NAME</literal> (string)</term>
-->
      <term><literal>NAME</literal> (文字列)</term>
      <listitem>
       <para>
<!--
        name of the column
-->
列名です。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--
      <term><literal>NULLABLE</literal> (integer)</term>
-->
      <term><literal>NULLABLE</literal> (整数)</term>
      <listitem>
       <para>
<!--
        not implemented
-->
実装されていません。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--
      <term><literal>OCTET_LENGTH</literal> (integer)</term>
-->
      <term><literal>OCTET_LENGTH</literal> (整数)</term>
      <listitem>
       <para>
<!--
        length of the character representation of the datum in bytes
-->
データの文字表現のバイト長です。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--
      <term><literal>PRECISION</literal> (integer)</term>
-->
      <term><literal>PRECISION</literal> (整数)</term>
      <listitem>
       <para>
<!--
        precision (for type <type>numeric</type>)
-->
（<type>numeric</type>型用の）精度です。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--
      <term><literal>RETURNED_LENGTH</literal> (integer)</term>
-->
      <term><literal>RETURNED_LENGTH</literal> (整数)</term>
      <listitem>
       <para>
<!--
        length of the datum in characters
-->
データの文字数です。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--
      <term><literal>RETURNED_OCTET_LENGTH</literal> (integer)</term>
-->
      <term><literal>RETURNED_OCTET_LENGTH</literal> (整数)</term>
      <listitem>
       <para>
<!--
        length of the character representation of the datum in bytes
-->
データの文字表現のバイト長です。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--
      <term><literal>SCALE</literal> (integer)</term>
-->
      <term><literal>SCALE</literal> (整数)</term>
      <listitem>
       <para>
<!--
        scale (for type <type>numeric</type>)
-->
（<type>numeric</type>型用の）桁です。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--
      <term><literal>TYPE</literal> (integer)</term>
-->
      <term><literal>TYPE</literal> (整数)</term>
      <listitem>
       <para>
<!--
        numeric code of the data type of the column
-->
列のデータ型の数値コードです。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>

   <para>
<!--
    In <command>EXECUTE</command>, <command>DECLARE</command> and <command>OPEN</command>
    statements, the effect of the <literal>INTO</literal> and <literal>USING</literal>
    keywords are different. A Descriptor Area can also be manually built to
    provide the input parameters for a query or a cursor and
    <literal>USING SQL DESCRIPTOR <replaceable>name</replaceable></literal>
    is the way to pass the input parameters into a parameterized query. The statement
    to build a named SQL Descriptor Area is below:
-->
<command>EXECUTE</command>、<command>DECLARE</command>および<command>OPEN</command>文では、<literal>INTO</literal>および<literal>USING</literal>の効果は異なります。
また、問い合わせやカーソル用の入力パラメータを提供するために記述子領域は手作業で構築することができます。
<literal>USING SQL DESCRIPTOR <replaceable>name</replaceable></literal>は入力パラメータとパラメータ付きの問い合わせに渡す方法です。
名前付きSQL記述子領域を構築するSQL文は以下の通りです。
<programlisting>
EXEC SQL SET DESCRIPTOR <replaceable>name</replaceable> VALUE <replaceable>num</replaceable> <replaceable>field</replaceable> = :<replaceable>hostvar</replaceable>;
</programlisting>
   </para>

   <para>
<!--
    PostgreSQL supports retrieving more that one record in one <command>FETCH</command>
    statement and storing the data in host variables in this case assumes that the
    variable is an array. E.g.:
-->
PostgreSQLは、1つの<command>FETCH</command>文内の1レコードを複数取り出し、ホスト変数に格納することをサポートします。
この場合ホスト変数は配列であると仮定されます。
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
int id[5];
EXEC SQL END DECLARE SECTION;

EXEC SQL FETCH 5 FROM mycursor INTO SQL DESCRIPTOR mydesc;

EXEC SQL GET DESCRIPTOR mydesc VALUE 1 :id = DATA;
</programlisting>

   </para>

  </sect2>

  <sect2 id="ecpg-sqlda-descriptors">
<!--
   <title>SQLDA Descriptor Areas</title>
-->
   <title>SQLDA記述子領域</title>

   <para>
<!--
    An SQLDA Descriptor Area is a C language structure which can be also used
    to get the result set and the metadata of a query. One structure stores one
    record from the result set.
-->
SQLDA記述子領域は、問い合わせの結果セットとメタデータを取り出すために使用可能なC言語の構造体です。
1つの構造体には結果セットの1レコードが格納されます。
<programlisting>
EXEC SQL include sqlda.h;
sqlda_t         *mysqlda;

EXEC SQL FETCH 3 FROM mycursor INTO DESCRIPTOR mysqlda;
</programlisting>
<!--
    Note that the <literal>SQL</literal> keyword is omitted. The paragraphs about
    the use cases of the <literal>INTO</literal> and <literal>USING</literal>
    keywords in <xref linkend="ecpg-named-descriptors"> also apply here with an addition.
    In a <command>DESCRIBE</command> statement the <literal>DESCRIPTOR</literal>
    keyword can be completely omitted if the <literal>INTO</literal> keyword is used:
-->
<literal>SQL</literal>キーワードが省略されていることに注意してください。
<xref linkend="ecpg-named-descriptors">の<literal>INTO</literal>および<literal>USING</literal>の使用状況に関する段落はここで多少追加して適用します。
<command>DESCRIBE</command>文では、<literal>INTO</literal>が使用されている場合<literal>DESCRIPTOR</literal>キーワードは完全に省略可能です。
<programlisting>
EXEC SQL DESCRIBE prepared_statement INTO mysqlda;
</programlisting>
   </para>

    <procedure>
     <para>
<!--
      The general flow of a program that uses SQLDA is:
-->
SQLDAを使用するプログラムの一般的な流れは以下の通りです。
     </para>
<!--
     <step><simpara>Prepare a query, and declare a cursor for it.</simpara></step>
     <step><simpara>Declare an SQLDA for the result rows.</simpara></step>
     <step><simpara>Declare an SQLDA for the input parameters, and initialize them (memory allocation, parameter settings).</simpara></step>
     <step><simpara>Open a cursor with the input SQLDA.</simpara></step>
     <step><simpara>Fetch rows from the cursor, and store them into an output SQLDA.</simpara></step>
     <step><simpara>Read values from the output SQLDA into the host variables (with conversion if necessary).</simpara></step>
     <step><simpara>Close the cursor.</simpara></step>
     <step><simpara>Free the memory area allocated for the input SQLDA.</simpara></step>
-->
     <step><simpara>問い合わせをプリペアし、そのカーソルを宣言します。</simpara></step>
     <step><simpara>結果セット用のSQLDAを宣言します。</simpara></step>
     <step><simpara>入力パラメータ用のSQLDAを宣言し、初期化（メモリ割り当て、パラメータの設定）します。</simpara></step>
     <step><simpara>入力用SQLDAでカーソルを開きます。</simpara></step>
     <step><simpara>カーソルから行を取り出し、出力用SQLDAに格納します。</simpara></step>
     <step><simpara>出力用SQLDAから値をホスト変数に（必要に応じて変換を行い）読み取ります。</simpara></step>
     <step><simpara>カーソルを閉じます。</simpara></step>
     <step><simpara>入力用SQLDAに割り当てられたメモリ領域を解放します。</simpara></step>
    </procedure>

   <sect3>
<!--
    <title>SQLDA Data Structure</title>
-->
    <title>SQLDAのデータ構造</title>

    <para>
<!--
     SQLDA uses three data structure
     types: <type>sqlda_t</type>, <type>sqlvar_t</type>,
     and <type>struct sqlname</type>.
-->
SQLDAは<type>sqlda_t</type>、<type>sqlvar_t</type>、<type>struct sqlname</type>という３つの種類のデータ構造を使用します。
    </para>

    <tip>
     <para>
<!--
      PostgreSQL's SQLDA has a similar data structure to the one in
      IBM DB2 Universal Database, so some technical information on
      DB2's SQLDA could help understanding PostgreSQL's one better.
-->
PostgreSQLのSQLDAはIBM DB2ユニバーサルデータベースのものと似たデータ構造を持ちます。
このため、DB2のSQLDAに関する技術情報の一部はPostgreSQLのSQLDAの理解のより良い助けになるでしょう。
     </para>
    </tip>

    <sect4 id="ecpg-sqlda-sqlda">
<!--
     <title>sqlda_t Structure</title>
-->
     <title>sqlda_t構造体</title>

     <para>
<!--
      The structure type <type>sqlda_t</type> is the type of the
      actual SQLDA.  It holds one record.  And two or
      more <type>sqlda_t</type> structures can be connected in a
      linked list with the pointer in
      the <structfield>desc_next</structfield> field, thus
      representing an ordered collection of rows.  So, when two or
      more rows are fetched, the application can read them by
      following the <structfield>desc_next</structfield> pointer in
      each <type>sqlda_t</type> node.
-->
<type>sqlda_t</type>構造体は実際のSQLDAの型です。
これは１つのレコードを保持します。
そして２つ以上の<type>sqlda_t</type>構造体を<structfield>desc_next</structfield>フィールド内においてポインタを使ってリンクリスト内でつなげることができます。
こうして行の順序付き集合を表現します。
このため、２つ以上の行を取り出す時、アプリケーションは各<type>sqlda_t</type>ノードの<structfield>desc_next</structfield>ポインタを追うことでそれらを読み取ることができます。
     </para>

     <para>
<!--
      The definition of <type>sqlda_t</type> is:
-->
<type>sqlda_t</type>の定義は以下の通りです。
<programlisting>
struct sqlda_struct
{
    char            sqldaid[8];
    long            sqldabc;
    short           sqln;
    short           sqld;
    struct sqlda_struct *desc_next;
    struct sqlvar_struct sqlvar[1];
};

typedef struct sqlda_struct sqlda_t;
</programlisting>

<!--
      The meaning of the fields is:
-->
フィールドの意味は以下の通りです。

    <variablelist>
     <varlistentry>
      <term><literal>sqldaid</></term>
      <listitem>
       <para>
<!--
        It contains the literal string <literal>"SQLDA  "</literal>.
-->
ここには<literal>"SQLDA  "</literal>文字列リテラルが含まれます。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>sqldabc</></term>
      <listitem>
       <para>
<!--
        It contains the size of the allocated space in bytes.
-->
ここにはバイト単位の割り当てられた領域のサイズが含まれます。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>sqln</></term>
      <listitem>
       <para>
<!--
        It contains the number of input parameters for a parameterized query in
        case it's passed into <command>OPEN</command>, <command>DECLARE</command> or
        <command>EXECUTE</command> statements using the <literal>USING</literal>
        keyword. In case it's used as output of <command>SELECT</command>,
        <command>EXECUTE</command> or <command>FETCH</command> statements,
        its value is the same as <literal>sqld</literal>
        statement
-->
<literal>USING</literal>キーワードを使用して<command>OPEN</command>、<command>DECLARE</command>、<command>EXECUTE</command>文に渡される場合、ここにはパラメータ付き問い合わせの入力パラメータ数が含まれます。
<command>SELECT</command>、<command>EXECUTE</command>、<command>FETCH</command>文の出力として使用される場合、この値は<literal>sqld</literal>文と同じです。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>sqld</></term>
      <listitem>
       <para>
<!--
        It contains the number of fields in a result set.
-->
ここには結果セットのフィールド数が含まれます。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>desc_next</></term>
      <listitem>
       <para>
<!--
        If the query returns more than one record, multiple linked
        SQLDA structures are returned, and <literal>desc_next</> holds
        a pointer to the next entry in the list.
-->
問い合わせが複数のレコードを返す場合、複数結び付いたSQLDA構造体が返されます。
<literal>desc_next</>にリスト内の次の項目を指し示すポインタが保持されます。
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>sqlvar</></term>
      <listitem>
       <para>
<!--
        This is the array of the columns in the result set.
-->
これは結果セット内の列の配列です。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
     </para>
    </sect4>

    <sect4 id="ecpg-sqlda-sqlvar">
<!--
     <title>sqlvar_t Structure</title>
-->
     <title>sqlvar_t構造体</title>

     <para>
<!--
      The structure type <type>sqlvar_t</type> holds a column value
      and metadata such as type and length. The definition of the type
      is:
-->
<type>sqlvar_t</type>構造体は列の値と型や長さなどのメタデータを保持します。
この型の定義は以下の通りです。

<programlisting>
struct sqlvar_struct
{
    short          sqltype;
    short          sqllen;
    char          *sqldata;
    short         *sqlind;
    struct sqlname sqlname;
};

typedef struct sqlvar_struct sqlvar_t;
</programlisting>

<!--
      The meaning of the fields is:
-->
フィールドの意味は以下の通りです。

        <variablelist>
         <varlistentry>
         <term><literal>sqltype</></term>
          <listitem>
           <para>
<!--
            Contains the type identifier of the field. For values,
            see <literal>enum ECPGttype</literal> in <literal>ecpgtype.h</literal>.
-->
ここにはフィールドの型識別子が含まれます。
値については<literal>ecpgtype.h</literal>の<literal>enum ECPGttype</literal>を参照してください。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
         <term><literal>sqllen</></term>
          <listitem>
           <para>
<!--
            Contains the binary length of the field. e.g. 4 bytes for <type>ECPGt_int</type>.
-->
フィールドのバイナリ長が含まれます。
例えば<type>ECPGt_int</type>では4バイトです。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
         <term><literal>sqldata</></term>
          <listitem>
           <para>
<!--
            Points to the data.  The format of the data is described
            in <xref linkend="ecpg-variables-type-mapping">.
-->
データそのものを指し示します。
データ書式は<xref linkend="ecpg-variables-type-mapping">で説明します。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
         <term><literal>sqlind</></term>
          <listitem>
           <para>
<!--
            Points to the null indicator.  0 means not null, -1 means
            null.
-->
データのNULL指示子を指し示します。
0は非NULLを、-1はNULLを意味します。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
         <term><literal>sqlname</></term>
          <listitem>
           <para>
<!--
            The name of the field.
-->
フィールドの名前です。
           </para>
          </listitem>
         </varlistentry>
        </variablelist>
     </para>
    </sect4>

    <sect4 id="ecpg-sqlda-sqlname">
<!--
     <title>struct sqlname Structure</title>
-->
     <title>struct sqlname構造体</title>

     <para>
<!--
      A <type>struct sqlname</type> structure holds a column name.  It
      is used as a member of the <type>sqlvar_t</type> structure.  The
      definition of the structure is:
-->
<type>struct sqlname</type>構造体は列名を保持します。
<type>sqlvar_t</type>構造体のメンバとして使用されます。
構造体の定義は以下の通りです。
<programlisting>
#define NAMEDATALEN 64

struct sqlname
{
        short           length;
        char            data[NAMEDATALEN];
};
</programlisting>
<!--
      The meaning of the fields is:
-->
フィールドの意味は以下の通りです。
            <variablelist>
             <varlistentry>
              <term><literal>length</></term>
               <listitem>
                <para>
<!--
                 Contains the length of the field name.
-->
フィールド名の長さが含まれます。
                </para>
               </listitem>
              </varlistentry>
             <varlistentry>
              <term><literal>data</></term>
               <listitem>
                <para>
<!--
                 Contains the actual field name.
-->
実際のフィールド名が含まれます。
                </para>
               </listitem>
              </varlistentry>
            </variablelist>
     </para>
    </sect4>
   </sect3>

   <sect3 id="ecpg-sqlda-output">
<!--
    <title>Retrieving a Result Set Using an SQLDA</title>
-->
    <title>SQLDAを使用した結果セットの取り出し</title>

    <procedure>
     <para>
<!--
      The general steps to retrieve a query result set through an
      SQLDA are:
-->
SQLDAを通して問い合わせの結果を取り出す一般的な手順は以下に示します。
     </para>
<!--
     <step><simpara>Declare an <type>sqlda_t</type> structure to receive the result set.</simpara></step>
     <step><simpara>Execute <command>FETCH</>/<command>EXECUTE</>/<command>DESCRIBE</> commands to process a query specifying the declared SQLDA.</simpara></step>
     <step><simpara>Check the number of records in the result set by looking at <structfield>sqln</>, a member of the <type>sqlda_t</type> structure.</simpara></step>
     <step><simpara>Get the values of each column from <literal>sqlvar[0]</>, <literal>sqlvar[1]</>, etc., members of the <type>sqlda_t</type> structure.</simpara></step>
     <step><simpara>Go to next row (<type>sqlda_t</type> structure) by following the <structfield>desc_next</> pointer, a member of the <type>sqlda_t</type> structure.</simpara></step>
     <step><simpara>Repeat above as you need.</simpara></step>
-->
     <step><simpara>結果セットを受けとるための<type>sqlda_t</type>構造体を宣言します。</simpara></step>
     <step><simpara>宣言したSQLDAを指定した問い合わせを処理するために<command>FETCH</>/<command>EXECUTE</>/<command>DESCRIBE</>を実行します。</simpara></step>
     <step><simpara><type>sqlda_t</type>構造体のメンバ<structfield>sqln</>を検索することにより結果セット内のレコード数を検査します。</simpara></step>
     <step><simpara><type>sqlda_t</type>構造体のメンバ<literal>sqlvar[0]</>、<literal>sqlvar[1]</>などから各列の値を入手します。</simpara></step>
     <step><simpara><type>sqlda_t</type>構造体のメンバ<structfield>desc_next</>ポインタを追い、次の行（<type>sqlda_t</type>構造体）に進みます。</simpara></step>
     <step><simpara>必要なだけ上を繰り返します。</simpara></step>
    </procedure>

    <para>
<!--
     Here is an example retrieving a result set through an SQLDA.
-->
以下にSQLDAを通して結果セットを取り出す例を示します。
    </para>

    <para>
<!--
     First, declare a <type>sqlda_t</type> structure to receive the result set.
-->
まず、結果セットを受け取る<type>sqlda_t</type>構造体を宣言します。
<programlisting>
sqlda_t *sqlda1;
</programlisting>
    </para>

    <para>
<!--
     Next, specify the SQLDA in a command.  This is
     a <command>FETCH</> command example.
-->
次にコマンド内にSQLDAを指定します。
以下は<command>FETCH</>コマンドの例です。
<programlisting>
EXEC SQL FETCH NEXT FROM cur1 INTO DESCRIPTOR sqlda1;
</programlisting>
    </para>

    <para>
<!--
     Run a loop following the linked list to retrieve the rows.
-->
行を取り出すためにリンクリストを追うループを実行します。
<programlisting>
sqlda_t *cur_sqlda;

for (cur_sqlda = sqlda1;
     cur_sqlda != NULL;
     cur_sqlda = cur_sqlda->desc_next)
{
    ...
}
</programlisting>
    </para>

    <para>
<!--
     Inside the loop, run another loop to retrieve each column data
     (<type>sqlvar_t</type> structure) of the row.
-->
ループの内側では、行の列データ（<type>sqlvar_t</type>構造体）それぞれを取り出す別のループを実行します。
<programlisting>
for (i = 0; i &lt; cur_sqlda->sqld; i++)
{
    sqlvar_t v = cur_sqlda->sqlvar[i];
    char *sqldata = v.sqldata;
    short sqllen  = v.sqllen;
    ...
}
</programlisting>
    </para>

    <para>
<!--
     To get a column value, check the <structfield>sqltype</> value,
     a member of the <type>sqlvar_t</type> structure.  Then, switch
     to an appropriate way, depending on the column type, to copy
     data from the <structfield>sqlvar</> field to a host variable.
-->
列の値を入手するために、<type>sqlvar_t</type>構造体のメンバ<structfield>sqltype</>の値を検査します。
そして、列の型に応じて、<structfield>sqlvar</>フィールドからホスト変数にデータをコピーするための適切な方法に切り替えます。
<programlisting>
char var_buf[1024];

switch (v.sqltype)
{
    case ECPGt_char:
        memset(&amp;var_buf, 0, sizeof(var_buf));
        memcpy(&amp;var_buf, sqldata, (sizeof(var_buf) &lt;= sqllen ? sizeof(var_buf) - 1 : sqllen));
        break;

<!--
    case ECPGt_int: /* integer */
-->
    case ECPGt_int: /* 整数 */
        memcpy(&amp;intval, sqldata, sqllen);
        snprintf(var_buf, sizeof(var_buf), "%d", intval);
        break;

    ...
}
</programlisting>
    </para>
   </sect3>

   <sect3 id="ecpg-sqlda-input">
<!--
    <title>Passing Query Parameters Using an SQLDA</title>
-->
    <title>SQLDAを使用した問い合わせパラメータ渡し</title>

    <procedure>
     <para>
<!--
      The general steps to use an SQLDA to pass input
      parameters to a prepared query are:
-->
プリペアド問い合わせに入力パラメータを渡すためにSQLDAを使用する、一般的な手順は以下の通りです。
     </para>
<!--
     <step><simpara>Create a prepared query (prepared statement)</simpara></step>
     <step><simpara>Declare a sqlda_t structure as an input SQLDA.</simpara></step>
     <step><simpara>Allocate memory area (as sqlda_t structure) for the input SQLDA.</simpara></step>
     <step><simpara>Set (copy) input values in the allocated memory.</simpara></step>
     <step><simpara>Open a cursor with specifying the input SQLDA.</simpara></step>
-->
     <step><simpara>プリペアド問い合わせ（プリペアド文）を作成します。</simpara></step>
     <step><simpara>入力用SQLDAとしてsqlda_t構造体を宣言します。</simpara></step>
     <step><simpara>入力用SQLDA用にメモリ領域を（sqlda_t構造体として）割り当てます。</simpara></step>
     <step><simpara>割り当てたメモリに入力値を設定（コピー）します。</simpara></step>
     <step><simpara>入力用SQLDAを指定してカーソルを開きます。</simpara></step>
    </procedure>

    <para>
<!--
     Here is an example.
-->
以下に例を示します。
    </para>

    <para>
<!--
     First, create a prepared statement.
-->
まずプリペアド文を作成します。
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
char query[1024] = "SELECT d.oid, * FROM pg_database d, pg_stat_database s WHERE d.oid = s.datid AND (d.datname = ? OR d.oid = ?)";
EXEC SQL END DECLARE SECTION;

EXEC SQL PREPARE stmt1 FROM :query;
</programlisting>
    </para>

    <para>
<!--
     Next, allocate memory for an SQLDA, and set the number of input
     parameters in <structfield>sqln</>, a member variable of
     the <type>sqlda_t</type> structure.  When two or more input
     parameters are required for the prepared query, the application
     has to allocate additional memory space which is calculated by
     (nr. of params - 1) * sizeof(sqlvar_t).  The example shown here
     allocates memory space for two input parameters.
-->
次にSQLDA用にメモリを割り当て、<type>sqlda_t</type>構造体のメンバ変数<structfield>sqln</>に入力パラメータ数を設定します。
プリペアド問い合わせで２つ以上の入力パラメータが必要な場合、アプリケーションは(パラメータ数 - 1) * sizeof(sqlvar_t)で計算される追加のメモリ空間を割り当てなければなりません。
ここで示す例では２つの入力パラメータ用にメモリ空間を割り当てます。
<programlisting>
sqlda_t *sqlda2;

sqlda2 = (sqlda_t *) malloc(sizeof(sqlda_t) + sizeof(sqlvar_t));
memset(sqlda2, 0, sizeof(sqlda_t) + sizeof(sqlvar_t));

<!--
sqlda2->sqln = 2; /* number of input variables */
-->
sqlda2->sqln = 2; /* 入力変数の個数 */
</programlisting>
    </para>

    <para>
<!--
     After memory allocation, store the parameter values into the
     <literal>sqlvar[]</literal> array.  (This is same array used for
     retrieving column values when the SQLDA is receiving a result
     set.)  In this example, the input parameters
     are <literal>"postgres"</literal>, having a string type,
     and <literal>1</literal>, having an integer type.
-->
メモリを割り当てた後、<literal>sqlvar[]</literal>配列にパラメータ値を格納します。
（これは、SQLDAが結果セットを受け取る時に列値を取り出すために使用した配列と同じです。）
この例では、入力パラメータは文字列型を持つ<literal>"postgres"</literal>と整数型を持つ<literal>1</literal>です。
<programlisting>
sqlda2->sqlvar[0].sqltype = ECPGt_char;
sqlda2->sqlvar[0].sqldata = "postgres";
sqlda2->sqlvar[0].sqllen  = 8;

int intval = 1;
sqlda2->sqlvar[1].sqltype = ECPGt_int;
sqlda2->sqlvar[1].sqldata = (char *) &amp;intval;
sqlda2->sqlvar[1].sqllen  = sizeof(intval);
</programlisting>
    </para>

    <para>
<!--
     By opening a cursor and specifying the SQLDA that was set up
     beforehand, the input parameters are passed to the prepared
     statement.
-->
ここまでで設定したSQLDAを指定するカーソルを開くことで、入力パラメータはプリペアド文に渡されます。
<programlisting>
EXEC SQL OPEN cur1 USING DESCRIPTOR sqlda2;
</programlisting>
    </para>

    <para>
<!--
     Finally, after using input SQLDAs, the allocated memory space
     must be freed explicitly, unlike SQLDAs used for receiving query
     results.
-->
最後に、問い合わせ結果を受け取るために使用するSQLDAとは異なり、入力用SQLDAの使用後、割り当てたメモリ空間を明示的に解放しなければなりません。
<programlisting>
free(sqlda2);
</programlisting>
    </para>
   </sect3>

   <sect3 id="ecpg-sqlda-example">
<!--
    <title>A Sample Application Using SQLDA</title>
-->
    <title>SQLDAを使用するサンプルアプリケーション</title>

    <para>
<!--
     Here is an example program, which describes how to fetch access
     statistics of the databases, specified by the input parameters,
     from the system catalogs.
-->
以下に、システムカタログから入力パラメータにより指定されたデータベースの統計情報にアクセスし取り出す方法を示す、プログラム例を示します。
    </para>

    <para>
<!--
     This application joins two system tables, pg_database and
     pg_stat_database on the database OID, and also fetches and shows
     the database statistics which are retrieved by two input
     parameters (a database <literal>postgres</literal>, and OID <literal>1</literal>).
-->
このアプリケーションは、pg_databaseとpg_stat_databaseシステムテーブルをデータベースOIDで結合し、２つの入力パラメータ（データベース<literal>postgres</literal>とOID<literal>1</literal>）により取り出されるデータベース統計情報を読み取り、表示します。
    </para>

    <para>
<!--
     First, declare an SQLDA for input and an SQLDA for output.
-->
まず、入力用のSQLDAと出力用のSQLDAを宣言します。
<programlisting>
EXEC SQL include sqlda.h;

<!--
sqlda_t *sqlda1; /* an output descriptor */
sqlda_t *sqlda2; /* an input descriptor  */
-->
sqlda_t *sqlda1; /* 出力記述子 */
sqlda_t *sqlda2; /* 入力記述子 */
</programlisting>
    </para>

    <para>
<!--
     Next, connect to the database, prepare a statement, and declare a
     cursor for the prepared statement.
-->
次に、データベースに接続し、プリペアド文を作成し、プリペアド文用のカーソルを宣言します。
<programlisting>
int
main(void)
{
    EXEC SQL BEGIN DECLARE SECTION;
    char query[1024] = "SELECT d.oid,* FROM pg_database d, pg_stat_database s WHERE d.oid=s.datid AND ( d.datname=? OR d.oid=? )";
    EXEC SQL END DECLARE SECTION;

    EXEC SQL CONNECT TO testdb AS con1 USER testuser;

    EXEC SQL PREPARE stmt1 FROM :query;
    EXEC SQL DECLARE cur1 CURSOR FOR stmt1;
</programlisting>
    </para>

    <para>
<!--
     Next, put some values in the input SQLDA for the input
     parameters.  Allocate memory for the input SQLDA, and set the
     number of input parameters to <literal>sqln</literal>.  Store
     type, value, and value length into <literal>sqltype</literal>,
     <literal>sqldata</literal>, and <literal>sqllen</literal> in the
     <literal>sqlvar</literal> structure.
-->
次に、入力パラメータのために入力用SQLDA内にいくつかの値を格納します。
入力用SQLDAのためのメモリを割り当て、入力パラメータの個数を<literal>sqln</literal>に設定します。
型、値、値の長さを<literal>sqlvar</literal>構造体内の<literal>sqltype</literal>、<literal>sqldata</literal>、<literal>sqllen</literal>に格納します。

<programlisting>
<!--
    /* Create SQLDA structure for input parameters. */
-->
    /* 入力パラメータ用のSQLDA構造体を作成する。 */
    sqlda2 = (sqlda_t *) malloc(sizeof(sqlda_t) + sizeof(sqlvar_t));
    memset(sqlda2, 0, sizeof(sqlda_t) + sizeof(sqlvar_t));
<!--
    sqlda2->sqln = 2; /* number of input variables */
-->
    sqlda2->sqln = 2; /* 入力変数の数 */

    sqlda2->sqlvar[0].sqltype = ECPGt_char;
    sqlda2->sqlvar[0].sqldata = "postgres";
    sqlda2->sqlvar[0].sqllen  = 8;

    intval = 1;
    sqlda2->sqlvar[1].sqltype = ECPGt_int;
    sqlda2->sqlvar[1].sqldata = (char *)&amp;intval;
    sqlda2->sqlvar[1].sqllen  = sizeof(intval);
</programlisting>
    </para>

    <para>
<!--
     After setting up the input SQLDA, open a cursor with the input
     SQLDA.
-->
入力用SQLDAを設定し終えた後、入力用SQLDAを付けたカーソルを開きます。

<programlisting>
<!--
    /* Open a cursor with input parameters. */
-->
    /* 入力パラメータ付きでカーソルを開く。 */
    EXEC SQL OPEN cur1 USING DESCRIPTOR sqlda2;
</programlisting>
    </para>

    <para>
<!--
     Fetch rows into the output SQLDA from the opened cursor.
     (Generally, you have to call <command>FETCH</command> repeatedly
     in the loop, to fetch all rows in the result set.)
-->
開いたカーソルから出力用SQLDA内に行を取り込みます。
（一般的に結果セット内の行をすべて取り込むためには、ループ内で<command>FETCH</command>を繰り返し呼び出さなければなりません。）
<programlisting>
    while (1)
    {
        sqlda_t *cur_sqlda;

<!--
        /* Assign descriptor to the cursor  */
-->
        /* 記述子をカーソルに割り当てる */
        EXEC SQL FETCH NEXT FROM cur1 INTO DESCRIPTOR sqlda1;
</programlisting>
    </para>

    <para>
<!--
     Next, retrieve the fetched records from the SQLDA, by following
     the linked list of the <type>sqlda_t</type> structure.
-->
次に、<type>sqlda_t</type>構造体のリンクリストを追うことで、SQLDAから取り込んだレコードを取り出します。
<programlisting>
    for (cur_sqlda = sqlda1 ;
         cur_sqlda != NULL ;
         cur_sqlda = cur_sqlda->desc_next)
    {
        ...
</programlisting>
    </para>

    <para>
<!--
     Read each columns in the first record.  The number of columns is
     stored in <structfield>sqld</>, the actual data of the first
     column is stored in <literal>sqlvar[0]</>, both members of
     the <type>sqlda_t</type> structure.
-->
最初のレコードから各列を読み取ります。
列数は<structfield>sqld</>に、最初の列の実データは<literal>sqlvar[0]</>に格納されています。
どちらも<type>sqlda_t</type>構造体のメンバです。

<programlisting>
<!--
        /* Print every column in a row. */
-->
        /* 1行の列をすべて表示する。 */
        for (i = 0; i &lt; sqlda1-&gt;sqld; i++)
        {
            sqlvar_t v = sqlda1->sqlvar[i];
            char *sqldata = v.sqldata;
            short sqllen  = v.sqllen;

            strncpy(name_buf, v.sqlname.data, v.sqlname.length);
            name_buf[v.sqlname.length] = '\0';
</programlisting>
    </para>

    <para>
<!--
     Now, the column data is stored in the variable <varname>v</>.
     Copy every datum into host variables, looking
     at <literal>v.sqltype</> for the type of the column.
-->
ここで、列データが<varname>v</>変数内に格納されました。
列の型について<literal>v.sqltype</>を検索しながら、すべてのデータをホスト変数にコピーします。
<programlisting>
            switch (v.sqltype) {
                int intval;
                double doubleval;
                unsigned long long int longlongval;

                case ECPGt_char:
                    memset(&amp;var_buf, 0, sizeof(var_buf));
                    memcpy(&amp;var_buf, sqldata, (sizeof(var_buf) &lt;= sqllen ? sizeof(var_buf)-1 : sqllen));
                    break;

<!--
                case ECPGt_int: /* integer */
-->
                case ECPGt_int: /* 整数 */
                    memcpy(&amp;intval, sqldata, sqllen);
                    snprintf(var_buf, sizeof(var_buf), "%d", intval);
                    break;

                ...

                default:
                    ...
            }

            printf("%s = %s (type: %d)\n", name_buf, var_buf, v.sqltype);
        }
</programlisting>
    </para>

    <para>
<!--
     Close the cursor after processing all of records, and disconnect
     from the database.
-->
すべてのレコードを処理した後カーソルを閉じ、データベースとの接続を切断します。
<programlisting>
    EXEC SQL CLOSE cur1;
    EXEC SQL COMMIT;

    EXEC SQL DISCONNECT ALL;
</programlisting>
    </para>

    <para>
<!--
     The whole program is shown
     in <xref linkend="ecpg-sqlda-example-example">.
-->
プログラム全体を<xref linkend="ecpg-sqlda-example-example">に示します。
    </para>

    <example id="ecpg-sqlda-example-example">
<!--
     <title>Example SQLDA Program</title>
-->
     <title>SQLDAプログラムの例</title>
<programlisting>
#include &lt;stdlib.h>
#include &lt;string.h>
#include &lt;stdlib.h>
#include &lt;stdio.h>
#include &lt;unistd.h>

EXEC SQL include sqlda.h;

<!--
sqlda_t *sqlda1; /* descriptor for output */
sqlda_t *sqlda2; /* descriptor for input */
-->
sqlda_t *sqlda1; /* 出力記述子 */
sqlda_t *sqlda2; /* 入力記述子 */

EXEC SQL WHENEVER NOT FOUND DO BREAK;
EXEC SQL WHENEVER SQLERROR STOP;

int
main(void)
{
    EXEC SQL BEGIN DECLARE SECTION;
    char query[1024] = "SELECT d.oid,* FROM pg_database d, pg_stat_database s WHERE d.oid=s.datid AND ( d.datname=? OR d.oid=? )";

    int intval;
    unsigned long long int longlongval;
    EXEC SQL END DECLARE SECTION;

    EXEC SQL CONNECT TO uptimedb AS con1 USER uptime;

    EXEC SQL PREPARE stmt1 FROM :query;
    EXEC SQL DECLARE cur1 CURSOR FOR stmt1;

<!--
    /* Create a SQLDA structure for an input parameter */
-->
    /* 入力パラメータ用のSQLDA構造体を作成する */
    sqlda2 = (sqlda_t *)malloc(sizeof(sqlda_t) + sizeof(sqlvar_t));
    memset(sqlda2, 0, sizeof(sqlda_t) + sizeof(sqlvar_t));
<!--
    sqlda2->sqln = 2; /* a number of input variables */
-->
    sqlda2->sqln = 2; /* 入力変数の数 */

    sqlda2->sqlvar[0].sqltype = ECPGt_char;
    sqlda2->sqlvar[0].sqldata = "postgres";
    sqlda2->sqlvar[0].sqllen  = 8;

    intval = 1;
    sqlda2->sqlvar[1].sqltype = ECPGt_int;
    sqlda2->sqlvar[1].sqldata = (char *) &amp;intval;
    sqlda2->sqlvar[1].sqllen  = sizeof(intval);

<!--
    /* Open a cursor with input parameters. */
-->
    /* 入力パラメータ付きでカーソルを開く。 */
    EXEC SQL OPEN cur1 USING DESCRIPTOR sqlda2;

    while (1)
    {
        sqlda_t *cur_sqlda;

<!--
        /* Assign descriptor to the cursor  */
-->
        /* 記述子をカーソルに割り当てる */
        EXEC SQL FETCH NEXT FROM cur1 INTO DESCRIPTOR sqlda1;

        for (cur_sqlda = sqlda1 ;
             cur_sqlda != NULL ;
             cur_sqlda = cur_sqlda->desc_next)
        {
            int i;
            char name_buf[1024];
            char var_buf[1024];

<!--
            /* Print every column in a row. */
-->
            /* 1行の列をすべて表示する。 */
            for (i=0 ; i&lt;cur_sqlda->sqld ; i++)
            {
                sqlvar_t v = cur_sqlda->sqlvar[i];
                char *sqldata = v.sqldata;
                short sqllen  = v.sqllen;

                strncpy(name_buf, v.sqlname.data, v.sqlname.length);
                name_buf[v.sqlname.length] = '\0';

                switch (v.sqltype)
                {
                    case ECPGt_char:
                        memset(&amp;var_buf, 0, sizeof(var_buf));
                        memcpy(&amp;var_buf, sqldata, (sizeof(var_buf)&lt;=sqllen ? sizeof(var_buf)-1 : sqllen) );
                        break;

<!--
                    case ECPGt_int: /* integer */
-->
                    case ECPGt_int: /* 整数 */
                        memcpy(&amp;intval, sqldata, sqllen);
                        snprintf(var_buf, sizeof(var_buf), "%d", intval);
                        break;

                    case ECPGt_long_long: /* bigint */
                        memcpy(&amp;longlongval, sqldata, sqllen);
                        snprintf(var_buf, sizeof(var_buf), "%lld", longlongval);
                        break;

                    default:
                    {
                        int i;
                        memset(var_buf, 0, sizeof(var_buf));
                        for (i = 0; i &lt; sqllen; i++)
                        {
                            char tmpbuf[16];
                            snprintf(tmpbuf, sizeof(tmpbuf), "%02x ", (unsigned char) sqldata[i]);
                            strncat(var_buf, tmpbuf, sizeof(var_buf));
                        }
                    }
                        break;
                }

                printf("%s = %s (type: %d)\n", name_buf, var_buf, v.sqltype);
            }

            printf("\n");
        }
    }

    EXEC SQL CLOSE cur1;
    EXEC SQL COMMIT;

    EXEC SQL DISCONNECT ALL;

    return 0;
}
</programlisting>

     <para>
<!--
      The output of this example should look something like the
      following (some numbers will vary).
-->
この例の出力は以下のようなものになるはずです（一部の数値は変動します）。
     </para>

<screen>
oid = 1 (type: 1)
datname = template1 (type: 1)
datdba = 10 (type: 1)
encoding = 0 (type: 5)
datistemplate = t (type: 1)
datallowconn = t (type: 1)
datconnlimit = -1 (type: 5)
datlastsysoid = 11510 (type: 1)
datfrozenxid = 379 (type: 1)
dattablespace = 1663 (type: 1)
datconfig =  (type: 1)
datacl = {=c/uptime,uptime=CTc/uptime} (type: 1)
datid = 1 (type: 1)
datname = template1 (type: 1)
numbackends = 0 (type: 5)
xact_commit = 113606 (type: 9)
xact_rollback = 0 (type: 9)
blks_read = 130 (type: 9)
blks_hit = 7341714 (type: 9)
tup_returned = 38262679 (type: 9)
tup_fetched = 1836281 (type: 9)
tup_inserted = 0 (type: 9)
tup_updated = 0 (type: 9)
tup_deleted = 0 (type: 9)

oid = 11511 (type: 1)
datname = postgres (type: 1)
datdba = 10 (type: 1)
encoding = 0 (type: 5)
datistemplate = f (type: 1)
datallowconn = t (type: 1)
datconnlimit = -1 (type: 5)
datlastsysoid = 11510 (type: 1)
datfrozenxid = 379 (type: 1)
dattablespace = 1663 (type: 1)
datconfig =  (type: 1)
datacl =  (type: 1)
datid = 11511 (type: 1)
datname = postgres (type: 1)
numbackends = 0 (type: 5)
xact_commit = 221069 (type: 9)
xact_rollback = 18 (type: 9)
blks_read = 1176 (type: 9)
blks_hit = 13943750 (type: 9)
tup_returned = 77410091 (type: 9)
tup_fetched = 3253694 (type: 9)
tup_inserted = 0 (type: 9)
tup_updated = 0 (type: 9)
tup_deleted = 0 (type: 9)
</screen>
    </example>
   </sect3>
  </sect2>
 </sect1>

 <sect1 id="ecpg-errors">
<!--
  <title>Error Handling</title>
-->
  <title>エラー処理</title>

  <para>
<!--
   This section describes how you can handle exceptional conditions
   and warnings in an embedded SQL program.  There are two
   nonexclusive facilities for this.
-->
本節では、埋め込みSQLプログラムにおいて、例外条件や警告をどのように扱うことができるかについて説明します。
このために、共に使用できる２つの機能があります。

   <itemizedlist>
    <listitem>
     <simpara>
<!--
      Callbacks can be configured to handle warning and error
      conditions using the <literal>WHENEVER</literal> command.
-->
<literal>WHENEVER</literal>コマンドを使用して、警告条件、エラー条件を扱うようにコールバックを設定することができます。
     </simpara>
    </listitem>

    <listitem>
     <simpara>
<!--
      Detailed information about the error or warning can be obtained
      from the <varname>sqlca</varname> variable.
-->
エラーまたは警告に関する詳細情報は<varname>sqlca</varname>変数から入手することができます。
     </simpara>
    </listitem>
   </itemizedlist>
  </para>

  <sect2 id="ecpg-whenever">
<!--
   <title>Setting Callbacks</title>
-->
   <title>コールバックの設定</title>

   <para>
<!--
    One simple method to catch errors and warnings is to set a
    specific action to be executed whenever a particular condition
    occurs.  In general:
-->
エラーや警告を受け取る簡単な手法の1つは、特定の条件が発生する度に特定の動作を実行するように設定することです。
一般的には以下のようになります。
<programlisting>
EXEC SQL WHENEVER <replaceable>condition</replaceable> <replaceable>action</replaceable>;
</programlisting>
   </para>

   <para>
<!--
    <replaceable>condition</replaceable> can be one of the following:
-->
    <replaceable>condition</replaceable>は以下のいずれかを取ることができます。

    <variablelist>
     <varlistentry>
      <term><literal>SQLERROR</literal></term>
      <listitem>
       <para>
<!--
        The specified action is called whenever an error occurs during
        the execution of an SQL statement.
-->
SQL文の実行中にエラーが発生する度に、指定した動作が呼び出されます。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>SQLWARNING</literal></term>
      <listitem>
       <para>
<!--
        The specified action is called whenever a warning occurs
        during the execution of an SQL statement.
-->
SQL文の実行中に警告が発生する度に、指定した動作が呼び出されます。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>NOT FOUND</literal></term>
      <listitem>
       <para>
<!--
        The specified action is called whenever an SQL statement
        retrieves or affects zero rows.  (This condition is not an
        error, but you might be interested in handling it specially.)
-->
SQL文が0行を受け取る、もしくは0行に影響する時、指定した動作が呼び出されます。
（この条件はエラーではありませんが、これを特別に扱いたい場合があります。）
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>

   <para>
<!--
    <replaceable>action</replaceable> can be one of the following:
-->
<replaceable>action</replaceable>は以下のいずれかを取ることができます。

    <variablelist>
     <varlistentry>
      <term><literal>CONTINUE</literal></term>
      <listitem>
       <para>
<!--
        This effectively means that the condition is ignored.  This is
        the default.
-->
これは、実際のところ、その条件が無視されることを意味します。
これがデフォルトです。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>GOTO <replaceable>label</replaceable></literal></term>
      <term><literal>GO TO <replaceable>label</replaceable></literal></term>
      <listitem>
       <para>
<!--
        Jump to the specified label (using a C <literal>goto</literal>
        statement).
-->
指定したラベルに移動します
（Cの<literal>goto</literal>文を使用します）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>SQLPRINT</literal></term>
      <listitem>
       <para>
<!--
        Print a message to standard error.  This is useful for simple
        programs or during prototyping.  The details of the message
        cannot be configured.
-->
標準エラーにメッセージを出力します。
これは、単純なプログラムやプロトタイプ作成時に役に立ちます。
メッセージの詳細は設定できません。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>STOP</literal></term>
      <listitem>
       <para>
<!--
        Call <literal>exit(1)</literal>, which will terminate the
        program.
-->
プログラムを終了させる<literal>exit(1)</literal>を呼び出します。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>DO BREAK</literal></term>
      <listitem>
       <para>
<!--
        Execute the C statement <literal>break</literal>.  This should
        only be used in loops or <literal>switch</literal> statements.
-->
Cの<literal>break</literal>文を実行します。
これはループ内、もしくは<literal>switch</literal>文内でのみ使用しなければなりません。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>CALL <replaceable>name</replaceable> (<replaceable>args</replaceable>)</literal></term>
      <term><literal>DO <replaceable>name</replaceable> (<replaceable>args</replaceable>)</literal></term>
      <listitem>
       <para>
<!--
        Call the specified C functions with the specified arguments.
-->
指定した引数で、指定したC関数を呼び出します。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>

<!--
    The SQL standard only provides for the actions
    <literal>CONTINUE</literal> and <literal>GOTO</literal> (and
    <literal>GO TO</literal>).
-->
標準SQLでは<literal>CONTINUE</literal>と<literal>GOTO</literal>（と<literal>GO TO</literal>）のみを提供しています。
   </para>

   <para>
<!--
    Here is an example that you might want to use in a simple program.
    It prints a simple message when a warning occurs and aborts the
    program when an error happens:
-->
簡単なプログラムで使用してみたくなるような例を以下に示します。
警告が発生した場合に簡単なメッセージを表示し、エラーが発生した場合にプログラムを中断します。
<programlisting>
EXEC SQL WHENEVER SQLWARNING SQLPRINT;
EXEC SQL WHENEVER SQLERROR STOP;
</programlisting>
   </para>

   <para>
<!--
    The statement <literal>EXEC SQL WHENEVER</literal> is a directive
    of the SQL preprocessor, not a C statement.  The error or warning
    actions that it sets apply to all embedded SQL statements that
    appear below the point where the handler is set, unless a
    different action was set for the same condition between the first
    <literal>EXEC SQL WHENEVER</literal> and the SQL statement causing
    the condition, regardless of the flow of control in the C program.
    So neither of the two following C program excerpts will have the
    desired effect:
-->
<literal>EXEC SQL WHENEVER</literal>文はCの構文ではなく、SQLプリプロセッサのディレクティブです。
設定したエラーもしくは警告動作は、最初の<literal>EXEC SQL WHENEVER</literal>と条件を発生させたSQL文の間で、同一条件に異なる動作が設定されない限り、ハンドラを設定した箇所より後にある、すべての埋め込みSQL文に適用されます。
Cプログラムの制御フローは関係しません。
ですので、以下の2つのCプログラムの抜粋はどちらも望み通りの動作を行いません。
<programlisting>
/*
<!--
 * WRONG
-->
 * 間違い
 */
int main(int argc, char *argv[])
{
    ...
    if (verbose) {
        EXEC SQL WHENEVER SQLWARNING SQLPRINT;
    }
    ...
    EXEC SQL SELECT ...;
    ...
}
</programlisting>

<programlisting>
/*
<!--
 * WRONG
-->
 * 間違い
 */
int main(int argc, char *argv[])
{
    ...
    set_error_handler();
    ...
    EXEC SQL SELECT ...;
    ...
}

static void set_error_handler(void)
{
    EXEC SQL WHENEVER SQLERROR STOP;
}
</programlisting>
   </para>
  </sect2>

  <sect2 id="ecpg-sqlca">
   <title>sqlca</title>

   <para>
<!--
    For more powerful error handling, the embedded SQL interface
    provides a global variable with the name <varname>sqlca</varname>
    (SQL communication area)
    that has the following structure:
-->
より強力にエラーを扱うために、埋め込みSQLインタフェースは以下の構造体を持つ<varname>sqlca</varname>（SQL通信領域）という名前のグローバル変数を提供します。
<programlisting>
struct
{
    char sqlcaid[8];
    long sqlabc;
    long sqlcode;
    struct
    {
        int sqlerrml;
        char sqlerrmc[SQLERRMC_LEN];
    } sqlerrm;
    char sqlerrp[8];
    long sqlerrd[6];
    char sqlwarn[8];
    char sqlstate[5];
} sqlca;
</programlisting>
<!--
    (In a multithreaded program, every thread automatically gets its
    own copy of <varname>sqlca</varname>.  This works similarly to the
    handling of the standard C global variable
    <varname>errno</varname>.)
-->
（マルチスレッド化されたプログラムでは、各スレッドは自動的に<varname>sqlca</varname>のコピーを独自に持ちます。
これは標準Cの<varname>errno</varname>グローバル変数の扱いと同様に動作します。）
   </para>

   <para>
<!--
    <varname>sqlca</varname> covers both warnings and errors.  If
    multiple warnings or errors occur during the execution of a
    statement, then <varname>sqlca</varname> will only contain
    information about the last one.
-->
<varname>sqlca</varname>は警告とエラーの両方を対象としています。
1つのSQL文の実行時に複数の警告やエラーが発生した場合、<varname>sqlca</varname>は最後のものに関した情報のみを含みます。
   </para>

   <para>
<!--
    If no error occurred in the last <acronym>SQL</acronym> statement,
    <literal>sqlca.sqlcode</literal> will be 0 and
    <literal>sqlca.sqlstate</literal> will be
    <literal>"00000"</literal>.  If a warning or error occurred, then
    <literal>sqlca.sqlcode</literal> will be negative and
    <literal>sqlca.sqlstate</literal> will be different from
    <literal>"00000"</literal>.  A positive
    <literal>sqlca.sqlcode</literal> indicates a harmless condition,
    such as that the last query returned zero rows.
    <literal>sqlcode</literal> and <literal>sqlstate</literal> are two
    different error code schemes; details appear below.
-->
直前の<acronym>SQL</acronym>文でエラーがなければ、<literal>sqlca.sqlcode</literal>は0に、<literal>sqlca.sqlstate</literal>は<literal>"00000"</literal>になります。
警告やエラーが発生した場合は、<literal>sqlca.sqlcode</literal>は負の値に、<literal>sqlca.sqlstate</literal>は<literal>"00000"</literal>以外になります。
正の<literal>sqlca.sqlcode</literal>は、直前の問い合わせが0行を返したなどの無害な条件を示します。
<literal>sqlca.sqlcode</literal>と<literal>sqlca.sqlstate</literal>は2つの異なるエラーコードスキーマです。
後で詳細に説明します。
   </para>

   <para>
<!--
    If the last SQL statement was successful, then
    <literal>sqlca.sqlerrd[1]</literal> contains the OID of the
    processed row, if applicable, and
    <literal>sqlca.sqlerrd[2]</literal> contains the number of
    processed or returned rows, if applicable to the command.
-->
直前のSQL文が成功すると、<literal>sqlca.sqlerrd[1]</literal>は処理された行のOIDが、もしあれば、格納されます。
また、もしそのコマンドで適切ならば、<literal>sqlca.sqlerrd[2]</literal>は処理された、もしくは返された行数が格納されます。
   </para>

   <para>
<!--
    In case of an error or warning,
    <literal>sqlca.sqlerrm.sqlerrmc</literal> will contain a string
    that describes the error.  The field
    <literal>sqlca.sqlerrm.sqlerrml</literal> contains the length of
    the error message that is stored in
    <literal>sqlca.sqlerrm.sqlerrmc</literal> (the result of
    <function>strlen()</function>, not really interesting for a C
    programmer).  Note that some messages are too long to fit in the
    fixed-size <literal>sqlerrmc</literal> array; they will be truncated.
-->
エラーもしくは警告の場合、<literal>sqlca.sqlerrm.sqlerrmc</literal>には、そのエラーを説明する文字列が格納されます。
<literal>sqlca.sqlerrm.sqlerrml</literal>フィールドには<literal>sqlca.sqlerrm.sqlerrmc</literal>に格納されたエラーメッセージ長が格納されます
（<function>strlen()</function>の結果です。おそらくCプログラマは必要としないでしょう）。
一部のメッセージは固定長の<literal>sqlerrmc</literal>配列には長過ぎることに注意してください。
この場合は切り詰められます。
   </para>

   <para>
<!--
    In case of a warning, <literal>sqlca.sqlwarn[2]</literal> is set
    to <literal>W</literal>.  (In all other cases, it is set to
    something different from <literal>W</literal>.)  If
    <literal>sqlca.sqlwarn[1]</literal> is set to
    <literal>W</literal>, then a value was truncated when it was
    stored in a host variable.  <literal>sqlca.sqlwarn[0]</literal> is
    set to <literal>W</literal> if any of the other elements are set
    to indicate a warning.
-->
警告の場合、<literal>sqlca.sqlwarn[2]</literal>は<literal>W</literal>に設定されます
（他のすべての場合では、これは<literal>W</literal>以外の何かに設定されます）。
<literal>sqlca.sqlwarn[1]</literal>が<literal>W</literal>に設定された場合、ホスト変数に代入する際に値が切り詰められています。
他の要素が警告を示すように設定された場合、<literal>sqlca.sqlwarn[0]</literal>は<literal>W</literal>に設定されます。
   </para>

   <para>
<!--
    The fields <structfield>sqlcaid</structfield>,
    <structfield>sqlcabc</structfield>,
    <structfield>sqlerrp</structfield>, and the remaining elements of
    <structfield>sqlerrd</structfield> and
    <structfield>sqlwarn</structfield> currently contain no useful
    information.
-->
今のところ、<structfield>sqlcaid</structfield>、<structfield>sqlcabc</structfield>、<structfield>sqlerrp</structfield>ならびに<structfield>sqlerrd</structfield>と<structfield>sqlwarn</structfield>の上記以外の要素は有用な情報を持ちません。
   </para>

   <para>
<!--
    The structure <varname>sqlca</varname> is not defined in the SQL
    standard, but is implemented in several other SQL database
    systems.  The definitions are similar at the core, but if you want
    to write portable applications, then you should investigate the
    different implementations carefully.
-->
<varname>sqlca</varname>は標準SQLでは定義されていません。
しかし、複数の他のSQLデータベースシステムで実装されています。
その定義は基本部分は似ていますが、移植性を持つアプリケーションを作成する場合は実装の違いを注意して調査しなければなりません。
   </para>

   <para>
<!--
    Here is one example that combines the use of <literal>WHENEVER</>
    and <varname>sqlca</varname>, printing out the contents
    of <varname>sqlca</varname> when an error occurs.  This is perhaps
    useful for debugging or prototyping applications, before
    installing a more <quote>user-friendly</quote> error handler.
-->
ここで<literal>WHENEVER</>と<varname>sqlca</varname>を組み合わせて使用して、エラーが発生した時に<varname>sqlca</varname>の内容を表示する、１つの例を示します。
これはおそらく、より<quote>ユーザ向け</quote>のエラー処理を組み込む前の、アプリケーションのデバッグまたはプロトタイプで有用です。

<programlisting>
EXEC SQL WHENEVER SQLERROR CALL print_sqlca();

void
print_sqlca()
{
    fprintf(stderr, "==== sqlca ====\n");
    fprintf(stderr, "sqlcode: %ld\n", sqlca.sqlcode);
    fprintf(stderr, "sqlerrm.sqlerrml: %d\n", sqlca.sqlerrm.sqlerrml);
    fprintf(stderr, "sqlerrm.sqlerrmc: %s\n", sqlca.sqlerrm.sqlerrmc);
    fprintf(stderr, "sqlerrd: %ld %ld %ld %ld %ld %ld\n", sqlca.sqlerrd[0],sqlca.sqlerrd[1],sqlca.sqlerrd[2],
                                                          sqlca.sqlerrd[3],sqlca.sqlerrd[4],sqlca.sqlerrd[5]);
    fprintf(stderr, "sqlwarn: %d %d %d %d %d %d %d %d\n", sqlca.sqlwarn[0], sqlca.sqlwarn[1], sqlca.sqlwarn[2],
                                                          sqlca.sqlwarn[3], sqlca.sqlwarn[4], sqlca.sqlwarn[5],
                                                          sqlca.sqlwarn[6], sqlca.sqlwarn[7]);
    fprintf(stderr, "sqlstate: %5s\n", sqlca.sqlstate);
    fprintf(stderr, "===============\n");
}
</programlisting>

<!--
    The result could look as follows (here an error due to a
    misspelled table name):
-->
結果は以下のようになります（ここでのエラーはテーブル名の誤記述によるものです。）。

<screen>
==== sqlca ====
sqlcode: -400
sqlerrm.sqlerrml: 49
sqlerrm.sqlerrmc: relation "pg_databasep" does not exist on line 38
sqlerrd: 0 0 0 0 0 0
sqlwarn: 0 0 0 0 0 0 0 0
sqlstate: 42P01
===============
</screen>
   </para>
  </sect2>

  <sect2 id="ecpg-sqlstate-sqlcode">
<!--
   <title><literal>SQLSTATE</literal> vs. <literal>SQLCODE</literal></title>
-->
   <title><literal>SQLSTATE</literal>対<literal>SQLCODE</literal></title>

   <para>
<!--
    The fields <literal>sqlca.sqlstate</literal> and
    <literal>sqlca.sqlcode</literal> are two different schemes that
    provide error codes.  Both are derived from the SQL standard, but
    <literal>SQLCODE</literal> has been marked deprecated in the SQL-92
    edition of the standard and has been dropped in later editions.
    Therefore, new applications are strongly encouraged to use
    <literal>SQLSTATE</literal>.
-->
<literal>sqlca.sqlstate</literal>と<literal>sqlca.sqlcode</literal>はエラーコードを提供する異なる2つの機構です。
共に標準SQLから派生されたものですが、<literal>SQLCODE</literal>はSQL-92版では廃れたものとされ、以降の版から削除されました。
したがって、新規アプリケーションでは<literal>SQLSTATE</literal>を使用することを強く勧めます。
   </para>

   <para>
<!--
    <literal>SQLSTATE</literal> is a five-character array.  The five
    characters contain digits or upper-case letters that represent
    codes of various error and warning conditions.
    <literal>SQLSTATE</literal> has a hierarchical scheme: the first
    two characters indicate the general class of the condition, the
    last three characters indicate a subclass of the general
    condition.  A successful state is indicated by the code
    <literal>00000</literal>.  The <literal>SQLSTATE</literal> codes are for
    the most part defined in the SQL standard.  The
    <productname>PostgreSQL</productname> server natively supports
    <literal>SQLSTATE</literal> error codes; therefore a high degree
    of consistency can be achieved by using this error code scheme
    throughout all applications.  For further information see
    <xref linkend="errcodes-appendix">.
-->
<literal>SQLSTATE</literal>は5要素の文字配列です。
この5文字は、各種のエラー条件、警告条件のコードを表現する数字、大文字から構成されます。
<literal>SQLSTATE</literal>は階層を持った機構です。
最初の2文字は条件を汎化したクラスを示し、残り3文字は汎化クラスの副クラスを示します。
成功状態は<literal>00000</literal>というコードで示されます。
<literal>SQLSTATE</literal>コードのほとんどは標準SQLで定義されています。
<productname>PostgreSQL</productname>サーバは本質的に<literal>SQLSTATE</literal>エラーコードをサポートしています。
したがって、すべてのアプリケーションでこのエラーコードを使用することで、高度な一貫性を達成することができます。
詳細については<xref linkend="errcodes-appendix">を参照してください。
   </para>

   <para>
<!--
    <literal>SQLCODE</literal>, the deprecated error code scheme, is a
    simple integer.  A value of 0 indicates success, a positive value
    indicates success with additional information, a negative value
    indicates an error.  The SQL standard only defines the positive
    value +100, which indicates that the last command returned or
    affected zero rows, and no specific negative values.  Therefore,
    this scheme can only achieve poor portability and does not have a
    hierarchical code assignment.  Historically, the embedded SQL
    processor for <productname>PostgreSQL</productname> has assigned
    some specific <literal>SQLCODE</literal> values for its use, which
    are listed below with their numeric value and their symbolic name.
    Remember that these are not portable to other SQL implementations.
    To simplify the porting of applications to the
    <literal>SQLSTATE</literal> scheme, the corresponding
    <literal>SQLSTATE</literal> is also listed.  There is, however, no
    one-to-one or one-to-many mapping between the two schemes (indeed
    it is many-to-many), so you should consult the global
    <literal>SQLSTATE</literal> listing in <xref linkend="errcodes-appendix">
    in each case.
-->
廃止されたエラーコードの機構である<literal>SQLCODE</literal>は単なる整数です。
0という値は成功を意味し、正の値は追加情報を持った成功を、負の値はエラーを示します。
標準SQLでは、直前のコマンドが0行を返す、もしくは0行に影響したことを示す+100という正の値のみを定義しています。
負の値は規定されていません。
したがって、この機構では低い移植性しか達成できず、また、コード体系も階層を持っていません。
歴史的に、<productname>PostgreSQL</productname>の埋め込みSQLプロセッサには、いくつかの特殊な<literal>SQLCODE</literal>の値が専用に割り当てられていました。
以下に、その数値とそのシンボル名の一覧を示します。
これらは他のSQL実装への移植性がないことを忘れないでください。
アプリケーションの<literal>SQLSTATE</literal>機構への移行を簡易化するために、対応する<literal>SQLSTATE</literal>も示しています。
しかし、2つのしくみの間の関係は1対1ではなく1対多です
（実際は多対多です）。
ですので、場合ごとに<xref linkend="errcodes-appendix">に示したグローバルな各<literal>SQLSTATE</literal>を参照しなければなりません。
   </para>

   <para>
<!--
    These are the assigned <literal>SQLCODE</literal> values:
-->
以下は割り当て済みの<literal>SQLCODE</literal>です。

    <variablelist>
     <varlistentry>
      <term>0 (<symbol>ECPG_NO_ERROR</symbol>)</term>
      <listitem>
       <para>
<!--
        Indicates no error. (SQLSTATE 00000)
-->
エラーがないことを示す。(SQLSTATE 00000)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>100 (<symbol>ECPG_NOT_FOUND</symbol>)</term>
     <listitem>
      <para>
<!--
       This is a harmless condition indicating that the last command
       retrieved or processed zero rows, or that you are at the end of
       the cursor.  (SQLSTATE 02000)
-->
これは、最後に実行したコマンドが取り出した、または、処理した行がゼロ行であったこと、あるいは、カーソルの最後であることを示す、害のない条件です。(SQLSTATE 02000)
      </para>

      <para>
<!--
       When processing a cursor in a loop, you could use this code as
       a way to detect when to abort the loop, like this:
-->
以下のように、カーソルをループ内で処理する時、ループを中断する時を検知する方法として、このコードを使用することができます。
<programlisting>
while (1)
{
    EXEC SQL FETCH ... ;
    if (sqlca.sqlcode == ECPG_NOT_FOUND)
        break;
}
</programlisting>
<!--
       But <literal>WHENEVER NOT FOUND DO BREAK</literal> effectively
       does this internally, so there is usually no advantage in
       writing this out explicitly.
-->
しかし、<literal>WHENEVER NOT FOUND DO BREAK</literal>はこれを内部で効率的に行います。
このため、通常、外部で明示的に記述する利点はありません。
      </para>
     </listitem>
    </varlistentry>

     <varlistentry>
      <term>-12 (<symbol>ECPG_OUT_OF_MEMORY</symbol>)</term>
      <listitem>
       <para>
<!--
        Indicates that your virtual memory is exhausted.  The numeric
        value is defined as <literal>-ENOMEM</literal>.  (SQLSTATE
        YE001)
-->
仮想メモリ不足を示します。
この数値は<literal>-ENOMEM</literal>として定義します。
（SQLSTATE YE001）
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-200 (<symbol>ECPG_UNSUPPORTED</symbol>)</term>
     <listitem>
      <para>
<!--
       Indicates the preprocessor has generated something that the
       library does not know about.  Perhaps you are running
       incompatible versions of the preprocessor and the
       library. (SQLSTATE YE002)
-->
ライブラリが把握していない何かをプリプロセッサが生成したことを示します。
おそらく、互換性がないプリプロセッサとライブラリのバージョンを使用しています。
（SQLSTATE YE002）
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-201 (<symbol>ECPG_TOO_MANY_ARGUMENTS</symbol>)</term>
     <listitem>
      <para>
<!--
       This means that the command specified more host variables than
       the command expected.  (SQLSTATE 07001 or 07002)
-->
コマンドの想定より多くのホスト変数が指定されたことを意味します。
（SQLSTATE 07001もしくは07002）
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-202 (<symbol>ECPG_TOO_FEW_ARGUMENTS</symbol>)</term>
     <listitem>
      <para>
<!--
       This means that the command specified fewer host variables than
       the command expected.  (SQLSTATE 07001 or 07002)
-->
コマンドの想定よりも少ないホスト変数が指定されたことを意味します。
（SQLSTATE 07001もしくは07002）
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-203 (<symbol>ECPG_TOO_MANY_MATCHES</symbol>)</term>
     <listitem>
      <para>
<!--
       This means a query has returned multiple rows but the statement
       was only prepared to store one result row (for example, because
       the specified variables are not arrays).  (SQLSTATE 21000)
-->
問い合わせが複数行を返したけれども、SQL文では1つの結果の格納の準備だけしかしていなかったことを意味します
（例えば、指定された変数が配列ではなかった）。
（SQLSTATE 21000）
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-204 (<symbol>ECPG_INT_FORMAT</symbol>)</term>
     <listitem>
      <para>
<!--
       The host variable is of type <type>int</type> and the datum in
       the database is of a different type and contains a value that
       cannot be interpreted as an <type>int</type>.  The library uses
       <function>strtol()</function> for this conversion.  (SQLSTATE
       42804)
-->
ホスト変数の型が<type>int</type>ですが、データベース内のデータ型が異なり、その値を<type>int</type>として解釈させることができませんでした。
ライブラリはこの変換に<function>strtol()</function>を使用します。
（SQLSTATE 42804）
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-205 (<symbol>ECPG_UINT_FORMAT</symbol>)</term>
     <listitem>
      <para>
<!--
       The host variable is of type <type>unsigned int</type> and the
       datum in the database is of a different type and contains a
       value that cannot be interpreted as an <type>unsigned
       int</type>.  The library uses <function>strtoul()</function>
       for this conversion.  (SQLSTATE 42804)
-->
ホスト変数の型が<type>unsigned int</type>ですが、データベース内のデータ型が異なり、その値を<type>unsigned int</type>として解釈させることができませんでした。
ライブラリはこの変換に<function>strtoul()</function>を使用します。
（SQLSTATE 42804）
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-206 (<symbol>ECPG_FLOAT_FORMAT</symbol>)</term>
     <listitem>
      <para>
<!--
       The host variable is of type <type>float</type> and the datum
       in the database is of another type and contains a value that
       cannot be interpreted as a <type>float</type>.  The library
       uses <function>strtod()</function> for this conversion.
       (SQLSTATE 42804)
-->
ホスト変数の型が<type>float</type>ですが、データベース内のデータ型が異なり、その値を<type>float</type>として解釈させることができませんでした。
ライブラリはこの変換に<function>strtod()</function>を使用します。
（SQLSTATE 42804）
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-207 (<symbol>ECPG_NUMERIC_FORMAT</symbol>)</term>
     <listitem>
      <para>
<!--
       The host variable is of type <type>numeric</type> and the datum
       in the database is of another type and contains a value that
       cannot be interpreted as a <type>numeric</type> value.
       (SQLSTATE 42804)
-->
ホスト変数の型が<type>numeric</type>ですが、データベース内のデータ型が異なり、その値を<type>numeric</type>として解釈させることができませんでした。
（SQLSTATE 42804）
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-208 (<symbol>ECPG_INTERVAL_FORMAT</symbol>)</term>
     <listitem>
      <para>
<!--
       The host variable is of type <type>interval</type> and the datum
       in the database is of another type and contains a value that
       cannot be interpreted as an <type>interval</type> value.
       (SQLSTATE 42804)
-->
ホスト変数の型が<type>interval</type>であり、データベース内のデータが他の型であり、<type>interval</type>値として解釈することができない値を含みます。
       (SQLSTATE 42804)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-209 (<symbol>ECPG_DATE_FORMAT</symbol>)</term>
     <listitem>
      <para>
<!--
       The host variable is of type <type>date</type> and the datum in
       the database is of another type and contains a value that
       cannot be interpreted as a <type>date</type> value.
       (SQLSTATE 42804)
-->
ホスト変数の型が<type>date</type>であり、データベース内のデータが他の型であり、<type>date</type>値として解釈することができない値を含みます。
       (SQLSTATE 42804)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-210 (<symbol>ECPG_TIMESTAMP_FORMAT</symbol>)</term>
     <listitem>
      <para>
<!--
       The host variable is of type <type>timestamp</type> and the
       datum in the database is of another type and contains a value
       that cannot be interpreted as a <type>timestamp</type> value.
       (SQLSTATE 42804)
-->
ホスト変数の型が<type>timestamp</type>であり、データベース内のデータが他の型であり、<type>timestamp</type>値として解釈することができない値を含みます。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-211 (<symbol>ECPG_CONVERT_BOOL</symbol>)</term>
     <listitem>
      <para>
<!--
       This means the host variable is of type <type>bool</type> and
       the datum in the database is neither <literal>'t'</> nor
       <literal>'f'</>.  (SQLSTATE 42804)
-->
これは、ホスト変数の型が<type>bool</type>ですが、データベース内のデータが<literal>'t'</>でも<literal>'f'</>でもなかったことを意味します。
（SQLSTATE 42804）
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-212 (<symbol>ECPG_EMPTY</symbol>)</term>
     <listitem>
      <para>
<!--
       The statement sent to the <productname>PostgreSQL</productname>
       server was empty.  (This cannot normally happen in an embedded
       SQL program, so it might point to an internal error.)  (SQLSTATE
       YE002)
-->
<productname>PostgreSQL</productname>サーバに送信されたSQL文が空でした
（通常埋め込みSQLプログラムでは発生しません。ですので、これは内部エラーを示しているかもしれません）。
（SQLSTATE YE002）
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-213 (<symbol>ECPG_MISSING_INDICATOR</symbol>)</term>
     <listitem>
      <para>
<!--
       A null value was returned and no null indicator variable was
       supplied.  (SQLSTATE 22002)
-->
NULL値が返されましたが、NULL用の指示子変数が与えられていませんでした。
（SQLSTATE 22002）
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-214 (<symbol>ECPG_NO_ARRAY</symbol>)</term>
     <listitem>
      <para>
<!--
       An ordinary variable was used in a place that requires an
       array.  (SQLSTATE 42804)
-->
配列が必要な箇所に普通の変数が使用されていました。
（SQLSTATE 42804）
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-215 (<symbol>ECPG_DATA_NOT_ARRAY</symbol>)</term>
     <listitem>
      <para>
<!--
       The database returned an ordinary variable in a place that
       requires array value.  (SQLSTATE 42804)
-->
配列値が必要な箇所にデータベースが普通の変数を返しました。
（SQLSTATE 42804）
      </para>
     </listitem>
    </varlistentry>

<![IGNORE[
    <!-- disabled by #if 0 in ecpglib -->
    <varlistentry>
     <term>-216 (<symbol>ECPG_ARRAY_INSERT</symbol>)</term>
     <listitem>
      <para>
       The value could not be inserted into the array.  (SQLSTATE
       42804)
      </para>
     </listitem>
    </varlistentry>
]]>

    <varlistentry>
     <term>-220 (<symbol>ECPG_NO_CONN</symbol>)</term>
     <listitem>
      <para>
<!--
       The program tried to access a connection that does not exist.
       (SQLSTATE 08003)
-->
存在しない接続にプログラムがアクセスしようとしました。
       （SQLSTATE 08003）
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-221 (<symbol>ECPG_NOT_CONN</symbol>)</term>
     <listitem>
      <para>
<!--
       The program tried to access a connection that does exist but is
       not open.  (This is an internal error.)  (SQLSTATE YE002)
-->
存在するが開いていない接続にプログラムがアクセスしようとしました
（これは内部エラーです）。
（SQLSTATE YE002）
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-230 (<symbol>ECPG_INVALID_STMT</symbol>)</term>
     <listitem>
      <para>
<!--
       The statement you are trying to use has not been prepared.
       (SQLSTATE 26000)
-->
使用しようとしたSQL文がプリペアされていませんでした。
       （SQLSTATE 26000）
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-239 (<symbol>ECPG_INFORMIX_DUPLICATE_KEY</symbol>)</term>
     <listitem>
      <para>
<!--
       Duplicate key error, violation of unique constraint (Informix
       compatibility mode).  (SQLSTATE 23505)
-->
重複キーエラー。一意性制約違反（Informix互換モード）。
(SQLSTATE 23505)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-240 (<symbol>ECPG_UNKNOWN_DESCRIPTOR</symbol>)</term>
     <listitem>
      <para>
<!--
       The descriptor specified was not found.  The statement you are
       trying to use has not been prepared.  (SQLSTATE 33000)
-->
指定した記述子が見つかりませんでした。
使用しようとしたSQL文はプリペアされていませんでした。
（SQLSTATE 33000）
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-241 (<symbol>ECPG_INVALID_DESCRIPTOR_INDEX</symbol>)</term>
     <listitem>
      <para>
<!--
       The descriptor index specified was out of range.  (SQLSTATE
       07009)
-->
記述子のインデックスが範囲外でした。
（SQLSTATE 07009）
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-242 (<symbol>ECPG_UNKNOWN_DESCRIPTOR_ITEM</symbol>)</term>
     <listitem>
      <para>
<!--
       An invalid descriptor item was requested.  (This is an internal
       error.)  (SQLSTATE YE002)
-->
無効な記述子項目が要求されました。（これは内部エラーです。）
（SQLSTATE YE002）
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-243 (<symbol>ECPG_VAR_NOT_NUMERIC</symbol>)</term>
     <listitem>
      <para>
<!--
       During the execution of a dynamic statement, the database
       returned a numeric value and the host variable was not numeric.
       (SQLSTATE 07006)
-->
動的なSQL文の実行時にデータベースが数値を返しましたが、ホスト変数が数値でありませんでした。
（SQLSTATE 07006）
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-244 (<symbol>ECPG_VAR_NOT_CHAR</symbol>)</term>
     <listitem>
      <para>
<!--
       During the execution of a dynamic statement, the database
       returned a non-numeric value and the host variable was numeric.
       (SQLSTATE 07006)
-->
動的なSQL文の実行時にデータベースが数値以外を返しましたが、ホスト変数が数値でした。
       （SQLSTATE 07006）
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-284 (<symbol>ECPG_INFORMIX_SUBSELECT_NOT_ONE</symbol>)</term>
     <listitem>
      <para>
<!--
       A result of the subquery is not single row (Informix
       compatibility mode).  (SQLSTATE 21000)
-->
副問い合わせの結果が単一行ではありません（Informix互換モード）。
(SQLSTATE 21000)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-400 (<symbol>ECPG_PGSQL</symbol>)</term>
     <listitem>
      <para>
<!--
       Some error caused by the <productname>PostgreSQL</productname>
       server.  The message contains the error message from the
       <productname>PostgreSQL</productname> server.
-->
<productname>PostgreSQL</productname>サーバで何らかのエラーが発生しました。
このメッセージは<productname>PostgreSQL</productname>サーバからのエラーメッセージを含みます。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-401 (<symbol>ECPG_TRANS</symbol>)</term>
     <listitem>
      <para>
<!--
       The <productname>PostgreSQL</productname> server signaled that
       we cannot start, commit, or rollback the transaction.
       (SQLSTATE 08007)
-->
<productname>PostgreSQL</productname>サーバがトランザクションのコミットやロールバックを始めることができないことを通知しました。
（SQLSTATE 08007）
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-402 (<symbol>ECPG_CONNECT</symbol>)</term>
     <listitem>
      <para>
<!--
       The connection attempt to the database did not succeed.
       (SQLSTATE 08001)
-->
データベースへの接続試行に失敗しました。
       (SQLSTATE 08001)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-403 (<symbol>ECPG_DUPLICATE_KEY</symbol>)</term>
     <listitem>
      <para>
<!--
       Duplicate key error, violation of unique constraint.  (SQLSTATE
       23505)
-->
重複キーエラー。一意性制約違反。
(SQLSTATE 23505)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-404 (<symbol>ECPG_SUBSELECT_NOT_ONE</symbol>)</term>
     <listitem>
      <para>
<!--
       A result for the subquery is not single row. (SQLSTATE 21000)
-->
副問い合わせの結果が単一行ではありません。
(SQLSTATE 21000)
      </para>
     </listitem>
    </varlistentry>

<![IGNORE[
    <!-- currently not used by the code -->
    <varlistentry>
     <term>-600 (<symbol>ECPG_WARNING_UNRECOGNIZED</symbol>)</term>
     <listitem>
      <para>
       An unrecognized warning was received from the server.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-601 (<symbol>ECPG_WARNING_QUERY_IGNORED</symbol>)</term>
     <listitem>
      <para>
       Current transaction is aborted.  Queries are ignored until the
       end of the transaction block.
      </para>
     </listitem>
    </varlistentry>
]]>

    <varlistentry>
     <term>-602 (<symbol>ECPG_WARNING_UNKNOWN_PORTAL</symbol>)</term>
     <listitem>
      <para>
<!--
       An invalid cursor name was specified. (SQLSTATE 34000)
-->
無効なカーソル名が指定されました。
(SQLSTATE 34000)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-603 (<symbol>ECPG_WARNING_IN_TRANSACTION</symbol>)</term>
     <listitem>
      <para>
<!--
       Transaction is in progress. (SQLSTATE 25001)
-->
トランザクションが進行中です。
(SQLSTATE 25001)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-604 (<symbol>ECPG_WARNING_NO_TRANSACTION</symbol>)</term>
     <listitem>
      <para>
<!--
       There is no active (in-progress) transaction. (SQLSTATE 25P01)
-->
活動中（進行中）のトランザクションがありません。
(SQLSTATE 25P01)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-605 (<symbol>ECPG_WARNING_PORTAL_EXISTS</symbol>)</term>
     <listitem>
      <para>
<!--
       An existing cursor name was specified. (SQLSTATE 42P03)
-->
既存のカーソル名が指定されました。
(SQLSTATE 42P03)
      </para>
     </listitem>
    </varlistentry>

   </variablelist>
  </para>
  </sect2>
 </sect1>

 <sect1 id="ecpg-preproc">
<!--
  <title>Preprocessor Directives</title>
-->
  <title>プリプロセッサ指示子</title>

  <para>
<!--
   Several preprocessor directives are available that modify how
   the <command>ecpg</command> preprocessor parses and processes a
   file.
-->
<command>ecpg</command>プリプロセッサがファイルを解析および処理する方法を変更することができる、プリプロセッサ指示子が複数あります。
  </para>

  <sect2 id="ecpg-include">
<!--
   <title>Including Files</title>
-->
   <title>ファイルのインクルード</title>

   <para>
<!--
    To include an external file into your embedded SQL program, use:
-->
埋め込みSQLプログラムに外部ファイルをインクルードするには、以下を使用します。
<programlisting>
EXEC SQL INCLUDE <replaceable>filename</replaceable>;
EXEC SQL INCLUDE &lt;<replaceable>filename</replaceable>&gt;;
EXEC SQL INCLUDE "<replaceable>filename</replaceable>";
</programlisting>
<!--
    The embedded SQL preprocessor will look for a file named
    <literal><replaceable>filename</replaceable>.h</literal>,
    preprocess it, and include it in the resulting C output.  Thus,
    embedded SQL statements in the included file are handled correctly.
-->
埋め込みSQLプリプロセッサは、<literal><replaceable>filename</replaceable>.h</literal>という名前のファイルを探し、その前処理を行い、最終的にC出力の中に含めます。
このようにして、ヘッダファイル内の埋め込みSQL文が正しく扱われます。
   </para>

   <para>
<!--
    The <command>ecpg</command> preprocessor will search a file at
    several directories in following order:
-->
<command>ecpg</command>プリプロセッサは以下の順番で複数のディレクトリからファイルを検索します。

    <itemizedlist>
<!--
     <listitem><simpara>current directory</simpara></listitem>
-->
     <listitem><simpara>カレントディレクトリ</simpara></listitem>
     <listitem><simpara><filename>/usr/local/include</filename></simpara></listitem>
<!--
     <listitem><simpara>PostgreSQL include directory, defined at build time (e.g., <filename>/usr/local/pgsql/include</filename>)</simpara></listitem>
-->
     <listitem><simpara>ビルド時に設定されたPostgreSQLのインクルードディレクトリ (例えば、<filename>/usr/local/pgsql/include</filename>)</simpara></listitem>
     <listitem><simpara><filename>/usr/include</filename></simpara></listitem>
    </itemizedlist>

<!--
    But when <literal>EXEC SQL INCLUDE
    "<replaceable>filename</replaceable>"</literal> is used, only the
    current directory is searched.
-->
しかし<literal>EXEC SQL INCLUDE "<replaceable>filename</replaceable>"</literal>が使われる場合、現在のディレクトリのみが検索されます。
   </para>

   <para>
<!--
    In each directory, the preprocessor will first look for the file
    name as given, and if not found will append <literal>.h</literal>
    to the file name and try again (unless the specified file name
    already has that suffix).
-->
各ディレクトリの中で、プリプロセッサはまず指定されたファイル名を探します。
見つからなければ（指定されたファイル名がこの接尾辞を持っていない限り）ファイル名に<literal>.h</literal>を付けて再検索します。
   </para>

   <para>
<!--
    Note that <command>EXEC SQL INCLUDE</command> is <emphasis>not</emphasis> the same as:
-->
<command>EXEC SQL INCLUDE</command>は以下とは<emphasis>異なる</emphasis>ことに注意してください。
<programlisting>
#include &lt;<replaceable>filename</replaceable>.h&gt;
</programlisting>
<!--
    because this file would not be subject to SQL command preprocessing.
    Naturally, you can continue to use the C
    <literal>#include</literal> directive to include other header
    files.
-->
このファイルにはSQLコマンド用前処理が行われないためです。
当然ながら、他のヘッダファイルをインクルードするCの<literal>#include</literal>ディレクティブを使用することができます。
   </para>

   <note>
    <para>
<!--
     The include file name is case-sensitive, even though the rest of
     the <literal>EXEC SQL INCLUDE</literal> command follows the normal
     SQL case-sensitivity rules.
-->
通常のSQLの大文字小文字の区別規則に従う<literal>EXEC SQL INCLUDE</literal>コマンドの一部であったとしても、インクルードファイルの名前は大文字小文字が区別されます。
    </para>
   </note>
  </sect2>

  <sect2 id="ecpg-define">
<!--
   <title>The define and undef Directives</title>
-->
   <title>defineおよびundef指示子</title>
   <para>
<!--
    Similar to the directive <literal>#define</literal> that is known from C,
    embedded SQL has a similar concept:
-->
Cで既知の<literal>#define</literal>指示子と同様、埋め込みSQLでも似たような概念を持ちます。
<programlisting>
EXEC SQL DEFINE <replaceable>name</>;
EXEC SQL DEFINE <replaceable>name</> <replaceable>value</>;
</programlisting>
<!--
    So you can define a name:
-->
このため、以下のように名前を定義することができます。
<programlisting>
EXEC SQL DEFINE HAVE_FEATURE;
</programlisting>
<!--
    And you can also define constants:
-->
また、定数を定義することもできます。
<programlisting>
EXEC SQL DEFINE MYNUMBER 12;
EXEC SQL DEFINE MYSTRING 'abc';
</programlisting>
<!--
    Use <literal>undef</> to remove a previous definition:
-->
事前の定義を削除するには<literal>undef</>を使用します。
<programlisting>
EXEC SQL UNDEF MYNUMBER;
</programlisting>
   </para>

   <para>
<!--
    Of course you can continue to use the C versions <literal>#define</literal>
    and <literal>#undef</literal> in your embedded SQL program. The difference
    is where your defined values get evaluated. If you use <literal>EXEC SQL
    DEFINE</> then the <command>ecpg</> preprocessor evaluates the defines and substitutes
    the values. For example if you write:
-->
当然、Cの<literal>#define</literal>や<literal>#undef</literal>を埋め込みSQLプログラムで使用することは可能です。
違いは宣言した値がどこで評価されるかです。
<literal>EXEC SQL DEFINE</>を使用する場合、<command>ecpg</>プリプロセッサがその定義を評価し、その値を置換します。
例えば、
<programlisting>
EXEC SQL DEFINE MYNUMBER 12;
...
EXEC SQL UPDATE Tbl SET col = MYNUMBER;
</programlisting>
<!--
    then <command>ecpg</> will already do the substitution and your C compiler will never
    see any name or identifier <literal>MYNUMBER</>. Note that you cannot use
    <literal>#define</literal> for a constant that you are going to use in an
    embedded SQL query because in this case the embedded SQL precompiler is not
    able to see this declaration.
-->
と記載した場合、<command>ecpg</>による置換がすでに行われていますので、Cコンパイラでは<literal>MYNUMBER</>という名前や識別子を参照することはありません。
埋め込みSQL問い合わせで使用する予定の定数に<literal>#define</literal>を使用することはできませんので注意してください。
この場合、埋め込みSQLプリプロセッサがこの宣言を参照することができないためです。
   </para>
  </sect2>

  <sect2 id="ecpg-ifdef">
<!--
   <title>ifdef, ifndef, else, elif, and endif Directives</title>
-->
   <title>ifdef、ifndef、else、elif、endif指示子</title>
   <para>
<!--
   You can use the following directives to compile code sections conditionally:
-->
以下の指示子を使用して、コンパイルするコード部分を選択することができます。

   <variablelist>
    <varlistentry>
     <term><literal>EXEC SQL ifdef <replaceable>name</>;</literal></term>
     <listitem>
     <para>
<!--
      Checks a <replaceable>name</> and processes subsequent lines if
      <replaceable>name</> has been created with <literal>EXEC SQL define
      <replaceable>name</></literal>.
-->
<replaceable>name</>を検査し、その<replaceable>name</>が<literal>EXEC SQL define <replaceable>name</></literal>で作成されていた場合に後続の行を処理します。
     </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>EXEC SQL ifndef <replaceable>name</>;</literal></term>
     <listitem>
     <para>
<!--
      Checks a <replaceable>name</> and processes subsequent lines if
      <replaceable>name</> has <emphasis>not</emphasis> been created with
      <literal>EXEC SQL define <replaceable>name</></literal>.
-->
<replaceable>name</>を検査し、その<replaceable>name</>が<literal>EXEC SQL define <replaceable>name</></literal>で作成されて<emphasis>いない</emphasis>場合に後続の行を処理します。
     </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>EXEC SQL else;</literal></term>
     <listitem>
     <para>
<!--
      Starts processing an alternative section to a section introduced by
      either <literal>EXEC SQL ifdef <replaceable>name</></literal> or
      <literal>EXEC SQL ifndef <replaceable>name</></literal>.
-->
<literal>EXEC SQL ifdef <replaceable>name</></literal>または<literal>EXEC SQL ifndef <replaceable>name</></literal>で導入されたセクションの代替セクションを開始します。
     </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>EXEC SQL elif <replaceable>name</>;</literal></term>
     <listitem>
     <para>
<!--
      Checks <replaceable>name</> and starts an alternative section if
      <replaceable>name</> has been created with <literal>EXEC SQL define
      <replaceable>name</></literal>.
-->
<replaceable>name</>を検査し、その<replaceable>name</>が<literal>EXEC SQL define <replaceable>name</></literal>で作成されている場合に代替セクションを開始します。
     </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>EXEC SQL endif;</literal></term>
     <listitem>
     <para>
<!--
      Ends an alternative section.
-->
代替セクションを終了します。
     </para>
     </listitem>
    </varlistentry>
   </variablelist>
   </para>

   <para>
<!--
    Example:
-->
以下に例を示します。
<programlisting>
EXEC SQL ifndef TZVAR;
EXEC SQL SET TIMEZONE TO 'GMT';
EXEC SQL elif TZNAME;
EXEC SQL SET TIMEZONE TO TZNAME;
EXEC SQL else;
EXEC SQL SET TIMEZONE TO TZVAR;
EXEC SQL endif;
</programlisting>
   </para>

  </sect2>
 </sect1>

  <sect1 id="ecpg-process">
<!--
  <title>Processing Embedded SQL Programs</title>
-->
  <title>埋め込みSQLプログラムの処理</title>

  <para>
<!--
   Now that you have an idea how to form embedded SQL C programs, you
   probably want to know how to compile them.  Before compiling you
   run the file through the embedded <acronym>SQL</acronym>
   <acronym>C</acronym> preprocessor, which converts the
   <acronym>SQL</acronym> statements you used to special function
   calls.  After compiling, you must link with a special library that
   contains the needed functions. These functions fetch information
   from the arguments, perform the <acronym>SQL</acronym> command using
   the <application>libpq</application> interface, and put the result
   in the arguments specified for output.
-->
ここまでで、埋め込みSQL Cプログラムの作成方法は理解できたと思います。
ここからはそのコンパイル方法についてお話しします。
コンパイルの前に、そのファイルを埋め込み<acronym>SQL</acronym> <acronym>C</acronym>プリプロセッサに通します。
これは、使用する<acronym>SQL</acronym>文を特別な関数呼び出しに変換します。
コンパイル後、必要な関数を持つ特別なライブラリとリンクしなければなりません。
これらの関数は引数から情報を取り出し、<application>libpq</application>を使用してその<acronym>SQL</acronym>を実行し、出力用に指定された引数にその結果を格納します。
  </para>

  <para>
<!--
   The preprocessor program is called <filename>ecpg</filename> and is
   included in a normal <productname>PostgreSQL</> installation.
   Embedded SQL programs are typically named with an extension
   <filename>.pgc</filename>.  If you have a program file called
   <filename>prog1.pgc</filename>, you can preprocess it by simply
   calling:
-->
プリプロセッサプログラムは<filename>ecpg</filename>という名前で、通常<productname>PostgreSQL</>のインストレーションに含まれています。
通常、埋め込みSQLプログラムの拡張子は<filename>.pgc</filename>とします。
<filename>prog1.pgc</filename>という名前のプログラムファイルがある場合、単純に以下を呼び出すことで前処理を行うことができます。
<programlisting>
ecpg prog1.pgc
</programlisting>
<!--
   This will create a file called <filename>prog1.c</filename>.  If
   your input files do not follow the suggested naming pattern, you
   can specify the output file explicitly using the
   <option>-o</option> option.
-->
これは<filename>prog1.c</filename>という名前のファイルを作成します。
入力ファイルがこの提案パターンに従った名前でない場合、<option>-o</option> オプションを使用して明示的に出力ファイルを指定することができます。
  </para>

  <para>
<!--
   The preprocessed file can be compiled normally, for example:
-->
前処理後のファイルは普通にコンパイルできます。
以下に例を示します。
<programlisting>
cc -c prog1.c
</programlisting>
<!--
   The generated C source files include header files from the
   <productname>PostgreSQL</> installation, so if you installed
   <productname>PostgreSQL</> in a location that is not searched by
   default, you have to add an option such as
   <literal>-I/usr/local/pgsql/include</literal> to the compilation
   command line.
-->
生成されたCソースファイルは<productname>PostgreSQL</>インストレーションに付随するヘッダファイルをインクルードします。
ですので、デフォルトで検索されない場所に<productname>PostgreSQL</>をインストールした場合は、コンパイル用のコマンドラインに<literal>-I/usr/local/pgsql/include</literal>のようなオプションを追加しなければなりません。
  </para>

  <para>
<!--
   To link an embedded SQL program, you need to include the
   <filename>libecpg</filename> library, like so:
-->
埋め込みSQLプログラムをリンクするためには、以下のように、<filename>libecpg</filename>ライブラリを含めなければなりません。
<programlisting>
cc -o myprog prog1.o prog2.o ... -lecpg
</programlisting>
<!--
   Again, you might have to add an option like
   <literal>-L/usr/local/pgsql/lib</literal> to that command line.
-->
繰り返しになりますが、コマンドラインに<literal>-L/usr/local/pgsql/lib</literal>といったオプションを追加する必要があるかもしれません。
  </para>

  <para>
<!--
   You can
   use <command>pg_config</command><indexterm><primary>pg_config</primary><secondary sortas="ecpg">with
   ecpg</secondary></indexterm>
   or <command>pkg-config</command><indexterm><primary>pkg-config</primary><secondary sortas="ecpg">with
   ecpg</secondary></indexterm> with package name <literal>libecpg</literal> to
   get the paths for your installation.
-->
インストール先のパスを取得するために、パッケージ名<literal>libecpg</literal>で<command>pg_config</command><indexterm><primary>pg_config</primary><secondary sortas="ecpg">ecpgでの</secondary></indexterm>または<command>pkg-config</command><indexterm><primary>pkg-config</primary><secondary sortas="ecpg">ecpgでの</secondary></indexterm>を使うことができます。
  </para>

  <para>
<!--
   If you manage the build process of a larger project using
   <application>make</application>, it might be convenient to include
   the following implicit rule to your makefiles:
-->
大規模プロジェクトの構築処理を<application>make</application>を使用して管理している場合、以下の暗黙規則をMakefileに含めておくと便利です。
<programlisting>
ECPG = ecpg

%.c: %.pgc
        $(ECPG) $&lt;
</programlisting>
  </para>

  <para>
<!--
   The complete syntax of the <command>ecpg</command> command is
   detailed in <xref linkend="app-ecpg">.
-->
<command>ecpg</command>コマンドの完全な構文は<xref linkend="app-ecpg">に説明があります。
  </para>

  <para>
<!--
   The <application>ecpg</application> library is thread-safe by
   default.  However, you might need to use some threading
   command-line options to compile your client code.
-->
デフォルトでは<application>ecpg</application>はスレッドセーフです。
しかしクライアントコードのコンパイル時に他のスレッド関連のコマンドラインオプションを使用する必要があるかもしれません。
  </para>
 </sect1>

 <sect1 id="ecpg-library">
<!--
  <title>Library Functions</title>
-->
  <title>ライブラリ関数</title>

  <para>
<!--
   The <filename>libecpg</filename> library primarily contains
   <quote>hidden</quote> functions that are used to implement the
   functionality expressed by the embedded SQL commands.  But there
   are some functions that can usefully be called directly.  Note that
   this makes your code unportable.
-->
<filename>libecpg</filename>ライブラリには基本的に、埋め込みSQLコマンドで表現される機能を実装するために使用する<quote>隠された</quote>関数が含まれています。
しかし、直接呼び出すことができる便利な関数もあります。
これによりコードが移植不可能になることに注意してください。
  </para>

  <itemizedlist>
   <listitem>
    <para>
<!--
     <function>ECPGdebug(int <replaceable>on</replaceable>, FILE
     *<replaceable>stream</replaceable>)</function> turns on debug
     logging if called with the first argument non-zero. Debug logging
     is done on <replaceable>stream</replaceable>.  The log contains
     all <acronym>SQL</acronym> statements with all the input
     variables inserted, and the results from the
     <productname>PostgreSQL</productname> server. This can be very
     useful when searching for errors in your <acronym>SQL</acronym>
     statements.
-->
<function>ECPGdebug(int <replaceable>on</replaceable>, FILE *<replaceable>stream</replaceable>)</function>は第1引数が0以外で渡された場合、デバッグログを有効にします。
デバッグログは<replaceable>stream</replaceable>に出力されます。
このログには、すべての入力変数が挿入されたすべての<acronym>SQL</acronym>文と、<productname>PostgreSQL</productname>サーバが返した結果が含まれます。
<acronym>SQL</acronym>文のエラーを見つける時に非常に役に立ちます。
    </para>
    <note>
    <para>
<!--
    On Windows, if the <application>ecpg</> libraries and an application are
    compiled with different flags, this function call will crash the
    application because the internal representation of the
    <literal>FILE</> pointers differ.  Specifically,
    multithreaded/single-threaded, release/debug, and static/dynamic
    flags should be the same for the library and all applications using
    that library.
-->
Windowsでは、<application>ecpg</>ライブラリとアプリケーションが異なるフラグでコンパイルされると、この関数の呼び出しは、<literal>FILE</>ポインタの内部表現が異なるため、アプリケーションをクラッシュさせる可能性があります。
特に、そのライブラリを使用するすべてのライブラリとすべてのアプリケーションに対して、multithreaded/single-threaded、release/debug、およびstatic/dynamicフラグは同じでなければなりません。
    </para>
    </note>
   </listitem>

   <listitem>
     <para>
<!--
       <function>ECPGget_PGconn(const char *<replaceable>connection_name</replaceable>)
       </function> returns the library database connection handle identified by the given name.
       If <replaceable>connection_name</replaceable> is set to <literal>NULL</literal>, the current
       connection handle is returned. If no connection handle can be identified, the function returns
       <literal>NULL</literal>. The returned connection handle can be used to call any other functions
       from <application>libpq</application>, if necessary.
-->
<function>ECPGget_PGconn(const char *<replaceable>connection_name</replaceable>)</function>は、指定された名前で識別されるライブラリデータベース接続ハンドルを返します。
<replaceable>connection_name</replaceable>の設定が<literal>NULL</literal>の場合、現在の接続ハンドルが返されます。
接続ハンドルを識別できない場合、関数は<literal>NULL</literal>を返します。
必要ならば返される接続ハンドルを使用して、任意の<application>libpq</application>の他の関数を呼び出すことができます。
     </para>
     <note>
     <para>
<!--
       It is a bad idea to manipulate database connection handles made from <application>ecpg</application> directly
       with <application>libpq</application> routines.
-->
<application>libpq</application>関数を直接使用して<application>ecpg</application>からデータベース接続ハンドルを操作することは推奨されません。
     </para>
     </note>
   </listitem>

   <listitem>
     <para>
<!--
       <function>ECPGtransactionStatus(const char *<replaceable>connection_name</replaceable>)</function>
       returns the current transaction status of the given connection identified by <replaceable>connection_name</replaceable>.
       See <xref linkend="libpq-status"> and libpq's <function>PQtransactionStatus()</function> for details about the returned status codes.
-->
<function>ECPGtransactionStatus(const char *<replaceable>connection_name</replaceable>)</function>は、<replaceable>connection_name</replaceable>で識別される指定接続の現在のトランザクション状態を返します。
返される状態コードの詳細については<xref linkend="libpq-status">とlibpqの<function>PQtransactionStatus()</function>を参照してください。
     </para>
   </listitem>

   <listitem>
    <para>
<!--
     <function>ECPGstatus(int <replaceable>lineno</replaceable>,
     const char* <replaceable>connection_name</replaceable>)</function>
     returns true if you are connected to a database and false if not.
     <replaceable>connection_name</replaceable> can be <literal>NULL</>
     if a single connection is being used.
-->
<function>ECPGstatus(int <replaceable>lineno</replaceable>, const char* <replaceable>connection_name</replaceable>)</function>はデータベースに接続している場合は真を、さもなくば偽を返します。
単一の接続を使用している場合は<replaceable>connection_name</replaceable>を<literal>NULL</>とすることができます。
    </para>
   </listitem>
  </itemizedlist>
 </sect1>

 <sect1 id="ecpg-lo">
<!--
  <title>Large Objects</title>
-->
  <title>ラージオブジェクト</title>

  <para>
<!--
   Large objects are not directly supported by ECPG, but ECPG
   application can manipulate large objects through the libpq large
   object functions, obtaining the necessary <type>PGconn</type>
   object by calling the <function>ECPGget_PGconn()</function>
   function.  (However, use of
   the <function>ECPGget_PGconn()</function> function and touching
   <type>PGconn</type> objects directly should be done very carefully
   and ideally not mixed with other ECPG database access calls.)
-->
ラージオブジェクトはECPGで直接サポートされていません。
しかしECPGアプリケーションは、<function>ECPGget_PGconn()</function>関数を呼び出して必要な<type>PGconn</type>を入手して、libpqラージオブジェクト関数を介してラージオブジェクトを操作することができます。
（しかし<function>ECPGget_PGconn()</function>関数の使用と<type>PGconn</type>を直接触ることは非常に注意して行わなければなりません。理想を言えば他のECPGデータベースアクセス呼び出しと混在させないようにしてください。）
  </para>

  <para>
<!--
   For more details about the <function>ECPGget_PGconn()</function>, see
   <xref linkend="ecpg-library">.  For information about the large
   object function interface, see <xref linkend="largeObjects">.
-->
<function>ECPGget_PGconn()</function>に関しては<xref linkend="ecpg-library">を参照してください。
ラージオブジェクト関数インタフェースについては<xref linkend="largeObjects">を参照してください。
  </para>

  <para>
<!--
   Large object functions have to be called in a transaction block, so
   when autocommit is off, <command>BEGIN</command> commands have to
   be issued explicitly.
-->
ラージオブジェクト関数をトランザクションブロック内で呼び出さなければなりません。
このため自動コミットが無効な場合、<command>BEGIN</command>コマンドを明示的に発行しなければなりません。
  </para>

  <para>
<!--
   <xref linkend="ecpg-lo-example"> shows an example program that
   illustrates how to create, write, and read a large object in an
   ECPG application.
-->
<xref linkend="ecpg-lo-example">では、ECPGアプリケーション内でラージオブジェクトの作成、書き出し、読み取りを行う方法を示すプログラム例を示します。
  </para>

  <example id="ecpg-lo-example">
<!--
   <title>ECPG Program Accessing Large Objects</title>
-->
   <title>ラージオブジェクトにアクセスするECPGプログラム</title>
<programlisting><![CDATA[
#include <stdio.h>
#include <stdlib.h>
#include <libpq-fe.h>
#include <libpq/libpq-fs.h>

EXEC SQL WHENEVER SQLERROR STOP;

int
main(void)
{
    PGconn     *conn;
    Oid         loid;
    int         fd;
    char        buf[256];
    int         buflen = 256;
    char        buf2[256];
    int         rc;

    memset(buf, 1, buflen);

    EXEC SQL CONNECT TO testdb AS con1;

    conn = ECPGget_PGconn("con1");
    printf("conn = %p\n", conn);

]]><!--
    /* create */
--><![CDATA[
    /* 作成 */
    loid = lo_create(conn, 0);
    if (loid &lt; 0)
        printf("lo_create() failed: %s", PQerrorMessage(conn));

    printf("loid = %d\n", loid);

]]><!--
    /* write test */
--><![CDATA[
    /* 書き出しテスト */
    fd = lo_open(conn, loid, INV_READ|INV_WRITE);
    if (fd &lt; 0)
        printf("lo_open() failed: %s", PQerrorMessage(conn));

    printf("fd = %d\n", fd);

    rc = lo_write(conn, fd, buf, buflen);
    if (rc &lt; 0)
        printf("lo_write() failed\n");

    rc = lo_close(conn, fd);
    if (rc &lt; 0)
        printf("lo_close() failed: %s", PQerrorMessage(conn));

]]><!--
    /* read test */
--><![CDATA[
    /* 読み取りテスト */
    fd = lo_open(conn, loid, INV_READ);
    if (fd &lt; 0)
        printf("lo_open() failed: %s", PQerrorMessage(conn));

    printf("fd = %d\n", fd);

    rc = lo_read(conn, fd, buf2, buflen);
    if (rc &lt; 0)
        printf("lo_read() failed\n");

    rc = lo_close(conn, fd);
    if (rc &lt; 0)
        printf("lo_close() failed: %s", PQerrorMessage(conn));

]]><!--
    /* check */
--><![CDATA[
    /* 確認 */
    rc = memcmp(buf, buf2, buflen);
    printf("memcmp() = %d\n", rc);

]]><!--
    /* cleanup */
--><![CDATA[
    /* 後始末 */
    rc = lo_unlink(conn, loid);
    if (rc &lt; 0)
        printf("lo_unlink() failed: %s", PQerrorMessage(conn));

    EXEC SQL COMMIT;
    EXEC SQL DISCONNECT ALL;
    return 0;
}
]]></programlisting>
  </example>
 </sect1>

 <sect1 id="ecpg-cpp">
<!--
  <title><acronym>C++</acronym> Applications</title>
-->
  <title><acronym>C++</acronym>アプリケーション</title>

  <para>
<!--
   ECPG has some limited support for C++ applications.  This section
   describes some caveats.
-->
ECPGはC++アプリケーションを多少の制限がありますがサポートします。
本節ではいくつかの注意を説明します。
  </para>

  <para>
<!--
   The <command>ecpg</command> preprocessor takes an input file
   written in C (or something like C) and embedded SQL commands,
   converts the embedded SQL commands into C language chunks, and
   finally generates a <filename>.c</filename> file.  The header file
   declarations of the library functions used by the C language chunks
   that <command>ecpg</command> generates are wrapped
   in <literal>extern "C" { ... }</literal> blocks when used under
   C++, so they should work seamlessly in C++.
-->
<command>ecpg</command>プリプロセッサはC（またはCのようなもの）と埋め込みSQLコマンドで記述された入力ファイルを取り、埋め込みSQLコマンドをC言語の小塊に変換し、最終的に<filename>.c</filename>ファイルを作成します。
<command>ecpg</command>が生成するC言語の小塊で使用されるライブラリ関数のヘッダファイル定義は、C++で使用される場合<literal>extern "C" { ... }</literal>で囲まれます。
このためC++でも継ぎ目なく動作するはずです。
  </para>

  <para>
<!--
   In general, however, the <command>ecpg</command> preprocessor only
   understands C; it does not handle the special syntax and reserved
   words of the C++ language.  So, some embedded SQL code written in
   C++ application code that uses complicated features specific to C++
   might fail to be preprocessed correctly or might not work as
   expected.
-->
しかし一般的には、<command>ecpg</command>プリプロセッサはCのみを理解しています。
C++言語の特殊な構文や予約語を取り扱いません。
このため、C++に特化した複雑な機能を使用するC++アプリケーションコードの中に記述された埋め込みSQLコードの一部は、正しく前処理することに失敗する、または想定通りに動作しないかもしれません。
  </para>

  <para>
<!--
   A safe way to use the embedded SQL code in a C++ application is
   hiding the ECPG calls in a C module, which the C++ application code
   calls into to access the database, and linking that together with
   the rest of the C++ code.  See <xref linkend="ecpg-cpp-and-c">
   about that.
-->
C++アプリケーションで埋め込みSQLコードを使用する安全な方法は、ECPGの呼び出しをCモジュール内に隠蔽し、残りのC++コードとまとめてリンクすることです。C++アプリケーションコードがデータベースにアクセスするためにはそのCモジュールを呼び出します。
<xref linkend="ecpg-cpp-and-c">を参照してください。
  </para>

  <sect2 id="ecpg-cpp-scope">
<!--
   <title>Scope for Host Variables</title>
-->
   <title>ホスト変数のスコープ</title>

   <para>
<!--
    The <command>ecpg</command> preprocessor understands the scope of
    variables in C.  In the C language, this is rather simple because
    the scopes of variables is based on their code blocks.  In C++,
    however, the class member variables are referenced in a different
    code block from the declared position, so
    the <command>ecpg</command> preprocessor will not understand the
    scope of the class member variables.
-->
<command>ecpg</command>プリプロセッサはCにおける変数のスコープを理解しています。
C言語では、変数のスコープはコードブロックに基づきますので、どちらかといえば単純です。
しかしC++では
クラスメンバ変数は宣言場所とは異なるコードブロック内で参照されます。
このため<command>ecpg</command>プリプロセッサはクラスメンバ変数のスコープを理解していません。
   </para>

   <para>
<!--
    For example, in the following case, the <command>ecpg</command>
    preprocessor cannot find any declaration for the
    variable <literal>dbname</literal> in the <literal>test</literal>
    method, so an error will occur.
-->
例えば、以下の場合、<command>ecpg</command>プリプロセッサは<literal>test</literal>メソッド内の<literal>dbname</literal>変数の定義を見つけることができません。
このためエラーになります。

<programlisting>
class TestCpp
{
    EXEC SQL BEGIN DECLARE SECTION;
    char dbname[1024];
    EXEC SQL END DECLARE SECTION;

  public:
    TestCpp();
    void test();
    ~TestCpp();
};

TestCpp::TestCpp()
{
    EXEC SQL CONNECT TO testdb1;
}

void Test::test()
{
    EXEC SQL SELECT current_database() INTO :dbname;
    printf("current_database = %s\n", dbname);
}

TestCpp::~TestCpp()
{
    EXEC SQL DISCONNECT ALL;
}
</programlisting>

<!--
    This code will result in an error like this:
-->
このコードは以下のようなエラーになります。
<screen>
<userinput>ecpg test_cpp.pgc</userinput>
test_cpp.pgc:28: ERROR: variable "dbname" is not declared
</screen>
   </para>

   <para>
<!--
    To avoid this scope issue, the <literal>test</literal> method
    could be modified to use a local variable as intermediate storage.
    But this approach is only a poor workaround, because it uglifies
    the code and reduces performance.
-->
このスコープ問題を回避するためには、<literal>test</literal>メソッドを中間格納領域としてローカル変数を使用するように変更することができます。
しかしこの手法は悪い回避策でしかありません。コードを醜くしますし性能も劣化させます。

<programlisting>
void TestCpp::test()
{
    EXEC SQL BEGIN DECLARE SECTION;
    char tmp[1024];
    EXEC SQL END DECLARE SECTION;

    EXEC SQL SELECT current_database() INTO :tmp;
    strlcpy(dbname, tmp, sizeof(tmp));

    printf("current_database = %s\n", dbname);
}
</programlisting>
   </para>
  </sect2>

  <sect2 id="ecpg-cpp-and-c">
<!--
   <title>C++ Application Development with External C Module</title>
-->
   <title>外部のCモジュールを用いたC++アプリケーションの開発</title>

   <para>
<!--
    If you understand these technical limitations of
    the <command>ecpg</command> preprocessor in C++, you might come to
    the conclusion that linking C objects and C++ objects at the link
    stage to enable C++ applications to use ECPG features could be
    better than writing some embedded SQL commands in C++ code
    directly.  This section describes a way to separate some embedded
    SQL commands from C++ application code with a simple example.  In
    this example, the application is implemented in C++, while C and
    ECPG is used to connect to the PostgreSQL server.
-->
C++における<command>ecpg</command>の技術的な制限を理解しているのであれば、ECPG機能を使用するC++アプリケーションを実現するためには、リンク段階でCオブジェクトとC++オブジェクトをリンクする方が、C++コード内で埋め込みSQLコマンドを直接記述することより優れているという結論に至るでしょう。
本節では、簡単な例を用いて、C++アプリケーションコードから埋め込みSQLコマンドを分離する方法について説明します。
この例では、アプリケーションはC++で実装し、PostgreSQLサーバに接続するためにCおよびECPGを使用します。
   </para>

   <para>
<!--
    Three kinds of files have to be created: a C file
    (<filename>*.pgc</filename>), a header file, and a C++ file:
-->
Cファイル（<filename>*.pgc</filename>）、ヘッダファイル、C++ファイルという３種類のファイルを作成しなければなりません。

    <variablelist>
     <varlistentry>
      <term><filename>test_mod.pgc</filename></term>
      <listitem>
       <para>
<!--
        A sub-routine module to execute SQL commands embedded in C.
        It is going to be converted
        into <filename>test_mod.c</filename> by the preprocessor.
-->
C内に埋め込まれたサブルーチンモジュールです。
プリプロセッサにより<filename>test_mod.c</filename>に変換されます。

<programlisting>
#include "test_mod.h"
#include &lt;stdio.h&gt;

void
db_connect()
{
    EXEC SQL CONNECT TO testdb1;
}

void
db_test()
{
    EXEC SQL BEGIN DECLARE SECTION;
    char dbname[1024];
    EXEC SQL END DECLARE SECTION;

    EXEC SQL SELECT current_database() INTO :dbname;
    printf("current_database = %s\n", dbname);
}

void
db_disconnect()
{
    EXEC SQL DISCONNECT ALL;
}
</programlisting>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><filename>test_mod.h</filename></term>
      <listitem>
       <para>
<!--
        A header file with declarations of the functions in the C
        module (<filename>test_mod.pgc</filename>).  It is included by
        <filename>test_cpp.cpp</filename>.  This file has to have an
        <literal>extern "C"</literal> block around the declarations,
        because it will be linked from the C++ module.
-->
Cモジュール（<filename>test_mod.pgc</filename>）内の関数宣言を持つヘッダファイルです。
<filename>test_cpp.cpp</filename>でインクルードされます。
このファイルは、C++モジュールからリンクされますので、宣言を囲む<literal>extern "C"</literal>ブロックを持たなければなりません。

<programlisting>
#ifdef __cplusplus
extern "C" {
#endif

void db_connect();
void db_test();
void db_disconnect();

#ifdef __cplusplus
}
#endif
</programlisting>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><filename>test_cpp.cpp</filename></term>
      <listitem>
       <para>
<!--
        The main code for the application, including
        the <function>main</function> routine, and in this example a
        C++ class.
-->
<function>main</function>ルーチンとこの例でのC++クラスを含む、アプリケーションの主要コードです。

<programlisting>
#include "test_mod.h"

class TestCpp
{
  public:
    TestCpp();
    void test();
    ~TestCpp();
};

TestCpp::TestCpp()
{
    db_connect();
}

void
TestCpp::test()
{
    db_test();
}

TestCpp::~TestCpp()
{
    db_disconnect();
}

int
main(void)
{
    TestCpp *t = new TestCpp();

    t->test();
    return 0;
}
</programlisting>
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>

   <para>
<!--
    To build the application, proceed as follows.  Convert
    <filename>test_mod.pgc</> into <filename>test_mod.c</> by
    running <command>ecpg</command>, and generate
    <filename>test_mod.o</> by compiling
    <filename>test_mod.c</> with the C compiler:
-->
アプリケーションを構築するためには、以下の処理を行います。
<command>ecpg</command>を実行して<filename>test_mod.pgc</>を<filename>test_mod.c</>に変換します。
そしてCコンパイラを用いて<filename>test_mod.c</>をコンパイルし<filename>test_mod.o</>を生成します。
<programlisting>
ecpg -o test_mod.c test_mod.pgc
cc -c test_mod.c -o test_mod.o
</programlisting>
   </para>

   <para>
<!--
    Next, generate <filename>test_cpp.o</> by compiling
    <filename>test_cpp.cpp</> with the C++ compiler:
-->
次にC++コンパイラを用いて<filename>test_cpp.cpp</>をコンパイルし<filename>test_cpp.o</>を生成します。
<programlisting>
c++ -c test_cpp.cpp -o test_cpp.o
</programlisting>
   </para>

   <para>
<!--
    Finally, link these object files, <filename>test_cpp.o</>
    and <filename>test_mod.o</>, into one executable, using the C++
    compiler driver:
-->
最後に、C++コンパイラドライバを用いて<filename>test_cpp.o</>および<filename>test_mod.o</>というオブジェクトファイルを実行形式ファイルにリンクします。
<programlisting>
c++ test_cpp.o test_mod.o -lecpg -o test_cpp
</programlisting>
   </para>
  </sect2>
 </sect1>

 <sect1 id="ecpg-sql-commands">
<!--
  <title>Embedded SQL Commands</title>
-->
  <title>埋め込みSQLコマンド</title>

  <para>
<!--
   This section describes all SQL commands that are specific to
   embedded SQL.  Also refer to the SQL commands listed
   in <xref linkend="sql-commands">, which can also be used in
   embedded SQL, unless stated otherwise.
-->
本節では、埋め込みSQL固有のSQLコマンドをすべて説明します。
また、言及がない限り、埋め込みSQLでも使用することができる、<xref linkend="sql-commands">に列挙されたSQLコマンドを参照してください。
  </para>

  <refentry id="ecpg-sql-allocate-descriptor">
   <refnamediv>
    <refname>ALLOCATE DESCRIPTOR</refname>
<!--
    <refpurpose>allocate an SQL descriptor area</refpurpose>
-->
    <refpurpose>SQL記述子領域を割り当てます。</refpurpose>
   </refnamediv>

   <refsynopsisdiv>
<synopsis>
ALLOCATE DESCRIPTOR <replaceable class="PARAMETER">name</replaceable>
</synopsis>
   </refsynopsisdiv>

   <refsect1>
<!--
    <title>Description</title>
-->
    <title>説明</title>

    <para>
<!--
     <command>ALLOCATE DESCRIPTOR</command> allocates a new named SQL
     descriptor area, which can be used to exchange data between the
     PostgreSQL server and the host program.
-->
<command>ALLOCATE DESCRIPTOR</command>は、PostgreSQLサーバとホストプログラムとの間のデータ交換のために使用することができる、新しい名前付きSQL記述子領域を割り当てます。
    </para>

    <para>
<!--
     Descriptor areas should be freed after use using
     the <command>DEALLOCATE DESCRIPTOR</command> command.
-->
記述子領域は、使用した後で<command>DEALLOCATE DESCRIPTOR</command>コマンドを使用して解放しなければなりません。
    </para>
   </refsect1>

   <refsect1>
<!--
    <title>Parameters</title>
-->
    <title>パラメータ</title>

    <variablelist>
     <varlistentry>
      <term><replaceable class="PARAMETER">name</replaceable></term>
      <listitem>
       <para>
<!--
        A name of SQL descriptor, case sensitive.  This can be an SQL
        identifier or a host variable.
-->
SQL記述子の名前です。
大文字小文字を区別します。
これはSQL識別子またはホスト変数になることができます。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </refsect1>

   <refsect1>
<!--
    <title>Examples</title>
-->
    <title>例</title>

<programlisting>
EXEC SQL ALLOCATE DESCRIPTOR mydesc;
</programlisting>
   </refsect1>

   <refsect1>
<!--
    <title>Compatibility</title>
-->
    <title>互換性</title>

    <para>
<!--
     <command>ALLOCATE DESCRIPTOR</command> is specified in the SQL
     standard.
-->
<command>ALLOCATE DESCRIPTOR</command>は標準SQLで規定されています。
    </para>
   </refsect1>

   <refsect1>
<!--
    <title>See Also</title>
-->
    <title>関連項目</title>

    <simplelist type="inline">
     <member><xref linkend="ecpg-sql-deallocate-descriptor"></member>
     <member><xref linkend="ecpg-sql-get-descriptor"></member>
     <member><xref linkend="ecpg-sql-set-descriptor"></member>
    </simplelist>
   </refsect1>
  </refentry>

  <refentry id="ecpg-sql-connect">
   <refnamediv>
    <refname>CONNECT</refname>
<!--
    <refpurpose>establish a database connection</refpurpose>
-->
    <refpurpose>データベース接続を確立します。</refpurpose>
   </refnamediv>

   <refsynopsisdiv>
<synopsis>
CONNECT TO <replaceable>connection_target</replaceable> [ AS <replaceable>connection_name</replaceable> ] [ USER <replaceable>connection_user</replaceable> ]
CONNECT TO DEFAULT
CONNECT <replaceable>connection_user</replaceable>
DATABASE <replaceable>connection_target</replaceable>
</synopsis>
   </refsynopsisdiv>

   <refsect1>
<!--
    <title>Description</title>
-->
    <title>説明</title>

    <para>
<!--
     The <command>CONNECT</command> command establishes a connection
     between the client and the PostgreSQL server.
-->
<command>CONNECT</command>コマンドはクライアントとPostgreSQLサーバとの間の接続を確立します。
    </para>
   </refsect1>

   <refsect1>
<!--
    <title>Parameters</title>
-->
    <title>パラメータ</title>

    <variablelist>
     <varlistentry>
      <term><replaceable class="PARAMETER">connection_target</replaceable></term>
      <listitem>
       <para>
        <replaceable class="PARAMETER">connection_target</replaceable>
<!--
        specifies the target server of the connection on one of
        several forms.
-->
以下の複数の形式の１つを使用して、接続する対象サーバを指定します。

        <variablelist>
         <varlistentry>
          <term>[ <replaceable>database_name</replaceable> ] [ <literal>@</literal><replaceable>host</replaceable> ] [ <literal>:</literal><replaceable>port</replaceable> ]</term>
          <listitem>
           <para>
<!--
            Connect over TCP/IP
-->
TCP/IPを介した接続。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>unix:postgresql://</literal><replaceable>host</replaceable> [ <literal>:</literal><replaceable>port</replaceable> ] <literal>/</literal> [ <replaceable>database_name</replaceable> ] [ <literal>?</literal><replaceable>connection_option</replaceable> ]</term>
          <listitem>
           <para>
<!--
            Connect over Unix-domain sockets
-->
Unixドメインソケットを介した接続。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>tcp:postgresql://</literal><replaceable>host</replaceable> [ <literal>:</literal><replaceable>port</replaceable> ] <literal>/</literal> [ <replaceable>database_name</replaceable> ] [ <literal>?</literal><replaceable>connection_option</replaceable> ]</term>
          <listitem>
           <para>
<!--
            Connect over TCP/IP
-->
TCP/IPを介した接続。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
<!--
          <term>SQL string constant</term>
-->
          <term>SQL文字列定数</term>
          <listitem>
           <para>
<!--
            containing a value in one of the above forms
-->
上記形式のいずれかで記述された値を持ちます。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
<!--
          <term>host variable</term>
-->
          <term>ホスト変数</term>
          <listitem>
           <para>
<!--
            host variable of type <type>char[]</type>
            or <type>VARCHAR[]</type> containing a value in one of the
            above forms
-->
上記形式のいずれかで記述された値を持つ<type>char[]</type>または<type>VARCHAR[]</type>型のホスト変数。
           </para>
          </listitem>
         </varlistentry>
        </variablelist>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="PARAMETER">connection_object</replaceable></term>
      <listitem>
       <para>
<!--
        An optional identifier for the connection, so that it can be
        referred to in other commands.  This can be an SQL identifier
        or a host variable.
-->
他のコマンドで参照することができる、このデータベース接続の識別子です。省略可能です。
これはSQL識別子またはホスト変数とすることができます。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="PARAMETER">connection_user</replaceable></term>
      <listitem>
       <para>
<!--
        The user name for the database connection.
-->
データベース接続用のユーザ名です。
       </para>

       <para>
<!--
        This parameter can also specify user name and password, using one the forms
        <literal><replaceable>user_name</replaceable>/<replaceable>password</replaceable></literal>,
        <literal><replaceable>user_name</replaceable> IDENTIFIED BY <replaceable>password</replaceable></literal>, or
        <literal><replaceable>user_name</replaceable> USING <replaceable>password</replaceable></literal>.
-->
このパラメータは、<literal><replaceable>user_name</replaceable>/<replaceable>password</replaceable></literal>、<literal><replaceable>user_name</replaceable> IDENTIFIED BY <replaceable>password</replaceable></literal>、<literal><replaceable>user_name</replaceable> USING <replaceable>password</replaceable></literal>のいずれかの形式を使用して、ユーザ名とパスワードを指定することができます。
       </para>

       <para>
<!--
        User name and password can be SQL identifiers, string
        constants, or host variables.
-->
ユーザ名とパスワードは、SQL識別子、文字列定数、ホスト変数とすることができます。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>DEFAULT</literal></term>
      <listitem>
       <para>
<!--
        Use all default connection parameters, as defined by libpq.
-->
libpqで定義された、デフォルトの接続パラメータすべてを使用します。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </refsect1>

   <refsect1>
<!--
    <title>Examples</title>
-->
    <title>例</title>

    <para>
<!--
     Here a several variants for specifying connection parameters:
-->
以下に接続パラメータを指定する複数の種類を示します。
<programlisting>
EXEC SQL CONNECT TO "connectdb" AS main;
EXEC SQL CONNECT TO "connectdb" AS second;
EXEC SQL CONNECT TO "unix:postgresql://200.46.204.71/connectdb" AS main USER connectuser;
EXEC SQL CONNECT TO "unix:postgresql://localhost/connectdb" AS main USER connectuser;
EXEC SQL CONNECT TO 'connectdb' AS main;
EXEC SQL CONNECT TO 'unix:postgresql://localhost/connectdb' AS main USER :user;
EXEC SQL CONNECT TO :db AS :id;
EXEC SQL CONNECT TO :db USER connectuser USING :pw;
EXEC SQL CONNECT TO @localhost AS main USER connectdb;
EXEC SQL CONNECT TO REGRESSDB1 as main;
EXEC SQL CONNECT TO AS main USER connectdb;
EXEC SQL CONNECT TO connectdb AS :id;
EXEC SQL CONNECT TO connectdb AS main USER connectuser/connectdb;
EXEC SQL CONNECT TO connectdb AS main;
EXEC SQL CONNECT TO connectdb@localhost AS main;
EXEC SQL CONNECT TO tcp:postgresql://localhost/ USER connectdb;
EXEC SQL CONNECT TO tcp:postgresql://localhost/connectdb USER connectuser IDENTIFIED BY connectpw;
EXEC SQL CONNECT TO tcp:postgresql://localhost:20/connectdb USER connectuser IDENTIFIED BY connectpw;
EXEC SQL CONNECT TO unix:postgresql://localhost/ AS main USER connectdb;
EXEC SQL CONNECT TO unix:postgresql://localhost/connectdb AS main USER connectuser;
EXEC SQL CONNECT TO unix:postgresql://localhost/connectdb USER connectuser IDENTIFIED BY "connectpw";
EXEC SQL CONNECT TO unix:postgresql://localhost/connectdb USER connectuser USING "connectpw";
EXEC SQL CONNECT TO unix:postgresql://localhost/connectdb?connect_timeout=14 USER connectuser;
</programlisting>
    </para>

    <para>
<!--
     Here is an example program that illustrates the use of host
     variables to specify connection parameters:
-->
以下にホスト変数を使用して接続パラメータを指定する方法を示すプログラム例を示します。
<programlisting>
int
main(void)
{
EXEC SQL BEGIN DECLARE SECTION;
<!--
    char *dbname     = "testdb";    /* database name */
    char *user       = "testuser";  /* connection user name */
    char *connection = "tcp:postgresql://localhost:5432/testdb";
                                    /* connection string */
    char ver[256];                  /* buffer to store the version string */
-->
    char *dbname     = "testdb";    /* データベース名 */
    char *user       = "testuser";  /* 接続ユーザ名 */
    char *connection = "tcp:postgresql://localhost:5432/testdb";
                                    /* 接続文字列 */
    char ver[256];                  /* バージョン文字列を保持するバッファ */
EXEC SQL END DECLARE SECTION;

    ECPGdebug(1, stderr);

    EXEC SQL CONNECT TO :dbname USER :user;
    EXEC SQL SELECT version() INTO :ver;
    EXEC SQL DISCONNECT;

    printf("version: %s\n", ver);

    EXEC SQL CONNECT TO :connection USER :user;
    EXEC SQL SELECT version() INTO :ver;
    EXEC SQL DISCONNECT;

    printf("version: %s\n", ver);

    return 0;
}
</programlisting>
    </para>
   </refsect1>

   <refsect1>
<!--
    <title>Compatibility</title>
-->
    <title>互換性</title>

    <para>
<!--
     <command>CONNECT</command> is specified in the SQL standard, but
     the format of the connection parameters is
     implementation-specific.
-->
<command>CONNECT</command>は標準SQLで規定されていますが、接続パラメータの書式は実装に特化しています。
    </para>
   </refsect1>

   <refsect1>
<!--
    <title>See Also</title>
-->
    <title>関連項目</title>

    <simplelist type="inline">
     <member><xref linkend="ecpg-sql-disconnect"></member>
     <member><xref linkend="ecpg-sql-set-connection"></member>
    </simplelist>
   </refsect1>
  </refentry>

  <refentry id="ecpg-sql-deallocate-descriptor">
   <refnamediv>
    <refname>DEALLOCATE DESCRIPTOR</refname>
<!--
    <refpurpose>deallocate an SQL descriptor area</refpurpose>
-->
    <refpurpose>SQL記述子領域の割り当てを解除します。</refpurpose>
   </refnamediv>

   <refsynopsisdiv>
<synopsis>
DEALLOCATE DESCRIPTOR <replaceable class="PARAMETER">name</replaceable>
</synopsis>
   </refsynopsisdiv>

   <refsect1>
<!--
    <title>Description</title>
-->
    <title>説明</title>

    <para>
<!--
     <command>DEALLOCATE DESCRIPTOR</command> deallocates a named SQL
     descriptor area.
-->
<command>DEALLOCATE DESCRIPTOR</command>は名前付きSQL記述子領域の割り当てを解除します。
    </para>
   </refsect1>

   <refsect1>
<!--
    <title>Parameters</title>
-->
    <title>パラメータ</title>

    <variablelist>
     <varlistentry>
      <term><replaceable class="PARAMETER">name</replaceable></term>
      <listitem>
       <para>
<!--
        The name of the descriptor which is going to be deallocated.
        It is case sensitive.  This can be an SQL identifier or a host
        variable.
-->
割り当てを解除する記述子の名前です。
大文字小文字を区別します。
これはSQL識別子またはホスト変数にすることができます。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </refsect1>

   <refsect1>
<!--
    <title>Examples</title>
-->
    <title>例</title>

<programlisting>
EXEC SQL DEALLOCATE DESCRIPTOR mydesc;
</programlisting>
   </refsect1>

   <refsect1>
<!--
    <title>Compatibility</title>
-->
    <title>互換性</title>

    <para>
<!--
     <command>DEALLOCATE DESCRIPTOR</command> is specified in the SQL
     standard.
-->
<command>DEALLOCATE DESCRIPTOR</command>は標準SQLで規定されています。
    </para>
   </refsect1>

   <refsect1>
<!--
    <title>See Also</title>
-->
    <title>関連項目</title>

    <simplelist type="inline">
     <member><xref linkend="ecpg-sql-allocate-descriptor"></member>
     <member><xref linkend="ecpg-sql-get-descriptor"></member>
     <member><xref linkend="ecpg-sql-set-descriptor"></member>
    </simplelist>
   </refsect1>
  </refentry>

  <refentry id="ecpg-sql-declare">
   <refnamediv>
    <refname>DECLARE</refname>
<!--
    <refpurpose>define a cursor</refpurpose>
-->
    <refpurpose>カーソルを定義します。</refpurpose>
   </refnamediv>

   <refsynopsisdiv>
<synopsis>
DECLARE <replaceable class="PARAMETER">cursor_name</replaceable> [ BINARY ] [ INSENSITIVE ] [ [ NO ] SCROLL ] CURSOR [ { WITH | WITHOUT } HOLD ] FOR <replaceable class="PARAMETER">prepared_name</replaceable>
DECLARE <replaceable class="PARAMETER">cursor_name</replaceable> [ BINARY ] [ INSENSITIVE ] [ [ NO ] SCROLL ] CURSOR [ { WITH | WITHOUT } HOLD ] FOR <replaceable class="PARAMETER">query</replaceable>
</synopsis>
   </refsynopsisdiv>

   <refsect1>
<!--
    <title>Description</title>
-->
    <title>説明</title>

    <para>
<!--
     <command>DECLARE</command> declares a cursor for iterating over
     the result set of a prepared statement.  This command has
     slightly different semantics from the direct SQL
     command <command>DECLARE</command>: Whereas the latter executes a
     query and prepares the result set for retrieval, this embedded
     SQL command merely declares a name as a <quote>loop
     variable</quote> for iterating over the result set of a query;
     the actual execution happens when the cursor is opened with
     the <command>OPEN</command> command.
-->
<command>DECLARE</command>は、プリペアド文の結果セット全体を繰り返し処理するカーソルを宣言します。
このコマンドは直接的な<command>DECLARE</command>SQLコマンドとは多少異なる意味を持ちます。
こちらは問い合わせを実行し、取り出し用の結果セットの準備を行いますが、埋め込みSQLコマンドでは、問い合わせの結果セット全体を繰り返す<quote>ループ変数</quote>の名前を宣言するだけです。
実際の実行は<command>OPEN</command>コマンドでカーソルが開いた時に起こります。
    </para>
   </refsect1>

   <refsect1>
<!--
    <title>Parameters</title>
-->
    <title>パラメータ</title>
    <variablelist>

     <varlistentry>
      <term><replaceable class="PARAMETER">cursor_name</replaceable></term>
      <listitem>
       <para>
<!--
        A cursor name, case sensitive.  This can be an SQL identifier
        or a host variable.
-->
カーソル名です。
大文字小文字を区別します。
これはSQL識別子またはホスト変数とすることができます。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="PARAMETER">prepared_name</replaceable></term>
      <listitem>
       <para>
<!--
        The name of a prepared query, either as an SQL identifier or a
        host variable.
-->
プリペアド問い合わせの名前です。
SQL識別子またはホスト変数のいずれかです。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">query</replaceable></term>
      <listitem>
       <para>
<!--
        A <xref linkend="sql-select"> or
        <xref linkend="sql-values"> command which will provide the
        rows to be returned by the cursor.
-->
このカーソルで返される行を供給する<xref linkend="sql-select">または<xref linkend="sql-values">コマンドです。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>

    <para>
<!--
     For the meaning of the cursor options,
     see <xref linkend="sql-declare">.
-->
カーソルオプションの意味については<xref linkend="sql-declare">を参照してください。
    </para>
   </refsect1>

   <refsect1>
<!--
    <title>Examples</title>
-->
    <title>例</title>

    <para>
<!--
     Examples declaring a cursor for a query:
-->
以下に問い合わせ用のカーソルを宣言する例を示します。
<programlisting>
EXEC SQL DECLARE C CURSOR FOR SELECT * FROM My_Table;
EXEC SQL DECLARE C CURSOR FOR SELECT Item1 FROM T;
EXEC SQL DECLARE cur1 CURSOR FOR SELECT version();
</programlisting>
    </para>

    <para>
<!--
     An example declaring a cursor for a prepared statement:
-->
プリペアド文用のカーソルを宣言する例を示します。
<programlisting>
EXEC SQL PREPARE stmt1 AS SELECT version();
EXEC SQL DECLARE cur1 CURSOR FOR stmt1;
</programlisting>
    </para>
   </refsect1>

   <refsect1>
<!--
    <title>Compatibility</title>
-->
    <title>互換性</title>

    <para>
<!--
     <command>DECLARE</command> is specified in the SQL standard.
-->
<command>DECLARE</command>は標準SQLで規定されています。
    </para>
   </refsect1>

   <refsect1>
<!--
    <title>See Also</title>
-->
    <title>関連項目</title>

    <simplelist type="inline">
     <member><xref linkend="ecpg-sql-open"></member>
     <member><xref linkend="sql-close"></member>
     <member><xref linkend="sql-declare"></member>
    </simplelist>
   </refsect1>
  </refentry>

  <refentry id="ecpg-sql-describe">
   <refnamediv>
    <refname>DESCRIBE</refname>
<!--
    <refpurpose>obtain information about a prepared statement or result set</refpurpose>
-->
    <refpurpose>プリペアド文または結果セットに関する情報を入手します。</refpurpose>
   </refnamediv>

   <refsynopsisdiv>
<synopsis>
DESCRIBE [ OUTPUT ] <replaceable class="PARAMETER">prepared_name</replaceable> USING [ SQL ] DESCRIPTOR <replaceable class="PARAMETER">descriptor_name</replaceable>
DESCRIBE [ OUTPUT ] <replaceable class="PARAMETER">prepared_name</replaceable> INTO [ SQL ] DESCRIPTOR <replaceable class="PARAMETER">descriptor_name</replaceable>
DESCRIBE [ OUTPUT ] <replaceable class="PARAMETER">prepared_name</replaceable> INTO <replaceable class="PARAMETER">sqlda_name</replaceable>
</synopsis>
   </refsynopsisdiv>

   <refsect1>
<!--
    <title>Description</title>
-->
    <title>説明</title>

    <para>
<!--
     <command>DESCRIBE</command> retrieves metadata information about
     the result columns contained in a prepared statement, without
     actually fetching a row.
-->
<command>DESCRIBE</command>は、実際に行を取り込むことなく、プリペアド文に含まれる結果列に関するメタデータ情報を取り出します。
    </para>
   </refsect1>

   <refsect1>
<!--
    <title>Parameters</title>
-->
    <title>パラメータ</title>

    <variablelist>
     <varlistentry>
      <term><replaceable class="PARAMETER">prepared_name</replaceable></term>
      <listitem>
       <para>
<!--
        The name of a prepared statement.  This can be an SQL
        identifier or a host variable.
-->
プリペアド文の名前です。
これはSQL識別子またはホスト変数とすることができます。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="PARAMETER">descriptor_name</replaceable></term>
      <listitem>
       <para>
<!--
        A descriptor name. It is case sensitive.  It can be an SQL
        identifier or a host variable.
-->
記述子の名前です。
大文字小文字を区別します。
これはSQL識別子またはホスト変数とすることができます。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="PARAMETER">sqlda_name</replaceable></term>
      <listitem>
       <para>
<!--
        The name of an SQLDA variable.
-->
SQLDA変数の名前です。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </refsect1>

   <refsect1>
<!--
    <title>Examples</title>
-->
    <title>例</title>

<programlisting>
EXEC SQL ALLOCATE DESCRIPTOR mydesc;
EXEC SQL PREPARE stmt1 FROM :sql_stmt;
EXEC SQL DESCRIBE stmt1 INTO SQL DESCRIPTOR mydesc;
EXEC SQL GET DESCRIPTOR mydesc VALUE 1 :charvar = NAME;
EXEC SQL DEALLOCATE DESCRIPTOR mydesc;
</programlisting>
   </refsect1>

   <refsect1>
<!--
    <title>Compatibility</title>
-->
    <title>互換性</title>

    <para>
<!--
     <command>DESCRIBE</command> is specified in the SQL standard.
-->
<command>DESCRIBE</command>は標準SQLで規定されています。
    </para>
   </refsect1>

   <refsect1>
<!--
    <title>See Also</title>
-->
    <title>関連項目</title>

    <simplelist type="inline">
     <member><xref linkend="ecpg-sql-allocate-descriptor"></member>
     <member><xref linkend="ecpg-sql-get-descriptor"></member>
    </simplelist>
   </refsect1>
  </refentry>

  <refentry id="ecpg-sql-disconnect">
   <refnamediv>
    <refname>DISCONNECT</refname>
<!--
    <refpurpose>terminate a database connection</refpurpose>
-->
    <refpurpose>データベース接続を終了します。</refpurpose>
   </refnamediv>

   <refsynopsisdiv>
<synopsis>
DISCONNECT <replaceable class="PARAMETER">connection_name</replaceable>
DISCONNECT [ CURRENT ]
DISCONNECT DEFAULT
DISCONNECT ALL
</synopsis>
   </refsynopsisdiv>

   <refsect1>
<!--
    <title>Description</title>
-->
    <title>説明</title>

    <para>
<!--
     <command>DISCONNECT</command> closes a connection (or all
     connections) to the database.
-->
<command>DISCONNECT</command>はデータベースとの接続（またはすべての接続）を閉ざします。
    </para>
   </refsect1>

   <refsect1>
<!--
    <title>Parameters</title>
-->
    <title>パラメータ</title>

    <variablelist>
     <varlistentry>
      <term><replaceable class="PARAMETER">connection_name</replaceable></term>
      <listitem>
       <para>
<!--
        A database connection name established by
        the <command>CONNECT</command> command.
-->
<command>CONNECT</command>コマンドで確立したデータベース接続の名前です。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>CURRENT</literal></term>
      <listitem>
       <para>
<!--
        Close the <quote>current</quote> connection, which is either
        the most recently opened connection, or the connection set by
        the <command>SET CONNECTION</command> command.  This is also
        the default if no argument is given to
        the <command>DISCONNECT</command> command.
-->
直前に開いた接続または<command>SET CONNECTION</command>コマンドで設定された接続のいずれかである、<quote>現在の</quote>接続を閉ざします。
これは<command>DISCONNECT</command>に引数が与えられなかった場合のデフォルトです。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>DEFAULT</literal></term>
      <listitem>
       <para>
<!--
        Close the default connection.
-->
デフォルトの接続を閉ざします。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ALL</literal></term>
      <listitem>
       <para>
<!--
        Close all open connections.
-->
開いているすべての接続を閉じます。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </refsect1>

   <refsect1>
<!--
    <title>Examples</title>
-->
    <title>例</title>

<programlisting>
int
main(void)
{
    EXEC SQL CONNECT TO testdb AS DEFAULT USER testuser;
    EXEC SQL CONNECT TO testdb AS con1 USER testuser;
    EXEC SQL CONNECT TO testdb AS con2 USER testuser;
    EXEC SQL CONNECT TO testdb AS con3 USER testuser;

<!--
    EXEC SQL DISCONNECT CURRENT;  /* close con3          */
    EXEC SQL DISCONNECT DEFAULT;  /* close DEFAULT       */
    EXEC SQL DISCONNECT ALL;      /* close con2 and con1 */
-->
    EXEC SQL DISCONNECT CURRENT;  /* con3を閉じる       */
    EXEC SQL DISCONNECT DEFAULT;  /* DEFAULTを閉じる    */
    EXEC SQL DISCONNECT ALL;      /* con2とcon1を閉じる */

    return 0;
}
</programlisting>
   </refsect1>

   <refsect1>
<!--
    <title>Compatibility</title>
-->
    <title>互換性</title>

    <para>
<!--
     <command>DISCONNECT</command> is specified in the SQL standard.
-->
<command>DISCONNECT</command>は標準SQLで規定されています。
    </para>
   </refsect1>

   <refsect1>
<!--
    <title>See Also</title>
-->
    <title>関連項目</title>

    <simplelist type="inline">
     <member><xref linkend="ecpg-sql-connect"></member>
     <member><xref linkend="ecpg-sql-set-connection"></member>
    </simplelist>
   </refsect1>
  </refentry>

  <refentry id="ecpg-sql-execute-immediate">
   <refnamediv>
    <refname>EXECUTE IMMEDIATE</refname>
<!--
    <refpurpose>dynamically prepare and execute a statement</refpurpose>
-->
    <refpurpose>SQL文を動的にプリペアし、実行します。</refpurpose>
   </refnamediv>

   <refsynopsisdiv>
<synopsis>
EXECUTE IMMEDIATE <replaceable class="PARAMETER">string</replaceable>
</synopsis>
   </refsynopsisdiv>

   <refsect1>
<!--
    <title>Description</title>
-->
    <title>説明</title>

    <para>
<!--
     <command>EXECUTE IMMEDIATE</command> immediately prepares and
     executes a dynamically specified SQL statement, without
     retrieving result rows.
-->
<command>EXECUTE IMMEDIATE</command>は動的に指定されたSQL文を、結果行を受け取ることなく、即座にプリペアし実行します。
    </para>
   </refsect1>

   <refsect1>
<!--
    <title>Parameters</title>
-->
    <title>パラメータ</title>

    <variablelist>
     <varlistentry>
      <term><replaceable class="PARAMETER">string</replaceable></term>
      <listitem>
       <para>
<!--
        A literal C string or a host variable containing the SQL
        statement to be executed.
-->
実行するSQL文を含むC文字列リテラルまたはホスト変数です。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </refsect1>

   <refsect1>
<!--
    <title>Examples</title>
-->
    <title>例</title>

    <para>
<!--
     Here is an example that executes an <command>INSERT</command>
     statement using <command>EXECUTE IMMEDIATE</command> and a host
     variable named <varname>command</varname>:
-->
以下に、<command>EXECUTE IMMEDIATE</command>と<varname>command</varname>ホスト変数を使用して<command>INSERT</command>を実行する例を示します。
<programlisting>
sprintf(command, "INSERT INTO test (name, amount, letter) VALUES ('db: ''r1''', 1, 'f')");
EXEC SQL EXECUTE IMMEDIATE :command;
</programlisting>
    </para>
   </refsect1>

   <refsect1>
<!--
    <title>Compatibility</title>
-->
    <title>互換性</title>

    <para>
<!--
     <command>EXECUTE IMMEDIATE</command> is specified in the SQL standard.
-->
<command>EXECUTE IMMEDIATE</command>は標準SQLで規定されています。
    </para>
   </refsect1>
  </refentry>

  <refentry id="ecpg-sql-get-descriptor">
   <refnamediv>
    <refname>GET DESCRIPTOR</refname>
<!--
    <refpurpose>get information from an SQL descriptor area</refpurpose>
-->
    <refpurpose>SQL記述子領域から情報を入手します。</refpurpose>
   </refnamediv>

   <refsynopsisdiv>
<synopsis>
GET DESCRIPTOR <replaceable class="PARAMETER">descriptor_name</replaceable> <replaceable class="PARAMETER">:cvariable</replaceable> = <replaceable class="PARAMETER">descriptor_header_item</replaceable> [, ... ]
GET DESCRIPTOR <replaceable class="PARAMETER">descriptor_name</replaceable> VALUE <replaceable class="PARAMETER">column_number</replaceable> <replaceable class="PARAMETER">:cvariable</replaceable> = <replaceable class="PARAMETER">descriptor_item</replaceable> [, ... ]
</synopsis>
   </refsynopsisdiv>

   <refsect1>
<!--
    <title>Description</title>
-->
    <title>説明</title>

    <para>
<!--
     <command>GET DESCRIPTOR</command> retrieves information about a
     query result set from an SQL descriptor area and stores it into
     host variables.  A descriptor area is typically populated
     using <command>FETCH</command> or <command>SELECT</command>
     before using this command to transfer the information into host
     language variables.
-->
<command>GET DESCRIPTOR</command>はSQL記述子領域から問い合わせ結果セットに関する情報を取り出し、それをホスト変数に格納します。
記述子領域は通常、このコマンドを使用してホスト言語変数に情報を転送する前に、<command>FETCH</command>または<command>SELECT</command>を用いて値が投入されます。
    </para>

    <para>
<!--
     This command has two forms: The first form retrieves
     descriptor <quote>header</quote> items, which apply to the result
     set in its entirety.  One example is the row count.  The second
     form, which requires the column number as additional parameter,
     retrieves information about a particular column.  Examples are
     the column name and the actual column value.
-->
このコマンドには２つの構文があります。
１番目の構文では、そのまま結果セットに適用されている記述子の<quote>ヘッダ</quote>項目を取り出します。
行数が１つの例です。
列番号を追加のパラメータとして必要とする２番目の構文では特定の列に関する情報を取り出します。
例えば、列名と列の実際の値です。
    </para>
   </refsect1>

   <refsect1>
<!--
    <title>Parameters</title>
-->
    <title>パラメータ</title>

    <variablelist>
     <varlistentry>
      <term><replaceable class="PARAMETER">descriptor_name</replaceable></term>
      <listitem>
       <para>
<!--
        A descriptor name.
-->
記述子の名前です。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="PARAMETER">descriptor_header_item</replaceable></term>
      <listitem>
       <para>
<!--
        A token identifying which header information item to retrieve.
        Only <literal>COUNT</literal>, to get the number of columns in the
        result set, is currently supported.
-->
どのヘッダ情報を取り出すかを識別するトークンです。
結果セット内の列数を入手する<literal>COUNT</literal>のみが現在サポートされています。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="PARAMETER">column_number</replaceable></term>
      <listitem>
       <para>
<!--
        The number of the column about which information is to be
        retrieved.  The count starts at 1.
-->
情報を取り出す列の番号です。
１から数えます。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="PARAMETER">descriptor_item</replaceable></term>
      <listitem>
       <para>
<!--
        A token identifying which item of information about a column
        to retrieve.  See <xref linkend="ecpg-named-descriptors"> for
        a list of supported items.
-->
どの列に関する情報を取り出すかを識別するトークンです。
サポートされる項目のリストについては<xref linkend="ecpg-named-descriptors">を参照してください。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="PARAMETER">cvariable</replaceable></term>
      <listitem>
       <para>
<!--
        A host variable that will receive the data retrieved from the
        descriptor area.
-->
記述子領域から取り出したデータを受け取るホスト変数です。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </refsect1>

   <refsect1>
<!--
    <title>Examples</title>
-->
    <title>例</title>

    <para>
<!--
     An example to retrieve the number of columns in a result set:
-->
この例は結果セット内の列数を取り出します。
<programlisting>
EXEC SQL GET DESCRIPTOR d :d_count = COUNT;
</programlisting>
    </para>

    <para>
<!--
     An example to retrieve a data length in the first column:
-->
この例は最初の列のデータ長を取り出します。
<programlisting>
EXEC SQL GET DESCRIPTOR d VALUE 1 :d_returned_octet_length = RETURNED_OCTET_LENGTH;
</programlisting>
    </para>

    <para>
<!--
     An example to retrieve the data body of the second column as a
     string:
-->
この例は、２番目の列のデータ本体を文字列として取り出します。
<programlisting>
EXEC SQL GET DESCRIPTOR d VALUE 2 :d_data = DATA;
</programlisting>
    </para>

    <para>
<!--
     Here is an example for a whole procedure of
     executing <literal>SELECT current_database();</> and showing the number of
     columns, the column data length, and the column data:
-->
以下は、<literal>SELECT current_database();</>を実行し、列数、列のデータ長、列のデータを表示する手続き全体を示す例です。
<programlisting>
int
main(void)
{
EXEC SQL BEGIN DECLARE SECTION;
    int  d_count;
    char d_data[1024];
    int  d_returned_octet_length;
EXEC SQL END DECLARE SECTION;

    EXEC SQL CONNECT TO testdb AS con1 USER testuser;
    EXEC SQL ALLOCATE DESCRIPTOR d;

<!--
    /* Declare, open a cursor, and assign a descriptor to the cursor  */
-->
    /* カーソルを宣言して開いて、記述子をそのカーソルに割り当てる */
    EXEC SQL DECLARE cur CURSOR FOR SELECT current_database();
    EXEC SQL OPEN cur;
    EXEC SQL FETCH NEXT FROM cur INTO SQL DESCRIPTOR d;

<!--
    /* Get a number of total columns */
-->
    /* 全列数を得る */
    EXEC SQL GET DESCRIPTOR d :d_count = COUNT;
    printf("d_count                 = %d\n", d_count);

<!--
    /* Get length of a returned column */
--> 
    /* 返された列の長さを得る */
    EXEC SQL GET DESCRIPTOR d VALUE 1 :d_returned_octet_length = RETURNED_OCTET_LENGTH;
    printf("d_returned_octet_length = %d\n", d_returned_octet_length);

<!--
    /* Fetch the returned column as a string */
--> 
    /* 返された列を文字列として取得する */
    EXEC SQL GET DESCRIPTOR d VALUE 1 :d_data = DATA;
    printf("d_data                  = %s\n", d_data);

<!--
    /* Closing */
--> 
    /* 閉じる */
    EXEC SQL CLOSE cur;
    EXEC SQL COMMIT;

    EXEC SQL DEALLOCATE DESCRIPTOR d;
    EXEC SQL DISCONNECT ALL;

    return 0;
}
</programlisting>
<!--
     When the example is executed, the result will look like this:
-->
この例を実行すると、結果は以下のようになります。
<screen>
d_count                 = 1
d_returned_octet_length = 6
d_data                  = testdb
</screen>
    </para>
   </refsect1>

   <refsect1>
<!--
    <title>Compatibility</title>
-->
    <title>互換性</title>

    <para>
<!--
     <command>GET DESCRIPTOR</command> is specified in the SQL standard.
-->
<command>GET DESCRIPTOR</command>は標準SQLで規定されています。
    </para>
   </refsect1>

   <refsect1>
<!--
    <title>See Also</title>
-->
    <title>関連項目</title>

    <simplelist type="inline">
     <member><xref linkend="ecpg-sql-allocate-descriptor"></member>
     <member><xref linkend="ecpg-sql-set-descriptor"></member>
    </simplelist>
   </refsect1>
  </refentry>

  <refentry id="ecpg-sql-open">
   <refnamediv>
    <refname>OPEN</refname>
<!--
    <refpurpose>open a dynamic cursor</refpurpose>
-->
    <refpurpose>動的カーソルを開きます。</refpurpose>
   </refnamediv>

   <refsynopsisdiv>
<synopsis>
OPEN <replaceable class="PARAMETER">cursor_name</replaceable>
OPEN <replaceable class="PARAMETER">cursor_name</replaceable> USING <replaceable class="PARAMETER">value</replaceable> [, ... ]
OPEN <replaceable class="PARAMETER">cursor_name</replaceable> USING SQL DESCRIPTOR <replaceable class="PARAMETER">descriptor_name</replaceable>
</synopsis>
   </refsynopsisdiv>

   <refsect1>
<!--
    <title>Description</title>
-->
    <title>説明</title>

    <para>
<!--
     <command>OPEN</command> opens a cursor and optionally binds
     actual values to the placeholders in the cursor's declaration.
     The cursor must previously have been declared with
     the <command>DECLARE</command> command.  The execution
     of <command>OPEN</command> causes the query to start executing on
     the server.
-->
<command>OPEN</command>はカーソルを開き、省略することができますが、実際の値をカーソル定義内のプレースホルダにバインドします。
カーソルは事前に<command>DECLARE</command>コマンドを用いて宣言されていなければなりません。
<command>OPEN</command>の実行により問い合わせがサーバ上で実行を開始されます。
    </para>
   </refsect1>

   <refsect1>
<!--
    <title>Parameters</title>
-->
    <title>パラメータ</title>

    <variablelist>
     <varlistentry>
      <term><replaceable class="PARAMETER">cursor_name</replaceable></term>
      <listitem>
       <para>
<!--
        The name of the cursor to be opened.  This can be an SQL
        identifier or a host variable.
-->
開くカーソルの名前です。
これはSQL識別子またはホスト変数とすることができます。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="PARAMETER">value</replaceable></term>
      <listitem>
       <para>
<!--
        A value to be bound to a placeholder in the cursor.  This can
        be an SQL constant, a host variable, or a host variable with
        indicator.
-->
カーソル内のプレースホルダにバインドされる値です。
これは、SQL定数、ホスト変数、指示子を持つホスト変数とすることができます。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="PARAMETER">descriptor_name</replaceable></term>
      <listitem>
       <para>
<!--
        The name of a descriptor containing values to be bound to the
        placeholders in the cursor.  This can be an SQL identifier or
        a host variable.
-->
カーソル内のプレースホルダにバインドされる値を含む記述子の名前です。
これはSQL識別子またはホスト変数とすることができます。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </refsect1>

   <refsect1>
<!--
    <title>Examples</title>
-->
    <title>例</title>

<programlisting>
EXEC SQL OPEN a;
EXEC SQL OPEN d USING 1, 'test';
EXEC SQL OPEN c1 USING SQL DESCRIPTOR mydesc;
EXEC SQL OPEN :curname1;
</programlisting>
   </refsect1>

   <refsect1>
<!--
    <title>Compatibility</title>
-->
    <title>互換性</title>

    <para>
<!--
     <command>OPEN</command> is specified in the SQL standard.
-->
<command>OPEN</command>は標準SQLで規定されています。
    </para>
   </refsect1>

   <refsect1>
<!--
    <title>See Also</title>
-->
    <title>関連項目</title>

    <simplelist type="inline">
     <member><xref linkend="ecpg-sql-declare"></member>
     <member><xref linkend="sql-close"></member>
    </simplelist>
   </refsect1>
  </refentry>

  <refentry id="ecpg-sql-prepare">
   <refnamediv>
    <refname>PREPARE</refname>
<!--
    <refpurpose>prepare a statement for execution</refpurpose>
-->
    <refpurpose>実行のためにSQL文をプリペアします。</refpurpose>
   </refnamediv>

   <refsynopsisdiv>
<synopsis>
PREPARE <replaceable class="PARAMETER">name</replaceable> FROM <replaceable class="PARAMETER">string</replaceable>
</synopsis>
   </refsynopsisdiv>

   <refsect1>
<!--
    <title>Description</title>
-->
    <title>説明</title>

    <para>
<!--
     <command>PREPARE</command> prepares a statement dynamically
     specified as a string for execution.  This is different from the
     direct SQL statement <xref linkend="sql-prepare">, which can also
     be used in embedded programs.  The <xref linkend="sql-execute">
     command is used to execute either kind of prepared statement.
-->
<command>PREPARE</command>は実行用に文字列として動的に指定されたSQL文をプリペアします。
これは、埋め込みプログラム内でも使用することができる、直接的な<xref linkend="sql-prepare"> SQL文とは異なります。
<xref linkend="sql-execute">コマンドを使用して、どちらの種類のプリペアド文を実行することができます。
    </para>
   </refsect1>

   <refsect1>
<!--
    <title>Parameters</title>
-->
    <title>パラメータ</title>

    <variablelist>
     <varlistentry>
      <term><replaceable class="PARAMETER">prepared_name</replaceable></term>
      <listitem>
       <para>
<!--
        An identifier for the prepared query.
-->
プリペアド問い合わせ用の識別子です。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="PARAMETER">string</replaceable></term>
      <listitem>
       <para>
<!--
        A literal C string or a host variable containing a preparable
        statement, one of the SELECT, INSERT, UPDATE, or
        DELETE.
-->
Cリテラル文字列、または、プリペア可能な文であるSELECT/INSERT/UPDATE/DELETEの1つを含むホスト変数、のいずれかです。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </refsect1>

   <refsect1>
<!--
    <title>Examples</title>
-->
    <title>例</title>
<programlisting>
char *stmt = "SELECT * FROM test1 WHERE a = ? AND b = ?";

EXEC SQL ALLOCATE DESCRIPTOR outdesc;
EXEC SQL PREPARE foo FROM :stmt;

EXEC SQL EXECUTE foo USING SQL DESCRIPTOR indesc INTO SQL DESCRIPTOR outdesc;
</programlisting>
   </refsect1>

   <refsect1>
<!--
    <title>Compatibility</title>
-->
    <title>互換性</title>

    <para>
<!--
     <command>PREPARE</command> is specified in the SQL standard.
-->
<command>PREPARE</command>は標準SQLで規定されています。
    </para>
   </refsect1>

   <refsect1>
<!--
    <title>See Also</title>
-->
    <title>関連項目</title>

    <simplelist type="inline">
     <member><xref linkend="sql-execute"></member>
    </simplelist>
   </refsect1>
  </refentry>

  <refentry id="ecpg-sql-set-autocommit">
   <refnamediv>
    <refname>SET AUTOCOMMIT</refname>
<!--
    <refpurpose>set the autocommit behavior of the current session</refpurpose>
-->
    <refpurpose>現在のセッションの自動コミット動作を設定します。</refpurpose>
   </refnamediv>

   <refsynopsisdiv>
<synopsis>
SET AUTOCOMMIT { = | TO } { ON | OFF }
</synopsis>
   </refsynopsisdiv>

   <refsect1>
<!--
    <title>Description</title>
-->
    <title>説明</title>

    <para>
<!--
     <command>SET AUTOCOMMIT</command> sets the autocommit behavior of
     the current database session.  By default, embedded SQL programs
     are <emphasis>not</emphasis> in autocommit mode,
     so <command>COMMIT</command> needs to be issued explicitly when
     desired.  This command can change the session to autocommit mode,
     where each individual statement is committed implicitly.
-->
<command>SET AUTOCOMMIT</command>は現在のデータベースセッションの自動コミット動作を設定します。
デフォルトでは埋め込みSQLプログラムは自動コミットモードでは<emphasis>ありません</emphasis>。
このため<command>COMMIT</command>コマンドを必要なところで明示的に発行しなければなりません。
このコマンドはセッションを、個々のSQL文それぞれが暗黙的にコミットされる、自動コミットモードに変更することができます。
    </para>
   </refsect1>

   <refsect1>
<!--
    <title>Compatibility</title>
-->
    <title>互換性</title>

    <para>
<!--
     <command>SET AUTOCOMMIT</command> is an extension of PostgreSQL ECPG.
-->
<command>SET AUTOCOMMIT</command>はPostgreSQL ECPGの拡張です。
    </para>
   </refsect1>
  </refentry>

  <refentry id="ecpg-sql-set-connection">
   <refnamediv>
    <refname>SET CONNECTION</refname>
<!--
    <refpurpose>select a database connection</refpurpose>
-->
    <refpurpose>データベース接続を選択します。</refpurpose>
   </refnamediv>

   <refsynopsisdiv>
<synopsis>
SET CONNECTION [ TO | = ] <replaceable class="PARAMETER">connection_name</replaceable>
</synopsis>
   </refsynopsisdiv>

   <refsect1>
<!--
    <title>Description</title>
-->
    <title>説明</title>

    <para>
<!--
     <command>SET CONNECTION</command> sets the <quote>current</quote>
     database connection, which is the one that all commands use
     unless overridden.
-->
<command>SET CONNECTION</command>は、上書きされない限りすべてのコマンドが使用する、<quote>現在の</quote>データベース接続を設定します。
    </para>
   </refsect1>

   <refsect1>
<!--
    <title>Parameters</title>
-->
    <title>パラメータ</title>

    <variablelist>
     <varlistentry>
      <term><replaceable class="PARAMETER">connection_name</replaceable></term>
      <listitem>
       <para>
<!--
        A database connection name established by
        the <command>CONNECT</command> command.
-->
<command>CONNECT</command>コマンドで確立したデータベース接続の名前です。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>DEFAULT</literal></term>
      <listitem>
       <para>
<!--
        Set the connection to the default connection.
-->
接続をデフォルトの接続に設定します。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </refsect1>

   <refsect1>
<!--
    <title>Examples</title>
-->
    <title>例</title>

<programlisting>
EXEC SQL SET CONNECTION TO con2;
EXEC SQL SET CONNECTION = con1;
</programlisting>
   </refsect1>

   <refsect1>
<!--
    <title>Compatibility</title>
-->
    <title>互換性</title>

    <para>
<!--
     <command>SET CONNECTION</command> is specified in the SQL standard.
-->
<command>SET CONNECTION</command>は標準SQLで規定されています。
    </para>
   </refsect1>

   <refsect1>
<!--
    <title>See Also</title>
-->
    <title>関連項目</title>

    <simplelist type="inline">
     <member><xref linkend="ecpg-sql-connect"></member>
     <member><xref linkend="ecpg-sql-disconnect"></member>
    </simplelist>
   </refsect1>
  </refentry>

  <refentry id="ecpg-sql-set-descriptor">
   <refnamediv>
    <refname>SET DESCRIPTOR</refname>
<!--
    <refpurpose>set information in an SQL descriptor area</refpurpose>
-->
    <refpurpose>SQL記述子領域に情報を設定します。</refpurpose>
   </refnamediv>

   <refsynopsisdiv>
<synopsis>
SET DESCRIPTOR <replaceable class="PARAMETER">descriptor_name</replaceable> <replaceable class="PARAMETER">descriptor_header_item</replaceable> = <replaceable>value</replaceable> [, ... ]
SET DESCRIPTOR <replaceable class="PARAMETER">descriptor_name</replaceable> VALUE <replaceable class="PARAMETER">number</replaceable> <replaceable class="PARAMETER">descriptor_item</replaceable> = <replaceable>value</replaceable> [, ...]
</synopsis>
   </refsynopsisdiv>

   <refsect1>
<!--
    <title>Description</title>
-->
    <title>説明</title>

    <para>
<!--
     <command>SET DESCRIPTOR</command> populates an SQL descriptor
     area with values.  The descriptor area is then typically used to
     bind parameters in a prepared query execution.
-->
<command>SET DESCRIPTOR</command>はSQL記述子領域に値を投入します。
その後、通常、記述子領域はプリペアド問い合わせ実行においてパラメータをバインドするために使用されます。
    </para>

    <para>
<!--
     This command has two forms: The first form applies to the
     descriptor <quote>header</quote>, which is independent of a
     particular datum.  The second form assigns values to particular
     datums, identified by number.
-->
このコマンドは２つの構文があります。
最初の構文は、特定のデータと独立した、記述子の<quote>ヘッダ</quote>に適用します。
２番目の構文は、番号で識別される特定のデータに値を割り当てます。
    </para>
   </refsect1>

   <refsect1>
<!--
    <title>Parameters</title>
-->
    <title>パラメータ</title>

    <variablelist>
     <varlistentry>
      <term><replaceable class="PARAMETER">descriptor_name</replaceable></term>
      <listitem>
       <para>
<!--
        A descriptor name.
-->
記述子の名前です。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="PARAMETER">descriptor_header_item</replaceable></term>
      <listitem>
       <para>
<!--
        A token identifying which header information item to set.
        Only <literal>COUNT</literal>, to set the number of descriptor
        items, is currently supported.
-->
設定するヘッダ情報項目を識別するトークンです。
記述子項目数を設定する<literal>COUNT</literal>のみが現在サポートされています。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="PARAMETER">number</replaceable></term>
      <listitem>
       <para>
<!--
        The number of the descriptor item to set.  The count starts at
        1.
-->
設定する記述子項目の番号です。
番号は１から数えます。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="PARAMETER">descriptor_item</replaceable></term>
      <listitem>
       <para>
<!--
        A token identifying which item of information to set in the
        descriptor.  See <xref linkend="ecpg-named-descriptors"> for a
        list of supported items.
-->
記述子内のどの項目の情報を設定するかを識別するトークンです。
サポートされる項目のリストについては<xref linkend="ecpg-named-descriptors">を参照してください。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="PARAMETER">value</replaceable></term>
      <listitem>
       <para>
<!--
        A value to store into the descriptor item.  This can be an SQL
        constant or a host variable.
-->
記述子項目に格納する値です。
これはSQL定数またはホスト変数とすることができます。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </refsect1>

   <refsect1>
<!--
    <title>Examples</title>
-->
    <title>例</title>
<programlisting>
EXEC SQL SET DESCRIPTOR indesc COUNT = 1;
EXEC SQL SET DESCRIPTOR indesc VALUE 1 DATA = 2;
EXEC SQL SET DESCRIPTOR indesc VALUE 1 DATA = :val1;
EXEC SQL SET DESCRIPTOR indesc VALUE 2 INDICATOR = :val1, DATA = 'some string';
EXEC SQL SET DESCRIPTOR indesc VALUE 2 INDICATOR = :val2null, DATA = :val2;
</programlisting>
   </refsect1>

   <refsect1>
<!--
    <title>Compatibility</title>
-->
    <title>互換性</title>

    <para>
<!--
     <command>SET DESCRIPTOR</command> is specified in the SQL standard.
-->
<command>SET DESCRIPTOR</command>は標準SQLで規定されています。
    </para>
   </refsect1>

   <refsect1>
<!--
    <title>See Also</title>
-->
    <title>関連項目</title>

    <simplelist type="inline">
     <member><xref linkend="ecpg-sql-allocate-descriptor"></member>
     <member><xref linkend="ecpg-sql-get-descriptor"></member>
    </simplelist>
   </refsect1>
  </refentry>

  <refentry id="ecpg-sql-type">
   <refnamediv>
    <refname>TYPE</refname>
<!--
    <refpurpose>define a new data type</refpurpose>
-->
    <refpurpose>新しいデータ型を定義します。</refpurpose>
   </refnamediv>

   <refsynopsisdiv>
<synopsis>
TYPE <replaceable class="PARAMETER">type_name</replaceable> IS <replaceable class="PARAMETER">ctype</replaceable>
</synopsis>
   </refsynopsisdiv>

   <refsect1>
<!--
    <title>Description</title>
-->
    <title>説明</title>

    <para>
<!--
     The <command>TYPE</command> command defines a new C type.  It is
     equivalent to putting a <literal>typedef</literal> into a declare
     section.
-->
<command>TYPE</command>コマンドは新しいCの型を定義します。
これは宣言セクションに<literal>typedef</literal>を記述することと同じです。
    </para>

    <para>
<!--
     This command is only recognized when <command>ecpg</command> is
     run with the <option>-c</option> option.
-->
<command>ecpg</command>が<option>-c</option>オプション付きで実行された場合にのみこのコマンドは認識されます。
    </para>
   </refsect1>

   <refsect1>
<!--
    <title>Parameters</title>
-->
    <title>パラメータ</title>

    <variablelist>
     <varlistentry>
      <term><replaceable class="PARAMETER">type_name</replaceable></term>
      <listitem>
       <para>
<!--
        The name for the new type.  It must be a valid C type name.
-->
新しい型の名前です。
これは有効なCの型名でなければなりません。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="PARAMETER">ctype</replaceable></term>
      <listitem>
       <para>
<!--
        A C type specification.
-->
Cの型指定です。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </refsect1>

   <refsect1>
<!--
    <title>Examples</title>
-->
    <title>例</title>

<programlisting>
EXEC SQL TYPE customer IS
    struct
    {
        varchar name[50];
        int     phone;
    };

EXEC SQL TYPE cust_ind IS
    struct ind
    {
        short   name_ind;
        short   phone_ind;
    };

EXEC SQL TYPE c IS char reference;
EXEC SQL TYPE ind IS union { int integer; short smallint; };
EXEC SQL TYPE intarray IS int[AMOUNT];
EXEC SQL TYPE str IS varchar[BUFFERSIZ];
EXEC SQL TYPE string IS char[11];
</programlisting>

    <para>
<!--
     Here is an example program that uses <command>EXEC SQL
     TYPE</command>:
-->
以下に<command>EXEC SQL TYPE</command>を使用するプログラム例を示します。
<programlisting>
EXEC SQL WHENEVER SQLERROR SQLPRINT;

EXEC SQL TYPE tt IS
    struct
    {
        varchar v[256];
        int     i;
    };

EXEC SQL TYPE tt_ind IS
    struct ind {
        short   v_ind;
        short   i_ind;
    };

int
main(void)
{
EXEC SQL BEGIN DECLARE SECTION;
    tt t;
    tt_ind t_ind;
EXEC SQL END DECLARE SECTION;

    EXEC SQL CONNECT TO testdb AS con1;

    EXEC SQL SELECT current_database(), 256 INTO :t:t_ind LIMIT 1;

    printf("t.v = %s\n", t.v.arr);
    printf("t.i = %d\n", t.i);

    printf("t_ind.v_ind = %d\n", t_ind.v_ind);
    printf("t_ind.i_ind = %d\n", t_ind.i_ind);

    EXEC SQL DISCONNECT con1;

    return 0;
}
</programlisting>

<!--
     The output from this program looks like this:
-->
このプログラムの出力は以下のようになります。
<screen>
t.v = testdb
t.i = 256
t_ind.v_ind = 0
t_ind.i_ind = 0
</screen>
    </para>
   </refsect1>

   <refsect1>
<!--
    <title>Compatibility</title>
-->
    <title>互換性</title>

    <para>
<!--
     The <command>TYPE</command> command is a PostgreSQL extension.
-->
<command>TYPE</command>コマンドはPostgreSQLの拡張です。
    </para>
   </refsect1>
  </refentry>

  <refentry id="ecpg-sql-var">
   <refnamediv>
    <refname>VAR</refname>
<!--
    <refpurpose>define a variable</refpurpose>
-->
    <refpurpose>変数を定義します。</refpurpose>
   </refnamediv>

   <refsynopsisdiv>
<synopsis>
VAR <replaceable>varname</replaceable> IS <replaceable>ctype</replaceable>
</synopsis>
   </refsynopsisdiv>

   <refsect1>
<!--
    <title>Description</title>
-->
    <title>説明</title>

    <para>
<!--
     The <command>VAR</command> command assigns a new C data type
     to a host variable.  The host variable must be previously
     declared in a declare section.
-->
<command>VAR</command>コマンドは新しいCデータ型にホスト変数を割り当てます。
ホスト変数は宣言セクションで前もって宣言されていなければなりません。
    </para>
   </refsect1>

   <refsect1>
<!--
    <title>Parameters</title>
-->
    <title>パラメータ</title>

    <variablelist>
     <varlistentry>
      <term><replaceable class="PARAMETER">varname</replaceable></term>
      <listitem>
       <para>
<!--
        A C variable name.
-->
Cの変数名です。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="PARAMETER">ctype</replaceable></term>
      <listitem>
       <para>
<!--
        A C type specification.
-->
Cの型指定です。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </refsect1>

   <refsect1>
<!--
    <title>Examples</title>
-->
    <title>例</title>

<programlisting>
Exec sql begin declare section;
short a;
exec sql end declare section;
EXEC SQL VAR a IS int;
</programlisting>
   </refsect1>

   <refsect1>
<!--
    <title>Compatibility</title>
-->
    <title>互換性</title>

    <para>
<!--
     The <command>VAR</command> command is a PostgreSQL extension.
-->
<command>VAR</command>コマンドはPostgreSQLの拡張です。
    </para>
   </refsect1>
  </refentry>

  <refentry id="ecpg-sql-whenever">
   <refnamediv>
    <refname>WHENEVER</refname>
<!--
    <refpurpose>specify the action to be taken when an SQL statement causes a specific class condition to be raised</refpurpose>
-->
    <refpurpose>SQL文により特定の分類の条件が発生する時に行う動作を指定します。</refpurpose>
   </refnamediv>

   <refsynopsisdiv>
<synopsis>
WHENEVER { NOT FOUND | SQLERROR | SQLWARNING } <replaceable class="PARAMETER">action</replaceable>
</synopsis>
   </refsynopsisdiv>

   <refsect1>
<!--
    <title>Description</title>
-->
    <title>説明</title>

    <para>
<!--
     Define a behavior which is called on the special cases (Rows not
     found, SQL warnings or errors) in the result of SQL execution.
-->
SQL実行の結果において特殊な状態（行がない、SQL警告またはSQLエラー）で呼び出される動作を定義します。
    </para>
   </refsect1>

   <refsect1>
<!--
    <title>Parameters</title>
-->
    <title>パラメータ</title>

    <para>
<!--
     See <xref linkend="ecpg-whenever"> for a description of the
     parameters.
-->
パラメータの説明については<xref linkend="ecpg-whenever">を参照してください。
    </para>
   </refsect1>

   <refsect1>
<!--
    <title>Examples</title>
-->
    <title>例</title>

<programlisting>
EXEC SQL WHENEVER NOT FOUND CONTINUE;
EXEC SQL WHENEVER NOT FOUND DO BREAK;
EXEC SQL WHENEVER SQLWARNING SQLPRINT;
EXEC SQL WHENEVER SQLWARNING DO warn();
EXEC SQL WHENEVER SQLERROR sqlprint;
EXEC SQL WHENEVER SQLERROR CALL print2();
EXEC SQL WHENEVER SQLERROR DO handle_error("select");
EXEC SQL WHENEVER SQLERROR DO sqlnotice(NULL, NONO);
EXEC SQL WHENEVER SQLERROR DO sqlprint();
EXEC SQL WHENEVER SQLERROR GOTO error_label;
EXEC SQL WHENEVER SQLERROR STOP;
</programlisting>

    <para>
<!--
     A typical application is the use of <literal>WHENEVER NOT FOUND
     BREAK</literal> to handle looping through result sets:
-->
以下は、結果セットを通したループ処理を扱うために<literal>WHENEVER NOT FOUND BREAK</literal>を使用する典型的なアプリケーションです。
<programlisting>
int
main(void)
{
    EXEC SQL CONNECT TO testdb AS con1;
    EXEC SQL ALLOCATE DESCRIPTOR d;
    EXEC SQL DECLARE cur CURSOR FOR SELECT current_database(), 'hoge', 256;
    EXEC SQL OPEN cur;

<!--
    /* when end of result set reached, break out of while loop */
-->
    /* 結果集合の最後に到達したら、whileループから抜ける */
    EXEC SQL WHENEVER NOT FOUND DO BREAK;

    while (1)
    {
        EXEC SQL FETCH NEXT FROM cur INTO SQL DESCRIPTOR d;
        ...
    }

    EXEC SQL CLOSE cur;
    EXEC SQL COMMIT;

    EXEC SQL DEALLOCATE DESCRIPTOR d;
    EXEC SQL DISCONNECT ALL;

    return 0;
}
</programlisting>
    </para>
   </refsect1>

   <refsect1>
<!--
    <title>Compatibility</title>
-->
    <title>互換性</title>

    <para>
<!--
     <command>WHENEVER</command> is specified in the SQL standard, but
     most of the actions are PostgreSQL extensions.
-->
<command>WHENEVER</command>は標準SQLで規定されていますが、ほとんどの動作はPostgreSQLの拡張です。
    </para>
   </refsect1>
  </refentry>
 </sect1>

 <sect1 id="ecpg-informix-compat">
<!--
  <title><productname>Informix</productname> Compatibility Mode</title>
-->
  <title><productname>Informix</productname>互換モード</title>
  <para>
<!--
   <command>ecpg</command> can be run in a so-called <firstterm>Informix compatibility mode</>. If
   this mode is active, it tries to behave as if it were the <productname>Informix</productname>
   precompiler for <productname>Informix</productname> E/SQL. Generally spoken this will allow you to use
   the dollar sign instead of the <literal>EXEC SQL</> primitive to introduce
   embedded SQL commands:
-->
<command>ecpg</command>を<firstterm>Informix互換モード</>というモードで動作させることができます。
このモードが有効ならば、<productname>Informix</productname> E/SQL用の<productname>Informix</productname>プリプロセッサであるかのように動作します。
一般的にいうと、これにより埋め込みSQLコマンドを導入する際に<literal>EXEC SQL</>プリミティブの代わりにドル記号を使用することができます。
<programlisting>
$int j = 3;
$CONNECT TO :dbname;
$CREATE TABLE test(i INT PRIMARY KEY, j INT);
$INSERT INTO test(i, j) VALUES (7, :j);
$COMMIT;
</programlisting>
  </para>

  <note>
   <para>
<!--
    There must not be any white space between the <literal>$</literal>
    and a following preprocessor directive, that is,
    <literal>include</literal>, <literal>define</literal>, <literal>ifdef</literal>,
    etc.  Otherwise, the preprocessor will parse the token as a host
    variable.
-->
<literal>$</literal>とその後に続く<literal>include</literal>、<literal>define</literal>、<literal>ifdef</literal>などのプリプロセッサ指示子の間に空白文字を含めてはなりません。
こうしないと、プリプロセッサはトークンをホスト変数として解析します。
   </para>
  </note>

  <para>
<!--
   There are two compatibility modes: <literal>INFORMIX</>, <literal>INFORMIX_SE</>
-->
<literal>INFORMIX</>、<literal>INFORMIX_SE</>という2つの互換モードがあります。
  </para>
  <para>
<!--
   When linking programs that use this compatibility mode, remember to link
   against <literal>libcompat</> that is shipped with ECPG.
-->
互換モードを使用するプログラムをリンクする際、ECPGに同梱される<literal>libcompat</>とリンクすることを忘れないでください。
  </para>
  <para>
<!--
   Besides the previously explained syntactic sugar, the <productname>Informix</productname> compatibility
   mode ports some functions for input, output and transformation of data as
   well as embedded SQL statements known from E/SQL to ECPG.
-->
以前に説明した構文上の飾りの他に、<productname>Informix</productname>互換モードでは、入力、出力、データ変換関数、E/SQLからECPGで既知の埋め込みSQL文変換に関する関数もいくつか移植しています。
  </para>
  <para>
<!--
   <productname>Informix</productname> compatibility mode is closely connected to the pgtypeslib library
   of ECPG. pgtypeslib maps SQL data types to data types within the C host
   program and most of the additional functions of the <productname>Informix</productname> compatibility
   mode allow you to operate on those C host program types. Note however that
   the extent of the compatibility is limited. It does not try to copy <productname>Informix</productname>
   behavior; it allows you to do more or less the same operations and gives
   you functions that have the same name and the same basic behavior but it is
   no drop-in replacement if you are using <productname>Informix</productname> at the moment. Moreover,
   some of the data types are different. For example,
   <productname>PostgreSQL's</productname> datetime and interval types do not
   know about ranges like for example <literal>YEAR TO MINUTE</> so you won't
   find support in ECPG for that either.
-->
<productname>Informix</productname>互換モードはECPGのpgtypeslibライブラリと密接に関係しています。
pgtypeslibはSQLデータ型とCホストプログラム内のデータ型を対応付けし、ほとんどの<productname>Informix</productname>互換モードで追加された関数を使用してこれらのCホストプログラム型を操作することができます。
しかし、互換範囲は制限されています。
これは<productname>Informix</productname>の動作を真似ることはしません。
これを使用して、多少は同じ名前で同じ基本動作を行う関数を操作、提供できますが、<productname>Informix</productname>を使用しているのであれば、完全な置き換えにはなりません。
さらに一部のデータ型は異なります。
例えば、<productname>PostgreSQL</productname>の日付時刻やinterval型では<literal>YEAR TO MINUTE</>のような範囲を持ちませんので、これらはECPGではサポートできないことがわかります。
  </para>

  <sect2 id="ecpg-informix-types">
<!--
   <title>Additional Types</title>
-->
   <title>追加の型</title>
   <para>
<!--
    The Informix-special "string" pseudo-type for storing right-trimmed character string data is now
    supported in Informix-mode without using <literal>typedef</literal>. In fact, in Informix-mode,
    ECPG refuses to process source files that contain <literal>typedef sometype string;</literal>
-->
右側を切り詰めた文字列データを格納するInformixの特別な"string"仮想型は<literal>typedef</literal>を使用せずともInformixモードでサポートされるようになりました。
実際Informixモードでは、ECPGは<literal>typedef sometype string;</literal>を含むソースファイルの処理を拒絶します。
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
<!--
string userid; /* this variable will contain trimmed data */
-->
string userid; /* この変数は切り詰められたデータを含むことになる */
EXEC SQL END DECLARE SECTION;

EXEC SQL FETCH MYCUR INTO :userid;
</programlisting>
   </para>
  </sect2>

  <sect2 id="ecpg-informix-statements">
<!--
   <title>Additional/Missing Embedded SQL Statements</title>
-->
   <title>追加または存在しない埋め込みSQL文</title>
   <para>
    <variablelist>
     <varlistentry>
      <term><literal>CLOSE DATABASE</></term>
      <listitem>
       <para>
<!--
        This statement closes the current connection. In fact, this is a
        synonym for ECPG's <literal>DISCONNECT CURRENT</>:
-->
このSQL文は現在の接続を閉じます。
実際、これはECPGの<literal>DISCONNECT CURRENT</>と同義です。
<programlisting>
<!--
$CLOSE DATABASE;                /* close the current connection */
-->
$CLOSE DATABASE;                /* 現在の接続を閉じる */
EXEC SQL CLOSE DATABASE;
</programlisting>
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>FREE cursor_name</></term>
      <listitem>
       <para>
<!--
        Due to the differences how ECPG works compared to Informix's ESQL/C (i.e. which steps
        are purely grammar transformations and which steps rely on the underlying run-time library)
        there is no <literal>FREE cursor_name</> statement in ECPG. This is because in ECPG,
        <literal>DECLARE CURSOR</literal> doesn't translate to a function call into
        the run-time library that uses to the cursor name. This means that there's no run-time
        bookkeeping of SQL cursors in the ECPG run-time library, only in the PostgreSQL server.
-->
InformixのESQL/Cと比べECPGの動作方法に違いがあります(つまり純粋に文法の変換がどの段階で行われ、背後の実行時ライブラリにどの段階で依存するか)ので、ECPGには<literal>FREE cursor_name</>文はありません。
このためECPGにおいて、<literal>DECLARE CURSOR</literal>がカーソル名を使用する実行時ライブラリ内の関数呼び出しに変換されません。
これはECPG実行時ライブラリ内ではSQLカーソルの実行状況を保持しておらず、PostgreSQLサーバ内のみで保持していることを意味します。
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>FREE statement_name</></term>
      <listitem>
       <para>
<!--
        <literal>FREE statement_name</> is a synonym for <literal>DEALLOCATE PREPARE statement_name</>.
-->
<literal>FREE statement_name</>は<literal>DEALLOCATE PREPARE statement_name</>の類義語です。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </sect2>

  <sect2 id="ecpg-informix-sqlda">
<!--
   <title>Informix-compatible SQLDA Descriptor Areas</title>
-->
   <title>Informix互換SQLDA記述子領域</title>
   <para>
<!--
    Informix-compatible mode supports a different structure than the one described in
    <xref linkend="ecpg-sqlda-descriptors">. See below:
-->
Informix互換モードは<xref linkend="ecpg-sqlda-descriptors">の説明と異なる構造体をサポートします。
以下を参照してください。
<programlisting>
struct sqlvar_compat
{
    short   sqltype;
    int     sqllen;
    char   *sqldata;
    short  *sqlind;
    char   *sqlname;
    char   *sqlformat;
    short   sqlitype;
    short   sqlilen;
    char   *sqlidata;
    int     sqlxid;
    char   *sqltypename;
    short   sqltypelen;
    short   sqlownerlen;
    short   sqlsourcetype;
    char   *sqlownername;
    int     sqlsourceid;
    char   *sqlilongdata;
    int     sqlflags;
    void   *sqlreserved;
};

struct sqlda_compat
{
    short  sqld;
    struct sqlvar_compat *sqlvar;
    char   desc_name[19];
    short  desc_occ;
    struct sqlda_compat *desc_next;
    void  *reserved;
};

typedef struct sqlvar_compat    sqlvar_t;
typedef struct sqlda_compat     sqlda_t;
</programlisting>
   </para>

   <para>
<!--
    The global properties are:
-->
大域的な属性を以下に示します。
    <variablelist>

     <varlistentry>
     <term><literal>sqld</></term>
      <listitem>
       <para>
<!--
        The number of fields in the <literal>SQLDA</> descriptor.
-->
<literal>SQLDA</>記述子内のフィールド数です。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>sqlvar</></term>
      <listitem>
       <para>
<!--
        Pointer to the per-field properties.
-->
フィールド単位の属性へのポインタです。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>desc_name</></term>
      <listitem>
       <para>
<!--
        Unused, filled with zero-bytes.
-->
未使用です。
ゼロバイトで埋められます。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>desc_occ</></term>
      <listitem>
       <para>
<!--
        Size of the allocated structure.
-->
割り当てられた構造体のサイズです。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>desc_next</></term>
      <listitem>
       <para>
<!--
        Pointer to the next SQLDA structure if the result set contains more than one record.
-->
結果セットに複数のレコードが含まれる場合、次のSQLDA構造体へのポインタです。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>reserved</></term>
      <listitem>
       <para>
<!--
        Unused pointer, contains NULL. Kept for Informix-compatibility.
-->
未使用のポインタでNULLが含まれます。
Informix互換のために保持されます。
       </para>
      </listitem>
     </varlistentry>

    </variablelist>

<!--
    The per-field properties are below, they are stored in the <literal>sqlvar</literal> array:
-->
フィールド毎の属性を以下に示します。
これらは<literal>sqlvar</literal>配列内に格納されます。

    <variablelist>

     <varlistentry>
     <term><literal>sqltype</></term>
      <listitem>
       <para>
<!--
        Type of the field. Constants are in <literal>sqltypes.h</literal>
-->
フィールドの型です。
定数は<literal>sqltypes.h</literal>内に記載されています。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>sqllen</></term>
      <listitem>
       <para>
<!--
        Length of the field data.
-->
フィールドデータ長です。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>sqldata</></term>
      <listitem>
       <para>
<!--
        Pointer to the field data. The pointer is of <literal>char *</literal> type,
        the data pointed by it is in a binary format. Example:
-->
フィールドデータへのポインタです。
このポインタは<literal>char *</literal>型です。
指し示されるデータはバイナリ書式です。
以下に例を示します。
<programlisting>
int intval;

switch (sqldata->sqlvar[i].sqltype)
{
    case SQLINTEGER:
        intval = *(int *)sqldata->sqlvar[i].sqldata;
        break;
  ...
}
</programlisting>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>sqlind</></term>
      <listitem>
       <para>
<!--
        Pointer to the NULL indicator. If returned by DESCRIBE or FETCH then it's always a valid pointer.
        If used as input for <literal>EXECUTE ... USING sqlda;</literal> then NULL-pointer value means
        that the value for this field is non-NULL. Otherwise a valid pointer and <literal>sqlitype</literal>
        has to be properly set. Example:
-->
NULL指示子へのポインタです。
DESCRIBEまたはFETCHで返される場合、常に有効なポインタです。
<literal>EXECUTE ... USING sqlda;</literal>への入力として使用される場合、NULLポインタ値はこのフィールドの値が非NULLであることを意味します。
さもなくば、有効なポインタと<literal>sqlitype</literal>は適切に設定されなければなりません。
以下に例を示します。
<programlisting>
if (*(int2 *)sqldata->sqlvar[i].sqlind != 0)
    printf("value is NULL\n");
</programlisting>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>sqlname</></term>
      <listitem>
       <para>
<!--
        Name of the field. 0-terminated string.
-->
フィールド名です。
ゼロ終端の文字列です。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>sqlformat</></term>
      <listitem>
       <para>
<!--
        Reserved in Informix, value of <function>PQfformat()</> for the field.
-->
Informixでは予約されています。
このフィールドの<function>PQfformat()</>の値です。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>sqlitype</></term>
      <listitem>
       <para>
<!--
        Type of the NULL indicator data. It's always SQLSMINT when returning data from the server.
        When the <literal>SQLDA</literal> is used for a parameterized query, the data is treated
        according to the set type.
-->
NULL指示子データの型です。
サーバからデータが返される場合は常にSQLSMINTです。
パラメータ付き問い合わせで<literal>SQLDA</literal>が使用される時、データは集合型にしたがって扱われます。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>sqlilen</></term>
      <listitem>
       <para>
<!--
        Length of the NULL indicator data.
-->
NULL指示子データの長さです。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>sqlxid</></term>
      <listitem>
       <para>
<!--
        Extended type of the field, result of <function>PQftype()</>.
-->
フィールドの拡張型で、<function>PQftype()</>の結果です。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>sqltypename</></term>
     <term><literal>sqltypelen</></term>
     <term><literal>sqlownerlen</></term>
     <term><literal>sqlsourcetype</></term>
     <term><literal>sqlownername</></term>
     <term><literal>sqlsourceid</></term>
     <term><literal>sqlflags</></term>
     <term><literal>sqlreserved</></term>
      <listitem>
       <para>
<!--
        Unused.
-->
未使用です。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>sqlilongdata</></term>
      <listitem>
       <para>
<!--
        It equals to <literal>sqldata</literal> if <literal>sqllen</literal> is larger than 32KB.
-->
<literal>sqllen</literal>が32キロバイトより大きい場合<literal>sqldata</literal>と同じです。
       </para>
      </listitem>
     </varlistentry>

    </variablelist>

<!--
    Example:
-->
以下に例を示します。
<programlisting>
EXEC SQL INCLUDE sqlda.h;

<!--
    sqlda_t        *sqlda; /* This doesn't need to be under embedded DECLARE SECTION */
-->
    sqlda_t        *sqlda; /* これは埋め込まれたDECLARE SECTIONの中にある必要はない */

    EXEC SQL BEGIN DECLARE SECTION;
    char *prep_stmt = "select * from table1";
    int i;
    EXEC SQL END DECLARE SECTION;

    ...

    EXEC SQL PREPARE mystmt FROM :prep_stmt;

    EXEC SQL DESCRIBE mystmt INTO sqlda;

    printf("# of fields: %d\n", sqlda-&gt;sqld);
    for (i = 0; i &lt; sqlda-&gt;sqld; i++)
      printf("field %d: \"%s\"\n", sqlda-&gt;sqlvar[i]-&gt;sqlname);

    EXEC SQL DECLARE mycursor CURSOR FOR mystmt;
    EXEC SQL OPEN mycursor;
    EXEC SQL WHENEVER NOT FOUND GOTO out;

    while (1)
    {
      EXEC SQL FETCH mycursor USING sqlda;
    }

    EXEC SQL CLOSE mycursor;

<!--
    free(sqlda); /* The main structure is all to be free(),
                  * sqlda and sqlda-&gt;sqlvar is in one allocated area */
-->
    free(sqlda); /* 主な構造体はすべてfree()される、
                  * sqldaとsqlda-&gt;sqlvarは1つの割り当て領域内にある */
</programlisting>
<!--
    For more information, see the <literal>sqlda.h</> header and the
    <literal>src/interfaces/ecpg/test/compat_informix/sqlda.pgc</literal> regression test.
-->
より詳細については<literal>sqlda.h</>ヘッダファイルと<literal>src/interfaces/ecpg/test/compat_informix/sqlda.pgc</literal>リグレッションテストを参照してください。
   </para>
  </sect2>

  <sect2 id="ecpg-informix-functions">
<!--
   <title>Additional Functions</title>
-->
   <title>追加関数</title>
   <para>
    <variablelist>
     <varlistentry>
      <term><function>decadd</></term>
      <listitem>
       <para>
<!--
        Add two decimal type values.
-->
2つのdecimal型変数を加算します。
<synopsis>
int decadd(decimal *arg1, decimal *arg2, decimal *sum);
</synopsis>
<!--
        The function receives a pointer to the first operand of type decimal
        (<literal>arg1</>), a pointer to the second operand of type decimal
        (<literal>arg2</>) and a pointer to a value of type decimal that will
        contain the sum (<literal>sum</>). On success, the function returns 0.
        <symbol>ECPG_INFORMIX_NUM_OVERFLOW</> is returned in case of overflow and
        <symbol>ECPG_INFORMIX_NUM_UNDERFLOW</> in case of underflow. -1 is returned for
        other failures and <varname>errno</> is set to the respective <varname>errno</> number of the
        pgtypeslib.
-->
この関数は、decimal型の最初の演算項目(<literal>arg1</>)へのポインタ、decimal型の2番目の演算項目(<literal>arg2</>)へのポインタ、加算結果を格納するdecimal型値(<literal>sum</>)へのポインタを受付けます。
成功すると、この関数は0を返します。
オーバーフローが発生した場合は<symbol>ECPG_INFORMIX_NUM_OVERFLOW</>が、アンダーフローの場合は<symbol>ECPG_INFORMIX_NUM_UNDERFLOW</>が返ります。
この他の失敗が発生した場合は-1が返り、<varname>errno</>にはpgtypeslibにおける対応する<varname>errno</>番号が設定されます。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>deccmp</></term>
      <listitem>
       <para>
<!--
        Compare two variables of type decimal.
-->
2つのdecimal型変数を比較します。
<synopsis>
int deccmp(decimal *arg1, decimal *arg2);
</synopsis>
<!--
        The function receives a pointer to the first decimal value
        (<literal>arg1</>), a pointer to the second decimal value
        (<literal>arg2</>) and returns an integer value that indicates which is
        the bigger value.
-->
この関数は、最初のdecimal値(<literal>arg1</>)へのポインタ、2番目のdecimal値(<literal>arg2</>)へのポインタを受付け、どちらが大きいかを示すint値を返します。
        <itemizedlist>
         <listitem>
          <para>
<!--
           1, if the value that <literal>arg1</> points to is bigger than the
           value that <literal>var2</> points to
-->
<literal>arg1</>が指し示す値が<literal>arg2</>が指し示す値より大きければ1。
          </para>
         </listitem>
         <listitem>
          <para>
<!--
           -1, if the value that <literal>arg1</> points to is smaller than the
           value that <literal>arg2</> points to </para>
-->
<literal>arg1</>が指し示す値が<literal>arg2</>が指し示す値より小さければ-1。
          </para>
         </listitem>
         <listitem>
          <para>
<!--
           0, if the value that <literal>arg1</> points to and the value that
           <literal>arg2</> points to are equal
-->
<literal>arg1</>が指し示す値と<literal>arg2</>が指し示す値が同じならば0。
          </para>
         </listitem>
        </itemizedlist>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>deccopy</></term>
      <listitem>
       <para>
<!--
        Copy a decimal value.
-->
decimal値をコピーします。
<synopsis>
void deccopy(decimal *src, decimal *target);
</synopsis>
<!--
        The function receives a pointer to the decimal value that should be
        copied as the first argument (<literal>src</>) and a pointer to the
        target structure of type decimal (<literal>target</>) as the second
        argument.
-->
この関数は、最初の引数としてコピー元のdecimal値(<literal>src</>)へのポインタ、2番目の引数としてdecimal型のコピー先構造体(<literal>target</>)へのポインタを受付けます。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>deccvasc</></term>
      <listitem>
       <para>
<!--
        Convert a value from its ASCII representation into a decimal type.
-->
ASCII表現からdecimal型に値を変換します。
<synopsis>
int deccvasc(char *cp, int len, decimal *np);
</synopsis>
<!--
        The function receives a pointer to string that contains the string
        representation of the number to be converted (<literal>cp</>) as well
        as its length <literal>len</>. <literal>np</> is a pointer to the
        decimal value that saves the result of the operation.
-->
この関数は、変換対象の文字列表現を持つ文字列(<literal>cp</>)へのポインタとその文字列長<literal>len</>を受付けます。
<literal>np</>はこの操作結果を格納するdecimal型の値へのポインタです。
       </para>
       <para>
<!--
        Valid formats are for example:
         <literal>-2</literal>,
         <literal>.794</literal>,
         <literal>+3.44</literal>,
         <literal>592.49E07</literal> or
         <literal>-32.84e-4</literal>.
-->
有効な書式の例は以下の通りです。
         <literal>-2</literal>、
         <literal>.794</literal>、
         <literal>+3.44</literal>、
         <literal>592.49E07</literal>、
         <literal>-32.84e-4</literal>。
       </para>
       <para>
<!--
        The function returns 0 on success. If overflow or underflow occurred,
        <literal>ECPG_INFORMIX_NUM_OVERFLOW</> or
        <literal>ECPG_INFORMIX_NUM_UNDERFLOW</> is returned. If the ASCII
        representation could not be parsed,
        <literal>ECPG_INFORMIX_BAD_NUMERIC</> is returned or
        <literal>ECPG_INFORMIX_BAD_EXPONENT</> if this problem occurred while
        parsing the exponent.
-->
この関数は成功時0を返します。
オーバーフローやアンダーフローが発生した場合は<literal>ECPG_INFORMIX_NUM_OVERFLOW</>や<literal>ECPG_INFORMIX_NUM_UNDERFLOW</>が返されます。
ASCII表現の解析ができなかった場合は<literal>ECPG_INFORMIX_BAD_NUMERIC</>が、指数部分の解析に問題がある場合は<literal>ECPG_INFORMIX_BAD_EXPONENT</>が返されます。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>deccvdbl</></term>
      <listitem>
       <para>
<!--
        Convert a value of type double to a value of type decimal.
-->
double型の値をdecimal型の値に変換します。
<synopsis>
int deccvdbl(double dbl, decimal *np);
</synopsis>
<!--
        The function receives the variable of type double that should be
        converted as its first argument (<literal>dbl</>). As the second
        argument (<literal>np</>), the function receives a pointer to the
        decimal variable that should hold the result of the operation.
-->
この関数は、最初の引数として変換対象のdouble型の変数(<literal>dbl</>)を受付けます。
2番目の引数(<literal>np</>)として、この関数は操作結果を格納するdecimal型変数へのポインタを受付けます。
       </para>
       <para>
<!--
        The function returns 0 on success and a negative value if the
        conversion failed.
-->
この関数は成功時に0を返します。
変換が失敗した場合は負の値が返ります。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>deccvint</></term>
      <listitem>
       <para>
<!--
        Convert a value of type int to a value of type decimal.
-->
int型の値をdecimal型の値に変換します。
<synopsis>
int deccvint(int in, decimal *np);
</synopsis>
<!--
        The function receives the variable of type int that should be
        converted as its first argument (<literal>in</>). As the second
        argument (<literal>np</>), the function receives a pointer to the
        decimal variable that should hold the result of the operation.
-->
この関数は最初の引数として、変換対象のint型変数(<literal>in</>)を受付けます。
2番目の引数(<literal>np</>)として、この関数は変換結果を格納するdecimal型変数へのポインタを受付けます。
       </para>
       <para>
<!--
        The function returns 0 on success and a negative value if the
        conversion failed.
-->
この関数は成功時に0を返します。
変換が失敗した場合は負の値が返ります。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>deccvlong</></term>
      <listitem>
       <para>
<!--
        Convert a value of type long to a value of type decimal.
-->
long型の値をdecimal型の値に変換します。
<synopsis>
int deccvlong(long lng, decimal *np);
</synopsis>
<!--
        The function receives the variable of type long that should be
        converted as its first argument (<literal>lng</>). As the second
        argument (<literal>np</>), the function receives a pointer to the
        decimal variable that should hold the result of the operation.
-->
この関数は最初の引数として、変換対象のlong型変数(<literal>lng</>)を受付けます。
2番目の引数(<literal>np</>)として、この関数は変換結果を格納するdecimal型変数へのポインタを受付けます。
       </para>
       <para>
<!--
        The function returns 0 on success and a negative value if the
        conversion failed.
-->
この関数は成功時に0を返します。
変換が失敗した場合は負の値が返ります。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>decdiv</></term>
      <listitem>
       <para>
<!--
        Divide two variables of type decimal.
-->
2つのdecimal型変数の除算を行います。
<synopsis>
int decdiv(decimal *n1, decimal *n2, decimal *result);
</synopsis>
<!--
        The function receives pointers to the variables that are the first
        (<literal>n1</>) and the second (<literal>n2</>) operands and
        calculates <literal>n1</>/<literal>n2</>. <literal>result</> is a
        pointer to the variable that should hold the result of the operation.
-->
この関数は、1番目の演算項目(<literal>n1</>)と2番目の演算項目(<literal>n2</>)となる変数のポインタを受付け、<literal>n1</>/<literal>n2</>を計算します。
<literal>result</>は、操作結果を格納する変数へのポインタです。
       </para>
       <para>
<!--
        On success, 0 is returned and a negative value if the division fails.
        If overflow or underflow occurred, the function returns
        <literal>ECPG_INFORMIX_NUM_OVERFLOW</> or
        <literal>ECPG_INFORMIX_NUM_UNDERFLOW</> respectively. If an attempt to
        divide by zero is observed, the function returns
        <literal>ECPG_INFORMIX_DIVIDE_ZERO</literal>.
-->
成功時0が返され、除算の失敗時には負の値が返されます。
オーバーフローやアンダーフローが発生した場合、この関数はそれぞれ<literal>ECPG_INFORMIX_NUM_OVERFLOW</>、<literal>ECPG_INFORMIX_NUM_UNDERFLOW</>を返します。
0割りが発生した場合は<literal>ECPG_INFORMIX_DIVIDE_ZERO</literal>が返されます。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>decmul</></term>
      <listitem>
       <para>
<!--
        Multiply two decimal values.
-->
2つのdecimal型変数を乗算します。
<synopsis>
int decmul(decimal *n1, decimal *n2, decimal *result);
</synopsis>
<!--
        The function receives pointers to the variables that are the first
        (<literal>n1</>) and the second (<literal>n2</>) operands and
        calculates <literal>n1</>*<literal>n2</>. <literal>result</> is a
        pointer to the variable that should hold the result of the operation.
-->
この関数は、1番目の演算項目(<literal>n1</>)と2番目の演算項目(<literal>n2</>)となる変数のポインタを受付け、<literal>n1</>*<literal>n2</>を計算します。
<literal>result</>は、操作結果を格納する変数へのポインタです。
       </para>
       <para>
<!--
        On success, 0 is returned and a negative value if the multiplication
        fails. If overflow or underflow occurred, the function returns
        <literal>ECPG_INFORMIX_NUM_OVERFLOW</> or
        <literal>ECPG_INFORMIX_NUM_UNDERFLOW</> respectively.
-->
成功時0が返され、乗算の失敗時には負の値が返されます。
オーバーフローやアンダーフローが発生した場合、この関数はそれぞれ<literal>ECPG_INFORMIX_NUM_OVERFLOW</>、<literal>ECPG_INFORMIX_NUM_UNDERFLOW</>を返します。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>decsub</></term>
      <listitem>
       <para>
<!--
        Subtract one decimal value from another.
-->
10進数型値同士の引算を行います。
<synopsis>
int decsub(decimal *n1, decimal *n2, decimal *result);
</synopsis>
<!--
        The function receives pointers to the variables that are the first
        (<literal>n1</>) and the second (<literal>n2</>) operands and
        calculates <literal>n1</>-<literal>n2</>. <literal>result</> is a
        pointer to the variable that should hold the result of the operation.
-->
この関数は、1番目の演算項目(<literal>n1</>)と2番目の演算項目(<literal>n2</>)となる変数のポインタを受付け、<literal>n1</>-<literal>n2</>を計算します。
<literal>result</>は、操作結果を格納する変数へのポインタです。
       </para>
       <para>
<!--
        On success, 0 is returned and a negative value if the subtraction
        fails. If overflow or underflow occurred, the function returns
        <literal>ECPG_INFORMIX_NUM_OVERFLOW</> or
        <literal>ECPG_INFORMIX_NUM_UNDERFLOW</> respectively.
-->
成功時0が返され、減算の失敗時には負の値が返されます。
オーバーフローやアンダーフローが発生した場合、この関数はそれぞれ<literal>ECPG_INFORMIX_NUM_OVERFLOW</>、<literal>ECPG_INFORMIX_NUM_UNDERFLOW</>を返します。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>dectoasc</></term>
      <listitem>
       <para>
<!--
        Convert a variable of type decimal to its ASCII representation in a C
        char* string.
-->
decimal型変数をC char* 文字列のASCII表現に変換します。
<synopsis>
int dectoasc(decimal *np, char *cp, int len, int right)
</synopsis>
<!--
        The function receives a pointer to a variable of type decimal
        (<literal>np</>) that it converts to its textual representation.
        <literal>cp</> is the buffer that should hold the result of the
        operation. The parameter <literal>right</> specifies, how many digits
        right of the decimal point should be included in the output. The result
        will be rounded to this number of decimal digits. Setting
        <literal>right</> to -1 indicates that all available decimal digits
        should be included in the output. If the length of the output buffer,
        which is indicated by <literal>len</> is not sufficient to hold the
        textual representation including the trailing zero byte, only a
        single <literal>*</> character is stored in the result and -1 is
        returned.
-->
この関数はdecimal型変数(<literal>np</>)のポインタを受け付け、テキスト表現に変換します。
<literal>cp</>は変換結果を格納するためのバッファです。
<literal>right</>パラメータは、decimal小数点の右側の何桁を出力するかを指定します。
結果はこの10進桁数で丸められます。
<literal>right</>を-1にすることで、すべての有効な桁数が出力されるようになります。
<literal>len</>で示す出力バッファ長が、最後のNULL文字を含むテキスト表現を格納するのには不十分であった場合、結果には<literal>*</>という1文字が格納され、-1が返されます。
       </para>
       <para>
<!--
        The function returns either -1 if the buffer <literal>cp</> was too
        small or <literal>ECPG_INFORMIX_OUT_OF_MEMORY</> if memory was
        exhausted.
-->
この関数は、<literal>cp</>バッファが小さすぎる場合に-1を返します。
メモリ不足の場合は<literal>ECPG_INFORMIX_OUT_OF_MEMORY</>を返します。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>dectodbl</></term>
      <listitem>
       <para>
<!--
        Convert a variable of type decimal to a double.
-->
decimal型変数をdoubleに変換します。
<synopsis>
int dectodbl(decimal *np, double *dblp);
</synopsis>
<!--
        The function receives a pointer to the decimal value to convert
        (<literal>np</>) and a pointer to the double variable that
        should hold the result of the operation (<literal>dblp</>).
-->
この関数は変換対象のdecimal型変数(<literal>np</>)のポインタと処理結果を格納するdouble変数(<literal>dblp</>)へのポインタを受け付けます。
       </para>
       <para>
<!--
        On success, 0 is returned and a negative value if the conversion
        failed.
-->
成功時0が、変換失敗時負の値が返されます。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>dectoint</></term>
      <listitem>
       <para>
<!--
        Convert a variable to type decimal to an integer.
-->
decimal型変数を整数型に変換します。
<synopsis>
int dectoint(decimal *np, int *ip);
</synopsis>
<!--
        The function receives a pointer to the decimal value to convert
        (<literal>np</>) and a pointer to the integer variable that
        should hold the result of the operation (<literal>ip</>).
-->
この関数は変換対象のdecimal型変数(<literal>np</>)のポインタと処理結果を格納するint型変数(<literal>ip</>)へのポインタを受け付けます。
       </para>
       <para>
<!--
        On success, 0 is returned and a negative value if the conversion
        failed. If an overflow occurred, <literal>ECPG_INFORMIX_NUM_OVERFLOW</>
        is returned.
-->
成功時0が、変換失敗時負の値が返されます。
オーバーフローが発生した場合は<literal>ECPG_INFORMIX_NUM_OVERFLOW</>が返されます。
       </para>
       <para>
<!--
        Note that the ECPG implementation differs from the <productname>Informix</productname>
        implementation. <productname>Informix</productname> limits an integer to the range from -32767 to
        32767, while the limits in the ECPG implementation depend on the
        architecture (<literal>-INT_MAX .. INT_MAX</>).
-->
このECPGの実装は<productname>Informix</productname>の実装と異なることに注意してください。
<productname>Informix</productname>では、整数範囲に-32767から32767までという制限をしていますが、ECPGでの制限はアーキテクチャに依存(<literal>-INT_MAX .. INT_MAX</>)します。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>dectolong</></term>
      <listitem>
       <para>
<!--
        Convert a variable to type decimal to a long integer.
-->
decimal型変数をlong型に変換します。
<synopsis>
int dectolong(decimal *np, long *lngp);
</synopsis>
<!--
        The function receives a pointer to the decimal value to convert
        (<literal>np</>) and a pointer to the long variable that
        should hold the result of the operation (<literal>lngp</>).
-->
この関数は変換対象のdecimal型変数(<literal>np</>)のポインタと処理結果を格納するlong変数(<literal>lngp</>)へのポインタを受け付けます。
       </para>
       <para>
<!--
        On success, 0 is returned and a negative value if the conversion
        failed. If an overflow occurred, <literal>ECPG_INFORMIX_NUM_OVERFLOW</>
        is returned.
-->
成功時0が、変換失敗時負の値が返されます。
オーバーフローが発生した場合は<literal>ECPG_INFORMIX_NUM_OVERFLOW</>が返されます。
       </para>
       <para>
<!--
        Note that the ECPG implementation differs from the <productname>Informix</productname>
        implementation. <productname>Informix</productname> limits a long integer to the range from
        -2,147,483,647 to 2,147,483,647, while the limits in the ECPG
        implementation depend on the architecture (<literal>-LONG_MAX ..
        LONG_MAX</>).
-->
このECPGの実装は<productname>Informix</productname>の実装と異なることに注意してください。
<productname>Informix</productname>では、整数範囲に-2,147,483,647から2,147,483,647までという制限をしていますが、ECPGでの制限はアーキテクチャに依存(<literal>-LONG_MAX .. LONG_MAX</>)します。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rdatestr</></term>
      <listitem>
       <para>
<!--
        Converts a date to a C char* string.
-->
date型をC char*文字列に変換します。
<synopsis>
int rdatestr(date d, char *str);
</synopsis>
<!--
        The function receives two arguments, the first one is the date to
        convert (<literal>d</>) and the second one is a pointer to the target
        string. The output format is always <literal>yyyy-mm-dd</>, so you need
        to allocate at least 11 bytes (including the zero-byte terminator) for the
        string.
-->
この関数は2つの引数を受付けます。
最初の引数は変換対象のdate型(<literal>d</>)、2番目は変換後の文字列へのポインタです。
出力書式は常に<literal>yyyy-mm-dd</>ですので、少なくとも11文字（NULL終端を含む）を結果文字列に割り当てなければなりません。
       </para>
       <para>
<!--
        The function returns 0 on success and a negative value in case of
        error.
-->
この関数は成功時0を、エラー時負の値を返します。
       </para>
       <para>
<!--
        Note that ECPG's implementation differs from the <productname>Informix</productname>
        implementation. In <productname>Informix</productname> the format can be influenced by setting
        environment variables. In ECPG however, you cannot change the output
        format.
-->
このECPGの実装は<productname>Informix</productname>の実装と異なることに注意してください。
<productname>Informix</productname>では、環境変数により書式を変更できますが、ECPGでは出力書式を変更することはできません。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rstrdate</></term>
      <listitem>
       <para>
<!--
        Parse the textual representation of a date.
-->
date型のテキスト表現を解析します。
<synopsis>
int rstrdate(char *str, date *d);
</synopsis>
<!--
        The function receives the textual representation of the date to convert
        (<literal>str</>) and a pointer to a variable of type date
        (<literal>d</>). This function does not allow you to specify a format
        mask. It uses the default format mask of <productname>Informix</productname> which is
        <literal>mm/dd/yyyy</>. Internally, this function is implemented by
        means of <function>rdefmtdate</>. Therefore, <function>rstrdate</> is
        not faster and if you have the choice you should opt for
        <function>rdefmtdate</> which allows you to specify the format mask
        explicitly.
-->
この関数は、変換対象のdate型のテキスト表現(<literal>str</>)とdate型変数のポインタ(<literal>d</>)を受付けます。
この関数では書式マスクを指定することができません。
<productname>Informix</productname>のデフォルトの書式マスクである<literal>mm/dd/yyyy</>を使用します。
内部的には、この関数は<function>rdefmtdate</>を使用して実装しています。
したがって<function>rstrdate</>は速くありません。
もし選択肢があるのであれば、書式マスクを明示的に指定することができる<function>rdefmtdate</>を選択すべきです。
       </para>
       <para>
<!--
        The function returns the same values as <function>rdefmtdate</>.
-->
この関数は<function>rdefmtdate</>と同様の値を返します。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rtoday</></term>
      <listitem>
       <para>
<!--
        Get the current date.
-->
現在の日付を（date型で）入手します。
<synopsis>
void rtoday(date *d);
</synopsis>
<!--
        The function receives a pointer to a date variable (<literal>d</>)
        that it sets to the current date.
-->
この関数はdate型変数(<literal>d</>)へのポインタを受付け、そこに現在の日付を格納します。
       </para>
       <para>
<!--
        Internally this function uses the <xref linkend="PGTYPESdatetoday">
        function.
-->
内部的には、この関数は<xref linkend="PGTYPESdatetoday">関数を使用します。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rjulmdy</></term>
      <listitem>
       <para>
<!--
        Extract the values for the day, the month and the year from a variable
        of type date.
-->
date型変数から、日、月、年の値を取り出します。
<synopsis>
int rjulmdy(date d, short mdy[3]);
</synopsis>
<!--
        The function receives the date <literal>d</> and a pointer to an array
        of 3 short integer values <literal>mdy</>. The variable name indicates
        the sequential order: <literal>mdy[0]</> will be set to contain the
        number of the month, <literal>mdy[1]</> will be set to the value of the
        day and <literal>mdy[2]</> will contain the year.
-->
この関数は日付<literal>d</>、3つのshort integer型の値からなる配列<literal>mdy</>へのポインタを受付けます。
この変数名はその並びを表し、<literal>mdy[0]</>には月数、<literal>mdy[1]</>には日数が、<literal>mdy[2]</>には年が入ります。
       </para>
       <para>
<!--
        The function always returns 0 at the moment.
-->
現在この関数は常に0を返します。
       </para>
       <para>
<!--
        Internally the function uses the <xref linkend="PGTYPESdatejulmdy">
        function.
-->
内部的にはこの関数は<xref linkend="PGTYPESdatejulmdy">関数を使用します。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rdefmtdate</></term>
      <listitem>
       <para>
<!--
        Use a format mask to convert a character string to a value of type
        date.
-->
書式マスクを使用して、文字列をdate型の値に変換します。
<synopsis>
int rdefmtdate(date *d, char *fmt, char *str);
</synopsis>
<!--
        The function receives a pointer to the date value that should hold the
        result of the operation (<literal>d</>), the format mask to use for
        parsing the date (<literal>fmt</>) and the C char* string containing
        the textual representation of the date (<literal>str</>). The textual
        representation is expected to match the format mask. However you do not
        need to have a 1:1 mapping of the string to the format mask. The
        function only analyzes the sequential order and looks for the literals
        <literal>yy</literal> or <literal>yyyy</literal> that indicate the
        position of the year, <literal>mm</literal> to indicate the position of
        the month and <literal>dd</literal> to indicate the position of the
        day.
-->
この関数は、処理結果を格納するためのdate型へのポインタ(<literal>d</>)、日付を解析するための書式マスク(<literal>fmt</>)、dateのテキスト表現を含むCのchar*文字列(<literal>str</>)を受付けます。
テキスト表現は書式マスクに合った表現であることが仮定されています。
しかし、文字列と書式マスクを1:1に対応付けする必要はありません。
この関数は並んだ順番に解析し、年の位置を表す<literal>yy</literal>または<literal>yyyy</literal>を、月の位置を表す<literal>mm</literal>を、日の位置を表す<literal>dd</literal>を検索します。
       </para>
       <para>
<!--
        The function returns the following values:
-->
この関数は以下の値を返します。
        <itemizedlist>
         <listitem>
          <para>
<!--
           0 - The function terminated successfully.
-->
0 - 関数が正常に終了しました。
          </para>
         </listitem>
         <listitem>
          <para>
<!--
           <literal>ECPG_INFORMIX_ENOSHORTDATE</> - The date does not contain
           delimiters between day, month and year. In this case the input
           string must be exactly 6 or 8 bytes long but isn't.
-->
<literal>ECPG_INFORMIX_ENOSHORTDATE</> - 日付に、日、月、年を区切る文字がありませんでした。
この場合、入力文字列は6バイト、8バイトのいずれかでなければなりませんが、そうではありませんでした。
          </para>
         </listitem>
         <listitem>
          <para>
<!--
           <literal>ECPG_INFORMIX_ENOTDMY</> - The format string did not
           correctly indicate the sequential order of year, month and day.
-->
<literal>ECPG_INFORMIX_ENOTDMY</> - 書式文字列が正しく年月日の順番を示していません。
          </para>
         </listitem>
         <listitem>
          <para>
<!--
           <literal>ECPG_INFORMIX_BAD_DAY</> - The input string does not
           contain a valid day.
-->
<literal>ECPG_INFORMIX_BAD_DAY</> - 入力文字列に有効な日が含まれていません。
          </para>
         </listitem>
         <listitem>
          <para>
<!--
           <literal>ECPG_INFORMIX_BAD_MONTH</> - The input string does not
           contain a valid month.
-->
<literal>ECPG_INFORMIX_BAD_MONTH</> - 入力文字列に有効な月が含まれていません。
          </para>
         </listitem>
         <listitem>
          <para>
<!--
           <literal>ECPG_INFORMIX_BAD_YEAR</> - The input string does not
           contain a valid year.
-->
<literal>ECPG_INFORMIX_BAD_YEAR</> - 入力文字列に有効な年が含まれていません。
          </para>
         </listitem>
        </itemizedlist>
       </para>
       <para>
<!--
        Internally this function is implemented to use the <xref
        linkend="PGTYPESdatedefmtasc"> function. See the reference there for a
        table of example input.
-->
内部的には、この関数は<xref linkend="PGTYPESdatedefmtasc">関数を使用して実装しています。
この関数の説明には、入力例の表がありますので、こちらも参照してください。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rfmtdate</></term>
      <listitem>
       <para>
<!--
        Convert a variable of type date to its textual representation using a
        format mask.
-->
書式マスクを使用してdate型変数をテキスト表現に変換します。
<synopsis>
int rfmtdate(date d, char *fmt, char *str);
</synopsis>
<!--
        The function receives the date to convert (<literal>d</>), the format
        mask (<literal>fmt</>) and the string that will hold the textual
        representation of the date (<literal>str</>).
-->
この関数は変換対象の日付(<literal>d</>)、書式マスク(<literal>fmt</>)、日付のテキスト表現を格納する文字列(<literal>str</>)を受付けます。
       </para>
       <para>
<!--
        On success, 0 is returned and a negative value if an error occurred.
-->
成功時0、エラーが発生した場合は負の値が返されます。
       </para>
       <para>
<!--
        Internally this function uses the <xref linkend="PGTYPESdatefmtasc">
        function, see the reference there for examples.
-->
内部的にはこの関数は<xref linkend="PGTYPESdatefmtasc">関数を使用します。
例が記載されていますので、こちらも参照してください。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rmdyjul</></term>
      <listitem>
       <para>
<!--
        Create a date value from an array of 3 short integers that specify the
        day, the month and the year of the date.
-->
日付の日、月、年を表す3つのshort integer型からなる配列から日付型の値を作成します。
<synopsis>
int rmdyjul(short mdy[3], date *d);
</synopsis>
<!--
        The function receives the array of the 3 short integers
        (<literal>mdy</>) and a pointer to a variable of type date that should
        hold the result of the operation.
-->
この関数は3つのshort integer型からなる配列(<literal>mdy</>)と処理結果を格納するdate型変数へのポインタを受付けます。
       </para>
       <para>
<!--
        Currently the function returns always 0.
-->
現在この関数は常に0を返します。
       </para>
       <para>
<!--
        Internally the function is implemented to use the function <xref
        linkend="PGTYPESdatemdyjul">.
-->
内部的にはこの関数は<xref linkend="PGTYPESdatemdyjul">関数を使用して実装しています。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rdayofweek</></term>
      <listitem>
       <para>
<!--
        Return a number representing the day of the week for a date value.
-->
日付型の値の週内日数を示す値を返します。
<synopsis>
int rdayofweek(date d);
</synopsis>
<!--
        The function receives the date variable <literal>d</> as its only
        argument and returns an integer that indicates the day of the week for
        this date.
-->
この関数はdate型変数<literal>d</>をその唯一の引数として受付け、その日付の週内日数を示す整数を返します。
        <itemizedlist>
         <listitem>
          <para>
<!--
           0 - Sunday
-->
0 - 日曜
          </para>
         </listitem>
         <listitem>
          <para>
<!--
           1 - Monday
-->
1 - 月曜
          </para>
         </listitem>
         <listitem>
          <para>
<!--
           2 - Tuesday
-->
2 - 火曜
          </para>
         </listitem>
         <listitem>
          <para>
<!--
           3 - Wednesday
-->
3 - 水曜
          </para>
         </listitem>
         <listitem>
          <para>
<!--
           4 - Thursday
-->
4 - 木曜
          </para>
         </listitem>
         <listitem>
          <para>
<!--
           5 - Friday
-->
5 - 金曜
          </para>
         </listitem>
         <listitem>
          <para>
<!--
           6 - Saturday
-->
6 - 土曜
          </para>
         </listitem>
        </itemizedlist>
       </para>
       <para>
<!--
        Internally the function is implemented to use the function <xref
        linkend="PGTYPESdatedayofweek">.
-->
内部的にはこの関数は <xref linkend="PGTYPESdatedayofweek">関数を使用して実装しています。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>dtcurrent</></term>
      <listitem>
       <para>
<!--
        Retrieve the current timestamp.
-->
現在のタイムスタンプを取り出します。
<synopsis>
void dtcurrent(timestamp *ts);
</synopsis>
<!--
        The function retrieves the current timestamp and saves it into the
        timestamp variable that <literal>ts</> points to.
-->
この関数は現在のタイムスタンプを受け取り、<literal>ts</>が指し示すタイムスタンプ型変数に格納します。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>dtcvasc</></term>
      <listitem>
       <para>
<!--
        Parses a timestamp from its textual representation
        into a timestamp variable.
-->
テキスト表現からtimestamp型変数にタイムスタンプを解析します。
<synopsis>
int dtcvasc(char *str, timestamp *ts);
</synopsis>
<!--
        The function receives the string to parse (<literal>str</>) and a
        pointer to the timestamp variable that should hold the result of the
        operation (<literal>ts</>).
-->
この関数は対象の文字列(<literal>str</>)と処理結果を格納するtimestamp型変数(<literal>ts</>)へのポインタを受付けます。
       </para>
       <para>
<!--
        The function returns 0 on success and a negative value in case of
        error.
-->
この関数は成功時0を返し、エラー時負の値を返します。
       </para>
       <para>
<!--
        Internally this function uses the <xref
        linkend="PGTYPEStimestampfromasc"> function. See the reference there
        for a table with example inputs.
-->
内部的にはこの関数は<xref linkend="PGTYPEStimestampfromasc">関数を使用します。
入力例の表がありますので、こちらも参照してください。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>dtcvfmtasc</></term>
      <listitem>
       <para>
<!--
        Parses a timestamp from its textual representation
        using a format mask into a timestamp variable.
-->
書式マスクを使用してタイムスタンプのテキスト表現をtimestamp型変数に変換します。
<synopsis>
dtcvfmtasc(char *inbuf, char *fmtstr, timestamp *dtvalue)
</synopsis>
<!--
        The function receives the string to parse (<literal>inbuf</>), the
        format mask to use (<literal>fmtstr</>) and a pointer to the timestamp
        variable that should hold the result of the operation
        (<literal>dtvalue</>).
-->
この関数は、対象とする文字列(<literal>inbuf</>)、使用する書式マスク(<literal>fmtstr</>)、処理結果を格納するtimestamp変数(<literal>dtvalue</>)へのポインタを受付けます。
       </para>
       <para>
<!--
        This function is implemented by means of the <xref
        linkend="PGTYPEStimestampdefmtasc"> function. See the documentation
        there for a list of format specifiers that can be used.
-->
この関数は<xref linkend="PGTYPEStimestampdefmtasc">関数を使用して実装されています。
使用可能な書式指定のリストがありますので、こちらも参照してください。
       </para>
       <para>
<!--
        The function returns 0 on success and a negative value in case of
        error.
-->
この関数は成功時に0を、エラー時負の値を返します。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>dtsub</></term>
      <listitem>
       <para>
<!--
        Subtract one timestamp from another and return a variable of type
        interval.
-->
timestamp型同士で減算を行い、interval型変数を返します。
<synopsis>
int dtsub(timestamp *ts1, timestamp *ts2, interval *iv);
</synopsis>
<!--
        The function will subtract the timestamp variable that <literal>ts2</>
        points to from the timestamp variable that <literal>ts1</> points to
        and will store the result in the interval variable that <literal>iv</>
        points to.
-->
この関数は<literal>ts1</>が指し示すtimestamp型変数から<literal>ts2</>が指し示すtimestamp型変数を引きます。
結果は<literal>iv</>が指し示すinterval型変数に格納されます。
       </para>
       <para>
<!--
        Upon success, the function returns 0 and a negative value if an
        error occurred.
-->
成功時この関数は0を返し、エラー時負の値を返します。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>dttoasc</></term>
      <listitem>
       <para>
<!--
        Convert a timestamp variable to a C char* string.
-->
timestamp型変数をC char*文字列に変換します。
<synopsis>
int dttoasc(timestamp *ts, char *output);
</synopsis>
<!--
        The function receives a pointer to the timestamp variable to convert
        (<literal>ts</>) and the string that should hold the result of the
        operation (<literal>output</>). It converts <literal>ts</> to its
        textual representation according to the SQL standard, which is
        be <literal>YYYY-MM-DD HH:MM:SS</literal>.
-->
この関数は対象のtimestamp型変数(<literal>ts</>)へのポインタ、処理結果を格納する文字列(<literal>output</>)を受付けます。
これは<literal>ts</>を標準SQLに従うテキスト表現（<literal>YYYY-MM-DD HH:MM:SS</literal>として定義）に変換します。
       </para>
       <para>
<!--
        Upon success, the function returns 0 and a negative value if an
        error occurred.
-->
成功時この関数は0を返し、エラー時負の値を返します。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>dttofmtasc</></term>
      <listitem>
       <para>
<!--
        Convert a timestamp variable to a C char* using a format mask.
-->
書式マスクを使用してtimestamp型変数をC char*に変換します。
<synopsis>
int dttofmtasc(timestamp *ts, char *output, int str_len, char *fmtstr);
</synopsis>
<!--
        The function receives a pointer to the timestamp to convert as its
        first argument (<literal>ts</>), a pointer to the output buffer
        (<literal>output</>), the maximal length that has been allocated for
        the output buffer (<literal>str_len</literal>) and the format mask to
        use for the conversion (<literal>fmtstr</literal>).
-->
この関数は、最初の引数として変換対象のタイムスタンプ(<literal>ts</>)を、出力バッファのポインタ(<literal>output</>)、出力バッファで割当て可能な最大長 (<literal>str_len</literal>)、変換に使用する書式マスク(<literal>fmtstr</literal>)を受付けます。
       </para>
       <para>
<!--
        Upon success, the function returns 0 and a negative value if an
        error occurred.
-->
成功時この関数は0を返します。エラーが発生した場合は負の値を返します。
       </para>
       <para>
<!--
        Internally, this function uses the <xref
        linkend="PGTYPEStimestampfmtasc"> function. See the reference there for
        information on what format mask specifiers can be used.
-->
内部的に、この関数は<xref linkend="PGTYPEStimestampfmtasc">関数を使用します。
使用できる書式マスクに関する情報がありますので、こちらも参照してください。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>intoasc</></term>
      <listitem>
       <para>
<!--
        Convert an interval variable to a C char* string.
-->
interval型変数をC char*文字列に変換します。
<synopsis>
int intoasc(interval *i, char *str);
</synopsis>
<!--
        The function receives a pointer to the interval variable to convert
        (<literal>i</>) and the string that should hold the result of the
        operation (<literal>str</>). It converts <literal>i</> to its
        textual representation according to the SQL standard, which is
        be <literal>YYYY-MM-DD HH:MM:SS</literal>.
-->
この関数は、変換対象のinterval型変数(<literal>i</>)へのポインタ、処理結果を格納する文字列(<literal>str</>)を受付けます。
これは<literal>i</>を標準SQLに従うテキスト表現（<literal>YYYY-MM-DD HH:MM:SS</literal>として定義）に変換します。
       </para>
       <para>
<!--
        Upon success, the function returns 0 and a negative value if an
        error occurred.
-->
成功時、この関数は0を返します。
エラーが発生した場合は負の値を返します。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rfmtlong</></term>
      <listitem>
       <para>
<!--
        Convert a long integer value to its textual representation using a
        format mask.
-->
long integer値を書式マスクを使用してテキスト表現に変換します。
<synopsis>
int rfmtlong(long lng_val, char *fmt, char *outbuf);
</synopsis>
<!--
        The function receives the long value <literal>lng_val</>, the format
        mask <literal>fmt</> and a pointer to the output buffer
        <literal>outbuf</>. It converts the long value according to the format
        mask to its textual representation.
-->
この関数は、long型の値<literal>lng_val</>、書式マスク<literal>fmt</>、出力バッファ<literal>outbuf</>へのポインタを受付けます。
これはlong型の値を書式マスクに従ってテキスト表現に変換します。
       </para>
       <para>
<!--
        The format mask can be composed of the following format specifying
        characters:
-->
書式マスクは以下の書式指定文字を組み合わせることができます。
        <itemizedlist>
         <listitem>
          <para>
<!--
           <literal>*</literal> (asterisk) - if this position would be blank
           otherwise, fill it with an asterisk.
-->
<literal>*</literal> (アスタリスク) - この位置が空白ならばアスタリスクで埋めます。
          </para>
         </listitem>
         <listitem>
          <para>
<!--
           <literal>&amp;</literal> (ampersand) - if this position would be
           blank otherwise, fill it with a zero.
-->
<literal>&amp;</literal> (アンパサンド) - この位置が空白ならば0で埋めます。
          </para>
         </listitem>
         <listitem>
          <para>
<!--
           <literal>#</literal> - turn leading zeroes into blanks.
-->
           <literal>#</literal> - 先頭のゼロを空白に変換します。
          </para>
         </listitem>
         <listitem>
          <para>
<!--
           <literal>&lt;</literal> - left-justify the number in the string.
-->
           <literal>&lt;</literal> - 文字列内で数値を左そろえします。
          </para>
         </listitem>
         <listitem>
          <para>
<!--
           <literal>,</literal> (comma) - group numbers of four or more digits
           into groups of three digits separated by a comma.
-->
<literal>,</literal> (カンマ) - 4桁以上の数値をカンマで区切った3桁にグループ化します。
          </para>
         </listitem>
         <listitem>
          <para>
<!--
           <literal>.</literal> (period) - this character separates the
           whole-number part of the number from the fractional part.
-->
           <literal>.</literal> (ピリオド) - この文字は数値から小数部分を区別します。
          </para>
         </listitem>
         <listitem>
          <para>
<!--
           <literal>-</literal> (minus) - the minus sign appears if the number
           is a negative value.
-->
           <literal>-</literal> (マイナス) - 数値が負の場合、マイナス記号を付けます。
          </para>
         </listitem>
         <listitem>
          <para>
<!--
           <literal>+</literal> (plus) - the plus sign appears if the number is
           a positive value.
-->
           <literal>+</literal> (プラス) - 数値が正の場合プラス記号を付けます。
          </para>
         </listitem>
         <listitem>
          <para>
<!--
           <literal>(</literal> - this replaces the minus sign in front of the
           negative number. The minus sign will not appear.
-->
           <literal>(</literal> - これは負の値の先頭のマイナス記号を置き換えます。
マイナス記号は現れません。
          </para>
         </listitem>
         <listitem>
          <para>
<!--
           <literal>)</literal> - this character replaces the minus and is
           printed behind the negative value.
-->
           <literal>)</literal> - この文字はマイナス記号を置き換え、負の値の最後に出力します。
          </para>
         </listitem>
         <listitem>
          <para>
<!--
           <literal>$</literal> - the currency symbol.
-->
           <literal>$</literal> - 通貨記号
          </para>
         </listitem>
        </itemizedlist>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rupshift</></term>
      <listitem>
       <para>
<!--
        Convert a string to upper case.
-->
文字列を大文字に変換します。
<synopsis>
void rupshift(char *str);
</synopsis>
<!--
        The function receives a pointer to the string and transforms every
        lower case character to upper case.
-->
この関数は文字列へのポインタを受付け、すべての小文字を大文字に変換します。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>byleng</></term>
      <listitem>
       <para>
<!--
        Return the number of characters in a string without counting trailing
        blanks.
-->
文字列内の文字数を返します。
ただし、末尾の空白は数えません。
<synopsis>
int byleng(char *str, int len);
</synopsis>
<!--
        The function expects a fixed-length string as its first argument
        (<literal>str</>) and its length as its second argument
        (<literal>len</>). It returns the number of significant characters,
        that is the length of the string without trailing blanks.
-->
この関数は最初の引数として、固定長の文字列(<literal>str</>)を、2番目の引数としてその文字列長 (<literal>len</>)想定しています。
これは、文字列から末尾の空白を取り除いた、有効文字の数を返します。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>ldchar</></term>
      <listitem>
       <para>
<!--
        Copy a fixed-length string into a null-terminated string.
-->
固定長の文字列をNULL終端の文字列に複製します。
<synopsis>
void ldchar(char *src, int len, char *dest);
</synopsis>
<!--
        The function receives the fixed-length string to copy
        (<literal>src</>), its length (<literal>len</>) and a pointer to the
        destination memory (<literal>dest</>). Note that you need to reserve at
        least <literal>len+1</> bytes for the string that <literal>dest</>
        points to. The function copies at most <literal>len</> bytes to the new
        location (less if the source string has trailing blanks) and adds the
        null-terminator.
-->
この関数はコピー対象の固定長の文字列(<literal>src</>)、文字列長(<literal>len</>)、格納先メモリ(<literal>dest</>)へのポインタを受付けます。
<literal>dest</>が指し示す文字列には少なくとも<literal>len+1</>バイトを割り当てなければならない点に注意してください。
この関数は多くても<literal>len</>バイトを新しい場所にコピーします。
（元の文字列が末尾に空白文字を持つ場合に少なくなります。）
そして、NULL終端を付与します。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rgetmsg</></term>
      <listitem>
       <para>
<synopsis>
int rgetmsg(int msgnum, char *s, int maxsize);
</synopsis>
<!--
        This function exists but is not implemented at the moment!
-->
この関数は存在しますが、現在実装されていません。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rtypalign</></term>
      <listitem>
       <para>
<synopsis>
int rtypalign(int offset, int type);
</synopsis>
<!--
        This function exists but is not implemented at the moment!
-->
この関数は存在しますが、現在実装されていません。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rtypmsize</></term>
      <listitem>
       <para>
<synopsis>
int rtypmsize(int type, int len);
</synopsis>
<!--
        This function exists but is not implemented at the moment!
-->
この関数は存在しますが、現在実装されていません。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rtypwidth</></term>
      <listitem>
       <para>
<synopsis>
int rtypwidth(int sqltype, int sqllen);
</synopsis>
<!--
        This function exists but is not implemented at the moment!
-->
この関数は存在しますが、現在実装されていません。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="rsetnull">
      <term><function>rsetnull</></term>
      <listitem>
       <para>
<!--
        Set a variable to NULL.
-->
変数にNULLを設定します。
<synopsis>
int rsetnull(int t, char *ptr);
</synopsis>
<!--
        The function receives an integer that indicates the type of the
        variable and a pointer to the variable itself that is cast to a C
        char* pointer.
-->
この関数は、変数の種類を示す整数とC char*にキャストした変数自体へのポインタを受付けます。
       </para>
       <para>
<!--
        The following types exist:
-->
以下の種類が存在します。
        <itemizedlist>
         <listitem>
          <para>
<!--
           <literal>CCHARTYPE</literal> - For a variable of type <type>char</type> or <type>char*</type>
-->
           <literal>CCHARTYPE</literal> - <type>char</type>または <type>char*</type>型の変数用
          </para>
         </listitem>
         <listitem>
          <para>
<!--
           <literal>CSHORTTYPE</literal> - For a variable of type <type>short int</type>
-->
           <literal>CSHORTTYPE</literal> - <type>short int</type>型の変数用
          </para>
         </listitem>
         <listitem>
          <para>
<!--
           <literal>CINTTYPE</literal> - For a variable of type <type>int</type>
-->
           <literal>CINTTYPE</literal> - <type>int</type>型の変数用
          </para>
         </listitem>
         <listitem>
          <para>
<!--
           <literal>CBOOLTYPE</literal> - For a variable of type <type>boolean</type>
-->
           <literal>CBOOLTYPE</literal> - <type>boolean</type>型の変数用
          </para>
         </listitem>
         <listitem>
          <para>
<!--
           <literal>CFLOATTYPE</literal> - For a variable of type <type>float</type>
-->
           <literal>CFLOATTYPE</literal> - <type>float</type>型の変数用
          </para>
         </listitem>
         <listitem>
          <para>
<!--
           <literal>CLONGTYPE</literal> - For a variable of type <type>long</type>
-->
           <literal>CLONGTYPE</literal> - <type>long</type>型の変数用
          </para>
         </listitem>
         <listitem>
          <para>
<!--
           <literal>CDOUBLETYPE</literal> - For a variable of type <type>double</type>
-->
           <literal>CDOUBLETYPE</literal> - <type>double</type>型の変数用
          </para>
         </listitem>
         <listitem>
          <para>
<!--
           <literal>CDECIMALTYPE</literal> - For a variable of type <type>decimal</type>
-->
           <literal>CDECIMALTYPE</literal> - <type>decimal</type>型の変数用
          </para>
         </listitem>
         <listitem>
          <para>
<!--
           <literal>CDATETYPE</literal> - For a variable of type <type>date</type>
-->
           <literal>CDATETYPE</literal> - <type>date</type>型の変数用
          </para>
         </listitem>
         <listitem>
          <para>
<!--
           <literal>CDTIMETYPE</literal> - For a variable of type <type>timestamp</type>
-->
           <literal>CDTIMETYPE</literal> - <type>timestamp</type>型の変数用
          </para>
         </listitem>
        </itemizedlist>
       </para>

       <para>
<!--
        Here is an example of a call to this function:
-->
以下にこの関数の呼び出し例を示します。
<programlisting><![CDATA[
$char c[] = "abc       ";
$short s = 17;
$int i = -74874;

rsetnull(CCHARTYPE, (char *) c);
rsetnull(CSHORTTYPE, (char *) &s);
rsetnull(CINTTYPE, (char *) &i);
]]>
</programlisting>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>risnull</></term>
      <listitem>
       <para>
<!--
        Test if a variable is NULL.
-->
変数がNULLか検査します。
<synopsis>
int risnull(int t, char *ptr);
</synopsis>
<!--
        The function receives the type of the variable to test (<literal>t</>)
        as well a pointer to this variable (<literal>ptr</>). Note that the
        latter needs to be cast to a char*. See the function <xref
        linkend="rsetnull"> for a list of possible variable types.
-->
この関数は検査する変数の種類(<literal>t</>)、変数(<literal>ptr</>)へのポインタを受付けます。
後者はchar*にキャストする必要があることに注意してください。
取り得る変数種類については <xref linkend="rsetnull">関数を参照してください。
       </para>
       <para>
<!--
        Here is an example of how to use this function:
-->
この関数の使用方法の例を示します。
<programlisting><![CDATA[
$char c[] = "abc       ";
$short s = 17;
$int i = -74874;

risnull(CCHARTYPE, (char *) c);
risnull(CSHORTTYPE, (char *) &s);
risnull(CINTTYPE, (char *) &i);
]]>
</programlisting>
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </sect2>

  <sect2 id="ecpg-informix-constants">
<!--
   <title>Additional Constants</title>
-->
   <title>追加の定数</title>
   <para>
<!--
    Note that all constants here describe errors and all of them are defined
    to represent negative values. In the descriptions of the different
    constants you can also find the value that the constants represent in the
    current implementation. However you should not rely on this number. You can
    however rely on the fact all of them are defined to represent negative
    values.
-->
ここで示す定数はすべてエラーを示すものであり、負の値を表すように定義されていることに注意してください。
また、他の定数の説明では、現在の実装で定数が表す数値がわかります。
しかし、この数値に依存してはなりません。
しかし、これらのすべてが負の値であることに依存することは可能です。
    <variablelist>
     <varlistentry>
      <term><literal>ECPG_INFORMIX_NUM_OVERFLOW</></term>
      <listitem>
       <para>
<!--
        Functions return this value if an overflow occurred in a
        calculation. Internally it is defined as -1200 (the <productname>Informix</productname>
        definition).
-->
計算時にオーバーフローが発生した場合、関数はこの値を返します。
内部的には-1200（<productname>Informix</productname>の定義）と定義されています。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_NUM_UNDERFLOW</></term>
      <listitem>
       <para>
<!--
        Functions return this value if an underflow occurred in a calculation.
        Internally it is defined as -1201 (the <productname>Informix</productname> definition).
-->
計算時にアンダーフローが発生した場合、関数はこの値を返します。
内部的には-1201（<productname>Informix</productname>の定義）と定義されています。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_DIVIDE_ZERO</></term>
      <listitem>
       <para>
<!--
        Functions return this value if an attempt to divide by zero is
        observed. Internally it is defined as -1202 (the <productname>Informix</productname> definition).
-->
計算時にゼロ除算が発生した場合、関数はこの値を返します。
内部的には-1202（<productname>Informix</productname>の定義）と定義されています。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_BAD_YEAR</></term>
      <listitem>
       <para>
<!--
        Functions return this value if a bad value for a year was found while
        parsing a date. Internally it is defined as -1204 (the <productname>Informix</productname>
        definition).
-->
日付の解析時に年の値が不正であった場合、関数はこの値を返します。
内部的には-1204（<productname>Informix</productname>の定義）と定義されています。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_BAD_MONTH</></term>
      <listitem>
       <para>
<!--
        Functions return this value if a bad value for a month was found while
        parsing a date. Internally it is defined as -1205 (the <productname>Informix</productname>
        definition).
-->
日付の解析時に月の値が不正であった場合、関数はこの値を返します。
内部的には-1205（<productname>Informix</productname>の定義）と定義されています。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_BAD_DAY</></term>
      <listitem>
       <para>
<!--
        Functions return this value if a bad value for a day was found while
        parsing a date. Internally it is defined as -1206 (the <productname>Informix</productname>
        definition).
-->
日付の解析時に日の値が不正であった場合、関数はこの値を返します。
内部的には-1206（<productname>Informix</productname>の定義）と定義されています。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_ENOSHORTDATE</></term>
      <listitem>
       <para>
<!--
        Functions return this value if a parsing routine needs a short date
        representation but did not get the date string in the right length.
        Internally it is defined as -1209 (the <productname>Informix</productname> definition).
-->
解析処理が短縮日付表現を必要としているが、正しい長さの日付文字列が得られなかった場合、関数はこの値を返します。
内部的には-1209（<productname>Informix</productname>の定義）と定義されています。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_DATE_CONVERT</></term>
      <listitem>
       <para>
<!--
        Functions return this value if an error occurred during date
        formatting.  Internally it is defined as -1210 (the
        <productname>Informix</productname> definition).
-->
日付の書式付けの時にエラーが発生した場合、関数はこの値を返します。
内部的には-1210（<productname>Informix</productname>の定義）と定義されています。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_OUT_OF_MEMORY</></term>
      <listitem>
       <para>
<!--
        Functions return this value if memory was exhausted during
        their operation.  Internally it is defined as -1211 (the
        <productname>Informix</productname> definition).
-->
操作時にメモリが不足した場合、関数はこの値を返します。
内部的には-1211（<productname>Informix</productname>の定義）と定義されています。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_ENOTDMY</></term>
      <listitem>
       <para>
<!--
        Functions return this value if a parsing routine was supposed to get a
        format mask (like <literal>mmddyy</>) but not all fields were listed
        correctly. Internally it is defined as -1212 (the <productname>Informix</productname> definition).
-->
解析処理が書式マスク（<literal>mmddyy</>のような）が存在することを前提としているが、すべてのフィールドが正しく列挙されていない場合、関数はこの値を返します。
内部的には-1212（<productname>Informix</productname>の定義）と定義されています。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_BAD_NUMERIC</></term>
      <listitem>
       <para>
<!--
        Functions return this value either if a parsing routine cannot parse
        the textual representation for a numeric value because it contains
        errors or if a routine cannot complete a calculation involving numeric
        variables because at least one of the numeric variables is invalid.
        Internally it is defined as -1213 (the <productname>Informix</productname> definition).
-->
解析処理がエラーのため数値のテキスト表現を解析できなかった場合や数値変数の少なくとも1つが無効のため数値変数を使用した計算を完了できなかった場合、関数はこの値を返します。
内部的には-1213（<productname>Informix</productname>の定義）と定義されています。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_BAD_EXPONENT</></term>
      <listitem>
       <para>
<!--
        Functions return this value if a parsing routine cannot parse
        an exponent.  Internally it is defined as -1216 (the
        <productname>Informix</productname> definition).
-->
解析処理が指数の解析を行うことができなかった場合、関数はこの値を返します。
内部的には-1216（<productname>Informix</productname>の定義）と定義されています。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_BAD_DATE</></term>
      <listitem>
       <para>
<!--
        Functions return this value if a parsing routine cannot parse
        a date.  Internally it is defined as -1218 (the
        <productname>Informix</productname> definition).
-->
解析処理が日付を解析できなかった場合、関数はこの値を返します。
内部的には-1218（<productname>Informix</productname>の定義）と定義されています。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_EXTRA_CHARS</></term>
      <listitem>
       <para>
<!--
        Functions return this value if a parsing routine is passed extra
        characters it cannot parse.  Internally it is defined as -1264 (the
        <productname>Informix</productname> definition).
-->
解析処理が追加の文字列を解析できなかった場合、関数はこの値を返します。
内部的には-1264（<productname>Informix</productname>の定義）と定義されています。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </sect2>
 </sect1>

 <sect1 id="ecpg-develop">
<!--
  <title>Internals</title>
-->
  <title>内部</title>

  <para>
<!--
   This section explains how <application>ECPG</application> works
   internally. This information can occasionally be useful to help
   users understand how to use <application>ECPG</application>.
-->
本節では内部的な<application>ECPG</application>の動作を説明します。
この情報は<application>ECPG</application>の使用方法を理解する手助けとして有用なことがあります。
  </para>

   <para>
<!--
    The first four lines written by <command>ecpg</command> to the
    output are fixed lines.  Two are comments and two are include
    lines necessary to interface to the library.  Then the
    preprocessor reads through the file and writes output.  Normally
    it just echoes everything to the output.
-->
<command>ecpg</command>によって出力に書き込まれる最初の4行は固定されています。
2行はコメントで、残り2行はライブラリとのインタフェースのために必要なインクルード行です。
その後、プリプロセッサはファイル全体を読み取り、出力に書き出します。
通常は、単にすべてそのまま出力に書き出します。
   </para>

   <para>
<!--
    When it sees an <command>EXEC SQL</command> statement, it
    intervenes and changes it. The command starts with <command>EXEC
    SQL</command> and ends with <command>;</command>. Everything in
    between is treated as an <acronym>SQL</acronym> statement and
    parsed for variable substitution.
-->
<command>EXEC SQL</command>を検出すると、間に入り、それを変更します。
このコマンドは<command>EXEC SQL</command>で始まり、<command>;</command>で終わります。
この間のすべては<acronym>SQL</acronym>文として扱われ、変数の置換のために解析されます。
   </para>

   <para>
<!--
    Variable substitution occurs when a symbol starts with a colon
    (<literal>:</literal>). The variable with that name is looked up
    among the variables that were previously declared within a
    <literal>EXEC SQL DECLARE</> section.
-->
変数置換は、シンボルがコロン（<literal>:</literal>）から始まる場合に発生します。
その名前の変数が、<literal>EXEC SQL DECLARE</>セクションで事前に宣言された変数の中から検索されます。
   </para>

   <para>
<!--
    The most important function in the library is
    <function>ECPGdo</function>, which takes care of executing most
    commands. It takes a variable number of arguments. This can easily
    add up to 50 or so arguments, and we hope this will not be a
    problem on any platform.
-->
ライブラリ内で最も重要な関数は<function>ECPGdo</function>です。
これが、ほとんどのコマンドの実行を管理します。
可変長の引数をとります。
すべてのプラットフォームで問題にならないことを祈っていますが、これは50程度の引数まで簡単に追加できます。
   </para>

   <para>
<!--
    The arguments are:
-->
引数を以下に示します。

    <variablelist>
     <varlistentry>
<!--
      <term>A line number</term>
-->
      <term>行番号</term>
      <listitem>
       <para>
<!--
        This is the line number of the original line; used in error
        messages only.
-->
元の行の行番号です。
エラーメッセージ内でのみ使用されます。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--
      <term>A string</term>
-->
      <term>文字列</term>
      <listitem>
       <para>
<!--
        This is the <acronym>SQL</acronym> command that is to be issued.
        It is modified by the input variables, i.e., the variables that
        where not known at compile time but are to be entered in the
        command. Where the variables should go the string contains
        <literal>?</literal>.
-->
発行すべき<acronym>SQL</acronym>コマンドです。
入力変数、つまり、コンパイル時に未知だったがそのコマンド内に与えるべき変数によって変更されます。
変数が文字列内に挿入される箇所は<literal>?</literal>となっています。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--
      <term>Input variables</term>
-->
      <term>入力変数</term>
      <listitem>
       <para>
<!--
        Every input variable causes ten arguments to be created.  (See below.)
-->
        すべての入力変数は10個の引数を作成します（後述）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><parameter>ECPGt_EOIT</></term>
      <listitem>
       <para>
<!--
        An <type>enum</> telling that there are no more input
        variables.
-->
        入力変数がもうないことを表す<type>enum</>です。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--
      <term>Output variables</term>
-->
<term>出力変数</term>
      <listitem>
       <para>
<!--
        Every output variable causes ten arguments to be created.
        (See below.)  These variables are filled by the function.
-->
すべての出力変数は10個の引数を作成します（後述）。
これらの変数は関数によって埋められます。
       </para>
      </listitem>
     </varlistentry>

      <varlistentry>
       <term><parameter>ECPGt_EORT</></term>
       <listitem>
       <para>
<!--
        An <type>enum</> telling that there are no more variables.
-->
        変数がもうないことを表す<type>enum</>です。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>

   <para>
<!--
    For every variable that is part of the <acronym>SQL</acronym>
    command, the function gets ten arguments:
-->
<acronym>SQL</acronym>コマンドの一部となるすべての変数に対して、この関数は以下の10個の引数を生成します。

    <orderedlist>
     <listitem>
      <para>
<!--
       The type as a special symbol.
-->
特別シンボルとしての型。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       A pointer to the value or a pointer to the pointer.
-->
値へのポインタ、もしくはポインタのポインタ。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       The size of the variable if it is a <type>char</type> or <type>varchar</type>.
-->
変数が<type>char</type>か<type>varchar</type>の場合はそのサイズ。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       The number of elements in the array (for array fetches).
-->
配列の要素数（配列取り出し用）。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       The offset to the next element in the array (for array fetches).
-->
配列の次の要素のオフセット（配列取り出し用）。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       The type of the indicator variable as a special symbol.
-->
特別シンボルとしての指示子変数の型。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       A pointer to the indicator variable.
-->
指示子変数へのポインタ。
      </para>
     </listitem>

     <listitem>
      <para>
       0
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       The number of elements in the indicator array (for array fetches).
-->
指示子配列内の要素数（配列取り出し用）。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       The offset to the next element in the indicator array (for
       array fetches).
-->
指示子配列内の次要素へのオフセット（配列取り出し用）。
      </para>
     </listitem>
    </orderedlist>
   </para>

   <para>
<!--
    Note that not all SQL commands are treated in this way.  For
    instance, an open cursor statement like:
-->
すべてのSQLコマンドがこの方法で扱われるわけではないことに注意してください。
例えば、以下のカーソルを開くSQL文は出力にコピーされません。
<programlisting>
EXEC SQL OPEN <replaceable>cursor</replaceable>;
</programlisting>
<!--
    is not copied to the output. Instead, the cursor's
    <command>DECLARE</> command is used at the position of the <command>OPEN</> command
    because it indeed opens the cursor.
-->
その代わりにカーソルの<command>DECLARE</>コマンドが<command>OPEN</>コマンドの場所で使用されます。
実際にこのコマンドがカーソルを開くからです。
   </para>

   <para>
<!--
    Here is a complete example describing the output of the
    preprocessor of a file <filename>foo.pgc</filename> (details might
    change with each particular version of the preprocessor):
-->
以下に、<filename>foo.pgc</filename>ファイルに対するプリプロセッサの出力を完全に説明する例を示します
（プリプロセッサのバージョンによって詳細が異なっているかもしれません）。
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
int index;
int result;
EXEC SQL END DECLARE SECTION;
...
EXEC SQL SELECT res INTO :result FROM mytable WHERE index = :index;
</programlisting>
<!--
    is translated into:
-->
これは以下に翻訳されます。
<programlisting><![CDATA[
/* Processed by ecpg (2.6.0) */
/* These two include files are added by the preprocessor */
#include <ecpgtype.h>;
#include <ecpglib.h>;

/* exec sql begin declare section */

#line 1 "foo.pgc"

 int index;
 int result;
/* exec sql end declare section */
...
ECPGdo(__LINE__, NULL, "SELECT res FROM mytable WHERE index = ?     ",
        ECPGt_int,&(index),1L,1L,sizeof(int),
        ECPGt_NO_INDICATOR, NULL , 0L, 0L, 0L, ECPGt_EOIT,
        ECPGt_int,&(result),1L,1L,sizeof(int),
        ECPGt_NO_INDICATOR, NULL , 0L, 0L, 0L, ECPGt_EORT);
#line 147 "foo.pgc"
]]>
</programlisting>
<!--
    (The indentation here is added for readability and not
    something the preprocessor does.)
-->
ここで可読性のためにインデントを付けています。
プリプロセッサが行ったものではありません。
   </para>
 </sect1>
</chapter>
