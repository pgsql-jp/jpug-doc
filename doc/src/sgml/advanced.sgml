<!-- doc/src/sgml/advanced.sgml -->

 <chapter id="tutorial-advanced">
<!--
  <title>Advanced Features</title>
-->
  <title>高度な諸機能</title>

  <sect1 id="tutorial-advanced-intro">
<!--
   <title>Introduction</title>
-->
   <title>はじめに</title>

   <para>
<!--
    In the previous chapter we have covered the basics of using
    <acronym>SQL</acronym> to store and access your data in
    <productname>PostgreSQL</productname>.  We will now discuss some
    more advanced features of <acronym>SQL</acronym> that simplify
    management and prevent loss or corruption of your data.  Finally,
    we will look at some <productname>PostgreSQL</productname>
    extensions.
-->
前章では、<productname>PostgreSQL</productname>で<acronym>SQL</acronym>を使用してデータを保存したりアクセスしたりする基本について説明しました。
ここでは、管理を単純化しデータの喪失や破壊を防止する<acronym>SQL</acronym>のいくつかのより高度な機能について論議します。
最後に<productname>PostgreSQL</productname>が拡張しているいくらかの機能に触れます。
   </para>

   <para>
<!--
    This chapter will on occasion refer to examples found in <xref
    linkend="tutorial-sql"> to change or improve them, so it will be
    useful to have read that chapter.  Some examples from
    this chapter can also be found in
    <filename>advanced.sql</filename> in the tutorial directory.  This
    file also contains some sample data to load, which is not
    repeated here.  (Refer to <xref linkend="tutorial-sql-intro"> for
    how to use the file.)
-->
本章では折々<xref linkend="tutorial-sql">にある例題に変更や改善を加えますので、その章を読んでおくことは役立ちます。
本章にあるいくつかの例題は、配付物を解凍した時にできるsrc/tutorialディレクトリの<filename>advanced.sql</filename>に入っています。ここでは繰り返しませんが、このファイルにはロードして使ってみることができるサンプルデータもあります。
（ファイルの使い方は<xref linkend="tutorial-sql-intro">を参照してください。）
   </para>
  </sect1>


  <sect1 id="tutorial-views">
<!--
   <title>Views</title>
-->
   <title>ビュー</title>

   <indexterm zone="tutorial-views">
<!--
    <primary>view</primary>
-->
    <primary>ビュー</primary>
   </indexterm>

   <para>
<!--
    Refer back to the queries in <xref linkend="tutorial-join">.
    Suppose the combined listing of weather records and city location
    is of particular interest to your application, but you do not want
    to type the query each time you need it.  You can create a
    <firstterm>view</firstterm> over the query, which gives a name to
    the query that you can refer to like an ordinary table:
-->
<xref linkend="tutorial-join">の問い合わせをもう一度参照してください。
天候の記録と都市の所在場所の組み合わせ一覧を得ることが今作っているアプリケーションにとって特に重要なのですが、この組み合わせの一覧を必要とする度に問い合わせを打ち込みたくはないとしましょう。
結果を求める問い合わせに対して<firstterm>ビュー</firstterm>を作成し、名前を付けると、通常のテーブル参照のように結果を入手できるようになります。

<programlisting>
CREATE VIEW myview AS
    SELECT city, temp_lo, temp_hi, prcp, date, location
        FROM weather, cities
        WHERE city = name;

SELECT * FROM myview;
</programlisting>
   </para>

   <para>
<!--
    Making liberal use of views is a key aspect of good SQL database
    design.  Views allow you to encapsulate the details of the
    structure of your tables, which might change as your application
    evolves, behind consistent interfaces.
-->
SQLデータベースを設計する上で押さえておかなければならないのは、ビューを自由に使えるようにするという項目です。
ビューはテーブル構造の詳細をカプセル化しますので、アプリケーションが発展するに従いテーブル構造が変わったとしても、一貫したインタフェースを保てます。
   </para>

   <para>
<!--
    Views can be used in almost any place a real table can be used.
    Building views upon other views is not uncommon.
-->
ビューは実テーブルが使用できるほとんどの場合で使えます。他のビューに対するビューの作成も珍しくはありません。
   </para>
  </sect1>


  <sect1 id="tutorial-fk">
<!--
   <title>Foreign Keys</title>
-->
   <title>外部キー</title>

   <indexterm zone="tutorial-fk">
<!--
    <primary>foreign key</primary>
-->
    <primary>外部キー</primary>
   </indexterm>

   <indexterm zone="tutorial-fk">
<!--
    <primary>referential integrity</primary>
-->
   <primary>参照整合性</primary>
   </indexterm>

   <para>
<!--
    Recall the <classname>weather</classname> and
    <classname>cities</classname> tables from <xref
    linkend="tutorial-sql">.  Consider the following problem:  You
    want to make sure that no one can insert rows in the
    <classname>weather</classname> table that do not have a matching
    entry in the <classname>cities</classname> table.  This is called
    maintaining the <firstterm>referential integrity</firstterm> of
    your data.  In simplistic database systems this would be
    implemented (if at all) by first looking at the
    <classname>cities</classname> table to check if a matching record
    exists, and then inserting or rejecting the new
    <classname>weather</classname> records.  This approach has a
    number of problems and is very inconvenient, so
    <productname>PostgreSQL</productname> can do this for you.
-->
<xref linkend="tutorial-sql">の<classname>weather</classname>テーブルと<classname>cities</classname>テーブルを思い出してください。
次のような問題点を考えてみましょう。
<classname>cities</classname>テーブルに一致する項目がない行は絶対に<classname>weather</classname>テーブルに挿入できなくしたいとします。
これをデータの<firstterm>参照整合性</firstterm>の保全と呼びます。
最も単純なデータベースシステムでは<classname>cities</classname>テーブルに一致する行が存在するかどうかを最初に検証してから<classname>weather</classname>テーブルに新規レコードを追加するか否かを実装しなければなりません。
この手法には多くの問題があること、そしてとても不便であることから、<productname>PostgreSQL</productname>に代わって作業させることができます。
   </para>

   <para>
<!--
    The new declaration of the tables would look like this:
-->
新規のテーブルの宣言は以下のようになります。

<programlisting>
CREATE TABLE cities (
        city     varchar(80) primary key,
        location point
);

CREATE TABLE weather (
        city      varchar(80) references cities(city),
        temp_lo   int,
        temp_hi   int,
        prcp      real,
        date      date
);
</programlisting>

<!--
    Now try inserting an invalid record:
-->
では無効なレコードを挿入してみましょう。

<programlisting>
INSERT INTO weather VALUES ('Berkeley', 45, 53, 0.0, '1994-11-28');
</programlisting>

<screen>
ERROR:  insert or update on table "weather" violates foreign key constraint "weather_city_fkey"
DETAIL:  Key (city)=(Berkeley) is not present in table "cities".
</screen>
   </para>

   <para>
<!--
    The behavior of foreign keys can be finely tuned to your
    application.  We will not go beyond this simple example in this
    tutorial, but just refer you to <xref linkend="ddl">
    for more information.  Making correct use of
    foreign keys will definitely improve the quality of your database
    applications, so you are strongly encouraged to learn about them.
-->
外部キーによる振舞いでアプリケーションが見事にチューニングされました。
このチュートリアルではこの簡単な例題より先には進みませんが、さらに情報がほしい方は<xref linkend="ddl">をご覧ください。
外部キーを正しく使用するようにすると、間違いなくデータベースアプリケーションの質を向上させますので身に付くように励んでください。
   </para>
  </sect1>


  <sect1 id="tutorial-transactions">
<!--
   <title>Transactions</title>
-->
   <title>トランザクション</title>

   <indexterm zone="tutorial-transactions">
<!--
    <primary>transaction</primary>
-->
    <primary>トランザクション</primary>
   </indexterm>

   <para>
<!--
    <firstterm>Transactions</> are a fundamental concept of all database
    systems.  The essential point of a transaction is that it bundles
    multiple steps into a single, all-or-nothing operation.  The intermediate
    states between the steps are not visible to other concurrent transactions,
    and if some failure occurs that prevents the transaction from completing,
    then none of the steps affect the database at all.
-->
<firstterm>トランザクション</firstterm>は全てのデータベースシステムで基礎となる概念です。
トランザクションの基本的要点は複数の手順を単一の「全てかなしか」の操作にまとめ上げることです。
手順の進行途中の状態は他の動いているトランザクションからは見えません。そして、何らかのエラーが起こるとトランザクションは完結しません。ですからデータベースはエラーの原因となった手順によってまったく影響されることはありません。
   </para>

   <para>
<!--
    For example, consider a bank database that contains balances for various
    customer accounts, as well as total deposit balances for branches.
    Suppose that we want to record a payment of $100.00 from Alice's account
    to Bob's account.  Simplifying outrageously, the SQL commands for this
    might look like:
-->
例を挙げましょう。ある銀行のデータベースでそこに多数の顧客の口座の残高と支店の総預金残高が記録されているとします。
アリスの口座からボブの口座に$100.00の送金があったことを記録したいとします。
ちょっと乱暴に単純化すると、このSQLは次のようになります。

<programlisting>
UPDATE accounts SET balance = balance - 100.00
    WHERE name = 'Alice';
UPDATE branches SET balance = balance - 100.00
    WHERE name = (SELECT branch_name FROM accounts WHERE name = 'Alice');
UPDATE accounts SET balance = balance + 100.00
    WHERE name = 'Bob';
UPDATE branches SET balance = balance + 100.00
    WHERE name = (SELECT branch_name FROM accounts WHERE name = 'Bob');
</programlisting>
   </para>

   <para>
<!--
    The details of these commands are not important here; the important
    point is that there are several separate updates involved to accomplish
    this rather simple operation.  Our bank's officers will want to be
    assured that either all these updates happen, or none of them happen.
    It would certainly not do for a system failure to result in Bob
    receiving $100.00 that was not debited from Alice.  Nor would Alice long
    remain a happy customer if she was debited without Bob being credited.
    We need a guarantee that if something goes wrong partway through the
    operation, none of the steps executed so far will take effect.  Grouping
    the updates into a <firstterm>transaction</> gives us this guarantee.
    A transaction is said to be <firstterm>atomic</>: from the point of
    view of other transactions, it either happens completely or not at all.
-->
書かれているSQLコマンドの詳しいことについて、ここでは重要でありません。
重要な点は、この単純な操作の目的を果たすため、複数の独立した更新手続きが関わっていることです。
銀行職員としてはこれら全ての更新が行われるかもしくはまったく行われないのかいずれかの確証が必要です。
$100.00がアリスの口座から引き落とされずにボブの口座に振り込まれるようなシステムの不備があってはなりません。
一方、$100.00がボブに振り込まれないでアリスの口座から引き落とされたとしたら、アリスはこの銀行のお得意様ではなくなるでしょうね。
操作の途中で一部不都合が発生した場合、結果に影響を与えるいかなる手続きも実行されないという確証が必要です。
更新手続きを<firstterm>トランザクション</>にグループ化すると、その確証が得られます。
あるトランザクションは他のトランザクションから見て完結するかまったく起こらなかったかという見方から<firstterm>原子的</firstterm>と呼ばれます。
   </para>

   <para>
<!--
    We also want a
    guarantee that once a transaction is completed and acknowledged by
    the database system, it has indeed been permanently recorded
    and won't be lost even if a crash ensues shortly thereafter.
    For example, if we are recording a cash withdrawal by Bob,
    we do not want any chance that the debit to his account will
    disappear in a crash just after he walks out the bank door.
    A transactional database guarantees that all the updates made by
    a transaction are logged in permanent storage (i.e., on disk) before
    the transaction is reported complete.
-->
もう一方で、いったんトランザクションが完結しデータベースシステムに承認された場合は、確実に恒久的に保存され、たとえ直後にクラッシュが起こったとしても記録は失われないという確証も必要です。
例えばボブが自分の口座から現金を引き落として店舗から立ち去った直後にボブの口座からの引き落とし記録がシステムのクラッシュで消えてしまうことは受け入れられません。
トランザクションが実装されているデータベースでは、あるトランザクションによる全ての更新がそのトランザクションを完結したと通知を行う前に永続的記録装置（すなわちディスク上）にログを書き込むことで保証しています。
   </para>

   <para>
<!--
    Another important property of transactional databases is closely
    related to the notion of atomic updates: when multiple transactions
    are running concurrently, each one should not be able to see the
    incomplete changes made by others.  For example, if one transaction
    is busy totalling all the branch balances, it would not do for it
    to include the debit from Alice's branch but not the credit to
    Bob's branch, nor vice versa.  So transactions must be all-or-nothing
    not only in terms of their permanent effect on the database, but
    also in terms of their visibility as they happen.  The updates made
    so far by an open transaction are invisible to other transactions
    until the transaction completes, whereupon all the updates become
    visible simultaneously.
-->
他にもトランザクション実装のデータベースの重要な特性は、原子的更新という概念に深く関係しています
。複数のトランザクションが同時に動作している時、それぞれのトランザクションは別のトランザクションが行っている未完了の変更を見ることができてはなりません。
例えば、あるトランザクションがすべての支店の残高を集計する作業を行なう場合、アリスの口座がある支店からの引き落としを勘定に入れませんし、ボブの口座がある支店への振り込みも勘定に入れません。もしくは両方とも勘定に入れます。
つまり、データベース上での恒久的効果という意味のみならず、一連の操作の過程で可視性ということにおいてもトランザクションは「すべて」か「なし」かでなければなりません。
作業中のトランザクションによる更新は、他のトランザクションからはトランザクションが完結するまで不可視です。
そのトランザクションが完結したその時点で、トランザクションが行った更新の全てが見えるようになります。
   </para>

   <para>
<!--
    In <productname>PostgreSQL</>, a transaction is set up by surrounding
    the SQL commands of the transaction with
    <command>BEGIN</> and <command>COMMIT</> commands.  So our banking
    transaction would actually look like:
-->
<productname>PostgreSQL</productname>ではトランザクションを構成するSQLコマンドを<command>BEGIN</command>と<command>COMMIT</command>で囲んで設定します。そうすると、この銀行取り引きのトランザクションの実際は次のようになります。

<programlisting>
BEGIN;
UPDATE accounts SET balance = balance - 100.00
    WHERE name = 'Alice';
<!--
&#045;- etc etc
-->
-- 等々
COMMIT;
</programlisting>
   </para>

   <para>
<!--
    If, partway through the transaction, we decide we do not want to
    commit (perhaps we just noticed that Alice's balance went negative),
    we can issue the command <command>ROLLBACK</> instead of
    <command>COMMIT</>, and all our updates so far will be canceled.
-->
トランザクション処理の途中でコミットを行わない（アリスの口座残高が足りなかったような場合）と判断した場合は、<command>COMMIT</command>ではなく<command>ROLLBACK</command>を使用して行った全ての更新を破棄します。
   </para>

   <para>
<!--
    <productname>PostgreSQL</> actually treats every SQL statement as being
    executed within a transaction.  If you do not issue a <command>BEGIN</>
    command,
    then each individual statement has an implicit <command>BEGIN</> and
    (if successful) <command>COMMIT</> wrapped around it.  A group of
    statements surrounded by <command>BEGIN</> and <command>COMMIT</>
    is sometimes called a <firstterm>transaction block</>.
-->
<productname>PostgreSQL</productname>は実際全てのSQL文をトランザクション内で実行するようになっています。
<command>BEGIN</command>を発行しないでも、それぞれの文は暗黙的に<command>BEGIN</command>が付いているとみなし、（成功すれば）<command>COMMIT</command>で囲まれているものとします。
<command>BEGIN</command>と<command>COMMIT</command>で囲まれた文のグループは<firstterm>トランザクションブロック</firstterm>と呼ばれることもあります。
   </para>

   <note>
    <para>
<!--
     Some client libraries issue <command>BEGIN</> and <command>COMMIT</>
     commands automatically, so that you might get the effect of transaction
     blocks without asking.  Check the documentation for the interface
     you are using.
-->
いくつかのクライアントライブラリは自動的に<command>BEGIN</command>と<command>COMMIT</command>コマンドを発行し、警告なしにトランザクションブロックが有効になります。
使用しているインタフェースのドキュメントで確認してください。
    </para>
   </note>

   <para>
<!--
    It's possible to control the statements in a transaction in a more
    granular fashion through the use of <firstterm>savepoints</>.  Savepoints
    allow you to selectively discard parts of the transaction, while
    committing the rest.  After defining a savepoint with
    <command>SAVEPOINT</>, you can if needed roll back to the savepoint
    with <command>ROLLBACK TO</>.  All the transaction's database changes
    between defining the savepoint and rolling back to it are discarded, but
    changes earlier than the savepoint are kept.
--> 
<firstterm>セーブポイント</>を使用することで、トランザクション内で文を、より粒度を細かく制御することが可能になります。
セーブポイントは、トランザクションを構成するある部分を選択的に破棄する一方、破棄されない残りの部分をコミットします。
<command>SAVEPOINT</>コマンドでセーブポイントを定義した後、必要であれば<command>ROLLBACK TO</>コマンドによりセーブポイントまでロールバックできます。
定義されたセーブポイントとロールバックするポイントとの間の全てのトランザクションのデータベースの変更は破棄されますが、セーブポイント以前の変更は保持されます。
   </para>

   <para>
<!--
    After rolling back to a savepoint, it continues to be defined, so you can
    roll back to it several times.  Conversely, if you are sure you won't need
    to roll back to a particular savepoint again, it can be released, so the
    system can free some resources.  Keep in mind that either releasing or
    rolling back to a savepoint
    will automatically release all savepoints that were defined after it.
-->
セーブポイントまでロールバックした後でもセーブポイントは定義されたままです。このため何度でもそこにロールバックできます。
逆に再度特定のセーブポイントにロールバックする必要がないのであれば、それを解除しシステムリソースを多少とも解放することができます。
あるセーブポイントを解除したりセーブポイントにロールバックすることにより、自動的にその後に定義されたすべてのセーブポイントが解除されることに注意してください。
   </para>

   <para>
<!--
    All this is happening within the transaction block, so none of it
    is visible to other database sessions.  When and if you commit the
    transaction block, the committed actions become visible as a unit
    to other sessions, while the rolled-back actions never become visible
    at all.
-->
これら全てはトランザクションブロック内で起こるので、他のデータベースセッションからは何も見えません。
トランザクションブロックをコミットした場合、他のセッションからはコミットされた行為が1つの単位として見えるようになりますが、ロールバックの行為は決して可視になりません。
   </para>

   <para>
<!--
    Remembering the bank database, suppose we debit $100.00 from Alice's
    account, and credit Bob's account, only to find later that we should
    have credited Wally's account.  We could do it using savepoints like
    this:
-->
銀行のデータベースを思い出してください。アリスの口座から$100.00を引き出してボブの口座に振り込むとします。後になってボブではなくウィリーの口座に振り込むべきだったと気が付きました。この場合セーブポイントを次のように使います。

<programlisting>
BEGIN;
UPDATE accounts SET balance = balance - 100.00
    WHERE name = 'Alice';
SAVEPOINT my_savepoint;
UPDATE accounts SET balance = balance + 100.00
    WHERE name = 'Bob';
<!--
&#045;- oops ... forget that and use Wally's account
-->
-- おっと、忘れるところだった。ウィリーの口座を使わなければ。
ROLLBACK TO my_savepoint;
UPDATE accounts SET balance = balance + 100.00
    WHERE name = 'Wally';
COMMIT;
</programlisting>
   </para>

   <para>
<!--
    This example is, of course, oversimplified, but there's a lot of control
    possible in a transaction block through the use of savepoints.
    Moreover, <command>ROLLBACK TO</> is the only way to regain control of a
    transaction block that was put in aborted state by the
    system due to an error, short of rolling it back completely and starting
    again.
-->
この例はもちろん極端に単純化していますが、セーブポイントの使用を通じてトランザクションブロック内で多くの可能な操作を行えることがわかります。
さらには何らかのエラーでシステムがトランザクションブロックを中断した場合、完全にロールバックして再び開始するのを除いて、<command>ROLLBACK TO</>コマンドがトランザクションブロックの制御を取り戻す唯一の手段です。
   </para>

  </sect1>


  <sect1 id="tutorial-window">
<!--
   <title>Window Functions</title>
-->
   <title>ウィンドウ関数</title>

   <indexterm zone="tutorial-window">
<!--
    <primary>window function</primary>
-->
    <primary>ウィンドウ関数</primary>
   </indexterm>

   <para>
<!--
    A <firstterm>window function</> performs a calculation across a set of
    table rows that are somehow related to the current row.  This is comparable
    to the type of calculation that can be done with an aggregate function.
    But unlike regular aggregate functions, use of a window function does not
    cause rows to become grouped into a single output row &mdash; the
    rows retain their separate identities.  Behind the scenes, the window
    function is able to access more than just the current row of the query
    result.
-->
<firstterm>ウィンドウ関数</>は現在の行に何らかとも関係するテーブル行の集合に渡って計算を行います。
これは集約関数により行われる計算の形式と似たようなものです。
とは言っても、通常の集約関数とは異なり、ウィンドウ関数の使用は単一出力行に行をグループ化しません。
行はそれぞれ個別の身元を維持します。
裏側では、ウィンドウ関数は問い合わせ結果による現在行だけでなく、それ以上の行にアクセスすることができます。
   </para>

   <para>
<!--
    Here is an example that shows how to compare each employee's salary
    with the average salary in his or her department:
-->
これはその部署の平均給与とそれぞれの従業員の給与をどのように比較するかを示した例です。

<programlisting>
SELECT depname, empno, salary, avg(salary) OVER (PARTITION BY depname) FROM empsalary;
</programlisting>

<screen>
  depname  | empno | salary |          avg          
-----------+-------+--------+-----------------------
 develop   |    11 |   5200 | 5020.0000000000000000
 develop   |     7 |   4200 | 5020.0000000000000000
 develop   |     9 |   4500 | 5020.0000000000000000
 develop   |     8 |   6000 | 5020.0000000000000000
 develop   |    10 |   5200 | 5020.0000000000000000
 personnel |     5 |   3500 | 3700.0000000000000000
 personnel |     2 |   3900 | 3700.0000000000000000
 sales     |     3 |   4800 | 4866.6666666666666667
 sales     |     1 |   5000 | 4866.6666666666666667
 sales     |     4 |   4800 | 4866.6666666666666667
(10 rows)
</screen>

<!--
    The first three output columns come directly from the table
    <structname>empsalary</>, and there is one output row for each row in the
    table.  The fourth column represents an average taken across all the table
    rows that have the same <structfield>depname</> value as the current row.
    (This actually is the same function as the regular <function>avg</>
    aggregate function, but the <literal>OVER</> clause causes it to be
    treated as a window function and computed across an appropriate set of
    rows.)
-->
最初の３つの出力列は、テーブル<structname>empsalary</>から直接もたらされ、テーブル内のそれぞれの行に対し１つの出力行が存在します。４番目の列は、現行の行と同じ<structfield>depname</>の値を持つ全てのテーブル行に渡って取得した平均値を表わしています。（これは実際、通常の<function>avg</>集約関数と同じですが、<literal>OVER</>句によりウィンドウ関数として扱われ、行の適切な集合に渡り計算されます。）
   </para>

   <para>
<!--
    A window function call always contains an <literal>OVER</> clause
    directly following the window function's name and argument(s).  This is what
    syntactically distinguishes it from a regular function or aggregate
    function.  The <literal>OVER</> clause determines exactly how the
    rows of the query are split up for processing by the window function.
    The <literal>PARTITION BY</> list within <literal>OVER</> specifies
    dividing the rows into groups, or partitions, that share the same
    values of the <literal>PARTITION BY</> expression(s).  For each row,
    the window function is computed across the rows that fall into the
    same partition as the current row.
-->
ウィンドウ関数呼び出しは常に、ウィンドウ関数名と引数に直接伴われた<literal>OVER</>句を含みます。
これが通常関数、または集約関数と構文的に区別されるところです。
<literal>OVER</>句は、ウィンドウ関数により処理のため問い合わせの行がどのように分解されるかを厳密に決定します。
<literal>OVER</>内の<literal>PARTITION BY</>リストは、行を<literal>PARTITION BY</>式の同じ値を共有するグループ、すなわちパーティションに分割する指定を行います。
それぞれの行に対し、ウィンドウ関数は現在行と同じパーティションに分類される行に渡って計算されます。
   </para>

   <para>
<!--
    You can also control the order in which rows are processed by
    window functions using <literal>ORDER BY</> within <literal>OVER</>.
    (The window <literal>ORDER BY</> does not even have to match the
    order in which the rows are output.)  Here is an example:
-->
<literal>OVER</>内で<literal>ORDER BY</>を使用することによりウィンドウ関数で処理される行の順序を制御することもできます。
（ウィンドウの<literal>ORDER BY</>は行が出力される順序に一致する必要すらありません。）
ここに例をあげます。

<programlisting>
SELECT depname, empno, salary,
       rank() OVER (PARTITION BY depname ORDER BY salary DESC)
FROM empsalary;
</programlisting>

<screen>
  depname  | empno | salary | rank 
-----------+-------+--------+------
 develop   |     8 |   6000 |    1
 develop   |    10 |   5200 |    2
 develop   |    11 |   5200 |    2
 develop   |     9 |   4500 |    4
 develop   |     7 |   4200 |    5
 personnel |     2 |   3900 |    1
 personnel |     5 |   3500 |    2
 sales     |     1 |   5000 |    1
 sales     |     4 |   4800 |    2
 sales     |     3 |   4800 |    2
(10 rows)
</screen>

<!--
    As shown here, the <function>rank</> function produces a numerical rank
    within the current row's partition for each distinct <literal>ORDER BY</>
    value, in the order defined by the <literal>ORDER BY</> clause.
    <function>rank</> needs no explicit parameter, because its behavior
    is entirely determined by the <literal>OVER</> clause.
-->
ここで示されたように、<function>rank</>関数は、それぞれの明確な<literal>ORDER BY</>の値に対する現在行のパーティション内における順位を、<literal>ORDER BY</>句で定義された順序で生成します。
<function>rank</>は明示的なパラメータを必要としません。この動作は<literal>OVER</>句により完全に決定されるためです。
   </para>

   <para>
<!--
    The rows considered by a window function are those of the <quote>virtual
    table</> produced by the query's <literal>FROM</> clause as filtered by its
    <literal>WHERE</>, <literal>GROUP BY</>, and <literal>HAVING</> clauses
    if any.  For example, a row removed because it does not meet the
    <literal>WHERE</> condition is not seen by any window function.
    A query can contain multiple window functions that slice up the data
    in different ways by means of different <literal>OVER</> clauses, but
    they all act on the same collection of rows defined by this virtual table.
-->
ウィンドウ関数で考慮される行は、もし存在するのであればその<literal>WHERE</>、<literal>GROUP BY</>、および<literal>HAVING</>句でフィルターをかけられた問い合わせの<literal>FROM</>句によって生成された<quote>仮想テーブル</>です。例えば、<literal>WHERE</>条件に一致しないため削除された行はウィンドウ関数では見つけることができません。異なった<literal>OVER</>句を用いて、異なった方法によりデータを分割する複数のウィンドウ関数を問い合わせが含んでも構いません。しかし、この仮想テーブルで定義された行の同一の集まり上で全てが作動します。
   </para>

   <para>
<!--
    We already saw that <literal>ORDER BY</> can be omitted if the ordering
    of rows is not important.  It is also possible to omit <literal>PARTITION
    BY</>, in which case there is just one partition containing all the rows.
-->
<literal>ORDER BY</>は、行の順序付けが重要でない場合割愛可能であることを見てきました。
<literal>PARTITION BY</>も同様に割愛することができます。
この場合、全ての行を含むたった一つのパーティションが存在します。
   </para>

   <para>
<!--
    There is another important concept associated with window functions:
    for each row, there is a set of rows within its partition called its
    <firstterm>window frame</>.  Many (but not all) window functions act only
    on the rows of the window frame, rather than of the whole partition.
    By default, if <literal>ORDER BY</> is supplied then the frame consists of
    all rows from the start of the partition up through the current row, plus
    any following rows that are equal to the current row according to the
    <literal>ORDER BY</> clause.  When <literal>ORDER BY</> is omitted the
    default frame consists of all rows in the partition.
-->
ウィンドウ関数に関連したその他の重要な概念があります。
それぞれの行に対して、その<firstterm>ウィンドウフレーム</>と呼ばれる、そのパーティション内の行の集合が存在します。
多くの（しかしすべてではありません）ウィンドウ関数は、パーティション全体ではなく、ウィンドウフレームの行のみに対して作用します。
デフォルトでは、<literal>ORDER BY</>が指定されると、フレームは、パーティションの始めから現在の行までのすべての行と、その後にある<literal>ORDER BY</>句に従って現在の行と等しい行から構成されます。
<literal>ORDER BY</>が省略された場合、デフォルトのフレームはそのパーティション内のすべての行を含みます。
     <footnote>
      <para>
<!--
       There are options to define the window frame in other ways, but
       this tutorial does not cover them.  See
       <xref linkend="syntax-window-functions"> for details.
-->
ほかの方法でウィンドウフレームを定義するいくつかのオプションがありますが、このチュートリアルでは扱いません。詳細は、<xref linkend="syntax-window-functions">を参照してください。
      </para>
     </footnote>
<!--
    Here is an example using <function>sum</>:
-->
<function>sum</>を使用した例を示します。
   </para>

<programlisting>
SELECT salary, sum(salary) OVER () FROM empsalary;
</programlisting>

<screen>
 salary |  sum  
--------+-------
   5200 | 47100
   5000 | 47100
   3500 | 47100
   4800 | 47100
   3900 | 47100
   4200 | 47100
   4500 | 47100
   4800 | 47100
   6000 | 47100
   5200 | 47100
(10 rows)
</screen>

   <para>
<!--
    Above, since there is no <literal>ORDER BY</> in the <literal>OVER</>
    clause, the window frame is the same as the partition, which for lack of
    <literal>PARTITION BY</> is the whole table; in other words each sum is
    taken over the whole table and so we get the same result for each output
    row.  But if we add an <literal>ORDER BY</> clause, we get very different
    results:
-->
上では、<literal>OVER</>句内に<literal>ORDER BY</>が存在しませんので、ウィンドウフレームはパーティションと同一です。またパーティションは<literal>PARTITION BY</>もありませんのでテーブル全体となります。言い換えると、総和はそれぞれ、テーブル全体に対して行われ、その結果、各出力行で同じ結果を得ることになります。しかし以下のように、<literal>ORDER BY</>句を加えると、非常に異なる結果を得ます。
   </para>

<programlisting>
SELECT salary, sum(salary) OVER (ORDER BY salary) FROM empsalary;
</programlisting>

<screen>
 salary |  sum  
--------+-------
   3500 |  3500
   3900 |  7400
   4200 | 11600
   4500 | 16100
   4800 | 25700
   4800 | 25700
   5000 | 30700
   5200 | 41100
   5200 | 41100
   6000 | 47100
(10 rows)
</screen>

   <para>
<!--
    Here the sum is taken from the first (lowest) salary up through the
    current one, including any duplicates of the current one (notice the
    results for the duplicated salaries).
-->
ここで、sumは最初の（最も低い）salaryから現在の行まで、現在のものと重複する全てを含んで、計算されます（重複するsalaryに対する結果に注意してください）。
   </para>

   <para>
<!--
    Window functions are permitted only in the <literal>SELECT</literal> list
    and the <literal>ORDER BY</> clause of the query. They are forbidden
    elsewhere, such as in <literal>GROUP BY</>, <literal>HAVING</>
    and <literal>WHERE</literal> clauses.  This is because they logically
    execute after the processing of those clauses.  Also, window functions
    execute after regular aggregate functions.  This means it is valid to
    include an aggregate function call in the arguments of a window function,
    but not vice versa.
-->
ウィンドウ関数は問い合わせの<literal>SELECT</literal>リストと<literal>ORDER BY</>句に限って許可されます。<literal>GROUP BY</>、<literal>HAVING</>、および<literal>WHERE</literal>のような句の中では禁止されています。その理由は、ウィンドウ関数は論理的に、ここに挙げたような句が処理された後に実行されるからです。
またウィンドウ関数は通常の集約関数の後に実行されます。
これが意味する所は、ウィンドウ関数の引数に集約関数呼び出しを含めても有効ですが、その逆は成り立たないと言うことです。
   </para>

   <para>
<!--
    If there is a need to filter or group rows after the window calculations
    are performed, you can use a sub-select.  For example:
-->
ウィンドウ演算が行われた後、行にフィルタ処理を行ったりグループ化を行う必要が生じた場合、副問い合わせを使用します。
例をあげます。

<programlisting>
SELECT depname, empno, salary, enroll_date
FROM
  (SELECT depname, empno, salary, enroll_date,
          rank() OVER (PARTITION BY depname ORDER BY salary DESC, empno) AS pos
     FROM empsalary
  ) AS ss
WHERE pos &lt; 3;
</programlisting>

<!--
    The above query only shows the rows from the inner query having
    <literal>rank</> less than 3.
-->
上記問い合わせは3より小さい<literal>rank</>を持った内部問い合わせからの行のみを表示します。
   </para>

   <para>
<!--
    When a query involves multiple window functions, it is possible to write
    out each one with a separate <literal>OVER</> clause, but this is
    duplicative and error-prone if the same windowing behavior is wanted
    for several functions.  Instead, each windowing behavior can be named
    in a <literal>WINDOW</> clause and then referenced in <literal>OVER</>.
    For example:
-->
問い合わせが複数のウィンドウ関数を含む場合、各ウィンドウ関数に異なる<literal>OVER</>句を記述することができます。しかし複数の関数で同じウィンドウ処理動作が必要な場合は重複となり、またエラーを招きがちです。代わりに<literal>WINDOW</>句でウィンドウ処理動作に名前を付け、これを<literal>OVER</>内で参照することができます。以下に例を示します。

<programlisting>
SELECT sum(salary) OVER w, avg(salary) OVER w
  FROM empsalary
  WINDOW w AS (PARTITION BY depname ORDER BY salary DESC);
</programlisting>
   </para>

   <para>
<!--
    More details about window functions can be found in
    <xref linkend="syntax-window-functions">,
    <xref linkend="functions-window">,
    <xref linkend="queries-window">, and the
    <xref linkend="sql-select"> reference page.
-->
ウィンドウ関数についてより詳細は、
    <xref linkend="syntax-window-functions">、
    <xref linkend="functions-window">、
    <xref linkend="queries-window">、および
    <xref linkend="sql-select"> マニュアルページにあります。
   </para>
  </sect1>


  <sect1 id="tutorial-inheritance">
<!--
   <title>Inheritance</title>
-->
   <title>継承</title>

   <indexterm zone="tutorial-inheritance">
<!--
    <primary>inheritance</primary>
-->
    <primary>継承</primary>
   </indexterm>

   <para>
<!--
    Inheritance is a concept from object-oriented databases.  It opens
    up interesting new possibilities of database design.
-->
継承とはオブジェクト指向データベースの概念です。
データベース設計においてこれまでになかった興味深い可能性を広げてくれます。
   </para>

   <para>
<!--
    Let's create two tables:  A table <classname>cities</classname>
    and a table <classname>capitals</classname>.  Naturally, capitals
    are also cities, so you want some way to show the capitals
    implicitly when you list all cities.  If you're really clever you
    might invent some scheme like this:
-->
2つのテーブルを作ってみましょう。<classname>cities（都市）</classname>テーブルと<classname>capitals（行政府所在地）</classname>テーブルです。行政府所在地は本来同時に都市でもありますので、全ての都市をリストする時は何もしなくても行政府所在地も表示する何らかの方法が必要です。賢い人なら次のような案を工夫するでしょう。

<programlisting>
CREATE TABLE capitals (
  name       text,
  population real,
<!--  altitude   int,    &#045;- (in ft) -->
  altitude   int,    -- （フィート単位）
  state      char(2)
);

CREATE TABLE non_capitals (
  name       text,
  population real,
<!--  altitude   int     &#045;- (in ft) -->
  altitude   int     -- （フィート単位）
);

CREATE VIEW cities AS
  SELECT name, population, altitude FROM capitals
    UNION
  SELECT name, population, altitude FROM non_capitals;
</programlisting>

<!--
    This works OK as far as querying goes, but it gets ugly when you
    need to update several rows, for one thing.
-->
問い合わせを続ける分には問題はありませんが、たった1つ、いくつか複数の行を更新する時に醜くなります。
   </para>

   <para>
<!--
    A better solution is this:
-->
より良い解決策は次のような構文です。

<programlisting>
CREATE TABLE cities (
  name       text,
  population real,
<!--  altitude   int     &#045;- (in ft) -->
  altitude   int     -- （フィート単位）
);

CREATE TABLE capitals (
  state      char(2)
) INHERITS (cities);
</programlisting>
   </para>

   <para>
<!--
    In this case, a row of <classname>capitals</classname>
    <firstterm>inherits</firstterm> all columns (<structfield>name</>,
    <structfield>population</>, and <structfield>altitude</>) from its
    <firstterm>parent</firstterm>, <classname>cities</classname>.  The
    type of the column <structfield>name</structfield> is
    <type>text</type>, a native <productname>PostgreSQL</productname>
    type for variable length character strings.  State capitals have
    an extra column, <structfield>state</>, that shows their state.  In
    <productname>PostgreSQL</productname>, a table can inherit from
    zero or more other tables.
-->
この例では、<classname>capitals（行政府所在地）</classname>テーブルの行は<firstterm>親</firstterm>の<classname>cities（都市）</classname>テーブルから全ての列、すなわち<structfield>name（都市名）</structfield>、<structfield>population（人口）</structfield>そして<structfield>altitude（標高）</structfield>を<firstterm>継承</firstterm>します。
<structfield>name</structfield>列のデータ型は、可変長文字列のために<productname>PostgreSQL</productname>が初めから備えている<type>text</type>型です。
州の行政府所在地のテーブルは、これに加えて州を示す<structfield>state</>列を持ちます。
<productname>PostgreSQL</productname>では、テーブルは関連付けられたテーブルがあればそれぞれから属性を継承することができます。
   </para>

   <para>
<!--
    For example, the  following  query finds the  names  of  all  cities,
    including  state capitals, that are located at an altitude
    over 500 feet:
-->
以下の問い合わせの例は、行政府所在地を含む標高500フィート以上に位置する全ての都市を求めるものです。

<programlisting>
SELECT name, altitude
  FROM cities
  WHERE altitude &gt; 500;
</programlisting>

<!--
    which returns:
-->
これは以下を返します。

<screen>
   name    | altitude
-----------+----------
 Las Vegas |     2174
 Mariposa  |     1953
 Madison   |      845
(3 rows)
</screen>
   </para>

   <para>
<!--
    On the other hand, the  following  query  finds
    all  the cities that are not state capitals and
    are situated at an altitude over 500 feet:
-->
その一方、行政府所在地ではない標高500フィート以上に位置する都市を見つけ出したい時は次のような問い合わせになります。

<programlisting>
SELECT name, altitude
    FROM ONLY cities
    WHERE altitude &gt; 500;
</programlisting>

<screen>
   name    | altitude
-----------+----------
 Las Vegas |     2174
 Mariposa  |     1953
(2 rows)
</screen>
   </para>

   <para>
<!--
    Here the <literal>ONLY</literal> before <literal>cities</literal>
    indicates that the query should be run over only the
    <classname>cities</classname> table, and not tables below
    <classname>cities</classname> in the inheritance hierarchy.  Many
    of the commands that we have already discussed &mdash;
    <command>SELECT</command>, <command>UPDATE</command>, and
    <command>DELETE</command> &mdash; support this <literal>ONLY</literal>
    notation.
-->
ここで<literal>cities（都市）</literal>の前に置かれた<literal>ONLY</literal>は、継承階層において<classname>cities（都市）</classname>テーブルの下層にあるテーブルではなく、<classname>cities（都市）</classname>テーブルのみを参照することを意味します。既に説明した<command>SELECT</command>、<command>UPDATE</command>および<command>DELETE</command>など数多くのコマンドは、この<literal>ONLY</literal>表記をサポートしています。
   </para>

   <note>
    <para>
<!--
     Although inheritance is frequently useful, it has not been integrated
     with unique constraints or foreign keys, which limits its usefulness.
     See <xref linkend="ddl-inherit"> for more detail.
-->
継承は便利ではありますが、一意性制約もしくは外部キーと一緒に使えないので万能ではありません。
詳細は<xref linkend="ddl-inherit">を参照してください。
    </para>
   </note>
  </sect1>


  <sect1 id="tutorial-conclusion">
<!--
   <title>Conclusion</title>
-->
   <title>まとめ</title>

   <para>
<!--
    <productname>PostgreSQL</productname> has many features not
    touched upon in this tutorial introduction, which has been
    oriented toward newer users of <acronym>SQL</acronym>.  These
    features are discussed in more detail in the remainder of this
    book.
-->
<acronym>SQL</acronym>初心者向けのこのチュートリアル入門では触れていない多くの機能が、<productname>PostgreSQL</productname>にはあります。
これらの機能は、本書の残りで詳しく説明します。
   </para>

   <para>
<!--
    If you feel you need more introductory material, please visit the PostgreSQL
    <ulink url="http://www.postgresql.org">web site</ulink>
    for links to more resources.
-->
もっと多くの入門資料がお望みであれば、PostgreSQLの<ulink url="http://www.postgresql.org/">Webサイト</ulink>により多くのリソースがリンクされています。
   </para>
  </sect1>
 </chapter>
