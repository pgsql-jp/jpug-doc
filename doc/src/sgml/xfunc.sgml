<!-- doc/src/sgml/xfunc.sgml -->

 <sect1 id="xfunc">
<!--
  <title>User-Defined Functions</title>
-->
  <title>ユーザ定義関数</title>

  <indexterm zone="xfunc">
<!--
   <primary>function</primary>
   <secondary>user-defined</secondary>
-->
   <primary>関数</primary>
   <secondary>ユーザ定義</secondary>
  </indexterm>

  <para>
<!--
   <productname>PostgreSQL</productname> provides four kinds of
   functions:
-->
<productname>PostgreSQL</productname>は4種類の関数を提供します。

   <itemizedlist>
    <listitem>
     <para>
<!--
      query language functions (functions written in
      <acronym>SQL</acronym>) (<xref linkend="xfunc-sql"/>)
-->
問い合わせ言語関数（<acronym>SQL</acronym>で作成された関数）（<xref linkend="xfunc-sql"/>）
     </para>
    </listitem>
    <listitem>
     <para>
<!--
      procedural language functions (functions written in, for
      example, <application>PL/pgSQL</application> or <application>PL/Tcl</application>)
      (<xref linkend="xfunc-pl"/>)
-->
手続型言語関数（<application>PL/pgSQL</application>や<application>PL/Tcl</application>などで作成された関数）（<xref linkend="xfunc-pl"/>）
     </para>
    </listitem>
    <listitem>
     <para>
<!--
      internal functions (<xref linkend="xfunc-internal"/>)
-->
内部関数（<xref linkend="xfunc-internal"/>）
     </para>
    </listitem>
    <listitem>
     <para>
<!--
      C-language functions (<xref linkend="xfunc-c"/>)
-->
C言語関数（<xref linkend="xfunc-c"/>）
     </para>
    </listitem>
   </itemizedlist>
  </para>

  <para>
<!--
   Every kind
   of  function  can take base types, composite types, or
   combinations of these as arguments (parameters). In addition,
   every kind of function can return a base type or
   a composite type.  Functions can also be defined to return
   sets of base or composite values.
-->
すべての関数は、基本型、複合型、またはこの組み合わせを引数（パラメータ）として受け付けることが可能です。
また、すべての関数は基本型または複合型を返すことが可能です。
関数は、基本型の集合または複合型の集合を返すように定義することもできます。
  </para>

  <para>
<!--
   Many kinds of functions can take or return certain pseudo-types
   (such as polymorphic types), but the available facilities vary.
   Consult the description of each kind of function for more details.
-->
多くの関数は（多様型のような）特定の疑似型を引数としたり返したりすることができます。
しかし、利用できる機能は様々です。
詳細は各関数の種類の説明を参照してください。
  </para>

  <para>
<!--
   It's easiest to define <acronym>SQL</acronym>
   functions, so we'll start by discussing those.
   Most of the concepts presented for <acronym>SQL</acronym> functions
   will carry over to the other types of functions.
-->
<acronym>SQL</acronym>関数の定義の方法が最も簡単ですので、そちらから説明します。
<acronym>SQL</acronym>関数にある概念のほとんどは、他の種類の関数にも適用できます。
  </para>

  <para>
<!--
   Throughout this chapter, it can be useful to look at the reference
   page of the <xref linkend="sql-createfunction"/> command to
   understand the examples better.  Some examples from this chapter
   can be found in <filename>funcs.sql</filename> and
   <filename>funcs.c</filename> in the <filename>src/tutorial</filename>
   directory in the <productname>PostgreSQL</productname> source
   distribution.
-->
本章の全体に関して、その例をより理解するために、<xref linkend="sql-createfunction"/>コマンドのマニュアルページを一読することが有用です。
本章の例のいくつかは<productname>PostgreSQL</productname>ソース配布物内の<filename>src/tutorial</filename>ディレクトリにある<filename>funcs.sql</filename>と<filename>funcs.c</filename>でも参照することができます。
  </para>
  </sect1>

  <sect1 id="xproc">
<!--
   <title>User-Defined Procedures</title>
-->
   <title>ユーザ定義プロシージャ</title>

  <indexterm zone="xproc">
<!--
   <primary>procedure</primary>
   <secondary>user-defined</secondary>
-->
   <primary>プロシージャ</primary>
   <secondary>ユーザ定義</secondary>
  </indexterm>

   <para>
<!--
    A procedure is a database object similar to a function.  The difference is
    that a procedure does not return a value, so there is no return type
    declaration.  While a function is called as part of a query or DML
    command, a procedure is called in isolation using
    the <xref linkend="sql-call"/> command.  If the CALL command is not
    part of an explicit transaction, a procedure in many server-side
    languages can commit, rollback, and begin new transactions during
    its execution, which is not possible in functions.
-->
プロシージャは関数と似たデータベースオブジェクトです。
違いはプロシージャは値を返さず、そのため戻り型の宣言が無いことです。
関数が問い合わせやDMLコマンドの一部として呼び出されるのに対して、プロシージャは明示的に<xref linkend="sql-call"/>コマンドを使って呼び出されます。
CALLコマンドが明示的なトランザクション内で無い場合、多くのサーバサイド言語のプロシージャはコミット、ロールバック、および新しいトランザクションの開始が実行出来ますが、関数には出来ません。
   </para>

   <para>
<!--
    The explanations on how to define user-defined functions in the rest of
    this chapter apply to procedures as well, except that
    the <xref linkend="sql-createprocedure"/> command is used instead, there is
    no return type, and some other features such as strictness don't apply.
-->
本章で後述するどのようにユーザ定義関数を定義するかの説明は、<xref linkend="sql-createprocedure"/>コマンドを代わりに使う、戻り値が無い、変動性区分などいくつかの他の仕様が該当しないという点を除き、プロシージャにも同様にあてはまります。
   </para>

   <para>
<!--
    Collectively, functions and procedures are also known
    as <firstterm>routines</firstterm><indexterm><primary>routine</primary></indexterm>.
    There are commands such as <xref linkend="sql-alterroutine"/>
    and <xref linkend="sql-droproutine"/> that can operate on functions and
    procedures without having to know which kind it is.  Note, however, that
    there is no <literal>CREATE ROUTINE</literal> command.
-->
関数とプロシージャは、ひとまとめに<firstterm>ルーチン</firstterm><indexterm><primary>ルーチン</primary></indexterm>とも言われます。
関数とプロシージャを区別することなしに操作できる<xref linkend="sql-alterroutine"/>や<xref linkend="sql-droproutine"/>などのコマンドがあります。
しかしながら、<literal>CREATE ROUTINE</literal>コマンドは無いことに注意してください。
   </para>
  </sect1>

  <sect1 id="xfunc-sql">
<!--
   <title>Query Language (<acronym>SQL</acronym>) Functions</title>
-->
<title>問い合わせ言語（<acronym>SQL</acronym>）関数</title>

   <indexterm zone="xfunc-sql">
<!--
    <primary>function</primary>
    <secondary>user-defined</secondary>
    <tertiary>in SQL</tertiary>
-->
    <primary>関数</primary>
    <secondary>ユーザ定義</secondary>
    <tertiary>SQLで作成した</tertiary>
   </indexterm>

   <para>
<!--
    SQL functions execute an arbitrary list of SQL statements, returning
    the result of the last query in the list.
    In the simple (non-set)
    case, the first row of the last query's result will be returned.
    (Bear in mind that <quote>the first row</quote> of a multirow
    result is not well-defined unless you use <literal>ORDER BY</literal>.)
    If the last query happens
    to return no rows at all, the null value will be returned.
-->
SQL関数は、任意のSQL文のリストを実行し、そのリストの最後の問い合わせの結果を返します。
単純な（集合ではない）場合、最後の問い合わせの結果の最初の行が返されます。
（複数行の結果のうちの<quote>最初の行</quote>は、<literal>ORDER BY</literal>を使用しない限り定義付けることができないことを覚えておいてください。）
最後の問い合わせが何も行を返さない時はNULL値が返されます。
   </para>

   <para>
<!--
    Alternatively, an SQL function can be declared to return a set (that is,
    multiple rows) by specifying the function's return type as <literal>SETOF
    <replaceable>sometype</replaceable></literal>, or equivalently by declaring it as
    <literal>RETURNS TABLE(<replaceable>columns</replaceable>)</literal>.  In this case
    all rows of the last query's result are returned.  Further details appear
    below.
-->
他にも、SQL関数は、<literal>SETOF</literal> <replaceable>sometype</replaceable>型を返すように指定すること、または同意の<literal>RETURNS TABLE(<replaceable>columns</replaceable>)</literal>と宣言することにより、集合（つまり複数の行）を返すように宣言することもできます。
この場合、最後の問い合わせの結果のすべての行が返されます。
詳細は後で説明します。
   </para>

   <para>
<!--
    The body of an SQL function must be a list of SQL
    statements separated by semicolons.  A semicolon after the last
    statement is optional.  Unless the function is declared to return
    <type>void</type>, the last statement must be a <command>SELECT</command>,
    or an <command>INSERT</command>, <command>UPDATE</command>, or <command>DELETE</command>
    that has a <literal>RETURNING</literal> clause.
-->
SQL関数の本体は、セミコロンで区切ったSQL文のリストでなければなりません。
最後の文の後のセミコロンは省略可能です。
関数が<type>void</type>を返すものと宣言されていない限り、最後の文は<command>SELECT</command>、または<literal>RETURNING</literal>句を持つ<command>INSERT</command>、<command>UPDATE</command>、または<command>DELETE</command>でなければなりません。
   </para>

    <para>
<!--
     Any collection of commands in the  <acronym>SQL</acronym>
     language can be packaged together and defined as a function.
     Besides <command>SELECT</command> queries, the commands can include data
     modification queries (<command>INSERT</command>,
     <command>UPDATE</command>, and <command>DELETE</command>), as well as
     other SQL commands. (You cannot use transaction control commands, e.g.,
     <command>COMMIT</command>, <command>SAVEPOINT</command>, and some utility
     commands, e.g.,  <literal>VACUUM</literal>, in <acronym>SQL</acronym> functions.)
     However, the final command
     must be a <command>SELECT</command> or have a <literal>RETURNING</literal>
     clause that returns whatever is
     specified as the function's return type.  Alternatively, if you
     want to define a SQL function that performs actions but has no
     useful value to return, you can define it as returning <type>void</type>.
     For example, this function removes rows with negative salaries from
     the <literal>emp</literal> table:
-->
<acronym>SQL</acronym>言語で作成された、任意のコマンド群はまとめて、関数として定義することができます。
<command>SELECT</command>問い合わせ以外に、データ変更用の問い合わせ（つまり、<command>INSERT</command>、<command>UPDATE</command>、<command>DELETE</command>）やその他のSQLコマンドを含めることができます。
（<acronym>SQL</acronym>関数では<command>COMMIT</command>、<command>SAVEPOINT</command>などのトランザクション制御コマンドおよび<literal>VACUUM</literal>などのユーティリティコマンドは使用することはできません。）
しかし、最後のコマンドは、関数の戻り値型として定義したものを返す<command>SELECT</command>、または<literal>RETURNING</literal>句があるものでなければなりません。
その他にも、何か動作をさせるが、有用な値を返さないSQL関数を定義したいのであれば、<type>void</type>を返すものと定義することで実現可能です。
たとえば、以下の関数は<literal>emp</literal>テーブルから負の給料となっている行を削除します。

<screen>
CREATE FUNCTION clean_emp() RETURNS void AS '
    DELETE FROM emp
        WHERE salary &lt; 0;
' LANGUAGE SQL;

SELECT clean_emp();

 clean_emp
-----------

(1 row)
</screen>
    </para>

    <note>
     <para>
<!--
      The entire body of a SQL function is parsed before any of it is
      executed.  While a SQL function can contain commands that alter
      the system catalogs (e.g., <command>CREATE TABLE</command>), the effects
      of such commands will not be visible during parse analysis of
      later commands in the function.  Thus, for example,
      <literal>CREATE TABLE foo (...); INSERT INTO foo VALUES(...);</literal>
      will not work as desired if packaged up into a single SQL function,
      since <structname>foo</structname> won't exist yet when the <command>INSERT</command>
      command is parsed.  It's recommended to use <application>PL/pgSQL</application>
      instead of a SQL function in this type of situation.
-->
SQL関数の本体全体は、その一部が実行される前に解析されます。
SQL関数はシステムカタログを変更するコマンド(例えば<command>CREATE TABLE</command>)を含むことができますので、そのようなコマンドの効果は関数の以降のコマンドの解析中は可視ではありません。
それゆえ、例えば、<literal>CREATE TABLE foo (...); INSERT INTO foo VALUES(...);</literal>は単一のSQL関数にまとめられていると期待したようには動作しません。<command>INSERT</command>コマンドが解析されている時には<structname>foo</structname>がまだ存在しないからです。
このような場合にはSQL関数の代わりに<application>PL/pgSQL</application>を使うことを薦めます。
     </para>
   </note>

   <para>
<!--
    The syntax of the <command>CREATE FUNCTION</command> command requires
    the function body to be written as a string constant.  It is usually
    most convenient to use dollar quoting (see <xref
    linkend="sql-syntax-dollar-quoting"/>) for the string constant.
    If you choose to use regular single-quoted string constant syntax,
    you must double single quote marks (<literal>'</literal>) and backslashes
    (<literal>\</literal>) (assuming escape string syntax) in the body of
    the function (see <xref linkend="sql-syntax-strings"/>).
-->
<command>CREATE FUNCTION</command>コマンドの構文では、関数本体は文字列定数として作成される必要があります。
この文字列定数の記述には、通常、ドル引用符付け（<xref linkend="sql-syntax-dollar-quoting"/>）が最も便利です。
文字列定数を単一引用符で括る通常の構文では、関数本体中で使用される単一引用符（<literal>'</literal>）とバックスラッシュ（<literal>\</literal>）（エスケープ文字列構文を仮定）を二重にしなければなりません（<xref linkend="sql-syntax-strings"/>を参照）。
   </para>

   <sect2 id="xfunc-sql-function-arguments">
<!--
    <title>Arguments for <acronym>SQL</acronym> Functions</title>
-->
    <title><acronym>SQL</acronym>関数用の引数</title>

   <indexterm>
<!--
    <primary>function</primary>
    <secondary>named argument</secondary>
-->
    <primary>関数</primary>
    <secondary>名前付き引数</secondary>
   </indexterm>

    <para>
<!--
     Arguments of a SQL function can be referenced in the function
     body using either names or numbers.  Examples of both methods appear
     below.
-->
SQL関数の引数は関数本体内で名前または番号を用いて参照することができます。
両方の方法の例を後で示します。
    </para>

    <para>
<!--
     To use a name, declare the function argument as having a name, and
     then just write that name in the function body.  If the argument name
     is the same as any column name in the current SQL command within the
     function, the column name will take precedence.  To override this,
     qualify the argument name with the name of the function itself, that is
     <literal><replaceable>function_name</replaceable>.<replaceable>argument_name</replaceable></literal>.
     (If this would conflict with a qualified column name, again the column
     name wins.  You can avoid the ambiguity by choosing a different alias for
     the table within the SQL command.)
-->
名前を使用するためには、関数引数を名前を持つものとして宣言し、その名前を関数本体内で記述するだけです。
引数名が関数内の現在のSQLコマンドにおける任意の列名と同じ場合は、列名が優先されます。
これを上書きするためには、<literal><replaceable>function_name</replaceable>.<replaceable>argument_name</replaceable></literal>のように、引数名を関数自身の名前を付けて修飾してください。
(もしこれも修飾された列名と競合する場合は、列名が優先されます。
SQLコマンド内でテーブルに他の別名を付けることで、この曖昧さを防止することができます。)
    </para>

    <para>
<!--
     In the older numeric approach, arguments are referenced using the syntax
     <literal>$<replaceable>n</replaceable></literal>: <literal>$1</literal> refers to the first input
     argument, <literal>$2</literal> to the second, and so on.  This will work
     whether or not the particular argument was declared with a name.
-->
古い番号による方法では、引数は関数本体内で<literal>$<replaceable>n</replaceable></literal>という構文を用いて表すことができます。
つまり、$1は第1引数を示し、$2は第2引数のようになります。
これは特定の引数が名前付きで宣言されているかどうかに関係なく動作します。
    </para>

    <para>
<!--
     If an argument is of a composite type, then the dot notation,
     e.g., <literal><replaceable>argname</replaceable>.<replaceable>fieldname</replaceable></literal> or
     <literal>$1.<replaceable>fieldname</replaceable></literal>, can be used to access attributes of the
     argument.  Again, you might need to qualify the argument's name with the
     function name to make the form with an argument name unambiguous.
-->
引数が複合型の場合、<literal><replaceable>argname</replaceable>.<replaceable>fieldname</replaceable></literal>や<literal>$1.<replaceable>fieldname</replaceable></literal>のようなドット表記を用いて引数の属性にアクセスすることができます。
ここでも、引数名を持つ形式で曖昧さが発生する場合には関数名で引数名を修飾してください。
    </para>

    <para>
<!--
     SQL function arguments can only be used as data values,
     not as identifiers.  Thus for example this is reasonable:
-->
SQL関数の引数は、識別子としてではなく、データ値としてのみ使用することができます。
したがって、例えば
<programlisting>
INSERT INTO mytable VALUES ($1);
</programlisting>
<!--
but this will not work:
-->
は正しいものですが、以下は動作しません。
<programlisting>
INSERT INTO $1 VALUES (42);
</programlisting>
    </para>

    <note>
     <para>
<!--
      The ability to use names to reference SQL function arguments was added
      in <productname>PostgreSQL</productname> 9.2.  Functions to be used in
      older servers must use the <literal>$<replaceable>n</replaceable></literal> notation.
-->
SQL関数の引数を参照するために名前を使用できる機能は、<productname>PostgreSQL</productname> 9.2で追加されました。
これより古いサーバ内で使われる関数は<literal>$<replaceable>n</replaceable></literal>記法を使用しなければなりません。
     </para>
    </note>
   </sect2>

   <sect2 id="xfunc-sql-base-functions">
<!--
    <title><acronym>SQL</acronym> Functions on Base Types</title>
-->
    <title>基本型を使用する<acronym>SQL</acronym>関数</title>

    <para>
<!--
     The simplest possible <acronym>SQL</acronym> function has no arguments and
     simply returns a base type, such as <type>integer</type>:
-->
最も簡単な<acronym>SQL</acronym>関数は、引数を取らずに単に<type>integer</type>のような基本型を返すものです。

<screen>
CREATE FUNCTION one() RETURNS integer AS $$
    SELECT 1 AS result;
$$ LANGUAGE SQL;

<!--
&#045;&#045; Alternative syntax for string literal:
-->
-- 文字列リテラルの別の構文では
CREATE FUNCTION one() RETURNS integer AS '
    SELECT 1 AS result;
' LANGUAGE SQL;

SELECT one();

 one
-----
   1
</screen>
    </para>

    <para>
<!--
     Notice that we defined a column alias within the function body for the result of the function
     (with  the  name <literal>result</literal>),  but this column alias is not visible
     outside the function.  Hence,  the  result  is labeled <literal>one</literal>
     instead of <literal>result</literal>.
-->
関数本体内で関数の結果用に列の別名を（<literal>result</literal>という名前で）定義したことに注目してください。
しかし、この列の別名はこの関数の外部からは可視ではありません。
したがって、その結果は<literal>result</literal>ではなく、<literal>one</literal>というラベルで表示されています。
    </para>

    <para>
<!--
     It is almost as easy to define <acronym>SQL</acronym> functions
     that take base types as arguments:
-->
基本型を引数として取る、<acronym>SQL</acronym>関数を定義することはほとんどの場合簡単です。

<screen>
CREATE FUNCTION add_em(x integer, y integer) RETURNS integer AS $$
    SELECT x + y;
$$ LANGUAGE SQL;

SELECT add_em(1, 2) AS answer;

 answer
--------
      3
</screen>
    </para>

    <para>
<!--
     Alternatively, we could dispense with names for the arguments and
     use numbers:
-->
この他に、引数に名前を付けることを省くことができます。この場合は番号を使用します。

<screen>
CREATE FUNCTION add_em(integer, integer) RETURNS integer AS $$
    SELECT $1 + $2;
$$ LANGUAGE SQL;

SELECT add_em(1, 2) AS answer;

 answer
--------
      3
</screen>
    </para>

    <para>
<!--
     Here is a more useful function, which might be used to debit a
     bank account:
-->
以下にもう少し役に立つ関数を示します。
これは銀行口座からの引き落としに使用できます。

<programlisting>
CREATE FUNCTION tf1 (accountno integer, debit numeric) RETURNS numeric AS $$
    UPDATE bank
        SET balance = balance - debit
        WHERE accountno = tf1.accountno;
    SELECT 1;
$$ LANGUAGE SQL;
</programlisting>

<!--
     A user could execute this function to debit account 17 by $100.00 as
     follows:
-->
以下のように、ユーザはこの関数を使用して、口座番号17から100ドルを引き出すことが可能です。

<programlisting>
SELECT tf1(17, 100.0);
</programlisting>
    </para>

    <para>
<!--
     In this example, we chose the name <literal>accountno</literal> for the first
     argument, but this is the same as the name of a column in the
     <literal>bank</literal> table.  Within the <command>UPDATE</command> command,
     <literal>accountno</literal> refers to the column <literal>bank.accountno</literal>,
     so <literal>tf1.accountno</literal> must be used to refer to the argument.
     We could of course avoid this by using a different name for the argument.
-->
この例では、第一引数の名前に<literal>accountno</literal>を選びましたが、これは<literal>bank</literal>テーブルの列の名前と同じです。
<command>UPDATE</command>コマンドの中では、<literal>accountno</literal>は<literal>bank.accountno</literal>列を参照しますので、引数を参照するためには<literal>tf1.accountno</literal>を使用しなければなりません。
もちろんこれは、引数に別の名前を使用することで防ぐことができます。
    </para>

    <para>
<!--
     In practice one would probably like a more useful result from the
     function than a constant 1, so a more likely definition
     is:
-->
実際には、関数の結果を定数1よりもわかりやすい形にするために、以下のように定義するとよいでしょう。

<programlisting>
CREATE FUNCTION tf1 (accountno integer, debit numeric) RETURNS numeric AS $$
    UPDATE bank
        SET balance = balance - debit
        WHERE accountno = tf1.accountno;
    SELECT balance FROM bank WHERE accountno = tf1.accountno;
$$ LANGUAGE SQL;
</programlisting>

<!--
     which adjusts the balance and returns the new balance.
     The same thing could be done in one command using <literal>RETURNING</literal>:
-->
これは残高を調整し、更新後の残高を返します。
同じことは<literal>RETURNING</literal>を使用して１つのコマンドで行えます。

<programlisting>
CREATE FUNCTION tf1 (accountno integer, debit numeric) RETURNS numeric AS $$
    UPDATE bank
        SET balance = balance - debit
        WHERE accountno = tf1.accountno
    RETURNING balance;
$$ LANGUAGE SQL;
</programlisting>
    </para>

    <para>
<!--
     If the final <literal>SELECT</literal> or <literal>RETURNING</literal>
     clause in a <acronym>SQL</acronym> function does not return exactly
     the function's declared result
     type, <productname>PostgreSQL</productname> will automatically cast
     the value to the required type, if that is possible with an implicit
     or assignment cast.  Otherwise, you must write an explicit cast.
     For example, suppose we wanted the
     previous <function>add_em</function> function to return
     type <type>float8</type> instead.  It's sufficient to write
-->
<acronym>SQL</acronym>関数の最後の<literal>SELECT</literal>句や<literal>RETURNING</literal>句が関数で定義された結果型を正確に返さない場合、<productname>PostgreSQL</productname>は可能な場合に暗黙的キャストまたは代入キャストで必要な型に自動でキャストします。
そうでない場合は明示的にキャストをする必要があります。
例えば、前出の<function>add_em</function>関数が代わりに<type>float8</type>型を返して欲しいとします。
次のように記述すれば十分です。

<programlisting>
CREATE FUNCTION add_em(integer, integer) RETURNS float8 AS $$
    SELECT $1 + $2;
$$ LANGUAGE SQL;
</programlisting>

<!--
     since the <type>integer</type> sum can be implicitly cast
     to <type>float8</type>.
     (See <xref linkend="typeconv"/> or <xref linkend="sql-createcast"/>
     for more about casts.)
-->
<type>integer</type>の和は<type>float8</type>に暗黙キャストできるからです。
（キャストについての詳細は<xref linkend="typeconv"/>または<xref linkend="sql-createcast"/>を参照して下さい）。
    </para>
   </sect2>

   <sect2 id="xfunc-sql-composite-functions">
<!--
    <title><acronym>SQL</acronym> Functions on Composite Types</title>
-->
    <title>複合型を使用する<acronym>SQL</acronym>関数</title>

    <para>
<!--
     When writing functions with arguments of composite types, we must not
     only specify which argument we want but also the desired attribute
     (field) of that argument.  For example, suppose that
     <type>emp</type> is a table containing employee data, and therefore
     also the name of the composite type of each row of the table.  Here
     is a function <function>double_salary</function> that computes what someone's
     salary would be if it were doubled:
-->
関数の引数に複合型を記述した場合、必要な引数を指定するだけではなく、必要とする引数の属性（フィールド）も指定する必要があります。
例えば、<type>emp</type>が従業員データを持つテーブルとすると、この名前はそのテーブル内の各行を表す複合型の名前でもあります。
以下に示す<function>double_salary</function>関数は、該当する従業員の給料が倍増したらどうなるかを計算します。

<screen>
CREATE TABLE emp (
    name        text,
    salary      numeric,
    age         integer,
    cubicle     point
);

INSERT INTO emp VALUES ('Bill', 4200, 45, '(2,1)');

CREATE FUNCTION double_salary(emp) RETURNS numeric AS $$
    SELECT $1.salary * 2 AS salary;
$$ LANGUAGE SQL;

SELECT name, double_salary(emp.*) AS dream
    FROM emp
    WHERE emp.cubicle ~= point '(2,1)';

 name | dream
------+-------
 Bill |  8400
</screen>
    </para>

    <para>
<!--
     Notice the use of the syntax <literal>$1.salary</literal>
     to select one field of the argument row value.  Also notice
     how the calling <command>SELECT</command> command
     uses <replaceable>table_name</replaceable><literal>.*</literal> to select
     the entire current row of a table as a composite value.  The table
     row can alternatively be referenced using just the table name,
     like this:
-->
<literal>$1.salary</literal>という構文を使用して、引数の行値の1フィールドを選択していることに注目してください。
また、<replaceable>table_name</replaceable><literal>.*</literal>を使用した<command>SELECT</command>コマンドの呼び出しでは、複合型の値として、現在のテーブル行全体を表すテーブル名を使用していることにも注目してください。
別の方法として、テーブル行は以下のようにテーブル名だけを使用して参照することができます。
<screen>
SELECT name, double_salary(emp) AS dream
    FROM emp
    WHERE emp.cubicle ~= point '(2,1)';
</screen>
<!--
     but this usage is deprecated since it's easy to get confused.
     (See <xref linkend="rowtypes-usage"/> for details about these
     two notations for the composite value of a table row.)
-->
しかし、この使用方法は混乱しやすいためお勧めしません。
(テーブル行の複合型の値に対するこの二つの表記の詳細は<xref linkend="rowtypes-usage"/>を参照してください)
    </para>

    <para>
<!--
     Sometimes it is handy to construct a composite argument value
     on-the-fly.  This can be done with the <literal>ROW</literal> construct.
     For example, we could adjust the data being passed to the function:
-->
その場で複合型の引数値を作成することが便利な場合があります。
これは<literal>ROW</literal>式で行うことができます。
例えば、以下のようにして関数に渡すデータを調整することができます。
<screen>
SELECT name, double_salary(ROW(name, salary*1.1, age, cubicle)) AS dream
    FROM emp;
</screen>
    </para>

    <para>
<!--
     It is also possible to build a function that returns a composite type.
     This is an example of a function
     that returns a single <type>emp</type> row:
-->
複合型を返す関数を作成することもできます。
以下に単一の<type>emp</type>行を返す関数の例を示します。

<programlisting>
CREATE FUNCTION new_emp() RETURNS emp AS $$
    SELECT text 'None' AS name,
        1000.0 AS salary,
        25 AS age,
        point '(2,2)' AS cubicle;
$$ LANGUAGE SQL;
</programlisting>

<!--
     In this example we have specified each of  the  attributes
     with  a  constant value, but any computation
     could have been substituted for these constants.
-->
ここでは、各属性を定数で指定していますが、この定数を何らかの演算に置き換えることもできます。
    </para>

    <para>
<!--
     Note two important things about defining the function:
-->
関数を定義する上で、2つの重要な注意点を以下に示します。

     <itemizedlist>
      <listitem>
       <para>
<!--
        The select list order in the query must be exactly the same as
        that in which the columns appear in the composite type.
        (Naming the columns, as we did above,
        is irrelevant to the system.)
-->
問い合わせにおける選択リストの順番は、複合型に列が現れる順番と正確に一致する必要があります。
（上で行ったように列に名前を付けても、システムは認識しません。）
       </para>
      </listitem>
      <listitem>
       <para>
<!--
        We must ensure each expression's type can be cast to that of
        the corresponding column of the composite type.
        Otherwise we'll get errors like this:
-->
各式の型が対応する複合型の列にキャスタができるようにする必要があります。
さもなくば、以下のようなエラーとなります。
<screen>
<computeroutput>
ERROR:  return type mismatch in function declared to return emp
DETAIL:  Final statement returns text instead of point at column 4.
</computeroutput>
</screen>
<!--
        As with the base-type case, the system will not insert explicit
        casts automatically, only implicit or assignment casts.
-->
基本型の場合と同様に、システムは明示的キャストを自動では挿入せず、暗黙または代入キャストのみをします。
       </para>
      </listitem>
     </itemizedlist>
    </para>

    <para>
<!--
     A different way to define the same function is:
-->
同じ関数を以下のように定義することもできます。

<programlisting>
CREATE FUNCTION new_emp() RETURNS emp AS $$
    SELECT ROW('None', 1000.0, 25, '(2,2)')::emp;
$$ LANGUAGE SQL;
</programlisting>

<!--
     Here we wrote a <command>SELECT</command> that returns just a single
     column of the correct composite type.  This isn't really better
     in this situation, but it is a handy alternative in some cases
     &mdash; for example, if we need to compute the result by calling
     another function that returns the desired composite value.
     Another example is that if we are trying to write a function that
     returns a domain over composite, rather than a plain composite type,
     it is always necessary to write it as returning a single column,
     since there is no way to cause a coercion of the whole row result.
-->
ここで、正しい複合型の単一の列を単に返す<command>SELECT</command>を記述しました。
今回の例ではこれはより優れたものとはいえませんが、例えば、必要な複合値を返す他の関数を呼び出して結果を計算しなければならない場合など、便利な解法になることがあります。
他の例としては、単なる複合型ではなく複合型のドメインを返す関数を書こうとしてる場合に、単一列を返すように書くことが常に必要となります。
なぜなら、行全体の結果を強制する方法がないからです。
    </para>

    <para>
<!--
     We could call this function directly either by using it in
     a value expression:
-->
この関数を、評価式で使って直接呼び出せますし、

<screen>
SELECT new_emp();

         new_emp
--------------------------
 (None,1000.0,25,"(2,2)")
</screen>

<!--
     or by calling it as a table function:
-->
テーブル関数として呼び出しても直接呼び出せます。

<screen>
SELECT * FROM new_emp();

 name | salary | age | cubicle
------+--------+-----+---------
 None | 1000.0 |  25 | (2,2)
</screen>

<!--
     The second way is described more fully in <xref
     linkend="xfunc-sql-table-functions"/>.
-->
2番目の方法については、<xref linkend="xfunc-sql-table-functions"/>でより詳しく説明します。
    </para>

    <para>
<!--
     When you use a function that returns a composite type,
     you might want only one field (attribute) from its result.
     You can do that with syntax like this:
-->
複合型を返す関数を使用する時に、その結果から1つのフィールド（属性）のみを使用したいという場合があります。
これは、以下のような構文で行うことができます。

<screen>
SELECT (new_emp()).name;

 name
------
 None
</screen>

<!--
     The extra parentheses are needed to keep the parser from getting
     confused.  If you try to do it without them, you get something like this:
-->
パーサが混乱しないように、括弧を追加する必要があります。
括弧なしで行おうとすると、以下のような結果になります。

<screen>
SELECT new_emp().name;
ERROR:  syntax error at or near "."
LINE 1: SELECT new_emp().name;
                        ^
</screen>
    </para>

    <para>
<!--
     Another option is to use functional notation for extracting an attribute:
-->
また、関数表記を使用して属性を抽出することもできます。

<screen>
SELECT name(new_emp());

 name
------
 None
</screen>

<!--
     As explained in <xref linkend="rowtypes-usage"/>, the field notation and
     functional notation are equivalent.
-->
<xref linkend="rowtypes-usage"/>で述べるように、フィールド表記と関数表記は等価です。
    </para>

    <para>
<!--
     Another way to use a function returning a composite type is to pass the
     result to another function that accepts the correct row type as input:
-->
複合型を結果として返す関数を使用する他の方法は、その結果を、その行型を入力として受け付ける関数に渡す、以下のような方法です。

<screen>
CREATE FUNCTION getname(emp) RETURNS text AS $$
    SELECT $1.name;
$$ LANGUAGE SQL;

SELECT getname(new_emp());
 getname
---------
 None
(1 row)
</screen>
    </para>
   </sect2>

   <sect2 id="xfunc-output-parameters">
<!--
    <title><acronym>SQL</acronym> Functions with Output Parameters</title>
-->
    <title>出力パラメータを持つ<acronym>SQL</acronym>関数</title>

   <indexterm>
<!--
    <primary>function</primary>
    <secondary>output parameter</secondary>
-->
    <primary>関数</primary>
    <secondary>出力パラメータ</secondary>
   </indexterm>

    <para>
<!--
     An alternative way of describing a function's results is to define it
     with <firstterm>output parameters</firstterm>, as in this example:
-->
関数の結果の記述方法には、他にも<firstterm>出力パラメータ</firstterm>を使用して定義する方法があります。
以下に例を示します。

<screen>
CREATE FUNCTION add_em (IN x int, IN y int, OUT sum int)
AS 'SELECT x + y'
LANGUAGE SQL;

SELECT add_em(3,7);
 add_em
--------
     10
(1 row)
</screen>

<!--
     This is not essentially different from the version of <literal>add_em</literal>
     shown in <xref linkend="xfunc-sql-base-functions"/>.  The real value of
     output parameters is that they provide a convenient way of defining
     functions that return several columns.  For example,
-->
<xref linkend="xfunc-sql-base-functions"/>で示した<literal>add_em</literal>版と基本的な違いはありません。
複数列を返す関数を定義する簡単な方法を提供することが出力パラメータの本来の価値です。
以下に例を示します。

<screen>
CREATE FUNCTION sum_n_product (x int, y int, OUT sum int, OUT product int)
AS 'SELECT x + y, x * y'
LANGUAGE SQL;

 SELECT * FROM sum_n_product(11,42);
 sum | product
-----+---------
  53 |     462
(1 row)
</screen>

<!--
     What has essentially happened here is that we have created an anonymous
     composite type for the result of the function.  The above example has
     the same end result as
-->
これは基本的に、関数結果用の無名の複合型の作成を行います。
上の例では、

<screen>
CREATE TYPE sum_prod AS (sum int, product int);

CREATE FUNCTION sum_n_product (int, int) RETURNS sum_prod
AS 'SELECT $1 + $2, $1 * $2'
LANGUAGE SQL;
</screen>
と同じ最終結果になります。

<!--
     but not having to bother with the separate composite type definition
     is often handy.  Notice that the names attached to the output parameters
     are not just decoration, but determine the column names of the anonymous
     composite type.  (If you omit a name for an output parameter, the
     system will choose a name on its own.)
-->
しかし、独立した複合型定義に悩まされることがなくなり、便利であるともいえます。
出力パラメータに割り振られた名前が単なる飾りではなく、無名複合型の列名を決定するものであることに注意してください。
（出力パラメータの名前を省略した場合、システム自身が名前を選びます。）
    </para>

    <para>
<!--
     Notice that output parameters are not included in the calling argument
     list when invoking such a function from SQL.  This is because
     <productname>PostgreSQL</productname> considers only the input
     parameters to define the function's calling signature.  That means
     also that only the input parameters matter when referencing the function
     for purposes such as dropping it.  We could drop the above function
     with either of
-->
SQLからこうした関数を呼び出す時、出力パラメータが呼び出し側の引数リストに含まれないことに注意してください。
<productname>PostgreSQL</productname>では入力パラメータのみが関数の呼び出しシグネチャを定義するとみなしているためです。
これはまた、関数を削除することなどを目的に関数を参照する場合、入力パラメータのみが考慮されることを意味しています。
上の関数は、次のいずれかの方法で削除することができます。

<screen>
DROP FUNCTION sum_n_product (x int, y int, OUT sum int, OUT product int);
DROP FUNCTION sum_n_product (int, int);
</screen>
    </para>

    <para>
<!--
     Parameters can be marked as <literal>IN</literal> (the default),
     <literal>OUT</literal>, <literal>INOUT</literal>, or <literal>VARIADIC</literal>.
     An <literal>INOUT</literal>
     parameter serves as both an input parameter (part of the calling
     argument list) and an output parameter (part of the result record type).
     <literal>VARIADIC</literal> parameters are input parameters, but are treated
     specially as described next.
-->
パラメータには、<literal>IN</literal>（デフォルト）、<literal>OUT</literal>、<literal>INOUT</literal>、または<literal>VARIADIC</literal>という印を付与できます。
<literal>INOUT</literal>パラメータは、入力パラメータ（呼び出し引数リストの一部）と出力パラメータ（結果のレコード型の一部）の両方を提供します。
<literal>VARIADIC</literal>パラメータは入力パラメータですが、次に説明するように特別に扱われます。
    </para>
   </sect2>

   <sect2 id="xfunc-sql-variadic-functions">
<!--
    <title><acronym>SQL</acronym> Functions with Variable Numbers of Arguments</title>
-->
    <title>可変長引数を取る<acronym>SQL</acronym>関数</title>

    <indexterm>
<!--
     <primary>function</primary>
-->
     <primary>関数</primary>
     <secondary>variadic</secondary>
    </indexterm>

    <indexterm>
<!--
     <primary>variadic function</primary>
-->
     <primary>variadic関数</primary>
    </indexterm>

    <para>
<!--
     <acronym>SQL</acronym> functions can be declared to accept
     variable numbers of arguments, so long as all the <quote>optional</quote>
     arguments are of the same data type.  The optional arguments will be
     passed to the function as an array.  The function is declared by
     marking the last parameter as <literal>VARIADIC</literal>; this parameter
     must be declared as being of an array type.  For example:
-->
すべての<quote>オプションの</quote>引数が同じデータ型の場合、<acronym>SQL</acronym>関数は可変長の引数を受け付けるように宣言できます。
オプションの引数は配列として関数に渡されます。
この関数は最後のパラメータを<literal>VARIADIC</literal>と印を付けて宣言されます。
このパラメータは配列型であるとして宣言されなければなりません。
例をあげます。

<screen>
CREATE FUNCTION mleast(VARIADIC arr numeric[]) RETURNS numeric AS $$
    SELECT min($1[i]) FROM generate_subscripts($1, 1) g(i);
$$ LANGUAGE SQL;

SELECT mleast(10, -1, 5, 4.4);
 mleast 
--------
     -1
(1 row)
</screen>

<!--
     Effectively, all the actual arguments at or beyond the
     <literal>VARIADIC</literal> position are gathered up into a one-dimensional
     array, as if you had written
-->
実際、<literal>VARIADIC</literal>の位置以降の実引数はすべて、あたかも以下のように記述したかのように、1次元の配列としてまとめられます。

<screen>
<!--
SELECT mleast(ARRAY[10, -1, 5, 4.4]);    &#045;&#045; doesn't work
-->
SELECT mleast(ARRAY[10, -1, 5, 4.4]);    -- 動作しません
</screen>

<!--
     You can't actually write that, though &mdash; or at least, it will
     not match this function definition.  A parameter marked
     <literal>VARIADIC</literal> matches one or more occurrences of its element
     type, not of its own type.
-->
しかし、実際にこのように記述することはできません。
少なくとも、この関数定義に一致しません。
<literal>VARIADIC</literal>印の付いたパラメータは、自身の型ではなく、その要素型が１つ以上存在することに一致します。
    </para>

    <para>
<!--
     Sometimes it is useful to be able to pass an already-constructed array
     to a variadic function; this is particularly handy when one variadic
     function wants to pass on its array parameter to another one.  Also,
     this is the only secure way to call a variadic function found in a schema
     that permits untrusted users to create objects; see
     <xref linkend="typeconv-func"/>.  You can do this by
     specifying <literal>VARIADIC</literal> in the call:
-->
時として、variadic関数に既に構築された配列を渡せることは有用です。
１つのvariadic関数が、自身の配列パラメータを他のものに渡したいとき特に便利です。
また、これが、信用できないユーザがオブジェクトを作成できるスキーマにあるvariadic関数を呼び出す唯一の安全な方法です。<xref linkend="typeconv-func"/>を参照してください。
これは、呼び出しに<literal>VARIADIC</literal>を指定することで行えます。

<screen>
SELECT mleast(VARIADIC ARRAY[10, -1, 5, 4.4]);
</screen>

<!--
     This prevents expansion of the function's variadic parameter into its
     element type, thereby allowing the array argument value to match
     normally.  <literal>VARIADIC</literal> can only be attached to the last
     actual argument of a function call.
-->
これは関数のvariadicパラメータがその要素型に拡張するのを防ぎます。
その結果、配列引数値が標準的にマッチされるようになります。
<literal>VARIADIC</literal>は関数呼び出しの最後の実引数としてのみ付加できます。
    </para>

    <para>
<!--
     Specifying <literal>VARIADIC</literal> in the call is also the only way to
     pass an empty array to a variadic function, for example:
-->
呼び出しで<literal>VARIADIC</literal>を指定することは、variadic関数に空の配列を渡す唯一の方法でもあります。例えば、

<screen>
SELECT mleast(VARIADIC ARRAY[]::numeric[]);
</screen>

<!--
     Simply writing <literal>SELECT mleast()</literal> does not work because a
     variadic parameter must match at least one actual argument.
     (You could define a second function also named <literal>mleast</literal>,
     with no parameters, if you wanted to allow such calls.)
-->
variadicパラメータが少なくとも1つの実引数と一致しなければなりませんので、単に<literal>SELECT mleast()</literal>と書くだけでは上手くいきません。
(もしそのような呼び出しを許可したいのなら、<literal>mleast</literal>という名前のパラメータのない第2の関数を定義することもできます。)
    </para>

    <para>
<!--
     The array element parameters generated from a variadic parameter are
     treated as not having any names of their own.  This means it is not
     possible to call a variadic function using named arguments (<xref
     linkend="sql-syntax-calling-funcs"/>), except when you specify
     <literal>VARIADIC</literal>.  For example, this will work:
-->
variadicパラメータから生成される配列要素パラメータは、それ自身にはまったく名前を持たないものとして扱われます。
これは、名前付き引数（<xref linkend="sql-syntax-calling-funcs"/>）を使用して可変長の関数を呼び出すことができないことを意味します。
ただし、<literal>VARIADIC</literal>を指定する場合は例外です。
たとえば、

<screen>
SELECT mleast(VARIADIC arr =&gt; ARRAY[10, -1, 5, 4.4]);
</screen>

<!--
     but not these:
-->
は動作しますが、

<screen>
SELECT mleast(arr =&gt; 10);
SELECT mleast(arr =&gt; ARRAY[10, -1, 5, 4.4]);
</screen>
は動作しません。
    </para>
   </sect2>

   <sect2 id="xfunc-sql-parameter-defaults">
<!--
    <title><acronym>SQL</acronym> Functions with Default Values for Arguments</title>
-->
    <title>引数にデフォルト値を持つ<acronym>SQL</acronym>関数</title>

    <indexterm>
<!--
     <primary>function</primary>
     <secondary>default values for arguments</secondary>
-->
     <primary>関数</primary>
     <secondary>引数のデフォルト値</secondary>
    </indexterm>

    <para>
<!--
     Functions can be declared with default values for some or all input
     arguments.  The default values are inserted whenever the function is
     called with insufficiently many actual arguments.  Since arguments
     can only be omitted from the end of the actual argument list, all
     parameters after a parameter with a default value have to have
     default values as well.  (Although the use of named argument notation
     could allow this restriction to be relaxed, it's still enforced so that
     positional argument notation works sensibly.)  Whether or not you use it,
     this capability creates a need for precautions when calling functions in
     databases where some users mistrust other users; see
     <xref linkend="typeconv-func"/>.
-->
一部またはすべての入力引数にデフォルト値を持つ関数を宣言することができます。
デフォルト値は、関数が実際の引数の数に足りない数の引数で呼び出された場合に挿入されます。
引数は実引数リストの終端から省略することができますので、デフォルト値を持つパラメータの後にあるパラメータはすべて、同様にデフォルト値を持たなければなりません。
（名前付きの引数記法を使用してこの制限を緩和させることもできますが、まだ位置引数記法が実用的に動作できることが強制されています。）
使うかどうかに関わりなく、この能力は、あるユーザが他のユーザを信用しないデータベースで関数を呼び出す時に、セキュリティの事前の対策を必要とします。<xref linkend="typeconv-func"/>を参照してください。
    </para>

    <para>
<!--
     For example:
-->
以下に例を示します。
<screen>
CREATE FUNCTION foo(a int, b int DEFAULT 2, c int DEFAULT 3)
RETURNS int
LANGUAGE SQL
AS $$
    SELECT $1 + $2 + $3;
$$;

SELECT foo(10, 20, 30);
 foo 
-----
  60
(1 row)

SELECT foo(10, 20);
 foo 
-----
  33
(1 row)

SELECT foo(10);
 foo 
-----
  15
(1 row)

<!--
SELECT foo();  &#045;- fails since there is no default for the first argument
-->
SELECT foo();  -- 最初の引数にデフォルトがないため失敗
ERROR:  function foo() does not exist
</screen>
<!--
     The <literal>=</literal> sign can also be used in place of the
     key word <literal>DEFAULT</literal>.
-->
<literal>=</literal>記号を<literal>DEFAULT</literal>キーワードの代わりに使用することもできます。
    </para>
   </sect2>

   <sect2 id="xfunc-sql-table-functions">
<!--
    <title><acronym>SQL</acronym> Functions as Table Sources</title>
-->
    <title>テーブルソースとしての<acronym>SQL</acronym>関数</title>

    <para>
<!--
     All SQL functions can be used in the <literal>FROM</literal> clause of a query,
     but it is particularly useful for functions returning composite types.
     If the function is defined to return a base type, the table function
     produces a one-column table.  If the function is defined to return
     a composite type, the table function produces a column for each attribute
     of the composite type.
-->
すべてのSQL関数は問い合わせの<literal>FROM</literal>句で使用できますが、複合型を返す関数に特に便利です。
関数が基本型を返すよう定義されている場合、テーブル関数は1列からなるテーブルを作成します。
関数が複合型を返すよう定義されている場合、テーブル関数は複合型の列のそれぞれに対して1つの列を作成します。
    </para>

    <para>
<!--
     Here is an example:
-->
以下に例を示します。

<screen>
CREATE TABLE foo (fooid int, foosubid int, fooname text);
INSERT INTO foo VALUES (1, 1, 'Joe');
INSERT INTO foo VALUES (1, 2, 'Ed');
INSERT INTO foo VALUES (2, 1, 'Mary');

CREATE FUNCTION getfoo(int) RETURNS foo AS $$
    SELECT * FROM foo WHERE fooid = $1;
$$ LANGUAGE SQL;

SELECT *, upper(fooname) FROM getfoo(1) AS t1;

 fooid | foosubid | fooname | upper
-------+----------+---------+-------
     1 |        1 | Joe     | JOE
(1 row)
</screen>

<!--
     As the example shows, we can work with the columns of the function's
     result just the same as if they were columns of a regular table.
-->
例からわかる通り、関数の結果の列を通常のテーブルの列と同じように扱うことができます。
    </para>

    <para>
<!--
     Note that we only got one row out of the function.  This is because
     we did not use <literal>SETOF</literal>.  That is described in the next section.
-->
この関数の結果得られたのは1行のみであることに注意してください。
これは<literal>SETOF</literal>を指定しなかったためです。
これについては次節で説明します。
    </para>
   </sect2>

   <sect2 id="xfunc-sql-functions-returning-set">
<!--
    <title><acronym>SQL</acronym> Functions Returning Sets</title>
-->
<title>集合を返す<acronym>SQL</acronym>関数</title>

    <indexterm>
<!--
     <primary>function</primary>
     <secondary>with SETOF</secondary>
-->
     <primary>関数</primary>
     <secondary>SETOF 付き</secondary>
    </indexterm>

    <para>
<!--
     When an SQL function is declared as returning <literal>SETOF
     <replaceable>sometype</replaceable></literal>, the function's final
     query is executed to completion, and each row it
     outputs is returned as an element of the result set.
-->
SQL関数が<literal>SETOF</literal> <replaceable>sometype</replaceable>を返すよう宣言されている場合、関数の最後の問い合わせは最後まで実行され、各出力行は結果集合の要素として返されます。
    </para>

    <para>
<!--
     This feature is normally used when calling the function in the <literal>FROM</literal>
     clause.  In this case each row returned by the function becomes
     a row of the table seen by the query.  For example, assume that
     table <literal>foo</literal> has the same contents as above, and we say:
-->
この機能は通常、関数を<literal>FROM</literal>句内で呼び出す時に使用されます。
この場合、関数によって返される各行は、問い合わせによって見えるテーブルの行になります。
例えば、テーブル<literal>foo</literal>の内容が上記と同じであれば以下のようになります。

<programlisting>
CREATE FUNCTION getfoo(int) RETURNS SETOF foo AS $$
    SELECT * FROM foo WHERE fooid = $1;
$$ LANGUAGE SQL;

SELECT * FROM getfoo(1) AS t1;
</programlisting>

<!--
     Then we would get:
-->
この出力は以下の通りです。
<screen>
 fooid | foosubid | fooname
-------+----------+---------
     1 |        1 | Joe
     1 |        2 | Ed
(2 rows)
</screen>
    </para>

    <para>
<!--
     It is also possible to return multiple rows with the columns defined by
     output parameters, like this:
-->
また、以下のように出力パラメータで定義された列を持つ複数の行を返すことも可能です。

<programlisting>
CREATE TABLE tab (y int, z int);
INSERT INTO tab VALUES (1, 2), (3, 4), (5, 6), (7, 8);

CREATE FUNCTION sum_n_product_with_tab (x int, OUT sum int, OUT product int)
RETURNS SETOF record
AS $$
    SELECT $1 + tab.y, $1 * tab.y FROM tab;
$$ LANGUAGE SQL;

SELECT * FROM sum_n_product_with_tab(10);
 sum | product
-----+---------
  11 |      10
  13 |      30
  15 |      50
  17 |      70
(4 rows)
</programlisting>

<!--
     The key point here is that you must write <literal>RETURNS SETOF record</literal>
     to indicate that the function returns multiple rows instead of just one.
     If there is only one output parameter, write that parameter's type
     instead of <type>record</type>.
-->
ここで重要な点は、関数が1行だけではなく複数行を返すことを示すために<literal>RETURNS SETOF record</literal>を記述しなければならない点です。
出力パラメータが１つしか存在しない場合は、<type>record</type>ではなく、そのパラメータの型を記述してください。
    </para>

    <para>
<!--
     It is frequently useful to construct a query's result by invoking a
     set-returning function multiple times, with the parameters for each
     invocation coming from successive rows of a table or subquery.  The
     preferred way to do this is to use the <literal>LATERAL</literal> key word,
     which is described in <xref linkend="queries-lateral"/>.
     Here is an example using a set-returning function to enumerate
     elements of a tree structure:
-->
集合を返す関数を、それぞれの呼び出し時に連続するテーブル行または副問い合わせに由来するパラメータを付けて、複数回呼び出すことで問い合わせ結果を構築することはしばしば有用です。
お勧めする方法は、<xref linkend="queries-lateral"/>で説明する<literal>LATERAL</literal>キーワードを使用することです。
以下は集合を返す関数を使用して、ツリー構造の要素を模擬する例です。

<screen>
SELECT * FROM nodes;
   name    | parent
-----------+--------
 Top       |
 Child1    | Top
 Child2    | Top
 Child3    | Top
 SubChild1 | Child1
 SubChild2 | Child1
(6 rows)

CREATE FUNCTION listchildren(text) RETURNS SETOF text AS $$
    SELECT name FROM nodes WHERE parent = $1
$$ LANGUAGE SQL STABLE;

SELECT * FROM listchildren('Top');
 listchildren
--------------
 Child1
 Child2
 Child3
(3 rows)

SELECT name, child FROM nodes, LATERAL listchildren(name) AS child;
  name  |   child
--------+-----------
 Top    | Child1
 Top    | Child2
 Top    | Child3
 Child1 | SubChild1
 Child1 | SubChild2
(5 rows)
</screen>

<!--
     This example does not do anything that we couldn't have done with a
     simple join, but in more complex calculations the option to put
     some of the work into a function can be quite convenient.
-->
この例は単純な結合でできない何かを行うものではありません。
しかしより複雑な計算では、何らかの作業を関数内に押し込むオプションはかなり便利です。
    </para>

    <para>
<!--
     Functions returning sets can also be called in the select list
     of a query.  For each row that the query
     generates by itself, the set-returning function is invoked, and an output
     row is generated for each element of the function's result set.
     The previous example could also be done with queries like
     these:
-->
集合を返す関数は問い合わせの選択リスト内でも呼び出すことができます。
問い合わせ自身によって生成する各行に対し、集合を返す関数が呼び出され、関数の結果集合の各要素に対して出力行が生成されます。
上の例は以下のような問い合わせでも実現することができます。

<screen>
SELECT listchildren('Top');
 listchildren
--------------
 Child1
 Child2
 Child3
(3 rows)

SELECT name, listchildren(name) FROM nodes;
  name  | listchildren
--------+--------------
 Top    | Child1
 Top    | Child2
 Top    | Child3
 Child1 | SubChild1
 Child1 | SubChild2
(5 rows)
</screen>

<!--
     In the last <command>SELECT</command>,
     notice that no output row appears for <literal>Child2</literal>, <literal>Child3</literal>, etc.
     This happens because <function>listchildren</function> returns an empty set
     for those arguments, so no result rows are generated.  This is the same
     behavior as we got from an inner join to the function result when using
     the <literal>LATERAL</literal> syntax.
-->
最後の<command>SELECT</command>において、<literal>Child2</literal>と<literal>Child3</literal>などが出力行に表示されていないことに注意してください。
これは、<function>listchildren</function>がこの入力に対して空の集合を返すため出力行が生成されないからです。
<literal>LATERAL</literal>構文を使用した時の関数の結果との内部結合から得る場合と同じ動作です。
    </para>

    <para>
<!--
     <productname>PostgreSQL</productname>'s behavior for a set-returning function in a
     query's select list is almost exactly the same as if the set-returning
     function had been written in a <literal>LATERAL FROM</literal>-clause item
     instead.  For example,
-->
選択リストにある集合を返す関数に対する<productname>PostgreSQL</productname>の振舞いは、集合を返す関数が<literal>LATERAL FROM</literal>句に書かれている場合とほとんど同じです。
例えば
<programlisting>
SELECT x, generate_series(1,5) AS g FROM tab;
</programlisting>
<!--
     is almost equivalent to
-->
は
<programlisting>
SELECT x, g FROM tab, LATERAL generate_series(1,5) AS g;
</programlisting>
とほぼ同じです。
<!--
     It would be exactly the same, except that in this specific example,
     the planner could choose to put <structname>g</structname> on the outside of the
     nested-loop join, since <structname>g</structname> has no actual lateral dependency
     on <structname>tab</structname>.  That would result in a different output row
     order.  Set-returning functions in the select list are always evaluated
     as though they are on the inside of a nested-loop join with the rest of
     the <literal>FROM</literal> clause, so that the function(s) are run to
     completion before the next row from the <literal>FROM</literal> clause is
     considered.
-->
この特定の例では、<structname>g</structname>は実際には<structname>tab</structname>にLATERALには依存しませんので、プランナがネステッドループ結合の外に<structname>g</structname>を置くことを選ぶかもしれないという点を除いて、全く同じです。
そのため、出力行の順番が異なる結果になるかもしれません。
選択リスト内の集合を返す関数は、<literal>FROM</literal>句からの次の行が考慮される前に関数の実行が完了するよう、<literal>FROM</literal>句の残りとのネステッドループ結合の中にあるかのように必ず評価されます。
    </para>

    <para>
<!--
     If there is more than one set-returning function in the query's select
     list, the behavior is similar to what you get from putting the functions
     into a single <literal>LATERAL ROWS FROM( ... )</literal> <literal>FROM</literal>-clause
     item.  For each row from the underlying query, there is an output row
     using the first result from each function, then an output row using the
     second result, and so on.  If some of the set-returning functions
     produce fewer outputs than others, null values are substituted for the
     missing data, so that the total number of rows emitted for one
     underlying row is the same as for the set-returning function that
     produced the most outputs.  Thus the set-returning functions
     run <quote>in lockstep</quote> until they are all exhausted, and then
     execution continues with the next underlying row.
-->
問い合わせの選択リスト内に集合を返す関数が2つ以上ある場合には、振舞いは一つの<literal>LATERAL ROWS FROM( ... )</literal> <literal>FROM</literal>句に関数を置いた場合に得られるものと似ています。
元となる問い合わせからの各行に対して、各関数からの最初の結果を使った出力行、2番目の結果を使った出力行、と続きます。
集合を返す関数の中に他のものより出力の数が少ないものがある場合には、欠けたデータの代わりにNULL値が使われますので、1つの元となる行から作られる行の合計の数は、一番多くの出力を出力する集合を返す関数に対するのと同じだけになります。
そのため、集合を返す関数はすべてが尽きるまで<quote>歩調を合わせて</quote>実行され、それから次の元となる行へと実行が続きます。
    </para>

    <para>
<!--
     Set-returning functions can be nested in a select list, although that is
     not allowed in <literal>FROM</literal>-clause items.  In such cases, each level
     of nesting is treated separately, as though it were
     a separate <literal>LATERAL ROWS FROM( ... )</literal> item.  For example, in
-->
集合を返す関数は、<literal>FROM</literal>句内では許されていませんが、選択リスト内では入れ子にできます。
その場合、入れ子の各階層は、別々の<literal>LATERAL ROWS FROM( ... )</literal>であるかのように別々に扱われます。
例えば、
<programlisting>
SELECT srf1(srf2(x), srf3(y)), srf4(srf5(z)) FROM tab;
</programlisting>
<!--
     the set-returning functions <function>srf2</function>, <function>srf3</function>,
     and <function>srf5</function> would be run in lockstep for each row
     of <structname>tab</structname>, and then <function>srf1</function> and <function>srf4</function>
     would be applied in lockstep to each row produced by the lower
     functions.
-->
では、集合を返す関数<function>srf2</function>、<function>srf3</function>、<function>srf5</function>は<structname>tab</structname>の各行に対して歩調を合わせて実行され、次に階層の低い関数が生成した各行に対して<function>srf1</function>と<function>srf4</function>が歩調を合わせて適用されます。
    </para>

    <para>
<!--
     Set-returning functions cannot be used within conditional-evaluation
     constructs, such as <literal>CASE</literal> or <literal>COALESCE</literal>.  For
     example, consider
-->
集合を返す関数は<literal>CASE</literal>や<literal>COALESCE</literal>のような条件を評価する構成の中では使えません。
例えば、
<programlisting>
SELECT x, CASE WHEN x &gt; 0 THEN generate_series(1, 5) ELSE 0 END FROM tab;
</programlisting>
を考えてください。
<!--
     It might seem that this should produce five repetitions of input rows
     that have <literal>x &gt; 0</literal>, and a single repetition of those that do
     not; but actually, because <function>generate_series(1, 5)</function> would be
     run in an implicit <literal>LATERAL FROM</literal> item before
     the <literal>CASE</literal> expression is ever evaluated, it would produce five
     repetitions of every input row.  To reduce confusion, such cases produce
     a parse-time error instead.
-->
これは、<literal>x &gt; 0</literal>である入力行の5回の繰り返しとそうでないものの1回の繰り返しを生成するように思えるかもしれません。しかし、実際には、<function>generate_series(1, 5)</function>は<literal>CASE</literal>が評価される前に暗黙の<literal>LATERAL FROM</literal>の中で実行されますので、各入力行に対して5回の繰り返しを生成します。
混乱を減らすため、そのような場合にはその代わりに解析時エラーになります。
    </para>

    <note>
     <para>
<!--
      If a function's last command is <command>INSERT</command>, <command>UPDATE</command>,
      or <command>DELETE</command> with <literal>RETURNING</literal>, that command will
      always be executed to completion, even if the function is not declared
      with <literal>SETOF</literal> or the calling query does not fetch all the
      result rows.  Any extra rows produced by the <literal>RETURNING</literal>
      clause are silently dropped, but the commanded table modifications
      still happen (and are all completed before returning from the function).
-->
もし関数の最後のコマンドが<literal>RETURNING</literal>を持つ<command>INSERT</command>、<command>UPDATE</command>、または<command>DELETE</command>である場合、関数が<literal>SETOF</literal>付きで宣言されていない、または呼び出す問い合わせがすべての結果行を取り出さなくても、そのコマンドは完了まで実行されます。
<literal>RETURNING</literal>句で生成される余計な行はすべて警告無しに削除されますが、コマンド対象のテーブルの変更はそれでも起こります（そして、関数から戻る前にすべて完了します）。
     </para>
    </note>

    <note>
     <para>
<!--
      Before <productname>PostgreSQL</productname> 10, putting more than one
      set-returning function in the same select list did not behave very
      sensibly unless they always produced equal numbers of rows.  Otherwise,
      what you got was a number of output rows equal to the least common
      multiple of the numbers of rows produced by the set-returning
      functions.  Also, nested set-returning functions did not work as
      described above; instead, a set-returning function could have at most
      one set-returning argument, and each nest of set-returning functions
      was run independently.  Also, conditional execution (set-returning
      functions inside <literal>CASE</literal> etc) was previously allowed,
      complicating things even more.
      Use of the <literal>LATERAL</literal> syntax is recommended when writing
      queries that need to work in older <productname>PostgreSQL</productname> versions,
      because that will give consistent results across different versions.
      If you have a query that is relying on conditional execution of a
      set-returning function, you may be able to fix it by moving the
      conditional test into a custom set-returning function.  For example,
-->
<productname>PostgreSQL</productname> 10より前では、集合を返す関数を2つ以上同じ選択リストに置くと常に等しい数の行を生成しない限りあまり賢くは振舞いませんでした。
そうでなければ、得られるのは、集合を返す関数が生成する行の数の最小公倍数に等しい数の出力行でした。
また、入れ子の集合を返す関数は上に書いたようには動作しませんでした。代わりに、集合を返す関数は多くても1つの集合を返す引数を持ち、集合を返す関数の各入れ子は独立に実行されました。
また、条件実行(<literal>CASE</literal>等の内側にある集合を返す関数)は以前は認められており、事態をより複雑にしていました。
<productname>PostgreSQL</productname>の古いバージョンで動作することが必要な問い合わせを書く場合には、バージョンが異なっても一貫した結果を返しますので、<literal>LATERAL</literal>構文を使うことを勧めます。
集合を返す関数の条件実行に頼った問い合わせがあるのなら、条件確認を独自の集合を返す関数の中に移動することで修正できます。
例えば
<programlisting>
SELECT x, CASE WHEN y &gt; 0 THEN generate_series(1, z) ELSE 5 END FROM tab;
</programlisting>
<!--
      could become
-->
は
<programlisting>
CREATE FUNCTION case_generate_series(cond bool, start int, fin int, els int)
  RETURNS SETOF int AS $$
BEGIN
  IF cond THEN
    RETURN QUERY SELECT generate_series(start, fin);
  ELSE
    RETURN QUERY SELECT els;
  END IF;
END$$ LANGUAGE plpgsql;

SELECT x, case_generate_series(y &gt; 0, 1, z, 5) FROM tab;
</programlisting>
になります。
<!--
      This formulation will work the same in all versions
      of <productname>PostgreSQL</productname>.
-->
この定式化は<productname>PostgreSQL</productname>のバージョンすべてで同じように動作します。
     </para>
    </note>
   </sect2>

   <sect2 id="xfunc-sql-functions-returning-table">
<!--
    <title><acronym>SQL</acronym> Functions Returning <literal>TABLE</literal></title>
-->
    <title><literal>TABLE</literal>を返す<acronym>SQL</acronym>関数</title>

    <indexterm>
<!--
     <primary>function</primary>
-->
     <primary>関数</primary>
     <secondary>RETURNS TABLE</secondary>
    </indexterm>

    <para>
<!--
     There is another way to declare a function as returning a set,
     which is to use the syntax
     <literal>RETURNS TABLE(<replaceable>columns</replaceable>)</literal>.
     This is equivalent to using one or more <literal>OUT</literal> parameters plus
     marking the function as returning <literal>SETOF record</literal> (or
     <literal>SETOF</literal> a single output parameter's type, as appropriate).
     This notation is specified in recent versions of the SQL standard, and
     thus may be more portable than using <literal>SETOF</literal>.
-->
集合を返すものとして関数を宣言するには、他にも方法があります。
<literal>RETURNS TABLE(<replaceable>columns</replaceable>)</literal>構文を使用することです。
これは１つ以上の<literal>OUT</literal>パラメータを使い、さらに、関数を<literal>SETOF record</literal>（または、適切ならば単一の出力パラメータの型の<literal>SETOF</literal>）を返すものと印を付けることと等価です。
この記法は標準SQLの最近の版で規定されたものですので、<literal>SETOF</literal>を使用するより移植性がより高いかもしれません。
    </para>

    <para>
<!--
     For example, the preceding sum-and-product example could also be
     done this way:
-->
例えば前述の合計と積の例はこのように書けます。

<programlisting>
CREATE FUNCTION sum_n_product_with_tab (x int)
RETURNS TABLE(sum int, product int) AS $$
    SELECT $1 + tab.y, $1 * tab.y FROM tab;
$$ LANGUAGE SQL;
</programlisting>

<!--
     It is not allowed to use explicit <literal>OUT</literal> or <literal>INOUT</literal>
     parameters with the <literal>RETURNS TABLE</literal> notation &mdash; you must
     put all the output columns in the <literal>TABLE</literal> list.
-->
<literal>RETURNS TABLE</literal>記法と一緒に、明示的<literal>OUT</literal>または<literal>INOUT</literal>パラメータを使用することはできません。
すべての出力列を<literal>TABLE</literal>リストに含めなければなりません。
    </para>
   </sect2>

   <sect2 id="xfunc-sql-polymorphic-functions">
<!--
    <title>Polymorphic <acronym>SQL</acronym> Functions</title>
-->
    <title>多様<acronym>SQL</acronym>関数</title>

    <para>
<!--
     <acronym>SQL</acronym> functions can be declared to accept and
     return the polymorphic types described in <xref
     linkend="extend-types-polymorphic"/>.  Here is a polymorphic
     function <function>make_array</function> that builds up an array
     from two arbitrary data type elements:
-->
<acronym>SQL</acronym>関数は、<xref linkend="extend-types-polymorphic"/>の多様型を受け付け、返すように宣言することができます。
以下の<function>make_array</function>多様関数は、任意の2つのデータ型要素から配列を作成します。
<screen>
CREATE FUNCTION make_array(anyelement, anyelement) RETURNS anyarray AS $$
    SELECT ARRAY[$1, $2];
$$ LANGUAGE SQL;

SELECT make_array(1, 2) AS intarray, make_array('a'::text, 'b') AS textarray;
 intarray | textarray
----------+-----------
 {1,2}    | {a,b}
(1 row)
</screen>
    </para>

    <para>
<!--
     Notice the use of the typecast <literal>'a'::text</literal>
     to specify that the argument is of type <type>text</type>. This is
     required if the argument is just a string literal, since otherwise
     it would be treated as type
     <type>unknown</type>, and array of <type>unknown</type> is not a valid
     type.
     Without the typecast, you will get errors like this:
-->
<literal>'a'::text</literal>という型キャストを使用して、引数が<type>text</type>型であることを指定していることに注目してください。
これは引数が単なる文字列リテラルである場合に必要です。
さもないと、<type>unknown</type>型として扱われてしまうため、無効な<type>unknown</type>の配列を返そうとしてしまいます。
型キャストがないと、以下のようなエラーが発生します。
<screen>
ERROR:  could not determine polymorphic type because input has type unknown
</screen>
    </para>

    <para>
<!--
     With <function>make_array</function> declared as above, you must
     provide two arguments that are of exactly the same data type; the
     system will not attempt to resolve any type differences.  Thus for
     example this does not work:
-->
上記のように<function>make_array</function>を宣言した場合、まったく同じデータ型の2つの引数を指定する必要があります。
システムは型の違いを解決しようとしません。
したがって、例えばこれはうまくいきません。
<screen>
SELECT make_array(1, 2.5) AS numericarray;
ERROR:  function make_array(integer, numeric) does not exist
</screen>
<!--
     An alternative approach is to use the <quote>common</quote> family of
     polymorphic types, which allows the system to try to identify a
     suitable common type:
-->
別の方法として、<quote>共通</quote>族の多様型を使用する方法があります。
これにより、システムは適切な共通の型を特定できます。
<screen>
CREATE FUNCTION make_array2(anycompatible, anycompatible)
RETURNS anycompatiblearray AS $$
    SELECT ARRAY[$1, $2];
$$ LANGUAGE SQL;

SELECT make_array2(1, 2.5) AS numericarray;
 numericarray
--------------
 {1,2.5}
(1 row)
</screen>
<!--
     Because the rules for common type resolution default to choosing
     type <type>text</type> when all inputs are of unknown types, this
     also works:
-->
すべての入力が未知の型である場合、共通の型を解決するルールはデフォルトで<type>text</type>型を選択するので、これも動作します。
<screen>
SELECT make_array2('a', 'b') AS textarray;
 textarray 
-----------
 {a,b}
(1 row)
</screen>
    </para>

    <para>
<!--
     It is permitted to have polymorphic arguments with a fixed
     return type, but the converse is not. For example:
-->
固定の戻り値型を持ちながら多様引数を持つことは許されますが、逆は許されません。
以下に例を示します。
<screen>
CREATE FUNCTION is_greater(anyelement, anyelement) RETURNS boolean AS $$
    SELECT $1 &gt; $2;
$$ LANGUAGE SQL;

SELECT is_greater(1, 2);
 is_greater
------------
 f
(1 row)

CREATE FUNCTION invalid_func() RETURNS anyelement AS $$
    SELECT 1;
$$ LANGUAGE SQL;
ERROR:  cannot determine result data type
DETAIL:  A result of type anyelement requires at least one input of type anyelement, anyarray, anynonarray, anyenum, or anyrange.
</screen>
    </para>

    <para>
<!--
     Polymorphism can be used with functions that have output arguments.
     For example:
-->
出力引数を持つ関数でも多様性を使用することができます。
以下に例を示します。
<screen>
CREATE FUNCTION dup (f1 anyelement, OUT f2 anyelement, OUT f3 anyarray)
AS 'select $1, array[$1,$1]' LANGUAGE SQL;

SELECT * FROM dup(22);
 f2 |   f3
----+---------
 22 | {22,22}
(1 row)
</screen>
    </para>

    <para>
<!--
     Polymorphism can also be used with variadic functions.
     For example:
-->
多様性はvariadic関数とともに使用できます。例をあげます。
<screen>
CREATE FUNCTION anyleast (VARIADIC anyarray) RETURNS anyelement AS $$
    SELECT min($1[i]) FROM generate_subscripts($1, 1) g(i);
$$ LANGUAGE SQL;

SELECT anyleast(10, -1, 5, 4);
 anyleast 
----------
       -1
(1 row)

SELECT anyleast('abc'::text, 'def');
 anyleast 
----------
 abc
(1 row)

CREATE FUNCTION concat_values(text, VARIADIC anyarray) RETURNS text AS $$
    SELECT array_to_string($2, $1);
$$ LANGUAGE SQL;

SELECT concat_values('|', 1, 4, 2);
 concat_values 
---------------
 1|4|2
(1 row)
</screen>
    </para>
   </sect2>

   <sect2>
<!--
    <title><acronym>SQL</acronym> Functions with Collations</title>
-->
    <title>照合順序を持つ<acronym>SQL</acronym>関数</title>

    <indexterm>
<!--
     <primary>collation</primary>
     <secondary>in SQL functions</secondary>
-->
     <primary>照合順序</primary>
     <secondary>SQL関数における</secondary>
    </indexterm>

    <para>
<!--
     When a SQL function has one or more parameters of collatable data types,
     a collation is identified for each function call depending on the
     collations assigned to the actual arguments, as described in <xref
     linkend="collation"/>.  If a collation is successfully identified
     (i.e., there are no conflicts of implicit collations among the arguments)
     then all the collatable parameters are treated as having that collation
     implicitly.  This will affect the behavior of collation-sensitive
     operations within the function.  For example, using the
     <function>anyleast</function> function described above, the result of
-->
SQL関数が照合順序の変更が可能なデータ型のパラメータを１つ以上持つ場合、それぞれの関数呼び出しに対して、実引数に割り当てられた照合順序に応じて、照合順序が識別されます。
照合順序の識別に成功した（つまり、暗黙的な照合順序がすべての引数で競合しない）場合、すべての照合順序の変更が可能なパラメータは暗黙的に照合順序を持つものとして扱われます。
これは関数内の照合順序に依存する操作の振舞いに影響します。
例えば、上記の<function>anyleast</function>を使って考えます。
<programlisting>
SELECT anyleast('abc'::text, 'ABC');
</programlisting>
<!--
     will depend on the database's default collation.  In <literal>C</literal> locale
     the result will be <literal>ABC</literal>, but in many other locales it will
     be <literal>abc</literal>.  The collation to use can be forced by adding
     a <literal>COLLATE</literal> clause to any of the arguments, for example
-->
この結果はデータベースのデフォルト照合順序に依存します。
<literal>C</literal>ロケールでは<literal>ABC</literal>という結果になりますが、他の多くのロケールでは<literal>abc</literal>になります。
使用される照合順序を<literal>COLLATE</literal>句を付与することで強制することができます。
例を以下に示します。
<programlisting>
SELECT anyleast('abc'::text, 'ABC' COLLATE "C");
</programlisting>
<!--
     Alternatively, if you wish a function to operate with a particular
     collation regardless of what it is called with, insert
     <literal>COLLATE</literal> clauses as needed in the function definition.
     This version of <function>anyleast</function> would always use <literal>en_US</literal>
     locale to compare strings:
-->
この他、呼び出し元の照合順序とは関係なく特定の照合順序で動作する関数にしたければ、関数定義において必要な所に<literal>COLLATE</literal>句を付けてください。
以下の<function>anyleast</function>では、文字列を比較する際に常に<literal>en_US</literal>を使用します。
<programlisting>
CREATE FUNCTION anyleast (VARIADIC anyarray) RETURNS anyelement AS $$
    SELECT min($1[i] COLLATE "en_US") FROM generate_subscripts($1, 1) g(i);
$$ LANGUAGE SQL;
</programlisting>
<!--
     But note that this will throw an error if applied to a non-collatable
     data type.
-->
しかし、もし照合順序の変更ができないデータ型が与えられた場合にエラーになってしまうことに注意してください。
    </para>

    <para>
<!--
     If no common collation can be identified among the actual arguments,
     then a SQL function treats its parameters as having their data types'
     default collation (which is usually the database's default collation,
     but could be different for parameters of domain types).
-->
実引数全体で共通の照合順序を識別できない場合、SQL関数はパラメータがそのデータ型のデフォルト照合順序（通常はデータベースのデフォルトの照合順序ですが、ドメイン型のパラメータでは異なる可能性があります）を持つものとみなします。
    </para>

    <para>
<!--
     The behavior of collatable parameters can be thought of as a limited
     form of polymorphism, applicable only to textual data types.
-->
照合順序の変更ができるパラメータの動作は、テキストのデータ型にのみ適用できる、限定された多様性と考えることができます。
    </para>
   </sect2>
  </sect1>

  <sect1 id="xfunc-overload">
<!--
   <title>Function Overloading</title>
-->
<title>関数のオーバーロード</title>

   <indexterm zone="xfunc-overload">
<!--
    <primary>overloading</primary>
    <secondary>functions</secondary>
-->
    <primary>オーバーロード</primary>
    <secondary>関数</secondary>
   </indexterm>

   <para>
<!--
    More than one function can be defined with the same SQL name, so long
    as the arguments they take are different.  In other words,
    function names can be <firstterm>overloaded</firstterm>.  Whether or not
    you use it, this capability entails security precautions when calling
    functions in databases where some users mistrust other users; see
    <xref linkend="typeconv-func"/>.  When a query is executed, the server
    will determine which function to call from the data types and the number
    of the provided arguments.  Overloading can also be used to simulate
    functions with a variable number of arguments, up to a finite maximum
    number.
-->
使用する引数が異なるのであれば、同じSQL名の関数を1つ以上定義することができます。
つまり、関数名は<firstterm>オーバーロード</firstterm>が可能です。
使うかどうかに関わりなく、この能力は、あるユーザが他のユーザを信用しないデータベースで関数を呼び出す時に、セキュリティの事前の対策を必要とします。<xref linkend="typeconv-func"/>を参照してください。
問い合わせが実行された時、サーバは与えられた引数のデータ型と数によって呼び出すべき関数を決定します。
またオーバーロードを使用して、有限個の可変長引数を持つ関数を模擬することができます。
   </para>

   <para>
<!--
    When creating a family of overloaded functions, one should be
    careful not to create ambiguities.  For instance, given the
    functions:
-->
オーバーロード関数を作成する時、曖昧さが発生しないように注意しなければなりません。
例えば、以下のような関数を考えてみます。
<programlisting>
CREATE FUNCTION test(int, real) RETURNS ...
CREATE FUNCTION test(smallint, double precision) RETURNS ...
</programlisting>
<!--
    it is not immediately clear which function would be called with
    some trivial input like <literal>test(1, 1.5)</literal>.  The
    currently implemented resolution rules are described in
    <xref linkend="typeconv"/>, but it is unwise to design a system that subtly
    relies on this behavior.
-->
<literal>test(1, 1.5)</literal>のような平凡な入力でも、どちらの関数を呼び出すのかはすぐには明確ではありません。
現在実装されている解決規則は<xref linkend="typeconv"/>にて説明していますが、この動作に巧妙に依存するようにシステムを設計することは推奨しません。
   </para>

   <para>
<!--
    A function that takes a single argument of a composite type should
    generally not have the same name as any attribute (field) of that type.
    Recall that <literal><replaceable>attribute</replaceable>(<replaceable>table</replaceable>)</literal>
    is considered equivalent
    to <literal><replaceable>table</replaceable>.<replaceable>attribute</replaceable></literal>.
    In the case that there is an
    ambiguity between a function on a composite type and an attribute of
    the composite type, the attribute will always be used.  It is possible
    to override that choice by schema-qualifying the function name
    (that is, <literal><replaceable>schema</replaceable>.<replaceable>func</replaceable>(<replaceable>table</replaceable>)
    </literal>) but it's better to
    avoid the problem by not choosing conflicting names.
-->
一般的に、1つの複合型の引数を取る関数は、その型の属性（フィールド）と同じ名前を持ってはいけません。
<literal><replaceable>attribute</replaceable>(<replaceable>table</replaceable>)</literal>が<literal><replaceable>table</replaceable>.<replaceable>attribute</replaceable></literal>と等価とみなされることを思い出してください。
複合型に対する関数と複合型の属性との間に曖昧さがあるような場合、属性の方が常に使用されます。
この振舞いは関数名をスキーマで修飾する（つまり、<literal><replaceable>schema</replaceable>.<replaceable>func</replaceable>(<replaceable>table</replaceable>)</literal>）ことにより変更できますが、競合する名前を使用しないことで問題を防ぐ方が良いでしょう。
   </para>

   <para>
<!--
    Another possible conflict is between variadic and non-variadic functions.
    For instance, it is possible to create both <literal>foo(numeric)</literal> and
    <literal>foo(VARIADIC numeric[])</literal>.  In this case it is unclear which one
    should be matched to a call providing a single numeric argument, such as
    <literal>foo(10.1)</literal>.  The rule is that the function appearing
    earlier in the search path is used, or if the two functions are in the
    same schema, the non-variadic one is preferred.
-->
可変長引数を取る関数と可変長引数を取らない関数の間に、他にも競合する可能性があります。
例えば、<literal>foo(numeric)</literal>と<literal>foo(VARIADIC numeric[])</literal>の両方を作成することが可能です。
この場合、単一の数値引数を取った呼び出し、例えば<literal>foo(10.1)</literal>をどちらに一致するものとすべきか不明瞭です。
検索パスのより前にある関数が使われる、もし2つの関数が同一スキーマにあれば可変長引数を取らない関数が優先されるというのが、この場合の規則です。
   </para>

   <para>
<!--
    When overloading C-language functions, there is an additional
    constraint: The C name of each function in the family of
    overloaded functions must be different from the C names of all
    other functions, either internal or dynamically loaded.  If this
    rule is violated, the behavior is not portable.  You might get a
    run-time linker error, or one of the functions will get called
    (usually the internal one).  The alternative form of the
    <literal>AS</literal> clause for the SQL <command>CREATE
    FUNCTION</command> command decouples the SQL function name from
    the function name in the C source code.  For instance:
-->
C言語関数をオーバーロードする場合、さらに制限があります。
オーバーロードされた関数群内の各関数のCの名前は、内部か動的ロードされたかに関係なく他のすべての関数のCの名前と異なる必要があります。
この規則に反した場合は、この動作は移植性がありません。
実行時リンカエラーになるかもしれませんし、関数群のどれか（たいていは内部関数）が呼び出されるかもしれません。
<command>CREATE FUNCTION</command> SQLコマンドの別形式の<literal>AS</literal>句は、SQL関数名とCソースコード内の関数名とを分離します。
以下に例を示します。
<programlisting>
CREATE FUNCTION test(int) RETURNS int
    AS '<replaceable>filename</replaceable>', 'test_1arg'
    LANGUAGE C;
CREATE FUNCTION test(int, int) RETURNS int
    AS '<replaceable>filename</replaceable>', 'test_2arg'
    LANGUAGE C;
</programlisting>
<!--
    The names of the C functions here reflect one of many possible conventions.
-->
ここでのC関数の名前は多くの取り得る規約の1つを反映しています。
   </para>
  </sect1>

  <sect1 id="xfunc-volatility">
<!--
   <title>Function Volatility Categories</title>
-->
   <title>関数の変動性分類</title>

   <indexterm zone="xfunc-volatility">
<!--
    <primary>volatility</primary>
    <secondary>functions</secondary>
-->
    <primary>変動性</primary>
    <secondary>関数</secondary>
   </indexterm>
   <indexterm zone="xfunc-volatility">
    <primary>VOLATILE</primary>
   </indexterm>
   <indexterm zone="xfunc-volatility">
    <primary>STABLE</primary>
   </indexterm>
   <indexterm zone="xfunc-volatility">
    <primary>IMMUTABLE</primary>
   </indexterm>

   <para>
<!--
    Every function has a <firstterm>volatility</firstterm> classification, with
    the possibilities being <literal>VOLATILE</literal>, <literal>STABLE</literal>, or
    <literal>IMMUTABLE</literal>.  <literal>VOLATILE</literal> is the default if the
    <xref linkend="sql-createfunction"/>
    command does not specify a category.  The volatility category is a
    promise to the optimizer about the behavior of the function:
-->
すべての関数は<firstterm>変動性</firstterm>区分を持ちます。
取り得る区分は、<literal>VOLATILE</literal>、<literal>STABLE</literal>、もしくは<literal>IMMUTABLE</literal>です。
<xref linkend="sql-createfunction"/>コマンドで分類の指定がなければデフォルトで<literal>VOLATILE</literal>になります。
変動性に関する分類は、その関数の動作に関するオプティマイザへの約束事です。

   <itemizedlist>
    <listitem>
     <para>
<!--
      A <literal>VOLATILE</literal> function can do anything, including modifying
      the database.  It can return different results on successive calls with
      the same arguments.  The optimizer makes no assumptions about the
      behavior of such functions.  A query using a volatile function will
      re-evaluate the function at every row where its value is needed.
-->
<literal>VOLATILE</literal>関数は、データベースの変更を含む、すべてを行うことができます。
同一引数で続けて呼び出したとしても異なる結果を返すことができます。
オプティマイザはこうした関数の振舞いに対する前提を持ちません。
VOLATILE関数を使用した問い合わせは、その行の値を必要とするすべての行においてその関数を再評価します。
     </para>
    </listitem>
    <listitem>
     <para>
<!--
      A <literal>STABLE</literal> function cannot modify the database and is
      guaranteed to return the same results given the same arguments
      for all rows within a single statement. This category allows the
      optimizer to optimize multiple calls of the function to a single
      call. In particular, it is safe to use an expression containing
      such a function in an index scan condition. (Since an index scan
      will evaluate the comparison value only once, not once at each
      row, it is not valid to use a <literal>VOLATILE</literal> function in an
      index scan condition.)
-->
<literal>STABLE</literal>関数はデータベースを変更することができません。
また、単一の文内ですべての行に対して同一の引数を渡した場合に同一の結果を返すことが保証されています。
この区分により、オプティマイザは複数の関数の呼び出しを１つの呼び出しに最適化することができます。
特に、インデックススキャン条件内でこうした関数を含んだ式を使用することは安全です。
（インデックススキャンは行ごとに一度ではなく、一度だけ比較値の評価を行いますので、インデックススキャン条件内で<literal>VOLATILE</literal>関数を使用することは意味がありません。）
     </para>
    </listitem>
    <listitem>
     <para>
<!--
      An <literal>IMMUTABLE</literal> function cannot modify the database and is
      guaranteed to return the same results given the same arguments forever.
      This category allows the optimizer to pre-evaluate the function when
      a query calls it with constant arguments.  For example, a query like
      <literal>SELECT ... WHERE x = 2 + 2</literal> can be simplified on sight to
      <literal>SELECT ... WHERE x = 4</literal>, because the function underlying
      the integer addition operator is marked <literal>IMMUTABLE</literal>.
-->
<literal>IMMUTABLE</literal>関数はデータベースを変更することができません。
また、同一引数に対する呼び出しは常に同一の結果を返すことが保証されています。
問い合わせが定数の引数でこうした関数を呼び出した場合、オプティマイザはこの関数を事前に評価することができます。
例えば、<literal>SELECT ... WHERE x = 2 + 2</literal>といった問い合わせは、<literal>SELECT ... WHERE x = 4</literal>のように単純化することができます。
これは、整数加算演算子の基になる関数が<literal>IMMUTABLE</literal>として宣言されているためです。
     </para>
    </listitem>
   </itemizedlist>
   </para>

   <para>
<!--
    For best optimization results, you should label your functions with the
    strictest volatility category that is valid for them.
-->
最適化の結果を最善にするためには、関数に対して有効かつ最も厳密な変動性区分を付けなければなりません。
   </para>

   <para>
<!--
    Any function with side-effects <emphasis>must</emphasis> be labeled
    <literal>VOLATILE</literal>, so that calls to it cannot be optimized away.
    Even a function with no side-effects needs to be labeled
    <literal>VOLATILE</literal> if its value can change within a single query;
    some examples are <literal>random()</literal>, <literal>currval()</literal>,
    <literal>timeofday()</literal>.
-->
副作用を持つ関数はすべて<literal>VOLATILE</literal>と付けなければ<emphasis>なりません</emphasis>。
こうした関数は最適化することができないためです。
関数が副作用を持たなかったとしても、単一問い合わせ内で値が変動する場合は<literal>VOLATILE</literal>と付けなければなりません。
例えば、<literal>random()</literal>、<literal>currval()</literal>、<literal>timeofday()</literal>などです。
   </para>

   <para>
<!--
    Another important example is that the <function>current_timestamp</function>
    family of functions qualify as <literal>STABLE</literal>, since their values do
    not change within a transaction.
-->
その他の重要な例は、<function>current_timestamp</function>系列の関数は、それらの値がトランザクション内で変わらないことから、<literal>STABLE</literal>と見なされます。
   </para>

   <para>
<!--
    There is relatively little difference between <literal>STABLE</literal> and
    <literal>IMMUTABLE</literal> categories when considering simple interactive
    queries that are planned and immediately executed: it doesn't matter
    a lot whether a function is executed once during planning or once during
    query execution startup.  But there is a big difference if the plan is
    saved and reused later.  Labeling a function <literal>IMMUTABLE</literal> when
    it really isn't might allow it to be prematurely folded to a constant during
    planning, resulting in a stale value being re-used during subsequent uses
    of the plan.  This is a hazard when using prepared statements or when
    using function languages that cache plans (such as
    <application>PL/pgSQL</application>).
-->
計画作成を行い、すぐに実行されるような単一の対話式問い合わせを考えた場合、相対的に<literal>STABLE</literal>区分と<literal>IMMUTABLE</literal>区分との違いはあまりありません。
このような場合、関数が計画作成中に一度実行されるか、問い合わせ実行中に一度実行されるかがあまり問題になりません。
しかし、計画が保存され、後で再利用される場合は大きな違いが現れます。
本来ならば関数が計画作成段階で早めに定数を保持することができない場合に<literal>IMMUTABLE</literal>を付けると、その後にこの計画を使用する時に古くて意味のない値が再利用されてしまうことになります。
これは、プリペアド文や計画をキャッシュする関数言語（<application>PL/pgSQL</application>など）を使用する場合は危険です。
   </para>

   <para>
<!--
    For functions written in SQL or in any of the standard procedural
    languages, there is a second important property determined by the
    volatility category, namely the visibility of any data changes that have
    been made by the SQL command that is calling the function.  A
    <literal>VOLATILE</literal> function will see such changes, a <literal>STABLE</literal>
    or <literal>IMMUTABLE</literal> function will not.  This behavior is implemented
    using the snapshotting behavior of MVCC (see <xref linkend="mvcc"/>):
    <literal>STABLE</literal> and <literal>IMMUTABLE</literal> functions use a snapshot
    established as of the start of the calling query, whereas
    <literal>VOLATILE</literal> functions obtain a fresh snapshot at the start of
    each query they execute.
-->
SQLもしくは標準手続き言語で作成された関数では、変動性分類で決定される２番目に重要な性質があります。
すなわち、その関数を呼び出すSQLコマンドによりなされてきたすべてのデータ変更の可視性です。
<literal>VOLATILE</literal>関数はそのような変更を捕らえますが、<literal>STABLE</literal>または<literal>IMMUTABLE</literal>関数はそうしません。
この動作はMVCC（<xref linkend="mvcc"/>を参照）のスナップショット処理の動作を使用して実装されています。
<literal>STABLE</literal>と<literal>IMMUTABLE</literal>関数は、呼び出す問い合わせの開始時点で成立したスナップショットを使用しますが、<literal>VOLATILE</literal>関数はそれぞれの問い合わせの実行開始時点の作りたてのスナップショットを取得します。
   </para>

   <note>
    <para>
<!--
     Functions written in C can manage snapshots however they want, but it's
     usually a good idea to make C functions work this way too.
-->
しかし、C言語で作成された関数は、どのようにでもスナップショットを管理することができますが、通常C関数でもこのように動作させることは良い考えです。
    </para>
   </note>

   <para>
<!--
    Because of this snapshotting behavior,
    a function containing only <command>SELECT</command> commands can safely be
    marked <literal>STABLE</literal>, even if it selects from tables that might be
    undergoing modifications by concurrent queries.
    <productname>PostgreSQL</productname> will execute all commands of a
    <literal>STABLE</literal> function using the snapshot established for the
    calling query, and so it will see a fixed view of the database throughout
    that query.
-->
このスナップショット処理の動作のため、同時実行の問い合わせによって別途変更されている可能性があるテーブルから選択していたとしても、<command>SELECT</command>コマンドのみを含む関数は、安全に<literal>STABLE</literal>とすることができます。
<productname>PostgreSQL</productname>は、呼び出し元の問い合わせに対して確立されたスナップショットを使用して<literal>STABLE</literal>関数のすべてのコマンドを実行します。
したがってその問い合わせの間、データベースに対して固定された視点で値を参照することになります。
   </para>

   <para>
<!--
    The same snapshotting behavior is used for <command>SELECT</command> commands
    within <literal>IMMUTABLE</literal> functions.  It is generally unwise to select
    from database tables within an <literal>IMMUTABLE</literal> function at all,
    since the immutability will be broken if the table contents ever change.
    However, <productname>PostgreSQL</productname> does not enforce that you
    do not do that.
-->
<literal>IMMUTABLE</literal>関数内の<command>SELECT</command>コマンドも同様のスナップショット処理の動作を使用します。
ただし、一般的に、<literal>IMMUTABLE</literal>関数内でデータベースのテーブルを検索（SELECT）することは勧められません。
テーブルの内容が変わってしまった場合にその不変性が壊れてしまうためです。
しかし、<productname>PostgreSQL</productname>では強制的に検索（SELECT）できないようにはしていません。
   </para>

   <para>
<!--
    A common error is to label a function <literal>IMMUTABLE</literal> when its
    results depend on a configuration parameter.  For example, a function
    that manipulates timestamps might well have results that depend on the
    <xref linkend="guc-timezone"/> setting.  For safety, such functions should
    be labeled <literal>STABLE</literal> instead.
-->
よくあるエラーは、設定パラメータに依存する結果となる関数に<literal>IMMUTABLE</literal>と付けることです。
例えば、タイムスタンプを操作する関数は、おそらく<xref linkend="guc-timezone"/>の設定に依存した結果になります。
こうした関数は、安全のため代わりに<literal>STABLE</literal>と付けてください。
   </para>

   <note>
    <para>
<!--
     <productname>PostgreSQL</productname> requires that <literal>STABLE</literal>
     and <literal>IMMUTABLE</literal> functions contain no SQL commands other
     than <command>SELECT</command> to prevent data modification.
     (This is not a completely bulletproof test, since such functions could
     still call <literal>VOLATILE</literal> functions that modify the database.
     If you do that, you will find that the <literal>STABLE</literal> or
     <literal>IMMUTABLE</literal> function does not notice the database changes
     applied by the called function, since they are hidden from its snapshot.)
-->
<productname>PostgreSQL</productname>はデータの変更を防ぐために<literal>STABLE</literal>関数と<literal>IMMUTABLE</literal>関数が<command>SELECT</command>以外のSQLコマンドを含まないことを要求します。
（こうした関数はまだデータベースを変更する<literal>VOLATILE</literal>関数を呼び出すことができますので、これは防弾条件として完全ではありません。
これを行うと、<literal>STABLE</literal>もしくは<literal>IMMUTABLE</literal>関数は、そのスナップショットからそれらが隠されていることから、呼び出した関数によるデータベースの変更に気がつきません。）
    </para>
   </note>
  </sect1>

  <sect1 id="xfunc-pl">
<!--
   <title>Procedural Language Functions</title>
-->
<title>手続き型言語関数</title>

   <para>
<!--
    <productname>PostgreSQL</productname> allows user-defined functions
    to be written in other languages besides SQL and C.  These other
    languages are generically called <firstterm>procedural
    languages</firstterm> (<acronym>PL</acronym>s).
    Procedural languages aren't built into the
    <productname>PostgreSQL</productname> server; they are offered
    by loadable modules.
    See <xref linkend="xplang"/> and following chapters for more
    information.
-->
<productname>PostgreSQL</productname>ではSQLやC言語以外の言語でユーザ定義の関数を作成することができます。
これらの他の言語は一般に<firstterm>手続き言語</firstterm>（<acronym>PL</acronym>）と呼ばれます。
手続き言語は<productname>PostgreSQL</productname>サーバに組み込まれておらず、ロード可能モジュールとして提供されています。
詳細は<xref linkend="xplang"/>と以下の章を参照してください。
   </para>
  </sect1>

  <sect1 id="xfunc-internal">
<!--
   <title>Internal Functions</title>
-->
<title>内部関数</title>

<!--
   <indexterm zone="xfunc-internal"><primary>function</primary><secondary>internal</secondary></indexterm>
-->
   <indexterm zone="xfunc-internal"><primary>関数</primary><secondary>内部</secondary></indexterm>

   <para>
<!--
    Internal functions are functions written in C that have been statically
    linked into the <productname>PostgreSQL</productname> server.
    The <quote>body</quote> of the function definition
    specifies the C-language name of the function, which need not be the
    same as the name being declared for SQL use.
    (For reasons of backward compatibility, an empty body
    is accepted as meaning that the C-language function name is the
    same as the SQL name.)
-->
内部関数とは、Cで作成された、<productname>PostgreSQL</productname>サーバに静的にリンクされた関数です。
関数定義の<quote>本体</quote>では関数のC言語における名前を指定します。
この名前をSQLでの使用のために宣言される名前と同じにする必要はありません。
（後方互換性のため、C言語関数名がSQL名と同じであるという意味として、空の本体も受け付けられます。）
   </para>

   <para>
<!--
    Normally, all internal functions present in the
    server are declared during the initialization of the database cluster
    (see <xref linkend="creating-cluster"/>),
    but a user could use <command>CREATE FUNCTION</command>
    to create additional alias names for an internal function.
    Internal functions are declared in <command>CREATE FUNCTION</command>
    with language name <literal>internal</literal>.  For instance, to
    create an alias for the <function>sqrt</function> function:
-->
通常、サーバに存在するすべての内部関数は、データベースクラスタの初期化（<xref linkend="creating-cluster"/>参照）の際に宣言されますが、ユーザは<command>CREATE FUNCTION</command>を使用して、内部関数の別名をさらに作成することができます。
内部関数は<literal>internal</literal>という言語名を付けた<command>CREATE FUNCTION</command>によって宣言されます。
例えば、<function>sqrt</function>関数の別名を作成するには以下のようにします。
<programlisting>
CREATE FUNCTION square_root(double precision) RETURNS double precision
    AS 'dsqrt'
    LANGUAGE internal
    STRICT;
</programlisting>
<!--
    (Most internal functions expect to be declared <quote>strict</quote>.)
-->
（ほとんどの内部関数は<quote>strict</quote>として宣言されることを想定しています。）
   </para>

   <note>
    <para>
<!--
     Not all <quote>predefined</quote> functions are
     <quote>internal</quote> in the above sense.  Some predefined
     functions are written in SQL.
-->
<quote>定義済みの</quote>関数のすべてが上の意味での<quote>内部</quote>ではありません。
SQLで作成された定義済み関数もあります。
    </para>
   </note>
  </sect1>

  <sect1 id="xfunc-c">
<!--
   <title>C-Language Functions</title>
-->
<title>C言語関数</title>

   <indexterm zone="xfunc-c">
<!--
    <primary>function</primary>
    <secondary>user-defined</secondary>
    <tertiary>in C</tertiary>
-->
    <primary>関数</primary>
    <secondary>ユーザ定義</secondary>
    <tertiary>Cで作成された</tertiary>
   </indexterm>

   <para>
<!--
    User-defined functions can be written in C (or a language that can
    be made compatible with C, such as C++).  Such functions are
    compiled into dynamically loadable objects (also called shared
    libraries) and are loaded by the server on demand.  The dynamic
    loading feature is what distinguishes <quote>C language</quote> functions
    from <quote>internal</quote> functions &mdash; the actual coding conventions
    are essentially the same for both.  (Hence, the standard internal
    function library is a rich source of coding examples for user-defined
    C functions.)
-->
ユーザ定義の関数はC（もしくはC++のようなCと互換性のある言語）で作成することができます。
そのような関数は動的ロード可能オブジェクト（共有ライブラリとも呼ばれます）としてコンパイルされ、必要に応じてサーバにロードされます。
動的ロード機能が、<quote>C言語</quote>関数を<quote>内部</quote>関数と区別するものです。
コーディング方法は基本的に両方とも同じです。
（したがって、標準内部関数ライブラリはユーザ定義のC関数のコーディング例の豊富な情報源となります。）
   </para>

   <para>
<!--
    Currently only one calling convention is used for C functions
    (<quote>version 1</quote>). Support for that calling convention is
    indicated by writing a <literal>PG_FUNCTION_INFO_V1()</literal> macro
    call for the function, as illustrated below.
-->
現在、1つの呼び出し規約だけがC関数で使用されています(<quote>version 1</quote>)。
その呼び出し規約をサポートしていることは、以下に示すように、その関数用に呼び出しマクロ<literal>PG_FUNCTION_INFO_V1()</literal>を書くことで示されます。
   </para>

  <sect2 id="xfunc-c-dynload">
<!--
   <title>Dynamic Loading</title>
-->
<title>動的ロード</title>

   <indexterm zone="xfunc-c-dynload">
<!--
    <primary>dynamic loading</primary>
-->
    <primary>動的ロード</primary>
   </indexterm>

   <para>
<!--
    The first time a user-defined function in a particular
    loadable object file is called in a session,
    the dynamic loader loads that object file into memory so that the
    function can be called.  The <command>CREATE FUNCTION</command>
    for a user-defined C function must therefore specify two pieces of
    information for the function: the name of the loadable
    object file, and the C name (link symbol) of the specific function to call
    within that object file.  If the C name is not explicitly specified then
    it is assumed to be the same as the SQL function name.
-->
特定のロード可能オブジェクト内のユーザ定義の関数がセッションで最初に呼び出されると、動的ローダは、その関数を呼び出すことができるように、オブジェクトファイルをメモリ内に読み込みます。
そのため、ユーザ定義のC関数用の<command>CREATE FUNCTION</command>はその関数について、ロード可能オブジェクトファイルの名前とオブジェクトファイル中の呼び出される特定の関数のC名称（リンクシンボル）という2つの情報を指定しなければなりません。
C名称が明示的に指定されなかった場合、SQLにおける関数名と同じものと仮定されます。
   </para>

   <para>
<!--
    The following algorithm is used to locate the shared object file
    based on the name given in the <command>CREATE FUNCTION</command>
    command:
-->
<command>CREATE FUNCTION</command>コマンドで与えられた名前に基づいて、共有オブジェクトファイルの場所を見つける際に以下のアルゴリズムが使用されます。

    <orderedlist>
     <listitem>
      <para>
<!--
       If the name is an absolute path, the given file is loaded.
-->
名前が絶対パスの場合、指定されたファイルが読み込まれます。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       If the name starts with the string <literal>$libdir</literal>,
       that part is replaced by the <productname>PostgreSQL</productname> package
        library directory
       name, which is determined at build time.<indexterm><primary>$libdir</primary></indexterm>
-->
名前が<literal>$libdir</literal>という文字列から始まる場合、その部分は<productname>PostgreSQL</productname>パッケージのライブラリディレクトリで置き換えられます。
このディレクトリはビルド時に決定されます。
<indexterm><primary>$libdir</primary></indexterm>
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       If the name does not contain a directory part, the file is
       searched for in the path specified by the configuration variable
       <xref linkend="guc-dynamic-library-path"/>.<indexterm><primary>dynamic_library_path</primary></indexterm>
-->
名前にディレクトリ部分がない場合、そのファイルは<xref linkend="guc-dynamic-library-path"/>設定変数で指定されたパス内から検索されます。
<indexterm><primary>dynamic_library_path</primary></indexterm>
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       Otherwise (the file was not found in the path, or it contains a
       non-absolute directory part), the dynamic loader will try to
       take the name as given, which will most likely fail.  (It is
       unreliable to depend on the current working directory.)
-->
上記以外の場合（ファイルがパス内に存在しない場合や相対ディレクトリ部分を持つ場合）、動的ローダは指定された名前をそのまま使用し、ほとんどの場合は失敗します。
（これは現在の作業ディレクトリに依存するため信頼できません。）
      </para>
     </listitem>
    </orderedlist>

<!--
    If this sequence does not work, the platform-specific shared
    library file name extension (often <filename>.so</filename>) is
    appended to the given name and this sequence is tried again.  If
    that fails as well, the load will fail.
-->
ここまでの流れがうまくいかなかった場合、プラットフォーム独自の共有ライブラリファイル拡張子（多くの場合<filename>.so</filename>）が指定された名前に追加され、再度この流れを試みます。
同様に失敗した場合は、読み込みは失敗します。
   </para>

   <para>
<!--
    It is recommended to locate shared libraries either relative to
    <literal>$libdir</literal> or through the dynamic library path.
    This simplifies version upgrades if the new installation is at a
    different location.  The actual directory that
    <literal>$libdir</literal> stands for can be found out with the
    command <literal>pg_config &#045;&#045;pkglibdir</literal>.
-->
共有ライブラリを<literal>$libdir</literal>から相対的に、もしくは動的ライブラリパスの通った所に配置することを推奨します。
異なる場所に新しいインストレーションを配置する場合にバージョンアップを簡単にします。
<literal>$libdir</literal>が示す実際のディレクトリは<literal>pg_config --pkglibdir</literal>コマンドを使用することでわかります。
   </para>

   <para>
<!--
    The user ID the <productname>PostgreSQL</productname> server runs
    as must be able to traverse the path to the file you intend to
    load.  Making the file or a higher-level directory not readable
    and/or not executable by the <systemitem>postgres</systemitem>
    user is a common mistake.
-->
<productname>PostgreSQL</productname>サーバの実効ユーザIDはロード予定のファイルのパスまで到達できなければなりません。
よくある失敗として、<systemitem>postgres</systemitem>ユーザに対して読み込み、実行、または両方の権限がそのファイルとその上位ディレクトリに与えられていないことがあります。
   </para>

   <para>
<!--
    In any case, the file name that is given in the
    <command>CREATE FUNCTION</command> command is recorded literally
    in the system catalogs, so if the file needs to be loaded again
    the same procedure is applied.
-->
どの場合でも、<command>CREATE FUNCTION</command>コマンドに与えたファイル名はそのままシステムカタログに保存されます。
ですので、もしそのファイルを再度読み込む必要がある場合、同じ処理が適用されます。
   </para>

   <note>
    <para>
<!--
     <productname>PostgreSQL</productname> will not compile a C function
     automatically.  The object file must be compiled before it is referenced
     in a <command>CREATE
     FUNCTION</command> command.  See <xref linkend="dfunc"/> for additional
     information.
-->
<productname>PostgreSQL</productname>はC関数を自動的にコンパイルしません。
<command>CREATE FUNCTION</command>コマンドで参照する前に、そのオブジェクトファイルはコンパイルされていなければなりません。
さらなる情報については<xref linkend="dfunc"/>を参照してください。
    </para>
   </note>

   <indexterm zone="xfunc-c-dynload">
<!--
    <primary>magic block</primary>
-->
    <primary>マジックブロック</primary>
   </indexterm>

   <para>
<!--
    To ensure that a dynamically loaded object file is not loaded into an
    incompatible server, <productname>PostgreSQL</productname> checks that the
    file contains a <quote>magic block</quote> with the appropriate contents.
    This allows the server to detect obvious incompatibilities, such as code
    compiled for a different major version of
    <productname>PostgreSQL</productname>. To include a magic block,
    write this in one (and only one) of the module source files, after having
    included the header <filename>fmgr.h</filename>:
-->
確実に、動的にロードされるモジュールが互換性がないサーバにロードされないように、<productname>PostgreSQL</productname>は、そのファイルに適切な内容を持つ<quote>マジックブロック</quote>が含まれているかどうか検査します。
これによりサーバは、メジャーバージョンが異なる<productname>PostgreSQL</productname>用にコンパイルされたモジュールなど、明確に互換性がないことを検知することができます。
マジックブロックを含めるためには、以下をモジュールのソースファイルに一度（一度だけ）、<filename>fmgr.h</filename>ヘッダファイルをincludeさせた後で、記述してください。

<programlisting>
PG_MODULE_MAGIC;
</programlisting>
   </para>

   <para>
<!--
    After it is used for the first time, a dynamically loaded object
    file is retained in memory.  Future calls in the same session to
    the function(s) in that file will only incur the small overhead of
    a symbol table lookup.  If you need to force a reload of an object
    file, for example after recompiling it, begin a fresh session.
-->
最初に使用された後も、動的にロードされたオブジェクトファイルはメモリ内に保持されます。
同一セッションにおいてそのファイル内の関数をその後に呼び出した場合、シンボルテーブルの検索に要する小さなオーバーヘッドしかかかりません。
例えば再コンパイルした後など、そのオブジェクトファイルを強制的に再度読み込ませる必要がある場合は、新しいセッションを開始してください。
   </para>

   <indexterm zone="xfunc-c-dynload">
    <primary>_PG_init</primary>
   </indexterm>
   <indexterm zone="xfunc-c-dynload">
    <primary>_PG_fini</primary>
   </indexterm>
   <indexterm zone="xfunc-c-dynload">
<!--
    <primary>library initialization function</primary>
-->
    <primary>ライブラリ初期化処理関数</primary>
   </indexterm>
   <indexterm zone="xfunc-c-dynload">
<!--
    <primary>library finalization function</primary>
-->
    <primary>ライブラリ最終処理関数</primary>
   </indexterm>

   <para>
<!--
    Optionally, a dynamically loaded file can contain initialization and
    finalization functions.  If the file includes a function named
    <function>_PG_init</function>, that function will be called immediately after
    loading the file.  The function receives no parameters and should
    return void.  If the file includes a function named
    <function>_PG_fini</function>, that function will be called immediately before
    unloading the file.  Likewise, the function receives no parameters and
    should return void.  Note that <function>_PG_fini</function> will only be called
    during an unload of the file, not during process termination.
    (Presently, unloads are disabled and will never occur, but this may
    change in the future.)
-->
省略することもできますが、動的にロードされるファイルに初期化処理関数と最終処理関数を含めることができます。
<function>_PG_init</function>という関数がファイルに存在すると、この関数はファイルがロードされた直後に呼び出されます。
この関数は引数を取らずvoid型を返さなければなりません。
<function>_PG_fini</function>という関数がファイルに存在すると、この関数はファイルがアンロードされる直前に呼び出されます。
この関数も同様に引数を取らずvoid型を返さなければなりません。
<function>_PG_fini</function>がファイルのアンロード時にのみ呼び出されるものであり、処理の終了時に呼び出されるものではないことに注意してください。
（現在、アンロードは無効となっていますので、決して発生しません。将来変更される可能性があります。）
   </para>

  </sect2>

   <sect2 id="xfunc-c-basetype">
<!--
    <title>Base Types in C-Language Functions</title>
-->
<title>C言語関数における基本型</title>

    <indexterm zone="xfunc-c-basetype">
<!--
     <primary>data type</primary>
     <secondary>internal organization</secondary>
-->
     <primary>データ型</primary>
     <secondary>内部構成</secondary>
    </indexterm>

    <para>
<!--
     To know how to write C-language functions, you need to know how
     <productname>PostgreSQL</productname> internally represents base
     data types and how they can be passed to and from functions.
     Internally, <productname>PostgreSQL</productname> regards a base
     type as a <quote>blob of memory</quote>.  The user-defined
     functions that you define over a type in turn define the way that
     <productname>PostgreSQL</productname> can operate on it.  That
     is, <productname>PostgreSQL</productname> will only store and
     retrieve the data from disk and use your user-defined functions
     to input, process, and output the data.
-->
C言語関数の作成方法を理解するためには、<productname>PostgreSQL</productname>が基本データ型を内部でどのように表現し、どのようにそれらを関数とやり取りしているかを理解する必要があります。
内部的に<productname>PostgreSQL</productname>は基本型を<quote>メモリの小さな塊</quote>とみなします。
ある型を定義するユーザ定義関数は、言い換えると、<productname>PostgreSQL</productname>がそれを操作できる方法を定義します。
つまり、<productname>PostgreSQL</productname>はデータの格納、ディスクからの取り出しのみを行い、データの入力や処理、出力にはユーザ定義関数を使用します。
    </para>

    <para>
<!--
     Base types can have one of three internal formats:
-->
基本型は下記の3つのいずれかの内部書式を使用しています。

     <itemizedlist>
      <listitem>
       <para>
<!--
        pass by value, fixed-length
-->
固定長の値渡し
       </para>
      </listitem>
      <listitem>
       <para>
<!--
        pass by reference, fixed-length
-->
固定長の参照渡し
       </para>
      </listitem>
      <listitem>
       <para>
<!--
        pass by reference, variable-length
-->
可変長の参照渡し
       </para>
      </listitem>
     </itemizedlist>
    </para>

    <para>
<!--
     By-value  types  can  only be 1, 2, or 4 bytes in length
     (also 8 bytes, if <literal>sizeof(Datum)</literal> is 8 on your machine).
     You should be careful to define your types such that they will be the
     same size (in bytes) on all architectures.  For example, the
     <literal>long</literal> type is dangerous because it is 4 bytes on some
     machines and 8 bytes on others, whereas <type>int</type> type is 4 bytes
     on most Unix machines.  A reasonable implementation of the
     <type>int4</type> type on Unix machines might be:
-->
値渡しは、1、2、4バイト長の型のみで使用することができます（使用するマシンの<literal>sizeof(Datum)</literal>が8の場合は8バイトも使用できます）。
データ型を定義する際、その型がすべてのアーキテクチャにおいて同一の大きさ（バイト数）となるように定義するように注意してください。
例えば、<literal>long</literal>型はマシンによっては4バイトであったり、8バイトであったりして危険ですが、<type>int</type>型はほとんどのUnixマシンでは4バイトです。
Unixマシンにおける<type>int4</type>の理論的な実装は以下のようになります。

<programlisting>
<!--
/* 4-byte integer, passed by value */
-->
/* 4 バイト整数、値渡し */
typedef int int4;
</programlisting>

<!--
     (The actual PostgreSQL C code calls this type <type>int32</type>, because
     it is a convention in C that <type>int<replaceable>XX</replaceable></type>
     means <replaceable>XX</replaceable> <emphasis>bits</emphasis>.  Note
     therefore also that the C type <type>int8</type> is 1 byte in size.  The
     SQL type <type>int8</type> is called <type>int64</type> in C.  See also
     <xref linkend="xfunc-c-type-table"/>.)
-->
（実際のPostgreSQLのCコードではこの型を<type>int32</type>と呼びます。
<type>int<replaceable>XX</replaceable></type>が<replaceable>XX</replaceable> <emphasis>ビット</emphasis>であることはCにおける規約だからです。
したがって<type>int8</type>というCの型のサイズは１バイトであることに注意してください。
<type>int8</type>というSQLの型はCでは<type>int64</type>と呼ばれます。
<xref linkend="xfunc-c-type-table"/>も参照してください。）
    </para>

    <para>
<!--
     On  the  other hand, fixed-length types of any size can
     be passed by-reference.  For example, here is a  sample
     implementation of a <productname>PostgreSQL</productname> type:
-->
一方、任意の大きさの固定長の型は参照として引き渡すことができます。
例として以下に<productname>PostgreSQL</productname>の型の実装サンプルを示します。

<programlisting>
<!--
/* 16-byte structure, passed by reference */
-->
/* 16 バイト構造体、参照渡し */
typedef struct
{
    double  x, y;
} Point;
</programlisting>

<!--
     Only  pointers  to  such types can be used when passing
     them in and out of <productname>PostgreSQL</productname> functions.
     To return a value of such a type, allocate the right amount of
     memory with <literal>palloc</literal>, fill in the allocated memory,
     and return a pointer to it.  (Also, if you just want to return the
     same value as one of your input arguments that's of the same data type,
     you can skip the extra <literal>palloc</literal> and just return the
     pointer to the input value.)
-->
それらの型のポインタのみが<productname>PostgreSQL</productname>関数の入出力時に使用できます。
それらの型の値を返すためには、<literal>palloc()</literal>を使用して正しい大きさのメモリ領域を割り当て、そのメモリ領域に値を入力し、それのポインタを返します。
（また、入力引数の1つと同じ型かつ同じ値を返したいのであれば、<literal>palloc</literal>を行う手間を省くことができます。
この場合は入力値へのポインタを単に返してください。）
    </para>

    <para>
<!--
     Finally, all variable-length types must also be  passed
     by  reference.   All  variable-length  types must begin
     with an opaque length field of exactly 4 bytes, which will be set
     by <symbol>SET_VARSIZE</symbol>; never set this field directly! All data to
     be  stored within that type must be located in the memory
     immediately  following  that  length  field.   The
     length field contains the total length of the structure,
     that is,  it  includes  the  size  of  the  length  field
     itself.
-->
最後に、すべての可変長型は参照として引き渡す必要があります。
また、すべての可変長型は正確に4バイトの不透明なlengthフィールドから始まる必要があります。
このフィールドは<symbol>SET_VARSIZE</symbol>で設定されます。決して直接このフィールドを設定してはいけません。
その型に格納されるすべてのデータはlengthフィールドのすぐ後のメモリ領域に置かれる必要があります。
lengthフィールドにはその構造体の総長が格納されます。つまり、lengthフィールドそのものもその大きさに含まれます。
    </para>

    <para>
<!--
     Another important point is to avoid leaving any uninitialized bits
     within data type values; for example, take care to zero out any
     alignment padding bytes that might be present in structs.  Without
     this, logically-equivalent constants of your data type might be
     seen as unequal by the planner, leading to inefficient (though not
     incorrect) plans.
-->
この他の重要な点は、データ型の値の中で初期化されていないビットを残さないことです。
例えば、構造体内に存在する可能性がある整列用のパディングバイトを注意してすべてゼロクリアしてください。
こうしないと、独自データ型の論理的に等価な定数がプランナにより一致しないものと判断され、（不正確ではありませんが）非効率的な計画をもたらすかもしれません。
    </para>

    <warning>
     <para>
<!--
      <emphasis>Never</emphasis> modify the contents of a pass-by-reference input
      value.  If you do so you are likely to corrupt on-disk data, since
      the pointer you are given might point directly into a disk buffer.
      The sole exception to this rule is explained in
      <xref linkend="xaggr"/>.
-->
参照渡しの入力値の内容を<emphasis>決して</emphasis>変更しないでください。
指定したポインタがディスクバッファを直接指し示している可能性がよくありますので、変更すると、ディスク上のデータを破壊してしまうかもしれません。
この規則の唯一の例外について<xref linkend="xaggr"/>で説明します。
     </para>
    </warning>

    <para>
<!--
     As an example, we can define the type <type>text</type> as
     follows:
-->
例えば、<type>text</type>型を定義するには、下記のように行えます。

<programlisting>
typedef struct {
    int32 length;
    char data[FLEXIBLE_ARRAY_MEMBER];
} text;
</programlisting>

<!--
     The <literal>[FLEXIBLE_ARRAY_MEMBER]</literal> notation means that the actual
     length of the data part is not specified by this declaration.
-->
<literal>[FLEXIBLE_ARRAY_MEMBER]</literal>表記は、データ部分の実際の長さはこの宣言では指定されないことを意味します。
    </para>

    <para>
<!--
     When manipulating
     variable-length types, we must  be  careful  to  allocate
     the  correct amount  of memory and set the length field correctly.
     For example, if we wanted to  store  40  bytes  in  a <structname>text</structname>
     structure, we might use a code fragment like this:
-->
可変長型を操作する時、正確な大きさのメモリを割り当て、lengthフィールドを正確に設定することに注意する必要があります。
例えば、40バイトを<structname>text</structname>構造体に保持させたい場合、下記のようなコードを使用します。

<programlisting><![CDATA[
#include "postgres.h"
...
]]><!--
char buffer[40]; /* our source data */
--><![CDATA[
char buffer[40]; /* 私たちの元のデータ */
...
text *destination = (text *) palloc(VARHDRSZ + 40);
SET_VARSIZE(destination, VARHDRSZ + 40);
memcpy(destination->data, buffer, 40);
...
]]>
</programlisting>

<!--
     <literal>VARHDRSZ</literal> is the same as <literal>sizeof(int32)</literal>, but
     it's considered good style to use the macro <literal>VARHDRSZ</literal>
     to refer to the size of the overhead for a variable-length type.
     Also, the length field <emphasis>must</emphasis> be set using the
     <literal>SET_VARSIZE</literal> macro, not by simple assignment.
-->
<literal>VARHDRSZ</literal>は<literal>sizeof(int32)</literal>と同一ですが、可変長型のオーバーヘッド分の大きさを参照する時には、<literal>VARHDRSZ</literal>マクロを使用する方が好ましい形式とみなされています。
また長さフィールドを単なる代入ではなく<literal>SET_VARSIZE</literal>マクロを使用して設定<emphasis>しなければなりません</emphasis>。
    </para>

    <para>
<!--
     <xref linkend="xfunc-c-type-table"/> specifies which C type
     corresponds to which SQL type when writing a C-language function
     that uses a built-in type of <productname>PostgreSQL</productname>.
     The <quote>Defined In</quote> column gives the header file that
     needs to be included to get the type definition.  (The actual
     definition might be in a different file that is included by the
     listed file.  It is recommended that users stick to the defined
     interface.)  Note that you should always include
     <filename>postgres.h</filename> first in any source file, because
     it declares a number of things that you will need anyway.
-->
<xref linkend="xfunc-c-type-table"/>は、<productname>PostgreSQL</productname>の組み込み型を使用するC言語関数を作成する時の、Cの型とSQL型との対応を規定したものです。
<quote>定義場所</quote>列では、型定義を取り出すためにインクルードしなければならないヘッダファイルを示しています。
（実際の定義は一覧中のファイルからインクルードされた、別のファイルであるかもしれません。
ユーザは定義されたインタフェースを厳守することを推奨されています。）
<filename>postgres.h</filename>には必ず必要になる多くのものが宣言されていますので、ソースファイルの中で必ず初めにこのファイルをインクルードしなければならないことに注意してください。
    </para>

     <table tocentry="1" id="xfunc-c-type-table">
<!--
      <title>Equivalent C Types for Built-in SQL Types</title>
-->
      <title>組み込みSQL型に相当するCの型</title>
      <tgroup cols="3">
       <colspec colname="col1" colwidth="1*"/>
       <colspec colname="col2" colwidth="1*"/>
       <colspec colname="col3" colwidth="2*"/>
       <thead>
        <row>
         <entry>
<!--
          SQL Type
-->
SQL型
         </entry>
         <entry>
<!--
          C Type
-->
C 言語型
         </entry>
         <entry>
<!--
          Defined In
-->
定義場所
         </entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry><type>boolean</type></entry>
         <entry><type>bool</type></entry>
<!--
         <entry><filename>postgres.h</filename> (maybe compiler built-in)</entry>
-->
         <entry><filename>postgres.h</filename>（コンパイラで組み込み済みの可能性があります）</entry>
        </row>
        <row>
         <entry><type>box</type></entry>
         <entry><type>BOX*</type></entry>
         <entry><filename>utils/geo_decls.h</filename></entry>
        </row>
        <row>
         <entry><type>bytea</type></entry>
         <entry><type>bytea*</type></entry>
         <entry><filename>postgres.h</filename></entry>
        </row>
        <row>
         <entry><type>"char"</type></entry>
         <entry><type>char</type></entry>
<!--
         <entry>(compiler built-in)</entry>
-->
         <entry>（コンパイラで組み込み済み）</entry>
        </row>
        <row>
         <entry><type>character</type></entry>
         <entry><type>BpChar*</type></entry>
         <entry><filename>postgres.h</filename></entry>
        </row>
        <row>
         <entry><type>cid</type></entry>
         <entry><type>CommandId</type></entry>
         <entry><filename>postgres.h</filename></entry>
        </row>
        <row>
         <entry><type>date</type></entry>
         <entry><type>DateADT</type></entry>
         <entry><filename>utils/date.h</filename></entry>
        </row>
        <row>
         <entry><type>smallint</type> (<type>int2</type>)</entry>
         <entry><type>int16</type></entry>
         <entry><filename>postgres.h</filename></entry>
        </row>
        <row>
         <entry><type>int2vector</type></entry>
         <entry><type>int2vector*</type></entry>
         <entry><filename>postgres.h</filename></entry>
        </row>
        <row>
         <entry><type>integer</type> (<type>int4</type>)</entry>
         <entry><type>int32</type></entry>
         <entry><filename>postgres.h</filename></entry>
        </row>
        <row>
         <entry><type>real</type> (<type>float4</type>)</entry>
         <entry><type>float4*</type></entry>
        <entry><filename>postgres.h</filename></entry>
        </row>
        <row>
         <entry><type>double precision</type> (<type>float8</type>)</entry>
         <entry><type>float8*</type></entry>
         <entry><filename>postgres.h</filename></entry>
        </row>
        <row>
         <entry><type>interval</type></entry>
         <entry><type>Interval*</type></entry>
         <entry><filename>datatype/timestamp.h</filename></entry>
        </row>
        <row>
         <entry><type>lseg</type></entry>
         <entry><type>LSEG*</type></entry>
         <entry><filename>utils/geo_decls.h</filename></entry>
        </row>
        <row>
         <entry><type>name</type></entry>
         <entry><type>Name</type></entry>
         <entry><filename>postgres.h</filename></entry>
        </row>
        <row>
         <entry><type>oid</type></entry>
         <entry><type>Oid</type></entry>
         <entry><filename>postgres.h</filename></entry>
        </row>
        <row>
         <entry><type>oidvector</type></entry>
         <entry><type>oidvector*</type></entry>
         <entry><filename>postgres.h</filename></entry>
        </row>
        <row>
         <entry><type>path</type></entry>
         <entry><type>PATH*</type></entry>
         <entry><filename>utils/geo_decls.h</filename></entry>
        </row>
        <row>
         <entry><type>point</type></entry>
         <entry><type>POINT*</type></entry>
         <entry><filename>utils/geo_decls.h</filename></entry>
        </row>
        <row>
         <entry><type>regproc</type></entry>
         <entry><type>regproc</type></entry>
         <entry><filename>postgres.h</filename></entry>
        </row>
        <row>
         <entry><type>text</type></entry>
         <entry><type>text*</type></entry>
         <entry><filename>postgres.h</filename></entry>
        </row>
        <row>
         <entry><type>tid</type></entry>
         <entry><type>ItemPointer</type></entry>
         <entry><filename>storage/itemptr.h</filename></entry>
        </row>
        <row>
         <entry><type>time</type></entry>
         <entry><type>TimeADT</type></entry>
         <entry><filename>utils/date.h</filename></entry>
        </row>
        <row>
         <entry><type>time with time zone</type></entry>
         <entry><type>TimeTzADT</type></entry>
         <entry><filename>utils/date.h</filename></entry>
        </row>
        <row>
         <entry><type>timestamp</type></entry>
         <entry><type>Timestamp</type></entry>
         <entry><filename>datatype/timestamp.h</filename></entry>
        </row>
        <row>
         <entry><type>varchar</type></entry>
         <entry><type>VarChar*</type></entry>
         <entry><filename>postgres.h</filename></entry>
        </row>
        <row>
         <entry><type>xid</type></entry>
         <entry><type>TransactionId</type></entry>
         <entry><filename>postgres.h</filename></entry>
        </row>
       </tbody>
      </tgroup>
     </table>

    <para>
<!--
     Now that we've gone over all of the possible structures
     for base types, we can show some examples of real functions.
-->
ここまでで基本型に関してあり得る構造体のすべてを記述しましたので、実際の関数の例をいくつか示すことができます。
    </para>
   </sect2>

   <sect2>
<!--
    <title>Version 1 Calling Conventions</title>
-->
<title>Version 1 呼び出し規約</title>

    <para>
<!--
     The version-1 calling convention relies on macros to suppress most
     of the complexity of passing arguments and results.  The C declaration
     of a version-1 function is always:
-->
Version-1呼び出し規約では、引数と結果の引き渡しの複雑さをなくすためにマクロを使用しています。
Version-1関数のC言語宣言は必ず下記のように行います。
<programlisting>
Datum funcname(PG_FUNCTION_ARGS)
</programlisting>
<!--
     In addition, the macro call:
-->
     さらに、マクロ呼び出し
<programlisting>
PG_FUNCTION_INFO_V1(funcname);
</programlisting>
<!--
     must appear in the same source file.  (Conventionally, it's
     written just before the function itself.)  This macro call is not
     needed for <literal>internal</literal>-language functions, since
     <productname>PostgreSQL</productname> assumes that all internal functions
     use the version-1 convention.  It is, however, required for
     dynamically-loaded functions.
-->
が同じソースファイルに書かれている必要があります。
（一般には、関数の直前に書かれます。）
<productname>PostgreSQL</productname>ではすべての内部関数はVersion-1であると認識するので、このマクロの呼び出しは<literal>internal</literal>言語関数では必要ありません。
しかし、動的にロードされる関数では必要です。
    </para>

    <para>
<!--
     In a version-1 function, each actual argument is fetched using a
     <function>PG_GETARG_<replaceable>xxx</replaceable>()</function>
     macro that corresponds to the argument's data type.  (In non-strict
     functions there needs to be a previous check about argument null-ness
     using <function>PG_ARGISNULL()</function>; see below.)
     The result is returned using a
     <function>PG_RETURN_<replaceable>xxx</replaceable>()</function>
     macro for the return type.
     <function>PG_GETARG_<replaceable>xxx</replaceable>()</function>
     takes as its argument the number of the function argument to
     fetch, where the count starts at 0.
     <function>PG_RETURN_<replaceable>xxx</replaceable>()</function>
     takes as its argument the actual value to return.
-->
Version-1関数では、それぞれの実引数は、引数のデータ型に合った<function>PG_GETARG_<replaceable>xxx</replaceable>()</function>マクロを使用して取り出されます。
（厳格でない関数では、<function>PG_ARGISNULL()</function>を使って引数がNULLかどうか事前に確認することが必要です。下記参照。）
結果は戻り値の型に合った<function>PG_RETURN_<replaceable>xxx</replaceable>()</function>マクロを使用して返されます。
<function>PG_GETARG_<replaceable>xxx</replaceable>()</function>は、その引数として、取り出す関数引数の番号（ゼロから始まります）を取ります。
<function>PG_RETURN_<replaceable>xxx</replaceable>()</function>は、その引数として、実際に返す値を取ります。
    </para>

    <para>
<!--
     Here are some examples using the version-1 calling convention:
-->
Version-1呼出し規約を使った例をいくつか以下に示します。
    </para>

<programlisting><![CDATA[
#include "postgres.h"
#include <string.h>
#include "fmgr.h"
#include "utils/geo_decls.h"

PG_MODULE_MAGIC;

]]><!--
/* by value */
--><![CDATA[
/* 値渡し */

PG_FUNCTION_INFO_V1(add_one);

Datum
add_one(PG_FUNCTION_ARGS)
{
    int32   arg = PG_GETARG_INT32(0);

    PG_RETURN_INT32(arg + 1);
}

]]><!--
/* by reference, fixed length */
--><![CDATA[
/* 固定長の参照渡し */

PG_FUNCTION_INFO_V1(add_one_float8);

Datum
add_one_float8(PG_FUNCTION_ARGS)
{
]]><!--
    /* The macros for FLOAT8 hide its pass-by-reference nature. */
--><![CDATA[
    /* FLOAT8用のマクロは参照渡しという性質を隠します */
    float8   arg = PG_GETARG_FLOAT8(0);

    PG_RETURN_FLOAT8(arg + 1.0);
}

PG_FUNCTION_INFO_V1(makepoint);

Datum
makepoint(PG_FUNCTION_ARGS)
{
]]><!--
    /* Here, the pass-by-reference nature of Point is not hidden. */
--><![CDATA[
    /* ここのPoint型の参照渡しという性質は隠されていません */
    Point     *pointx = PG_GETARG_POINT_P(0);
    Point     *pointy = PG_GETARG_POINT_P(1);
    Point     *new_point = (Point *) palloc(sizeof(Point));

    new_point->x = pointx->x;
    new_point->y = pointy->y;

    PG_RETURN_POINT_P(new_point);
}

]]><!--
/* by reference, variable length */
--><![CDATA[
/* 可変長の参照渡し */

PG_FUNCTION_INFO_V1(copytext);

Datum
copytext(PG_FUNCTION_ARGS)
{
    text     *t = PG_GETARG_TEXT_PP(0);

    /*
]]><!--
     * VARSIZE_ANY_EXHDR is the size of the struct in bytes, minus the
     * VARHDRSZ or VARHDRSZ_SHORT of its header.  Construct the copy with a
     * full-length header.
--><![CDATA[
     * VARSIZEは、そのヘッダのVARHDRSZまたはVARHDRSZ_SHORTを引いた
     * 構造体の総長をバイト数で表したものです。
     * 完全な長さのヘッダと合わせたコピーを作成します。
     */
    text     *new_t = (text *) palloc(VARSIZE_ANY_EXHDR(t) + VARHDRSZ);
    SET_VARSIZE(new_t, VARSIZE_ANY_EXHDR(t) + VARHDRSZ);

    /*
]]><!--
     * VARDATA is a pointer to the data region of the new struct.  The source
     * could be a short datum, so retrieve its data through VARDATA_ANY.
--><![CDATA[
     * VARDATAは新しい構造体のデータ領域へのポインタです。
     * コピー元はshortデータかもしれませんので、VARDATA_ANYでデータを取り出します。
     */
]]><!--
    memcpy((void *) VARDATA(new_t), /* destination */
           (void *) VARDATA_ANY(t), /* source */
           VARSIZE_ANY_EXHDR(t));   /* how many bytes */
--><![CDATA[
    memcpy((void *) VARDATA(new_t), /* コピー先 */
           (void *) VARDATA_ANY(t), /* コピー元 */
           VARSIZE_ANY_EXHDR(t));   /* バイト数 */
    PG_RETURN_TEXT_P(new_t);
}

PG_FUNCTION_INFO_V1(concat_text);

Datum
concat_text(PG_FUNCTION_ARGS)
{
    text  *arg1 = PG_GETARG_TEXT_PP(0);
    text  *arg2 = PG_GETARG_TEXT_PP(1);
    int32 arg1_size = VARSIZE_ANY_EXHDR(arg1);
    int32 arg2_size = VARSIZE_ANY_EXHDR(arg2);
    int32 new_text_size = arg1_size + arg2_size + VARHDRSZ;
    text *new_text = (text *) palloc(new_text_size);

    SET_VARSIZE(new_text, new_text_size);
    memcpy(VARDATA(new_text), VARDATA_ANY(arg1), arg1_size);
    memcpy(VARDATA(new_text) + arg1_size, VARDATA_ANY(arg2), arg2_size);
    PG_RETURN_TEXT_P(new_text);
}
]]>
</programlisting>

    <para>
<!--
     Supposing that the above code has been prepared in file
     <filename>funcs.c</filename> and compiled into a shared object,
     we could define the functions to <productname>PostgreSQL</productname>
     with commands like this:
-->
上のコードがファイル<filename>funcs.c</filename>に用意されていて、共有オブジェクトにコンパイルされているとしたら、以下のように<productname>PostgreSQL</productname>にコマンドで関数を定義できます。
    </para>

<programlisting>
CREATE FUNCTION add_one(integer) RETURNS integer
     AS '<replaceable>DIRECTORY</replaceable>/funcs', 'add_one'
     LANGUAGE C STRICT;

<!--
&#045;- note overloading of SQL function name "add_one"
-->
-- SQL関数名"add_one"のオーバーロードに注意
CREATE FUNCTION add_one(double precision) RETURNS double precision
     AS '<replaceable>DIRECTORY</replaceable>/funcs', 'add_one_float8'
     LANGUAGE C STRICT;

CREATE FUNCTION makepoint(point, point) RETURNS point
     AS '<replaceable>DIRECTORY</replaceable>/funcs', 'makepoint'
     LANGUAGE C STRICT;

CREATE FUNCTION copytext(text) RETURNS text
     AS '<replaceable>DIRECTORY</replaceable>/funcs', 'copytext'
     LANGUAGE C STRICT;

CREATE FUNCTION concat_text(text, text) RETURNS text
     AS '<replaceable>DIRECTORY</replaceable>/funcs', 'concat_text'
     LANGUAGE C STRICT;
</programlisting>

    <para>
<!--
     Here, <replaceable>DIRECTORY</replaceable> stands for the
     directory of the shared library file (for instance the
     <productname>PostgreSQL</productname> tutorial directory, which
     contains the code for the examples used in this section).
     (Better style would be to use just <literal>'funcs'</literal> in the
     <literal>AS</literal> clause, after having added
     <replaceable>DIRECTORY</replaceable> to the search path.  In any
     case, we can omit the system-specific extension for a shared
     library, commonly <literal>.so</literal>.)
-->
ここでは、<replaceable>DIRECTORY</replaceable>は共有ライブラリファイルのディレクトリ(例えば<productname>PostgreSQL</productname>のチュートリアルのディレクトリ、そこにはこの節で使われている例のコードがあります)を表しています。
(<replaceable>DIRECTORY</replaceable>を検索パスに追加した後に<literal>AS</literal>句で<literal>'funcs'</literal>だけを使うのがより良いやり方でしょう。
どの場合でも、共有ライブラリを表すシステムに特有の拡張子、普通は<literal>.so</literal>を省略できます。)
    </para>

    <para>
<!--
     Notice that we have specified the functions as <quote>strict</quote>,
     meaning that
     the system should automatically assume a null result if any input
     value is null.  By doing this, we avoid having to check for null inputs
     in the function code.  Without this, we'd have to check for null values
     explicitly, using <function>PG_ARGISNULL()</function>.
-->
関数を<quote>strict</quote>と指定したことに注意してください。これは入力値のいずれかがNULLだった場合、システムが自動的に結果をNULLと決めてしまうことを意味します。
こうすることで、関数のコード内でNULLの入力を確認しなければならないことを避けています。
これがなければ、<function>PG_ARGISNULL()</function>を使ってNULL値を明示的に確認しなければなりません。
    </para>

    <para>
<!--
     The macro <function>PG_ARGISNULL(<replaceable>n</replaceable>)</function>
     allows a function to test whether each input is null.  (Of course, doing
     this is only necessary in functions not declared <quote>strict</quote>.)
     As with the
     <function>PG_GETARG_<replaceable>xxx</replaceable>()</function> macros,
     the input arguments are counted beginning at zero.  Note that one
     should refrain from executing
     <function>PG_GETARG_<replaceable>xxx</replaceable>()</function> until
     one has verified that the argument isn't null.
     To return a null result, execute <function>PG_RETURN_NULL()</function>;
     this works in both strict and nonstrict functions.
-->
<function>PG_ARGISNULL(<replaceable>n</replaceable>)</function>マクロにより関数は各入力がNULLであるかどうかの検査を行うことができます。
（もちろんこれは、<quote>厳密</quote>と宣言されていない関数でのみ必要です。）
<function>PG_GETARG_<replaceable>xxx</replaceable>()</function>マクロと同様、入力引数の番号はゼロから始まります。
引数がNULLでないことを確認するまでは、<function>PG_GETARG_<replaceable>xxx</replaceable>()</function>の実行は控えなければなりません。
結果としてNULLを返す場合は、<function>PG_RETURN_NULL()</function>を実行します。
これは、厳密な関数と厳密でない関数の両方で使用可能です。
    </para>

    <para>
<!--
     At first glance, the version-1 coding conventions might appear
     to be just pointless obscurantism, compared to using
     plain <literal>C</literal> calling conventions.  They do however allow
     us to deal with <literal>NULL</literal>able arguments/return values,
     and <quote>toasted</quote> (compressed or out-of-line) values.
-->
一見、Version-1のコーディング規約は、普通の<literal>C</literal>の呼出し規約と比較すると、無意味なあいまいなものの様に見えるかもしれません。
しかし、<literal>NULL</literal>になりうる引数や戻り値、<quote>TOASTされた</quote>（圧縮または行外）値を扱うことができます。
    </para>

    <para>
<!--
     Other options provided by the version-1 interface are two
     variants of the
     <function>PG_GETARG_<replaceable>xxx</replaceable>()</function>
     macros. The first of these,
     <function>PG_GETARG_<replaceable>xxx</replaceable>_COPY()</function>,
     guarantees to return a copy of the specified argument that is
     safe for writing into. (The normal macros will sometimes return a
     pointer to a value that is physically stored in a table, which
     must not be written to. Using the
     <function>PG_GETARG_<replaceable>xxx</replaceable>_COPY()</function>
     macros guarantees a writable result.)
    The second variant consists of the
    <function>PG_GETARG_<replaceable>xxx</replaceable>_SLICE()</function>
    macros which take three arguments. The first is the number of the
    function argument (as above). The second and third are the offset and
    length of the segment to be returned. Offsets are counted from
    zero, and a negative length requests that the remainder of the
    value be returned. These macros provide more efficient access to
    parts of large values in the case where they have storage type
    <quote>external</quote>. (The storage type of a column can be specified using
    <literal>ALTER TABLE <replaceable>tablename</replaceable> ALTER
    COLUMN <replaceable>colname</replaceable> SET STORAGE
    <replaceable>storagetype</replaceable></literal>. <replaceable>storagetype</replaceable> is one of
    <literal>plain</literal>, <literal>external</literal>, <literal>extended</literal>,
     or <literal>main</literal>.)
-->
Version 1のインタフェースでは、その他のオプションとして<function>PG_GETARG_<replaceable>xxx</replaceable>()</function>マクロの変形を2つ提供しています。
1つ目の<function>PG_GETARG_<replaceable>xxx</replaceable>_COPY()</function>によって、安全に書き込むことができる指定引数のコピーが確実に返されます。
（通常のマクロは、物理的にテーブルに格納されている値へのポインタを返すことがあるので、書き込んではなりません。
<function>PG_GETARG_<replaceable>xxx</replaceable>_COPY()</function>マクロの結果は書き込み可能であることが保証されています。）
2つ目の変形は、引数を3つ取る<function>PG_GETARG_<replaceable>xxx</replaceable>_SLICE()</function>マクロからなります。
1つ目は関数の引数の番号（上記の通り）です。
2つ目と3つ目は、オフセットと返されるセグメントの長さです。
オフセットはゼロから始まり、負の長さは残りの値を返すことを要求します。
これらのマクロを使用すると、ストレージ種類が<quote>external</quote>（外部）である大きな値の一部へアクセスする際に非常に効果的です。
（列のストレージ種類は<literal>ALTER TABLE <replaceable>tablename</replaceable> ALTER COLUMN <replaceable>colname</replaceable> SET STORAGE <replaceable>storagetype</replaceable></literal>を使用して指定できます。
<replaceable>storagetype</replaceable>は、<literal>plain</literal>、<literal>external</literal>、<literal>extended</literal>、または<literal>main</literal>のいずれかです。）
    </para>

    <para>
<!--
     Finally, the version-1 function call conventions make it possible
     to return set results (<xref linkend="xfunc-c-return-set"/>) and
     implement trigger functions (<xref linkend="triggers"/>) and
     procedural-language call handlers (<xref
     linkend="plhandler"/>).  For more details
     see <filename>src/backend/utils/fmgr/README</filename> in the
     source distribution.
-->
最後に、Version-1関数呼び出し規約では、結果集合（<xref linkend="xfunc-c-return-set"/>）を返すこと、およびトリガ関数（<xref linkend="triggers"/>）と手続型言語の呼び出しハンドラ（<xref linkend="plhandler"/>）を実装することができます。
詳細についてはソース配布物内の<filename>src/backend/utils/fmgr/README</filename>を参照してください。
    </para>
   </sect2>

   <sect2>
<!--
    <title>Writing Code</title>
-->
    <title>コードの作成</title>

    <para>
<!--
     Before we turn to the more advanced topics, we should discuss
     some coding rules for <productname>PostgreSQL</productname>
     C-language functions.  While it might be possible to load functions
     written in languages other than C into
     <productname>PostgreSQL</productname>, this is usually difficult
     (when it is possible at all) because other languages, such as
     C++, FORTRAN, or Pascal often do not follow the same calling
     convention as C.  That is, other languages do not pass argument
     and return values between functions in the same way.  For this
     reason, we will assume that your C-language functions are
     actually written in C.
-->
より先進的な話題に入る前に、<productname>PostgreSQL</productname> C言語関数のコーディングについての規則をいくつか説明します。
C言語以外の言語で記述した関数を<productname>PostgreSQL</productname>に組み込みむことは可能であるかもしれませんが、例えばC++、FORTRANやPascalといった言語はC言語と同じ呼び出し規約に従いませんので、多くの場合、（可能であったとしても）困難です。
それはつまり、他の言語では同じ方法で関数に引数を渡したり、関数から結果を返すことを行わないということです。
このため、C言語関数は実際にC言語で書かれているものと仮定します。
    </para>

    <para>
<!--
     The basic rules for writing and building C functions are as follows:
-->
C関数の作成と構築の基本規則を以下に示します。

     <itemizedlist>
      <listitem>
       <para>
<!--
        Use <literal>pg_config
        &#045;&#045;includedir-server</literal><indexterm><primary>pg_config</primary><secondary>with user-defined C functions</secondary></indexterm>
        to find out where the <productname>PostgreSQL</productname> server header
        files are installed on your system (or the system that your
        users will be running on).
-->
<literal>pg_config --includedir-server</literal>を使用して、使用中のシステム（もしくはユーザが実行するシステム）にて<productname>PostgreSQL</productname>サーバのヘッダファイルがインストールされた場所を見つけます。
<indexterm><primary>pg_config</primary><secondary>ユーザ定義C関数</secondary></indexterm>
       </para>
      </listitem>

      <listitem>
       <para>
<!--
        Compiling and linking your code so that it can be dynamically
        loaded into <productname>PostgreSQL</productname> always
        requires special flags.  See <xref linkend="dfunc"/> for a
        detailed explanation of how to do it for your particular
        operating system.
-->
<productname>PostgreSQL</productname>に動的にロードできるように独自コードをコンパイル/リンクする時には常に、特別なフラグが必要となります。
特定のオペレーティングシステムにおけるコンパイル/リンク方法については<xref linkend="dfunc"/>を参照してください。
       </para>
      </listitem>

      <listitem>
       <para>
<!--
        Remember to define a <quote>magic block</quote> for your shared library,
        as described in <xref linkend="xfunc-c-dynload"/>.
-->
忘れずに<xref linkend="xfunc-c-dynload"/>で説明した<quote>マジックブロック</quote>を共有ライブラリで定義してください。
       </para>
      </listitem>

      <listitem>
       <para>
<!--
        When allocating memory, use the
        <productname>PostgreSQL</productname> functions
        <function>palloc</function><indexterm><primary>palloc</primary></indexterm> and <function>pfree</function><indexterm><primary>pfree</primary></indexterm>
        instead of the corresponding C library functions
        <function>malloc</function> and <function>free</function>.
        The memory allocated by <function>palloc</function> will be
        freed automatically at the end of each transaction, preventing
        memory leaks.
-->
メモリを割り当てる際、Cライブラリの<function>malloc</function>と<function>free</function>ではなく、<productname>PostgreSQL</productname>の<function>palloc</function>と<function>pfree</function>を使用してください。
<indexterm><primary>palloc</primary></indexterm><indexterm><primary>pfree</primary></indexterm>
<function>palloc</function>で割り当てられたメモリは各トランザクションの終わりに自動的に解放され、メモリリークを防ぎます。
       </para>
      </listitem>

      <listitem>
       <para>
<!--
        Always zero the bytes of your structures using <function>memset</function>
        (or allocate them with <function>palloc0</function> in the first place).
        Even if you assign to each field of your structure, there might be
        alignment padding (holes in the structure) that contain
        garbage values.  Without this, it's difficult to
        support hash indexes or hash joins, as you must pick out only
        the significant bits of your data structure to compute a hash.
        The planner also sometimes relies on comparing constants via
        bitwise equality, so you can get undesirable planning results if
        logically-equivalent values aren't bitwise equal.
-->
<function>memset</function>を使用して、構造体を必ずゼロクリアしてください（または最初の段階で<function>palloc0</function>を用いて割り当ててください）。
構造体の各フィールドを割り当てたとしても、ゴミの値を持つ整列用のパディング（構造体内の穴）があるかもしれません。
こうしないと、ハッシュインデックスやハッシュ結合をサポートすることが困難です。
ハッシュを計算するには、データ構造体内の有意なビットのみを取り出す必要があるためです。
プランナはまた時折ビット単位の等価性を用いて定数の比較を行います。
このため論理的にな値がビット単位で等価でない場合に望まない計画になってしまう可能性があります。
       </para>
      </listitem>

      <listitem>
       <para>
<!--
        Most of the internal <productname>PostgreSQL</productname>
        types are declared in <filename>postgres.h</filename>, while
        the function manager interfaces
        (<symbol>PG_FUNCTION_ARGS</symbol>, etc.)  are in
        <filename>fmgr.h</filename>, so you will need to include at
        least these two files.  For portability reasons it's best to
        include <filename>postgres.h</filename> <emphasis>first</emphasis>,
        before any other system or user header files.  Including
        <filename>postgres.h</filename> will also include
        <filename>elog.h</filename> and <filename>palloc.h</filename>
        for you.
-->
ほとんどの<productname>PostgreSQL</productname>の内部型は<filename>postgres.h</filename>に宣言されています。
一方、関数管理インタフェース（<symbol>PG_FUNCTION_ARGS</symbol>など）は<filename>fmgr.h</filename>で宣言されています。
したがって、少なくともこの2つのファイルをインクルードする必要があります。
移植性に関する理由により、<filename>postgres.h</filename>をその他のシステムヘッダファイル、ユーザヘッダファイルよりも<emphasis>先に</emphasis>インクルードしておくことが最善です。
<filename>postgres.h</filename>をインクルードすることは<filename>elog.h</filename>、<filename>palloc.h</filename>もインクルードすることになります。
       </para>
      </listitem>

      <listitem>
       <para>
<!--
        Symbol names defined within object files must not conflict
        with each other or with symbols defined in the
        <productname>PostgreSQL</productname> server executable.  You
        will have to rename your functions or variables if you get
        error messages to this effect.
-->
オブジェクトファイルで定義されているシンボル名は、互いに、または<productname>PostgreSQL</productname>サーバの実行ファイルで定義されているものと異なっている必要があります。
これに関するエラーが表示される場合は、関数名または変数名を変更する必要があります。
       </para>
      </listitem>
     </itemizedlist>
    </para>
   </sect2>

&dfunc;

   <sect2>
<!--
    <title>Composite-Type Arguments</title>
-->
<title>複合型引数</title>

    <para>
<!--
     Composite types do not have a fixed layout like C structures.
     Instances of a composite type can contain null fields.  In
     addition, composite types that are part of an inheritance
     hierarchy can have different fields than other members of the
     same inheritance hierarchy.  Therefore,
     <productname>PostgreSQL</productname> provides a function
     interface for accessing fields of composite types from C.
-->
複合型ではCの構造体のような固定のレイアウトがありません。
複合型のインスタンスはNULLフィールドを持つことができます。
さらに、複合型で継承階層の一部であるものは、同じ継承階層の他のメンバとは異なるフィールドを持つこともできます。
そのため、<productname>PostgreSQL</productname>はC言語から複合型のフィールドにアクセスするための関数インタフェースを提供します。
    </para>

    <para>
<!--
     Suppose we want to write a function to answer the query:
-->
以下のような問い合わせに答える関数を書こうとしていると仮定します。

<programlisting>
SELECT name, c_overpaid(emp, 1500) AS overpaid
    FROM emp
    WHERE name = 'Bill' OR name = 'Sam';
</programlisting>

<!--
     Using the version-1 calling conventions, we can define
     <function>c_overpaid</function> as:
-->
Version 1呼び出し規約を使用すると、<function>c_overpaid</function>は以下のように定義できます。

<programlisting><![CDATA[
#include "postgres.h"
]]><!--
#include "executor/executor.h"  /* for GetAttributeByName() */
--><![CDATA[
#include "executor/executor.h"  /* GetAttributeByName()用 */

PG_MODULE_MAGIC;

PG_FUNCTION_INFO_V1(c_overpaid);

Datum
c_overpaid(PG_FUNCTION_ARGS)
{
    HeapTupleHeader  t = PG_GETARG_HEAPTUPLEHEADER(0);
    int32            limit = PG_GETARG_INT32(1);
    bool isnull;
    Datum salary;

    salary = GetAttributeByName(t, "salary", &isnull);
    if (isnull)
        PG_RETURN_BOOL(false);
]]><!--
    /* Alternatively, we might prefer to do PG_RETURN_NULL() for null salary. */
--><![CDATA[
    /* この他、salaryがNULLの場合用にPG_RETURN_NULL()を行った方が良いでしょう */

    PG_RETURN_BOOL(DatumGetInt32(salary) > limit);
}
]]>
</programlisting>
    </para>

    <para>
<!--
     <function>GetAttributeByName</function> is the
     <productname>PostgreSQL</productname> system function that
     returns attributes out of the specified row.  It has
     three arguments: the argument of type <type>HeapTupleHeader</type> passed
     into
     the  function, the name of the desired attribute, and a
     return parameter that tells whether  the  attribute
     is  null.   <function>GetAttributeByName</function> returns a <type>Datum</type>
     value that you can convert to the proper data type by using the
     appropriate <function>DatumGet<replaceable>XXX</replaceable>()</function>
     macro.  Note that the return value is meaningless if the null flag is
     set; always check the null flag before trying to do anything with the
     result.
-->
<function>GetAttributeByName</function>は、指定された行から属性を返す、<productname>PostgreSQL</productname>システム関数です。
これには3つの引数があります。
それらは、関数に渡された<type>HeapTupleHeader</type>型の引数、求められた属性の名前、属性がNULLであるかどうかを通知する返りパラメータです。
<function>GetAttributeByName</function>は適切な<function>DatumGet<replaceable>XXX</replaceable>()</function>マクロを使用して適切なデータ型に変換可能な<type>Datum</type>型の値を返します。
このNULLフラグが設定されている場合、戻り値の意味がないことに注意し、この結果で何かを行おうとする前に常に、NULLフラグを検査してください。
    </para>

    <para>
<!--
     There is also <function>GetAttributeByNum</function>, which selects
     the target attribute by column number instead of name.
-->
対象列を名前ではなく列番号で選択する<function>GetAttributeByNum</function>もあります。
    </para>

    <para>
<!--
     The following command declares the function
     <function>c_overpaid</function> in SQL:
-->
下記のコマンドで<function>c_overpaid</function>関数をSQLで宣言します。

<programlisting>
CREATE FUNCTION c_overpaid(emp, integer) RETURNS boolean
    AS '<replaceable>DIRECTORY</replaceable>/funcs', 'c_overpaid'
    LANGUAGE C STRICT;
</programlisting>

<!--
     Notice we have used <literal>STRICT</literal> so that we did not have to
     check whether the input arguments were NULL.
-->
入力引数がNULLかどうかを検査する必要がないように<literal>STRICT</literal>を使用していることに注意してください。
    </para>
   </sect2>

   <sect2>
<!--
    <title>Returning Rows (Composite Types)</title>
-->
    <title>行（複合型）を返す</title>

    <para>
<!--
     To return a row or composite-type value from a C-language
     function, you can use a special API that provides macros and
     functions to hide most of the complexity of building composite
     data types.  To use this API, the source file must include:
-->
C言語関数から行もしくは複合型の値を返すために、複合型の複雑な作成のほとんどを隠蔽するマクロや関数を提供する、特別なAPIを使用することができます。
このAPIを使用するためには、ソースファイルで以下をインクルードする必要があります。
<programlisting>
#include "funcapi.h"
</programlisting>
    </para>

    <para>
<!--
     There are two ways you can build a composite data value (henceforth
     a <quote>tuple</quote>): you can build it from an array of Datum values,
     or from an array of C strings that can be passed to the input
     conversion functions of the tuple's column data types.  In either
     case, you first need to obtain or construct a <structname>TupleDesc</structname>
     descriptor for the tuple structure.  When working with Datums, you
     pass the <structname>TupleDesc</structname> to <function>BlessTupleDesc</function>,
     and then call <function>heap_form_tuple</function> for each row.  When working
     with C strings, you pass the <structname>TupleDesc</structname> to
     <function>TupleDescGetAttInMetadata</function>, and then call
     <function>BuildTupleFromCStrings</function> for each row.  In the case of a
     function returning a set of tuples, the setup steps can all be done
     once during the first call of the function.
-->
複合型のデータ値（以降<quote>タプル</quote>と記す）を作成する2つの方法があります。
Datum値の配列から作成する方法、もしくはタプルのある列の型の入力変換関数に渡すことができるC文字列の配列から作成することです。
どちらの方法でも、まずタプル構造体用の<structname>TupleDesc</structname>記述子を入手、あるいは作成しなければなりません。
Datumを使用する場合は、<structname>TupleDesc</structname>を<function>BlessTupleDesc</function>に渡し、各行に対して<function>heap_form_tuple</function>を呼び出します。
C文字列を使用する場合は、<structname>TupleDesc</structname> を<function>TupleDescGetAttInMetadata</function>に渡し、各行に対して <function>BuildTupleFromCStrings</function>を呼び出します。
タプルの集合を返す関数の場合、この設定段階を最初の関数呼び出しで一度にまとめて行うことができます。
    </para>

    <para>
<!--
     Several helper functions are available for setting up the needed
     <structname>TupleDesc</structname>.  The recommended way to do this in most
     functions returning composite values is to call:
-->
必要な<structname>TupleDesc</structname>の設定用の補助用関数がいくつかあります。
ほとんどの複合型を返す関数での推奨方法は、以下の関数を呼び出し、呼び出し元の関数自身に渡される<literal>fcinfo</literal>構造体と同じものを渡すことです。
<programlisting>
TypeFuncClass get_call_result_type(FunctionCallInfo fcinfo,
                                   Oid *resultTypeId,
                                   TupleDesc *resultTupleDesc)
</programlisting>
<!--
     passing the same <literal>fcinfo</literal> struct passed to the calling function
     itself.  (This of course requires that you use the version-1
     calling conventions.)  <varname>resultTypeId</varname> can be specified
     as <literal>NULL</literal> or as the address of a local variable to receive the
     function's result type OID.  <varname>resultTupleDesc</varname> should be the
     address of a local <structname>TupleDesc</structname> variable.  Check that the
     result is <literal>TYPEFUNC_COMPOSITE</literal>; if so,
     <varname>resultTupleDesc</varname> has been filled with the needed
     <structname>TupleDesc</structname>.  (If it is not, you can report an error along
     the lines of <quote>function returning record called in context that
     cannot accept type record</quote>.)
-->
（これにはもちろん、version 1呼び出し規約を使用していることが必要です。）
<varname>resultTypeId</varname>を<literal>NULL</literal>とすることも、ローカル変数のアドレスを指定して関数の戻り値型のOIDを受け取ることができます。
<varname>resultTupleDesc</varname>はローカルな<structname>TupleDesc</structname>変数のアドレスでなければなりません。
結果が<literal>TYPEFUNC_COMPOSITE</literal>かどうかを確認してください。
<literal>TYPEFUNC_COMPOSITE</literal>であった場合、<varname>resultTupleDesc</varname>には必要な<structname>TupleDesc</structname>が格納されています。
（<literal>TYPEFUNC_COMPOSITE</literal>ではなかった場合、<quote>レコード型を受け付けない文脈でレコードを返す関数が呼び出されました</quote>というエラーを報告することができます。）
    </para>

    <tip>
     <para>
<!--
      <function>get_call_result_type</function> can resolve the actual type of a
      polymorphic function result; so it is useful in functions that return
      scalar polymorphic results, not only functions that return composites.
      The <varname>resultTypeId</varname> output is primarily useful for functions
      returning polymorphic scalars.
-->
<function>get_call_result_type</function>は、多様性関数の結果の実際の型を解決することができます。
ですので、複合型を返す関数だけではなく、スカラの多様結果を返す関数でも有意です。
<varname>resultTypeId</varname>出力は主にスカラの多様結果を返す関数で有意です。
     </para>
    </tip>

    <note>
     <para>
<!--
      <function>get_call_result_type</function> has a sibling
      <function>get_expr_result_type</function>, which can be used to resolve the
      expected output type for a function call represented by an expression
      tree.  This can be used when trying to determine the result type from
      outside the function itself.  There is also
      <function>get_func_result_type</function>, which can be used when only the
      function's OID is available.  However these functions are not able
      to deal with functions declared to return <structname>record</structname>, and
      <function>get_func_result_type</function> cannot resolve polymorphic types,
      so you should preferentially use <function>get_call_result_type</function>.
-->
<function>get_call_result_type</function>は、<function>get_expr_result_type</function>と似たような関数で、関数呼び出しで想定される出力型を式のツリー構造として解決します。
関数自身以外から結果型を決定したい場合に、これを使用することができます。
また、<function>get_func_result_type</function>という関数もあります。
これは関数のOIDが利用できる場合にのみ使用することができます。
しかし、これらの関数は、<structname>record</structname>型を返すものと宣言された関数では使用できません。
また、<function>get_func_result_type</function>は多様型を解決することができません。
したがって、優先して<function>get_call_result_type</function>を使用すべきです。
     </para>
    </note>

    <para>
<!--
     Older, now-deprecated functions for obtaining
     <structname>TupleDesc</structname>s are:
-->
古く、廃止予定の<structname>TupleDesc</structname>を入手するための関数を以下に示します。
<programlisting>
TupleDesc RelationNameGetTupleDesc(const char *relname)
</programlisting>
<!--
     to get a <structname>TupleDesc</structname> for the row type of a named relation,
     and:
-->
これを指名したリレーションの行型用の<structname>TupleDesc</structname>を取り出すために使用してください。
また、
<programlisting>
TupleDesc TypeGetTupleDesc(Oid typeoid, List *colaliases)
</programlisting>
<!--
     to get a <structname>TupleDesc</structname> based on a type OID. This can
     be used to get a <structname>TupleDesc</structname> for a base or
     composite type.  It will not work for a function that returns
     <structname>record</structname>, however, and it cannot resolve polymorphic
     types.
-->
これを型のOIDに基づいて<structname>TupleDesc</structname>を取り出すために使用してください。
これは、基本型もしくは複合型の<structname>TupleDesc</structname>を取り出すために使用可能です。
これは<structname>record</structname>を返す関数ではうまく動作しません。
また、多様型を解決することもできません。
    </para>

    <para>
<!--
     Once you have a <structname>TupleDesc</structname>, call:
-->
<structname>TupleDesc</structname>を獲得した後に、Datumを使用する場合は以下を呼び出してください。
<programlisting>
TupleDesc BlessTupleDesc(TupleDesc tupdesc)
</programlisting>
<!--
     if you plan to work with Datums, or:
-->
C文字列を使用する場合は以下を呼び出してください。
<programlisting>
AttInMetadata *TupleDescGetAttInMetadata(TupleDesc tupdesc)
</programlisting>
<!--
     if you plan to work with C strings.  If you are writing a function
     returning set, you can save the results of these functions in the
     <structname>FuncCallContext</structname> structure &mdash; use the
     <structfield>tuple_desc</structfield> or <structfield>attinmeta</structfield> field
     respectively.
-->
集合を返す関数を作成する場合は、これらの関数の結果を<structname>FuncCallContext</structname>構造体に格納してください。
それぞれ<structfield>tuple_desc</structfield>と<structfield>attinmeta</structfield>を使用します。
    </para>

    <para>
<!--
     When working with Datums, use:
-->
Datumを使用する場合は、ユーザデータをDatum形式に格納した<structname>HeapTuple</structname>を構築するために以下を使用します。
<programlisting>
HeapTuple heap_form_tuple(TupleDesc tupdesc, Datum *values, bool *isnull)
</programlisting>
<!--
     to build a <structname>HeapTuple</structname> given user data in Datum form.
-->
    </para>

    <para>
<!--
     When working with C strings, use:
-->
C文字列を使用する場合は、ユーザデータをC文字列形式に格納した<structname>HeapTuple</structname>を構築するために以下を使用します。
<programlisting>
HeapTuple BuildTupleFromCStrings(AttInMetadata *attinmeta, char **values)
</programlisting>
<!--
     to build a <structname>HeapTuple</structname> given user data
     in C string form.  <parameter>values</parameter> is an array of C strings,
     one for each attribute of the return row. Each C string should be in
     the form expected by the input function of the attribute data
     type. In order to return a null value for one of the attributes,
     the corresponding pointer in the <parameter>values</parameter> array
     should be set to <symbol>NULL</symbol>.  This function will need to
     be called again for each row you return.
-->
<literal>values</literal>は行の各属性を1要素としたC文字列の配列です。
各C文字列は、属性のデータ型用の入力関数が受け付け可能な形式でなければなりません。
属性の値をNULL値として返すためには、<parameter>values</parameter>配列の対応するポインタに<symbol>NULL</symbol>を設定してください。
この関数は返す行それぞれに対して繰り返し呼び出す必要があります。
    </para>

    <para>
<!--
     Once you have built a tuple to return from your function, it
     must be converted into a <type>Datum</type>. Use:
-->
関数から返すタプルを構築し終わったら、それを<type>Datum</type>に変換しなければなりません。
以下を使用して、<structname>HeapTuple</structname>を有効なDatumに変換してください。
<programlisting>
HeapTupleGetDatum(HeapTuple tuple)
</programlisting>
<!--
     to convert a <structname>HeapTuple</structname> into a valid Datum.  This
     <type>Datum</type> can be returned directly if you intend to return
     just a single row, or it can be used as the current return value
     in a set-returning function.
-->
単一行のみを返すのであれば、この<type>Datum</type>を直接返すことができます。
さもなくば、集合を返す関数における現在の戻り値として使用することができます。
    </para>

    <para>
<!--
     An example appears in the next section.
-->
次節に例を示します。
    </para>

   </sect2>

   <sect2 id="xfunc-c-return-set">
<!--
    <title>Returning Sets</title>
-->
    <title>集合を返す</title>

    <para>
<!--
     C-language functions have two options for returning sets (multiple
     rows).  In one method, called <firstterm>ValuePerCall</firstterm>
     mode, a set-returning function is called repeatedly (passing the same
     arguments each time) and it returns one new row on each call, until
     it has no more rows to return and signals that by returning NULL.
     The set-returning function (<acronym>SRF</acronym>) must therefore
     save enough state across calls to remember what it was doing and
     return the correct next item on each call.
     In the other method, called <firstterm>Materialize</firstterm> mode,
     a SRF fills and returns a tuplestore object containing its
     entire result; then only one call occurs for the whole result, and
     no inter-call state is needed.
-->
C言語関数から集合（複数行）を返すには2つ選択肢があります。
一つは、<firstterm>ValuePerCall</firstterm>モードと呼ばれる方法で、集合を返す関数が繰り返し呼び出され(毎回同じ引数を渡します)、返す行がなくなるまで呼び出しごとに1つの新しい行を返し、返す行がなくなったらNULLを返します。
したがって、集合を返す関数（<acronym>SRF</acronym>）は、呼び出し間に十分な状態を保存し何をしていたかを記憶して、呼び出しの度に次の項目を返す必要があります。
もう一つは、<firstterm>Materialize</firstterm>モードと呼ばれる方法で、集合を返す関数は結果全体を含むタプルストアオブジェクトを埋めて返します。
結果全体に対して１つの呼び出しだけが発生し、呼び出し間の状態は必要ありません。
    </para>

    <para>
<!--
     When using ValuePerCall mode, it is important to remember that the
     query is not guaranteed to be run to completion; that is, due to
     options such as <literal>LIMIT</literal>, the executor might stop
     making calls to the set-returning function before all rows have been
     fetched.  This means it is not safe to perform cleanup activities in
     the last call, because that might not ever happen.  It's recommended
     to use Materialize mode for functions that need access to external
     resources, such as file descriptors.
-->
ValuePerCallモードを使用する場合、問い合わせが完全に実行される保証はないことに注意してください。
つまり、<literal>LIMIT</literal>などのオプションがあるため、全ての行をフェッチする前に、エクゼキュータが集合を返す関数の呼び出しを中止することがあります。
これは、実行されない可能性があるため、最後の呼び出しでクリーンアップ活動を実行するのは安全ではないことを意味します。
ファイル記述子などの外部リソースにアクセスする必要がある関数には、Materializeモードを使用することをお勧めします。
    </para>

    <para>
<!--
     The remainder of this section documents a set of helper macros that
     are commonly used (though not required to be used) for SRFs using
     ValuePerCall mode.  Additional details about Materialize mode can be
     found in <filename>src/backend/utils/fmgr/README</filename>.  Also,
     the <filename>contrib</filename> modules in
     the <productname>PostgreSQL</productname> source distribution contain
     many examples of SRFs using both ValuePerCall and Materialize mode.
-->
本節の残りの部分では、ValuePerCallモードを使用する集合を返す関数で一般に使用される補助マクロのセット（ただし、使用は必須ではありませんが）について説明します。
Materializeモードの詳細については、<filename>src/backend/utils/fmgr/README</filename>を参照してください。
また、<productname>PostgreSQL</productname>ソース配布物内の<filename>contrib</filename>モジュールには、ValuePerCallとMaterializeモードの両方を使用する、集合を返す関数のより多くの例があります。
    </para>

    <para>
<!--
     To use the ValuePerCall support macros described here,
     include <filename>funcapi.h</filename>.  These macros work with a
     structure <structname>FuncCallContext</structname> that contains the
     state that needs to be saved across calls.  Within the calling
     SRF, <literal>fcinfo-&gt;flinfo-&gt;fn_extra</literal> is used to
     hold a pointer to <structname>FuncCallContext</structname> across
     calls.  The macros automatically fill that field on first use,
     and expect to find the same pointer there on subsequent uses.
-->
ここで説明するValuePerCallサポートマクロを使用するには、<filename>funcapi.h</filename>をインクルードします。
これらのマクロは、複数の呼び出しにわたって保存する必要がある状態を含む<structname>FuncCallContext</structname>構造体が備わっています。
集合を返す関数内では、<literal>fcinfo-&gt;flinfo-&gt;fn_extra</literal>は、呼び出し間で<structname>FuncCallContext</structname>へのポインタを保持するために使用されます。
マクロは、最初の使用時に自動的にそのフィールドを埋め、その後の使用時に同じポインタを見つけることを期待します。
<programlisting>
typedef struct FuncCallContext
{
    /*
<!--
     * Number of times we've been called before
-->
     * 既に行われた呼び出しの回数。
     *
<!--
     * call_cntr is initialized to 0 for you by SRF_FIRSTCALL_INIT(), and
     * incremented for you every time SRF_RETURN_NEXT() is called.
-->
     * SRF_FIRSTCALL_INIT()によってcall_cntrが0に初期化され、
     * SRF_RETURN_NEXT()が呼び出される度に増分されます。
     */
    uint64 call_cntr;

    /*
<!--
     * OPTIONAL maximum number of calls
     *
     * max_calls is here for convenience only and setting it is optional.
     * If not set, you must provide alternative means to know when the
     * function is done.
-->
     * 省略可能 : 呼び出しの最大数
     *
     * max_callsは、便宜上用意されているだけで、設定は省略可能です。
     * 設定されていなければ、関数が終了したことを知るための別の方法を
     * 用意する必要があります。
     */
    uint64 max_calls;

    /*
<!--
     * OPTIONAL pointer to miscellaneous user-provided context information
     *
     * user_fctx is for use as a pointer to your own data to retain
     * arbitrary context information between calls of your function.
-->
     * 省略可能 : 様々なユーザによるコンテキスト情報へのポインタ
     *
     * user_fctxは、関数の呼び出し間の任意のコンテキスト情報を
     * 取得するためのユーザ独自の構造へのポインタとして使用されます。
     */
    void *user_fctx;

    /*
<!--
     * OPTIONAL pointer to struct containing attribute type input metadata
     *
     * attinmeta is for use when returning tuples (i.e., composite data types)
     * and is not used when returning base data types. It is only needed
     * if you intend to use BuildTupleFromCStrings() to create the return
     * tuple.
-->
     * 省略可能 : 属性型入力メタ情報を含んだ構造体へのポインタ
     *
     * attinmeta はタプル（つまり複合データ型）を返す際に使用され、
     * 基本データ型を返す場合には必要ありません。
     * BuildTupleFromCStrings()を使用して返されるタプルを作成する場合にのみ必要です。
     */
    AttInMetadata *attinmeta;

    /*
<!--
     * memory context used for structures that must live for multiple calls
     *
     * multi_call_memory_ctx is set by SRF_FIRSTCALL_INIT() for you, and used
     * by SRF_RETURN_DONE() for cleanup. It is the most appropriate memory
     * context for any memory that is to be reused across multiple calls
     * of the SRF.
-->
     *  複数の呼び出しで必要とされる構造体に使われるメモリコンテキスト
     *
     * multi_call_memory_ctxは、SRF_FIRSTCALL_INIT()によってに設定され、
     * SRF_RETURN_DONE()がクリーンアップの際に使用します。
     * これはSRFの複数呼び出しで再利用される全てのメモリ用に最も適切なメモリコンテキストです。
     */
    MemoryContext multi_call_memory_ctx;

    /*
<!--
     * OPTIONAL pointer to struct containing tuple description
     *
     * tuple_desc is for use when returning tuples (i.e., composite data types)
     * and is only needed if you are going to build the tuples with
     * heap_form_tuple() rather than with BuildTupleFromCStrings().  Note that
     * the TupleDesc pointer stored here should usually have been run through
     * BlessTupleDesc() first.
-->
     * 省略可能: タプル説明を含む構造体へのポインタ。
     * tuple_descはタプル（つまり複合データ型）を返す場合に使用され、BuildTupleFromCStrings()
     * ではなくheap_form_tuple()を使用してタプルを作成する場合にのみ必要です。
     * 通常ここに格納されるTupleDescは最初にBlessTupleDesc()を最初に実行したものでなければなり
     * ません。
     */
    TupleDesc tuple_desc;

} FuncCallContext;
</programlisting>
    </para>

    <para>
<!--
     The macros to be used by an <acronym>SRF</acronym> using this
     infrastructure are:
-->
この基盤を使用して、<acronym>SRF</acronym>が使用するマクロは以下の通りです。
<programlisting>
SRF_IS_FIRSTCALL()
</programlisting>
<!--
     Use this to determine if your function is being called for the first or a
     subsequent time. On the first call (only), call:
-->
これを使用して、関数が初めて呼び出されたのか、2回目以降に呼び出されたのかを判別します。
最初の呼び出し（のみ）で、
<programlisting>
SRF_FIRSTCALL_INIT()
</programlisting>
<!--
     to initialize the <structname>FuncCallContext</structname>. On every function call,
     including the first, call:
-->
を呼び出し、<structname>FuncCallContext</structname>を初期化します。
最初の呼び出しを含むすべての呼び出しで、
<programlisting>
SRF_PERCALL_SETUP()
</programlisting>
<!--
     to set up for using the <structname>FuncCallContext</structname>.
-->
を呼び出し、<structname>FuncCallContext</structname>を使用するように設定します。
    </para>

    <para>
<!--
     If your function has data to return in the current call, use:
-->
現在の呼び出しで返すべきデータが関数にある場合は、次を使用します。
<programlisting>
SRF_RETURN_NEXT(funcctx, result)
</programlisting>
<!--
     to return it to the caller.  (<literal>result</literal> must be of type
     <type>Datum</type>, either a single value or a tuple prepared as
     described above.)  Finally, when your function is finished
     returning data, use:
-->
を使用して、そのデータを呼び出し側に返します。
（先に説明した通り <literal>result</literal>は<type>Datum</type>型、つまり1つの値またはタプルである必要があります。）
最後に、関数がデータを返し終わったら、
<programlisting>
SRF_RETURN_DONE(funcctx)
</programlisting>
<!--
     to clean up and end the <acronym>SRF</acronym>.
-->
を使用して<acronym>SRF</acronym>を片付け、終了します。
    </para>

    <para>
<!--
     The memory context that is current when the <acronym>SRF</acronym> is called is
     a transient context that will be cleared between calls.  This means
     that you do not need to call <function>pfree</function> on everything
     you allocated using <function>palloc</function>; it will go away anyway.  However, if you want to allocate
     any data structures to live across calls, you need to put them somewhere
     else.  The memory context referenced by
     <structfield>multi_call_memory_ctx</structfield> is a suitable location for any
     data that needs to survive until the <acronym>SRF</acronym> is finished running.  In most
     cases, this means that you should switch into
     <structfield>multi_call_memory_ctx</structfield> while doing the
     first-call setup.
     Use <literal>funcctx-&gt;user_fctx</literal> to hold a pointer to
     any such cross-call data structures.
     (Data you allocate
     in <structfield>multi_call_memory_ctx</structfield> will go away
     automatically when the query ends, so it is not necessary to free
     that data manually, either.)
-->
<acronym>SRF</acronym>の呼び出し時に現行になっているメモリコンテキストは一時的なコンテキストで、各呼び出しの間に消去されます。
つまり<function>palloc</function>を使用して割り当てたもののすべてを<function>pfree</function>する必要はありません。
これらはいずれ消去されるものだからです。
しかし、データ構造体を複数の呼び出しに渡って使用するように割り当てる場合は、どこか別の場所に置いておく必要があります。
<structfield>multi_call_memory_ctx</structfield>によって参照されるメモリコンテキストは、<acronym>SRF</acronym>の実行が終わるまで使用可能にしなければならないデータの保管場所として適しています。
つまり、ほとんどの場合、最初の呼び出しのセットアップ中に<structfield>multi_call_memory_ctx</structfield>へ切り替える必要があるということです。
<literal>funcctx-&gt;user_fctx</literal>を使用して、このような複数の呼び出しに渡るデータ構造体へのポインタを保持します。
（<structfield>multi_call_memory_ctx</structfield>に配置したデータは、問い合わせが終了すると自動的に削除されるので、そのデータを手動で開放する必要はありません。）
    </para>

    <warning>
     <para>
<!--
      While the actual arguments to the function remain unchanged between
      calls, if you detoast the argument values (which is normally done
      transparently by the
      <function>PG_GETARG_<replaceable>xxx</replaceable></function> macro)
      in the transient context then the detoasted copies will be freed on
      each cycle. Accordingly, if you keep references to such values in
      your <structfield>user_fctx</structfield>, you must either copy them into the
      <structfield>multi_call_memory_ctx</structfield> after detoasting, or ensure
      that you detoast the values only in that context.
-->
関数の実引数は呼出しの間変わらないままですが、一時的なコンテキストで引数の値をTOAST解除した場合には(これは通常、<function>PG_GETARG_<replaceable>xxx</replaceable></function>マクロにより透過的に行なわれます)、TOAST解除されたコピーが各サイクルで解放されます。
従って、<structfield>user_fctx</structfield>内のその値への参照を保持する場合には、TOAST解除した後に<structfield>multi_call_memory_ctx</structfield>にそれらをコピーするか、その値をTOAST解除するのはそのコンテキストの中だけであること確実にしなければなりません。
     </para>
    </warning>

    <para>
<!--
     A complete pseudo-code example looks like the following:
-->
     完全な疑似コードの例を示します。
<programlisting>
Datum
my_set_returning_function(PG_FUNCTION_ARGS)
{
    FuncCallContext  *funcctx;
    Datum             result;
    <replaceable>further declarations as needed</replaceable>

    if (SRF_IS_FIRSTCALL())
    {
        MemoryContext oldcontext;

        funcctx = SRF_FIRSTCALL_INIT();
        oldcontext = MemoryContextSwitchTo(funcctx-&gt;multi_call_memory_ctx);
<!--
        /* One-time setup code appears here: */
-->
        /* 一度限りのセットアップコードがここに入ります: */
        <replaceable>user code</replaceable>
        <replaceable>if returning composite</replaceable>
            <replaceable>build TupleDesc, and perhaps AttInMetadata</replaceable>
        <replaceable>endif returning composite</replaceable>
        <replaceable>user code</replaceable>
        MemoryContextSwitchTo(oldcontext);
    }

<!--
    /* Each-time setup code appears here: */
-->
    /* 毎回実行するセットアップコードがここに入ります: */
    <replaceable>user code</replaceable>
    funcctx = SRF_PERCALL_SETUP();
    <replaceable>user code</replaceable>

<!--
    /* this is just one way we might test whether we are done: */
-->
    /* これは、終了したかどうかをテストする方法の1つです: */
    if (funcctx-&gt;call_cntr &lt; funcctx-&gt;max_calls)
    {
<!--
        /* Here we want to return another item: */
-->
        /* ここで、別の項目を返します: */
        <replaceable>user code</replaceable>
        <replaceable>obtain result Datum</replaceable>
        SRF_RETURN_NEXT(funcctx, result);
    }
    else
    {
<!--
        /* Here we are done returning items, so just report that fact. */
        /* (Resist the temptation to put cleanup code here.) */
-->
        /* これで項目を返し終わりました。 その事実を報告します。 */
        /* （ここにクリーンアップコードを置く誘惑に抵抗してください。) */
        SRF_RETURN_DONE(funcctx);
    }
}
</programlisting>
    </para>

    <para>
<!--
     A complete example of a simple <acronym>SRF</acronym> returning a composite type
     looks like:
-->
複合型を返す単純な<acronym>SRF</acronym>の完全な例は以下の通りです。
<programlisting><![CDATA[
PG_FUNCTION_INFO_V1(retcomposite);

Datum
retcomposite(PG_FUNCTION_ARGS)
{
    FuncCallContext     *funcctx;
    int                  call_cntr;
    int                  max_calls;
    TupleDesc            tupdesc;
    AttInMetadata       *attinmeta;

]]><!--
    /* stuff done only on the first call of the function */
--><![CDATA[
     /* 関数の最初の呼び出し時にのみ実行 */
    if (SRF_IS_FIRSTCALL())
    {
        MemoryContext   oldcontext;

]]><!--
        /* create a function context for cross-call persistence */
--><![CDATA[
        /* 呼び出し間で永続化する関数コンテキストを作成 */
        funcctx = SRF_FIRSTCALL_INIT();

]]><!--
        /* switch to memory context appropriate for multiple function calls */
--><![CDATA[
        /* 複数関数呼び出しに適切なメモリコンテキストへの切り替え */
        oldcontext = MemoryContextSwitchTo(funcctx->multi_call_memory_ctx);

]]><!--
        /* total number of tuples to be returned */
--><![CDATA[
        /* 返されるタプルの合計数 */
        funcctx->max_calls = PG_GETARG_UINT32(0);

]]><!--
        /* Build a tuple descriptor for our result type */
--><![CDATA[
        /*  結果型用のタプル記述子を作成 */
        if (get_call_result_type(fcinfo, NULL, &tupdesc) != TYPEFUNC_COMPOSITE)
            ereport(ERROR,
                    (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
                     errmsg("function returning record called in context "
                            "that cannot accept type record")));

        /*
]]><!--
         * generate attribute metadata needed later to produce tuples from raw
         * C strings
--><![CDATA[
         * 後で未加工のC文字列からタプルを作成するために必要となる
         * 属性メタデータの生成
         */
        attinmeta = TupleDescGetAttInMetadata(tupdesc);
        funcctx->attinmeta = attinmeta;

        MemoryContextSwitchTo(oldcontext);
    }

]]><!--
    /* stuff done on every call of the function */
--><![CDATA[
    /* 全ての関数呼び出しで実行 */
    funcctx = SRF_PERCALL_SETUP();

    call_cntr = funcctx->call_cntr;
    max_calls = funcctx->max_calls;
    attinmeta = funcctx->attinmeta;

]]><!--
    if (call_cntr < max_calls)    /* do when there is more left to send */
--><![CDATA[
    if (call_cntr < max_calls)    /* 他にも送るものがある場合  */
    {
        char       **values;
        HeapTuple    tuple;
        Datum        result;

        /*
]]><!--
         * Prepare a values array for building the returned tuple.
         * This should be an array of C strings which will
         * be processed later by the type input functions.
--><![CDATA[
         * 返すタプルを構築するためのvalues配列を用意します。
         * これは、後で適切な入力関数で処理される
         * C文字列の配列でなければなりません。
         */
        values = (char **) palloc(3 * sizeof(char *));
        values[0] = (char *) palloc(16 * sizeof(char));
        values[1] = (char *) palloc(16 * sizeof(char));
        values[2] = (char *) palloc(16 * sizeof(char));

        snprintf(values[0], 16, "%d", 1 * PG_GETARG_INT32(1));
        snprintf(values[1], 16, "%d", 2 * PG_GETARG_INT32(1));
        snprintf(values[2], 16, "%d", 3 * PG_GETARG_INT32(1));

]]><!--
        /* build a tuple */
--><![CDATA[
        /* タプルの作成 */
        tuple = BuildTupleFromCStrings(attinmeta, values);

]]><!--
        /* make the tuple into a datum */
--><![CDATA[
        /* タプルをdatumに変換 */
        result = HeapTupleGetDatum(tuple);

]]><!--
        /* clean up (this is not really necessary) */
--><![CDATA[
        /* クリーンアップ（これは必須ではありません） */
        pfree(values[0]);
        pfree(values[1]);
        pfree(values[2]);
        pfree(values);

        SRF_RETURN_NEXT(funcctx, result);
    }
]]><!--
    else    /* do when there is no more left */
--><![CDATA[
    else    /* 何も残っていない場合 */
    {
        SRF_RETURN_DONE(funcctx);
    }
}
]]>
</programlisting>

<!--
     One way to declare this function in SQL is:
-->
以下にこの関数をSQLで宣言する一例を示します。
<programlisting>
CREATE TYPE __retcomposite AS (f1 integer, f2 integer, f3 integer);

CREATE OR REPLACE FUNCTION retcomposite(integer, integer)
    RETURNS SETOF __retcomposite
    AS '<replaceable>filename</replaceable>', 'retcomposite'
    LANGUAGE C IMMUTABLE STRICT;
</programlisting>
<!--
     A different way is to use OUT parameters:
-->
他にも以下のようにOUTパラメータを使用する方法もあります。
<programlisting>
CREATE OR REPLACE FUNCTION retcomposite(IN integer, IN integer,
    OUT f1 integer, OUT f2 integer, OUT f3 integer)
    RETURNS SETOF record
    AS '<replaceable>filename</replaceable>', 'retcomposite'
    LANGUAGE C IMMUTABLE STRICT;
</programlisting>
<!--
     Notice that in this method the output type of the function is formally
     an anonymous <structname>record</structname> type.
-->
この方法では、関数の出力型は形式上無名の<structname>record</structname>型になることに注意してください。
    </para>
   </sect2>

   <sect2>
<!--
    <title>Polymorphic Arguments and Return Types</title>
-->
    <title>引数と戻り値の多様性</title>

    <para>
<!--
     C-language functions can be declared to accept and
     return the polymorphic types described in <xref
     linkend="extend-types-polymorphic"/>.
     When a function's arguments or return types
     are defined as polymorphic types, the function author cannot know
     in advance what data type it will be called with, or
     need to return. There are two routines provided in <filename>fmgr.h</filename>
     to allow a version-1 C function to discover the actual data types
     of its arguments and the type it is expected to return. The routines are
     called <literal>get_fn_expr_rettype(FmgrInfo *flinfo)</literal> and
     <literal>get_fn_expr_argtype(FmgrInfo *flinfo, int argnum)</literal>.
     They return the result or argument type OID, or <symbol>InvalidOid</symbol> if the
     information is not available.
     The structure <literal>flinfo</literal> is normally accessed as
     <literal>fcinfo-&gt;flinfo</literal>. The parameter <literal>argnum</literal>
     is zero based.  <function>get_call_result_type</function> can also be used
     as an alternative to <function>get_fn_expr_rettype</function>.
     There is also <function>get_fn_expr_variadic</function>, which can be used to
     find out whether variadic arguments have been merged into an array.
     This is primarily useful for <literal>VARIADIC "any"</literal> functions,
     since such merging will always have occurred for variadic functions
     taking ordinary array types.
-->
C言語関数は、<xref linkend="extend-types-polymorphic"/>で説明されている多様型を受け付ける、または返すように宣言することができます。
多様関数の詳細な説明は<xref linkend="extend-types-polymorphic"/>を参照してください。
関数の引数もしくは戻り値が多様型として定義される時、関数の作成者は前もって呼び出しにおけるデータ型や返すべきデータ型が何であるかを知ることはできません。
Version-1 C関数で引数の実データ型と、返すべきと想定された型を発見できるための2つのルーチンが<filename>fmgr.h</filename>に用意されています。
このルーチンは<literal>get_fn_expr_rettype(FmgrInfo *flinfo)</literal>と<literal>get_fn_expr_argtype(FmgrInfo *flinfo, int argnum)</literal>という名前です。
これらは結果もしくは引数型のOIDを返します。
ただし、もし情報が利用できなければ<symbol>InvalidOid</symbol>を返します。
<literal>flinfo</literal>構造体は通常<literal>fcinfo-&gt;flinfo</literal>としてアクセスされます。
<literal>argnum</literal>パラメータは0から始まります。
また、<function>get_fn_expr_rettype</function>の代わりに<function>get_call_result_type</function>を使用することもできます。
また、variadic変数が配列に吸収されたかどうかを判定するために使用できる<function>get_fn_expr_variadic</function>があります。
そのような吸収はvariadic関数が普通の配列型をとる場合に必ず起こりますので、これは特に<literal>VARIADIC "any"</literal>の場合に有用です。
    </para>

    <para>
<!--
     For example, suppose we want to write a function to accept a single
     element of any type, and return a one-dimensional array of that type:
-->
例えば、任意の型の単一要素を受け付け、その型の1次元配列を返す関数を考えてみます。

<programlisting>
PG_FUNCTION_INFO_V1(make_array);
Datum
make_array(PG_FUNCTION_ARGS)
{
    ArrayType  *result;
    Oid         element_type = get_fn_expr_argtype(fcinfo-&gt;flinfo, 0);
    Datum       element;
    bool        isnull;
    int16       typlen;
    bool        typbyval;
    char        typalign;
    int         ndims;
    int         dims[MAXDIM];
    int         lbs[MAXDIM];

    if (!OidIsValid(element_type))
        elog(ERROR, "could not determine data type of input");

<!--
    /* get the provided element, being careful in case it's NULL */
-->
    /* 与えられた要素がNULLかどうか注意しつつ、要素を取り出します。*/
    isnull = PG_ARGISNULL(0);
    if (isnull)
        element = (Datum) 0;
    else
        element = PG_GETARG_DATUM(0);

<!--
    /* we have one dimension */
-->
    /* 次元数は1 */
    ndims = 1;
<!--
    /* and one element */
-->
    /* 要素を1つ */
    dims[0] = 1;
<!--
    /* and lower bound is 1 */
-->
    /* 下限は1 */
    lbs[0] = 1;

<!--
    /* get required info about the element type */
-->
    /* この要素型に関する必要情報を取り出す。 */
    get_typlenbyvalalign(element_type, &amp;typlen, &amp;typbyval, &amp;typalign);

<!--
    /* now build the array */
-->
    /* ここで配列を作成 */
    result = construct_md_array(&amp;element, &amp;isnull, ndims, dims, lbs,
                                element_type, typlen, typbyval, typalign);

    PG_RETURN_ARRAYTYPE_P(result);
}
</programlisting>
    </para>

    <para>
<!--
     The following command declares the function
     <function>make_array</function> in SQL:
-->
以下のコマンドはSQLで<function>make_array</function>関数を宣言します。

<programlisting>
CREATE FUNCTION make_array(anyelement) RETURNS anyarray
    AS '<replaceable>DIRECTORY</replaceable>/funcs', 'make_array'
    LANGUAGE C IMMUTABLE;
</programlisting>
    </para>

    <para>
<!--
     There is a variant of polymorphism that is only available to C-language
     functions: they can be declared to take parameters of type
     <literal>"any"</literal>.  (Note that this type name must be double-quoted,
     since it's also a SQL reserved word.)  This works like
     <type>anyelement</type> except that it does not constrain different
     <literal>"any"</literal> arguments to be the same type, nor do they help
     determine the function's result type.  A C-language function can also
     declare its final parameter to be <literal>VARIADIC "any"</literal>.  This will
     match one or more actual arguments of any type (not necessarily the same
     type).  These arguments will <emphasis>not</emphasis> be gathered into an array
     as happens with normal variadic functions; they will just be passed to
     the function separately.  The <function>PG_NARGS()</function> macro and the
     methods described above must be used to determine the number of actual
     arguments and their types when using this feature.  Also, users of such
     a function might wish to use the <literal>VARIADIC</literal> keyword in their
     function call, with the expectation that the function would treat the
     array elements as separate arguments.  The function itself must implement
     that behavior if wanted, after using <function>get_fn_expr_variadic</function> to
     detect that the actual argument was marked with <literal>VARIADIC</literal>.
-->
C言語関数でのみ使用できる多様性の変異体があります。
<literal>"any"</literal>型のパラメータを取るように宣言できます。
（この型名は、SQL予約語でもあるため二重引用符で括らなくてはならないことに注意してください。）
これは、他の<literal>"any"</literal>引数が同じ型になることを強要することも、関数の結果型の決定を支援することもない点を除いて、<type>anyelement</type>のように動作します。
C言語関数は最終パラメータが<literal>VARIADIC "any"</literal>であるように宣言可能です。
これは任意の型の１つ以上の実引数と一致します（同じ型である必要はありません）。
これらの引数は、通常のvariadic関数で起こったように、配列の中にまとめ<emphasis>られません</emphasis>。
それらは単に別々に関数に渡されるだけです。
<function>PG_NARGS()</function>マクロと上に記載したメソッドは、この機能を使用するときに実際の引数とその型を決定するため使用されなければなりません。
また、こうした関数のユーザは、その関数呼び出しにおいて、関数が配列要素を分離した引数として扱うだろうという予想のもとで<literal>VARIADIC</literal>キーワードを良く使用するかもしれません。
関数自身は必要ならば、<function>get_fn_expr_variadic</function>を実行した後で、実引数が<literal>VARIADIC</literal>付きであることを検出した場合に、その動作を実装しなければなりません。
    </para>
   </sect2>

   <sect2 id="xfunc-shared-addin">
<!--
    <title>Shared Memory and LWLocks</title>
-->
    <title>共有メモリとLWLocks</title>

    <para>
<!--
     Add-ins can reserve LWLocks and an allocation of shared memory on server
     startup.  The add-in's shared library must be preloaded by specifying
     it in
     <xref linkend="guc-shared-preload-libraries"/><indexterm><primary>shared_preload_libraries</primary></indexterm>.
     Shared memory is reserved by calling:
-->
アドインはLWLocks（軽量ロック）とサーバ起動時に共有メモリの割り当てを保持することができます。
<xref linkend="guc-shared-preload-libraries"/><indexterm><primary>shared_preload_libraries</primary></indexterm>で指定して、こうしたアドインの共有ライブラリを事前にロードしなければなりません。
共有メモリは、その<function>_PG_init</function>関数で以下を呼び出すことで保持されます。
<programlisting>
void RequestAddinShmemSpace(int size)
</programlisting>
<!--
     from your <function>_PG_init</function> function.
-->
    </para>
    <para>
<!--
     LWLocks are reserved by calling:
-->
LWLocksはその<function>_PG_init</function>関数で以下を呼び出すことで保持されます。
<programlisting>
void RequestNamedLWLockTranche(const char *tranche_name, int num_lwlocks)
</programlisting>
<!--
     from <function>_PG_init</function>.  This will ensure that an array of
     <literal>num_lwlocks</literal> LWLocks is available under the name
     <literal>tranche_name</literal>.  Use <function>GetNamedLWLockTranche</function>
     to get a pointer to this array.
-->
<literal>num_lwlocks</literal>個のLWLockの配列が<literal>tranche_name</literal>という名前で確実に利用できるようにします。
この配列へのポインタを得るには<function>GetNamedLWLockTranche</function>を使ってください。
    </para>
    <para>
<!--
     To avoid possible race-conditions, each backend should use the LWLock
     <function>AddinShmemInitLock</function> when connecting to and initializing
     its allocation of shared memory, as shown here:
-->
競合状態の可能性を防止するために、割り当てられた共有メモリへの接続やその初期化時に、以下のように各バックエンドで<function>AddinShmemInitLock</function>軽量ロックを使用しなければなりません。
<programlisting>
static mystruct *ptr = NULL;

if (!ptr)
{
        bool    found;

        LWLockAcquire(AddinShmemInitLock, LW_EXCLUSIVE);
        ptr = ShmemInitStruct("my struct name", size, &amp;found);
        if (!found)
        {
                initialize contents of shmem area;
                acquire any requested LWLocks using:
                ptr->locks = GetNamedLWLockTranche("my tranche name");
        }
        LWLockRelease(AddinShmemInitLock);
}
</programlisting>
    </para>
   </sect2>

   <sect2 id="extend-cpp">
<!--
    <title>Using C++ for Extensibility</title>
-->
    <title>拡張へのC++の利用</title>

    <indexterm zone="extend-cpp">
     <primary>C++</primary>
    </indexterm>

    <para>
<!--
     Although the <productname>PostgreSQL</productname> backend is written in
     C, it is possible to write extensions in C++ if these guidelines are
     followed:
-->
以下のガイドラインに従うことで、<productname>PostgreSQL</productname>の拡張を構築するためC++モードのコンパイラを利用できます。

     <itemizedlist>
      <listitem>
       <para>
<!--
         All functions accessed by the backend must present a C interface
         to the backend;  these C functions can then call C++ functions.
         For example, <literal>extern C</literal> linkage is required for
         backend-accessed functions.  This is also necessary for any
         functions that are passed as pointers between the backend and
         C++ code.
-->
バックエンドからアクセスされる関数はすべてバックエンドに対してCインタフェースを提供しなければなりません。
このC関数はC++関数を呼びだすことができます。
例えば、バックエンドからアクセスされる関数には<literal>extern C</literal>リンクが必要です。
これはバックエンドとC++コードの間でポインタとして渡される関数にも必要です。
       </para>
      </listitem>
      <listitem>
       <para>
<!--
        Free memory using the appropriate deallocation method.  For example,
        most backend memory is allocated using <function>palloc()</function>, so use
        <function>pfree()</function> to free it.  Using C++
        <function>delete</function> in such cases will fail.
-->
適切な解放メソッドを使ってメモリを解放してください。
例えば、ほとんどのバックエンドメモリは<function>palloc()</function>で確保されますので、<function>pfree()</function>を使って解放してください。
この場合にC++の<function>delete()</function>を使うと失敗するでしょう。
       </para>
      </listitem>
      <listitem>
       <para>
<!--
        Prevent exceptions from propagating into the C code (use a catch-all
        block at the top level of all <literal>extern C</literal> functions).  This
        is necessary even if the C++ code does not explicitly throw any
        exceptions, because events like out-of-memory can still throw
        exceptions.  Any exceptions must be caught and appropriate errors
        passed back to the C interface.  If possible, compile C++ with
        <option>-fno-exceptions</option> to eliminate exceptions entirely; in such
        cases, you must check for failures in your C++ code, e.g.,  check for
        NULL returned by <function>new()</function>.
-->
例外がCコードへ伝播しないようにしてください（<literal>extern C</literal>関数すべての最上位ですべての例外を捕捉するブロックを使ってください）。
メモリ不足のようなイベントにより例外が発生する可能性がありますので、C++コードが何も例外を発生させない場合であっても、これは必要です。
例外はすべて捕捉しなければなりません。
そして適切なエラーをCインタフェースに渡してください。
可能であれば、例外を完全に除去できるように<option>-fno-exceptions</option>を付けてC++をコンパイルしてください。
その場合、例えば<function>new()</function>で返されるNULLの検査など、C++コード内で失敗の検査を行わなければなりません。
       </para>
      </listitem>
      <listitem>
       <para>
<!--
        If calling backend functions from C++ code, be sure that the
        C++ call stack contains only plain old data structures
        (<acronym>POD</acronym>).  This is necessary because backend errors
        generate a distant <function>longjmp()</function> that does not properly
        unroll a C++ call stack with non-POD objects.
-->
C++コードからバックエンド関数を呼び出す場合には、C++呼び出しスタック内にC言語互換構造体（<acronym>POD</acronym>）のみが含まれていることを確認してください。
バックエンドのエラーは、非PODオブジェクトを持つC++呼び出しスタックを適切に戻すことができない、長距離<function>longjmp()</function>を生成しますので、これは必要です。
       </para>
      </listitem>
     </itemizedlist>
    </para>

    <para>
<!--
     In summary, it is best to place C++ code behind a wall of
     <literal>extern C</literal> functions that interface to the backend,
     and avoid exception, memory, and call stack leakage.
-->
まとめると、バックエンドとやりとりするための壁の役割を担う<literal>extern C</literal>関数の背後にC++コードを配置して、例外、メモリ、呼び出しスタックそれぞれの漏れを避けるのが最善です。
    </para>
   </sect2>

  </sect1>

  <sect1 id="xfunc-optimization">
<!--
   <title>Function Optimization Information</title>
-->
   <title>関数最適化に関する情報</title>

  <indexterm zone="xfunc-optimization">
<!--
   <primary>optimization information</primary>
   <secondary>for functions</secondary>
-->
   <primary>最適化情報</primary>
   <secondary>関数に対する</secondary>
  </indexterm>

   <para>
<!--
    By default, a function is just a <quote>black box</quote> that the
    database system knows very little about the behavior of.  However,
    that means that queries using the function may be executed much less
    efficiently than they could be.  It is possible to supply additional
    knowledge that helps the planner optimize function calls.
-->
デフォルトでは、関数は、データベースシステムがその振舞いについてごく一部しか知らない単なる<quote>ブラックボックス</quote>です。
しかし、これは、関数を使う問い合わせがその実力よりもずっと効率悪く実行されるかもしれないことを意味します。
プランナが関数呼び出しを最適化するのを助ける補足の情報を提供することが可能です。
   </para>

   <para>
<!--
    Some basic facts can be supplied by declarative annotations provided in
    the <xref linkend="sql-createfunction"/> command.  Most important of
    these is the function's <link linkend="xfunc-volatility">volatility
    category</link> (<literal>IMMUTABLE</literal>, <literal>STABLE</literal>,
    or <literal>VOLATILE</literal>); one should always be careful to
    specify this correctly when defining a function.
    The parallel safety property (<literal>PARALLEL
    UNSAFE</literal>, <literal>PARALLEL RESTRICTED</literal>, or
    <literal>PARALLEL SAFE</literal>) must also be specified if you hope
    to use the function in parallelized queries.
    It can also be useful to specify the function's estimated execution
    cost, and/or the number of rows a set-returning function is estimated
    to return.  However, the declarative way of specifying those two
    facts only allows specifying a constant value, which is often
    inadequate.
-->
基本的な事実のいくつかは<xref linkend="sql-createfunction"/>コマンドで宣言的な注釈として提供されます。
この中でも最も重要なものは、関数の<link linkend="xfunc-volatility">変動性分類</link>(<literal>IMMUTABLE</literal>、<literal>STABLE</literal>または<literal>VOLATILE</literal>)です。関数を定義する時にはこれを正しく指定するよう常に注意すべきです。
並列問い合わせでその関数を使いたいのなら、並列処理での安全性の性質(<literal>PARALLEL UNSAFE</literal>、<literal>PARALLEL RESTRICTED</literal>または<literal>PARALLEL SAFE</literal>)も指定しなければなりません。
関数の推定実行コストや集合を返す関数が返すと推定される行数を指定することも有用な場合があります。
しかし、この2つの事実を指定する宣言的な方法は定数を指定することしか許しておらず、それは多くの場合不適切です。
   </para>

   <para>
<!--
    It is also possible to attach a <firstterm>planner support
    function</firstterm> to a SQL-callable function (called
    its <firstterm>target function</firstterm>), and thereby provide
    knowledge about the target function that is too complex to be
    represented declaratively.  Planner support functions have to be
    written in C (although their target functions might not be), so this is
    an advanced feature that relatively few people will use.
-->
SQLで呼び出せる関数(対応する<firstterm>対象関数</firstterm>と呼ばれます)に<firstterm>プランナサポート関数</firstterm>を結び付け、それによって複雑すぎて宣言的に表現できない対象関数に関する知識を提供することも可能です。
(対象関数はそうではありませんが)プランナサポート関数はCで書かなければなりませんので、これは比較的少数の人が使う先進的な機能です。
   </para>

   <para>
<!--
    A planner support function must have the SQL signature
-->
プランナサポート関数には以下のSQLシグネチャがなければなりません。
<programlisting>
supportfn(internal) returns internal
</programlisting>
<!--
    It is attached to its target function by specifying
    the <literal>SUPPORT</literal> clause when creating the target function.
-->
対象関数を作成する時に<literal>SUPPORT</literal>句を指定することで対象関数に結び付けられます。
   </para>

   <para>
<!--
    The details of the API for planner support functions can be found in
    file <filename>src/include/nodes/supportnodes.h</filename> in the
    <productname>PostgreSQL</productname> source code.  Here we provide
    just an overview of what planner support functions can do.
    The set of possible requests to a support function is extensible,
    so more things might be possible in future versions.
-->
プランナサポート関数のAPIの詳細は、<productname>PostgreSQL</productname>ソースコードのファイル<filename>src/include/nodes/supportnodes.h</filename>で見つけられます。
ここではプランナサポート関数ができることの概略を説明するにとどめます。
サポート関数へ可能なリクエストの集合は拡張可能ですので、将来のバージョンではより多くのことが可能になっているでしょう。
   </para>

   <para>
<!--
    Some function calls can be simplified during planning based on
    properties specific to the function.  For example,
    <literal>int4mul(n, 1)</literal> could be simplified to
    just <literal>n</literal>.  This type of transformation can be
    performed by a planner support function, by having it implement
    the <literal>SupportRequestSimplify</literal> request type.
    The support function will be called for each instance of its target
    function found in a query parse tree.  If it finds that the particular
    call can be simplified into some other form, it can build and return a
    parse tree representing that expression.  This will automatically work
    for operators based on the function, too &mdash; in the example just
    given, <literal>n * 1</literal> would also be simplified to
    <literal>n</literal>.
    (But note that this is just an example; this particular
    optimization is not actually performed by
    standard <productname>PostgreSQL</productname>.)
    We make no guarantee that <productname>PostgreSQL</productname> will
    never call the target function in cases that the support function could
    simplify.  Ensure rigorous equivalence between the simplified
    expression and an actual execution of the target function.
-->
一部の関数呼び出しでは、関数固有の属性に基づいて計画作成中に単純化できます。
例えば、<literal>int4mul(n, 1)</literal>は<literal>n</literal>だけに単純化できます。
この種の変形は、<literal>SupportRequestSimplify</literal>リクエスト型プランナサポート関数に実装することにより実行されます。
問い合わせ解析木で見つかった対象関数それぞれに対して、サポート関数が呼び出されます。
特定の呼出しが別の形に単純化できることが分かれば、その式を表現する解析木を作成して返します。
これは、その関数に基づく演算子に対しても自動的に行なわれます&mdash;上の例では<literal>n * 1</literal>も<literal>n</literal>へと単純化されます。
(しかし、これは単なる例であることに注意してください。この特定の最適化は、標準の<productname>PostgreSQL</productname>では実際には行なわれません。)
サポート関数が単純化する状況では、<productname>PostgreSQL</productname>が対象関数を呼び出すことはないとは保証しません。
単純化された式と対象関数の実際の実行が厳密に等しいことを確実にしてください。
   </para>

   <para>
<!--
    For target functions that return <type>boolean</type>, it is often useful to estimate
    the fraction of rows that will be selected by a <literal>WHERE</literal> clause using that
    function.  This can be done by a support function that implements
    the <literal>SupportRequestSelectivity</literal> request type.
-->
<type>boolean</type>を返す対象関数に対しては、その関数を使った<literal>WHERE</literal>句により選択される行の割合を推定するのが有用な場合がよくあります。
これは<literal>SupportRequestSelectivity</literal>リクエスト型を実装したサポート関数で行なえます。
   </para>

   <para>
<!--
    If the target function's run time is highly dependent on its inputs,
    it may be useful to provide a non-constant cost estimate for it.
    This can be done by a support function that implements
    the <literal>SupportRequestCost</literal> request type.
-->
対象関数の実行時間が、その入力に大きく依存する場合には、それに対応する定数でないコスト推定を提供するのが有用でしょう。
これは<literal>SupportRequestCost</literal>リクエスト型を実装したサポート関数で行なえます。
   </para>

   <para>
<!--
    For target functions that return sets, it is often useful to provide
    a non-constant estimate for the number of rows that will be returned.
    This can be done by a support function that implements
    the <literal>SupportRequestRows</literal> request type.
-->
集合を返す対象関数に対しては、その関数が返す行の数の定数でない推定を提供するのが有用な場合がよくあります。
これは<literal>SupportRequestRows</literal>リクエスト型を実装したサポート関数で行なえます。
   </para>

   <para>
<!--
    For target functions that return <type>boolean</type>, it may be possible to
    convert a function call appearing in <literal>WHERE</literal> into an indexable operator
    clause or clauses.  The converted clauses might be exactly equivalent
    to the function's condition, or they could be somewhat weaker (that is,
    they might accept some values that the function condition does not).
    In the latter case the index condition is said to
    be <firstterm>lossy</firstterm>; it can still be used to scan an index,
    but the function call will have to be executed for each row returned by
    the index to see if it really passes the <literal>WHERE</literal> condition or not.
    To create such conditions, the support function must implement
    the <literal>SupportRequestIndexCondition</literal> request type.
-->
<type>boolean</type>を返す対象関数に対しては、<literal>WHERE</literal>句に現れる関数呼び出しをインデックス可能な演算子句に変換できる場合があります。
変換された句は、正確にその関数の条件と等しいか幾分弱い(すなわち、関数の条件が受け付けない値も受け付けるかもしれません)でしょう。
後者の場合、インデックスの条件は<firstterm>損失がある</firstterm>と言われます。それでもインデックスの走査には使えますが、それが本当に<literal>WHERE</literal>条件を満たすのかどうか、インデックスにより返された各行に対して関数呼び出しを実行しないといけません。
そのような条件を作るには、サポート関数は<literal>SupportRequestIndexCondition</literal>リクエスト型を実装しなければなりません。
   </para>
  </sect1>
