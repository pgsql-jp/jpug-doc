<!-- doc/src/sgml/ddl.sgml -->

<chapter id="ddl">
<!--
 <title>Data Definition</title>
-->
 <title>データ定義</title>

 <para>
<!--
  This chapter covers how one creates the database structures that
  will hold one's data.  In a relational database, the raw data is
  stored in tables, so the majority of this chapter is devoted to
  explaining how tables are created and modified and what features are
  available to control what data is stored in the tables.
  Subsequently, we discuss how tables can be organized into
  schemas, and how privileges can be assigned to tables.  Finally,
  we will briefly look at other features that affect the data storage,
  such as inheritance, table partitioning, views, functions, and
  triggers.
-->
本章では、データを保持するためのデータベース構造を作成する方法を説明します。
リレーショナルデータベースでは生データはテーブルに格納されます。
したがって、本章ではテーブルの作成と変更の方法や、テーブルにどのようなデータを格納するかを制御するための機能について重点的に解説します。
さらに、テーブルをスキーマに編成する方法、およびテーブルへの権限の割り当てについても説明します。
そして最後に、継承、テーブルのパーティショニング、ビュー、関数、およびトリガなど、データの格納に影響する機能について簡単に説明します。
 </para>

 <sect1 id="ddl-basics">
<!--
  <title>Table Basics</title>
-->
  <title>テーブルの基本</title>

  <indexterm zone="ddl-basics">
<!--
   <primary>table</primary>
-->
   <primary>テーブル</primary>
  </indexterm>

  <indexterm>
<!--
   <primary>row</primary>
-->
   <primary>行</primary>
  </indexterm>

  <indexterm>
<!--
   <primary>column</primary>
-->
   <primary>列</primary>
  </indexterm>

  <para>
<!--
   A table in a relational database is much like a table on paper: It
   consists of rows and columns.  The number and order of the columns
   is fixed, and each column has a name.  The number of rows is
   variable &mdash; it reflects how much data is stored at a given moment.
   SQL does not make any guarantees about the order of the rows in a
   table.  When a table is read, the rows will appear in an unspecified order,
   unless sorting is explicitly requested.  This is covered in <xref
   linkend="queries"/>.  Furthermore, SQL does not assign unique
   identifiers to rows, so it is possible to have several completely
   identical rows in a table.  This is a consequence of the
   mathematical model that underlies SQL but is usually not desirable.
   Later in this chapter we will see how to deal with this issue.
-->
リレーショナルデータベースのテーブルは、紙に書く表によく似ています。
テーブルは行と列からできています。
列の数と順序は固定されており、それぞれの列に名前が付けられています。
行の数は可変です。
つまり行の数とは、その時点でどれだけのデータが格納されているのかを示すものです。
SQLではテーブル内の行の順序は保証されません。
テーブルを読み込むと、明示的に並び替えが要求されない限り、行は不特定な順序で返されます。
これについては<xref linkend="queries"/>を参照してください。
さらに、SQLでは行に固有の識別子が割り当てられないので、テーブル内にまったく同一の行がいくつも存在することがあり得ます。
これは、SQLの基礎をなす数学的モデルの帰結ですが、通常は好ましいことではありません。
この問題の対処法については、本章で後述します。
  </para>

  <para>
<!--
   Each column has a data type.  The data type constrains the set of
   possible values that can be assigned to a column and assigns
   semantics to the data stored in the column so that it can be used
   for computations.  For instance, a column declared to be of a
   numerical type will not accept arbitrary text strings, and the data
   stored in such a column can be used for mathematical computations.
   By contrast, a column declared to be of a character string type
   will accept almost any kind of data but it does not lend itself to
   mathematical calculations, although other operations such as string
   concatenation are available.
-->
それぞれの列にデータ型があります。
データ型によって、列に割り当てられる値が制限されます。
また、列に格納されているデータに意味が割り当てられ、データを計算に使用できるようになります。
例えば、数値型と宣言された列は任意のテキスト文字列は受け付けません。
そして、数値型の列に格納されているデータは算術計算に使用できます。
これに対して、文字列型と宣言された列はほとんど全ての種類のデータを受け付けます。
しかし、文字列の結合といった演算には使用できますが、算術計算には使用できません。
  </para>

  <para>
<!--
   <productname>PostgreSQL</productname> includes a sizable set of
   built-in data types that fit many applications.  Users can also
   define their own data types.  Most built-in data types have obvious
   names and semantics, so we defer a detailed explanation to <xref
   linkend="datatype"/>.  Some of the frequently used data types are
   <type>integer</type> for whole numbers, <type>numeric</type> for
   possibly fractional numbers, <type>text</type> for character
   strings, <type>date</type> for dates, <type>time</type> for
   time-of-day values, and <type>timestamp</type> for values
   containing both date and time.
-->
<productname>PostgreSQL</productname>には、様々なアプリケーションに対応した多数のデータ型の集合が組み込まれています。
またユーザが独自のデータ型を定義することも可能です。
組み込みデータ型のほとんどにはわかりやすい名前と意味が付けれられているので、詳しい説明はここでは行わず、<xref linkend="datatype"/>で行います。
よく使用されるデータ型としては、整数を表す<type>integer</type>、小数も表すことができる<type>numeric</type>、文字列を表す<type>text</type>、日付を表す<type>date</type>、時刻を表す<type>time</type>、そして日付と時刻の両方を含む<type>timestamp</type>があります。
  </para>

  <indexterm>
<!--
   <primary>table</primary>
   <secondary>creating</secondary>
-->
   <primary>テーブル</primary>
   <secondary>の作成</secondary>
  </indexterm>

  <para>
<!--
   To create a table, you use the aptly named <xref
   linkend="sql-createtable"/> command.
   In this command you specify at least a name for the new table, the
   names of the columns and the data type of each column.  For
   example:
-->
テーブルを作成するには、その名の通り<xref linkend="sql-createtable"/>コマンドを使用します。
このコマンドで最低限指定する必要があるのは、新規テーブル名、列名、各列のデータ型です。
例を示します。
<programlisting>
CREATE TABLE my_first_table (
    first_column text,
    second_column integer
);
</programlisting>
<!--
   This creates a table named <literal>my_first_table</literal> with
   two columns.  The first column is named
   <literal>first_column</literal> and has a data type of
   <type>text</type>; the second column has the name
   <literal>second_column</literal> and the type <type>integer</type>.
   The table and column names follow the identifier syntax explained
   in <xref linkend="sql-syntax-identifiers"/>.  The type names are
   usually also identifiers, but there are some exceptions.  Note that the
   column list is comma-separated and surrounded by parentheses.
-->
これで2列からなる<literal>my_first_table</literal>という名前のテーブルが作成されます。
最初の列の名前は<literal>first_column</literal>で、そのデータ型は<type>text</type>です。
2番目の列の名前は<literal>second_column</literal>で、そのデータ型は<type>integer</type>です。
テーブル名および列名は、<xref linkend="sql-syntax-identifiers"/>で説明した識別子の構文に従います。
型名も通常は識別子ですが、例外もあります。
列リストはカンマで区切り、括弧で囲むことに注意してください。
  </para>

  <para>
<!--
   Of course, the previous example was heavily contrived.  Normally,
   you would give names to your tables and columns that convey what
   kind of data they store.  So let's look at a more realistic
   example:
-->
先ほどの例は、説明が目的であるため現実的ではありません。
通常、テーブルおよび列の名前は、どのようなデータが格納されているかわかるような名前にします。
以下に、より現実的な例を示します。
<programlisting>
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric
);
</programlisting>
<!--
   (The <type>numeric</type> type can store fractional components, as
   would be typical of monetary amounts.)
-->
（<type>numeric</type>型は小数を格納することができ、金額を扱う場合はこれが一般的です。）
  </para>

  <tip>
   <para>
<!--
    When you create many interrelated tables it is wise to choose a
    consistent naming pattern for the tables and columns.  For
    instance, there is a choice of using singular or plural nouns for
    table names, both of which are favored by some theorist or other.
-->
相関するテーブルを数多く作成する場合は、テーブルと列の命名規則を一貫させるのが賢明です。
例えば、テーブル名に単数形あるいは複数形どちらの名詞を使用するかという選択肢があります（これは論者によって好みが分かれています）。
   </para>
  </tip>

  <para>
<!--
   There is a limit on how many columns a table can contain.
   Depending on the column types, it is between 250 and 1600.
   However, defining a table with anywhere near this many columns is
   highly unusual and often a questionable design.
-->
テーブルに含めることができる列の数には制限があります。
制限は、列の型に応じて250〜1600の間となります。
しかし、これほど多くの列を使用することは稀ですし、そのような場合は設計に問題があることも多いのです。
  </para>

  <indexterm>
<!--
   <primary>table</primary>
   <secondary>removing</secondary>
-->
   <primary>テーブル</primary>
   <secondary>の削除</secondary>
  </indexterm>

  <para>
<!--
   If you no longer need a table, you can remove it using the <xref
   linkend="sql-droptable"/> command.
   For example:
-->
必要のないテーブルができた場合は、<xref linkend="sql-droptable"/>コマンドを使用してそのテーブルを削除できます。
例を示します。
<programlisting>
DROP TABLE my_first_table;
DROP TABLE products;
</programlisting>
<!--
   Attempting to drop a table that does not exist is an error.
   Nevertheless, it is common in SQL script files to unconditionally
   try to drop each table before creating it, ignoring any error
   messages, so that the script works whether or not the table exists.
   (If you like, you can use the <literal>DROP TABLE IF EXISTS</literal> variant
   to avoid the error messages, but this is not standard SQL.)
-->
存在しないテーブルを削除しようとすると、エラーになります。
もっともテーブルが存在するかどうか関係なくスクリプト全体を動作させることができるように、テーブルを作成する前に、エラーメッセージを無視して無条件に削除操作を行うことは、SQLスクリプトファイルではよく行われることです。
（この操作を行いたければ、エラーメッセージの出力を防ぐ<literal>DROP TABLE IF EXISTS</literal>という構文を使用することができます。
しかし、これは標準SQLではありません。）
  </para>

  <para>
<!--
   If you need to modify a table that already exists, see <xref
   linkend="ddl-alter"/> later in this chapter.
-->
既に存在するテーブルを変更する方法については、本章で後述する<xref linkend="ddl-alter"/>を参照してください。
  </para>

  <para>
<!--
   With the tools discussed so far you can create fully functional
   tables.  The remainder of this chapter is concerned with adding
   features to the table definition to ensure data integrity,
   security, or convenience.  If you are eager to fill your tables with
   data now you can skip ahead to <xref linkend="dml"/> and read the
   rest of this chapter later.
-->
これまでに説明したツールを使用して、十分に機能するテーブルを作成できます。
本章の残りでは、テーブル定義に機能を追加して、データの整合性、安全性、利便性を確実にする方法について述べていきます。
この時点でテーブルにデータを入力したければ、本章の残りを後回しにして<xref linkend="dml"/>に進んでも構いません。
  </para>
 </sect1>

 <sect1 id="ddl-default">
<!--
  <title>Default Values</title>
-->
  <title>デフォルト値</title>

  <indexterm zone="ddl-default">
<!--
   <primary>default value</primary>
-->
   <primary>デフォルト値</primary>
  </indexterm>

  <para>
<!--
   A column can be assigned a default value.  When a new row is
   created and no values are specified for some of the columns, those
   columns will be filled with their respective default values.  A
   data manipulation command can also request explicitly that a column
   be set to its default value, without having to know what that value is.
   (Details about data manipulation commands are in <xref linkend="dml"/>.)
-->
列にはデフォルトの値を割り当てることができます。
新しく作成された行のいくつかの列に値が指定されていない場合、そうした空欄にはそれぞれの列のデフォルト値が入ります。
データ操作コマンドを使用して、列を（どのような値かを把握する必要なく）デフォルト値に設定するように明示的に要求することもできます。
（データ操作コマンドの詳細については<xref linkend="dml"/>を参照してください。）
  </para>

  <para>
<!--
   <indexterm><primary>null value</primary><secondary>default value</secondary></indexterm>
   If no default value is declared explicitly, the default value is the
   null value.  This usually makes sense because a null value can
   be considered to represent unknown data.
-->
   <indexterm><primary>NULL値</primary><secondary>デフォルト値</secondary></indexterm>
明示的に宣言されたデフォルト値がない場合は、デフォルト値はNULL値になります。
NULL値は不明のデータを表すものとみなすことができるので、通常はこの方法で問題ありません。
  </para>

  <para>
<!--
   In a table definition, default values are listed after the column
   data type.  For example:
-->
テーブル定義では、デフォルト値は列データ型の後に列挙されています。
例を示します。
<programlisting>
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric <emphasis>DEFAULT 9.99</emphasis>
);
</programlisting>
  </para>

  <para>
<!--
   The default value can be an expression, which will be
   evaluated whenever the default value is inserted
   (<emphasis>not</emphasis> when the table is created).  A common example
   is for a <type>timestamp</type> column to have a default of <literal>CURRENT_TIMESTAMP</literal>,
   so that it gets set to the time of row insertion.  Another common
   example is generating a <quote>serial number</quote> for each row.
   In <productname>PostgreSQL</productname> this is typically done by
   something like:
-->
デフォルト値を式にすることが可能で、それはデフォルト値が挿入される時はいつでも（テーブルが作成されたときでは<emphasis>ありません</emphasis>）評価されます。よくある例として、<type>timestamp</type>列が挿入時の時刻に設定されるように、その列はデフォルトの<literal>CURRENT_TIMESTAMP</literal>を持つことができます。もう1つの例としては、各行に<quote>通番</quote>を割り振る場合です。
<productname>PostgreSQL</productname>では、典型的に以下のように記述することにより生成されます。
<programlisting>
CREATE TABLE products (
    product_no integer <emphasis>DEFAULT nextval('products_product_no_seq')</emphasis>,
    ...
);
</programlisting>
<!--
   where the <literal>nextval()</literal> function supplies successive values
   from a <firstterm>sequence object</firstterm> (see <xref
   linkend="functions-sequence"/>). This arrangement is sufficiently common
   that there's a special shorthand for it:
-->
ここで、<literal>nextval()</literal>関数が、<firstterm>シーケンスオブジェクト</firstterm>から連続した値を生成します（<xref linkend="functions-sequence"/>を参照してください）。
これは非常によく使われるやり方なので、以下のような特別な短縮記法が用意されています。
<programlisting>
CREATE TABLE products (
    product_no <emphasis>SERIAL</emphasis>,
    ...
);
</programlisting>
<!--
   The <literal>SERIAL</literal> shorthand is discussed further in <xref
   linkend="datatype-serial"/>.
-->
省略形である<literal>SERIAL</literal>は<xref linkend="datatype-serial"/>で詳しく述べられています。
  </para>
 </sect1>

 <sect1 id="ddl-generated-columns">
<!--
  <title>Generated Columns</title>
-->
  <title>生成列</title>

  <indexterm zone="ddl-generated-columns">
   <primary>generated column</primary>
  </indexterm>

  <para>
<!--
   A generated column is a special column that is always computed from other
   columns.  Thus, it is for columns what a view is for tables.  There are two
   kinds of generated columns: stored and virtual.  A stored generated column
   is computed when it is written (inserted or updated) and occupies storage
   as if it were a normal column.  A virtual generated column occupies no
   storage and is computed when it is read.  Thus, a virtual generated column
   is similar to a view and a stored generated column is similar to a
   materialized view (except that it is always updated automatically).
   PostgreSQL currently implements only stored generated columns.
-->
生成列は常に他の列から計算される特別な列です。
ですから、これは列におけるテーブルに対するビューのようなものです。
生成列には格納と仮想の2種類があります。
格納生成列はそれが書かれた（挿入または更新）時に計算され、あたかも通常の列のようにストレージが割当てられます。
仮想列にはストレージは割り当てられず、列が読み出された時に計算されます。
つまり、仮想生成列はビューに似ており、格納生成列はマテリアライズドビューに似ています。（常に自動的に更新される点は除きます。）
今の所PostgreSQLは格納生成列のみを実装しています。
  </para>

  <para>
<!--
   To create a generated column, use the <literal>GENERATED ALWAYS
   AS</literal> clause in <command>CREATE TABLE</command>, for example:
-->
生成列を作るには、<command>CREATE TABLE</command>で<literal>GENERATED ALWAYS AS</literal>節を使ってください。例を示します。
<programlisting>
CREATE TABLE people (
    ...,
    height_cm numeric,
    height_in numeric <emphasis>GENERATED ALWAYS AS (height_cm / 2.54) STORED</emphasis>
);
</programlisting>
<!--
   The keyword <literal>STORED</literal> must be specified to choose the
   stored kind of generated column.  See <xref linkend="sql-createtable"/> for
   more details.
-->
種類を格納生成列として選択するためにキーワード<literal>STORED</literal>を選択する必要があります。
より詳しくは<xref linkend="sql-createtable"/>をご覧ください。
  </para>

  <para>
<!--
   A generated column cannot be written to directly.  In
   <command>INSERT</command> or <command>UPDATE</command> commands, a value
   cannot be specified for a generated column, but the keyword
   <literal>DEFAULT</literal> may be specified.
-->
生成列には直接書き込みができません。
<command>INSERT</command>あるいは<command>UPDATE</command>コマンドでは値を生成列には指定できませんが、キーワード<literal>DEFAULT</literal>が指定できます。
  </para>

  <para>
<!--
   Consider the differences between a column with a default and a generated
   column.  The column default is evaluated once when the row is first
   inserted if no other value was provided; a generated column is updated
   whenever the row changes and cannot be overridden.  A column default may
   not refer to other columns of the table; a generation expression would
   normally do so.  A column default can use volatile functions, for example
   <literal>random()</literal> or functions referring to the current time;
   this is not allowed for generated columns.
-->
デフォルトを備えた列と生成列の違いを考えてみましょう。
列のデフォルトは、他に値が指定されないときに、最初に行が挿入された時に一度だけ評価されます。
生成列は、行が変更された時に常に更新され、上書きはできません。
デフォルトを備えた列はテーブルの他の列を参照することはできませんが、生成式は通常それを行います。
デフォルトを備えた列は揮発性の関数、たとえば<literal>random()</literal>や現在時刻を参照する関数を使用できますが、これは生成列では許されていません。
  </para>

  <para>
<!--
   Several restrictions apply to the definition of generated columns and
   tables involving generated columns:
-->
生成列の定義と生成列を伴うテーブルには以下の制限が適用されます。

   <itemizedlist>
    <listitem>
     <para>
<!--
      The generation expression can only use immutable functions and cannot
      use subqueries or reference anything other than the current row in any
      way.
-->
生成式は不変関数のみが使用でき、副問合せ、あるいは現在の行以外へのいかなる参照も使用できません。
     </para>
    </listitem>
    <listitem>
     <para>
<!--
      A generation expression cannot reference another generated column.
-->
生成式はほかの生成列を参照できません。
     </para>
    </listitem>
    <listitem>
     <para>
<!--
      A generation expression cannot reference a system column, except
      <varname>tableoid</varname>.
-->
生成式は<varname>tableoid</varname>以外のシステム列を参照できません。
     </para>
    </listitem>
    <listitem>
     <para>
<!--
      A generated column cannot have a column default or an identity definition.
-->
生成列は列デフォルトも識別定義も持てません。
     </para>
    </listitem>
    <listitem>
     <para>
<!--
      A generated column cannot be part of a partition key.
-->
生成列はパーティションキーの一部にはなれません。
     </para>
    </listitem>
    <listitem>
     <para>
<!--
      Foreign tables can have generated columns.  See <xref
      linkend="sql-createforeigntable"/> for details.
-->
外部テーブルは生成列を持つことができます。
詳細は<xref linkend="sql-createforeigntable"/>をご覧ください。
     </para>
    </listitem>
    <listitem>
<!--
     <para>For inheritance:</para>
-->
     <para>継承の場合：</para>
     <itemizedlist>
      <listitem>
       <para>
        If a parent column is a generated column, a child column must also be
        a generated column using the same expression.  In the definition of
        the child column, leave off the <literal>GENERATED</literal> clause,
        as it will be copied from the parent.
-->
親列が生成列なら、子列もまた同じ式を用いた生成列でなければなりません。
子列の定義では<literal>GENERATED</literal>節は親列からコピーされるので、指定しないでください。
       </para>
      </listitem>
      <listitem>
       <para>
<!--
        In case of multiple inheritance, if one parent column is a generated
        column, then all parent columns must be generated columns and with the
        same expression.
-->
多重継承では、一つの親列が生成列なら、すべての親列は同じ式による生成列でなければなりません。
       </para>
      </listitem>
      <listitem>
       <para>
<!--
        If a parent column is not a generated column, a child column may be
        defined to be a generated column or not.
-->
親列が生成列でなければ、子列は生成列として定義されるかもしれませんし、されないかもしれません。
       </para>
      </listitem>
     </itemizedlist>
    </listitem>
   </itemizedlist>
  </para>

  <para>
<!--
   Additional considerations apply to the use of generated columns.
-->
生成列の利用の際には以下の追加の考慮が必要です。
   <itemizedlist>
    <listitem>
     <para>
<!--
      Generated columns maintain access privileges separately from their
      underlying base columns.  So, it is possible to arrange it so that a
      particular role can read from a generated column but not from the
      underlying base columns.
-->
生成列は元になる基底列とは別にアクセス権限を維持します。
ですから、ある特定のロールが生成列を読み出しつつも、元になる基底列からは読み出さないように調整することが可能です。
     </para>
    </listitem>
    <listitem>
     <para>
<!--
      Generated columns are, conceptually, updated after
      <literal>BEFORE</literal> triggers have run.  Therefore, changes made to
      base columns in a <literal>BEFORE</literal> trigger will be reflected in
      generated columns.  But conversely, it is not allowed to access
      generated columns in <literal>BEFORE</literal> triggers.
-->
概念的には、生成列は<literal>BEFORE</literal>トリガが走った後に更新されます。
ですから、<literal>BEFORE</literal>トリガの中で基底列に加えられた変更は生成列に反映されます。
しかし逆に生成列を<literal>BEFORE</literal>トリガの中でアクセスすることは許されません。
     </para>
    </listitem>
   </itemizedlist>
  </para>
 </sect1>

 <sect1 id="ddl-constraints">
<!--
  <title>Constraints</title>
-->
  <title>制約</title>

  <indexterm zone="ddl-constraints">
<!--
   <primary>constraint</primary>
-->
   <primary>制約</primary>
  </indexterm>

  <para>
<!--
   Data types are a way to limit the kind of data that can be stored
   in a table.  For many applications, however, the constraint they
   provide is too coarse.  For example, a column containing a product
   price should probably only accept positive values.  But there is no
   standard data type that accepts only positive numbers.  Another issue is
   that you might want to constrain column data with respect to other
   columns or rows.  For example, in a table containing product
   information, there should be only one row for each product number.
-->
データ型は、テーブルに格納するデータの種類を限定するための方法です。
しかし、多くのアプリケーションでは、型が提供する制約では精密さに欠けます。
例えば、製品の価格が入る列には、おそらく正数のみを受け入れるようにする必要があります。
しかし、正数のみを受け入れるという標準のデータ型はありません。
また、他の列や行に関連して列データを制約したい場合もあります。
例えば、製品の情報が入っているテーブルでは、1つの製品番号についての行が2行以上あってはなりません。
  </para>

  <para>
<!--
   To that end, SQL allows you to define constraints on columns and
   tables.  Constraints give you as much control over the data in your
   tables as you wish.  If a user attempts to store data in a column
   that would violate a constraint, an error is raised.  This applies
   even if the value came from the default value definition.
-->
このような問題を解決するため、SQLでは列およびテーブルに対する制約を定義することができます。
制約によってテーブル内のデータを自由に制御することができます。
制約に違反するデータを列に格納しようとすると、エラーとなります。
このことは、デフォルト値として定義された値を格納する場合にも適用されます。
  </para>

  <sect2 id="ddl-constraints-check-constraints">
<!--
   <title>Check Constraints</title>
-->
   <title>検査制約</title>

   <indexterm>
<!--
    <primary>check constraint</primary>
-->
    <primary>検査制約</primary>
   </indexterm>

   <indexterm>
<!--
    <primary>constraint</primary>
    <secondary>check</secondary>
-->
    <primary>制約</primary>
    <secondary>検査</secondary>
   </indexterm>

   <para>
<!--
    A check constraint is the most generic constraint type.  It allows
    you to specify that the value in a certain column must satisfy a
    Boolean (truth-value) expression.  For instance, to require positive
    product prices, you could use:
-->
検査制約は最も汎用的な制約の種類です。
これを使用して、特定の列の値が論理値の式を満たす（真の値）ように指定できます。
例えば、製品価格を必ず正数にするには以下のようにします。
<programlisting>
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric <emphasis>CHECK (price &gt; 0)</emphasis>
);
</programlisting>
   </para>

   <para>
<!--
    As you see, the constraint definition comes after the data type,
    just like default value definitions.  Default values and
    constraints can be listed in any order.  A check constraint
    consists of the key word <literal>CHECK</literal> followed by an
    expression in parentheses.  The check constraint expression should
    involve the column thus constrained, otherwise the constraint
    would not make too much sense.
-->
このように、制約の定義はデフォルト値の定義と同様に、データ型の後にきます。
デフォルト値と制約は任意の順序で列挙できます。
検査制約は<literal>CHECK</literal>キーワードの後に続く括弧で囲まれた式で構成されます。
検査制約式には、制約される列を含む必要があります。
そうしないと、制約はあまり意味のないものになります。
   </para>

   <indexterm>
<!--
    <primary>constraint</primary>
    <secondary>name</secondary>
-->
    <primary>制約</primary>
    <secondary>の名前</secondary>
   </indexterm>

   <para>
<!--
    You can also give the constraint a separate name.  This clarifies
    error messages and allows you to refer to the constraint when you
    need to change it.  The syntax is:
-->
制約に個別に名前を付けることもできます。
名前を付けることで、エラーメッセージがわかりやすくなりますし、変更したい制約を参照できるようになります。
構文は以下の通りです。
<programlisting>
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric <emphasis>CONSTRAINT positive_price</emphasis> CHECK (price &gt; 0)
);
</programlisting>
<!--
    So, to specify a named constraint, use the key word
    <literal>CONSTRAINT</literal> followed by an identifier followed
    by the constraint definition.  (If you don't specify a constraint
    name in this way, the system chooses a name for you.)
-->
上記のように、名前付き制約の指定は<literal>CONSTRAINT</literal>キーワードで始め、これに識別子、制約定義と続きます。
（この方法で制約名を指定しない場合は、システムにより名前が付けられます。）
   </para>

   <para>
<!--
    A check constraint can also refer to several columns.  Say you
    store a regular price and a discounted price, and you want to
    ensure that the discounted price is lower than the regular price:
-->
検査制約では複数の列を参照することもできます。
例えば、通常価格と割引価格を格納する場合に、必ず割引価格が通常価格よりも低くなるようにしたいとします。
<programlisting>
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric CHECK (price &gt; 0),
    discounted_price numeric CHECK (discounted_price &gt; 0),
    <emphasis>CHECK (price &gt; discounted_price)</emphasis>
);
</programlisting>
   </para>

   <para>
<!--
    The first two constraints should look familiar.  The third one
    uses a new syntax.  It is not attached to a particular column,
    instead it appears as a separate item in the comma-separated
    column list.  Column definitions and these constraint
    definitions can be listed in mixed order.
-->
最初の2つの制約は上で説明した通りです。
3つ目の制約では新しい構文を使っています。
これは特定の列に付加されるのではなく、カンマで区切られた列リスト内の別個の項目として現れます。
列定義およびこれらの制約定義は、任意の順序で列挙することができます。
   </para>

   <para>
<!--
    We say that the first two constraints are column constraints, whereas the
    third one is a table constraint because it is written separately
    from any one column definition.  Column constraints can also be
    written as table constraints, while the reverse is not necessarily
    possible, since a column constraint is supposed to refer to only the
    column it is attached to.  (<productname>PostgreSQL</productname> doesn't
    enforce that rule, but you should follow it if you want your table
    definitions to work with other database systems.)  The above example could
    also be written as:
-->
最初の2つの制約を列制約と言います。これに対し、3つ目の制約は列定義とは別個に書かれるので、テーブル制約と言います。
列制約をテーブル制約として書くことはできますが、その逆はできる場合とできない場合があります。なぜなら列制約は、制約に関連付けられている列のみを参照するためです。
（<productname>PostgreSQL</productname>はこの規則を強制しません。しかし、作成したテーブル定義を他のデータベースシステムでも動作させたい場合はこの規則に従ってください。）
上の例は、以下のように書くこともできます。
<programlisting>
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric,
    CHECK (price &gt; 0),
    discounted_price numeric,
    CHECK (discounted_price &gt; 0),
    CHECK (price &gt; discounted_price)
);
</programlisting>
<!--
    or even:
-->
あるいは、次のようにもできます。
<programlisting>
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric CHECK (price &gt; 0),
    discounted_price numeric,
    CHECK (discounted_price &gt; 0 AND price &gt; discounted_price)
);
</programlisting>
<!--
    It's a matter of taste.
-->
どのようにするかは好みの問題です。
   </para>

   <para>
<!--
    Names can be assigned to table constraints in the same way as
    column constraints:
-->
列制約と同様に、テーブル制約に名前を割り当てることができます。
<programlisting>
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric,
    CHECK (price &gt; 0),
    discounted_price numeric,
    CHECK (discounted_price &gt; 0),
    <emphasis>CONSTRAINT valid_discount</emphasis> CHECK (price &gt; discounted_price)
);
</programlisting>
   </para>

   <indexterm>
<!--
    <primary>null value</primary>
    <secondary sortas="check constraints">with check constraints</secondary>
-->
    <primary>NULL値</primary>
    <secondary sortas="check constraints">検査制約</secondary>
   </indexterm>

   <para>
<!--
    It should be noted that a check constraint is satisfied if the
    check expression evaluates to true or the null value.  Since most
    expressions will evaluate to the null value if any operand is null,
    they will not prevent null values in the constrained columns.  To
    ensure that a column does not contain null values, the not-null
    constraint described in the next section can be used.
-->
検査制約では、検査式が真またはNULL値と評価された場合に、条件が満たされることに注意して下さい。
ほとんどの式は、演算項目に一つでもNULLがあればNULLと評価されるので、検査制約では制約対象の列にNULL値が入るのを防げません。
列がNULL値を含まないようにするために、次節で説明する非NULL制約を使用することができます。
   </para>

   <note>
    <para>
<!--
     <productname>PostgreSQL</productname> does not support
     <literal>CHECK</literal> constraints that reference table data other than
     the new or updated row being checked.  While a <literal>CHECK</literal>
     constraint that violates this rule may appear to work in simple
     tests, it cannot guarantee that the database will not reach a state
     in which the constraint condition is false (due to subsequent changes
     of the other row(s) involved).  This would cause a database dump and
     reload to fail.  The reload could fail even when the complete
     database state is consistent with the constraint, due to rows not
     being loaded in an order that will satisfy the constraint.  If
     possible, use <literal>UNIQUE</literal>, <literal>EXCLUDE</literal>,
     or <literal>FOREIGN KEY</literal> constraints to express
     cross-row and cross-table restrictions.
-->
<productname>PostgreSQL</productname>は、検査対象の新しい行もしくは更新対象行以外のテーブルデータを参照する<literal>CHECK</literal>制約はサポートしていません。
このルールに違反する<literal>CHECK</literal>制約は単純なテストでは動いたように見えますが、（関連する他の行が後で更新されたことにより）データベースがその制約条件が偽になるような状態にならないことを保証できません。
これによってデータベースのダンプと再ロードの失敗が引き起こされるでしょう。
最終的なデータベース状態が制約に対して一貫した状態であったとしても、制約を満たす順で行がロードされないことにより再ロードは失敗することがあります。
可能ならば<literal>UNIQUE</literal>、<literal>EXCLUDE</literal>、<literal>FOREIGN KEY</literal>制約を使って行あるいはテーブルをまたがる制約を表現してください。
    </para>

    <para>
<!--
     If what you desire is a one-time check against other rows at row
     insertion, rather than a continuously-maintained consistency
     guarantee, a custom <link linkend="triggers">trigger</link> can be used
     to implement that.  (This approach avoids the dump/reload problem because
     <application>pg_dump</application> does not reinstall triggers until after
     reloading data, so that the check will not be enforced during a
     dump/reload.)
-->
常に一貫性の保障を維持するのではなく、行挿入の際に一回だけの行の検査が必要なら、その実装のためにカスタム<link linkend="triggers">トリガ</link>が利用できます。
（<application>pg_dump</application>はデータの再ロード後までトリガを再インストールせず、ダンプ/再ロード中は検査が強制されないため、この方法でダンプ/再ロード問題を回避できます。）
    </para>
   </note>

   <note>
    <para>
<!--
     <productname>PostgreSQL</productname> assumes that
     <literal>CHECK</literal> constraints' conditions are immutable, that
     is, they will always give the same result for the same input row.
     This assumption is what justifies examining <literal>CHECK</literal>
     constraints only when rows are inserted or updated, and not at other
     times.  (The warning above about not referencing other table data is
     really a special case of this restriction.)
-->
<productname>PostgreSQL</productname>は<literal>CHECK</literal>制約の条件は不変であると仮定します。
つまり同じ入力行に対して常に同じ結果が返るということです。
この仮定により<literal>CHECK</literal>制約が挿入あるいは更新時にのみ検査され、他のときには検査されないことが正当化されます。
（他のテーブルデータを参照しないことによる上述の警告はこの制限の本当に特別な場合です。）
    </para>

    <para>
<!--
     An example of a common way to break this assumption is to reference a
     user-defined function in a <literal>CHECK</literal> expression, and
     then change the behavior of that
     function.  <productname>PostgreSQL</productname> does not disallow
     that, but it will not notice if there are rows in the table that now
     violate the <literal>CHECK</literal> constraint. That would cause a
     subsequent database dump and reload to fail.
     The recommended way to handle such a change is to drop the constraint
     (using <command>ALTER TABLE</command>), adjust the function definition,
     and re-add the constraint, thereby rechecking it against all table rows.
-->
この仮定に反する一般的な例は、<literal>CHECK</literal>式でユーザ定義関数を参照し、その関数の振る舞いを変更することです。
<productname>PostgreSQL</productname>はこれを禁止はしませんが、今や<literal>CHECK</literal>制約に違反する行がテーブル中に存在することを通知しません。
これによって後でデータベースのダンプと再ロードの失敗を引き起こすでしょう。
そのような変更に対処するおすすめの方法は、（<command>ALTER TABLE</command>を使って）制約を削除し、関数定義を調整し、そして制約を再度追加して、それによってテーブル全体の行に対して再チェックを行うことです。
    </para>
   </note>
  </sect2>

  <sect2>
<!--
   <title>Not-Null Constraints</title>
-->
   <title>非NULL制約</title>

   <indexterm>
<!--
    <primary>not-null constraint</primary>
-->
    <primary>非NULL制約</primary>
   </indexterm>

   <indexterm>
<!--
    <primary>constraint</primary>
    <secondary>NOT NULL</secondary>
-->
    <primary>制約</primary>
    <secondary>非NULL</secondary>
   </indexterm>

   <para>
<!--
    A not-null constraint simply specifies that a column must not
    assume the null value.  A syntax example:
-->
非NULL制約は単純に、列がNULL値を取らないことを指定します。
構文の例は以下の通りです。
<programlisting>
CREATE TABLE products (
    product_no integer <emphasis>NOT NULL</emphasis>,
    name text <emphasis>NOT NULL</emphasis>,
    price numeric
);
</programlisting>
   </para>

   <para>
<!--
    A not-null constraint is always written as a column constraint.  A
    not-null constraint is functionally equivalent to creating a check
    constraint <literal>CHECK (<replaceable>column_name</replaceable>
    IS NOT NULL)</literal>, but in
    <productname>PostgreSQL</productname> creating an explicit
    not-null constraint is more efficient.  The drawback is that you
    cannot give explicit names to not-null constraints created this
    way.
-->
非NULL制約は常に列制約として記述されます。
非NULL制約は<literal>CHECK (<replaceable>column_name</replaceable> IS NOT NULL)</literal>という検査制約と機能的には同等ですが、<productname>PostgreSQL</productname>では、明示的に非NULL制約を作成する方がより効果的です。
このように作成された非NULL制約に明示的な名前を付けられないのが欠点です。
   </para>

   <para>
<!--
    Of course, a column can have more than one constraint.  Just write
    the constraints one after another:
-->
もちろん、1つの列に複数の制約を適用することもできます。
そのためには、次々と制約を書いていくだけです。
<programlisting>
CREATE TABLE products (
    product_no integer NOT NULL,
    name text NOT NULL,
    price numeric NOT NULL CHECK (price &gt; 0)
);
</programlisting>
<!--
    The order doesn't matter.  It does not necessarily determine in which
    order the constraints are checked.
-->
順序は関係ありません。
書かれた順序と検査される順序は必ずしも同じではありません。
   </para>

   <para>
<!--
    The <literal>NOT NULL</literal> constraint has an inverse: the
    <literal>NULL</literal> constraint.  This does not mean that the
    column must be null, which would surely be useless.  Instead, this
    simply selects the default behavior that the column might be null.
    The <literal>NULL</literal> constraint is not present in the SQL
    standard and should not be used in portable applications.  (It was
    only added to <productname>PostgreSQL</productname> to be
    compatible with some other database systems.)  Some users, however,
    like it because it makes it easy to toggle the constraint in a
    script file.  For example, you could start with:
-->
<literal>NOT NULL</literal>制約に対し、逆のパターンである<literal>NULL</literal>制約があります。
これは、列がNULLでなければならないということではありません。
そのような制約は意味がありません。
この制約は、列がNULLであってもよいというデフォルトの振舞いを選択するだけのものです。
<literal>NULL</literal>制約は標準SQLには存在しませんので、移植予定のアプリケーションでは使用すべきではありません。
（これは、<productname>PostgreSQL</productname>と他の一部のデータベースシステムとの互換性のために追加された機能に過ぎません。）
もっとも、スクリプトファイルでの制約の切り替えが簡単であるという理由でこの機能を歓迎するユーザもいます。
例えば、最初に
<programlisting>
CREATE TABLE products (
    product_no integer NULL,
    name text NULL,
    price numeric NULL
);
</programlisting>
<!--
    and then insert the <literal>NOT</literal> key word where desired.
-->
と書いてから、必要な場所に<literal>NOT</literal>キーワードを挿入することができます。
   </para>

   <tip>
    <para>
<!--
     In most database designs the majority of columns should be marked
     not null.
-->
ほとんどのデータベース設計において、列の多くをNOT NULLとマークする必要があります。
    </para>
   </tip>
  </sect2>

  <sect2 id="ddl-constraints-unique-constraints">
<!--
   <title>Unique Constraints</title>
-->
   <title>一意性制約</title>

   <indexterm>
<!--
    <primary>unique constraint</primary>
-->
    <primary>一意性制約</primary>
   </indexterm>

   <indexterm>
<!--
    <primary>constraint</primary>
    <secondary>unique</secondary>
-->
    <primary>制約</primary>
    <secondary>一意性</secondary>
   </indexterm>

   <para>
<!--
    Unique constraints ensure that the data contained in a column, or a
    group of columns, is unique among all the rows in the
    table.  The syntax is:
-->
一意性制約によって、列あるいは列のグループに含まれるデータが、テーブル内の全ての行で一意であることを確実にします。
列制約の場合の構文は以下の通りです。
<programlisting>
CREATE TABLE products (
    product_no integer <emphasis>UNIQUE</emphasis>,
    name text,
    price numeric
);
</programlisting>
<!--
    when written as a column constraint, and:
-->
また、テーブル制約の場合の構文は
<programlisting>
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric,
    <emphasis>UNIQUE (product_no)</emphasis>
);
</programlisting>
<!--
    when written as a table constraint.
-->
となります。
   </para>

   <para>
<!--
    To define a unique constraint for a group of columns, write it as a
    table constraint with the column names separated by commas:
-->
列の集合に対して一意性制約を定義するには、列名をカンマで区切り、表制約として記述します。
<programlisting>
CREATE TABLE example (
    a integer,
    b integer,
    c integer,
    <emphasis>UNIQUE (a, c)</emphasis>
);
</programlisting>
<!--
    This specifies that the combination of values in the indicated columns
    is unique across the whole table, though any one of the columns
    need not be (and ordinarily isn't) unique.
-->
これは、指定された列の値の組み合わせがテーブル全体で一意であることを指定しています。
しかし、列の片方が一意である必要はありません（通常一意ではありません）。
   </para>

   <para>
<!--
    You can assign your own name for a unique constraint, in the usual way:
-->
一意性制約には、通常の方法で名前を割り当てることもできます。
<programlisting>
CREATE TABLE products (
    product_no integer <emphasis>CONSTRAINT must_be_different</emphasis> UNIQUE,
    name text,
    price numeric
);
</programlisting>
   </para>

   <para>
<!--
    Adding a unique constraint will automatically create a unique B-tree
    index on the column or group of columns listed in the constraint.
    A uniqueness restriction covering only some rows cannot be written as
    a unique constraint, but it is possible to enforce such a restriction by
    creating a unique <link linkend="indexes-partial">partial index</link>.
-->
一意性制約を追加すると、制約で指定された列または列のグループに対して一意的なBツリーのインデックスが自動的に作られます。
一部の行だけに適用される一意性の制限を一意性制約として作成することはできませんが、そのような制限を一意な<link linkend="indexes-partial">部分インデックス</link>を作成することで実現することは可能です。
   </para>

   <indexterm>
<!--
    <primary>null value</primary>
    <secondary sortas="unique constraints">with unique constraints</secondary>
-->
    <primary>NULL値</primary>
    <secondary sortas="unique constraints">一意性制約</secondary>
   </indexterm>

   <para>
<!--
    In general, a unique constraint is violated if there is more than
    one row in the table where the values of all of the
    columns included in the constraint are equal.
    However, two null values are never considered equal in this
    comparison.  That means even in the presence of a
    unique constraint it is possible to store duplicate
    rows that contain a null value in at least one of the constrained
    columns.  This behavior conforms to the SQL standard, but we have
    heard that other SQL databases might not follow this rule.  So be
    careful when developing applications that are intended to be
    portable.
-->
一般に、制約の対象となるすべての列について同じ値を持つ行が、テーブル内に２行以上ある場合は、一意性制約違反になります。
しかし、この比較では2つのNULL値は決して等価とはみなされません。
つまり、一意性制約があったとしても、制約対象の列の少なくとも1つにNULL値を持つ行を複数格納することができるということです。
この振舞いは標準SQLに準拠していますが、この規則に従わないSQLデータベースがあることを聞いたことがあります。
ですから、移植する予定のアプリケーションを開発する際には注意してください。
   </para>
  </sect2>

  <sect2 id="ddl-constraints-primary-keys">
<!--
   <title>Primary Keys</title>
-->
   <title>主キー</title>

   <indexterm>
<!--
    <primary>primary key</primary>
-->
    <primary>主キー</primary>
   </indexterm>

   <indexterm>
<!--
    <primary>constraint</primary>
    <secondary>primary key</secondary>
-->
    <primary>制約</primary>
    <secondary>主キー</secondary>
   </indexterm>

   <para>
<!--
    A primary key constraint indicates that a column, or group of columns,
    can be used as a unique identifier for rows in the table.  This
    requires that the values be both unique and not null.  So, the following
    two table definitions accept the same data:
-->
主キー制約は、列または列のグループがテーブル内の行を一意に識別するものとして利用できることを意味します。
これには値が一意で、かつNULLでないことが必要となります。
つまり、次の2つのテーブル定義は同じデータを受け入れます。
<programlisting>
CREATE TABLE products (
    product_no integer UNIQUE NOT NULL,
    name text,
    price numeric
);
</programlisting>

<programlisting>
CREATE TABLE products (
    product_no integer <emphasis>PRIMARY KEY</emphasis>,
    name text,
    price numeric
);
</programlisting>
   </para>

   <para>
<!--
    Primary keys can span more than one column; the syntax
    is similar to unique constraints:
-->
主キーも複数の列に渡ることがあり、その構文は一意性制約に似ています。
<programlisting>
CREATE TABLE example (
    a integer,
    b integer,
    c integer,
    <emphasis>PRIMARY KEY (a, c)</emphasis>
);
</programlisting>
   </para>

   <para>
<!--
    Adding a primary key will automatically create a unique B-tree index
    on the column or group of columns listed in the primary key, and will
    force the column(s) to be marked <literal>NOT NULL</literal>.
-->
主キーを追加すると、主キーで指定された列または列のグループに対して一意的なBツリーのインデックスが自動的に作られます。
また、その列について<literal>NOT NULL</literal>の印が強制されます。
   </para>

   <para>
<!--
    A table can have at most one primary key.  (There can be any number
    of unique and not-null constraints, which are functionally almost the
    same thing, but only one can be identified as the primary key.)
    Relational database theory
    dictates that every table must have a primary key.  This rule is
    not enforced by <productname>PostgreSQL</productname>, but it is
    usually best to follow it.
-->
1つのテーブルは最大1つの主キーを持つことができます。
（一意性制約および非NULL制約には個数の制限はありません。
機能的にはほとんど同じものですが、主キーとして識別される制約は1つのみです。）
リレーショナルデータベース理論では、全てのテーブルに主キーが1つ必要とされています。
この規則は<productname>PostgreSQL</productname>では強制されませんが、たいていの場合はこれに従うことが推奨されます。
   </para>

   <para>
<!--
    Primary keys are useful both for
    documentation purposes and for client applications.  For example,
    a GUI application that allows modifying row values probably needs
    to know the primary key of a table to be able to identify rows
    uniquely.  There are also various ways in which the database system
    makes use of a primary key if one has been declared; for example,
    the primary key defines the default target column(s) for foreign keys
    referencing its table.
-->
主キーは文書化、および、クライアントアプリケーションの両方の面で役に立ちます。
例えば、行値の変更が可能なGUIアプリケーションが行を一意的に特定するためには、
おそらくテーブルの主キーを知る必要があります。
他にも主キーが宣言されているときにデータベースシステムがそれを利用する場面がいくつかあります。
例えば、外部キーがそのテーブルを参照するとき、主キーがデフォルトの対象列となります。
   </para>

  </sect2>

  <sect2 id="ddl-constraints-fk">
<!--
   <title>Foreign Keys</title>
-->
   <title>外部キー</title>

   <indexterm>
<!--
    <primary>foreign key</primary>
-->
    <primary>外部キー</primary>
   </indexterm>

   <indexterm>
<!--
    <primary>constraint</primary>
    <secondary>foreign key</secondary>
-->
    <primary>制約</primary>
    <secondary>外部キー</secondary>
   </indexterm>

   <indexterm>
<!--
    <primary>referential integrity</primary>
-->
    <primary>参照整合性</primary>
   </indexterm>

   <para>
<!--
    A foreign key constraint specifies that the values in a column (or
    a group of columns) must match the values appearing in some row
    of another table.
    We say this maintains the <firstterm>referential
    integrity</firstterm> between two related tables.
-->
外部キー制約は、列（または列のグループ）の値が、他のテーブルの行の値と一致しなければならないことを指定します。
これによって関連する2つのテーブルの<firstterm>参照整合性</firstterm>が維持されます。
   </para>

   <para>
<!--
    Say you have the product table that we have used several times already:
-->
これでまで何度か例に使用したproductsテーブルについて考えてみます。
<programlisting>
CREATE TABLE products (
    product_no integer PRIMARY KEY,
    name text,
    price numeric
);
</programlisting>
<!--
    Let's also assume you have a table storing orders of those
    products.  We want to ensure that the orders table only contains
    orders of products that actually exist.  So we define a foreign
    key constraint in the orders table that references the products
    table:
-->
また、これらの製品に対する注文を格納するテーブルも作成済みだとしましょう。
この注文のordersテーブルには実際に存在する製品の注文のみを格納したいと思っています。
そこで、productsテーブルを参照するordersテーブルに外部キー制約を定義します。
<programlisting>
CREATE TABLE orders (
    order_id integer PRIMARY KEY,
    product_no integer <emphasis>REFERENCES products (product_no)</emphasis>,
    quantity integer
);
</programlisting>
<!--
    Now it is impossible to create orders with non-NULL
    <structfield>product_no</structfield> entries that do not appear in the
    products table.
-->
これで、productsテーブルに存在しない非NULLの<structfield>product_no</structfield>項目を使用して注文を作成することはできなくなります。
   </para>

   <para>
<!--
    We say that in this situation the orders table is the
    <firstterm>referencing</firstterm> table and the products table is
    the <firstterm>referenced</firstterm> table.  Similarly, there are
    referencing and referenced columns.
-->
このような場合に、ordersテーブルのことを<firstterm>参照</firstterm>テーブル、productテーブルのことを<firstterm>被参照</firstterm>テーブルと呼びます。
同様に、参照列と被参照列もあります。
   </para>

   <para>
<!--
    You can also shorten the above command to:
-->
上記のコマンドは、次のように短縮することもできます。
<programlisting>
CREATE TABLE orders (
    order_id integer PRIMARY KEY,
    product_no integer <emphasis>REFERENCES products</emphasis>,
    quantity integer
);
</programlisting>
<!--
    because in absence of a column list the primary key of the
    referenced table is used as the referenced column(s).
-->
列リストがないため、被参照テーブルの主キーが被参照列として使用されます。
   </para>

   <para>
<!--
    A foreign key can also constrain and reference a group of columns.
    As usual, it then needs to be written in table constraint form.
    Here is a contrived syntax example:
-->
外部キーでも、列のグループを制約したり参照したりすることもできます。
これもまた、テーブル制約の形式で記述する必要があります。
以下は、説明のための非現実的な例です。
<programlisting>
CREATE TABLE t1 (
  a integer PRIMARY KEY,
  b integer,
  c integer,
  <emphasis>FOREIGN KEY (b, c) REFERENCES other_table (c1, c2)</emphasis>
);
</programlisting>
<!--
    Of course, the number and type of the constrained columns need to
    match the number and type of the referenced columns.
-->
もちろん、制約される列数および型は、被参照列の数および型と一致しなければなりません。
   </para>

   <para>
<!--
    You can assign your own name for a foreign key constraint,
    in the usual way.
-->
外部キー制約には、通常の方法で名前を割り当てることもできます。
   </para>

   <para>
<!--
    A table can have more than one foreign key constraint.  This is
    used to implement many-to-many relationships between tables.  Say
    you have tables about products and orders, but now you want to
    allow one order to contain possibly many products (which the
    structure above did not allow).  You could use this table structure:
-->
テーブルは複数の外部キー制約を持つことができます。
このことはテーブル間の多対多関係を実装するために使用されます。
例えば、製品と注文に関するそれぞれのテーブルがある場合に、複数の製品にまたがる注文を可能にしたいとします
（上の例の構造では不可能です）。
この場合、次のテーブル構造を使用できます。
<programlisting>
CREATE TABLE products (
    product_no integer PRIMARY KEY,
    name text,
    price numeric
);

CREATE TABLE orders (
    order_id integer PRIMARY KEY,
    shipping_address text,
    ...
);

CREATE TABLE order_items (
    product_no integer REFERENCES products,
    order_id integer REFERENCES orders,
    quantity integer,
    PRIMARY KEY (product_no, order_id)
);
</programlisting>
<!--
    Notice that the primary key overlaps with the foreign keys in
    the last table.
-->
最後のテーブルで、主キーと外部キーが重なっていることに注目してください。
   </para>

   <indexterm>
    <primary>CASCADE</primary>
<!--
    <secondary>foreign key action</secondary>
-->
    <secondary>外部キー動作</secondary>
   </indexterm>

   <indexterm>
    <primary>RESTRICT</primary>
<!--
    <secondary>foreign key action</secondary>
-->
    <secondary>外部キー動作</secondary>
   </indexterm>

   <para>
<!--
    We know that the foreign keys disallow creation of orders that
    do not relate to any products.  But what if a product is removed
    after an order is created that references it?  SQL allows you to
    handle that as well.  Intuitively, we have a few options:
-->
外部キーが製品に関連付けられていない注文の作成を許可しないことは、既に説明した通りです。
しかし、ある注文で参照していた製品が、注文後に削除されたらどうなるでしょう。
SQLではこのような場合も扱うことができます。
直感的に、いくつかのオプションが考えられます。
    <itemizedlist spacing="compact">
<!--
     <listitem><para>Disallow deleting a referenced product</para></listitem>
     <listitem><para>Delete the orders as well</para></listitem>
     <listitem><para>Something else?</para></listitem>
-->
     <listitem><para>参照される製品の削除を許可しない</para></listitem>
     <listitem><para>注文も一緒に削除する</para></listitem>
     <listitem><para>他にもありますか？</para></listitem>
    </itemizedlist>
   </para>

   <para>
<!--
    To illustrate this, let's implement the following policy on the
    many-to-many relationship example above: when someone wants to
    remove a product that is still referenced by an order (via
    <literal>order_items</literal>), we disallow it.  If someone
    removes an order, the order items are removed as well:
-->
具体例として、上の例の多対多関係に次のポリシーを実装してみましょう。
（<literal>order_items</literal>によって）注文で参照されたままの製品を削除しようしても、この操作を行えないようにします。
注文が削除されると、注文項目も削除されます。
<programlisting>
CREATE TABLE products (
    product_no integer PRIMARY KEY,
    name text,
    price numeric
);

CREATE TABLE orders (
    order_id integer PRIMARY KEY,
    shipping_address text,
    ...
);

CREATE TABLE order_items (
    product_no integer REFERENCES products <emphasis>ON DELETE RESTRICT</emphasis>,
    order_id integer REFERENCES orders <emphasis>ON DELETE CASCADE</emphasis>,
    quantity integer,
    PRIMARY KEY (product_no, order_id)
);
</programlisting>
   </para>

   <para>
<!--
    Restricting and cascading deletes are the two most common options.
    <literal>RESTRICT</literal> prevents deletion of a
    referenced row. <literal>NO ACTION</literal> means that if any
    referencing rows still exist when the constraint is checked, an error
    is raised; this is the default behavior if you do not specify anything.
    (The essential difference between these two choices is that
    <literal>NO ACTION</literal> allows the check to be deferred until
    later in the transaction, whereas <literal>RESTRICT</literal> does not.)
    <literal>CASCADE</literal> specifies that when a referenced row is deleted,
    row(s) referencing it should be automatically deleted as well.
    There are two other options:
    <literal>SET NULL</literal> and <literal>SET DEFAULT</literal>.
    These cause the referencing column(s) in the referencing row(s)
    to be set to nulls or their default
    values, respectively, when the referenced row is deleted.
    Note that these do not excuse you from observing any constraints.
    For example, if an action specifies <literal>SET DEFAULT</literal>
    but the default value would not satisfy the foreign key constraint, the
    operation will fail.
-->
削除の制限およびカスケードという2つは、最も一般的なオプションです。
<literal>RESTRICT</literal>は、被参照行が削除されるのを防ぎます。
<literal>NO ACTION</literal>は、制約が検査された時に参照行がまだ存在していた場合に、エラーとなることを意味しています。
これは、何も指定しない場合のデフォルトの振舞いとなります
（これらの本質的な違いは、<literal>NO ACTION</literal>では検査をトランザクション中で後回しにすることができるのに対し、<literal>RESTRICT</literal>では後回しにできないということです）。
<literal>CASCADE</literal>は被参照行が削除された時、それを参照する行も同様に削除されることを指定します。
他にも2つのオプション、<literal>SET NULL</literal>と<literal>SET DEFAULT</literal>があります。
これらは、被参照行が削除された際に、参照行の参照列がそれぞれNULLか各列のデフォルト値に設定されるようになります。
これらは制約を守ることを免除することではない、ということに注意してください。
例えば、動作に<literal>SET DEFAULT</literal>を指定したとしても、デフォルト値が外部キー制約を満たさない場合には操作は失敗します。
   </para>

   <para>
<!--
    Analogous to <literal>ON DELETE</literal> there is also
    <literal>ON UPDATE</literal> which is invoked when a referenced
    column is changed (updated).  The possible actions are the same.
    In this case, <literal>CASCADE</literal> means that the updated values of the
    referenced column(s) should be copied into the referencing row(s).
-->
<literal>ON DELETE</literal>に似たもので、被参照列が変更（更新）された時に呼び出される<literal>ON UPDATE</literal>もあります。
これらが行えるアクションは同じです。
この場合、<literal>CASCADE</literal>は被参照列の更新後の値が参照行にコピーされることを意味します。
   </para>

   <para>
<!--
    Normally, a referencing row need not satisfy the foreign key constraint
    if any of its referencing columns are null.  If <literal>MATCH FULL</literal>
    is added to the foreign key declaration, a referencing row escapes
    satisfying the constraint only if all its referencing columns are null
    (so a mix of null and non-null values is guaranteed to fail a
    <literal>MATCH FULL</literal> constraint).  If you don't want referencing rows
    to be able to avoid satisfying the foreign key constraint, declare the
    referencing column(s) as <literal>NOT NULL</literal>.
-->
通常、参照行はその参照列のいずれかがnullの場合は外部キー制約を満たす必要がありません。
もし<literal>MATCH FULL</literal>が外部キー宣言に追加された場合、その参照列の全てがnullの場合にのみ参照行は制約を満たすことから逃れることができます(つまりnullと非nullの組み合わせは<literal>MATCH FULL</literal>制約に違反することが保証されます)。
もし参照行が外部キー制約を満たさない可能性を排除したい場合は、参照列を<literal>NOT NULL</literal>として宣言してください。
   </para>

   <para>
<!--
    A foreign key must reference columns that either are a primary key or
    form a unique constraint.  This means that the referenced columns always
    have an index (the one underlying the primary key or unique constraint);
    so checks on whether a referencing row has a match will be efficient.
    Since a <command>DELETE</command> of a row from the referenced table
    or an <command>UPDATE</command> of a referenced column will require
    a scan of the referencing table for rows matching the old value, it
    is often a good idea to index the referencing columns too.  Because this
    is not always needed, and there are many choices available on how
    to index, declaration of a foreign key constraint does not
    automatically create an index on the referencing columns.
-->
外部キーは主キーであるかまたは一意性制約を構成する列を参照しなければなりません。
これは、被参照列は常に(主キーまたは一意性制約の基礎となる)インデックスを持つことを意味します。
このため、参照行に一致する行があるかどうかのチェックは効率的です。
被参照テーブルからの行の<command>DELETE</command>や被参照行の<command>UPDATE</command>は、古い値と一致する行に対して参照テーブルのスキャンが必要となるので、参照行にもインデックスを付けるのは大抵は良い考えです。
これは常に必要という訳ではなく、また、インデックスの方法には多くの選択肢がありますので、外部キー制約の宣言では参照列のインデックスが自動的に作られるということはありません。
   </para>

   <para>
<!--
    More information about updating and deleting data is in <xref
    linkend="dml"/>.  Also see the description of foreign key constraint
    syntax in the reference documentation for
    <xref linkend="sql-createtable"/>.
-->
データの更新および削除について詳しくは、<xref linkend="dml"/>を参照してください。
また、<xref linkend="sql-createtable"/>のリファレンス文書にある外部キー制約構文の説明も参照してください。
   </para>
  </sect2>

  <sect2 id="ddl-constraints-exclusion">
<!--
   <title>Exclusion Constraints</title>
-->
   <title>排他制約</title>

   <indexterm>
<!--
    <primary>exclusion constraint</primary>
-->
    <primary>排他制約</primary>
   </indexterm>

   <indexterm>
<!--
    <primary>constraint</primary>
    <secondary>exclusion</secondary>
-->
    <primary>制約</primary>
    <secondary>排他</secondary>
   </indexterm>

   <para>
<!--
    Exclusion constraints ensure that if any two rows are compared on
    the specified columns or expressions using the specified operators,
    at least one of these operator comparisons will return false or null.
    The syntax is:
-->
排他制約によって、2つの行に関して指定された列もしくは式を指定された演算子を利用して比較した場合に、少なくとも演算子の比較の1つが偽もしくはnullを返すことを確実にします。
構文は以下の通りです。
<programlisting>
CREATE TABLE circles (
    c circle,
    EXCLUDE USING gist (c WITH &amp;&amp;)
);
</programlisting>
   </para>

   <para>
<!--
    See also <link linkend="sql-createtable-exclude"><command>CREATE
    TABLE ... CONSTRAINT ... EXCLUDE</command></link> for details.
-->
詳細は<link linkend="sql-createtable-exclude"><command>CREATE
TABLE ... CONSTRAINT ... EXCLUDE</command></link>を参照して下さい。
   </para>

   <para>
<!--
    Adding an exclusion constraint will automatically create an index
    of the type specified in the constraint declaration.
-->
排他制約を追加すると、制約宣言で指定された種類のインデックスが自動的に作られます。
   </para>
  </sect2>
 </sect1>

 <sect1 id="ddl-system-columns">
<!--
  <title>System Columns</title>
-->
  <title>システム列</title>

  <para>
<!--
   Every table has several <firstterm>system columns</firstterm> that are
   implicitly defined by the system.  Therefore, these names cannot be
   used as names of user-defined columns.  (Note that these
   restrictions are separate from whether the name is a key word or
   not; quoting a name will not allow you to escape these
   restrictions.)  You do not really need to be concerned about these
   columns; just know they exist.
-->
全てのテーブルには、システムによって暗黙的に定義された<firstterm>システム列</firstterm>がいくつかあります。
そのため、システム列の名前はユーザ定義列の名前として使うことはできません。
（これらの制約は名前がキーワードであるかどうかとは関係ありません。
つまり、名前を引用符で囲んでもこの制約を回避することはできません。）
システム列については、あまり意識する必要はありません。
これらが存在することを知っていれば十分です。
  </para>

  <indexterm>
<!--
   <primary>column</primary>
   <secondary>system column</secondary>
-->
   <primary>列</primary>
   <secondary>システム列</secondary>
  </indexterm>

  <variablelist>
   <varlistentry>
    <term><structfield>tableoid</structfield></term>
    <listitem>
     <indexterm>
      <primary>tableoid</primary>
     </indexterm>

     <para>
<!--
      The OID of the table containing this row.  This column is
      particularly handy for queries that select from inheritance
      hierarchies (see <xref linkend="ddl-inherit"/>), since without it,
      it's difficult to tell which individual table a row came from.  The
      <structfield>tableoid</structfield> can be joined against the
      <structfield>oid</structfield> column of
      <structname>pg_class</structname> to obtain the table name.
-->
この行を含むテーブルのOIDです。
この列は特に、継承階層からの選択問い合わせでは便利です（<xref linkend="ddl-inherit"/>を参照してください）。
この列がないと、どのテーブルからその行が来たのかわかりにくいからです。
<structfield>tableoid</structfield>を<classname>pg_class</classname>の<structfield>oid</structfield>列に結合することでテーブル名を得ることができます。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><structfield>xmin</structfield></term>
    <listitem>
     <indexterm>
      <primary>xmin</primary>
     </indexterm>

     <para>
<!--
      The identity (transaction ID) of the inserting transaction for
      this row version.  (A row version is an individual state of a
      row; each update of a row creates a new row version for the same
      logical row.)
-->
この行バージョンの挿入トランザクションの識別情報（トランザクションID）です。
（行バージョンとは、行の個別の状態です。
行が更新される度に、同一の論理的な行に対する新しい行バージョンが作成されます。）
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><structfield>cmin</structfield></term>
    <listitem>
     <indexterm>
      <primary>cmin</primary>
     </indexterm>

     <para>
<!--
      The command identifier (starting at zero) within the inserting
      transaction.
-->
挿入トランザクション内の（0から始まる）コマンド識別子です。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><structfield>xmax</structfield></term>
    <listitem>
     <indexterm>
      <primary>xmax</primary>
     </indexterm>

     <para>
<!--
      The identity (transaction ID) of the deleting transaction, or
      zero for an undeleted row version.  It is possible for this column to
      be nonzero in a visible row version. That usually indicates that the
      deleting transaction hasn't committed yet, or that an attempted
      deletion was rolled back.
-->
削除トランザクションの識別情報（トランザクションID）です。
削除されていない行バージョンではゼロです。
可視の行バージョンでこの列が非ゼロの場合があります。
これは通常、削除トランザクションがまだコミットされていないこと、または、削除の試行がロールバックされたことを意味しています。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><structfield>cmax</structfield></term>
    <listitem>
     <indexterm>
      <primary>cmax</primary>
     </indexterm>

     <para>
<!--
      The command identifier within the deleting transaction, or zero.
-->
削除トランザクション内のコマンド識別子、もしくはゼロです。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><structfield>ctid</structfield></term>
    <listitem>
     <indexterm>
      <primary>ctid</primary>
     </indexterm>

     <para>
<!--
      The physical location of the row version within its table.  Note that
      although the <structfield>ctid</structfield> can be used to
      locate the row version very quickly, a row's
      <structfield>ctid</structfield> will change if it is
      updated or moved by <command>VACUUM FULL</command>.  Therefore
      <structfield>ctid</structfield> is useless as a long-term row
      identifier.  A primary key should be used to identify logical rows.
-->
テーブル内における、行バージョンの物理的位置を表します。
<structfield>ctid</structfield>は行バージョンを素早く見つけるために使うことができますが、行の<structfield>ctid</structfield>は<command>VACUUM FULL</command>により更新あるいは移動させられると変わります。
したがって、<structfield>ctid</structfield>は長期の行識別子としては使えません。
論理行を識別するためには、主キーを使うべきです。
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

   <para>
<!--
    Transaction identifiers are also 32-bit quantities.  In a
    long-lived database it is possible for transaction IDs to wrap
    around.  This is not a fatal problem given appropriate maintenance
    procedures; see <xref linkend="maintenance"/> for details.  It is
    unwise, however, to depend on the uniqueness of transaction IDs
    over the long term (more than one billion transactions).
-->
トランザクション識別子も32ビット量です。
長期間使用するデータベースでは、トランザクションIDが一周してしまう可能性があります。
これは、適切な保守作業を行うことで、致命的な問題にはなりません。
詳細は<xref linkend="maintenance"/>を参照してください。
しかし、長期（10億トランザクション以上）にわたってトランザクションIDの一意性に依存することは賢明ではありません。
   </para>

   <para>
<!--
    Command identifiers are also 32-bit quantities.  This creates a hard limit
    of 2<superscript>32</superscript> (4 billion) <acronym>SQL</acronym> commands
    within a single transaction.  In practice this limit is not a
    problem &mdash; note that the limit is on the number of
    <acronym>SQL</acronym> commands, not the number of rows processed.
    Also, only commands that actually modify the database contents will
    consume a command identifier.
-->
コマンド識別子もまた、32ビット量です。
このため、単一トランザクション内のコマンド数には2<superscript>32</superscript>（40億）個までという制限が発生します。
実際、この制限は問題にはなりません。
これは<acronym>SQL</acronym>コマンド数に対する制限であり、処理される行数に対する制限ではないことに注意してください。
また、データベースの内容を実際に変更するコマンドのみがコマンド識別子を消費します。
   </para>
 </sect1>

 <sect1 id="ddl-alter">
<!--
  <title>Modifying Tables</title>
-->
  <title>テーブルの変更</title>

  <indexterm zone="ddl-alter">
<!--
   <primary>table</primary>
   <secondary>modifying</secondary>
-->
   <primary>テーブル</primary>
   <secondary>の変更</secondary>
  </indexterm>

  <para>
<!--
   When you create a table and you realize that you made a mistake, or
   the requirements of the application change, you can drop the
   table and create it again.  But this is not a convenient option if
   the table is already filled with data, or if the table is
   referenced by other database objects (for instance a foreign key
   constraint).  Therefore <productname>PostgreSQL</productname>
   provides a family of commands to make modifications to existing
   tables.  Note that this is conceptually distinct from altering
   the data contained in the table: here we are interested in altering
   the definition, or structure, of the table.
-->
テーブルの作成後に間違いに気付いたり、あるいはアプリケーションの要件が変わったりした場合には、テーブルをいったん削除して再度作成することができます。
しかし、テーブルにデータを入力済みの場合、あるいはそのテーブルが他のデータベースオブジェクト（例えば外部キー制約）によって参照されている場合、これは良い方法ではありません。
そのため、<productname>PostgreSQL</productname> では既存のテーブルに変更を加えるための一連のコマンドが用意されています。テーブル内のデータを変更するという概念ではないことに注意してください。
ここでは、テーブルの定義や構造を変更することに焦点を合わせます。
  </para>

  <para>
<!--
   You can:
-->
次のことができます。
   <itemizedlist spacing="compact">
    <listitem>
<!--
     <para>Add columns</para>
-->
     <para>列の追加</para>
    </listitem>
    <listitem>
<!--
     <para>Remove columns</para>
-->
     <para>列の削除</para>
    </listitem>
    <listitem>
<!--
     <para>Add constraints</para>
-->
     <para>制約の追加</para>
    </listitem>
    <listitem>
<!--
     <para>Remove constraints</para>
-->
     <para>制約の削除</para>
    </listitem>
    <listitem>
<!--
     <para>Change default values</para>
-->
     <para>デフォルト値の変更</para>
    </listitem>
    <listitem>
<!--
     <para>Change column data types</para>
-->
     <para>列のデータ型の変更</para>
    </listitem>
    <listitem>
<!--
     <para>Rename columns</para>
-->
     <para>列名の変更</para>
    </listitem>
    <listitem>
<!--
     <para>Rename tables</para>
-->
     <para>テーブル名の変更</para>
    </listitem>
   </itemizedlist>

<!--
   All these actions are performed using the
   <xref linkend="sql-altertable"/>
   command, whose reference page contains details beyond those given
   here.
-->
これらの操作は全て<xref linkend="sql-altertable"/>コマンド（本節の説明範囲を超えますので詳細はこちらを参照してください）を使用して行うことができます。
  </para>

  <sect2 id="ddl-alter-adding-a-column">
<!--
   <title>Adding a Column</title>
-->
   <title>列の追加</title>

   <indexterm>
<!--
    <primary>column</primary>
    <secondary>adding</secondary>
-->
    <primary>列</primary>
    <secondary>の追加</secondary>
   </indexterm>

   <para>
<!--
    To add a column, use a command like:
-->
列を追加するには、次のようなコマンドを使用します。
<programlisting>
ALTER TABLE products ADD COLUMN description text;
</programlisting>
<!--
    The new column is initially filled with whatever default
    value is given (null if you don't specify a <literal>DEFAULT</literal> clause).
-->
新しい列にはデフォルト値が初期値として入ります（<literal>DEFAULT</literal>句を指定しない場合はNULL値が入ります）。
   </para>

   <tip>
    <para>
<!--
     From <productname>PostgreSQL</productname> 11, adding a column with
     a constant default value no longer means that each row of the table
     needs to be updated when the <command>ALTER TABLE</command> statement
     is executed. Instead, the default value will be returned the next time
     the row is accessed, and applied when the table is rewritten, making
     the <command>ALTER TABLE</command> very fast even on large tables.
-->
<productname>PostgreSQL</productname> 11から、定数のデフォルト値の列を追加するためにテーブルの各行が<command>ALTER TABLE</command>実行時に更新される必要はもうありません。
その代わりに、デフォルト値は次回にその行にアクセスされた場合に返され、テーブルが書き換えられた際に適用されるため、<command>ALTER TABLE</command>は巨大なテーブルでも非常に高速になります。
    </para>

    <para>
<!--
     However, if the default value is volatile (e.g.,
     <function>clock_timestamp()</function>)
     each row will need to be updated with the value calculated at the time
     <command>ALTER TABLE</command> is executed. To avoid a potentially
     lengthy update operation, particularly if you intend to fill the column
     with mostly nondefault values anyway, it may be preferable to add the
     column with no default, insert the correct values using
     <command>UPDATE</command>, and then add any desired default as described
     below.
-->
しかしながら、もしデフォルト値に揮発性（例えば、<function>clock_timestamp()</function>）がある場合、各行は<command>ALTER TABLE</command>実行時に計算した値に更新される必要があります。
潜在的に長時間の更新作業を避けるため、特に列を主にデフォルト以外の値でとにかく埋めたい場合、デフォルトのない列を追加し<command>UPDATE</command>を使用して正しい値を挿入することが望ましいかもしれません。
その上で、後述するように期待するデフォルトを追加してください。
    </para>
   </tip>

   <para>
<!--
    You can also define constraints on the column at the same time,
    using the usual syntax:
-->
次の構文を使用すると、列の制約も同時に定義することができます。
<programlisting>
ALTER TABLE products ADD COLUMN description text CHECK (description &lt;&gt; '');
</programlisting>
<!--
    In fact all the options that can be applied to a column description
    in <command>CREATE TABLE</command> can be used here.  Keep in mind however
    that the default value must satisfy the given constraints, or the
    <literal>ADD</literal> will fail.  Alternatively, you can add
    constraints later (see below) after you've filled in the new column
    correctly.
-->
実際には<command>CREATE TABLE</command>内の列の記述に使用されている全てのオプションが、ここで使用できます。
ただしデフォルト値は与えられている制約を満足するものでなくてはならないことに注意してください。満足しない場合は<literal>ADD</literal>が失敗します。一方で、新規の列に正しく値を入れた後で制約を追加することができます（下記参照）。
   </para>

  </sect2>

  <sect2 id="ddl-alter-removing-a-column">
<!--
   <title>Removing a Column</title>
-->
   <title>列の削除</title>

   <indexterm>
<!--
    <primary>column</primary>
    <secondary>removing</secondary>
-->
    <primary>列</primary>
    <secondary>の削除</secondary>
   </indexterm>

   <para>
<!--
    To remove a column, use a command like:
-->
列を削除するには、次のようなコマンドを使用します。
<programlisting>
ALTER TABLE products DROP COLUMN description;
</programlisting>
<!--
    Whatever data was in the column disappears.  Table constraints involving
    the column are dropped, too.  However, if the column is referenced by a
    foreign key constraint of another table,
    <productname>PostgreSQL</productname> will not silently drop that
    constraint.  You can authorize dropping everything that depends on
    the column by adding <literal>CASCADE</literal>:
-->
列内にある、どんなデータであれ消去します。
またその列に関連するテーブルの制約も消去されます。
しかし、その列が他のテーブルの外部キー制約として参照されている場合は、<productname>PostgreSQL</productname>は暗黙のうちに制約を消去したりはしません。
<literal>CASCADE</literal>を追加することにより列に依存する全てを消去することを許可できます。
<programlisting>
ALTER TABLE products DROP COLUMN description CASCADE;
</programlisting>
<!--
    See <xref linkend="ddl-depend"/> for a description of the general
    mechanism behind this.
-->
この背後にある一般的な仕組みに関する説明については<xref linkend="ddl-depend"/>を参照してください。
   </para>
  </sect2>

  <sect2 id="ddl-alter-adding-a-constraint">
<!--
   <title>Adding a Constraint</title>
-->
   <title>制約の追加</title>

   <indexterm>
<!--
    <primary>constraint</primary>
    <secondary>adding</secondary>
-->
    <primary>制約</primary>
    <secondary>の追加</secondary>
   </indexterm>

   <para>
<!--
    To add a constraint, the table constraint syntax is used.  For example:
-->
制約を追加するには、テーブル制約の構文が使用されます。
<programlisting>
ALTER TABLE products ADD CHECK (name &lt;&gt; '');
ALTER TABLE products ADD CONSTRAINT some_name UNIQUE (product_no);
ALTER TABLE products ADD FOREIGN KEY (product_group_id) REFERENCES product_groups;
</programlisting>
<!--
    To add a not-null constraint, which cannot be written as a table
    constraint, use this syntax:
-->
非NULL制約はテーブル制約として記述できないので、追加するには次の構文を使用します。
<programlisting>
ALTER TABLE products ALTER COLUMN product_no SET NOT NULL;
</programlisting>
   </para>

   <para>
<!--
    The constraint will be checked immediately, so the table data must
    satisfy the constraint before it can be added.
-->
制約は即座に検査されますので、制約を追加する前にテーブル内のデータがこれに従っている必要があります。
   </para>
  </sect2>

  <sect2 id="ddl-alter-removing-a-constraint">
<!--
   <title>Removing a Constraint</title>
-->
   <title>制約の削除</title>

   <indexterm>
<!--
    <primary>constraint</primary>
    <secondary>removing</secondary>
-->
    <primary>制約</primary>
    <secondary>の削除</secondary>
   </indexterm>

   <para>
<!--
    To remove a constraint you need to know its name.  If you gave it
    a name then that's easy.  Otherwise the system assigned a
    generated name, which you need to find out.  The
    <application>psql</application> command <literal>\d
    <replaceable>tablename</replaceable></literal> can be helpful
    here; other interfaces might also provide a way to inspect table
    details.  Then the command is:
-->
制約を削除するには、その制約名を知る必要があります。
自分で名前を付けた場合は簡単です。
しかし、自分で名前を付けていない場合はシステム生成の名前が割り当てられているので、それを調べなくてはなりません。
それには<application>psql</application>の<literal>\d <replaceable>tablename</replaceable></literal>コマンドを使用すると便利です。
他のインタフェースにもテーブルの詳細を調べる方法があるかもしれません。
制約名がわかったら、次のコマンドで制約を削除できます。
<programlisting>
ALTER TABLE products DROP CONSTRAINT some_name;
</programlisting>
<!--
    (If you are dealing with a generated constraint name like <literal>$2</literal>,
    don't forget that you'll need to double-quote it to make it a valid
    identifier.)
-->
（自動生成された<literal>$2</literal>といった制約名を扱う場合は、有効な識別子となるように二重引用符で括る必要があることを忘れないでください。）
   </para>

   <para>
<!--
    As with dropping a column, you need to add <literal>CASCADE</literal> if you
    want to drop a constraint that something else depends on.  An example
    is that a foreign key constraint depends on a unique or primary key
    constraint on the referenced column(s).
-->
列の削除の場合と同じく、何か他のものが依存している制約を削除する場合には<literal>CASCADE</literal>を付ける必要があります。
例えば、外部キー制約は、参照されている列の一意または主キー制約に依存しています。
   </para>

   <para>
<!--
    This works the same for all constraint types except not-null
    constraints. To drop a not null constraint use:
-->
上記は、非NULL制約以外の全ての制約型に適用できます。
非NULL制約を削除するには、次のようにします。
<programlisting>
ALTER TABLE products ALTER COLUMN product_no DROP NOT NULL;
</programlisting>
<!--
    (Recall that not-null constraints do not have names.)
-->
（非NULL制約には名前がないことを想起してください。）
   </para>
  </sect2>

  <sect2>
<!--
   <title>Changing a Column's Default Value</title>
-->
   <title>列のデフォルト値の変更</title>

   <indexterm>
<!--
    <primary>default value</primary>
    <secondary>changing</secondary>
-->
    <primary>デフォルト値</primary>
    <secondary>の変更</secondary>
   </indexterm>

   <para>
<!--
    To set a new default for a column, use a command like:
-->
列に新しいデフォルトを設定するには、以下のようなコマンドを使用します。
<programlisting>
ALTER TABLE products ALTER COLUMN price SET DEFAULT 7.77;
</programlisting>
<!--
    Note that this doesn't affect any existing rows in the table, it
    just changes the default for future <command>INSERT</command> commands.
-->
これはテーブル内の既存の行には何も影響を与えないことに注意してください。これは将来の<command>INSERT</command>コマンドのために単純にデフォルトを変えるだけです。
   </para>

   <para>
<!--
    To remove any default value, use:
-->
デフォルト値を削除するには次のようにします。
<programlisting>
ALTER TABLE products ALTER COLUMN price DROP DEFAULT;
</programlisting>
<!--
    This is effectively the same as setting the default to null.
    As a consequence, it is not an error
    to drop a default where one hadn't been defined, because the
    default is implicitly the null value.
-->
これは、デフォルトをNULLに設定することと同等です。
そのため、定義されていないデフォルト値を削除してもエラーにはなりません。
なぜなら NULL値が暗黙的にデフォルトとなっているからです。
   </para>
  </sect2>

  <sect2>
<!--
   <title>Changing a Column's Data Type</title>
-->
   <title>列のデータ型の変更</title>

   <indexterm>
<!--
    <primary>column data type</primary>
    <secondary>changing</secondary>
-->
    <primary>列のデータ型</primary>
    <secondary>の変更</secondary>
   </indexterm>

   <para>
<!--
    To convert a column to a different data type, use a command like:
-->
列を異なるデータ型に変換するには以下のようなコマンドを使用してください。
<programlisting>
ALTER TABLE products ALTER COLUMN price TYPE numeric(10,2);
</programlisting>
<!--
    This will succeed only if each existing entry in the column can be
    converted to the new type by an implicit cast.  If a more complex
    conversion is needed, you can add a <literal>USING</literal> clause that
    specifies how to compute the new values from the old.
-->
これは、その列の既存の項目が新しい型に暗黙的キャストにより変換できる場合にのみ成功します。
より複雑な変換が必要な場合、古い値から新しい値をどのように計算するかを指定する<literal>USING</literal>句を付けることができます。
   </para>

   <para>
<!--
    <productname>PostgreSQL</productname> will attempt to convert the column's
    default value (if any) to the new type, as well as any constraints
    that involve the column.  But these conversions might fail, or might
    produce surprising results.  It's often best to drop any constraints
    on the column before altering its type, and then add back suitably
    modified constraints afterwards.
-->
<productname>PostgreSQL</productname>は、（もしあれば）列のデフォルト値を新しい型に、同時に、その列に関連する全ての制約も新しい型に変換しようとします。
しかし、こうした変換は失敗するかもしれませんし、予想を超えた結果になってしまうかもしれません。
型を変更する前にその列に関する制約を全て削除し、後で適切に変更した制約を付け直すことが最善な場合がよくあります。
   </para>
  </sect2>

  <sect2>
<!--
   <title>Renaming a Column</title>
-->
   <title>列名の変更</title>

   <indexterm>
<!--
    <primary>column</primary>
    <secondary>renaming</secondary>
-->
    <primary>列</primary>
    <secondary>の名称変更</secondary>
   </indexterm>

   <para>
<!--
    To rename a column:
-->
列名を変更するには、次のようにします。
<programlisting>
ALTER TABLE products RENAME COLUMN product_no TO product_number;
</programlisting>
   </para>
  </sect2>

  <sect2>
<!--
   <title>Renaming a Table</title>
-->
   <title>テーブル名の変更</title>

   <indexterm>
<!--
    <primary>table</primary>
    <secondary>renaming</secondary>
-->
    <primary>テーブル</primary>
    <secondary>の名称変更</secondary>
   </indexterm>

   <para>
<!--
    To rename a table:
-->
テーブル名を変更するには、次のようにします。
<programlisting>
ALTER TABLE products RENAME TO items;
</programlisting>
   </para>
  </sect2>
 </sect1>

 <sect1 id="ddl-priv">
<!--
  <title>Privileges</title>
-->
  <title>権限</title>

  <indexterm zone="ddl-priv">
<!--
   <primary>privilege</primary>
-->
   <primary>権限</primary>
  </indexterm>

  <indexterm>
<!--
   <primary>permission</primary>
   <see>privilege</see>
-->
   <primary>権利</primary>
   <see>権限</see>
  </indexterm>

  <indexterm zone="ddl-priv">
<!--
   <primary>owner</primary>
-->
   <primary>所有者</primary>
  </indexterm>

  <indexterm zone="ddl-priv">
   <primary>GRANT</primary>
  </indexterm>

  <indexterm zone="ddl-priv">
   <primary>REVOKE</primary>
  </indexterm>

  <indexterm zone="ddl-priv">
   <primary>ACL</primary>
  </indexterm>

  <para>
<!--
   When an object is created, it is assigned an owner. The
   owner is normally the role that executed the creation statement.
   For most kinds of objects, the initial state is that only the owner
   (or a superuser) can do anything with the object. To allow
   other roles to use it, <firstterm>privileges</firstterm> must be
   granted.
-->
オブジェクトが作成されると、所有者が割り当てられます。通常、所有者は作成する文を実行したロールです。ほとんどの種類のオブジェクトについて、初期状態では所有者(またはスーパーユーザ)だけがそのオブジェクトを使用できます。
他のユーザがこのオブジェクトを使用するには、<firstterm>権限</firstterm>が付与されていなければなりません。
  </para>

  <para>
<!--
   There are different kinds of privileges: <literal>SELECT</literal>,
   <literal>INSERT</literal>, <literal>UPDATE</literal>, <literal>DELETE</literal>,
   <literal>TRUNCATE</literal>, <literal>REFERENCES</literal>, <literal>TRIGGER</literal>,
   <literal>CREATE</literal>, <literal>CONNECT</literal>, <literal>TEMPORARY</literal>,
   <literal>EXECUTE</literal>, and <literal>USAGE</literal>.
   The privileges applicable to a particular
   object vary depending on the object's type (table, function, etc).
   More detail about the meanings of these privileges appears below.
   The following sections and chapters will also show you how
   these privileges are used.
-->
権限にはいくつかの種類があります。
すなわち<literal>SELECT</literal>、 <literal>INSERT</literal>、<literal>UPDATE</literal>、<literal>DELETE</literal>、<literal>TRUNCATE</literal>、<literal>REFERENCES</literal>、<literal>TRIGGER</literal>、<literal>CREATE</literal>、<literal>CONNECT</literal>、<literal>TEMPORARY</literal>、 <literal>EXECUTE</literal>、<literal>USAGE</literal>です。
特定のオブジェクトに適用可能な権限は、オブジェクトの型（テーブル、関数など）により変わります。
これらの権限の詳細な意味を以下に示します。
以降の節および章でもこれらの権限の使用方法についての説明があります。
  </para>

  <para>
<!--
   The right to modify or destroy an object is inherent in being the
   object's owner, and cannot be granted or revoked in itself.
   (However, like all privileges, that right can be inherited by
   members of the owning role; see <xref linkend="role-membership"/>.)
-->
オブジェクトの変更や削除の権限は常に所有者のみに与えられるものです。
  </para>

  <para>
<!--
   An object can be assigned to a new owner with an <command>ALTER</command>
   command of the appropriate kind for the object, for example
-->
たとえば次のように、オブジェクトに対する適切な種類の<command>ALTER</command>コマンドにより、あるオブジェクトに新しい所有者を割り当てることができます。
<programlisting>
ALTER TABLE <replaceable>table_name</replaceable> OWNER TO <replaceable>new_owner</replaceable>;
</programlisting>
<!--
   Superusers can always do this; ordinary roles can only do it if they are
   both the current owner of the object (or a member of the owning role) and
   a member of the new owning role.
-->
スーパーユーザはいつでも所有者を変更できます。通常のロールは、対象オブジェクトの現在の所有者(または所有者ロールのメンバー)であり、かつ新しい所有者ロールのメンバーである場合に限り、所有者を変更できます。
  </para>

  <para>
<!--
   To assign privileges, the <xref linkend="sql-grant"/> command is
   used. For example, if <literal>joe</literal> is an existing role, and
   <literal>accounts</literal> is an existing table, the privilege to
   update the table can be granted with:
-->
権限を割り当てるには、<xref linkend="sql-grant"/>コマンドを使用します。
例えば、<literal>joe</literal>という既存のロールと<literal>accounts</literal>という既存のテーブルがある場合、このテーブルを更新する権限を付与するには以下のようにします。
<programlisting>
GRANT UPDATE ON accounts TO joe;
</programlisting>
<!--
   Writing <literal>ALL</literal> in place of a specific privilege grants all
   privileges that are relevant for the object type.
-->
特定の権限名を指定する代わりに<literal>ALL</literal>を指定すると、その種類のオブジェクトに関連する全ての権限が付与されます。
  </para>

  <para>
<!--
   The special <quote>role</quote> name <literal>PUBLIC</literal> can
   be used to grant a privilege to every role on the system.  Also,
   <quote>group</quote> roles can be set up to help manage privileges when
   there are many users of a database &mdash; for details see
   <xref linkend="user-manag"/>.
-->
システム内の全てのロールに権限を付与するには、特別な<quote>ロール</quote>名である<literal>PUBLIC</literal>を使用することができます。
また、<quote>グループ</quote>ロールを使用すれば、データベース内に多くのユーザが存在する場合に権限の管理が簡単になります。
詳細は<xref linkend="user-manag"/>を参照してください。
  </para>

  <para>
<!--
   To revoke a previously-granted privilege, use the fittingly named
   <xref linkend="sql-revoke"/> command:
-->
権限を取り消す(revoke)には、それに相応しい名前の<xref linkend="sql-revoke"/>コマンドを使用します。
<programlisting>
REVOKE ALL ON accounts FROM PUBLIC;
</programlisting>
  </para>

  <para>
<!--
   Ordinarily, only the object's owner (or a superuser) can grant or
   revoke privileges on an object.  However, it is possible to grant a
   privilege <quote>with grant option</quote>, which gives the recipient
   the right to grant it in turn to others.  If the grant option is
   subsequently revoked then all who received the privilege from that
   recipient (directly or through a chain of grants) will lose the
   privilege.  For details see the <xref linkend="sql-grant"/> and
   <xref linkend="sql-revoke"/> reference pages.
-->
普通はオブジェクトの所有者（またはスーパーユーザ）だけが、オブジェクトにおける権限の付与や剥奪ができます。
しかし<quote>with grant option</quote>を付けることで、権限を与えられたユーザが、所有者と同様に他のユーザに権限を付与することが可能になります。
もし後になってグラントオプションが剥奪されると、剥奪されたユーザから（直接もしくは権限付与の連鎖により）権限を与えられていたユーザはすべて、その権限が剥奪されます。
詳細は、<xref linkend="sql-grant"/>と<xref linkend="sql-revoke"/>を参照してください。
  </para>

  <para>
   An object's owner can choose to revoke their own ordinary privileges,
   for example to make a table read-only for themselves as well as others.
   But owners are always treated as holding all grant options, so they
   can always re-grant their own privileges.
  </para>

  <para>
<!--
   The available privileges are:
-->
可能な権限は以下です。

   <variablelist>
    <varlistentry>
     <term><literal>SELECT</literal></term>
     <listitem>
      <para>
<!--
       Allows <xref linkend="sql-select"/> from
       any column, or specific column(s), of a table, view, materialized
       view, or other table-like object.
       Also allows use of <xref linkend="sql-copy"/> TO.
       This privilege is also needed to reference existing column values in
       <xref linkend="sql-update"/> or <xref linkend="sql-delete"/>.
       For sequences, this privilege also allows use of the
       <function>currval</function> function.
       For large objects, this privilege allows the object to be read.
-->
テーブル、ビュー、マテリアライズドビュー、あるいはそれ以外のテーブルのように見えるオブジェクトに対して<xref linkend="sql-select"/>をある列、あるいは指定した列（複数可）に許可します。
また、<xref linkend="sql-copy"/>の利用を許可します。
この権限は<xref linkend="sql-update"/>あるいは<xref linkend="sql-delete"/>において既存の列を参照する場合にも必要になります。
シーケンスにおいてはこの権限は<function>currval</function>関数の使用を許可します。
ラージオブジェクトにおいてはこの権限はオブジェクトの読み出しを許可します。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>INSERT</literal></term>
     <listitem>
      <para>
<!--
       Allows <xref linkend="sql-insert"/> of a new row into a table, view,
       etc.  Can be granted on specific column(s), in which case
       only those columns may be assigned to in the <command>INSERT</command>
       command (other columns will therefore receive default values).
       Also allows use of <xref linkend="sql-copy"/> FROM.
-->
テーブル、ビューなどに新しい行を<xref linkend="sql-insert"/>することを許可します。
特定の列だけを<command>INSERT</command>コマンドで指定したい場合に、それらの列に許可することができます。
（したがって他の列にはデフォルトが設定されます）。
<xref linkend="sql-copy"/> FROMを利用することもできます。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>UPDATE</literal></term>
     <listitem>
      <para>
<!--
       Allows <xref linkend="sql-update"/> of any
       column, or specific column(s), of a table, view, etc.
       (In practice, any nontrivial <command>UPDATE</command> command will
       require <literal>SELECT</literal> privilege as well, since it must
       reference table columns to determine which rows to update, and/or to
       compute new values for columns.)
       <literal>SELECT ... FOR UPDATE</literal>
       and <literal>SELECT ... FOR SHARE</literal>
       also require this privilege on at least one column, in addition to the
       <literal>SELECT</literal> privilege.  For sequences, this
       privilege allows use of the <function>nextval</function> and
       <function>setval</function> functions.
       For large objects, this privilege allows writing or truncating the
       object.
-->
テーブル、ビューなどの列を<xref linkend="sql-update"/>することを許可します。
（実用的には、簡単ではない<command>UPDATE</command>コマンドには<literal>SELECT</literal>権限も必要になります。
どの行を更新するかを決定したり、列に対して新しい値を計算するためにテーブルの列を参照しなければならないからです。）
<literal>SELECT ... FOR UPDATE</literal>と<literal>SELECT ... FOR SHARE</literal>は<literal>SELECT</literal>権限に加えて更にこの権限が必要になります。
シーケンスではこの権限は<function>nextval</function>と<function>setval</function>関数の利用を許可します。
ラージオブジェクトではこの権限はオブジェクトへの書き込みあるいは切り詰めを行うことを許可します。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>DELETE</literal></term>
     <listitem>
      <para>
<!--
       Allows <xref linkend="sql-delete"/> of a row from a table, view, etc.
       (In practice, any nontrivial <command>DELETE</command> command will
       require <literal>SELECT</literal> privilege as well, since it must
       reference table columns to determine which rows to delete.)
-->
テーブル、ビューなどの列を<xref linkend="sql-delete"/>することを許可します。
（実用的には、簡単ではない<command>DELETE</command>コマンドには<literal>SELECT</literal>権限も必要になります。
どの行を削除するかを決定するためにテーブルの列を参照しなければならないからです。）
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>TRUNCATE</literal></term>
     <listitem>
      <para>
<!--
       Allows <xref linkend="sql-truncate"/> on a table, view, etc.
-->
テーブルあるいはビューの<xref linkend="sql-truncate"/>を許可します。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>REFERENCES</literal></term>
     <listitem>
      <para>
<!--
       Allows creation of a foreign key constraint referencing a
       table, or specific column(s) of a table.
-->
テーブルあるいはテーブルの特定の列を参照する外部キー制約を作ることを許可します。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>TRIGGER</literal></term>
     <listitem>
      <para>
<!--
       Allows creation of a trigger on a table, view, etc.
-->
テーブルあるいはビューにトリガを作ることを許可します。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>CREATE</literal></term>
     <listitem>
      <para>
<!--
       For databases, allows new schemas and publications to be created within
       the database, and allows trusted extensions to be installed within
       the database.
-->
データベースに対して、データベース内に新しいスキーマとパブリケーションを作ることを許可します。
      </para>
      <para>
<!--
       For schemas, allows new objects to be created within the schema.
       To rename an existing object, you must own the
       object <emphasis>and</emphasis> have this privilege for the containing
       schema.
-->
スキーマに対して、スキーマ内に新しいオブジェクトを作ることを許可します。
既存のオブジェクトの名前を変えるには、オブジェクトを所有する<emphasis>とともに</emphasis>そのオブジェクトを含むスキーマに対してこの権限を持っていなければなりません。
      </para>
      <para>
<!--
       For tablespaces, allows tables, indexes, and temporary files to be
       created within the tablespace, and allows databases to be created that
       have the tablespace as their default tablespace.
-->
テーブル空間に対しては、そのテーブル空間内にテーブル、インデックス、一時ファイルを作ることを許可し、そのテーブル空間をデフォルトのテーブル空間として持つデータベースを作ることを許可します。
（この権限を剥奪しても既存のオブジェクトの配置を変更しないことに注意してください。）
      </para>
      <para>
       Note that revoking this privilege will not alter the existence or
       location of existing objects.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>CONNECT</literal></term>
     <listitem>
      <para>
<!--
       Allows the grantee to connect to the database.  This
       privilege is checked at connection startup (in addition to checking
       any restrictions imposed by <filename>pg_hba.conf</filename>).
-->
権限を与えられた者がデータベースに接続することを許可します。
（<filename>pg_hba.conf</filename>が課す制限の検査に加えて）この権限は接続の開始時に検査されます。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>TEMPORARY</literal></term>
     <listitem>
      <para>
<!--
       Allows temporary tables to be created while using the database.
-->
データベース使用中に一時テーブルを作成することを許可します。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>EXECUTE</literal></term>
     <listitem>
      <para>
<!--
       Allows calling a function or procedure, including use of
       any operators that are implemented on top of the function.  This is the
       only type of privilege that is applicable to functions and procedures.
-->
関数上に実装された演算子を含めて関数あるいはプロシージャの呼び出しを許可します。
これは関数とプロシージャに適用される唯一のタイプの権限です。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>USAGE</literal></term>
     <listitem>
      <para>
<!--
       For procedural languages, allows use of the language for
       the creation of functions in that language.  This is the only type
       of privilege that is applicable to procedural languages.
-->
手続き言語に対して、言語内で関数を作るために言語を使用することを許可します。
これは手続き言語に適用される唯一のタイプの権限です。
      </para>
      <para>
<!--
       For schemas, allows access to objects contained in the
       schema (assuming that the objects' own privilege requirements are
       also met).  Essentially this allows the grantee to <quote>look up</quote>
       objects within the schema.  Without this permission, it is still
       possible to see the object names, e.g., by querying system catalogs.
       Also, after revoking this permission, existing sessions might have
       statements that have previously performed this lookup, so this is not
       a completely secure way to prevent object access.
-->
スキーマに対しては、（オブジェクト自身の権限要件が満たされているものと仮定した上で）スキーマ内に含まれるオブジェクトへのアクセスを許可します。
本質的に、これは権限を授与されたものがスキーマ内のオブジェクトを<quote>検査</quote>することを許可します。
この許可がなくても依然としてオブジェクト名を見ることを可能です。たとえば、システムカタログを問い合わせることによってです。
また、この許可を剥奪した後でも、既存のセッションはすでにこの検査を実施していると主張するかも知れません。
ですからこれはオブジェクトへのアクセスを妨げる完全にセキュアな方法ではありません。
      </para>
      <para>
<!--
       For sequences, allows use of the
       <function>currval</function> and <function>nextval</function> functions.
-->
シーケンスに対しては、<function>currval</function>と<function>nextval</function>関数の利用を許可します。
      </para>
      <para>
<!--
       For types and domains, allows use of the type or domain in the
       creation of tables, functions, and other schema objects.  (Note that
       this privilege does not control all <quote>usage</quote> of the
       type, such as values of the type appearing in queries.  It only
       prevents objects from being created that depend on the type.  The
       main purpose of this privilege is controlling which users can create
       dependencies on a type, which could prevent the owner from changing
       the type later.)
-->
型とドメインに対しては、テーブル、関数、および他のスキーマオブジェクトを生成する際に型とドメインを使用することを許可します。
（たとえば問い合わせ中に表れる型の値のような、すべての型の<quote>利用</quote>をこの権限はコントロールするわけではないことに注意してください。
その型に依存するオブジェクトが作られるのを防ぐだけです。
この権限の主な目的は、どのユーザがある型への依存関係を作ることができるかを制御し、後で所有者がこの型を変更するのを防ぐためです。）
      </para>
      <para>
<!--
       For foreign-data wrappers, allows creation of new servers using the
       foreign-data wrapper.
-->
外部データラッパーに対しては、その外部データラッパーを使って新しいサーバを作ることを許可します。
      </para>
      <para>
<!--
       For foreign servers, allows creation of foreign tables using the
       server.  Grantees may also create, alter, or drop their own user
       mappings associated with that server.
-->
外部サーバに対しては、そのサーバを使って外部テーブルを作ることを許可します。
権限を授与されたものは、そのサーバに結びついたユーザマッピングを作成、変更、削除することができます。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>

<!--
   The privileges required by other commands are listed on the
   reference page of the respective command.
-->
他のコマンドで必要となる権限はそれぞれのコマンドのリファレンスページに列挙されています。
  </para>

  <para>
<!--
   PostgreSQL grants privileges on some types of objects to
   <literal>PUBLIC</literal> by default when the objects are created.
   No privileges are granted to <literal>PUBLIC</literal> by default on
   tables,
   table columns,
   sequences,
   foreign data wrappers,
   foreign servers,
   large objects,
   schemas,
   or tablespaces.
   For other types of objects, the default privileges
   granted to <literal>PUBLIC</literal> are as follows:
   <literal>CONNECT</literal> and <literal>TEMPORARY</literal> (create
   temporary tables) privileges for databases;
   <literal>EXECUTE</literal> privilege for functions and procedures; and
   <literal>USAGE</literal> privilege for languages and data types
   (including domains).
   The object owner can, of course, <command>REVOKE</command>
   both default and expressly granted privileges. (For maximum
   security, issue the <command>REVOKE</command> in the same transaction that
   creates the object; then there is no window in which another user
   can use the object.)
   Also, these default privilege settings can be overridden using the
   <xref linkend="sql-alterdefaultprivileges"/> command.
-->
PostgreSQLはあるタイプのオブジェクトが作成された時に、そのオブジェクトに対する権限をデフォルトで<literal>PUBLIC</literal>に付与します。
テーブル、テーブルの列、シーケンス、外部データラッパー、外部サーバ、ラージオブジェクト、スキーマ、テーブル空間に対しては、デフォルトでは<literal>PUBLIC</literal>に権限を付与しません。
他のタイプのオブジェクトに対しては、<literal>PUBLIC</literal>にデフォルトで付与される権限は次のものです。
<literal>CONNECT</literal>、<literal>TEMPORARY</literal> （データベース内で一時テーブルを作成する権限）、関数とプロシージャに対する<literal>EXECUTE</literal>権限、言語とデータ型（ドメインを含む）に対する<literal>USAGE</literal>権限。
もちろんオブジェクトの所有者は、デフォルト、あるいは明示的に与えられた権限を<command>REVOKE</command>できます。
（セキュリティを最大限に高めるためには、<command>REVOKE</command>をオブジェクトを作成したのと同じトランザクション内で発行してください。そうすれば他のユーザがそのオブジェクトを使う隙が存在しません。）
また、デフォルトの権限設定は<xref linkend="sql-alterdefaultprivileges"/>を使って上書きできます。
  </para>

  <para>
<!--
   <xref linkend="privilege-abbrevs-table"/> shows the one-letter
   abbreviations that are used for these privilege types in
   <firstterm>ACL</firstterm> (Access Control List) values.
   You will see these letters in the output of the <xref linkend="app-psql"/>
   commands listed below, or when looking at ACL columns of system catalogs.
-->
<xref linkend="privilege-abbrevs-table"/>に、<firstterm>ACL</firstterm>（Access Control List）値において権限タイプに使われる1文字の短縮形を示します。
<xref linkend="app-psql"/>の出力、あるいはシステムカタログのACL列を参照することでこれらの文字を見ることができます。
  </para>

  <table id="privilege-abbrevs-table">
<!--
   <title>ACL Privilege Abbreviations</title>
-->
   <title>ACL短縮形</title>
   <tgroup cols="3">
    <colspec colname="col1" colwidth="1*"/>
    <colspec colname="col2" colwidth="1*"/>
    <colspec colname="col3" colwidth="2*"/>
    <thead>
     <row>
<!--
      <entry>Privilege</entry>
      <entry>Abbreviation</entry>
      <entry>Applicable Object Types</entry>
-->
      <entry>権限</entry>
      <entry>短縮形</entry>
      <entry>適用可能なオブジェクトタイプ</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><literal>SELECT</literal></entry>
      <entry><literal>r</literal> (<quote>read</quote>)</entry>
      <entry>
       <literal>LARGE OBJECT</literal>,
       <literal>SEQUENCE</literal>,
<!--
       <literal>TABLE</literal> (and table-like objects),
       table column
-->
       <literal>TABLE</literal>（およびテーブルのようなオブジェクト）、テーブルの列
      </entry>
     </row>
     <row>
      <entry><literal>INSERT</literal></entry>
      <entry><literal>a</literal> (<quote>append</quote>)</entry>
<!--
      <entry><literal>TABLE</literal>, table column</entry>
-->
      <entry><literal>TABLE</literal>、テーブルの列</entry>
     </row>
     <row>
      <entry><literal>UPDATE</literal></entry>
      <entry><literal>w</literal> (<quote>write</quote>)</entry>
      <entry>
       <literal>LARGE OBJECT</literal>,
       <literal>SEQUENCE</literal>,
       <literal>TABLE</literal>,
<!--
       table column
-->
       テーブルの列
      </entry>
     </row>
     <row>
      <entry><literal>DELETE</literal></entry>
      <entry><literal>d</literal></entry>
      <entry><literal>TABLE</literal></entry>
     </row>
     <row>
      <entry><literal>TRUNCATE</literal></entry>
      <entry><literal>D</literal></entry>
      <entry><literal>TABLE</literal></entry>
     </row>
     <row>
      <entry><literal>REFERENCES</literal></entry>
      <entry><literal>x</literal></entry>
<!--
      <entry><literal>TABLE</literal>, table column</entry>
-->
      <entry><literal>TABLE</literal>、テーブルの列</entry>
     </row>
     <row>
      <entry><literal>TRIGGER</literal></entry>
      <entry><literal>t</literal></entry>
      <entry><literal>TABLE</literal></entry>
     </row>
     <row>
      <entry><literal>CREATE</literal></entry>
      <entry><literal>C</literal></entry>
      <entry>
       <literal>DATABASE</literal>,
       <literal>SCHEMA</literal>,
       <literal>TABLESPACE</literal>
      </entry>
     </row>
     <row>
      <entry><literal>CONNECT</literal></entry>
      <entry><literal>c</literal></entry>
      <entry><literal>DATABASE</literal></entry>
     </row>
     <row>
      <entry><literal>TEMPORARY</literal></entry>
      <entry><literal>T</literal></entry>
      <entry><literal>DATABASE</literal></entry>
     </row>
     <row>
      <entry><literal>EXECUTE</literal></entry>
      <entry><literal>X</literal></entry>
      <entry><literal>FUNCTION</literal>, <literal>PROCEDURE</literal></entry>
     </row>
     <row>
      <entry><literal>USAGE</literal></entry>
      <entry><literal>U</literal></entry>
      <entry>
       <literal>DOMAIN</literal>,
       <literal>FOREIGN DATA WRAPPER</literal>,
       <literal>FOREIGN SERVER</literal>,
       <literal>LANGUAGE</literal>,
       <literal>SCHEMA</literal>,
       <literal>SEQUENCE</literal>,
       <literal>TYPE</literal>
      </entry>
     </row>
     </tbody>
   </tgroup>
  </table>

  <para>
<!--
   <xref linkend="privileges-summary-table"/> summarizes the privileges
   available for each type of SQL object, using the abbreviations shown
   above.
   It also shows the <application>psql</application> command
   that can be used to examine privilege settings for each object type.
-->
<xref linkend="privileges-summary-table"/>は、前述の短縮形を用いてそれぞれのタイプのSQLオブジェクトで利用可能な権限をまとめています。
また、それぞれのオブジェクトタイプの権限設定を調べる際に利用できる<application>psql</application>コマンドを示します。
  </para>

  <table id="privileges-summary-table">
<!--
   <title>Summary of Access Privileges</title>
-->
   <title>アクセス権限のまとめ</title>
   <tgroup cols="4">
    <colspec colname="col1" colwidth="2*"/>
    <colspec colname="col2" colwidth="1*"/>
    <colspec colname="col3" colwidth="1*"/>
    <colspec colname="col4" colwidth="1*"/>
    <thead>
     <row>
<!--
      <entry>Object Type</entry>
      <entry>All Privileges</entry>
      <entry>Default <literal>PUBLIC</literal> Privileges</entry>
      <entry><application>psql</application> Command</entry>
-->
      <entry>オブジェクトタイプ</entry>
      <entry>すべての権限</entry>
      <entry>デフォルト<literal>PUBLIC</literal>権限</entry>
      <entry><application>psql</application>コマンド</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><literal>DATABASE</literal></entry>
      <entry><literal>CTc</literal></entry>
      <entry><literal>Tc</literal></entry>
      <entry><literal>\l</literal></entry>
     </row>
     <row>
      <entry><literal>DOMAIN</literal></entry>
      <entry><literal>U</literal></entry>
      <entry><literal>U</literal></entry>
      <entry><literal>\dD+</literal></entry>
     </row>
     <row>
      <entry><literal>FUNCTION</literal> or <literal>PROCEDURE</literal></entry>
      <entry><literal>X</literal></entry>
      <entry><literal>X</literal></entry>
      <entry><literal>\df+</literal></entry>
     </row>
     <row>
      <entry><literal>FOREIGN DATA WRAPPER</literal></entry>
      <entry><literal>U</literal></entry>
      <entry>none</entry>
      <entry><literal>\dew+</literal></entry>
     </row>
     <row>
      <entry><literal>FOREIGN SERVER</literal></entry>
      <entry><literal>U</literal></entry>
      <entry>none</entry>
      <entry><literal>\des+</literal></entry>
     </row>
     <row>
      <entry><literal>LANGUAGE</literal></entry>
      <entry><literal>U</literal></entry>
      <entry><literal>U</literal></entry>
      <entry><literal>\dL+</literal></entry>
     </row>
     <row>
      <entry><literal>LARGE OBJECT</literal></entry>
      <entry><literal>rw</literal></entry>
      <entry>none</entry>
      <entry></entry>
     </row>
     <row>
      <entry><literal>SCHEMA</literal></entry>
      <entry><literal>UC</literal></entry>
      <entry>none</entry>
      <entry><literal>\dn+</literal></entry>
     </row>
     <row>
      <entry><literal>SEQUENCE</literal></entry>
      <entry><literal>rwU</literal></entry>
      <entry>none</entry>
      <entry><literal>\dp</literal></entry>
     </row>
     <row>
<!--
      <entry><literal>TABLE</literal> (and table-like objects)</entry>
-->
      <entry><literal>TABLE</literal>（およびテーブルのようなオブジェクト）</entry>
      <entry><literal>arwdDxt</literal></entry>
      <entry>none</entry>
      <entry><literal>\dp</literal></entry>
     </row>
     <row>
<!--
      <entry>Table column</entry>
-->
      <entry>テーブルの列</entry>
      <entry><literal>arwx</literal></entry>
      <entry>none</entry>
      <entry><literal>\dp</literal></entry>
     </row>
     <row>
      <entry><literal>TABLESPACE</literal></entry>
      <entry><literal>C</literal></entry>
      <entry>none</entry>
      <entry><literal>\db+</literal></entry>
     </row>
     <row>
      <entry><literal>TYPE</literal></entry>
      <entry><literal>U</literal></entry>
      <entry><literal>U</literal></entry>
      <entry><literal>\dT+</literal></entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   <indexterm>
    <primary><type>aclitem</type></primary>
   </indexterm>
<!--
   The privileges that have been granted for a particular object are
   displayed as a list of <type>aclitem</type> entries, where each
   <type>aclitem</type> describes the permissions of one grantee that
   have been granted by a particular grantor.  For example,
   <literal>calvin=r*w/hobbes</literal> specifies that the role
   <literal>calvin</literal> has the privilege
   <literal>SELECT</literal> (<literal>r</literal>) with grant option
   (<literal>*</literal>) as well as the non-grantable
   privilege <literal>UPDATE</literal> (<literal>w</literal>), both granted
   by the role <literal>hobbes</literal>.  If <literal>calvin</literal>
   also has some privileges on the same object granted by a different
   grantor, those would appear as a separate <type>aclitem</type> entry.
   An empty grantee field in an <type>aclitem</type> stands
   for <literal>PUBLIC</literal>.
-->
あるオブジェクトに与えられている権限は<type>aclitem</type>エントリのリストとして表示されます。
そこでは、<type>aclitem</type>はある権限付与者によって与えられている権限授与者の許可を示しています。
たとえば、<literal>calvin=r*w/hobbes</literal>は、ロール<literal>calvin</literal>が許可オプション（<literal>*</literal>）ありの<literal>SELECT</literal>（<literal>r</literal>）と許可オプションなしの<literal>UPDATE</literal> (<literal>w</literal>)を持ち、それらがロール<literal>hobbes</literal>に与えられていることを示します。
別の権限付与者によって権限が与えられている同じオブジェクトに対して<literal>calvin</literal>も権限を持っている場合は、別の<type>aclitem</type>エントリとして表示されます。
<type>aclitem</type>の権限授与者フィールドが空であれば、それは<literal>PUBLIC</literal>を表します。
  </para>

  <para>
<!--
   As an example, suppose that user <literal>miriam</literal> creates
   table <literal>mytable</literal> and does:
-->
ユーザ<literal>miriam</literal>がテーブル<literal>mytable</literal>を作成し、以下を行う例を考えます。
<programlisting>
GRANT SELECT ON mytable TO PUBLIC;
GRANT SELECT, UPDATE, INSERT ON mytable TO admin;
GRANT SELECT (col1), UPDATE (col1) ON mytable TO miriam_rw;
</programlisting>
<!--
   Then <application>psql</application>'s <literal>\dp</literal> command
   would show:
-->
すると、<application>psql</application>の<literal>\dp</literal>コマンドは次のように表示するはずです。
<programlisting>
=&gt; \dp mytable
                                  Access privileges
 Schema |  Name   | Type  |   Access privileges   |   Column privileges   | Policies
--------+---------+-------+-----------------------+-----------------------+----------
 public | mytable | table | miriam=arwdDxt/miriam+| col1:                +|
        |         |       | =r/miriam            +|   miriam_rw=rw/miriam |
        |         |       | admin=arw/miriam      |                       |
(1 row)
</programlisting>
  </para>

  <para>
<!--
   If the <quote>Access privileges</quote> column is empty for a given
   object, it means the object has default privileges (that is, its
   privileges entry in the relevant system catalog is null).  Default
   privileges always include all privileges for the owner, and can include
   some privileges for <literal>PUBLIC</literal> depending on the object
   type, as explained above.  The first <command>GRANT</command>
   or <command>REVOKE</command> on an object will instantiate the default
   privileges (producing, for
   example, <literal>miriam=arwdDxt/miriam</literal>) and then modify them
   per the specified request.  Similarly, entries are shown in <quote>Column
   privileges</quote> only for columns with nondefault privileges.
   (Note: for this purpose, <quote>default privileges</quote> always means
   the built-in default privileges for the object's type.  An object whose
   privileges have been affected by an <command>ALTER DEFAULT
   PRIVILEGES</command> command will always be shown with an explicit
   privilege entry that includes the effects of
   the <command>ALTER</command>.)
-->
あるオブジェクトに対して<quote>Access privileges</quote>列が空なら、そのオブジェクトがデフォルトの権限を持つことを意味します。
（つまり、関連するシステムカタログの権限エントリがNULLだということです。）
デフォルト権限は常に所有者の全権限を含み、更に上で説明示したようにオブジェクトタイプ依存の<literal>PUBLIC</literal>に対する権限を持つことができます。
オブジェクトに対する初回の<command>GRANT</command>あるいは<command>REVOKE</command>により、デフォルト権限（たとえば<literal>miriam=arwdDxt/miriam</literal>）が設定され、次に特定の要求に従って変更されます。
同様に、<quote>Column privileges</quote>に示されるエントリは非デフォルトの権限を持つ列のためだけのものです。
（注意：<quote>デフォルト権限</quote>は常にオブジェクトのタイプの組み込みのデフォルト権限を意味します。
<command>ALTER DEFAULT PRIVILEGES</command>コマンドによって権限が影響を受けるオブジェクトは常に<command>ALTER</command>の影響を含む明示的な権限エントリを伴って示されます。）
  </para>

  <para>
<!--
   Notice that the owner's implicit grant options are not marked in the
   access privileges display.  A <literal>*</literal> will appear only when
   grant options have been explicitly granted to someone.
-->
所有者の暗黙的な許可オプションはアクセス権限表示では印を付けられないことに注意してください。
<literal>*</literal>は許可オプションが明示的に誰かに許可されたときにのみ現れます。
  </para>
 </sect1>

 <sect1 id="ddl-rowsecurity">
<!--
  <title>Row Security Policies</title>
-->
  <title>行セキュリティポリシー</title>

  <indexterm zone="ddl-rowsecurity">
<!--
   <primary>row-level security</primary>
-->
   <primary>行単位セキュリティ</primary>
  </indexterm>

  <indexterm zone="ddl-rowsecurity">
<!--
   <primary>policy</primary>
-->
   <primary>ポリシー</primary>
  </indexterm>

  <para>
<!--
   In addition to the SQL-standard <link linkend="ddl-priv">privilege
   system</link> available through <xref linkend="sql-grant"/>,
   tables can have <firstterm>row security policies</firstterm> that restrict,
   on a per-user basis, which rows can be returned by normal queries
   or inserted, updated, or deleted by data modification commands.
   This feature is also known as <firstterm>Row-Level Security</firstterm>.
   By default, tables do not have any policies, so that if a user has
   access privileges to a table according to the SQL privilege system,
   all rows within it are equally available for querying or updating.
-->
<xref linkend="sql-grant"/>によって利用できるSQL標準の<link linkend="ddl-priv">権限システム</link>に加えて、通常の問い合わせでどの行が戻され、データ更新のコマンドでどの行を挿入、更新、削除できるかをユーザ単位で制限する<firstterm>行セキュリティポリシー</firstterm>をテーブルに定義できます。
この機能は<firstterm>行単位セキュリティ</firstterm>としても知られています。
デフォルトではテーブルには何もポリシーはなく、SQLの権限システムによってテーブルのアクセス権限があるユーザは、テーブル内のすべての行について同じように、問い合わせや更新をすることができます。
  </para>

  <para>
<!--
   When row security is enabled on a table (with
   <link linkend="sql-altertable">ALTER TABLE ... ENABLE ROW LEVEL
   SECURITY</link>), all normal access to the table for selecting rows or
   modifying rows must be allowed by a row security policy.  (However, the
   table's owner is typically not subject to row security policies.)  If no
   policy exists for the table, a default-deny policy is used, meaning that
   no rows are visible or can be modified.  Operations that apply to the
   whole table, such as <command>TRUNCATE</command> and <literal>REFERENCES</literal>,
   are not subject to row security.
-->
テーブルの行セキュリティが有効の場合（<link linkend="sql-altertable">ALTER TABLE ... ENABLE ROW LEVEL SECURITY</link>を使います）、行の検索や行の更新のための通常のテーブルアクセスはすべて、行セキュリティポリシーによって許可される必要があります。
（ただし、テーブルの所有者は典型的には行セキュリティポリシーの対象とはなりません。）
テーブルにポリシーが存在しない場合は、デフォルト拒否のポリシーが使われて、どの行も見ることも更新することもできなくなります。
<command>TRUNCATE</command>や<literal>REFERENCES</literal>など、テーブル全体に対する操作は行セキュリティの対象とはなりません。
  </para>

  <para>
<!--
   Row security policies can be specific to commands, or to roles, or to
   both.  A policy can be specified to apply to <literal>ALL</literal>
   commands, or to <literal>SELECT</literal>, <literal>INSERT</literal>, <literal>UPDATE</literal>,
   or <literal>DELETE</literal>.  Multiple roles can be assigned to a given
   policy, and normal role membership and inheritance rules apply.
-->
行セキュリティポリシーは特定のコマンド、特定のロール、あるいはその両方に対して定義できます。
ポリシーは<literal>ALL</literal>つまりすべてのコマンドに対して適用、あるいは<literal>SELECT</literal>、<literal>INSERT</literal>、<literal>UPDATE</literal>、<literal>DELETE</literal>に適用することを指定できます。
1つのポリシーを複数のロールに割り当てることができ、通常のロールのメンバ資格と継承の規則が当てはまります。
  </para>

  <para>
<!--
   To specify which rows are visible or modifiable according to a policy,
   an expression is required that returns a Boolean result.  This
   expression will be evaluated for each row prior to any conditions or
   functions coming from the user's query.  (The only exceptions to this
   rule are <literal>leakproof</literal> functions, which are guaranteed to
   not leak information; the optimizer may choose to apply such functions
   ahead of the row-security check.)  Rows for which the expression does
   not return <literal>true</literal> will not be processed.  Separate expressions
   may be specified to provide independent control over the rows which are
   visible and the rows which are allowed to be modified.  Policy
   expressions are run as part of the query and with the privileges of the
   user running the query, although security-definer functions can be used
   to access data not available to the calling user.
-->
ポリシーでどの行が可視である、あるいは更新可能であるかを指定するために、ブーリアン値を返す式が必要です。
ユーザの問い合わせにあるどの条件や関数よりも前に、この式が各行について評価されます。
（この規則の例外は、情報リークがないことが保証される<literal>leakproof</literal>関数だけです。
行セキュリティの確認の前にこのような関数を適用することをオプティマイザが選択することがあります。）
式が<literal>true</literal>を返さない行は処理対象になりません。
可視である行と変更可能な行について独立した制御ができるように、別々の式を指定することも可能です。
ポリシーの式は問い合わせの一部分として、問い合わせをしているユーザの権限で実行されます。
ただし、呼び出しユーザに利用できないデータにアクセスするために、セキュリティ定義関数を使うことができます。
  </para>

  <para>
<!--
   Superusers and roles with the <literal>BYPASSRLS</literal> attribute always
   bypass the row security system when accessing a table.  Table owners
   normally bypass row security as well, though a table owner can choose to
   be subject to row security with <link linkend="sql-altertable">ALTER
   TABLE ... FORCE ROW LEVEL SECURITY</link>.
-->
スーパーユーザ、および<literal>BYPASSRLS</literal>属性のあるロールは、テーブルへのアクセス時に、常に行セキュリティシステムを無視します。
テーブルの所有者も通常は行セキュリティを無視しますが、<link linkend="sql-altertable">ALTER TABLE ... FORCE ROW LEVEL SECURITY</link>により、テーブルの所有者も行セキュリティの対象となることができます。
  </para>

  <para>
<!--
   Enabling and disabling row security, as well as adding policies to a
   table, is always the privilege of the table owner only.
-->
行セキュリティの有効化、無効化、およびポリシーのテーブルへの追加は、常に、テーブルの所有者のみの権限です。
  </para>

  <para>
<!--
   Policies are created using the <xref linkend="sql-createpolicy"/>
   command, altered using the <xref linkend="sql-alterpolicy"/> command,
   and dropped using the <xref linkend="sql-droppolicy"/> command.  To
   enable and disable row security for a given table, use the
   <xref linkend="sql-altertable"/> command.
-->
ポリシーは<xref linkend="sql-createpolicy"/>コマンドで作成され、<xref linkend="sql-alterpolicy"/>コマンドで変更され、<xref linkend="sql-droppolicy"/>コマンドで削除されます。
テーブルの行セキュリティを有効に、あるいは無効にするには<xref linkend="sql-altertable"/>コマンドを使います。
  </para>

  <para>
<!--
   Each policy has a name and multiple policies can be defined for a
   table.  As policies are table-specific, each policy for a table must
   have a unique name.  Different tables may have policies with the
   same name.
-->
各ポリシーには名前があり、1つのテーブルに複数のポリシーを定義することができます。
ポリシーはテーブルごとに定義されるので、1つのテーブルの各ポリシーは異なる名前でなければなりません。
異なるテーブルであれば、同じ名前のポリシーが存在しても構いません。
  </para>

  <para>
<!--
   When multiple policies apply to a given query, they are combined using
   either <literal>OR</literal> (for permissive policies, which are the
   default) or using <literal>AND</literal> (for restrictive policies).
   This is similar to the rule that a given role has the privileges
   of all roles that they are a member of.  Permissive vs. restrictive
   policies are discussed further below.
-->
ある問い合わせに複数のポリシーが適用される場合、（デフォルトの許容(permissive)ポリシーについては）<literal>OR</literal>または（制限(restrictive)ポリシーについては） <literal>AND</literal>を使って結合されます。
これは、あるロールが、それが属するすべてのロールの権限を合わせ持つのと類似しています。
許容ポリシーと制限ポリシーについては以下で更に説明します。
  </para>

  <para>
<!--
   As a simple example, here is how to create a policy on
   the <literal>account</literal> relation to allow only members of
   the <literal>managers</literal> role to access rows, and only rows of their
   accounts:
-->
簡単な例として、<literal>managers</literal>ロールのメンバーだけが行にアクセスでき、かつ自分のアカウントの行のみアクセスできるポリシーを<literal>account</literal>リレーション上に作成する方法を以下に示します。
  </para>

<programlisting>
CREATE TABLE accounts (manager text, company text, contact_email text);

ALTER TABLE accounts ENABLE ROW LEVEL SECURITY;

CREATE POLICY account_managers ON accounts TO managers
    USING (manager = current_user);
</programlisting>

  <para>
<!--
   The policy above implicitly provides a <literal>WITH CHECK</literal>
   clause identical to its <literal>USING</literal> clause, so that the
   constraint applies both to rows selected by a command (so a manager
   cannot <command>SELECT</command>, <command>UPDATE</command>,
   or <command>DELETE</command> existing rows belonging to a different
   manager) and to rows modified by a command (so rows belonging to a
   different manager cannot be created via <command>INSERT</command>
   or <command>UPDATE</command>).
-->
上記のポリシーは、上記の<literal>USING</literal>句と同じ<literal>WITH CHECK</literal>句を暗黙的に提供するので、制約は、コマンドが選択した行にも適用されますし（ですから、マネージャは、違うマネージャに属する既存の行に対して<command>SELECT</command>、<command>UPDATE</command>、<command>DELETE</command>を発行することはできません）、コマンドが変更した行にも適用されます（ですから、違うマネージャに属する行を、<command>INSERT</command>あるいは<command>UPDATE</command>で作ることはできません）。
  </para>

  <para>
<!--
   If no role is specified, or the special user name
   <literal>PUBLIC</literal> is used, then the policy applies to all
   users on the system.  To allow all users to access only their own row in
   a <literal>users</literal> table, a simple policy can be used:
-->
ロールが指定されなかった場合、あるいは特別なユーザ名<literal>PUBLIC</literal>が指定された場合、ポリシーはシステム上の全ユーザに適用されます。
すべてのユーザが<literal>users</literal>テーブルの自分自身の行にだけアクセスできるようにするためには、次の簡単なポリシーが使用できます。
  </para>

<programlisting>
CREATE POLICY user_policy ON users
    USING (user_name = current_user);
</programlisting>

  <para>
<!--
   This works similarly to the previous example.
-->
これは前の例と同じように動きます。
  </para>

  <para>
<!--
   To use a different policy for rows that are being added to the table
   compared to those rows that are visible, multiple policies can be
   combined.  This pair of policies would allow all users to view all rows
   in the <literal>users</literal> table, but only modify their own:
-->
テーブルに追加される行に対し、可視である行とは異なるポリシーを使用する場合は、複数のポリシーを組み合わせることができます。
組み合わせたポリシーにより、すべてのユーザが<literal>users</literal>テーブルのすべての行を見ることができますが、自分自身の行だけしか更新できません。
  </para>

<programlisting>
CREATE POLICY user_sel_policy ON users
    FOR SELECT
    USING (true);
CREATE POLICY user_mod_policy ON users
    USING (user_name = current_user);
</programlisting>

  <para>
<!--
   In a <command>SELECT</command> command, these two policies are combined
   using <literal>OR</literal>, with the net effect being that all rows
   can be selected.  In other command types, only the second policy applies,
   so that the effects are the same as before.
-->
<command>SELECT</command>コマンドでは、<literal>OR</literal>を使って2つのポリシーが組み合わされ、すべての行を検索できる効果をもたらします。
他のコマンドに対しては、二番目のポリシーだけが適用され、以前と効果は同じです。
  </para>

  <para>
<!--
   Row security can also be disabled with the <command>ALTER TABLE</command>
   command.  Disabling row security does not remove any policies that are
   defined on the table; they are simply ignored.  Then all rows in the
   table are visible and modifiable, subject to the standard SQL privileges
   system.
-->
行セキュリティは<command>ALTER TABLE</command>で無効にすることもできます。
行セキュリティを無効にしても、テーブルに定義されているポリシーは削除されず、単に無視されるだけになります。
このときはSQL標準の権限システムに従って、すべての行が可視で更新可能になります。
  </para>

  <para>
<!--
   Below is a larger example of how this feature can be used in production
   environments.  The table <literal>passwd</literal> emulates a Unix password
   file:
-->
以下のより大きな例で、この機能が実運用の環境で如何にして使えるかを示します。
<literal>passwd</literal>テーブルはUnixのパスワードファイルと同等のものです。
  </para>

<programlisting>
<!--
&#045;- Simple passwd-file based example
-->
-- passwdファイルに基づく簡単な例
CREATE TABLE passwd (
  user_name             text UNIQUE NOT NULL,
  pwhash                text,
  uid                   int  PRIMARY KEY,
  gid                   int  NOT NULL,
  real_name             text NOT NULL,
  home_phone            text,
  extra_info            text,
  home_dir              text NOT NULL,
  shell                 text NOT NULL
);

<!--
CREATE ROLE admin;  &#045;- Administrator
CREATE ROLE bob;    &#045;- Normal user
CREATE ROLE alice;  &#045;- Normal user
-->
CREATE ROLE admin;  -- 管理者
CREATE ROLE bob;    -- 一般ユーザ
CREATE ROLE alice;  -- 一般ユーザ


<!--
&#045;- Populate the table
-->
-- テーブルに値を入れる
INSERT INTO passwd VALUES
  ('admin','xxx',0,0,'Admin','111-222-3333',null,'/root','/bin/dash');
INSERT INTO passwd VALUES
  ('bob','xxx',1,1,'Bob','123-456-7890',null,'/home/bob','/bin/zsh');
INSERT INTO passwd VALUES
  ('alice','xxx',2,1,'Alice','098-765-4321',null,'/home/alice','/bin/zsh');

<!--
&#045;- Be sure to enable row level security on the table
-->
-- テーブルの行単位セキュリティを有効にする
ALTER TABLE passwd ENABLE ROW LEVEL SECURITY;

<!--
&#045;- Create policies
&#045;- Administrator can see all rows and add any rows
-->
-- ポリシーを作成する
-- 管理者はすべての行を見ることができ、どんな行でも追加できる
CREATE POLICY admin_all ON passwd TO admin USING (true) WITH CHECK (true);
<!--
&#045;- Normal users can view all rows
-->
-- 一般ユーザはすべての行を見ることができる
CREATE POLICY all_view ON passwd FOR SELECT USING (true);
<!--
&#045;- Normal users can update their own records, but
&#045;- limit which shells a normal user is allowed to set
-->
-- 一般ユーザは自身のレコードを更新できるが、
-- 変更できるのは使用するシェルだけに制限する
CREATE POLICY user_mod ON passwd FOR UPDATE
  USING (current_user = user_name)
  WITH CHECK (
    current_user = user_name AND
    shell IN ('/bin/bash','/bin/sh','/bin/dash','/bin/zsh','/bin/tcsh')
  );

<!--
&#045;- Allow admin all normal rights
-->
-- adminにはすべての通常の権限を付与する
GRANT SELECT, INSERT, UPDATE, DELETE ON passwd TO admin;
<!--
&#045;- Users only get select access on public columns
-->
-- 一般ユーザは公開列にSELECTでアクセスできるだけとする
GRANT SELECT
  (user_name, uid, gid, real_name, home_phone, extra_info, home_dir, shell)
  ON passwd TO public;
<!--
&#045;- Allow users to update certain columns
-->
-- 特定の列についてはユーザによる更新を許可する
GRANT UPDATE
  (pwhash, real_name, home_phone, extra_info, shell)
  ON passwd TO public;
</programlisting>

  <para>
<!--
   As with any security settings, it's important to test and ensure that
   the system is behaving as expected.  Using the example above, this
   demonstrates that the permission system is working properly.
-->
どんなセキュリティ設定でも同じですが、システムが期待通りに動作していることをテストして確認することが重要です。
上の例を利用して、以下ではパーミッションのシステムが適切に動作していることを示します。
  </para>

<programlisting>
<!--
&#045;- admin can view all rows and fields
-->
-- adminはすべての行と列を見ることができる
postgres=&gt; set role admin;
SET
postgres=&gt; table passwd;
 user_name | pwhash | uid | gid | real_name |  home_phone  | extra_info | home_dir    |   shell
-----------+--------+-----+-----+-----------+--------------+------------+-------------+-----------
 admin     | xxx    |   0 |   0 | Admin     | 111-222-3333 |            | /root       | /bin/dash
 bob       | xxx    |   1 |   1 | Bob       | 123-456-7890 |            | /home/bob   | /bin/zsh
 alice     | xxx    |   2 |   1 | Alice     | 098-765-4321 |            | /home/alice | /bin/zsh
(3 rows)

<!--
&#045;- Aliceに何ができるか試してみる
-->
-- Test what Alice is able to do
postgres=&gt; set role alice;
SET
postgres=&gt; table passwd;
ERROR:  permission denied for relation passwd
postgres=&gt; select user_name,real_name,home_phone,extra_info,home_dir,shell from passwd;
 user_name | real_name |  home_phone  | extra_info | home_dir    |   shell
-----------+-----------+--------------+------------+-------------+-----------
 admin     | Admin     | 111-222-3333 |            | /root       | /bin/dash
 bob       | Bob       | 123-456-7890 |            | /home/bob   | /bin/zsh
 alice     | Alice     | 098-765-4321 |            | /home/alice | /bin/zsh
(3 rows)

postgres=&gt; update passwd set user_name = 'joe';
ERROR:  permission denied for relation passwd
<!--
&#045;- Alice is allowed to change her own real_name, but no others
-->
-- Aliceは自分のreal_nameを変更できるが、他は変更できない
postgres=&gt; update passwd set real_name = 'Alice Doe';
UPDATE 1
postgres=&gt; update passwd set real_name = 'John Doe' where user_name = 'admin';
UPDATE 0
postgres=&gt; update passwd set shell = '/bin/xx';
ERROR:  new row violates WITH CHECK OPTION for "passwd"
postgres=&gt; delete from passwd;
ERROR:  permission denied for relation passwd
postgres=&gt; insert into passwd (user_name) values ('xxx');
ERROR:  permission denied for relation passwd
<!--
&#045;- Alice can change her own password; RLS silently prevents updating other rows
-->
-- Aliceは自分のパスワードを変更できる。
-- RLSにより他の行は更新されないが、何も報告されない。
postgres=&gt; update passwd set pwhash = 'abc';
UPDATE 1
</programlisting>

  <para>
<!--
   All of the policies constructed thus far have been permissive policies,
   meaning that when multiple policies are applied they are combined using
   the <quote>OR</quote> Boolean operator.  While permissive policies can be constructed
   to only allow access to rows in the intended cases, it can be simpler to
   combine permissive policies with restrictive policies (which the records
   must pass and which are combined using the <quote>AND</quote> Boolean operator).
   Building on the example above, we add a restrictive policy to require
   the administrator to be connected over a local Unix socket to access the
   records of the <literal>passwd</literal> table:
-->
ここまでで作成したポリシーはすべて許容ポリシーで、つまり複数のポリシーが適用される場合、それらは論理演算子<quote>OR</quote>を使って結合されるものでした。
意図した場合にのみ行へのアクセスが許されるよう許容ポリシーを構築することは可能ですが、許容ポリシーを制限ポリシーと組み合わせることで、より単純にすることが可能です（制限ポリシーはレコードが満たさなければならないポリシーで、論理演算子<quote>AND</quote>を使って結合されます）。
上記の例に重ねて、管理者がローカルのUnixソケットを通して接続して<literal>passwd</literal>テーブルのレコードにアクセスすることを要求する制限ポリシーを追加してみます。
  </para>

<programlisting>
CREATE POLICY admin_local_only ON passwd AS RESTRICTIVE TO admin
    USING (pg_catalog.inet_client_addr() IS NULL);
</programlisting>

  <para>
<!--
   We can then see that an administrator connecting over a network will not
   see any records, due to the restrictive policy:
-->
こうすると以下のように、制限ポリシーにより、ネットワーク経由で接続している管理者にはレコードが見えないことがわかります。
  </para>

<programlisting>
=&gt; SELECT current_user;
 current_user 
--------------
 admin
(1 row)

=&gt; select inet_client_addr();
 inet_client_addr 
------------------
 127.0.0.1
(1 row)

=&gt; SELECT current_user;
 current_user 
--------------
 admin
(1 row)

=&gt; TABLE passwd;
 user_name | pwhash | uid | gid | real_name | home_phone | extra_info | home_dir | shell
-----------+--------+-----+-----+-----------+------------+------------+----------+-------
(0 rows)

=&gt; UPDATE passwd set pwhash = NULL;
UPDATE 0
</programlisting>

  <para>
<!--
   Referential integrity checks, such as unique or primary key constraints
   and foreign key references, always bypass row security to ensure that
   data integrity is maintained.  Care must be taken when developing
   schemas and row level policies to avoid <quote>covert channel</quote> leaks of
   information through such referential integrity checks.
-->
一意性制約、主キー制約、外部キー制約などの参照整合性確認は、データの整合性を維持するため、常に行セキュリティを無視します。
スキーマと行単位セキュリティの開発において、このような参照整合性確認により<quote>カバートチャネル(covert channel)</quote>の情報漏洩が起こらないようにするため、注意が必要です。
  </para>

  <para>
<!--
   In some contexts it is important to be sure that row security is
   not being applied.  For example, when taking a backup, it could be
   disastrous if row security silently caused some rows to be omitted
   from the backup.  In such a situation, you can set the
   <xref linkend="guc-row-security"/> configuration parameter
   to <literal>off</literal>.  This does not in itself bypass row security;
   what it does is throw an error if any query's results would get filtered
   by a policy.  The reason for the error can then be investigated and
   fixed.
-->
状況によっては、行セキュリティが適用されないことを確実にするのが重要になります。
例えばバックアップを取るとき、行セキュリティのために、何のエラーや警告もなしに一部の行がバックアップされないとすると、破滅的です。
このような状況では、設定パラメータ<xref linkend="guc-row-security"/>を<literal>off</literal>にすることができます。
これ自体は行セキュリティを無視するわけではなく、問い合わせの結果がポリシーによって影響を受ける場合にエラーを発生させます。
その後でエラーの原因を調査して解決することができます。
  </para>

  <para>
<!--
   In the examples above, the policy expressions consider only the current
   values in the row to be accessed or updated.  This is the simplest and
   best-performing case; when possible, it's best to design row security
   applications to work this way.  If it is necessary to consult other rows
   or other tables to make a policy decision, that can be accomplished using
   sub-<command>SELECT</command>s, or functions that contain <command>SELECT</command>s,
   in the policy expressions.  Be aware however that such accesses can
   create race conditions that could allow information leakage if care is
   not taken.  As an example, consider the following table design:
-->
上の例では、ポリシーの式はアクセス対象または更新対象の行の現在の値のみを考慮していました。
これは最も単純で、しかも効率の良い場合です。
可能であれば、行セキュリティの適用はこのように動作するよう設計するのが最善です。
ポリシーの決定をするために他の行あるいは他のテーブルを参照する必要がある場合は、ポリシーの式で副<command>SELECT</command>を使う、あるいは<command>SELECT</command>を含む関数を使うことができます。
ただし、そのようなアクセスは注意深く設計しなければ、情報漏洩を起こすような競合条件を作り出す場合があることに注意して下さい。
例えば、以下のテーブル設計を考えます。
  </para>

<programlisting>
<!--
&#045;- definition of privilege groups
-->
-- 権限グループの定義
CREATE TABLE groups (group_id int PRIMARY KEY,
                     group_name text NOT NULL);

INSERT INTO groups VALUES
  (1, 'low'),
  (2, 'medium'),
  (5, 'high');

<!--
GRANT ALL ON groups TO alice;  &#045;- alice is the administrator
-->
GRANT ALL ON groups TO alice;  -- aliceが管理者
GRANT SELECT ON groups TO public;

<!--
&#045;- definition of users' privilege levels
-->
-- ユーザの権限レベルの定義
CREATE TABLE users (user_name text PRIMARY KEY,
                    group_id int NOT NULL REFERENCES groups);

INSERT INTO users VALUES
  ('alice', 5),
  ('bob', 2),
  ('mallory', 2);

GRANT ALL ON users TO alice;
GRANT SELECT ON users TO public;

<!--
&#045;- table holding the information to be protected
-->
-- 保護される情報を保持するテーブル
CREATE TABLE information (info text,
                          group_id int NOT NULL REFERENCES groups);

INSERT INTO information VALUES
  ('barely secret', 1),
  ('slightly secret', 2),
  ('very secret', 5);

ALTER TABLE information ENABLE ROW LEVEL SECURITY;

<!--
&#045;- a row should be visible to/updatable by users whose security group_id is
&#045;- greater than or equal to the row's group_id
-->
-- セキュリティのgroup_idが行のgroup_idより大きいか等しいユーザは
-- その行を見ること、更新することが可能
CREATE POLICY fp_s ON information FOR SELECT
  USING (group_id &lt;= (SELECT group_id FROM users WHERE user_name = current_user));
CREATE POLICY fp_u ON information FOR UPDATE
  USING (group_id &lt;= (SELECT group_id FROM users WHERE user_name = current_user));

<!--
&#045;- we rely only on RLS to protect the information table
-->
-- informationテーブルを保護するのにRLSのみに依存する
GRANT ALL ON information TO public;
</programlisting>

  <para>
<!--
   Now suppose that <literal>alice</literal> wishes to change the <quote>slightly
   secret</quote> information, but decides that <literal>mallory</literal> should not
   be trusted with the new content of that row, so she does:
-->
ここで<literal>alice</literal>が<quote>slightly secret</quote>の情報を更新したいが、この行の新しい内容に関して<literal>mallory</literal>は信頼すべきでないと判断しました。
そこで、彼女は次のようにします。
  </para>

<programlisting>
BEGIN;
UPDATE users SET group_id = 1 WHERE user_name = 'mallory';
UPDATE information SET info = 'secret from mallory' WHERE group_id = 2;
COMMIT;
</programlisting>

  <para>
<!--
   That looks safe; there is no window wherein <literal>mallory</literal> should be
   able to see the <quote>secret from mallory</quote> string.  However, there is
   a race condition here.  If <literal>mallory</literal> is concurrently doing,
   say,
-->
これは安全なように見えます。
<literal>mallory</literal>が<quote>secret from mallory</quote>の文字列を見ることができる隙はありません。
しかし、ここには競合条件があります。
例えば、<literal>mallory</literal>が同時に以下を実行していたとしましょう。
<programlisting>
SELECT * FROM information WHERE group_id = 2 FOR UPDATE;
</programlisting>
<!--
   and her transaction is in <literal>READ COMMITTED</literal> mode, it is possible
   for her to see <quote>secret from mallory</quote>.  That happens if her
   transaction reaches the <structname>information</structname> row just
   after <literal>alice</literal>'s does.  It blocks waiting
   for <literal>alice</literal>'s transaction to commit, then fetches the updated
   row contents thanks to the <literal>FOR UPDATE</literal> clause.  However, it
   does <emphasis>not</emphasis> fetch an updated row for the
   implicit <command>SELECT</command> from <structname>users</structname>, because that
   sub-<command>SELECT</command> did not have <literal>FOR UPDATE</literal>; instead
   the <structname>users</structname> row is read with the snapshot taken at the start
   of the query.  Therefore, the policy expression tests the old value
   of <literal>mallory</literal>'s privilege level and allows her to see the
   updated row.
-->
ここで彼女のトランザクションが<literal>READ COMMITTED</literal>モードなら、彼女は<quote>secret from mallory</quote>を見ることが可能です。
それは彼女のトランザクションが、<literal>alice</literal>のトランザクションの直後に<structname>information</structname>の行にアクセスした場合に発生します。
それは<literal>alice</literal>のトランザクションがコミットされるのを待ってブロックされ、次に<literal>FOR UPDATE</literal>句があるため、更新後の行の内容をフェッチします。
しかし、<structname>users</structname>からの暗示的な<command>SELECT</command>では更新後の行をフェッチ<emphasis>しません</emphasis>。
なぜなら、その副<command>SELECT</command>には<literal>FOR UPDATE</literal>がないため、<structname>users</structname>の行は問い合わせの開始時に取得したスナップショットから読まれるからです。
そのため、ポリシーの式は<literal>mallory</literal>の権限レベルの古い値について検査し、更新後の行を見ることを許してしまいます。
  </para>

  <para>
<!--
   There are several ways around this problem.  One simple answer is to use
   <literal>SELECT ... FOR SHARE</literal> in sub-<command>SELECT</command>s in row
   security policies.  However, that requires granting <literal>UPDATE</literal>
   privilege on the referenced table (here <structname>users</structname>) to the
   affected users, which might be undesirable.  (But another row security
   policy could be applied to prevent them from actually exercising that
   privilege; or the sub-<command>SELECT</command> could be embedded into a security
   definer function.)  Also, heavy concurrent use of row share locks on the
   referenced table could pose a performance problem, especially if updates
   of it are frequent.  Another solution, practical if updates of the
   referenced table are infrequent, is to take an exclusive lock on the
   referenced table when updating it, so that no concurrent transactions
   could be examining old row values.  Or one could just wait for all
   concurrent transactions to end after committing an update of the
   referenced table and before making changes that rely on the new security
   situation.
-->
この問題を回避する方法はいくつかあります。
一つの簡単な答は行セキュリティポリシーの副<command>SELECT</command>で<literal>SELECT ... FOR SHARE</literal>を使うことです。
しかし、これは影響を受けるユーザに対し、参照先テーブル（この場合は<structname>users</structname>）の<literal>UPDATE</literal>権限を付与する必要があり、望ましくないかもしれません。
（しかし、もう一つの行セキュリティポリシーを適用して、彼らが実際にその権限を行使することを防ぐことはできます。
また、副<command>SELECT</command>をセキュリティ定義関数内に埋め込むことも可能です。）
また、参照先テーブルに行共有ロックが同時に大量に発生するとパフォーマンス問題が起きるかもしれません。
特にそのテーブルの更新が多いときは問題になるでしょう。
別の解決策で、参照先テーブルの更新が少ない場合に現実的なのは、参照先テーブルの更新時に排他ロックを取得するものです。
そうすれば、同時実行のトランザクションが行の古い値を調べることはできません。
あるいは、参照先のテーブルの更新をコミットした後、単にすべての同時実行トランザクションが終わるのを待ってから、新しいセキュリティ状況に依存する変更をする、ということもできます。
  </para>

  <para>
<!--
   For additional details see <xref linkend="sql-createpolicy"/>
   and <xref linkend="sql-altertable"/>.
-->
更なる詳細は<xref linkend="sql-createpolicy"/>と<xref linkend="sql-altertable"/>を参照して下さい。
  </para>

 </sect1>

 <sect1 id="ddl-schemas">
<!--
  <title>Schemas</title>
-->
  <title>スキーマ</title>

  <indexterm zone="ddl-schemas">
<!--
   <primary>schema</primary>
-->
   <primary>スキーマ</primary>
  </indexterm>

  <para>
<!--
   A <productname>PostgreSQL</productname> database cluster contains
   one or more named databases.  Roles and a few other object types are
   shared across the entire cluster.  A client connection to the server
   can only access data in a single database, the one specified in the
   connection request.
-->
<productname>PostgreSQL</productname>データベースクラスタには、1つ以上の名前付きデータベースが含まれます。
ロールおよびいくつかの他のタイプのオブジェクトはクラスタ全体で共有されます。
サーバに接続しているクライアント接続は、単一のデータベース、つまり接続要求で指定したデータベース内のデータにしかアクセスできません。
  </para>

  <note>
   <para>
<!--
    Users of a cluster do not necessarily have the privilege to access every
    database in the cluster.  Sharing of role names means that there
    cannot be different roles named, say, <literal>joe</literal> in two databases
    in the same cluster; but the system can be configured to allow
    <literal>joe</literal> access to only some of the databases.
-->
クラスタのユーザは、クラスタ内の全てのデータベースへのアクセス権限を持っているとは限りません。
ロール名を共有するということは、例えば<literal>joe</literal>という同じロール名を持つ異なるユーザが同じクラスタ内の2つのデータベースに存在することはできないということです。
しかし、<literal>joe</literal>が一部のデータベースにのみアクセスできるようにシステムを構成することはできます。
   </para>
  </note>

  <para>
<!--
   A database contains one or more named <firstterm>schemas</firstterm>, which
   in turn contain tables.  Schemas also contain other kinds of named
   objects, including data types, functions, and operators.  The same
   object name can be used in different schemas without conflict; for
   example, both <literal>schema1</literal> and <literal>myschema</literal> can
   contain tables named <literal>mytable</literal>.  Unlike databases,
   schemas are not rigidly separated: a user can access objects in any
   of the schemas in the database they are connected to, if they have
   privileges to do so.
-->
データベースには、1つ以上の名前付き<firstterm>スキーマ</firstterm>が含まれ、スキーマにはテーブルが含まれます。
スキーマには、データ型、関数および演算子などの他の名前付きオブジェクトも含まれます。
同じオブジェクト名を異なるスキーマで使用しても競合は起こりません。
例えば、<literal>schema1</literal>と<literal>myschema</literal>の両方のスキーマに<literal>mytable</literal>というテーブルが含まれていても構いません。
スキーマはデータベースとは異なり厳格に分離されていないので、ユーザは、権限さえ持っていれば接続しているデータベース内のどのスキーマのオブジェクトにでもアクセスすることができます。
  </para>

  <para>
<!--
   There are several reasons why one might want to use schemas:
-->
スキーマの使用が好まれる理由はいくつかあります。

   <itemizedlist>
    <listitem>
     <para>
<!--
      To allow many users to use one database without interfering with
      each other.
-->
1つのデータベースを多数のユーザが互いに干渉することなく使用できるようにするため。
     </para>
    </listitem>

    <listitem>
     <para>
<!--
      To organize database objects into logical groups to make them
      more manageable.
-->
管理しやすくなるよう、データベースオブジェクトを論理グループに編成するため。
     </para>
    </listitem>

    <listitem>
     <para>
<!--
      Third-party applications can be put into separate schemas so
      they do not collide with the names of other objects.
-->
サードパーティのアプリケーションを別々のスキーマに入れることにより、他のオブジェクトの名前と競合しないようにするため。
     </para>
    </listitem>
   </itemizedlist>

<!--
   Schemas are analogous to directories at the operating system level,
   except that schemas cannot be nested.
-->
スキーマは、入れ子にできないという点を除き、オペレーティングシステムのディレクトリと似ています。
  </para>

  <sect2 id="ddl-schemas-create">
<!--
   <title>Creating a Schema</title>
-->
   <title>スキーマの作成</title>

   <indexterm zone="ddl-schemas-create">
<!--
    <primary>schema</primary>
    <secondary>creating</secondary>
-->
    <primary>スキーマ</primary>
    <secondary>の作成</secondary>
   </indexterm>

   <para>
<!--
    To create a schema, use the <xref linkend="sql-createschema"/>
    command.  Give the schema a name
    of your choice.  For example:
-->
スキーマを作成するには、<xref linkend="sql-createschema"/>コマンドを使用します。
スキーマに自由に名前を付けます。
例を示します。
<programlisting>
CREATE SCHEMA myschema;
</programlisting>
   </para>

   <indexterm>
<!--
    <primary>qualified name</primary>
-->
    <primary>修飾名</primary>
   </indexterm>

   <indexterm>
<!--
    <primary>name</primary>
    <secondary>qualified</secondary>
-->
    <primary>名前</primary>
    <secondary>修飾された</secondary>
   </indexterm>

   <para>
<!--
    To create or access objects in a schema, write a
    <firstterm>qualified name</firstterm> consisting of the schema name and
    table name separated by a dot:
-->
スキーマ内にオブジェクトを作成したりこれにアクセスするには、スキーマ名とテーブル名をドットで区切った<firstterm>修飾名</firstterm>を書きます。
<synopsis>
<replaceable>schema</replaceable><literal>.</literal><replaceable>table</replaceable>
</synopsis>
<!--
    This works anywhere a table name is expected, including the table
    modification commands and the data access commands discussed in
    the following chapters.
    (For brevity we will speak of tables only, but the same ideas apply
    to other kinds of named objects, such as types and functions.)
-->
この方法は、後の章で説明するテーブル変更コマンドやデータアクセスコマンドなど、テーブル名を必要とする場合すべてに使用できます。
（話を簡単にするため、テーブルについてのみ述べます。
しかし型や関数といった名前付きのオブジェクトの他の種類について同様の考え方が適用できます。）
   </para>

   <para>
<!--
    Actually, the even more general syntax
-->
実際には、より一般的な以下の構文
<synopsis>
<replaceable>database</replaceable><literal>.</literal><replaceable>schema</replaceable><literal>.</literal><replaceable>table</replaceable>
</synopsis>
<!--
    can be used too, but at present this is just for <foreignphrase>pro
    forma</foreignphrase> compliance with the SQL standard.  If you write a database name,
    it must be the same as the database you are connected to.
-->
を使用することもできますが、現在ではこの構文は標準SQLに<foreignphrase>形式的に</foreignphrase>準拠するためにのみ存在しています。
記述されるデータベース名は、接続しているデータベースと同じ名前でなければなりません。
   </para>

   <para>
<!--
    So to create a table in the new schema, use:
-->
ですから、新しいスキーマにテーブルを作成するには次のようにします。
<programlisting>
CREATE TABLE myschema.mytable (
 ...
);
</programlisting>
   </para>

   <indexterm>
<!--
    <primary>schema</primary>
    <secondary>removing</secondary>
-->
    <primary>スキーマ</primary>
    <secondary>の削除</secondary>
   </indexterm>

   <para>
<!--
    To drop a schema if it's empty (all objects in it have been
    dropped), use:
-->
空のスキーマ（全てのオブジェクトが削除されたスキーマ）を削除するには次のようにします。
<programlisting>
DROP SCHEMA myschema;
</programlisting>
<!--
    To drop a schema including all contained objects, use:
-->
スキーマ内の全オブジェクトも含めてスキーマを削除する場合には次のようにします。
<programlisting>
DROP SCHEMA myschema CASCADE;
</programlisting>
<!--
    See <xref linkend="ddl-depend"/> for a description of the general
    mechanism behind this.
-->
この背後にある一般的な機構についての詳細は<xref linkend="ddl-depend"/>を参照してください。
   </para>

   <para>
<!--
    Often you will want to create a schema owned by someone else
    (since this is one of the ways to restrict the activities of your
    users to well-defined namespaces).  The syntax for that is:
-->
他のユーザが所有するスキーマを作成したい場合があります（これは他のユーザの活動を明確に定義された名前空間内に制限する方法の1つです）。
そのための構文は次の通りです。
<programlisting>
CREATE SCHEMA <replaceable>schema_name</replaceable> AUTHORIZATION <replaceable>user_name</replaceable>;
</programlisting>
<!--
    You can even omit the schema name, in which case the schema name
    will be the same as the user name.  See <xref
    linkend="ddl-schemas-patterns"/> for how this can be useful.
-->
スキーマ名は省略することもでき、その場合スキーマ名はユーザ名と同じになります。
この構文の便利な使用方法は<xref linkend="ddl-schemas-patterns"/>に記載されています。
   </para>

   <para>
<!--
    Schema names beginning with <literal>pg_</literal> are reserved for
    system purposes and cannot be created by users.
-->
<literal>pg_</literal>で始まるスキーマ名は、システム上の使用のため予約されており、ユーザが作成することはできません。
   </para>
  </sect2>

  <sect2 id="ddl-schemas-public">
<!--
   <title>The Public Schema</title>
-->
   <title>publicスキーマ</title>

   <indexterm zone="ddl-schemas-public">
<!--
    <primary>schema</primary>
    <secondary>public</secondary>
-->
    <primary>スキーマ</primary>
    <secondary>public</secondary>
   </indexterm>

   <para>
<!--
    In the previous sections we created tables without specifying any
    schema names.  By default such tables (and other objects) are
    automatically put into a schema named <quote>public</quote>.  Every new
    database contains such a schema.  Thus, the following are equivalent:
-->
これまでの節ではスキーマ名を指定せずにテーブルを作成してきました。
デフォルトでは、このようなテーブル（および他のオブジェクト）は自動的に<quote>public</quote>という名前のスキーマに入れられます。
新しいデータベースには全てこのようなスキーマが含まれています。
そのため、以下の2つの構文は同等です。
<programlisting>
CREATE TABLE products ( ... );
</programlisting>
<!--
    and:
-->
および
<programlisting>
CREATE TABLE public.products ( ... );
</programlisting>
   </para>
  </sect2>

  <sect2 id="ddl-schemas-path">
<!--
   <title>The Schema Search Path</title>
-->
   <title>スキーマ検索パス</title>

   <indexterm>
<!--
    <primary>search path</primary>
-->
    <primary>検索パス</primary>
   </indexterm>

   <indexterm>
<!--
    <primary>unqualified name</primary>
-->
    <primary>非修飾名</primary>
   </indexterm>

   <indexterm>
<!--
    <primary>name</primary>
    <secondary>unqualified</secondary>
-->
    <primary>名前</primary>
    <secondary>非修飾の</secondary>
   </indexterm>

   <para>
<!--
    Qualified names are tedious to write, and it's often best not to
    wire a particular schema name into applications anyway.  Therefore
    tables are often referred to by <firstterm>unqualified names</firstterm>,
    which consist of just the table name.  The system determines which table
    is meant by following a <firstterm>search path</firstterm>, which is a list
    of schemas to look in.  The first matching table in the search path
    is taken to be the one wanted.  If there is no match in the search
    path, an error is reported, even if matching table names exist
    in other schemas in the database.
-->
修飾名を書くのは手間がかかりますし、どちらにしても、アプリケーションに特定のスキーマ名を書き込まない方が良いことも多いのです。
そのため、テーブルは多くの場合、テーブル名しか持たない<firstterm>非修飾名</firstterm>として参照されます。
システムは、検索するスキーマのリストである<firstterm>検索パス</firstterm>に従って、どのテーブルを指しているのかを判別します。
検索パスで最初に一致したテーブルが、該当テーブルだと解釈されます。
検索パス内に一致するテーブルがないと、データベースの他のスキーマ内に一致するテーブルがある場合でもエラーが報告されます。
   </para>

  <para>
<!--
    The ability to create like-named objects in different schemas complicates
    writing a query that references precisely the same objects every time.  It
    also opens up the potential for users to change the behavior of other
    users' queries, maliciously or accidentally.  Due to the prevalence of
    unqualified names in queries and their use
    in <productname>PostgreSQL</productname> internals, adding a schema
    to <varname>search_path</varname> effectively trusts all users having
    <literal>CREATE</literal> privilege on that schema.  When you run an
    ordinary query, a malicious user able to create objects in a schema of
    your search path can take control and execute arbitrary SQL functions as
    though you executed them.
-->
同じ名前のオブジェクトを異なるスキーマに作成できる結果、正確に同じオブジェクトを参照する問合せを書く作業が、いつも複雑になります。
また、ユーザが悪意を持って、あるいは偶然に他のユーザの問合せの挙動を変える可能性をもたらします。
<productname>PostgreSQL</productname>内部では非修飾名を問合せ中で使うことが一般的なので、<varname>search_path</varname>にスキーマを追加することは、<literal>CREATE</literal>の書き込み権限を持っているすべてのユーザを、実質的に信頼することになります。
あなたが通常の問合せを実行する際、あなたのサーチパス内のスキーマにオブジェクトを作成できる悪意のあるユーザは、支配権を奪い、あたかもあなたが実行したように任意のSQL関数を実行できます。
   </para>

   <indexterm>
<!--
    <primary>schema</primary>
    <secondary>current</secondary>
-->
    <primary>スキーマ</primary>
    <secondary>現在の</secondary>
   </indexterm>

   <para>
<!--
    The first schema named in the search path is called the current schema.
    Aside from being the first schema searched, it is also the schema in
    which new tables will be created if the <command>CREATE TABLE</command>
    command does not specify a schema name.
-->
検索パスの最初に列挙されているスキーマは、「現在のスキーマ」と呼ばれます。
現在のスキーマは、検索される最初のスキーマであると同時に、スキーマ名を指定せずに<command>CREATE TABLE</command>コマンドでテーブルを作成した場合に新しいテーブルが作成されるスキーマでもあります。
   </para>

   <indexterm>
<!--
    <primary><varname>search_path</varname> configuration parameter</primary>
-->
    <primary><varname>search_path</varname>設定パラメータ</primary>
   </indexterm>

   <para>
<!--
    To show the current search path, use the following command:
-->
現行の検索パスを示すには次のコマンドを使用します。
<programlisting>
SHOW search_path;
</programlisting>
<!--
    In the default setup this returns:
-->
デフォルトの設定では次のように返されます。
<screen>
 search_path
--------------
 "$user", public
</screen>
<!--
    The first element specifies that a schema with the same name as
    the current user is to be searched.  If no such schema exists,
    the entry is ignored.  The second element refers to the
    public schema that we have seen already.
-->
最初の要素は、現行ユーザと同じ名前のスキーマを検索することを指定しています。
そのようなスキーマが存在していない場合、この項目は無視されます。
2番目の要素は、先ほど説明したpublicスキーマを参照しています。
   </para>

   <para>
<!--
    The first schema in the search path that exists is the default
    location for creating new objects.  That is the reason that by
    default objects are created in the public schema.  When objects
    are referenced in any other context without schema qualification
    (table modification, data modification, or query commands) the
    search path is traversed until a matching object is found.
    Therefore, in the default configuration, any unqualified access
    again can only refer to the public schema.
-->
実存するスキーマのうち、検索パス内で最初に現れるスキーマが、新規オブジェクトが作成されるデフォルトの場所になります。
これが、デフォルトでオブジェクトがpublicスキーマに作成される理由です。
オブジェクトがスキーマ修飾なしで別の文脈で参照される場合（テーブル変更、データ変更、あるいは問い合わせコマンドなど）、一致するオブジェクトが見つかるまで検索パス内で探索されます。
そのためデフォルト構成では、非修飾のアクセスはpublicスキーマしか参照できません。
   </para>

   <para>
<!--
    To put our new schema in the path, we use:
-->
新しいスキーマをパスに追加するには次のようにします。
<programlisting>
SET search_path TO myschema,public;
</programlisting>
<!--
    (We omit the <literal>$user</literal> here because we have no
    immediate need for it.)  And then we can access the table without
    schema qualification:
-->
（<literal>$user</literal>はまだ必要ないので、ここでは省略しています。）
そして、次のようにしてスキーマ修飾なしでテーブルにアクセスします。
<programlisting>
DROP TABLE mytable;
</programlisting>
<!--
    Also, since <literal>myschema</literal> is the first element in
    the path, new objects would by default be created in it.
-->
また、<literal>myschema</literal>はパス内の最初の要素なので、新しいオブジェクトはデフォルトでここに作成されます。
   </para>

   <para>
<!--
    We could also have written:
-->
以下のように書くこともできます。
<programlisting>
SET search_path TO myschema;
</programlisting>
<!--
    Then we no longer have access to the public schema without
    explicit qualification.  There is nothing special about the public
    schema except that it exists by default.  It can be dropped, too.
-->
このようにすると、今後は修飾名なしでpublicスキーマにアクセスすることができなくなります。
publicスキーマはデフォルトで存在するということ以外に特別な意味はありません。
他のスキーマと同様に削除することもできます。
   </para>

   <para>
<!--
    See also <xref linkend="functions-info"/> for other ways to manipulate
    the schema search path.
-->
スキーマ検索パスを操作する他の方法については<xref linkend="functions-info"/>を参照してください。
   </para>

   <para>
<!--
    The search path works in the same way for data type names, function names,
    and operator names as it does for table names.  Data type and function
    names can be qualified in exactly the same way as table names.  If you
    need to write a qualified operator name in an expression, there is a
    special provision: you must write
-->
検索パスはデータ型名、関数名、演算子名についても、テーブル名の場合と同じように機能します。
データ型および関数の名前は、テーブル名とまったく同じように修飾することができます。
式で修飾演算子名を書く場合には、特別な決まりがあります。
それは以下の通りです。
<synopsis>
<literal>OPERATOR(</literal><replaceable>schema</replaceable><literal>.</literal><replaceable>operator</replaceable><literal>)</literal>
</synopsis>
<!--
    This is needed to avoid syntactic ambiguity.  An example is:
-->
この規則は構文が曖昧になることを防ぐためのものです。
以下に例を示します。
<programlisting>
SELECT 3 OPERATOR(pg_catalog.+) 4;
</programlisting>
<!--
    In practice one usually relies on the search path for operators,
    so as not to have to write anything so ugly as that.
-->
実際の場面ではこのような見づらい構文を書かなくて済むように、演算子についても検索パスが使用されています。
   </para>
  </sect2>

  <sect2 id="ddl-schemas-priv">
<!--
   <title>Schemas and Privileges</title>
-->
   <title>スキーマおよび権限</title>

   <indexterm zone="ddl-schemas-priv">
<!--
    <primary>privilege</primary>
    <secondary sortas="schemas">for schemas</secondary>
-->
    <primary>権限</primary>
    <secondary sortas="schemas">スキーマ用の</secondary>
   </indexterm>

   <para>
<!--
    By default, users cannot access any objects in schemas they do not
    own.  To allow that, the owner of the schema must grant the
    <literal>USAGE</literal> privilege on the schema.  To allow users
    to make use of the objects in the schema, additional privileges
    might need to be granted, as appropriate for the object.
-->
ユーザは、デフォルトでは所有していないスキーマのオブジェクトをアクセスすることはできません。
アクセスするためには、そのスキーマの所有者からスキーマの<literal>USAGE</literal>権限を付与してもらわなければなりません。
そのスキーマ内のオブジェクトに対して操作を行うには、そのオブジェクトに応じて、さらに追加の権限が必要となる場合があります。
   </para>

   <para>
<!--
    A user can also be allowed to create objects in someone else's
    schema.  To allow that, the <literal>CREATE</literal> privilege on
    the schema needs to be granted.  Note that by default, everyone
    has <literal>CREATE</literal> and <literal>USAGE</literal> privileges on
    the schema
    <literal>public</literal>.  This allows all users that are able to
    connect to a given database to create objects in its
    <literal>public</literal> schema.
    Some <link linkend="ddl-schemas-patterns">usage patterns</link> call for
    revoking that privilege:
-->
他のユーザのスキーマ内でオブジェクトを作成できるようにすることも可能です。
それには、スキーマ上で<literal>CREATE</literal>権限が付与されていなければなりません。
デフォルトでは、<literal>public</literal> スキーマに関しては全てのユーザが<literal>CREATE</literal>と<literal>USAGE</literal>権限を持っていることに注意してください。
つまり、全てのユーザは、そのユーザが接続できる任意のデータベース上の<literal>public</literal>スキーマにオブジェクトを作成できるということです。
<link linkend="ddl-schemas-patterns">利用パターン</link>では、その権限を剥奪することを求めています。
<programlisting>
REVOKE CREATE ON SCHEMA public FROM PUBLIC;
</programlisting>
<!--
    (The first <quote>public</quote> is the schema, the second
    <quote>public</quote> means <quote>every user</quote>.  In the
    first sense it is an identifier, in the second sense it is a
    key word, hence the different capitalization; recall the
    guidelines from <xref linkend="sql-syntax-identifiers"/>.)
-->
（最初の<quote>public</quote>はスキーマです。2番目の<quote>public</quote>は<quote>全てのユーザ</quote>を意味します。
最初のpublicは識別子で、2番目のpublicはキーワードなので、それぞれ小文字、大文字を使用しています。<xref linkend="sql-syntax-identifiers"/>のガイドラインを思い出してください。）
   </para>
  </sect2>

  <sect2 id="ddl-schemas-catalog">
<!--
   <title>The System Catalog Schema</title>
-->
   <title>システムカタログスキーマ</title>

   <indexterm zone="ddl-schemas-catalog">
<!--
    <primary>system catalog</primary>
    <secondary>schema</secondary>
-->
    <primary>システムカタログ</primary>
    <secondary>スキーマ</secondary>
   </indexterm>

   <para>
<!--
    In addition to <literal>public</literal> and user-created schemas, each
    database contains a <literal>pg_catalog</literal> schema, which contains
    the system tables and all the built-in data types, functions, and
    operators.  <literal>pg_catalog</literal> is always effectively part of
    the search path.  If it is not named explicitly in the path then
    it is implicitly searched <emphasis>before</emphasis> searching the path's
    schemas.  This ensures that built-in names will always be
    findable.  However, you can explicitly place
    <literal>pg_catalog</literal> at the end of your search path if you
    prefer to have user-defined names override built-in names.
-->
各データベースには、<literal>public</literal>およびユーザ作成のスキーマの他に<literal>pg_catalog</literal>スキーマが含まれています。
このスキーマにはシステムテーブルと全ての組み込みデータ型、関数および演算子が含まれています。
<literal>pg_catalog</literal>は常に検索パスに含まれています。
パスに明示的にリストされていない場合は、パスのスキーマを検索する<emphasis>前</emphasis>に暗黙的に検索されます。
これにより組み込みの名前が常に検索されることが保証されます。
しかし、ユーザ定義の名前で組み込みの名前を上書きする場合は、<literal>pg_catalog</literal>を明示的にパスの最後に置くことができます。
   </para>

   <para>
<!--
    Since system table names begin with <literal>pg_</literal>, it is best to
    avoid such names to ensure that you won't suffer a conflict if some
    future version defines a system table named the same as your
    table.  (With the default search path, an unqualified reference to
    your table name would then be resolved as the system table instead.)
    System tables will continue to follow the convention of having
    names beginning with <literal>pg_</literal>, so that they will not
    conflict with unqualified user-table names so long as users avoid
    the <literal>pg_</literal> prefix.
-->
システムカタログの名前は<literal>pg_</literal>で始まりますので、このような名前は使用しないのが得策と言えます。
今後のバージョンでユーザのテーブルと同じ名前のシステムカタログが定義され、競合する事態を避けるためです。
（その結果、デフォルトの検索パスでは、ユーザのテーブル名への非修飾の参照はシステムカタログとして解決されることになります。）
システムカタログは今後も<literal>pg_</literal>で始まる規則に従うので、ユーザが<literal>pg_</literal>という接頭辞を使わない限り、非修飾のユーザ定義テーブル名がシステムカタログと競合することはありません。
   </para>
  </sect2>

  <sect2 id="ddl-schemas-patterns">
<!--
   <title>Usage Patterns</title>
-->
   <title>使用パターン</title>

   <para>
<!--
    Schemas can be used to organize your data in many ways.
    A <firstterm>secure schema usage pattern</firstterm> prevents untrusted
    users from changing the behavior of other users' queries.  When a database
    does not use a secure schema usage pattern, users wishing to securely
    query that database would take protective action at the beginning of each
    session.  Specifically, they would begin each session by
    setting <varname>search_path</varname> to the empty string or otherwise
    removing non-superuser-writable schemas
    from <varname>search_path</varname>.  There are a few usage patterns
    easily supported by the default configuration:
-->
スキーマは様々な方法でデータの編成に使用できます。
<firstterm>セキュアなスキーマの使用パターン</firstterm>は信頼できないユーザが他のユーザの問い合わせの振る舞いを変えるのを防ぎます。
データベースがセキュアなスキーマの使用パターンを使わない場合、セキュアにデータベースを問い合わせたいユーザはセッションの開始毎に防御的なアクションを取るようにします。
とりわけユーザは<varname>search_path</varname>に空文字をセットするか、さもなければ非スーパーユーザが書き込めるスキーマを<varname>search_path</varname>から削除します。
デフォルト構成で簡単にサポートできるお勧めの使用パターンがいくつかあります。
    <itemizedlist>
     <listitem>
      <!-- "DROP SCHEMA public" is inferior to this REVOKE, because pg_dump
           doesn't preserve that DROP.

           A database owner can attack the database's users via "CREATE SCHEMA
           trojan; ALTER DATABASE $mydb SET search_path = trojan, public;".  A
           CREATEROLE user can issue "GRANT $dbowner TO $me" and then use the
           database owner attack. -->
      <!-- "DROP SCHEMA public"はこのREVOKEに劣ります。なぜなら、pg_dumpはそのDROPを保存しないからです。

      データベース所有者はデータベースユーザを"CREATE SCHEMA
      trojan; ALTER DATABASE $mydb SET search_path = trojan, public;"で攻撃することができます。
      CREATEROLEユーザは"GRANT $dbowner TO $me"を発行し、そのデータベース所有者の攻撃を使用できます。
       -->
      <para>
<!--
       Constrain ordinary users to user-private schemas.  To implement this,
       issue <literal>REVOKE CREATE ON SCHEMA public FROM PUBLIC</literal>,
       and create a schema for each user with the same name as that user.
       Recall that the default search path starts
       with <literal>$user</literal>, which resolves to the user name.
       Therefore, if each user has a separate schema, they access their own
       schemas by default.  After adopting this pattern in a database where
       untrusted users had already logged in, consider auditing the public
       schema for objects named like objects in
       schema <literal>pg_catalog</literal>.  This pattern is a secure schema
       usage pattern unless an untrusted user is the database owner or holds
       the <literal>CREATEROLE</literal> privilege, in which case no secure
       schema usage pattern exists.
-->
一般ユーザに、ユーザ個人用のスキーマだけを使わせます。
これを実現するには、<literal>REVOKE CREATE ON SCHEMA public FROM PUBLIC</literal>を発行し、個々のユーザにユーザと同じ名前でスキーマを作成してください。
デフォルトサーチパスは、ユーザ名として解釈される<literal>$user</literal>で始まることを思い出してください。
ですから、ユーザが各自別々のスキーマを所有しているなら、デフォルトでは自身のスキーマにアクセスします。
信頼できないユーザがすでにログインしたデータベースでこのパターンを採用した後には、<literal>pg_catalog</literal>スキーマ内にあるのと同じ名前のpublicスキーマ内のオブジェクトを監視することを考慮してください。
セキュアなスキーマ利用パターンが存在しないような、信用できないユーザがデータベース所有者である場合や、<literal>CREATEROLE</literal>権限を持っている場合を除き、このパターンはセキュアなスキーマ利用パターンです。
      </para>
      <para>
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       Remove the public schema from the default search path, by modifying
       <link linkend="config-setting-configuration-file"><filename>postgresql.conf</filename></link>
       or by issuing <literal>ALTER ROLE ALL SET search_path =
       "$user"</literal>.  Everyone retains the ability to create objects in
       the public schema, but only qualified names will choose those objects.
       While qualified table references are fine, calls to functions in the
       public schema <link linkend="typeconv-func">will be unsafe or
       unreliable</link>.  If you create functions or extensions in the public
       schema, use the first pattern instead.  Otherwise, like the first
       pattern, this is secure unless an untrusted user is the database owner
       or holds the <literal>CREATEROLE</literal> privilege.
-->
<link linkend="config-setting-configuration-file"><filename>postgresql.conf</filename></link>の<varname>search_path</varname>を変更、あるいは<literal>ALTER ROLE ALL SET search_path = "$user"</literal>を実行することにより、デフォルトサーチパスからからpublicスキーマを削除します。
全員がパブリックスキーマに引き続きオブジェクトを作ることができますが、オブジェクトの選択は修飾名によってのみ行われます。
修飾されたテーブル名による参照は問題ありませんが、パブリックスキーマ内の関数呼び出しは<link linkend="typeconv-func">安全ではないか、あるいは信頼性がありません</link>。
パブリックスキーマ内に関数や拡張を作る場合は、最初のパターンを代わりに使ってください。
それ以外では、最初のパターン同様、信頼できないユーザがデータベース所有者である場合や、<literal>CREATEROLE</literal>権限を持っている場合を除き、これはセキュアです。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       Keep the default.  All users access the public schema implicitly.  This
       simulates the situation where schemas are not available at all, giving
       a smooth transition from the non-schema-aware world.  However, this is
       never a secure pattern.  It is acceptable only when the database has a
       single user or a few mutually-trusting users.
-->
デフォルトを維持します。
すべてのユーザがpublicスキーマに暗黙的にアクセスします。
これはスキーマを考慮しない世界からのスムースな移行を可能にしながら、スキーマがまったく利用できない状況をシミュレートします。
しかし、これは決してセキュアなパターンではありません。
このパターンは、データベースに一人、あるいは少数のお互いに信頼できるユーザだけが存在する場合にのみ受け入れ可能です。
      </para>
     </listitem>
    </itemizedlist>
   </para>

   <para>
<!--
    For any pattern, to install shared applications (tables to be used by
    everyone, additional functions provided by third parties, etc.), put them
    into separate schemas.  Remember to grant appropriate privileges to allow
    the other users to access them.  Users can then refer to these additional
    objects by qualifying the names with a schema name, or they can put the
    additional schemas into their search path, as they choose.
-->
どのパターンでも、共有のアプリケーション（全員が使うテーブル、サードパーティが提供する追加の関数など）をインストールするには、別のスキーマにアプリケーションを入れてください。
他のユーザがアプリケーションにアクセスするために、適切な権限を与えることを忘れないようにしてください。
ユーザはスキーマ名で名前を修飾するか、あるいは追加スキーマをサーチパスに入れるかを選択し、これらの追加オブジェクトを参照できます。
   </para>
  </sect2>

  <sect2 id="ddl-schemas-portability">
<!--
   <title>Portability</title>
-->
   <title>移植性</title>

   <para>
<!--
    In the SQL standard, the notion of objects in the same schema
    being owned by different users does not exist.  Moreover, some
    implementations do not allow you to create schemas that have a
    different name than their owner.  In fact, the concepts of schema
    and user are nearly equivalent in a database system that
    implements only the basic schema support specified in the
    standard.  Therefore, many users consider qualified names to
    really consist of
    <literal><replaceable>user_name</replaceable>.<replaceable>table_name</replaceable></literal>.
    This is how <productname>PostgreSQL</productname> will effectively
    behave if you create a per-user schema for every user.
-->
標準SQLでは、1つのスキーマ内のオブジェクトを異なるユーザが所有するという概念は存在しません。
それどころか、実装によっては所有者と異なる名前のスキーマを作成することが許可されていない場合もあります。
実際、標準で規定されている基本スキーマサポートのみを実装しているデータベースシステムでは、スキーマという概念とユーザという概念はほとんど同じなのです。
そのため、修飾名とは<literal><replaceable>username</replaceable>.<replaceable>tablename</replaceable></literal>のことであると思っているユーザはたくさんいます。
<productname>PostgreSQL</productname>においても、ユーザごとに1つのスキーマを作成すると、このようになります。
   </para>

   <para>
<!--
    Also, there is no concept of a <literal>public</literal> schema in the
    SQL standard.  For maximum conformance to the standard, you should
    not use the <literal>public</literal> schema.
-->
また、標準SQLには、<literal>public</literal>スキーマという概念もありません。
標準に最大限従うためには、<literal>public</literal>スキーマは使用すべきではありません。
   </para>

   <para>
<!--
    Of course, some SQL database systems might not implement schemas
    at all, or provide namespace support by allowing (possibly
    limited) cross-database access.  If you need to work with those
    systems, then maximum portability would be achieved by not using
    schemas at all.
-->
もちろん、スキーマをまったく実装していなかったり、または、データベース間アクセスを（場合によっては制限付きで）許可することによって名前空間の使用をサポートしているSQLデータベースもあります。
このようなシステムで作業する必要がある場合は、スキーマをまったく使わないようにすることで最大限の移植性を実現できます。
   </para>
  </sect2>
 </sect1>

 <sect1 id="ddl-inherit">
<!--
  <title>Inheritance</title>
-->
  <title>継承</title>

  <indexterm>
<!--
   <primary>inheritance</primary>
-->
   <primary>継承</primary>
  </indexterm>

  <indexterm>
<!--
   <primary>table</primary>
   <secondary>inheritance</secondary>
-->
   <primary>テーブル</primary>
   <secondary>継承</secondary>
  </indexterm>

  <para>
<!--
   <productname>PostgreSQL</productname> implements table inheritance,
   which can be a useful tool for database designers.  (SQL:1999 and
   later define a type inheritance feature, which differs in many
   respects from the features described here.)
-->
<productname>PostgreSQL</productname>は、データベース設計者にとって便利なテーブルの継承を実装しています。
（SQL:1999以降は型の継承を定義していますが、ここで述べられている継承とは多くの点で異なっています。）
  </para>

  <para>
<!--
   Let's start with an example: suppose we are trying to build a data
   model for cities.  Each state has many cities, but only one
   capital. We want to be able to quickly retrieve the capital city
   for any particular state. This can be done by creating two tables,
   one for state capitals and one for cities that are not
   capitals. However, what happens when we want to ask for data about
   a city, regardless of whether it is a capital or not? The
   inheritance feature can help to resolve this problem. We define the
   <structname>capitals</structname> table so that it inherits from
   <structname>cities</structname>:
-->
まず例から始めましょう。
市（cities）のデータモデルを作成しようとしていると仮定してください。
それぞれの州にはたくさんの市がありますが、州都（capitals）は1つのみです。
どの州についても州都を素早く検索したいとします。
これは、2つのテーブルを作成することにより実現できます。
1つは州都のテーブルで、もう1つは州都ではない市のテーブルです。
しかし、州都であるか否かに関わらず、市に対するデータを問い合わせたいときには何が起こるでしょうか？
継承はこの問題を解決できます。
<structname>cities</structname>から継承される<structname>capitals</structname>テーブルを定義するのです。

<programlisting>
CREATE TABLE cities (
    name            text,
    population      float,
    elevation       int     -- in feet
);

CREATE TABLE capitals (
    state           char(2)
) INHERITS (cities);
</programlisting>

<!--
   In this case, the <structname>capitals</structname> table <firstterm>inherits</firstterm>
   all the columns of its parent table, <structname>cities</structname>. State
   capitals also have an extra column, <structfield>state</structfield>, that shows
   their state.
-->
この場合、<structname>capitals</structname>テーブルは、その親テーブルである<structname>cities</structname>テーブルの列をすべて<firstterm>継承</firstterm>します。
州都は1つの追加の列<structfield>state</structfield>を持ち、州を表現します。
  </para>

  <para>
<!--
   In <productname>PostgreSQL</productname>, a table can inherit from
   zero or more other tables, and a query can reference either all
   rows of a table or all rows of a table plus all of its descendant tables.
   The latter behavior is the default.
   For example, the following query finds the names of all cities,
   including state capitals, that are located at an elevation over
   500 feet:
-->
<productname>PostgreSQL</productname>では、1つのテーブルは、0以上のテーブルから継承することが可能です。
また、問い合わせはテーブルのすべての行、またはテーブルのすべての行と継承されたテーブルのすべての行のいずれかを参照できます。
後者がデフォルトの動作になります。
例えば次の問い合わせは、500フィートより高い標高に位置しているすべての市の名前を、州都を含めて検索します。

<programlisting>
SELECT name, elevation
    FROM cities
    WHERE elevation &gt; 500;
</programlisting>

<!--
   Given the sample data from the <productname>PostgreSQL</productname>
   tutorial (see <xref linkend="tutorial-sql-intro"/>), this returns:
-->
<productname>PostgreSQL</productname>チュートリアルからのサンプルデータ（<xref linkend="tutorial-sql-intro"/>を参照してください）に対して、この問い合わせは、以下の結果を出力します。

<programlisting>
   name    | elevation
-----------+-----------
 Las Vegas |      2174
 Mariposa  |      1953
 Madison   |       845
</programlisting>
  </para>

  <para>
<!--
   On the other hand, the following query finds all the cities that
   are not state capitals and are situated at an elevation over 500 feet:
-->
一方、次の問い合わせは、州都ではなく500フィートより高い高度に位置しているすべての市を検索します。

<programlisting>
SELECT name, elevation
    FROM ONLY cities
    WHERE elevation &gt; 500;

   name    | elevation
-----------+-----------
 Las Vegas |      2174
 Mariposa  |      1953
</programlisting>
  </para>

  <para>
<!--
   Here the <literal>ONLY</literal> keyword indicates that the query
   should apply only to <structname>cities</structname>, and not any tables
   below <structname>cities</structname> in the inheritance hierarchy.  Many
   of the commands that we have already discussed &mdash;
   <command>SELECT</command>, <command>UPDATE</command> and
   <command>DELETE</command> &mdash; support the
   <literal>ONLY</literal> keyword.
-->
ここで<literal>ONLY</literal>キーワードは、問い合わせが<structname>cities</structname>テーブルのみを対象にし<structname>cities</structname>以下の継承の階層にあるテーブルは対象としないことを意味します。
これまで議論したコマンドの多く&mdash;<command>SELECT</command>、<command>UPDATE</command>そして<command>DELETE</command> &mdash;が<literal>ONLY</literal>キーワードをサポートしています。
  </para>

  <para>
<!--
   You can also write the table name with a trailing <literal>*</literal>
   to explicitly specify that descendant tables are included:
-->
また、明示的に子孫テーブルが含まれていることを示すために、テーブル名の後ろに<literal>*</literal>を書くこともできます:

<programlisting>
SELECT name, elevation
    FROM cities*
    WHERE elevation &gt; 500;
</programlisting>

<!--
   Writing <literal>*</literal> is not necessary, since this behavior is always
   the default.  However, this syntax is still supported for
   compatibility with older releases where the default could be changed.
-->
<literal>*</literal>の指定は、その動作が常にデフォルトであるため、必要ありません。
しかし、この構文はデフォルトが変更可能であった古いリリースとの互換性のためにまだサポートされています。
  </para>

  <para>
<!--
   In some cases you might wish to know which table a particular row
   originated from. There is a system column called
   <structfield>tableoid</structfield> in each table which can tell you the
   originating table:
-->
ある特定の行がどのテーブルからきたものか知りたいという場合もあるでしょう。
それぞれのテーブルには<structfield>tableoid</structfield>という、元になったテーブルを示すシステム列があります。

<programlisting>
SELECT c.tableoid, c.name, c.elevation
FROM cities c
WHERE c.elevation &gt; 500;
</programlisting>

<!--
   which returns:
-->
出力は以下の通りです。

<programlisting>
 tableoid |   name    | elevation
----------+-----------+-----------
   139793 | Las Vegas |      2174
   139793 | Mariposa  |      1953
   139798 | Madison   |       845
</programlisting>

<!--
   (If you try to reproduce this example, you will probably get
   different numeric OIDs.)  By doing a join with
   <structname>pg_class</structname> you can see the actual table names:
-->
（この例をそのまま実行しても、おそらく異なる数値OIDが得られるでしょう。）
<structname>pg_class</structname>と結合することで、テーブルの実際の名前が分かります。

<programlisting>
SELECT p.relname, c.name, c.elevation
FROM cities c, pg_class p
WHERE c.elevation &gt; 500 AND c.tableoid = p.oid;
</programlisting>

<!--
   which returns:
-->
出力は以下の通りです。

<programlisting>
 relname  |   name    | elevation
----------+-----------+-----------
 cities   | Las Vegas |      2174
 cities   | Mariposa  |      1953
 capitals | Madison   |       845
</programlisting>
  </para>

  <para>
<!--
   Another way to get the same effect is to use the <type>regclass</type>
   alias type, which will print the table OID symbolically:
-->
同じ効果を得る別の方法は、別名型<type>regclass</type>を使うことで、これによりテーブルのOIDを記号的に表示します。

<programlisting>
SELECT c.tableoid::regclass, c.name, c.elevation
FROM cities c
WHERE c.elevation &gt; 500;
</programlisting>
  </para>

  <para>
<!--
   Inheritance does not automatically propagate data from
   <command>INSERT</command> or <command>COPY</command> commands to
   other tables in the inheritance hierarchy. In our example, the
   following <command>INSERT</command> statement will fail:
-->
継承は<command>INSERT</command>または<command>COPY</command>によるデータを、継承の階層にある他のテーブルに自動的に伝播しません。
この例では、次の<command>INSERT</command>文は失敗します。
<programlisting>
INSERT INTO cities (name, population, elevation, state)
VALUES ('Albany', NULL, NULL, 'NY');
</programlisting>
<!--
   We might hope that the data would somehow be routed to the
   <structname>capitals</structname> table, but this does not happen:
   <command>INSERT</command> always inserts into exactly the table
   specified.  In some cases it is possible to redirect the insertion
   using a rule (see <xref linkend="rules"/>).  However that does not
   help for the above case because the <structname>cities</structname> table
   does not contain the column <structfield>state</structfield>, and so the
   command will be rejected before the rule can be applied.
-->
データが、どうにかして<structname>capitals</structname>テーブルに入ることを期待するかもしれませんが、そのようにはなりません。
<command>INSERT</command>は、いつも指定されたテーブルそれ自体に対してデータを挿入します。
ルール（詳細は<xref linkend="rules"/>を参照してください）を使用して挿入を中継できる場合もあります。
しかし、ルールを使用しても上記のような場合は解決できません。
なぜなら、<structname>cities</structname>テーブルに<structfield>state</structfield>列が含まれていないため、ルールが適用される前にコマンドが拒否されてしまうからです。
  </para>

  <para>
<!--
   All check constraints and not-null constraints on a parent table are
   automatically inherited by its children, unless explicitly specified
   otherwise with <literal>NO INHERIT</literal> clauses.  Other types of constraints
   (unique, primary key, and foreign key constraints) are not inherited.
-->
親テーブル上の検査制約と非NULL制約は、<literal>NO INHERIT</literal>句によって明示的に指定され無い限り、その子テーブルに自動的に継承されます。
他の種類の制約（一意性制約、主キー、外部キー制約）は継承されません。
  </para>

  <para>
<!--
   A table can inherit from more than one parent table, in which case it has
   the union of the columns defined by the parent tables.  Any columns
   declared in the child table's definition are added to these.  If the
   same column name appears in multiple parent tables, or in both a parent
   table and the child's definition, then these columns are <quote>merged</quote>
   so that there is only one such column in the child table.  To be merged,
   columns must have the same data types, else an error is raised.
   Inheritable check constraints and not-null constraints are merged in a
   similar fashion.  Thus, for example, a merged column will be marked
   not-null if any one of the column definitions it came from is marked
   not-null.  Check constraints are merged if they have the same name,
   and the merge will fail if their conditions are different.
-->
テーブルは1つ以上の親テーブルから継承可能です。
この場合、テーブルは親テーブルで定義された列の和になります。
子テーブルで宣言された列は、これらの列に追加されることになります。
もし親テーブルに同じ名前の列がある場合、もしくは、親テーブルと子テーブルに同じ名前の列がある場合は、列が<quote>統合</quote>されて子テーブルではただ1つの列となります。
統合されるには列は同じデータ型を持っている必要があります。
異なるデータ型の場合にはエラーとなります。
継承可能な検査制約と非NULL制約は、同じようなやり方で統合されます。
つまり、例えば、列定義のいずれかが非NULL制約の印が付いているならば、統合された列に非NULLという印が付きます。
検査制約は、同じ名前を持っている場合に統合され、それらの条件が異なる場合は統合に失敗します。
  </para>

  <para>
<!--
   Table inheritance is typically established when the child table is
   created, using the <literal>INHERITS</literal> clause of the
   <xref linkend="sql-createtable"/>
   statement.
   Alternatively, a table which is already defined in a compatible way can
   have a new parent relationship added, using the <literal>INHERIT</literal>
   variant of <xref linkend="sql-altertable"/>.
   To do this the new child table must already include columns with
   the same names and types as the columns of the parent. It must also include
   check constraints with the same names and check expressions as those of the
   parent. Similarly an inheritance link can be removed from a child using the
   <literal>NO INHERIT</literal> variant of <command>ALTER TABLE</command>.
   Dynamically adding and removing inheritance links like this can be useful
   when the inheritance relationship is being used for table
   partitioning (see <xref linkend="ddl-partitioning"/>).
-->
テーブル継承は、通常、<xref linkend="sql-createtable"/>文の<literal>INHERITS</literal>句を使用して、子テーブルを作成する時に確立します。
他にも、互換性を持つ方法で定義済みのテーブルに新しく親子関係を付けることも可能です。
これには<xref linkend="sql-altertable"/>の<literal>INHERIT</literal>形式を使用します。
このためには、新しい子テーブルは親テーブルと同じ名前の列を持ち、その列の型は同じデータ型でなければなりません。
また、親テーブルと同じ名前、同じ式の検査制約を持っていなければなりません。
<command>ALTER TABLE</command>の<literal>NO INHERIT</literal>形式を使用して、同様に継承関係を子テーブルから取り除くことも可能です。
このような継承関係の動的追加、動的削除は、継承関係をテーブル分割（<xref linkend="ddl-partitioning"/>を参照）に使用している場合に有用です。
  </para>

  <para>
<!--
   One convenient way to create a compatible table that will later be made
   a new child is to use the <literal>LIKE</literal> clause in <command>CREATE
   TABLE</command>. This creates a new table with the same columns as
   the source table. If there are any <literal>CHECK</literal>
   constraints defined on the source table, the <literal>INCLUDING
   CONSTRAINTS</literal> option to <literal>LIKE</literal> should be
   specified, as the new child must have constraints matching the parent
   to be considered compatible.
-->
後で子テーブルとする予定の、互換性を持つテーブルを簡単に作成する方法の1つは、<command>CREATE TABLE</command>で<literal>LIKE</literal>句を使用することです。
これは、元としたテーブルと同じ列を持つテーブルを新しく作成します。
新しい子テーブルが必ず親テーブルと一致する制約を持ち、互換性があるものとみなされるように、元となるテーブルで<literal>CHECK</literal>制約が存在する場合は、<literal>LIKE</literal>に<literal>INCLUDING CONSTRAINTS</literal>オプションを指定すべきです。
  </para>

  <para>
<!--
   A parent table cannot be dropped while any of its children remain. Neither
   can columns or check constraints of child tables be dropped or altered
   if they are inherited
   from any parent tables. If you wish to remove a table and all of its
   descendants, one easy way is to drop the parent table with the
   <literal>CASCADE</literal> option (see <xref linkend="ddl-depend"/>).
-->
子テーブルが存在する場合親テーブルを削除することはできません。
また、子テーブルでは、親テーブルから継承した列、または検査制約を削除することも変更することもできません。
テーブルとそのすべての子テーブルを削除したければ、<literal>CASCADE</literal>オプションを付けて親テーブルを削除することが簡単な方法です（<xref linkend="ddl-depend"/>を参照）。
  </para>

  <para>
<!--
   <xref linkend="sql-altertable"/> will
   propagate any changes in column data definitions and check
   constraints down the inheritance hierarchy.  Again, dropping
   columns that are depended on by other tables is only possible when using
   the <literal>CASCADE</literal> option. <command>ALTER
   TABLE</command> follows the same rules for duplicate column merging
   and rejection that apply during <command>CREATE TABLE</command>.
-->
<xref linkend="sql-altertable"/>は、列データ定義と検査制約の変更を継承の階層にあるテーブルに伝えます。
ここでも、他のテーブルに依存する列の削除は<literal>CASCADE</literal>オプションを使用したときのみ可能となります。
<command>ALTER TABLE</command>は、重複列の統合と拒否について、<command>CREATE TABLE</command>時に適用される規則に従います。
  </para>

  <para>
<!--
   Inherited queries perform access permission checks on the parent table
   only.  Thus, for example, granting <literal>UPDATE</literal> permission on
   the <structname>cities</structname> table implies permission to update rows in
   the <structname>capitals</structname> table as well, when they are
   accessed through <structname>cities</structname>.  This preserves the appearance
   that the data is (also) in the parent table.  But
   the <structname>capitals</structname> table could not be updated directly
   without an additional grant.  In a similar way, the parent table's row
   security policies (see <xref linkend="ddl-rowsecurity"/>) are applied to
   rows coming from child tables during an inherited query.  A child table's
   policies, if any, are applied only when it is the table explicitly named
   in the query; and in that case, any policies attached to its parent(s) are
   ignored.
-->
同様に、親テーブルの行セキュリティポリシー（<xref linkend="ddl-rowsecurity"/>を参照してください）が、継承された問い合わせの時に子テーブルの行に適用されます。
子テーブルのポリシー（あれば）は、問い合わせにて明示的に指定されたテーブルである時にのみ適用されます。
そしてこの場合、親テーブルに紐付けられたあらゆるポリシーは無視されます。
  </para>

  <para>
<!--
   Foreign tables (see <xref linkend="ddl-foreign-data"/>) can also
   be part of inheritance hierarchies, either as parent or child
   tables, just as regular tables can be.  If a foreign table is part
   of an inheritance hierarchy then any operations not supported by
   the foreign table are not supported on the whole hierarchy either.
-->
外部テーブル（<xref linkend="ddl-foreign-data"/>参照）も通常のテーブルと同様、親テーブルあるいは子テーブルとして継承の階層の一部となりえます。
外部テーブルが継承の階層の一部となっている場合、外部テーブルがサポートしない操作は、その継承全体でもサポートされません。
  </para>

 <sect2 id="ddl-inherit-caveats">
<!--
  <title>Caveats</title>
-->
  <title>警告</title>

  <para>
<!--
   Note that not all SQL commands are able to work on
   inheritance hierarchies.  Commands that are used for data querying,
   data modification, or schema modification
   (e.g., <literal>SELECT</literal>, <literal>UPDATE</literal>, <literal>DELETE</literal>,
   most variants of <literal>ALTER TABLE</literal>, but
   not <literal>INSERT</literal> or <literal>ALTER TABLE ...
   RENAME</literal>) typically default to including child tables and
   support the <literal>ONLY</literal> notation to exclude them.
   Commands that do database maintenance and tuning
   (e.g., <literal>REINDEX</literal>, <literal>VACUUM</literal>)
   typically only work on individual, physical tables and do not
   support recursing over inheritance hierarchies.  The respective
   behavior of each individual command is documented in its reference
   page (<xref linkend="sql-commands"/>).
-->
すべてのSQLコマンドが継承階層に対して動作できるとは限らないことに注意してください。
データの検索、データの変更、スキーマの変更のために使用されるコマンド（例えば<literal>SELECT</literal>、<literal>UPDATE</literal>、<literal>DELETE</literal>、<literal>ALTER TABLE</literal>のほとんどの構文が該当しますが、<literal>INSERT</literal>や<literal>ALTER TABLE ... RENAME</literal>は含まれません）は通常、デフォルトで子テーブルを含み、また、それを除外するための<literal>ONLY</literal>記法をサポートします。
データベース保守およびチューニング（例えば<literal>REINDEX</literal>、<literal>VACUUM</literal>）を行うコマンドは通常、個々の物理テーブルに対してのみ動作し、継承階層に対する再帰をサポートしません。
個々のコマンドのそれぞれの動作はそのマニュアルページ（<xref linkend="sql-commands"/>）に記載されています。
  </para>

  <para>
<!--
   A serious limitation of the inheritance feature is that indexes (including
   unique constraints) and foreign key constraints only apply to single
   tables, not to their inheritance children. This is true on both the
   referencing and referenced sides of a foreign key constraint. Thus,
   in the terms of the above example:
-->
継承機能の重大な制限として、インデックス（一意性制約を含む）、および外部キーは、そのテーブルのみに適用され、それを継承した子テーブルには適用されないことがあります。
これは外部キーの参照側、被参照側の両方について当てはまります。
したがって、上の例では

   <itemizedlist>
    <listitem>
     <para>
<!--
      If we declared <structname>cities</structname>.<structfield>name</structfield> to be
      <literal>UNIQUE</literal> or a <literal>PRIMARY KEY</literal>, this would not stop the
      <structname>capitals</structname> table from having rows with names duplicating
      rows in <structname>cities</structname>.  And those duplicate rows would by
      default show up in queries from <structname>cities</structname>.  In fact, by
      default <structname>capitals</structname> would have no unique constraint at all,
      and so could contain multiple rows with the same name.
      You could add a unique constraint to <structname>capitals</structname>, but this
      would not prevent duplication compared to <structname>cities</structname>.
-->
もし、<structname>cities</structname>.<structfield>name</structfield>を<literal>UNIQUE</literal>または<literal>PRIMARY KEY</literal>と宣言しても、<structname>cities</structname>テーブルの行と重複した行を<structname>capitals</structname>テーブル内に持つことを禁止することにはなりません。
さらに、これらの重複した行はデフォルトで<structname>cities</structname>テーブルへの問い合わせで現れるでしょう。
事実として、<structname>capitals</structname>テーブルはデフォルトで一意性制約を持っていませんし、同一の名前の複数の行を持つことがあり得ます。
<structname>capitals</structname>テーブルに一意性制約を追加できますが、これは<structname>cities</structname>テーブルと比較して重複を禁止することにはなりません。
     </para>
    </listitem>

    <listitem>
     <para>
<!--
      Similarly, if we were to specify that
      <structname>cities</structname>.<structfield>name</structfield> <literal>REFERENCES</literal> some
      other table, this constraint would not automatically propagate to
      <structname>capitals</structname>.  In this case you could work around it by
      manually adding the same <literal>REFERENCES</literal> constraint to
      <structname>capitals</structname>.
-->
同じように、<structname>cities</structname>.<structfield>name</structfield> <literal>REFERENCES</literal>で他のテーブルを参照するようにしても、この制約は自動的に<structname>capitals</structname>に引き継がれるわけではありません。
この場合は<structname>capitals</structname>テーブルに同一の<literal>REFERENCES</literal>制約を手動で追加すれば問題を回避できます。
     </para>
    </listitem>

    <listitem>
     <para>
<!--
      Specifying that another table's column <literal>REFERENCES
      cities(name)</literal> would allow the other table to contain city names, but
      not capital names.  There is no good workaround for this case.
-->
他のテーブルの列に<literal>REFERENCES cities(name)</literal>を指定すると、他のテーブルが市の名前を持つことはできますが、州都の名前を持つことできません。
この場合は良い回避策がありません。
     </para>
    </listitem>
   </itemizedlist>

<!--
   Some functionality not implemented for inheritance hierarchies is
   implemented for declarative partitioning.
   Considerable care is needed in deciding whether partitioning with legacy
   inheritance is useful for your application.
-->
継承の階層に対して実装されていないいくつかの機能は、宣言的パーティショニングでは実装されています。
従来の継承がアプリケーションにとって有用であるかどうかを判断する際に十分注意してください。
  </para>

   </sect2>
  </sect1>

  <sect1 id="ddl-partitioning">
<!--
   <title>Table Partitioning</title>
-->
   <title>テーブルのパーティショニング</title>

   <indexterm>
<!--
    <primary>partitioning</primary>
-->
    <primary>パーティショニング</primary>
   </indexterm>

   <indexterm>
<!--
    <primary>table</primary>
    <secondary>partitioning</secondary>
-->
    <primary>テーブル</primary>
    <secondary>パーティショニング</secondary>
   </indexterm>

   <indexterm>
<!--
    <primary>partitioned table</primary>
-->
    <primary>パーティションテーブル</primary>
   </indexterm>

   <para>
<!--
    <productname>PostgreSQL</productname> supports basic table
    partitioning. This section describes why and how to implement
    partitioning as part of your database design.
-->
<productname>PostgreSQL</productname>は基本的なテーブルのパーティショニング（分割）をサポートしています。
この節では、データベース設計において、なぜそしてどのようにしてパーティショニングを実装するのかを解説します。
   </para>

   <sect2 id="ddl-partitioning-overview">
<!--
     <title>Overview</title>
-->
     <title>概要</title>

    <para>
<!--
     Partitioning refers to splitting what is logically one large table into
     smaller physical pieces.  Partitioning can provide several benefits:
-->
パーティショニングとは、論理的には一つの大きなテーブルであるものを、物理的により小さな部品に分割することを指します。
パーティショニングによって得られる利点は以下のようにいくつかあります。
    <itemizedlist>
     <listitem>
      <para>
<!--
       Query performance can be improved dramatically in certain situations,
       particularly when most of the heavily accessed rows of the table are in a
       single partition or a small number of partitions.  The partitioning
       substitutes for leading columns of indexes, reducing index size and
       making it more likely that the heavily-used parts of the indexes
       fit in memory.
-->
特定の条件下で問い合わせのパフォーマンスが劇的に向上することがあります。
特にテーブル内のアクセスが集中する行の殆どが単一または少数のパーティションに存在している場合がそうです。
パーティショニングはインデックスの先頭にある列の代わりになり、インデックスの大きさを小さくして、インデックスの頻繁に使われる部分がメモリに収まりやすくなるようにします。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       When queries or updates access a large percentage of a single
       partition, performance can be improved by taking advantage
       of sequential scan of that partition instead of using an
       index and random access reads scattered across the whole table.
-->
問い合わせや更新が一つのパーティションの大部分にアクセスする場合、インデックスやランダムアクセスを使用してテーブル全体にまたがる読み取りをする代わりに、そのパーティションへの順次アクセスをすることでパフォーマンスを向上させることができます。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       Bulk loads and deletes can be accomplished by adding or removing
       partitions, if that requirement is planned into the partitioning design.
       Doing <command>ALTER TABLE DETACH PARTITION</command> or dropping an individual
       partition using <command>DROP TABLE</command> is far faster than a bulk
       operation.  These commands also entirely avoid the
       <command>VACUUM</command> overhead caused by a bulk <command>DELETE</command>.
-->
一括挿入や削除について、その要件をパーティションの設計に組み込んでいれば、それをパーティションの追加や削除で実現することが可能です。
<command>ALTER TABLE DETACH PARTITION</command>を実行する、あるいは個々のパーティションを<command>DROP TABLE</command>で削除するのは、一括の操作をするよりも遥かに高速です。
これらのコマンドはまた、一括の<command>DELETE</command>で引き起こされる<command>VACUUM</command>のオーバーヘッドを完全に回避できます。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       Seldom-used data can be migrated to cheaper and slower storage media.
-->
滅多に使用されないデータを安価で低速なストレージメディアに移行することができます。
      </para>
     </listitem>
    </itemizedlist>

<!--
     The benefits will normally be worthwhile only when a table would
     otherwise be very large. The exact point at which a table will
     benefit from partitioning depends on the application, although a
     rule of thumb is that the size of the table should exceed the physical
     memory of the database server.
-->
この利益は通常、そうしなければテーブルが非常に大きくなる場合にのみ価値があります。
テーブルがパーティショニングから利益を得られるかどうかの正確な分岐点はアプリケーションに依存しますが、重要なことはテーブルのサイズがデータベースサーバの物理メモリより大きいことです。
    </para>

    <para>
<!--
     <productname>PostgreSQL</productname> offers built-in support for the
     following forms of partitioning:
-->
<productname>PostgreSQL</productname>にはパーティショニングについて以下の形式の組み込み機能があります。

     <variablelist>
      <varlistentry>
<!--
       <term>Range Partitioning</term>
-->
       <term>範囲パーティショニング</term>

       <listitem>
        <para>
<!--
         The table is partitioned into <quote>ranges</quote> defined
         by a key column or set of columns, with no overlap between
         the ranges of values assigned to different partitions.  For
         example, one might partition by date ranges, or by ranges of
         identifiers for particular business objects.
-->
テーブルはキー列またはキー列の集合で定義される<quote>範囲</quote>にパーティション分割され、異なるパーティションに割り当てられる値の範囲に重なりがないようになります。
例えば、日付の範囲によってパーティション分割することもあるでしょうし、特定のビジネスオブジェクトの識別子の範囲によって分割することもあるでしょう。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
<!--
       <term>List Partitioning</term>
-->
       <term>リストパーティション</term>

       <listitem>
        <para>
<!--
         The table is partitioned by explicitly listing which key values
         appear in each partition.
-->
各パーティションに現れるキーの値を明示的に列挙することでテーブルをパーティションに分割します。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
<!--
       <term>Hash Partitioning</term>
-->
       <term>ハッシュパーティション</term>

       <listitem>
        <para>
<!--
         The table is partitioned by specifying a modulus and a remainder for
         each partition. Each partition will hold the rows for which the hash
         value of the partition key divided by the specified modulus will
         produce the specified remainder.
-->
各パーティションに対して法と剰余を指定することでテーブルをパーティションに分割します。
各パーティションは、パーティションキーのハッシュ値を指定された法で割った際に指定された剰余となる行を保持します。
        </para>
       </listitem>
      </varlistentry>
     </variablelist>

<!--
     If your application needs to use other forms of partitioning not listed
     above, alternative methods such as inheritance and
     <literal>UNION ALL</literal> views can be used instead.  Such methods
     offer flexibility but do not have some of the performance benefits
     of built-in declarative partitioning.
-->
アプリケーションで上記に列挙されていない他の形式のパーティショニングを使用する必要がある場合は、継承や<literal>UNION ALL</literal>などの代替方式を代わりに使うことができます。
そのような方式は柔軟性がありますが、組み込みの宣言的パーティショニングによるパフォーマンス上の利益の一部を享受できません。
    </para>
   </sect2>

  <sect2 id="ddl-partitioning-declarative">
<!--
   <title>Declarative Partitioning</title>
-->
   <title>宣言的パーティショニング</title>

   <para>
<!--
    <productname>PostgreSQL</productname> offers a way to specify how to
    divide a table into pieces called partitions.  The table that is divided
    is referred to as a <firstterm>partitioned table</firstterm>.  The
    specification consists of the <firstterm>partitioning method</firstterm>
    and a list of columns or expressions to be used as the
    <firstterm>partition key</firstterm>.
-->
<productname>PostgreSQL</productname>はテーブルをパーティションと呼ばれる部品に分割する方法を指定するための方法を提供しています。
分割されたテーブルは<firstterm>パーティションテーブル</firstterm>と呼ばれます。
方法の指定は<firstterm>パーティション方式</firstterm>と<firstterm>パーティションキー</firstterm>として使用される列あるいは式のリストからなります。
   </para>

   <para>
<!--
    All rows inserted into a partitioned table will be routed to one of the
    <firstterm>partitions</firstterm> based on the value of the partition
    key.  Each partition has a subset of the data defined by its
    <firstterm>partition bounds</firstterm>.  The currently supported
    partitioning methods are range, list, and hash.
-->
パーティションテーブルに挿入されるすべての行は、パーティションキーの値に基づいて<firstterm>パーティション</firstterm>の一つに振り向けられます。
各パーティションはその<firstterm>パーティション境界</firstterm>によって定義されるデータの部分集合を持ちます。
現在サポートされるパーティション方式には範囲、リスト、ハッシュがあります。
   </para>

   <para>
<!--
    Partitions may themselves be defined as partitioned tables, using what is
    called <firstterm>sub-partitioning</firstterm>.  Partitions may have their
    own indexes, constraints and default values, distinct from those of other
    partitions.  See <xref linkend="sql-createtable"/> for more details on
    creating partitioned tables and partitions.
-->
<firstterm>サブパーティショニング</firstterm>と呼ばれる方法を使って、パーティションそれ自体をパーティションテーブルとして定義することができます。
パーティションには、他のパーティションとは別に独自のインデックス、制約、デフォルト値を定義できます。
パーティションテーブルおよびパーティションの作成についての更なる詳細については<xref linkend="sql-createtable"/>を参照してください。
   </para>

   <para>
<!--
    It is not possible to turn a regular table into a partitioned table or
    vice versa.  However, it is possible to add a regular or partitioned table
    containing data as a partition of a partitioned table, or remove a
    partition from a partitioned table turning it into a standalone table;
    see <xref linkend="sql-altertable"/> to learn more about the
    <command>ATTACH PARTITION</command> and <command>DETACH PARTITION</command>
    sub-commands.
-->
通常のテーブルをパーティションテーブルに変更する、およびその逆はできません。
しかし、データのある通常のテーブルやパーティションテーブルをパーティションテーブルのパーティションとして追加する、あるいはパーティションテーブルからパーティションを削除し、それを独立したテーブルにすることは可能です。
<command>ATTACH PARTITION</command>および<command>DETACH PARTITION</command>のサブコマンドについての詳細は<xref linkend="sql-altertable"/>を参照してください。
   </para>

   <para>
<!--
    Individual partitions are linked to the partitioned table with inheritance
    behind-the-scenes; however, it is not possible to use some of the
    generic features of inheritance (discussed below) with declaratively
    partitioned tables or their partitions.  For example, a partition
    cannot have any parents other than the partitioned table it is a
    partition of, nor can a regular table inherit from a partitioned table
    making the latter its parent.  That means partitioned tables and their
    partitions do not participate in inheritance with regular tables.
    Since a partition hierarchy consisting of the partitioned table and its
    partitions is still an inheritance hierarchy, all the normal rules of
    inheritance apply as described in <xref linkend="ddl-inherit"/> with
    some exceptions, most notably:
-->
個々のパーティションは継承を背景にパーティションテーブルに紐付けられていますが、宣言的パーティションテーブルもしくはそれらのパーティションでは継承の一般的な機能の一部（後述）を使用することはできません。
例えば、パーティションテーブルのパーティションは、そのパーティションテーブル以外の親を持つことができませんし、また一般のテーブルはパーティションテーブルをその親にしてパーティションテーブルから継承することはできません。
これはつまり、パーティションテーブルおよびそれらのパーティションは一般のテーブルと継承によって繋がることができないということです。
パーティションテーブルとそのパーティションを構成するパーティションの階層は継承の階層でもあるので、継承におけるすべての通常の規則が<xref linkend="ddl-inherit"/>で説明したとおりに適用されますが、いくつか例外があります。
最も重要な例外を以下に示します。

    <itemizedlist>
     <listitem>
      <para>
<!--
       Both <literal>CHECK</literal> and <literal>NOT NULL</literal>
       constraints of a partitioned table are always inherited by all its
       partitions.  <literal>CHECK</literal> constraints that are marked
       <literal>NO INHERIT</literal> are not allowed to be created on
       partitioned tables.
-->
パーティションテーブルの<literal>CHECK</literal>制約と<literal>NOT NULL</literal>制約はいずれも必ずすべてのパーティションに継承されます。
パーティションテーブルで<literal>NO INHERIT</literal>の印を付けた<literal>CHECK</literal>制約を作ることはできません。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       Using <literal>ONLY</literal> to add or drop a constraint on only the
       partitioned table is supported as long as there are no partitions.  Once
       partitions exist, using <literal>ONLY</literal> will result in an error
       as adding or dropping constraints on only the partitioned table, when
       partitions exist, is not supported.  Instead, constraints on the
       partitions themselves can be added and (if they are not present in the
       parent table) dropped.
-->
<literal>ONLY</literal>を使ってパーティションテーブルについてのみ制約を追加または削除することは、パーティションが存在しない場合はサポートされます。
パーティションが存在する時にパーティションテーブルについてのみ制約を追加または削除することはサポートされないため、一度パーティションが存在すれば、<literal>ONLY</literal>の使用はエラーになります。
その代わりに、パーティション自身の制約を追加することや（親テーブルに存在しない場合）削除することが可能です。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       As a partitioned table does not have any data directly, attempts to use
       <command>TRUNCATE</command> <literal>ONLY</literal> on a partitioned
       table will always return an error.
-->
パーティションテーブルは直接データを所有することはないため、<command>TRUNCATE</command> <literal>ONLY</literal>をパーティションテーブルに対して使用しようとすると、必ずエラーが返されます。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       Partitions cannot have columns that are not present in the parent.  It
       is not possible to specify columns when creating partitions with
       <command>CREATE TABLE</command>, nor is it possible to add columns to
       partitions after-the-fact using <command>ALTER TABLE</command>.  Tables may be
       added as a partition with <command>ALTER TABLE ... ATTACH PARTITION</command>
       only if their columns exactly match the parent.
-->
パーティションは親に存在しない列を持つことができません。
パーティションを<command>CREATE TABLE</command>で作成する時に列を指定することはできませんし、作成後に<command>ALTER TABLE</command>でパーティションに列を追加することもできません。
テーブルを<command>ALTER TABLE ... ATTACH PARTITION</command>でパーティションとして追加できるのは、その列が完全に親と一致している場合のみです。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       You cannot drop the <literal>NOT NULL</literal> constraint on a
       partition's column if the constraint is present in the parent table.
-->
親テーブルの列に存在する<literal>NOT NULL</literal>制約をパーティションの列から削除することはできません。
      </para>
     </listitem>
    </itemizedlist>
   </para>

   <para>
<!--
    Partitions can also be foreign tables, although they have some limitations
    that normal tables do not; see <xref linkend="sql-createforeigntable"/> for
    more information.
-->
通常のテーブルにない制限がいくつかありますが、パーティションを外部テーブルとすることができます。
詳細は<xref linkend="sql-createforeigntable"/>を参照してください。
例えば、パーティションテーブルに挿入されるデータは外部テーブルのパーティションには振り向けられません。
   </para>

   <para>
<!--
    Updating the partition key of a row might cause it to be moved into a
    different partition where this row satisfies the partition bounds.
-->
行のパーティションキーを更新することは、その行がパーティション境界を満たす異なるパーティションに移動される原因となるかもしれません。
   </para>

   <sect3 id="ddl-partitioning-declarative-example">
<!--
    <title>Example</title>
-->
    <title>例</title>

   <para>
<!--
    Suppose we are constructing a database for a large ice cream company.
    The company measures peak temperatures every day as well as ice cream
    sales in each region. Conceptually, we want a table like:
-->
大きなアイスクリーム会社のデータベースを構築している場合を考えましょう。
その会社は毎日の最高気温、および各地域でのアイスクリームの売上を計測します。
概念的には次のようなテーブルが必要です。

<programlisting>
CREATE TABLE measurement (
    city_id         int not null,
    logdate         date not null,
    peaktemp        int,
    unitsales       int
);
</programlisting>

<!--
    We know that most queries will access just the last week's, month's or
    quarter's data, since the main use of this table will be to prepare
    online reports for management.  To reduce the amount of old data that
    needs to be stored, we decide to only keep the most recent 3 years
    worth of data. At the beginning of each month we will remove the oldest
    month's data.  In this situation we can use partitioning to help us meet
    all of our different requirements for the measurements table.
-->
このテーブルの主な利用目的は経営層向けにオンラインの報告書を作成することであるため、ほとんどの問い合わせは単に直前の週、月、四半期のデータにアクセスするだけであることがわかっています。
保存すべき古いデータの量を削減するため、最近3年分のデータのみを残すことに決めました。
各月のはじめに、最も古い月のデータを削除します。
この場合、計測テーブルについての様々な要求のすべてを、パーティショニングを使って満たすことができます。
   </para>

   <para>
<!--
    To use declarative partitioning in this case, use the following steps:
-->
この場合に宣言的パーティショニングを使うには、以下の手順に従います。

    <orderedlist spacing="compact">
     <listitem>
      <para>
<!--
       Create <structname>measurement</structname> table as a partitioned
       table by specifying the <literal>PARTITION BY</literal> clause, which
       includes the partitioning method (<literal>RANGE</literal> in this
       case) and the list of column(s) to use as the partition key.
-->
<literal>PARTITION BY</literal>句を指定して、<structname>measurement</structname>テーブルをパーティションテーブルとして作成します。
<literal>PARTITION BY</literal>句にはパーティション方式（この場合は<literal>RANGE</literal>）とパーティションキーとして使う列のリストを記述します。

<programlisting>
CREATE TABLE measurement (
    city_id         int not null,
    logdate         date not null,
    peaktemp        int,
    unitsales       int
) PARTITION BY RANGE (logdate);
</programlisting>
      </para>

      <para>
<!--
       You may decide to use multiple columns in the partition key for range
       partitioning, if desired.  Of course, this will often result in a larger
       number of partitions, each of which is individually smaller.  On the
       other hand, using fewer columns may lead to a coarser-grained
       partitioning criteria with smaller number of partitions.  A query
       accessing the partitioned table will have to scan fewer partitions if
       the conditions involve some or all of these columns.
       For example, consider a table range partitioned using columns
       <structfield>lastname</structfield> and <structfield>firstname</structfield> (in that order)
       as the partition key.
-->
望むなら、範囲パーティショニングのパーティションキーとして複数の列を使うようにすることもできます。
もちろん、こうすると多くの場合、パーティションの数が増え、各パーティションの大きさは小さくなります。
一方で、列の数を少なくすると、パーティショニングの基準の粒度が荒くなり、パーティションの数が少なくなります。
パーティションテーブルにアクセスする問い合わせで、その条件がこれらの列の一部またはすべてを含む場合、より少ない数のパーティションを走査することになります。
例えば、パーティションキーとして列<structfield>lastname</structfield>と<structfield>firstname</structfield>を（この順で）使用して範囲パーティショニングをしたテーブルを考えてみてください。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       Create partitions.  Each partition's definition must specify the bounds
       that correspond to the partitioning method and partition key of the
       parent.  Note that specifying bounds such that the new partition's
       values will overlap with those in one or more existing partitions will
       cause an error.  Inserting data into the parent table that does not map
       to one of the existing partitions will cause an error; an appropriate
       partition must be added manually.
-->
パーティションを作成します。
各パーティションの定義では、親のパーティショニング方式およびパーティションキーに対応する境界を指定しなければなりません。
新しいパーティションの値が一つ以上の既存のパーティションの値と重なるような境界を指定するとエラーになることに注意してください。
既存のおよびパーティションのどれにも当てはまらないデータを親テーブルに挿入するとエラーになります。
この場合、適切なパーティションを手作業で追加しなければなりません。
      </para>

      <para>
<!--
       Partitions thus created are in every way normal
       <productname>PostgreSQL</productname>
       tables (or, possibly, foreign tables).  It is possible to specify a
       tablespace and storage parameters for each partition separately.
-->
こうして作成されたパーティションは、すべての点において<productname>PostgreSQL</productname>の通常のテーブル（あるいは場合によっては外部テーブル）と同じです。
各パーティション毎に別々にテーブル空間や格納パラメータを指定することもできます。
      </para>

      <para>
<!--
       It is not necessary to create table constraints describing partition
       boundary condition for partitions.  Instead, partition constraints are
       generated implicitly from the partition bound specification whenever
       there is need to refer to them.
-->
各パーティションについて、パーティションの境界条件を定義するテーブル制約を作成する必要はありません。
その代わりに、指定した境界条件からパーティション制約が暗黙的に生成され、必要なときにはそれが参照されます。

<programlisting>
CREATE TABLE measurement_y2006m02 PARTITION OF measurement
    FOR VALUES FROM ('2006-02-01') TO ('2006-03-01');

CREATE TABLE measurement_y2006m03 PARTITION OF measurement
    FOR VALUES FROM ('2006-03-01') TO ('2006-04-01');

...
CREATE TABLE measurement_y2007m11 PARTITION OF measurement
    FOR VALUES FROM ('2007-11-01') TO ('2007-12-01');

CREATE TABLE measurement_y2007m12 PARTITION OF measurement
    FOR VALUES FROM ('2007-12-01') TO ('2008-01-01')
    TABLESPACE fasttablespace;

CREATE TABLE measurement_y2008m01 PARTITION OF measurement
    FOR VALUES FROM ('2008-01-01') TO ('2008-02-01')
    WITH (parallel_workers = 4)
    TABLESPACE fasttablespace;
</programlisting>
      </para>

      <para>
<!--
       To implement sub-partitioning, specify the
       <literal>PARTITION BY</literal> clause in the commands used to create
       individual partitions, for example:
-->
サブパーティショニングを実装するには、例えば以下のように、個々のパーティションを作成するコマンドで<literal>PARTITION BY</literal>句を指定してください。

<programlisting>
CREATE TABLE measurement_y2006m02 PARTITION OF measurement
    FOR VALUES FROM ('2006-02-01') TO ('2006-03-01')
    PARTITION BY RANGE (peaktemp);
</programlisting>

<!--
       After creating partitions of <structname>measurement_y2006m02</structname>,
       any data inserted into <structname>measurement</structname> that is mapped to
       <structname>measurement_y2006m02</structname> (or data that is directly inserted
       into <structname>measurement_y2006m02</structname>, provided it satisfies its
       partition constraint) will be further redirected to one of its
       partitions based on the <structfield>peaktemp</structfield> column.  The partition
       key specified may overlap with the parent's partition key, although
       care should be taken when specifying the bounds of a sub-partition
       such that the set of data it accepts constitutes a subset of what
       the partition's own bounds allows; the system does not try to check
       whether that's really the case.
-->
<structname>measurement_y2006m02</structname>のパーティションの作成後、<structname>measurement</structname>に挿入されるデータで<structname>measurement_y2006m02</structname>に振り向けられるもの（あるいは<structname>measurement_y2006m02</structname>に直接挿入されるデータでそのパーティション制約を満たしているもの）はすべて、<structfield>peaktemp</structfield>列に基いて更にその下のパーティションの一つにリダイレクトされます。
指定するパーティションキーは親のパーティションキーと重なっても構いませんが、サブパーティションの境界を指定するときは、それが受け付けるデータの集合がパーティション自体の境界でできるものの部分集合を構成するように注意してください。
システムは本当にそのようになっているかどうか、検査しようとしません。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       Create an index on the key column(s), as well as any other indexes you
       might want, on the partitioned table. (The key index is not strictly
       necessary, but in most scenarios it is helpful.)
       This automatically creates
       one index on each partition, and any partitions you create or attach
       later will also contain the index.
-->
キー列にインデックスを作成し、またその他のインデックスも必要に応じてパーティションテーブル上に作成します。
（厳密に言えば、キー列のインデックスは必要なわけではありませんが、ほとんどの場合に役に立つでしょう。）
これは各パーティション上に1つのインデックスを自動的に作ります。
後から作成もしくは追加したパーティションにもインデックスが含まれます。

<programlisting>
CREATE INDEX ON measurement (logdate);
</programlisting>
      </para>
     </listitem>

      <listitem>
       <para>
<!--
        Ensure that the <xref linkend="guc-enable-partition-pruning"/>
        configuration parameter is not disabled in <filename>postgresql.conf</filename>.
        If it is, queries will not be optimized as desired.
-->
<filename>postgresql.conf</filename>で設定パラメータ<xref linkend="guc-enable-partition-pruning"/>が無効になっていないことを確認します。
これが無効になっていると、問い合わせが期待通りには最適化されません。
       </para>
      </listitem>
    </orderedlist>
   </para>

   <para>
<!--
    In the above example we would be creating a new partition each month, so
    it might be wise to write a script that generates the required DDL
    automatically.
-->
上記の例では、毎月、新しいパーティションを作ることになりますから、必要なDDLを自動的に生成するスクリプトを作るのが賢明かもしれません。
   </para>
   </sect3>

   <sect3 id="ddl-partitioning-declarative-maintenance">
<!--
    <title>Partition Maintenance</title>
-->
    <title>パーティションの保守</title>

    <para>
<!--
      Normally the set of partitions established when initially defining the
      table is not intended to remain static.  It is common to want to
      remove old partitions of data and periodically add new partitions for
      new data. One of the most important advantages of partitioning is
      precisely that it allows this otherwise painful task to be executed
      nearly instantaneously by manipulating the partition structure, rather
      than physically moving large amounts of data around.
-->
最初にテーブルを定義した時に作成したパーティションの集合は、通常はそのまま静的に残ることを意図したものではありません。
古いデータのパーティションを削除し、新しいデータの入った新しいパーティションを定期的に作成したいというのが普通です。
パーティショニングのもっとも重要な利点の一つは、パーティショニングがなければ大変なことになるであろうこの作業を、大量のデータを物理的に動かすのではなく、パーティション構造を操作することにより、ほとんど一瞬にして実行できるという、まさにそのことなのです。
    </para>

    <para>
<!--
     The simplest option for removing old data is to drop the partition that
     is no longer necessary:
-->
古いデータを削除する最も単純な方法は、次のように、不要になったパーティションを削除することです。
<programlisting>
DROP TABLE measurement_y2006m02;
</programlisting>
<!--
     This can very quickly delete millions of records because it doesn't have
     to individually delete every record.  Note however that the above command
     requires taking an <literal>ACCESS EXCLUSIVE</literal> lock on the parent
     table.
-->
これはすべてのレコードを個別に削除する必要がないため、数百万行のレコードを非常に高速に削除できます。
ただし、上記のコマンドは親テーブルについて<literal>ACCESS EXCLUSIVE</literal>ロックを取得する必要があることに注意してください。
    </para>

   <para>
<!--
     Another option that is often preferable is to remove the partition from
     the partitioned table but retain access to it as a table in its own
     right:
-->
別の方法で多くの場合に望ましいのは、パーティションテーブルからパーティションを削除する一方で、パーティションそれ自体はテーブルとしてアクセス可能なまま残すことです。

<programlisting>
ALTER TABLE measurement DETACH PARTITION measurement_y2006m02;
</programlisting>

<!--
     This allows further operations to be performed on the data before
     it is dropped. For example, this is often a useful time to back up
     the data using <command>COPY</command>, <application>pg_dump</application>, or
     similar tools. It might also be a useful time to aggregate data
     into smaller formats, perform other data manipulations, or run
     reports.
-->
こうすると、データを削除する前に、そのデータについて追加の操作が実行できます。
例えば、<command>COPY</command>、<application>pg_dump</application>や類似のツールを使ってデータのバックアップをする好機となることが多いでしょう。
また、データを集計してより小さな形式にする、その他のデータ操作を実行する、レポート作成を実行するなどのための好機となるかもしれません。
   </para>

   <para>
<!--
     Similarly we can add a new partition to handle new data. We can create an
     empty partition in the partitioned table just as the original partitions
     were created above:
-->
同様に、新しいデータを扱うために新しいパーティションを追加することができます。
上で元のパーティションを作ったのと全く同じように、パーティションテーブル内に空のパーティションを以下のように作成できます。

<programlisting>
CREATE TABLE measurement_y2008m02 PARTITION OF measurement
    FOR VALUES FROM ('2008-02-01') TO ('2008-03-01')
    TABLESPACE fasttablespace;
</programlisting>

<!--
     As an alternative, it is sometimes more convenient to create the
     new table outside the partition structure, and make it a proper
     partition later. This allows the data to be loaded, checked, and
     transformed prior to it appearing in the partitioned table:
-->
別の方法として、新しいテーブルをパーティション構造の外部に作成し、その後でそれを適切なパーティションにする方が便利な場合もあります。
こうすると、パーティションテーブル内でデータが見えるようになるより前に、データをロードし、確認し、変換することができます。

<programlisting>
CREATE TABLE measurement_y2008m02
  (LIKE measurement INCLUDING DEFAULTS INCLUDING CONSTRAINTS)
  TABLESPACE fasttablespace;

ALTER TABLE measurement_y2008m02 ADD CONSTRAINT y2008m02
   CHECK ( logdate &gt;= DATE '2008-02-01' AND logdate &lt; DATE '2008-03-01' );

\copy measurement_y2008m02 from 'measurement_y2008m02'
-- possibly some other data preparation work

ALTER TABLE measurement ATTACH PARTITION measurement_y2008m02
    FOR VALUES FROM ('2008-02-01') TO ('2008-03-01' );
</programlisting>
    </para>

    <para>
<!--
     Before running the <command>ATTACH PARTITION</command> command, it is
     recommended to create a <literal>CHECK</literal> constraint on the table to
     be attached matching the desired partition constraint. That way,
     the system will be able to skip the scan which is otherwise needed to validate the implicit
     partition constraint. Without the <literal>CHECK</literal> constraint,
     the table will be scanned to validate the partition constraint while
     holding an <literal>ACCESS EXCLUSIVE</literal> lock on that partition
     and a <literal>SHARE UPDATE EXCLUSIVE</literal> lock on the parent table.
     It may be desired to drop the redundant <literal>CHECK</literal> constraint
     after <command>ATTACH PARTITION</command> is finished.
-->
<command>ATTACH PARTITION</command>コマンドを実行する前に、マッチするパーティション制約を記述する<literal>CHECK</literal>制約を、パーティションに追加するテーブルに作成することを推奨します。
こうすることで、システムは暗示的なパーティション制約を検証するための走査を省略することができます。
このような制約がなければ、そのパーティションに<literal>ACCESS EXCLUSIVE</literal>ロック、親テーブルに<literal>SHARE UPDATE EXCLUSIVE</literal>を保持したままで、パーティション制約を検証するためにテーブルを走査することになります。
この制約は<command>ATTACH PARTITION</command>が終わった後に削除するのが望ましいかも知れません。
    </para>

    <para>
<!--
     As explained above, it is possible to create indexes on partitioned tables
     and they are applied automatically to the entire hierarchy.  This is very
     convenient, as not only the existing partitions will become indexed, but
     also any partitions that are created in the future will.  One limitation is
     that it's not possible to use the <literal>CONCURRENTLY</literal>
     qualifier when creating such a partitioned index.  To overcome long lock
     times, it is possible to use <command>CREATE INDEX ON ONLY</command>
     the partitioned table; such an index is marked invalid, and the partitions
     do not get the index applied automatically.  The indexes on partitions can
     be created separately using <literal>CONCURRENTLY</literal>, and later
     <firstterm>attached</firstterm> to the index on the parent using
     <command>ALTER INDEX .. ATTACH PARTITION</command>.  Once indexes for all
     partitions are attached to the parent index, the parent index is marked
     valid automatically.  Example:
-->
前述したとおり、パーティションテーブル上にインデックスを作成することが可能であり、それらは階層全体に自動で適用されます。
既存のパーティションだけではなく将来作成されるパーティションもインデックス付けされるため、これはとても便利です。
一つの制限は、そのようなパーティションのインデックスを作成する場合<literal>CONCURRENTLY</literal>句を使うことができません。
長いロック時間を克服するためには、パーティションテーブルに<command>CREATE INDEX ON ONLY</command>を使うことが可能です。
そのようなインデックスは無効とマークされ、パーティションは適用するインデックスを自動で取得しません。
パーティション上のインデックスは<literal>CONCURRENTLY</literal>を使用して個々に作成することができ、後から<command>ALTER INDEX .. ATTACH PARTITION</command>を使用して親のインデックスに<firstterm>attached</firstterm>できます。
全てのパーティションに対してインデックスがアタッチされた時点で、親のインデックスは、自動で有効とマークされます。
例を示します。
<programlisting>
CREATE INDEX measurement_usls_idx ON ONLY measurement (unitsales);

CREATE INDEX measurement_usls_200602_idx
    ON measurement_y2006m02 (unitsales);
ALTER INDEX measurement_usls_idx
    ATTACH PARTITION measurement_usls_200602_idx;
...
</programlisting>

<!--
     This technique can be used with <literal>UNIQUE</literal> and
     <literal>PRIMARY KEY</literal> constraints too; the indexes are created
     implicitly when the constraint is created.  Example:
-->
この手法は、<literal>UNIQUE</literal>と<literal>PRIMARY KEY</literal>制約でも使用できます。
制約が作成された際にインデックスは暗黙的に作成されます。
例を示します。
<programlisting>
ALTER TABLE ONLY measurement ADD UNIQUE (city_id, logdate);

ALTER TABLE measurement_y2006m02 ADD UNIQUE (city_id, logdate);
ALTER INDEX measurement_city_id_logdate_key
    ATTACH PARTITION measurement_y2006m02_city_id_logdate_key;
...
</programlisting>
    </para>
   </sect3>

   <sect3 id="ddl-partitioning-declarative-limitations">
<!--
    <title>Limitations</title>
-->
    <title>制限事項</title>

   <para>
<!--
    The following limitations apply to partitioned tables:
-->
パーティションテーブルには以下の制限事項があります。
    <itemizedlist>
     <listitem>
      <para>
<!--
       There is no way to create an
       exclusion constraint spanning all partitions; it is only possible
       to constrain each leaf partition individually.
-->
すべてのパーティションにまたがる排他制約を作成する方法はありません。
それぞれの末端のパーティションについて別々に制約をつけることしかできません。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       Unique constraints (and hence primary keys) on partitioned tables must
       include all the partition key columns.  This limitation exists because
       <productname>PostgreSQL</productname> can only enforce
       uniqueness in each partition individually.
-->
パーティションテーブル上の一意制約は、すべてのパーティションキー列を含んでいなければなりません。
<productname>PostgreSQL</productname>が各パーティションの一意性を個別に強制するために、この制限は存在します。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       <literal>BEFORE ROW</literal> triggers cannot change which partition
       is the final destination for a new row.
-->
<literal>BEFORE ROW</literal>トリガーが必要であれば、パーティションテーブルではなく、個々のパーティションに定義されなければなりなません。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       Mixing temporary and permanent relations in the same partition tree is
       not allowed.  Hence, if the partitioned table is permanent, so must be
       its partitions and likewise if the partitioned table is temporary.  When
       using temporary relations, all members of the partition tree have to be
       from the same session.
-->
一時リレーションと永続的リレーションを同じパーティションツリーに混合することはできません。
ですから、パーティション化されたテーブルが永続的なら、パーティションも永続的でなければなりません。
同様にパーティション化されたテーブルが一時的なら、パーティションも一時的でなければなりません。
一時リレーションを使う場合は、パーティションツリーのすべてのメンバーは同じセッションに由来しなければなりません。
      </para>
     </listitem>
    </itemizedlist>
    </para>
    </sect3>
   </sect2>

   <sect2 id="ddl-partitioning-implementation-inheritance">
<!--
    <title>Implementation Using Inheritance</title>
-->
    <title>継承を使用した実装</title>
    <para>
<!--
     While the built-in declarative partitioning is suitable for most
     common use cases, there are some circumstances where a more flexible
     approach may be useful.  Partitioning can be implemented using table
     inheritance, which allows for several features not supported
     by declarative partitioning, such as:
-->
組み込みの宣言的パーティショニングは、ほとんどの一般的な利用例に適合しますが、もっと柔軟な方式が便利な状況もあります。
パーティショニングはテーブルの継承を使用して実装することも可能で、これは宣言的パーティショニングではサポートされない以下のような機能が利用できます。

     <itemizedlist>
      <listitem>
       <para>
<!--
        For declarative partitioning, partitions must have exactly the same set
        of columns as the partitioned table, whereas with table inheritance,
        child tables may have extra columns not present in the parent.
-->
宣言的パーティショニングの場合、パーティションは正確にパーティションテーブルと同じ列の集合を持たなければなりません。
一方テーブルの継承では、子テーブルは親テーブルに存在しない追加の列を持つかもしれません。
       </para>
      </listitem>

      <listitem>
       <para>
<!--
        Table inheritance allows for multiple inheritance.
-->
テーブルの継承では、複数の継承が可能です。
       </para>
      </listitem>

      <listitem>
       <para>
<!--
        Declarative partitioning only supports range, list and hash
        partitioning, whereas table inheritance allows data to be divided in a
        manner of the user's choosing.  (Note, however, that if constraint
        exclusion is unable to prune child tables effectively, query performance
        might be poor.)
-->
宣言的パーティショニングではリストパーティショニング、範囲パーティショニングとハッシュパーティショニングしかサポートされませんが、テーブルの継承ではユーザが選択した方法に従ってデータを分割することができます。
（ただし、制約による除外が子テーブルを効果的に分離できない場合、問い合わせのパフォーマンスが悪くなるかもしれないことに注意してください。）
       </para>
      </listitem>

      <listitem>
       <para>
<!--
        Some operations require a stronger lock when using declarative
        partitioning than when using table inheritance.  For example,
        removing a partition from a partitioned table requires taking
        an <literal>ACCESS EXCLUSIVE</literal> lock on the parent table,
        whereas a <literal>SHARE UPDATE EXCLUSIVE</literal> lock is enough
        in the case of regular inheritance.
-->
宣言的パーティショニングを使用すると、テーブルの継承を使用する場合に比べて、一部の走査でより強いロックが要求されます。
例えば、パーティションテーブルからパーティションを削除するには、親テーブルの<literal>ACCESS EXCLUSIVE</literal>ロックを取得する必要がありますが、通常の継承の場合には<literal>SHARE UPDATE EXCLUSIVE</literal>ロックで十分です。
       </para>
      </listitem>
     </itemizedlist>
    </para>

    <sect3 id="ddl-partitioning-inheritance-example">
<!--
     <title>Example</title>
-->
     <title>例</title>

     <para>
<!--
      We use the non-partitioned <structname>measurement</structname>
      table above.  To implement partitioning using inheritance, use
      the following steps:
-->
上の非パーティション<structname>measurement</structname>テーブルを使用します。
継承を使用したパーティショニングを実装するには、以下の手順に従います。

      <orderedlist spacing="compact">
       <listitem>
        <para>
<!--
         Create the <quote>master</quote> table, from which all of the
         <quote>child</quote> tables will inherit.  This table will contain no data.  Do not
         define any check constraints on this table, unless you intend them
         to be applied equally to all child tables.  There is no point in
         defining any indexes or unique constraints on it, either.  For our
         example, the master table is the <structname>measurement</structname>
         table as originally defined.
-->
<quote>マスター</quote>テーブルを作成します。
すべての<quote>子</quote>テーブルはこれを継承します。
このテーブルにはデータは含まれません。
子テーブルに同じように適用されるのでなければ、このテーブルにチェック制約を定義しないでください。
このテーブル上にインデックスや一意制約を定義することにも意味はありません。
以下の例では、マスターテーブルは最初に定義したのと同じ<structname>measurement</structname>テーブルです。
        </para>
       </listitem>

       <listitem>
        <para>
<!--
         Create several <quote>child</quote> tables that each inherit from
         the master table.  Normally, these tables will not add any columns
         to the set inherited from the master.  Just as with declarative
         partitioning, these tables are in every way normal
         <productname>PostgreSQL</productname> tables (or foreign tables).
-->
いくつかの<quote>子</quote>テーブルを作成し、それぞれマスターテーブルを継承するものにします。
通常、これらのテーブルはマスターから継承したものに列を追加しません。
宣言的パーティショニングの場合と同じく、これらのテーブルはすべての点で普通の<productname>PostgreSQL</productname>のテーブル（あるいは外部テーブル）と同じです。
        </para>

        <para>
<programlisting>
CREATE TABLE measurement_y2006m02 () INHERITS (measurement);
CREATE TABLE measurement_y2006m03 () INHERITS (measurement);
...
CREATE TABLE measurement_y2007m11 () INHERITS (measurement);
CREATE TABLE measurement_y2007m12 () INHERITS (measurement);
CREATE TABLE measurement_y2008m01 () INHERITS (measurement);
</programlisting>
        </para>
       </listitem>

       <listitem>
        <para>
<!--
         Add non-overlapping table constraints to the child tables to
         define the allowed key values in each.
-->
子テーブルに、重なり合わないテーブル制約を追加し、各テーブルに許されるキー値を定義します。
        </para>

        <para>
<!--
         Typical examples would be:
-->
典型的な例は次のようなものです。
<programlisting>
CHECK ( x = 1 )
CHECK ( county IN ( 'Oxfordshire', 'Buckinghamshire', 'Warwickshire' ))
CHECK ( outletID &gt;= 100 AND outletID &lt; 200 )
</programlisting>
<!--
         Ensure that the constraints guarantee that there is no overlap
         between the key values permitted in different child tables.  A common
         mistake is to set up range constraints like:
-->
制約により、異なる子テーブルで許されるキー値に重なりがないことが保証されるようにします。
よくある誤りは、次のような範囲制約を設定することです。
<programlisting>
CHECK ( outletID BETWEEN 100 AND 200 )
CHECK ( outletID BETWEEN 200 AND 300 )
</programlisting>
<!--
         This is wrong since it is not clear which child table the key
         value 200 belongs in.
-->
キー値200がどちらの子テーブルに属するか明らかではないため、これは誤っています。
        </para>

        <para>
<!--
         It would be better to instead create child tables as follows:
-->
その代わりに以下のように子テーブルを作る方が良いでしょう。

<programlisting>
CREATE TABLE measurement_y2006m02 (
    CHECK ( logdate &gt;= DATE '2006-02-01' AND logdate &lt; DATE '2006-03-01' )
) INHERITS (measurement);

CREATE TABLE measurement_y2006m03 (
    CHECK ( logdate &gt;= DATE '2006-03-01' AND logdate &lt; DATE '2006-04-01' )
) INHERITS (measurement);

...
CREATE TABLE measurement_y2007m11 (
    CHECK ( logdate &gt;= DATE '2007-11-01' AND logdate &lt; DATE '2007-12-01' )
) INHERITS (measurement);

CREATE TABLE measurement_y2007m12 (
    CHECK ( logdate &gt;= DATE '2007-12-01' AND logdate &lt; DATE '2008-01-01' )
) INHERITS (measurement);

CREATE TABLE measurement_y2008m01 (
    CHECK ( logdate &gt;= DATE '2008-01-01' AND logdate &lt; DATE '2008-02-01' )
) INHERITS (measurement);
</programlisting>
        </para>
       </listitem>

       <listitem>
        <para>
<!--
         For each child table, create an index on the key column(s),
         as well as any other indexes you might want.
-->
各子テーブルについて、キー列にインデックスを作成し、またその他のインデックスも必要に応じて作成します。
<programlisting>
CREATE INDEX measurement_y2006m02_logdate ON measurement_y2006m02 (logdate);
CREATE INDEX measurement_y2006m03_logdate ON measurement_y2006m03 (logdate);
CREATE INDEX measurement_y2007m11_logdate ON measurement_y2007m11 (logdate);
CREATE INDEX measurement_y2007m12_logdate ON measurement_y2007m12 (logdate);
CREATE INDEX measurement_y2008m01_logdate ON measurement_y2008m01 (logdate);
</programlisting>
        </para>
       </listitem>

       <listitem>
        <para>
<!--
         We want our application to be able to say <literal>INSERT INTO
         measurement ...</literal> and have the data be redirected into the
         appropriate child table.  We can arrange that by attaching
         a suitable trigger function to the master table.
         If data will be added only to the latest child, we can
         use a very simple trigger function:
-->
アプリケーションで<literal>INSERT INTO measurement ...</literal>を実行することができ、そのときにデータが適切な子テーブルにリダイレクトされることが望ましいです。
マスターテーブルに適当なトリガー関数を追加することでそのような設定にすることができます。
データが最後の子テーブルにしか追加されないなら、次のような非常に単純なトリガー関数を使うことができます。

<programlisting>
CREATE OR REPLACE FUNCTION measurement_insert_trigger()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO measurement_y2008m01 VALUES (NEW.*);
    RETURN NULL;
END;
$$
LANGUAGE plpgsql;
</programlisting>
        </para>

        <para>
<!--
         After creating the function, we create a trigger which
         calls the trigger function:
-->
関数を作成した後で、このトリガ関数を呼ぶトリガを作成します。

<programlisting>
CREATE TRIGGER insert_measurement_trigger
    BEFORE INSERT ON measurement
    FOR EACH ROW EXECUTE FUNCTION measurement_insert_trigger();
</programlisting>

<!--
         We must redefine the trigger function each month so that it always
         points to the current child table.  The trigger definition does
         not need to be updated, however.
-->
トリガが常に現在の子テーブルを指すようにするためには、毎月、トリガ関数を再定義しなくてはいけません。
しかし、トリガ定義を更新する必要はありません。
        </para>

        <para>
<!--
         We might want to insert data and have the server automatically
         locate the child table into which the row should be added. We
         could do this with a more complex trigger function, for example:
-->
データを挿入したら、サーバが行を追加すべき子テーブルを自動的に決定するようにしたいかもしれません。
これは以下のようなもっと複雑なトリガ関数を作成することにより可能です。

<programlisting>
CREATE OR REPLACE FUNCTION measurement_insert_trigger()
RETURNS TRIGGER AS $$
BEGIN
    IF ( NEW.logdate &gt;= DATE '2006-02-01' AND
         NEW.logdate &lt; DATE '2006-03-01' ) THEN
        INSERT INTO measurement_y2006m02 VALUES (NEW.*);
    ELSIF ( NEW.logdate &gt;= DATE '2006-03-01' AND
            NEW.logdate &lt; DATE '2006-04-01' ) THEN
        INSERT INTO measurement_y2006m03 VALUES (NEW.*);
    ...
    ELSIF ( NEW.logdate &gt;= DATE '2008-01-01' AND
            NEW.logdate &lt; DATE '2008-02-01' ) THEN
        INSERT INTO measurement_y2008m01 VALUES (NEW.*);
    ELSE
        RAISE EXCEPTION 'Date out of range.  Fix the measurement_insert_trigger() function!';
    END IF;
    RETURN NULL;
END;
$$
LANGUAGE plpgsql;
</programlisting>

<!--
         The trigger definition is the same as before.
         Note that each <literal>IF</literal> test must exactly match the
         <literal>CHECK</literal> constraint for its child table.
-->
トリガ定義は前と同じです。
それぞれの<literal>IF</literal>テストを子テーブルの<literal>CHECK</literal>制約と正確に一致させなければならないことに注意してください。
        </para>

        <para>
<!--
         While this function is more complex than the single-month case,
         it doesn't need to be updated as often, since branches can be
         added in advance of being needed.
-->
この関数は単一月の場合より複雑になりますが、頻繁に更新する必要はありません。なぜなら条件分岐を前もって追加しておくことが可能だからです。
        </para>

        <note>
         <para>
<!--
          In practice, it might be best to check the newest child first,
          if most inserts go into that child.  For simplicity, we have
          shown the trigger's tests in the same order as in other parts
          of this example.
-->
実際には、ほとんどの挿入が一番新しい子テーブルに入る場合は、その子を最初に検査することが最善です。
簡単にするため、この例でのほかの部分と同じ順番でのトリガのテストを示しました。
         </para>
        </note>

        <para>
<!--
         A different approach to redirecting inserts into the appropriate
         child table is to set up rules, instead of a trigger, on the
         master table.  For example:
-->
挿入を適切な子テーブルにリダイレクトする別の方法は、マスターテーブルにトリガーではなくルールを設定することです。
例えば次のようにします。

<programlisting>
CREATE RULE measurement_insert_y2006m02 AS
ON INSERT TO measurement WHERE
    ( logdate &gt;= DATE '2006-02-01' AND logdate &lt; DATE '2006-03-01' )
DO INSTEAD
    INSERT INTO measurement_y2006m02 VALUES (NEW.*);
...
CREATE RULE measurement_insert_y2008m01 AS
ON INSERT TO measurement WHERE
    ( logdate &gt;= DATE '2008-01-01' AND logdate &lt; DATE '2008-02-01' )
DO INSTEAD
    INSERT INTO measurement_y2008m01 VALUES (NEW.*);
</programlisting>

<!--
         A rule has significantly more overhead than a trigger, but the
         overhead is paid once per query rather than once per row, so this
         method might be advantageous for bulk-insert situations.  In most
         cases, however, the trigger method will offer better performance.
-->
ルールはトリガーに比べるとかなり大きなオーバーヘッドがありますが、このオーバーヘッドは一つの問い合わせに対して一度だけで行ごとではないので、この方法にも一括挿入の状況では利点があります。
ただし、ほとんどの場合はトリガーを使う方法の方が良いパフォーマンスが得られます。
        </para>

        <para>
<!--
         Be aware that <command>COPY</command> ignores rules.  If you want to
         use <command>COPY</command> to insert data, you'll need to copy into the
         correct child table rather than directly into the master. <command>COPY</command>
         does fire triggers, so you can use it normally if you use the trigger
         approach.
-->
<command>COPY</command>はルールを無視することに注意してください。
データの挿入に<command>COPY</command>を使いたい場合は、マスターではなく正しい子テーブルにコピーする必要があります。
トリガーであれば<command>COPY</command>でも起動されるので、トリガーを使う方法であれば通常通りに使用することができます。
        </para>

        <para>
<!--
         Another disadvantage of the rule approach is that there is no simple
         way to force an error if the set of rules doesn't cover the insertion
         date; the data will silently go into the master table instead.
-->
ルールを使う方法のもう一つの欠点は、ルールの集合が挿入日付に対応しきれていない場合に、強制的にエラーにする簡単な方法がないことです。
この場合、データは警告などを出すことなくマスターテーブルに入ります。
        </para>
       </listitem>

       <listitem>
        <para>
<!--
         Ensure that the <xref linkend="guc-constraint-exclusion"/>
         configuration parameter is not disabled in
         <filename>postgresql.conf</filename>; otherwise
         child tables may be accessed unnecessarily.
-->
設定パラメータ<xref linkend="guc-constraint-exclusion"/>が<filename>postgresql.conf</filename>で無効にされないようにしてください。
他の子テーブルが不要にアクセスされるかもしれません。
        </para>
       </listitem>
      </orderedlist>
     </para>

     <para>
<!--
      As we can see, a complex table hierarchy could require a
      substantial amount of DDL.  In the above example we would be creating
      a new child table each month, so it might be wise to write a script that
      generates the required DDL automatically.
-->
以上のように、複雑なテーブルの階層はたくさんのDDLが必要となります。
上記の例では、毎月新しい子テーブルを作成することになりますが、必要となるDDLを自動的に生成するスクリプトを書くのが賢明です。
     </para>
    </sect3>

    <sect3 id="ddl-partitioning-inheritance-maintenance">
<!--
     <title>Maintenance for Inheritance Partitioning</title>
-->
     <title>継承パーティショニングの保守</title>
     <para>
<!--
      To remove old data quickly, simply drop the child table that is no longer
      necessary:
-->
古いデータを高速に削除するには、不要になった子テーブルを単に削除します。
<programlisting>
DROP TABLE measurement_y2006m02;
</programlisting>
     </para>

    <para>
<!--
     To remove the child table from the inheritance hierarchy table but retain access to
     it as a table in its own right:
-->
子テーブルを継承階層テーブルから削除するものの、それ自体をテーブルとしてアクセスできるようにするには、次のようにします。

<programlisting>
ALTER TABLE measurement_y2006m02 NO INHERIT measurement;
</programlisting>
    </para>

    <para>
<!--
     To add a new child table to handle new data, create an empty child table
     just as the original children were created above:
-->
新しいデータを扱う新しい子テーブルを追加するには、上で最初の子テーブルを作成したときと同じように空の子テーブルを作成します。

<programlisting>
CREATE TABLE measurement_y2008m02 (
    CHECK ( logdate &gt;= DATE '2008-02-01' AND logdate &lt; DATE '2008-03-01' )
) INHERITS (measurement);
</programlisting>

<!--
     Alternatively, one may want to create and populate the new child table
     before adding it to the table hierarchy.  This could allow data to be
     loaded, checked, and transformed before being made visible to queries on
     the parent table.
-->
あるいは、新たな子テーブルをテーブル階層に追加する前に作成してデータ投入したい場合もあるでしょう。
これは、親テーブルのクエリから見えるようになる前にデータのロード、確認、変換できるでしょう。

<programlisting>
CREATE TABLE measurement_y2008m02
  (LIKE measurement INCLUDING DEFAULTS INCLUDING CONSTRAINTS);
ALTER TABLE measurement_y2008m02 ADD CONSTRAINT y2008m02
   CHECK ( logdate &gt;= DATE '2008-02-01' AND logdate &lt; DATE '2008-03-01' );
\copy measurement_y2008m02 from 'measurement_y2008m02'
<!--
&#045;- possibly some other data preparation work
-->
-- その他のデータ準備操作を行うこともあります。
ALTER TABLE measurement_y2008m02 INHERIT measurement;
</programlisting>
    </para>
   </sect3>

   <sect3 id="ddl-partitioning-inheritance-caveats">
<!--
    <title>Caveats</title>
-->
    <title>注意事項</title>

    <para>
<!--
     The following caveats apply to partitioning implemented using
     inheritance:
-->
継承を使用して実装したパーティショニングには以下の注意事項があります。
     <itemizedlist>
      <listitem>
       <para>
<!--
        There is no automatic way to verify that all of the
        <literal>CHECK</literal> constraints are mutually
        exclusive.  It is safer to create code that generates
        child tables and creates and/or modifies associated objects than
        to write each by hand.
-->
すべての<literal>CHECK</literal>制約が相互に排他的であることを自動的に確認する手段はありません。
各子テーブルを手作業で作成するよりも、子テーブルを生成し、関連オブジェクトを作成、更新するコードを作成するのが安全でしょう。
       </para>
      </listitem>

      <listitem>
       <para>
<!--
        Indexes and foreign key constraints apply to single tables and not
        to their inheritance children, hence they have some
        <link linkend="ddl-inherit-caveats">caveats</link> to be aware of.
-->
インデックスと外部キー制約は継承上の子ではなく、単一テーブルに適用されます。したがってそれらは<link linkend="ddl-inherit-caveats">警告</link>に気を付ける必要があります。
       </para>
      </listitem>

      <listitem>
       <para>
<!--
        The schemes shown here assume that the values of a row's key column(s)
        never change, or at least do not change enough to require it to move to another partition.
        An <command>UPDATE</command> that attempts
        to do that will fail because of the <literal>CHECK</literal> constraints.
        If you need to handle such cases, you can put suitable update triggers
        on the child tables, but it makes management of the structure
        much more complicated.
-->
ここで示した方法は、行のキー列の値が変わらないか、あるいは、少なくとも他のパーティションへの移動が必要になるような変更はないということを前提としています。
そのような変更をしようとする<command>UPDATE</command>は<literal>CHECK</literal>制約のためにエラーになります。
このような場合を処理できる必要があるなら、子テーブルに適切なUPDATEトリガーを設定することもできますが、構造の管理がずっと複雑になります。
       </para>
      </listitem>

      <listitem>
       <para>
<!--
        If you are using manual <command>VACUUM</command> or
        <command>ANALYZE</command> commands, don't forget that
        you need to run them on each child table individually. A command like:
-->
手作業で<command>VACUUM</command>あるいは<command>ANALYZE</command>コマンドを実行している場合、それを個々の子テーブルに対して実行する必要があることを忘れないで下さい。
次のようなコマンドはマスターテーブルしか処理しません。
<programlisting>
ANALYZE measurement;
</programlisting>
<!--
        will only process the master table.
-->
       </para>
      </listitem>

      <listitem>
       <para>
<!--
        <command>INSERT</command> statements with <literal>ON CONFLICT</literal>
        clauses are unlikely to work as expected, as the <literal>ON CONFLICT</literal>
        action is only taken in case of unique violations on the specified
        target relation, not its child relations.
-->
<literal>ON CONFLICT</literal>句のある<command>INSERT</command>文は恐らく期待通りには動作しないでしょう。
<literal>ON CONFLICT</literal>の動作は対象となる指定リレーション上での一意制約違反の場合にのみ発生するもので、その子リレーションの場合には発生しないからです。
       </para>
      </listitem>

      <listitem>
       <para>
<!--
        Triggers or rules will be needed to route rows to the desired
        child table, unless the application is explicitly aware of the
        partitioning scheme.  Triggers may be complicated to write, and will
        be much slower than the tuple routing performed internally by
        declarative partitioning.
-->
アプリケーションがパーティショニングのスキームについて明示的に意識しているのでなければ、トリガーまたはルールで行を適切な子テーブルに振り向ける必要があります。
トリガーを書くのは複雑であり、また宣言的パーティショニングによって内部的に実行されるタプルの振り向けよりずっと遅いでしょう。
       </para>
      </listitem>
     </itemizedlist>
    </para>
   </sect3>
  </sect2>

  <sect2 id="ddl-partition-pruning">
<!--
   <title>Partition Pruning</title>
-->
   <title>パーティション除去</title>

   <indexterm>
<!--
    <primary>partition pruning</primary>
-->
    <primary>パーティション除去</primary>
   </indexterm>

   <para>
<!--
    <firstterm>Partition pruning</firstterm> is a query optimization technique
    that improves performance for declaratively partitioned tables.
    As an example:
-->
<firstterm>パーティション除去</firstterm>は、宣言的パーティショニングテーブルに対するパフォーマンスを向上させる問い合わせの最適化技術です。
例えば、

<programlisting>
SET enable_partition_pruning = on;                 -- the default
SELECT count(*) FROM measurement WHERE logdate &gt;= DATE '2008-01-01';
</programlisting>

<!--
    Without partition pruning, the above query would scan each of the
    partitions of the <structname>measurement</structname> table. With
    partition pruning enabled, the planner will examine the definition
    of each partition and prove that the partition need not
    be scanned because it could not contain any rows meeting the query's
    <literal>WHERE</literal> clause.  When the planner can prove this, it
    excludes (<firstterm>prunes</firstterm>) the partition from the query
    plan.
-->
パーティション除去がなければ、上記の問い合わせは<structname>measurement</structname>テーブルの各パーティションをスキャンするでしょう。
パーティション除去が有効になっているとき、プランナはそれぞれのパーティションの定義を検証し、パーティションが問い合わせの<literal>WHERE</literal>に一致する行を含んでいないためにスキャンされる必要が無いことを証明します。
プランナはこれを証明すると、問い合わせ計画からそのパーティションを除外（<firstterm>除去</firstterm>）します。
   </para>

   <para>
<!--
    By using the EXPLAIN command and the <xref
    linkend="guc-enable-partition-pruning"/> configuration parameter, it's
    possible to show the difference between a plan for which partitions have
    been pruned and one for which they have not.  A typical unoptimized
    plan for this type of table setup is:
-->
EXPLAINコマンドと設定パラメータ<xref linkend="guc-enable-partition-pruning"/> を使用することによって、パーティションの除去をした計画とそうでない計画の違いを明らかにすることを可能とします。
この種類のテーブル設定に対する典型的な最適化されない計画は以下のようになります。
<programlisting>
SET enable_partition_pruning = off;
EXPLAIN SELECT count(*) FROM measurement WHERE logdate &gt;= DATE '2008-01-01';
                                    QUERY PLAN
-------------------------------------------------------------------&zwsp;----------------
 Aggregate  (cost=188.76..188.77 rows=1 width=8)
   -&gt;  Append  (cost=0.00..181.05 rows=3085 width=0)
         -&gt;  Seq Scan on measurement_y2006m02  (cost=0.00..33.12 rows=617 width=0)
               Filter: (logdate &gt;= '2008-01-01'::date)
         -&gt;  Seq Scan on measurement_y2006m03  (cost=0.00..33.12 rows=617 width=0)
               Filter: (logdate &gt;= '2008-01-01'::date)
...
         -&gt;  Seq Scan on measurement_y2007m11  (cost=0.00..33.12 rows=617 width=0)
               Filter: (logdate &gt;= '2008-01-01'::date)
         -&gt;  Seq Scan on measurement_y2007m12  (cost=0.00..33.12 rows=617 width=0)
               Filter: (logdate &gt;= '2008-01-01'::date)
         -&gt;  Seq Scan on measurement_y2008m01  (cost=0.00..33.12 rows=617 width=0)
               Filter: (logdate &gt;= '2008-01-01'::date)
</programlisting>

<!--
    Some or all of the partitions might use index scans instead of
    full-table sequential scans, but the point here is that there
    is no need to scan the older partitions at all to answer this query.
    When we enable partition pruning, we get a significantly
    cheaper plan that will deliver the same answer:
-->
一部のパーティション、もしくはすべてのパーティションで、テーブル全体に対するシーケンシャルスキャンではなく、インデックススキャンが使用される可能性があります。
しかしここで重要なことは、この問い合わせに対する回答のために古いパーティションをスキャンする必要はまったく無いということです。
パーティション除去を有効にしたとき、同じ回答を返す計画で、大幅に安価なものを得ることができます。

<programlisting>
SET enable_partition_pruning = on;
EXPLAIN SELECT count(*) FROM measurement WHERE logdate &gt;= DATE '2008-01-01';
                                    QUERY PLAN
-------------------------------------------------------------------&zwsp;----------------
 Aggregate  (cost=37.75..37.76 rows=1 width=8)
   -&gt;  Seq Scan on measurement_y2008m01  (cost=0.00..33.12 rows=617 width=0)
         Filter: (logdate &gt;= '2008-01-01'::date)
</programlisting>
   </para>

   <para>
<!--
    Note that partition pruning is driven only by the constraints defined
    implicitly by the partition keys, not by the presence of indexes.
    Therefore it isn't necessary to define indexes on the key columns.
    Whether an index needs to be created for a given partition depends on
    whether you expect that queries that scan the partition will
    generally scan a large part of the partition or just a small part.
    An index will be helpful in the latter case but not the former.
-->
パーティション除去はパーティションキーによって暗黙的に定義された制約のみで動作し、インデックスの有無では動作しないことに注意してください。
よってキー列のインデックスを定義することは必要ではありません。
あるパーティションでインデックスが必要かどうかは、パーティションをスキャンする問い合わせが通常はパーティションの大部分をスキャンするのか、あるいは小さな部分をスキャンするのかによります。
インデックスは後者において役立ちますが、前者では役立ちません。
   </para>

   <para>
<!--
    Partition pruning can be performed not only during the planning of a
    given query, but also during its execution.  This is useful as it can
    allow more partitions to be pruned when clauses contain expressions
    whose values are not known at query planning time, for example,
    parameters defined in a <command>PREPARE</command> statement, using a
    value obtained from a subquery, or using a parameterized value on the
    inner side of a nested loop join.  Partition pruning during execution
    can be performed at any of the following times:
-->
パーティション除去は与えられた問い合わせの計画時だけでなく、問い合わせの実行時にも可能です。
問い合わせの計画時、句が値のわからない式を含むときにより多くのパーティションを除去できるため便利です。
例えば、<command>PREPARE</command>文中に定義されたパラメータや、副問い合わせから取得される値の利用、ネステッドループ結合の内側でパラメータ化された値の利用です。
実行中のパーティション除去は、次のいずれかの時点で可能です。

    <itemizedlist>
     <listitem>
      <para>
<!--
       During initialization of the query plan.  Partition pruning can be
       performed here for parameter values which are known during the
       initialization phase of execution.  Partitions which are pruned
       during this stage will not show up in the query's
       <command>EXPLAIN</command> or <command>EXPLAIN ANALYZE</command>.
       It is possible to determine the number of partitions which were
       removed during this phase by observing the
       <quote>Subplans Removed</quote> property in the
       <command>EXPLAIN</command> output.
-->
問い合わせ計画の初期化時。
パーティション除去は、パラメータの値が分かる実行の初期化段階時に可能です。
この段階で除去されたパーティションは、問い合わせの<command>EXPLAIN</command>や<command>EXPLAIN ANALYZE</command>中に姿を見せることはないでしょう。
<command>EXPLAIN</command>出力中に<quote>Subplans removed</quote>プロパティを観察することによってこの段階で削除されるパーティションの数を特定することが可能です。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       During actual execution of the query plan.  Partition pruning may
       also be performed here to remove partitions using values which are
       only known during actual query execution.  This includes values
       from subqueries and values from execution-time parameters such as
       those from parameterized nested loop joins.  Since the value of
       these parameters may change many times during the execution of the
       query, partition pruning is performed whenever one of the
       execution parameters being used by partition pruning changes.
       Determining if partitions were pruned during this phase requires
       careful inspection of the <literal>loops</literal> property in
       the <command>EXPLAIN ANALYZE</command> output.  Subplans
       corresponding to different partitions may have different values
       for it depending on how many times each of them was pruned during
       execution.  Some may be shown as <literal>(never executed)</literal>
       if they were pruned every time.
-->
問い合わせ計画の実行時。
パーティション除去では実際に問い合わせの実行をする際にのみ分かる値を用いてパーティションを取り除くことも同様に可能でしょう。
これは、副問い合わせからの値やネステッドループ結合でパラメータ化されたような実行時のパラメータからの値を含みます。
それらのパラメータの値は問い合わせの実行時に何回も変わるかもしれないため、パーティション除去はパーティション除去に使われる実行パラメータの値が変るたびに行われます。
この段階で除去されたパーティションを特定するには、<command>EXPLAIN ANALYZE</command>出力中の<quote>loops</quote>プロパティの慎重な調査が必要です。
異なるパーティションに対応するサブプランは、それぞれ実行時に除去された回数に応じて異なる値を持っているかもしれません。
毎回パーティションが除去される場合、一部は<literal>(never executed)</literal>と表示されるでしょう。
      </para>
     </listitem>
    </itemizedlist>
   </para>

   <para>
<!--
    Partition pruning can be disabled using the
    <xref linkend="guc-enable-partition-pruning"/> setting.
-->
パーティション除去は<xref linkend="guc-enable-partition-pruning"/>設定を使うことにより無効化できます。
   </para>

   <note>
    <para>
<!--
     Execution-time partition pruning currently only occurs for the
     <literal>Append</literal> and <literal>MergeAppend</literal> node types.
     It is not yet implemented for the <literal>ModifyTable</literal> node
     type, but that is likely to be changed in a future release of
     <productname>PostgreSQL</productname>.
-->
実行時のパーティション除去は現在<literal>Append</literal>と<literal>MergeAppend</literal>ノードタイプに対してのみ発生します。
<literal>ModifyTable</literal>ノードタイプについてはまだ実装されていません。
これは<productname>PostgreSQL</productname>の将来のリリースで変更される可能性があります。
    </para>
   </note>
  </sect2>

  <sect2 id="ddl-partitioning-constraint-exclusion">
<!--
   <title>Partitioning and Constraint Exclusion</title>
-->
   <title>パーティショニングと制約による除外</title>

   <indexterm>
<!--
    <primary>constraint exclusion</primary>
-->
    <primary>制約による除外</primary>
   </indexterm>

   <para>
<!--
    <firstterm>Constraint exclusion</firstterm> is a query optimization
    technique similar to partition pruning.  While it is primarily used
    for partitioning implemented using the legacy inheritance method, it can be
    used for other purposes, including with declarative partitioning.
-->
<firstterm>制約による除外</firstterm>はパーティション除去と同様に問い合わせ最適化技術です。
主に従来の継承方法を使用して実装されたパーティショニングのために使用されると同時に
宣言的パーティショニングを含む他の目的に使うことができます。
   </para>

   <para>
<!--
    Constraint exclusion works in a very similar way to partition
    pruning, except that it uses each table's <literal>CHECK</literal>
    constraints &mdash; which gives it its name &mdash; whereas partition
    pruning uses the table's partition bounds, which exist only in the
    case of declarative partitioning.  Another difference is that
    constraint exclusion is only applied at plan time; there is no attempt
    to remove partitions at execution time.
-->
各テーブルの名前の付いた<literal>CHECK</literal>制約を使用すること（一方でパーティション除去は宣言的パーティショニングの場合にのみ存在するテーブルのパーティション境界を使用します）を除いて、制約による除外はパーティション除去と極めて同様な方法で動作します。
その他の違いは、制約による除外は計画時にのみ適用され実行時にパーティションの削除を試しません。
   </para>

   <para>
<!--
    The fact that constraint exclusion uses <literal>CHECK</literal>
    constraints, which makes it slow compared to partition pruning, can
    sometimes be used as an advantage: because constraints can be defined
    even on declaratively-partitioned tables, in addition to their internal
    partition bounds, constraint exclusion may be able
    to elide additional partitions from the query plan.
-->
制約による除外は<literal>CHECK</literal>制約を使用しているためパーティション除去と比べて遅いですが、ときどき利点として使うことができます。
なぜなら、内部のパーティション境界に加えて宣言的パーティションテーブルにも制約は定義することができるため、制約による除外は問い合わせ計画から追加のパーティションを取り除けるかもしれません。
   </para>

   <para>
<!--
    The default (and recommended) setting of
    <xref linkend="guc-constraint-exclusion"/> is neither
    <literal>on</literal> nor <literal>off</literal>, but an intermediate setting
    called <literal>partition</literal>, which causes the technique to be
    applied only to queries that are likely to be working on inheritance partitioned
    tables.  The <literal>on</literal> setting causes the planner to examine
    <literal>CHECK</literal> constraints in all queries, even simple ones that
    are unlikely to benefit.
-->
実のところ、<xref linkend="guc-constraint-exclusion"/>のデフォルト（かつ推奨）の設定は、<literal>on</literal>でも<literal>off</literal>でもなく、<literal>partition</literal>という中間の設定です。
これによりこの技法は、継承パーティションテーブルに対して動作することになる問い合わせのみに適用されるようになります。
<literal>on</literal>設定にすると、プランナは、効果のなさそうな単純な問い合わせを含め、すべての問い合わせで<literal>CHECK</literal>制約を検証するようになります。
   </para>

   <para>
<!--
    The following caveats apply to constraint exclusion:
-->
制約による除外には以下の注意事項が適用されます。

   <itemizedlist>
    <listitem>
     <para>
<!--
      Constraint exclusion is only applied during query planning, unlike
      partition pruning, which can also be applied during query execution.
-->
問い合わせの実行中にも適用できるパーティション除去とは違い、制約による除外は問い合わせ計画時にのみ適用されます。
     </para>
    </listitem>

    <listitem>
     <para>
<!--
      Constraint exclusion only works when the query's <literal>WHERE</literal>
      clause contains constants (or externally supplied parameters).
      For example, a comparison against a non-immutable function such as
      <function>CURRENT_TIMESTAMP</function> cannot be optimized, since the
      planner cannot know which child table the function's value might fall
      into at run time.
-->
制約による除外は問い合わせの<literal>WHERE</literal>句が定数(または外部から供給されたパラメータ)を含んでいたときにのみ動作します。例えば、<function>CURRENT_TIMESTAMP</function>のような非immutable関数に対する比較は、関数の結果値がどの子テーブルに該当するかを実行時にプランナが知ることが出来ないため、最適化できません。
     </para>
    </listitem>

    <listitem>
     <para>
<!--
      Keep the partitioning constraints simple, else the planner may not be
      able to prove that child tables might not need to be visited.  Use simple
      equality conditions for list partitioning, or simple
      range tests for range partitioning, as illustrated in the preceding
      examples.  A good rule of thumb is that partitioning constraints should
      contain only comparisons of the partitioning column(s) to constants
      using B-tree-indexable operators, because only B-tree-indexable
      column(s) are allowed in the partition key.
-->
パーティション制約を簡単にしておいてください。そうしないとプランナは、子テーブルを使う必要がないことを立証できないでしょう。
前述の例で示したとおり、リスト分割のために簡単な等号条件を使用してください。また範囲分割のために簡単な範囲テストを使用してください。
手っ取り早い良い方法は、パーティショニングの制約がパーティション列とB-treeインデックス作成可能な演算子を用いた定数の比較のみを含んでいることです。
なぜならパーティションキーにはB-treeでインデックス可能な列だけが使用できるからです。
     </para>
    </listitem>

    <listitem>
     <para>
<!--
      All constraints on all children of the parent table are examined
      during constraint exclusion, so large numbers of children are likely
      to increase query planning time considerably.  So the legacy
      inheritance based partitioning will work well with up to perhaps a
      hundred child tables; don't try to use many thousands of children.
-->
親テーブルのすべての子テーブルのすべての制約は、制約による除外で試験されます。
よって子テーブルの数が多くなれば問い合わせ計画の時間がかなり増加します。
そのため、従来の継承を基にしたパーティショニングはおそらく100個までの子でうまく動作します。
何千もの子テーブルを使用することは避けてください。
     </para>
    </listitem>

   </itemizedlist>
   </para>
  </sect2>

  <sect2 id="ddl-partitioning-declarative-best-practices">
<!--
   <title>Declarative Partitioning Best Practices</title>
-->
   <title>宣言的パーティショニングのベストプラクティス</title>

   <para>
<!--
    The choice of how to partition a table should be made carefully as the
    performance of query planning and execution can be negatively affected by
    poor design.
-->
不十分な設計によってクエリ計画および実行性能に負の影響がでる可能性があるため
テーブルのパーティション方法の選択は注意して行う必要があります。
   </para>

   <para>
<!--
    One of the most critical design decisions will be the column or columns
    by which you partition your data.  Often the best choice will be to
    partition by the column or set of columns which most commonly appear in
    <literal>WHERE</literal> clauses of queries being executed on the
    partitioned table.  <literal>WHERE</literal> clause items that match and
    are compatible with the partition key can be used to prune unneeded
    partitions.  However, you may be forced into making other decisions by
    requirements for the <literal>PRIMARY KEY</literal> or a
    <literal>UNIQUE</literal> constraint.  Removal of unwanted data is also a
    factor to consider when planning your partitioning strategy.  An entire
    partition can be detached fairly quickly, so it may be beneficial to
    design the partition strategy in such a way that all data to be removed
    at once is located in a single partition.
-->
最も重要な設計の決定の一つは、データを分割するための一つまたは複数の列です。
大抵最適な選択は、パーティションテーブル上で実行されるクエリの<literal>WHERE</literal>句に最もよく現れる列または列の組み合わせによって分割することです。
パーティションキーと一致し互換性がある<literal>WHERE</literal>句の項目は、不要なパーティションを取り除く為に使うことができます。
しかしながら、<literal>PRIMARY KEY</literal>もしくは<literal>UNIQUE</literal>制約の条件により、他の決定を強いられるかもしれません。
不要なデータの削除も同様にパーティショニング戦略を計画する際に考えるべき要素です。
すべてのパーティションはとても早くデタッチすることができるため、一度に削除される全てのデータが単一のパーティション中に設置されるようにパーティション戦略を設計することが有益かもしれません。
   </para>

   <para>
<!--
    Choosing the target number of partitions that the table should be divided
    into is also a critical decision to make.  Not having enough partitions
    may mean that indexes remain too large and that data locality remains poor
    which could result in low cache hit ratios.  However, dividing the table
    into too many partitions can also cause issues.  Too many partitions can
    mean longer query planning times and higher memory consumption during both
    query planning and execution.  When choosing how to partition your table,
    it's also important to consider what changes may occur in the future.  For
    example, if you choose to have one partition per customer and you
    currently have a small number of large customers, consider the
    implications if in several years you instead find yourself with a large
    number of small customers.  In this case, it may be better to choose to
    partition by <literal>HASH</literal> and choose a reasonable number of
    partitions rather than trying to partition by <literal>LIST</literal> and
    hoping that the number of customers does not increase beyond what it is
    practical to partition the data by.
-->
テーブルを分割するパーティションの目標数を選択することもまた需要な決定です。
十分なパーティションがないとインデックスは大きくなりデータの局所性が貧しいままであるかもしれず、キャッシュヒット率が低い結果となる可能性があります。
しかしながら非常に多くのパーティションにテーブルを分割することもまた問題の原因となります。
非常に多くのパーティションは、クエリの計画時間が長くなり、クエリの計画および実行の両方の際にメモリ消費が高くなることを意味します。
テーブルを分割する方法を選択するとき、 将来に起こる変化を考慮することもまた重要です。
例えば、顧客毎に一つのパーティションを用意することを選択し、現在大規模な顧客が少数いる場合、数年以内に小規模な顧客を多数代わりに見つける可能性を含めて考慮します。
この場合、<literal>LIST</literal>によって分割しデータの分割が実用的な数以上に顧客の数が増加しないことを期待するより、<literal>HASH</literal>によって分割し妥当なパーティション数にすることを選択する方が良いかもしれません。
   </para>

   <para>
<!--
    Sub-partitioning can be useful to further divide partitions that are
    expected to become larger than other partitions, although excessive
    sub-partitioning can easily lead to large numbers of partitions and can
    cause the same problems mentioned in the preceding paragraph.
-->
サブパーティショニングは、他のパーティションより巨大になると想定されるパーティションを更に分割するために役立ちますが、過度なサブパーティショニングは大量のパーティションを容易に引き起こし、前の段落で言及したのと同じ問題の原因となります。
   </para>

   <para>
<!--
    It is also important to consider the overhead of partitioning during
    query planning and execution.  The query planner is generally able to
    handle partition hierarchies with up to a few thousand partitions fairly
    well, provided that typical queries allow the query planner to prune all
    but a small number of partitions.  Planning times become longer and memory
    consumption becomes higher when more partitions remain after the planner
    performs partition pruning.  This is particularly true for the
    <command>UPDATE</command> and <command>DELETE</command> commands.  Another
    reason to be concerned about having a large number of partitions is that
    the server's memory consumption may grow significantly over a period of
    time, especially if many sessions touch large numbers of partitions.
    That's because each partition requires its metadata to be loaded into the
    local memory of each session that touches it.
-->
クエリの計画および実行時のパーティショニングのオーバーヘッドを考慮することもまた重要です。
典型的なクエリではクエリプランナが少数のパーティションを除いて残り全てのパーティションを除外できるという前提に立てば、クエリプランナは通常最大数千パーティションのパーティション階層を適切に操作することができます。
プランナがパーティション除去を行った後に多くのパーティションが残るほど、計画時間は長くなりメモリ消費は高くなります。
これは<command>UPDATE</command>と<command>DELETE</command>コマンドに特に当てはまります。
大量のパーティションを持っていることについて考慮するもうひとつの理由は、特に多くのセッションが大量のパーティションを参照する場合、ある期間にサーバのメモリ消費が著しく増加するかもしれないことです。
その理由は、各パーティションは参照される各セッションのローカルメモリにメタデータを読み込む必要があるためです。
   </para>

   <para>
<!--
    With data warehouse type workloads, it can make sense to use a larger
    number of partitions than with an <acronym>OLTP</acronym> type workload.
    Generally, in data warehouses, query planning time is less of a concern as
    the majority of processing time is spent during query execution.  With
    either of these two types of workload, it is important to make the right
    decisions early, as re-partitioning large quantities of data can be
    painfully slow.  Simulations of the intended workload are often beneficial
    for optimizing the partitioning strategy.  Never assume that more
    partitions are better than fewer partitions and vice-versa.
-->
データウェアハウスタイプのワークロードでは、<acronym>OLTP</acronym>タイプのワークロードより大量のパーティションを使用するのが当然です。
通常、データウェアハウスでは処理時間の大半をクエリ実行に費やすため、クエリ計画時間はあまり問題になりません。
2種類のワークロードのいずれかでも、大量のデータを再パーティショニングすることは非常に遅いため、初期に適切な決定を下すことが重要です。
計画したワークロードのシミュレーションは、パーティショニング戦略を最適化するためにしばしば役立ちます。
多数のパーティションがより少数のパーティションより優れていることや、少数のパーティションが多数のパーティションより優れていることを前提としないでください。
   </para>
  </sect2>

 </sect1>

 <sect1 id="ddl-foreign-data">
<!--
  <title>Foreign Data</title>
-->
  <title>外部データ</title>

   <indexterm>
<!--
    <primary>foreign data</primary>
-->
    <primary>外部データ</primary>
   </indexterm>
   <indexterm>
<!--
    <primary>foreign table</primary>
-->
    <primary>外部テーブル</primary>
   </indexterm>
   <indexterm>
<!--
    <primary>user mapping</primary>
-->
    <primary>ユーザマッピング</primary>
   </indexterm>

   <para>
<!--
    <productname>PostgreSQL</productname> implements portions of the SQL/MED
    specification, allowing you to access data that resides outside
    PostgreSQL using regular SQL queries.  Such data is referred to as
    <firstterm>foreign data</firstterm>.  (Note that this usage is not to be confused
    with foreign keys, which are a type of constraint within the database.)
-->
<productname>PostgreSQL</productname>はSQL/MED仕様を部分的に実装しており、PostgreSQLの外部にあるデータに対して標準的なSQLクエリでアクセスできます。このようなデータは<firstterm>外部データ</firstterm>と呼ばれます。(この用語をデータベース内の制約である外部キーと混同しないように気をつけてください。)
   </para>

   <para>
<!--
    Foreign data is accessed with help from a
    <firstterm>foreign data wrapper</firstterm>. A foreign data wrapper is a
    library that can communicate with an external data source, hiding the
    details of connecting to the data source and obtaining data from it.
    There are some foreign data wrappers available as <filename>contrib</filename>
    modules; see <xref linkend="contrib"/>.  Other kinds of foreign data
    wrappers might be found as third party products.  If none of the existing
    foreign data wrappers suit your needs, you can write your own; see <xref
    linkend="fdwhandler"/>.
-->
外部データは<firstterm>外部データラッパ</firstterm>の手助けによりアクセスされます。外部データラッパは外部データソースと通信できるライブラリであり、接続確立やデータ取得といった詳細を隠蔽します。<filename>contrib</filename>モジュールとして、いくつかの外部データラッパが利用できます; <xref linkend="contrib"/>を参照してください。
その他の種類の外部データラッパは外部製品として見つかるでしょう。既存の外部データラッパがあなたの用途に合わない場合、独自のラッパを書くことができます。<xref linkend="fdwhandler"/>を参照してください。
   </para>

   <para>
<!--
    To access foreign data, you need to create a <firstterm>foreign server</firstterm>
    object, which defines how to connect to a particular external data source
    according to the set of options used by its supporting foreign data
    wrapper. Then you need to create one or more <firstterm>foreign
    tables</firstterm>, which define the structure of the remote data. A
    foreign table can be used in queries just like a normal table, but a
    foreign table has no storage in the PostgreSQL server.  Whenever it is
    used, <productname>PostgreSQL</productname> asks the foreign data wrapper
    to fetch data from the external source, or transmit data to the external
    source in the case of update commands.
-->
外部データにアクセスするには、特定の外部データソースへの接続方法をそれを支える外部データラッパが使用するオプションの組み合わせによって定義する<firstterm>外部サーバ</firstterm>オブジェクトを作成する必要があります。その後、外部データの構造を定義する<firstterm>外部テーブル</firstterm>を少なくともひとつ作成する必要があります。外部テーブルは通常のテーブルと同様にクエリの中で使用できますが、外部テーブルはPostgreSQLサーバには格納領域を持ちません。
外部テーブルが使われるたびに、<productname>PostgreSQL</productname>は外部ソースからデータを取得することや、更新コマンドの場合には外部ソースへデータを送信することを外部データラッパに依頼します。
   </para>

   <para>
<!--
    Accessing remote data may require authenticating to the external
    data source.  This information can be provided by a
    <firstterm>user mapping</firstterm>, which can provide additional data
    such as user names and passwords based
    on the current <productname>PostgreSQL</productname> role.
-->
外部データへのアクセスは外部データソースからの認証を必要とする場合があります。この情報は、現在の<productname>PostgreSQL</productname>ロールに基づいてユーザ名やパスワードといった追加のデータを提供することができる<firstterm>ユーザマッピング</firstterm>によって提供することができます。
   </para>

   <para>
<!--
    For additional information, see
    <xref linkend="sql-createforeigndatawrapper"/>,
    <xref linkend="sql-createserver"/>,
    <xref linkend="sql-createusermapping"/>,
    <xref linkend="sql-createforeigntable"/>, and
    <xref linkend="sql-importforeignschema"/>.
-->
追加情報は、<xref linkend="sql-createforeigndatawrapper"/>、<xref linkend="sql-createserver"/>、<xref linkend="sql-createusermapping"/>、<xref linkend="sql-createforeigntable"/>、<xref linkend="sql-importforeignschema"/>を参照してください。
   </para>
 </sect1>

 <sect1 id="ddl-others">
<!--
  <title>Other Database Objects</title>
-->
  <title>その他のデータベースオブジェクト</title>

  <para>
<!--
   Tables are the central objects in a relational database structure,
   because they hold your data.  But they are not the only objects
   that exist in a database.  Many other kinds of objects can be
   created to make the use and management of the data more efficient
   or convenient.  They are not discussed in this chapter, but we give
   you a list here so that you are aware of what is possible:
-->
テーブルにはデータが保持されていますので、リレーショナルデータベース構造ではテーブルが中心オブジェクトとなります。
しかし、データベースにはテーブルの他にもオブジェクトが存在します。
様々なオブジェクトを作成して、データの使用および管理をより効果的に行うことができます。
本章ではこれらのオブジェクトについては説明しませんが、どのようなものがあるかをここに列挙します。
  </para>

  <itemizedlist>
   <listitem>
    <para>
<!--
     Views
-->
ビュー
    </para>
   </listitem>

   <listitem>
    <para>
<!--
     Functions, procedures, and operators
-->
関数、プロシージャおよび演算子
    </para>
   </listitem>

   <listitem>
    <para>
<!--
     Data types and domains
-->
データ型およびドメイン
    </para>
   </listitem>

   <listitem>
    <para>
<!--
     Triggers and rewrite rules
-->
トリガおよび書き換えルール
    </para>
   </listitem>
  </itemizedlist>

  <para>
<!--
   Detailed information on
   these topics appears in <xref linkend="server-programming"/>.
-->
これらのトピックに関する詳細な情報は<xref linkend="server-programming"/>にあります。
  </para>
 </sect1>

 <sect1 id="ddl-depend">
<!--
  <title>Dependency Tracking</title>
-->
  <title>依存関係の追跡</title>

  <indexterm zone="ddl-depend">
   <primary>CASCADE</primary>
<!--
   <secondary sortas="DROP">with DROP</secondary>
-->
   <secondary sortas="DROP">DROPの</secondary>
  </indexterm>

  <indexterm zone="ddl-depend">
   <primary>RESTRICT</primary>
<!--
   <secondary sortas="DROP">with DROP</secondary>
-->
   <secondary sortas="DROP">DROPの</secondary>
  </indexterm>

  <para>
<!--
   When you create complex database structures involving many tables
   with foreign key constraints, views, triggers, functions, etc. you
   implicitly create a net of dependencies between the objects.
   For instance, a table with a foreign key constraint depends on the
   table it references.
-->
外部キー制約や、ビュー、トリガ、関数などを使ったテーブルが多数含まれるような複雑なデータベース構造を作成すると、ユーザはそれらのオブジェクト間の暗黙的な依存関係のネットワークも作成していることになります。
例えば、外部キー制約を持つテーブルは、参照するテーブルに依存しています。
  </para>

  <para>
<!--
   To ensure the integrity of the entire database structure,
   <productname>PostgreSQL</productname> makes sure that you cannot
   drop objects that other objects still depend on.  For example,
   attempting to drop the products table we considered in <xref
   linkend="ddl-constraints-fk"/>, with the orders table depending on
   it, would result in an error message like this:
-->
データベース構造全体の整合性を保つため、<productname>PostgreSQL</productname>は、他のオブジェクトと依存関係にあるオブジェクトの削除を許可しません。
例えば、<xref linkend="ddl-constraints-fk"/>で検討したproductsテーブルを削除しようとしても、ordersテーブルがこのテーブルに依存しているので、以下のようなエラーメッセージが現れます。
<screen>
DROP TABLE products;

ERROR:  cannot drop table products because other objects depend on it
DETAIL:  constraint orders_product_no_fkey on table orders depends on table products
HINT:  Use DROP ... CASCADE to drop the dependent objects too.
</screen>
<!--
   The error message contains a useful hint: if you do not want to
   bother deleting all the dependent objects individually, you can run:
-->
エラーメッセージには役に立つヒントが含まれています。
以下のようにすると、依存する全てのオブジェクトを1つずつ削除する手間を省けます。
<screen>
DROP TABLE products CASCADE;
</screen>
<!--
   and all the dependent objects will be removed, as will any objects
   that depend on them, recursively.  In this case, it doesn't remove
   the orders table, it only removes the foreign key constraint.
   It stops there because nothing depends on the foreign key constraint.
   (If you want to check what <command>DROP ... CASCADE</command> will do,
   run <command>DROP</command> without <literal>CASCADE</literal> and read the
   <literal>DETAIL</literal> output.)
-->
これで、全ての依存オブジェクトが削除され、それらに依存するいかなるオブジェクトも削除されます。
この場合、ordersテーブルは削除されずに外部キー制約のみが削除されます。
外部キー制約に依存するものが何もないので、処理がそこで停止します。
（<command>DROP ... CASCADE</command>が何を行うかを知りたい場合は、<literal>CASCADE</literal>を指定せずに<command>DROP</command>を実行して<literal>DETAIL</literal>出力を読んでください）。
  </para>

  <para>
<!--
   Almost all <command>DROP</command> commands in <productname>PostgreSQL</productname> support
   specifying <literal>CASCADE</literal>.  Of course, the nature of
   the possible dependencies varies with the type of the object.  You
   can also write <literal>RESTRICT</literal> instead of
   <literal>CASCADE</literal> to get the default behavior, which is to
   prevent dropping objects that any other objects depend on.
-->
<productname>PostgreSQL</productname>では、ほぼ全ての<command>DROP</command>コマンドに<literal>CASCADE</literal>を指定することができます。
もちろん、どのような依存関係が存在するかは、オブジェクトの種類によって異なります。
また、<literal>CASCADE</literal>ではなく<literal>RESTRICT</literal>と記述することもできます。
これは、他のオブジェクトが依存しているオブジェクトの削除を禁止するというデフォルトの振舞いになります。
  </para>

  <note>
   <para>
<!--
    According to the SQL standard, specifying either
    <literal>RESTRICT</literal> or <literal>CASCADE</literal> is
    required in a <command>DROP</command> command.  No database system actually
    enforces that rule, but whether the default behavior
    is <literal>RESTRICT</literal> or <literal>CASCADE</literal> varies
    across systems.
-->
標準SQLでは、<command>DROP</command>コマンドで<literal>RESTRICT</literal>または<literal>CASCADE</literal>のいずれかを指定する必要があります。
実際にこの決まり通りのデータベースシステムはありませんが、デフォルトが<literal>RESTRICT</literal>であるか、<literal>CASCADE</literal>であるかは、システムによって異なります。
   </para>
  </note>

  <para>
<!--
   If a <command>DROP</command> command lists multiple
   objects, <literal>CASCADE</literal> is only required when there are
   dependencies outside the specified group.  For example, when saying
   <literal>DROP TABLE tab1, tab2</literal> the existence of a foreign
   key referencing <literal>tab1</literal> from <literal>tab2</literal> would not mean
   that <literal>CASCADE</literal> is needed to succeed.
-->
<command>DROP</command>コマンドで複数のオブジェクトを羅列した場合、<literal>CASCADE</literal>は、指定されたグループの外部に依存関係が存在する時のみ要求されます。
例えば、<literal>DROP TABLE tab1, tab2</literal>と記述したとき、<literal>tab2</literal>から<literal>tab1</literal>への外部キー参照の存在は、<literal>CASCADE</literal>の指定がコマンド成功に必要とされるということを意味しません。
  </para>

  <para>
<!--
   For user-defined functions, <productname>PostgreSQL</productname> tracks
   dependencies associated with a function's externally-visible properties,
   such as its argument and result types, but <emphasis>not</emphasis> dependencies
   that could only be known by examining the function body.  As an example,
   consider this situation:
-->
ユーザ定義関数について、<productname>PostgreSQL</productname>は引数や結果の型など、関数の外部に可視な属性に関連した依存性については追跡しますが、関数の実体を検査することによってしかわからない依存性は追跡<emphasis>しません</emphasis>。
例えば以下の状況を考えてみます。

<programlisting>
CREATE TYPE rainbow AS ENUM ('red', 'orange', 'yellow',
                             'green', 'blue', 'purple');

CREATE TABLE my_colors (color rainbow, note text);

CREATE FUNCTION get_color_note (rainbow) RETURNS text AS
  'SELECT note FROM my_colors WHERE color = $1'
  LANGUAGE SQL;
</programlisting>

<!--
   (See <xref linkend="xfunc-sql"/> for an explanation of SQL-language
   functions.)  <productname>PostgreSQL</productname> will be aware that
   the <function>get_color_note</function> function depends on the <type>rainbow</type>
   type: dropping the type would force dropping the function, because its
   argument type would no longer be defined.  But <productname>PostgreSQL</productname>
   will not consider <function>get_color_note</function> to depend on
   the <structname>my_colors</structname> table, and so will not drop the function if
   the table is dropped.  While there are disadvantages to this approach,
   there are also benefits.  The function is still valid in some sense if the
   table is missing, though executing it would cause an error; creating a new
   table of the same name would allow the function to work again.
-->
（SQL言語による関数についての説明は<xref linkend="xfunc-sql"/>を参照してください。）
<productname>PostgreSQL</productname>は関数<function>get_color_note</function>が型<type>rainbow</type>に依存することは認識します。
例えば、その型を削除すると、関数の引数の型が定義されなくなるため、関数の削除も強制されます。
しかし、<productname>PostgreSQL</productname>は<function>get_color_note</function>がテーブル<structname>my_colors</structname>に依存するとは考えません。
従って、そのテーブルが削除されても関数は削除されません。
この方法には不利な点もありますが、同時に利益もあります。
テーブルがない状態で関数を実行すればエラーを引き起こしますが、それでも関数はある意味で、有効な状態になっています。
そのため、同じ名前の新しいテーブルを作成することで、関数を再び動作させることができます。
  </para>
 </sect1>

</chapter>
