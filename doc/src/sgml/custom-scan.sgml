<!-- doc/src/sgml/custom-scan.sgml -->

<chapter id="custom-scan">
<!--
 <title>Writing A Custom Scan Provider</title>
-->
 <title>カスタムスキャンプロバイダの作成</title>

 <indexterm zone="custom-scan">
<!--
  <primary>custom scan provider</primary>
  <secondary>handler for</secondary>
-->
  <primary>カスタムスキャンプロバイダ</primary>
  <secondary>のハンドラ</secondary>
 </indexterm>

 <para>
<!--
  <productname>PostgreSQL</> supports a set of experimental facilities which
  are intended to allow extension modules to add new scan types to the system.
  Unlike a <link linkend="fdwhandler">foreign data wrapper</>, which is only
  responsible for knowing how to scan its own foreign tables, a custom scan
  provider can provide an alternative method of scanning any relation in the
  system.  Typically, the motivation for writing a custom scan provider will
  be to allow the use of some optimization not supported by the core
  system, such as caching or some form of hardware acceleration.  This chapter
  outlines how to write a new custom scan provider.
-->
<productname>PostgreSQL</>では、システムに新しいスキャン方式を追加する拡張モジュールを可能にするためのいくつかの実験的機構をサポートしています。
<link linkend="fdwhandler">外部データラッパ</>が自分の外部テーブルのスキャン方法を知っていることだけを担当するのと異なり、カスタムスキャンプロバイダはシステム内のリレーションをスキャンする代替方式を提供することができます。
典型的には、カスタムスキャンプロバイダを作成する理由は、キャッシュの利用や何らかの形式のハードウェアアクセラレーションといったコアシステムによってサポートされない最適化を利用可能にすることでしょう。
本章では新しいカスタムスキャンプロバイダの作成方法について概要を説明します。
 </para>

 <para>
<!--
  Implementing a new type of custom scan is a three-step process.  First,
  during planning, it is necessary to generate access paths representing a
  scan using the proposed strategy.  Second, if one of those access paths
  is selected by the planner as the optimal strategy for scanning a
  particular relation, the access path must be converted to a plan.
  Finally, it must be possible to execute the plan and generate the same
  results that would have been generated for any other access path targeting
  the same relation.
-->
新しい種類のカスタムスキャンの実装には3段階のプロセスがあります。
第一に、計画段階において、提案される戦略を用いたスキャンを表現するアクセスパスを生成する必要があります。
第二に、プランナがあるリレーションをスキャンするための最適戦略として、そのアクセスパスの一つを選んだとき、アクセスパスが計画に変換されなければなりません。
最後に、計画を実行して、同じリレーションを対象とする他のアクセスパスが生成するのと同じ結果を生成することが可能でなければなりません。
 </para>

 <sect1 id="custom-scan-path">
<!--
  <title>Creating Custom Scan Paths</title>
-->
  <title>カスタムスキャンパスの作成</title>

  <para>
<!--
    A custom scan provider will typically add paths for a base relation by
    setting the following hook, which is called after the core code has
    generated what it believes to be the complete and correct set of access
    paths for the relation.
-->
カスタムスキャンプロバイダは、典型的には、以下のフックを設定することでベースのリレーションのためのパスを追加します。
このフックはコアのコードがリレーションへの完全で正しいアクセスパスの集合であると信じるものを生成した後で呼び出されます。
<programlisting>
typedef void (*set_rel_pathlist_hook_type) (PlannerInfo *root,
                                            RelOptInfo *rel,
                                            Index rti,
                                            RangeTblEntry *rte);
extern PGDLLIMPORT set_rel_pathlist_hook_type set_rel_pathlist_hook;
</programlisting>
  </para>

  <para>
<!--
    Although this hook function can be used to examine, modify, or remove
    paths generated by the core system, a custom scan provider will typically
    confine itself to generating <structname>CustomPath</> objects and adding
    them to <literal>rel</> using <function>add_path</>.  The custom scan
    provider is responsible for initializing the <structname>CustomPath</>
    object, which is declared like this:
-->
このフックはコアシステムが生成したパスを検査し、修正し、あるいは削除するために使うことができますが、カスタムスキャンプロバイダは、典型的には<structname>CustomPath</>オブジェクトを生成し、<function>add_path</>を使ってそれを<literal>rel</>に追加することのみを行います。
カスタムスキャンプロバイダは<structname>CustomPath</>オブジェクトの初期化を担当します。
このオブジェクトは以下のように宣言されています。
<programlisting>
typedef struct CustomPath
{
    Path      path;
    uint32    flags;
    List     *custom_paths;
    List     *custom_private;
    const CustomPathMethods *methods;
} CustomPath;
</programlisting>
  </para>

  <para>
<!--
    <structfield>path</> must be initialized as for any other path, including
    the row-count estimate, start and total cost, and sort ordering provided
    by this path.  <structfield>flags</> is a bit mask, which should include
    <literal>CUSTOMPATH_SUPPORT_BACKWARD_SCAN</> if the custom path can support
    a backward scan and <literal>CUSTOMPATH_SUPPORT_MARK_RESTORE</> if it
    can support mark and restore.  Both capabilities are optional.
    An optional <structfield>custom_paths</> is a list of <structname>Path</>
    nodes used by this custom-path node; these will be transformed into
    <structname>Plan</> nodes by planner.
    <structfield>custom_private</> can be used to store the custom path's
    private data.  Private data should be stored in a form that can be handled
    by <literal>nodeToString</>, so that debugging routines that attempt to
    print the custom path will work as designed.  <structfield>methods</> must
    point to a (usually statically allocated) object implementing the required
    custom path methods, of which there is currently only one.  The
    <structfield>LibraryName</> and <structfield>SymbolName</> fields must also
    be initialized so that the dynamic loader can resolve them to locate the
    method table.
-->
<structfield>path</>は、他のすべてのパスと同じく、行数の推定値、開始とトータルのコスト、このパスで提供されるソート順を含めて初期化される必要があります。
<structfield>flags</>はビットマスクで、カスタムパスが逆向きスキャンをサポートできるなら<literal>CUSTOMPATH_SUPPORT_BACKWARD_SCAN</>を、マークとリストアがサポートできるなら<literal>CUSTOMPATH_SUPPORT_MARK_RESTORE</>を含めます。
いずれの機能も必須ではありません。
オプションの<structfield>custom_paths</>はこのカスタムパスのノードで使用される<structname>Path</>のノードのリストです。
プランナがこれを<structname>Plan</>のノードに変換します。
<structfield>custom_private</>はカスタムパスのプライベートデータを格納するために使うことができます。
プライベートデータは<literal>nodeToString</>が処理できるような形式で格納してください。
そうすることで、カスタムパスを出力するデバッグルーチンが設計通りに動作します。
<structfield>methods</>は要求されるカスタムパスのメソッドのオブジェクト（通常は静的に割り当てられる）を指している必要があり、現在は1つのみとなります。
<structfield>LibraryName</>フィールドと<structfield>SymbolName</>フィールドは、動的ローダがそれらのメソッドテーブルの位置を解決できるように、初期化されていなければなりません。
  </para>

  <para>
<!--
   A custom scan provider can also provide join paths.  Just as for base
   relations, such a path must produce the same output as would normally be
   produced by the join it replaces.  To do this, the join provider should
   set the following hook, and then within the hook function,
   create <structname>CustomPath</> path(s) for the join relation.
-->
カスタムスキャンプロバイダは結合(join)のパスを提供することもできます。
ベースのリレーションの場合と同様、そのようなパスは置換される結合が普通に生成したであろうものと同じ結果を生成しなければなりません。
そのために、結合のプロバイダは以下のフックをセットし、フック関数内で結合リレーション用に<structname>CustomPath</>のパスを作成します。
<programlisting>
typedef void (*set_join_pathlist_hook_type) (PlannerInfo *root,
                                             RelOptInfo *joinrel,
                                             RelOptInfo *outerrel,
                                             RelOptInfo *innerrel,
                                             JoinType jointype,
                                             JoinPathExtraData *extra);
extern PGDLLIMPORT set_join_pathlist_hook_type set_join_pathlist_hook;
</programlisting>

<!--
   This hook will be invoked repeatedly for the same join relation, with
   different combinations of inner and outer relations; it is the
   responsibility of the hook to minimize duplicated work.
-->
このフックは、同じ結合リレーションについて、内側あるいは外側のリレーションとの様々な組み合わせで繰り返し呼び出されます。
繰り返しの作業を最小化するのはフック側の責任です。
  </para>

  <sect2 id="custom-scan-path-callbacks">
<!--
  <title>Custom Scan Path Callbacks</title>
-->
  <title>カスタムスキャンパスのコールバック</title>

  <para>
<programlisting>
Plan *(*PlanCustomPath) (PlannerInfo *root,
                         RelOptInfo *rel,
                         CustomPath *best_path,
                         List *tlist,
                         List *clauses,
                         List *custom_plans);
</programlisting>
<!--
    Convert a custom path to a finished plan.  The return value will generally
    be a <literal>CustomScan</> object, which the callback must allocate and
    initialize.  See <xref linkend="custom-scan-plan"> for more details.
-->
カスタムパスを完成した計画に変換します。
戻り値は一般的には<literal>CustomScan</>オブジェクトで、その領域はコールバックが割り当てて初期化しなければなりません。
詳しくは<xref linkend="custom-scan-plan">を参照してください。
   </para>
  </sect2>
 </sect1>

 <sect1 id="custom-scan-plan">
<!--
  <title>Creating Custom Scan Plans</title>
-->
  <title>カスタムスキャン計画の作成</title>

  <para>
<!--
    A custom scan is represented in a finished plan tree using the following
    structure:
-->
カスタムスキャンは完成した計画ツリー内で、以下の構造体を使って表現されます。
<programlisting>
typedef struct CustomScan
{
    Scan      scan;
    uint32    flags;
    List     *custom_plans;
    List     *custom_exprs;
    List     *custom_private;
    List     *custom_scan_tlist;
    Bitmapset *custom_relids;
    const CustomScanMethods *methods;
} CustomScan;
</programlisting>
  </para>

  <para>
<!--
    <structfield>scan</> must be initialized as for any other scan, including
    estimated costs, target lists, qualifications, and so on.
    <structfield>flags</> is a bit mask with the same meaning as in
    <structname>CustomPath</>.
    <structfield>custom_plans</> can be used to store child
    <structname>Plan</> nodes.
    <structfield>custom_exprs</> should be used to
    store expression trees that will need to be fixed up by
    <filename>setrefs.c</> and <filename>subselect.c</>, while
    <structfield>custom_private</> should be used to store other private data
    that is only used by the custom scan provider itself.
    <structfield>custom_scan_tlist</> can be NIL when scanning a base
    relation, indicating that the custom scan returns scan tuples that match
    the base relation's row type.  Otherwise it is a target list describing
    the actual scan tuples.  <structfield>custom_scan_tlist</> must be
    provided for joins, and could be provided for scans if the custom scan
    provider can compute some non-Var expressions.
    <structfield>custom_relids</> is set by the core code to the set of
    relations (range table indexes) that this scan node handles; except when
    this scan is replacing a join, it will have only one member.
    <structfield>methods</> must point to a (usually statically allocated)
    object implementing the required custom scan methods, which are further
    detailed below.
-->
<structfield>scan</>は他のすべてのスキャンと同じく、推定コスト、対象のリスト、制約などを含めて初期化される必要があります。
<structfield>flags</>は<structname>CustomPath</>と同じ意味のビットマスクです。
<structfield>custom_plans</>は子の<structname>Plan</>ノードを格納するために使うことができます。
<structfield>custom_exprs</>は<filename>setrefs.c</>および<filename>subselect.c</>によって作成される必要がある式のツリーを格納するために使われます。
一方で<structfield>custom_private</>はカスタムスキャンプロバイダ自体によってのみ使用されるその他のプライベートデータを格納するために使われます。
<structfield>custom_scan_tlist</>はベースリレーションをスキャンするときはNILとすることができます。
これはカスタムスキャンがベースリレーションの行の型と一致するスキャンタプルを返すことを意味します。
それ以外の場合は、実際のスキャンタプルを表現する対象のリストとなります。
<structfield>custom_scan_tlist</>は結合の場合には提供される必要があります。
また、カスタムスキャンプロバイダがVarでない式を計算できる場合はスキャン用に提供することができます。
<structfield>custom_relids</>は、コアコードにより、このスキャンノードが処理するリレーションの集合（範囲テーブルのインデックス）にセットされます。
ただし、このスキャンが結合を置換する場合は例外で、ただ1つのメンバーだけになります。
<structfield>methods</>は必要なカスタムスキャンメソッドを実装しているオブジェクト（通常は静的に割り当てられる）を指していなければなりません。
これについては以下で詳しく説明します。
  </para>

  <para>
<!--
   When a <structname>CustomScan</> scans a single relation,
   <structfield>scan.scanrelid</> must be the range table index of the table
   to be scanned.  When it replaces a join, <structfield>scan.scanrelid</>
   should be zero.
-->
<structname>CustomScan</>がリレーションを1つだけスキャンするときは、<structfield>scan.scanrelid</>はスキャンされるテーブルの範囲テーブルのインデックスである必要があります。
結合を置換するときは<structfield>scan.scanrelid</>はゼロになります。
  </para>

  <para>
<!--
   Plan trees must be able to be duplicated using <function>copyObject</>,
   so all the data stored within the <quote>custom</> fields must consist of
   nodes that that function can handle.  Furthermore, custom scan providers
   cannot substitute a larger structure that embeds
   a <structname>CustomScan</> for the structure itself, as would be possible
   for a <structname>CustomPath</> or <structname>CustomScanState</>.
-->
計画ツリーは<function>copyObject</>により複製できる必要があるので、<quote>custom</>フィールド内に格納されるすべてのデータは、その関数が処理できるノードから構成されていなければなりません。
また、カスタムスキャンプロバイダは<structname>CustomScan</>を組み込んでいる大きな構造体を<structname>CustomScan</>の構造体で代替することができません。
<structname>CustomPath</>や<structname>CustomScanState</>に対してはこれが可能です。
  </para>

  <sect2 id="custom-scan-plan-callbacks">
<!--
   <title>Custom Scan Plan Callbacks</title>
-->
   <title>カスタムスキャン計画のコールバック</title>
   <para>
<programlisting>
Node *(*CreateCustomScanState) (CustomScan *cscan);
</programlisting>
<!--
    Allocate a <structname>CustomScanState</> for this
    <structname>CustomScan</>.  The actual allocation will often be larger than
    required for an ordinary <structname>CustomScanState</>, because many
    providers will wish to embed that as the first field of a larger structure.
    The value returned must have the node tag and <structfield>methods</>
    set appropriately, but other fields should be left as zeroes at this
    stage; after <function>ExecInitCustomScan</> performs basic initialization,
    the <function>BeginCustomScan</> callback will be invoked to give the
    custom scan provider a chance to do whatever else is needed.
-->
この<structname>CustomScan</>に<structname>CustomScanState</>の領域を割り当てます。
多くのプロバイダは、より大きな構造体の最初のフィールドとしてこれを組み込もうとするので、実際の割り当ては通常の<structname>CustomScanState</>が必要とするよりも多くくなることが多いでしょう。
戻り値では、ノードのタグと<structfield>methods</>が適切に設定されている必要がありますが、その他のフィールドはこの段階ではゼロのままになっています。
<function>ExecInitCustomScan</>が基本的な初期化をした後、<function>BeginCustomScan</>コールバックが呼び出されることで、カスタムスキャンプロバイダがその他の必要なことを実行する機会が与えられます。
   </para>
  </sect2>
 </sect1>

 <sect1 id="custom-scan-execution">
<!--
  <title>Executing Custom Scans</title>
-->
  <title>カスタムスキャンの実行</title>

  <para>
<!--
   When a <structfield>CustomScan</> is executed, its execution state is
   represented by a <structfield>CustomScanState</>, which is declared as
   follows:
-->
<structfield>CustomScan</>が実行されるとき、その実行状態は<structfield>CustomScanState</>で表現されます。
これは次のように宣言されています。
<programlisting>
typedef struct CustomScanState
{
    ScanState ss;
    uint32    flags;
    const CustomExecMethods *methods;
} CustomScanState;
</programlisting>
  </para>

  <para>
<!--
   <structfield>ss</> is initialized as for any other scan state,
   except that if the scan is for a join rather than a base relation,
   <literal>ss.ss_currentRelation</> is left NULL.
   <structfield>flags</> is a bit mask with the same meaning as in
   <structname>CustomPath</> and <structname>CustomScan</>.
   <structfield>methods</> must point to a (usually statically allocated)
   object implementing the required custom scan state methods, which are
   further detailed below.  Typically, a <structname>CustomScanState</>, which
   need not support <function>copyObject</>, will actually be a larger
   structure embedding the above as its first member.
-->
<structfield>ss</>は他のすべてのスキャン状態と同じく初期化されますが、スキャンがベースリレーションではなく結合を対象にしているときは例外で、<literal>ss.ss_currentRelation</>はNULLのままになります。
<structfield>flags</>は<structname>CustomPath</>および<structname>CustomScan</>と同じ意味のビットマスクです。
<structfield>methods</>は必要なカスタムスキャン状態のメソッドを実装するオブジェクト（通常は静的に割り当てられる）を指していなければなりません。
これについては以下で詳しく説明します。
<structname>CustomScanState</>は<function>copyObject</>をサポートしなくてもよく、典型的には上記を先頭のメンバーとして組み込んだより大きな構造体になっています。
  </para>

  <sect2 id="custom-scan-execution-callbacks">
<!--
   <title>Custom Scan Execution Callbacks</title>
-->
   <title>カスタムスキャン実行のコールバック</title>

   <para>
<programlisting>
void (*BeginCustomScan) (CustomScanState *node,
                         EState *estate,
                         int eflags);
</programlisting>
<!--
    Complete initialization of the supplied <structname>CustomScanState</>.
    Standard fields have been initialized by <function>ExecInitCustomScan</>,
    but any private fields should be initialized here.
-->
提供された<structname>CustomScanState</>の初期化を完了します。
標準的なフィールドは<function>ExecInitCustomScan</>で初期化が済んでいますが、プライベートフィールドはここで初期化されます。
   </para>

   <para>
<programlisting>
TupleTableSlot *(*ExecCustomScan) (CustomScanState *node);
</programlisting>
<!--
    Fetch the next scan tuple.  If any tuples remain, it should fill
    <literal>ps_ResultTupleSlot</> with the next tuple in the current scan
    direction, and then return the tuple slot.  If not,
    <literal>NULL</> or an empty slot should be returned.
-->
次のスキャンタプルをフェッチします。
タプルが残っている場合は、現在のスキャン方向で次にあるタプルを<literal>ps_ResultTupleSlot</>に入れます。
タプルが残っていないときは、<literal>NULL</>または空のスロットが戻されます。
   </para>

   <para>
<programlisting>
void (*EndCustomScan) (CustomScanState *node);
</programlisting>
<!--
    Clean up any private data associated with the <literal>CustomScanState</>.
    This method is required, but it does not need to do anything if there is
    no associated data or it will be cleaned up automatically.
-->
<literal>CustomScanState</>に関連付けられたプライベートデータを整理します。
このメソッドは必須ですが、関連付けられたデータがない場合、あるいはそれが自動的に整理される場合は、このメソッドは何もする必要はありません。
   </para>

   <para>
<programlisting>
void (*ReScanCustomScan) (CustomScanState *node);
</programlisting>
<!--
    Rewind the current scan to the beginning and prepare to rescan the
    relation.
-->
現在のスキャンを先頭まで巻き戻し、リレーションの再スキャンの準備をします。
   </para>

   <para>
<programlisting>
void (*MarkPosCustomScan) (CustomScanState *node);
</programlisting>
<!--
    Save the current scan position so that it can subsequently be restored
    by the <function>RestrPosCustomScan</> callback.  This callback is
    optional, and need only be supplied if the
    <literal>CUSTOMPATH_SUPPORT_MARK_RESTORE</> flag is set.
-->
現在のスキャン位置を保存し、後で<function>RestrPosCustomScan</>コールバックでリストアできるようにします。
このコールバックは必須ではなく、<literal>CUSTOMPATH_SUPPORT_MARK_RESTORE</>フラグがセットされている場合にのみ、提供する必要があります。
   </para>

   <para>
<programlisting>
void (*RestrPosCustomScan) (CustomScanState *node);
</programlisting>
<!--
    Restore the previous scan position as saved by the
    <function>MarkPosCustomScan</> callback.  This callback is optional,
    and need only be supplied if the
    <literal>CUSTOMPATH_SUPPORT_MARK_RESTORE</> flag is set.
-->
<function>MarkPosCustomScan</>コールバックで保存された以前のスキャン位置をリストアします。
このコールバックは必須ではなく、<literal>CUSTOMPATH_SUPPORT_MARK_RESTORE</>フラグがセットされている場合にのみ、提供する必要があります。
   </para>

   <para>
<programlisting>
Size (*EstimateDSMCustomScan) (CustomScanState *node,
                               ParallelContext *pcxt);
</programlisting>
<!--
    Estimate the amount of dynamic shared memory that will be required
    for parallel operation.  This may be higher than the amount that will
    actually be used, but it must not be lower.  The return value is in bytes.
    This callback is optional, and need only be supplied if this custom
    scan provider supports parallel execution.
-->
並列操作に要求される動的共有メモリの使用量を予測します。
使用を予測される量よりも多い量の結果が返しても良いですが、少なく返してはいけません。
返り値の単位はバイトとなります。
このコールバックは必須ではなく、カスタムスキャンプロバイダが並列実行をサポートする場合にのみ提供される必要があります。
   </para>

   <para>
<programlisting>
void (*InitializeDSMCustomScan) (CustomScanState *node,
                                 ParallelContext *pcxt,
                                 void *coordinate);
</programlisting>
<!--
    Initialize the dynamic shared memory that will be required for parallel
    operation.  <literal>coordinate</> points to a shared memory area of
    size equal to the return value of <function>EstimateDSMCustomScan</>.
    This callback is optional, and need only be supplied if this custom
    scan provider supports parallel execution.
-->
並列操作に要求される動的共有メモリを初期化します。
<literal>coordinate</>は、<function>EstimateDSMCustomScan</>の返り値と一致する、割り当て済み領域の量を示しています。
このコールバックは必須ではなく、カスタムスキャンプロバイダが並列実行をサポートする場合にのみ提供される必要があります。
   </para>

   <para>
<programlisting>
void (*ReInitializeDSMCustomScan) (CustomScanState *node,
                                   ParallelContext *pcxt,
                                   void *coordinate);
</programlisting>
    Re-initialize the dynamic shared memory required for parallel operation
    when the custom-scan plan node is about to be re-scanned.
    This callback is optional, and need only be supplied if this custom
    scan provider supports parallel execution.
    Recommended practice is that this callback reset only shared state,
    while the <function>ReScanCustomScan</> callback resets only local
    state.  Currently, this callback will be called
    before <function>ReScanCustomScan</>, but it's best not to rely on
    that ordering.
   </para>

   <para>
<programlisting>
void (*InitializeWorkerCustomScan) (CustomScanState *node,
                                    shm_toc *toc,
                                    void *coordinate);
</programlisting>
<!--
    Initialize a parallel worker's local state based on the shared state
    set up by the leader during <function>InitializeDSMCustomScan</>.
    This callback is optional, and need only be supplied if this custom
    scan provider supports parallel execution.
-->
<literal>InitializeDSMCustomScan</>によりリーダーにて設定された共有状態を元に、並列ワーカーのカスタム状態を初期化します。
このコールバックは必須ではなく、カスタムスキャンプロバイダが並列実行をサポートする場合にのみ提供される必要があります。
   </para>

   <para>
<programlisting>
void (*ShutdownCustomScan) (CustomScanState *node);
</programlisting>
    Release resources when it is anticipated the node will not be executed
    to completion.  This is not called in all cases; sometimes,
    <literal>EndCustomScan</> may be called without this function having
    been called first.  Since the DSM segment used by parallel query is
    destroyed just after this callback is invoked, custom scan providers that
    wish to take some action before the DSM segment goes away should implement
    this method.
   </para>

   <para>
<programlisting>
void (*ExplainCustomScan) (CustomScanState *node,
                           List *ancestors,
                           ExplainState *es);
</programlisting>
<!--
    Output additional information for <command>EXPLAIN</> of a custom-scan
    plan node.  This callback is optional.  Common data stored in the
    <structname>ScanState</>, such as the target list and scan relation, will
    be shown even without this callback, but the callback allows the display
    of additional, private state.
-->
カスタムスキャンの計画ノードの<command>EXPLAIN</>について追加情報を出力します。
このコールバックは必須ではありません。
対象のリストやスキャンのリレーションなど<structname>ScanState</>に格納される共通データは、このコールバックがなくても表示されますが、このコールバックにより、追加のプライベートな状態が表示できるようになります。
   </para>
  </sect2>
 </sect1>
</chapter>
