<!-- doc/src/sgml/plpython.sgml -->

<chapter id="plpython">
<!--
 <title>PL/Python - Python Procedural Language</title>
-->
<title>PL/Python - Python手続き言語</title>

 <indexterm zone="plpython"><primary>PL/Python</></>
 <indexterm zone="plpython"><primary>Python</></>

 <para>
<!--
  The <application>PL/Python</application> procedural language allows
  <productname>PostgreSQL</productname> functions to be written in the
  <ulink url="http://www.python.org">Python language</ulink>.
-->
<application>PL/Python</application>手続き言語を使用して<productname>PostgreSQL</productname>の関数を<ulink url="http://www.python.org/">Python言語</ulink>で作成することができます。
 </para>

 <para>
<!--
  To install PL/Python in a particular database, use
  <literal>CREATE EXTENSION plpythonu</>, or from the shell command line use
  <literal>createlang plpythonu <replaceable>dbname</></literal> (but
  see also <xref linkend="plpython-python23">).
-->
PL/Pythonを特定のデータベースにインストールするには、<literal>CREATE EXTENSION plpythonu</>を使用するか、またはシェルのコマンドラインから<literal>createlang plpython <replaceable>dbname</></literal>を使用してください
(ただし<xref linkend="plpython-python23">も参照してください)。
 </para>

  <tip>
   <para>
<!--
    If a language is installed into <literal>template1</>, all subsequently
    created databases will have the language installed automatically.
-->
言語を<literal>template1</>にインストールすると、その後に作成されるデータベース全てにその言語は自動的にインストールされます。
   </para>
  </tip>

 <para>
<!--
  PL/Python is only available as an <quote>untrusted</> language, meaning
  it does not offer any way of restricting what users can do in it and
  is therefore named <literal>plpythonu</>.  A trusted
  variant <literal>plpython</> might become available in the future
  if a secure execution mechanism is developed in Python.  The
  writer of a function in untrusted PL/Python must take care that the
  function cannot be used to do anything unwanted, since it will be
  able to do anything that could be done by a user logged in as the
  database administrator.  Only superusers can create functions in
  untrusted languages such as <literal>plpythonu</literal>.
-->
PL/Pythonは<quote>信頼されない</>、つまり、ユーザが実行可能なことを制限する方法を提供しない言語としてのみ利用可能です。
したがって、<literal>plpythonu</>という名前に変更されました。
Pythonで新しい安全な実行手法が開発されたら、将来信頼できる<literal>plpython</>の亜種は利用可能になるかもしれません。
データベース管理者としてログインしたユーザにより行えることをすべて行うことができますので、信頼されないPL/Pythonによる関数開発者は、その関数は不必要なものを行うために使用できないことに注意しなければなりません。
スーパーユーザのみが<literal>plpythonu</literal>などの信頼されない言語で関数を作成することができます。
 </para>

 <note>
  <para>
<!--
   Users of source packages must specially enable the build of
   PL/Python during the installation process.  (Refer to the
   installation instructions for more information.)  Users of binary
   packages might find PL/Python in a separate subpackage.
-->
ソースパッケージを使用するユーザは、インストール処理の過程でPL/Pythonの構築が有効になるように指定する必要があります。
（詳細については、インストール手順を参照してください。）
バイナリパッケージを使用する場合は、別のサブパッケージにPL/Pythonが入っている可能性があります。
  </para>
 </note>

 <sect1 id="plpython-python23">
<!--
  <title>Python 2 vs. Python 3</title>
-->
  <title>Python 2対Python 3</title>

  <para>
<!--
   PL/Python supports both the Python 2 and Python 3 language
   variants.  (The PostgreSQL installation instructions might contain
   more precise information about the exact supported minor versions
   of Python.)  Because the Python 2 and Python 3 language variants
   are incompatible in some important aspects, the following naming
   and transitioning scheme is used by PL/Python to avoid mixing them:
-->
PL/PythonはPython 2およびPython 3言語の両方をサポートします。
(PostgreSQLのインストール手順では、サポートするPythonの細かなマイナーバージョンに関して、より正確な情報が記載されています。)
Python 2及びPython 3言語には重要な側面でいくつか互換性がありませんので、混在を防ぐためにPL/Pythonでは以下の命名ならびに移行計画が使用されています。

   <itemizedlist>
    <listitem>
     <para>
<!--
      The PostgreSQL language named <literal>plpython2u</literal>
      implements PL/Python based on the Python 2 language variant.
-->
<literal>plpython2u</literal>という名前のPostgreSQL言語はPython 2言語に基づいたPL/Pythonを実装します。
     </para>
    </listitem>

    <listitem>
     <para>
<!--
      The PostgreSQL language named <literal>plpython3u</literal>
      implements PL/Python based on the Python 3 language variant.
-->
<literal>plpython3u</literal>という名前のPostgreSQL言語はPython 3言語に基づいたPL/Pythonを実装します。
     </para>
    </listitem>

    <listitem>
     <para>
<!--
      The language named <literal>plpythonu</literal> implements
      PL/Python based on the default Python language variant, which is
      currently Python 2.  (This default is independent of what any
      local Python installations might consider to be
      their <quote>default</quote>, for example,
      what <filename>/usr/bin/python</filename> might be.)  The
      default will probably be changed to Python 3 in a distant future
      release of PostgreSQL, depending on the progress of the
      migration to Python 3 in the Python community.
-->
<literal>plpythonu</literal>という名前の言語はデフォルトのPython言語(現時点ではPython 2)に基づいたPL/Pythonを実装します。
(このデフォルトはどのローカルにインストールされたPythonがその<quote>デフォルト</quote>とみなされるか、例えば<filename>/usr/bin/python</filename>が何を示すか、とは独立しています。)
PythonコミュニティにおけるPython 3への移行の進行状況に依存しますが、おそらく近い将来のPostgreSQLのデフォルトはPython 3に変わります。
     </para>
    </listitem>
   </itemizedlist>

<!--
   This scheme is analogous to the recommendations in <ulink
   url="http://www.python.org/dev/peps/pep-0394/">PEP 394</ulink> regarding the
   naming and transitioning of the <command>python</command> command.
-->
この計画は、<ulink url="http://www.python.org/dev/peps/pep-0394/">PEP 394</ulink>内の、<command>python</command>コマンドの命名と移行に関する推奨に類似しています。
  </para>

  <para>
<!--
   It depends on the build configuration or the installed packages
   whether PL/Python for Python 2 or Python 3 or both are available.
-->
Python 2用のPL/PythonかPython 3用のPL/Python、またはその両方が利用できるかどうかは、構築時の設定またはインストールしたパッケージに依存します。
  </para>

  <tip>
   <para>
<!--
    The built variant depends on which Python version was found during
    the installation or which version was explicitly set using
    the <envar>PYTHON</envar> environment variable;
    see <xref linkend="install-procedure">.  To make both variants of
    PL/Python available in one installation, the source tree has to be
    configured and built twice.
-->
どのバージョンのPythonがインストール時に検出されるか、または、<envar>PYTHON</envar>環境変数を使用してバージョンを明示的に設定することで、構築される亜種が決まります。
<xref linkend="install-procedure">を参照してください。
１つのインストレーションで両方のPL/Pythonを利用可能にするためには、ソースツリーでconfigureと構築を２回行う必要があります。
   </para>
  </tip>

  <para>
<!--
   This results in the following usage and migration strategy:
-->
この結果以下のような使用方法と移行戦略となります。

   <itemizedlist>
    <listitem>
     <para>
<!--
      Existing users and users who are currently not interested in
      Python 3 use the language name <literal>plpythonu</literal> and
      don't have to change anything for the foreseeable future.  It is
      recommended to gradually <quote>future-proof</quote> the code
      via migration to Python 2.6/2.7 to simplify the eventual
      migration to Python 3.
-->
既存のユーザおよび現時点でPython 3に興味を持たないユーザは<literal>plpythonu</literal>という名前の言語を使用し、当分の間何も変更する必要はありません。
最終的なPython 3への移行を簡単にするために、Python 2.6/2.7への移行を介してコードを少しずつ<quote>将来に備える</quote>ことを勧めます。
     </para>

     <para>
<!--
      In practice, many PL/Python functions will migrate to Python 3
      with few or no changes.
-->
実際には、多くのPL/Python関数はそのまま、またはわずかな変更を行うことでPython 3に移行されます。
     </para>
    </listitem>

    <listitem>
     <para>
<!--
      Users who know that they have heavily Python 2 dependent code
      and don't plan to ever change it can make use of
      the <literal>plpython2u</literal> language name.  This will
      continue to work into the very distant future, until Python 2
      support might be completely dropped by PostgreSQL.
-->
Python 2に大きく依存するコードがあることが分かっていて、変更する予定がないユーザは<literal>plpython2u</literal>言語名を使用することができます。
これは、PostgreSQLでPython 2のサポートが完全になくなる、非常に先の将来まで動作し続けます。
     </para>
    </listitem>

    <listitem>
     <para>
<!--
      Users who want to dive into Python 3 can use
      the <literal>plpython3u</literal> language name, which will keep
      working forever by today's standards.  In the distant future,
      when Python 3 might become the default, they might like to
      remove the <quote>3</quote> for aesthetic reasons.
-->
Python 3に挑戦したいユーザは、現在の標準では永久に動作し続ける<literal>plpython3u</literal>言語名を使用できます。
遠い将来、Python 3がデフォルトになった時、美的な理由から<quote>3</quote>という文字はなくなることになるでしょう。
     </para>
    </listitem>

    <listitem>
     <para>
<!--
      Daredevils, who want to build a Python-3-only operating system
      environment, can change the contents of
      <link linkend="catalog-pg-pltemplate"><structname>pg_pltemplate</structname></link>
      to make <literal>plpythonu</literal> be equivalent
      to <literal>plpython3u</literal>, keeping in mind that this
      would make their installation incompatible with most of the rest
      of the world.
-->
Python 3のみのオペレーティングシステム環境を構築したい、恐れを知らぬユーザは、<link linkend="catalog-pg-pltemplate"><structname>pg_pltemplate</structname></link>の内容を変更して、<literal>plpythonu</literal>が<literal>plpython3u</literal>を示すようにすることができます。
ただし、世間一般と互換性がないインストレーションを作成していることを覚えておいてください。
     </para>
    </listitem>
   </itemizedlist>
  </para>

  <para>
<!--
   See also the
   document <ulink url="http://docs.python.org/py3k/whatsnew/3.0.html">What's
   New In Python 3.0</ulink> for more information about porting to
   Python 3.
-->
また、Python 3への移植に関する情報については<ulink url="http://docs.python.org/py3k/whatsnew/3.0.html">Python 3.0における新機能</ulink>文書を参照してください。
  </para>

  <para>
<!--
   It is not allowed to use PL/Python based on Python 2 and PL/Python
   based on Python 3 in the same session, because the symbols in the
   dynamic modules would clash, which could result in crashes of the
   PostgreSQL server process.  There is a check that prevents mixing
   Python major versions in a session, which will abort the session if
   a mismatch is detected.  It is possible, however, to use both
   PL/Python variants in the same database, from separate sessions.
-->
Python 2を基にしたPL/PythonとPython 3を基にしたPL/Pythonを同じセッションで使用することはできません。
動的モジュール内のシンボルが相反するため、こうするとPostgreSQLサーバプロセスがクラッシュしてしまうためです。
あるセッション内でPythonのメジャーバージョンが混在させないための検査があり、不一致が見つかるとセッションは中断されます。
しかし別々のセッションからであれば、同じデータベースにおいて異なるPL/Pythonの両方を使用することができます。
  </para>
 </sect1>

 <sect1 id="plpython-funcs">
<!--
  <title>PL/Python Functions</title>
-->
  <title>PL/Python関数</title>

  <para>
<!--
   Functions in PL/Python are declared via the
   standard <xref linkend="sql-createfunction"> syntax:
-->
PL/Pythonで作成された関数は標準的な<xref linkend="sql-createfunction">構文で宣言されます。

<programlisting>
CREATE FUNCTION <replaceable>funcname</replaceable> (<replaceable>argument-list</replaceable>)
  RETURNS <replaceable>return-type</replaceable>
AS $$
  # PL/Python function body
$$ LANGUAGE plpythonu;
</programlisting>
  </para>

  <para>
<!--
   The body of a function is simply a Python script. When the function
   is called, its arguments are passed as elements of the list
   <varname>args</varname>; named arguments are also passed as
   ordinary variables to the Python script.  Use of named arguments is
   usually more readable.  The result is returned from the Python code
   in the usual way, with <literal>return</literal> or
   <literal>yield</literal> (in case of a result-set statement).  If
   you do not provide a return value, Python returns the default
   <symbol>None</symbol>. <application>PL/Python</application> translates
   Python's <symbol>None</symbol> into the SQL null value.
-->
関数本体は単なるPythonスクリプトです。
関数が呼び出されると、引数は<varname>args[]</varname>リストの要素として渡されます。
名前付きの引数も通常の変数としてPythonスクリプトに渡されます。
通常、名前付き引数の方が可読性が高くなります。
結果は、Pythonコードから通常の方法、<literal>return</literal>または<literal>yield</literal>（結果セット文の場合）で返されるものです。
戻り値を提供しない場合、Pythonはデフォルトの<symbol>None</symbol>を返します。
<application>PL/Python</application>はPythonの<symbol>None</symbol>をSQLのNULL値に変換します。
  </para>

  <para>
<!--
   For example, a function to return the greater of two integers can be
   defined as:
-->
たとえば、2つの整数の内大きな数を返す関数は以下のように定義することができます。

<programlisting>
CREATE FUNCTION pymax (a integer, b integer)
  RETURNS integer
AS $$
  if a &gt; b:
    return a
  return b
$$ LANGUAGE plpythonu;
</programlisting>

<!--
   The Python code that is given as the body of the function definition
   is transformed into a Python function. For example, the above results in:
-->
関数定義の本体として提供されたPythonのコードはPythonの関数に変換されます。
例えば上の例は以下のようになります。

<programlisting>
def __plpython_procedure_pymax_23456():
  if a &gt; b:
    return a
  return b
</programlisting>

<!--
   assuming that 23456 is the OID assigned to the function by
   <productname>PostgreSQL</productname>.
-->
ここで、23456は<productname>PostgreSQL</productname>により割り当てられたこの関数のOIDです。
  </para>

  <para>
<!--
   The arguments are set as global variables.  Because of the scoping
   rules of Python, this has the subtle consequence that an argument
   variable cannot be reassigned inside the function to the value of
   an expression that involves the variable name itself, unless the
   variable is redeclared as global in the block.  For example, the
   following won't work:
-->
引数はグローバル変数として設定されます。
Pythonのスコープ規則のため、これは、ブロック内でグローバルとして再宣言されていない限り、関数内で引数変数に変数名自身を含む式の値として再代入できないという難解な結果をもたらします。
例えば以下は動作しません。

<programlisting>
CREATE FUNCTION pystrip(x text)
  RETURNS text
AS $$
  x = x.strip()  # error
  return x
$$ LANGUAGE plpythonu;
</programlisting>
<!--
   because assigning to <varname>x</varname>
   makes <varname>x</varname> a local variable for the entire block,
   and so the <varname>x</varname> on the right-hand side of the
   assignment refers to a not-yet-assigned local
   variable <varname>x</varname>, not the PL/Python function
   parameter.  Using the <literal>global</literal> statement, this can
   be made to work:
-->
<varname>x</varname>への代入は、<varname>x</varname>をブロック全体に対するローカル変数にしようとし、そして、代入の右辺の<varname>x</varname>がPL/Pythonの関数パラメータではなく、まだ割り当てられていないローカル変数<varname>x</varname>を参照するためです。
<literal>global</literal>文を使用することで、動作するようになります。
<programlisting>
CREATE FUNCTION pystrip(x text)
  RETURNS text
AS $$
  global x
  x = x.strip()  # ok now
  return x
$$ LANGUAGE plpythonu;
</programlisting>
<!--
   But it is advisable not to rely on this implementation detail of
   PL/Python.  It is better to treat the function parameters as
   read-only.
-->
しかし、PL/Pythonのこうした詳細な実装に依存しないようにすることを勧めます。
関数パラメータは読み取りのみとして扱うことを勧めます。
  </para>

 </sect1>

 <sect1 id="plpython-data">
<!--
  <title>Data Values</title>
-->
  <title>データ値</title>
  <para>
<!--
   Generally speaking, the aim of PL/Python is to provide
   a <quote>natural</quote> mapping between the PostgreSQL and the
   Python worlds.  This informs the data mapping rules described
   below.
-->
一般的にいって、PL/Pythonの目標はPostgreSQLとPythonの世界の間で<quote>自然な</quote>対応付けを提供することです。
これは以下のようなデータの対応付けを形成します。
  </para>

  <sect2>
<!--
   <title>Data Type Mapping</title>
-->
   <title>データ型の対応付け</title>
   <para>
<!--
    Function arguments are converted from their PostgreSQL type to a
    corresponding Python type:
-->
関数引数は、以下のようにPostgreSQLの型から対応するPython型に変換されます。
    <itemizedlist>
     <listitem>
      <para>
<!--
       PostgreSQL <type>boolean</type> is converted to Python <type>bool</type>.
-->
PostgreSQLの<type>boolean</type>はPythonの<type>bool</type>に変換されます。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       PostgreSQL <type>smallint</type> and <type>int</type> are
       converted to Python <type>int</type>.
       PostgreSQL <type>bigint</type> is converted
       to <type>long</type> in Python 2 and to <type>int</type> in
       Python 3.
-->
PostgreSQLの<type>smallint</type>および<type>int</type>はPythonの<type>int</type>に変換されます。
PostgreSQLの<type>bigint</type>は、Python 2では<type>long</type>に、Python 3では<type>int</type>に変換されます。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       PostgreSQL <type>real</type> and <type>double</type> are converted to
       Python <type>float</type>.
-->
PostgreSQLの<type>real</type>および<type>double</type>はPythonの<type>float</type>に変換されます。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       PostgreSQL <type>numeric</type> is converted to
       Python <type>Decimal</type>.  This type is imported from
       the <literal>cdecimal</literal> package if that is available.
       Otherwise,
       <literal>decimal.Decimal</literal> from the standard library will be
       used.  <literal>cdecimal</literal> is significantly faster
       than <literal>decimal</literal>.  In Python 3.3,
       however, <literal>cdecimal</literal> has been integrated into the
       standard library under the name <literal>decimal</literal>, so there is
       no longer any difference.
-->
PostgreSQLの<type>numeric</type>はPythonの<type>Decimal</type>に変換されます。
この型は可能ならば<literal>cdecimal</literal>パッケージからインポートできます。
可能でなければ、標準ライブラリの<literal>decimal.Decimal</literal>が使用できます。
<literal>cdecimal</literal>は<literal>decimal</literal>より高速です。
しかしPython 3.3から、<literal>cdecimal</literal>は<literal>decimal</literal>という名前で標準ライブラリに統合されたので、もはや差異はありません。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       PostgreSQL <type>bytea</type> is converted to
       Python <type>str</type> in Python 2 and to <type>bytes</type>
       in Python 3.  In Python 2, the string should be treated as a
       byte sequence without any character encoding.
-->
PostgreSQLの<type>bytea</type>は、Python 2では<type>str</type>に、Python 3では<type>bytes</type>に変換されます。
Python 2では文字列は文字符号化方式を持たないバイト列として扱われるはずです。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       All other data types, including the PostgreSQL character string
       types, are converted to a Python <type>str</type>.  In Python
       2, this string will be in the PostgreSQL server encoding; in
       Python 3, it will be a Unicode string like all strings.
-->
PostgreSQLの文字列型を含む、上記以外のデータ型はすべてPythonの<type>str</type>に変換されます。
Python 2ではこの文字列はPostgreSQLのサーバ符号化方式で表されます。
Python 3ではすべての文字列と同様にUnicode文字列となります。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       For nonscalar data types, see below.
-->
スカラ型以外については後述します。
      </para>
     </listitem>
    </itemizedlist>
   </para>

   <para>
<!--
    Function return values are converted to the declared PostgreSQL
    return data type as follows:
-->
関数の戻り値は、以下のようにPostgreSQLの宣言された戻り値データ型に変換されます。
    <itemizedlist>
     <listitem>
      <para>
<!--
       When the PostgreSQL return type is <type>boolean</type>, the
       return value will be evaluated for truth according to the
       <emphasis>Python</emphasis> rules.  That is, 0 and empty string
       are false, but notably <literal>'f'</literal> is true.
-->
PostgreSQLの戻り値の型が<type>boolean</type>の場合、戻り値は<emphasis>Python</emphasis>の規約に従った真に対して評価されます。
つまり、0や空文字列は偽です。
<literal>'f'</literal>が真となることには注意してください。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       When the PostgreSQL return type is <type>bytea</type>, the
       return value will be converted to a string (Python 2) or bytes
       (Python 3) using the respective Python built-ins, with the
       result being converted <type>bytea</type>.
-->
PostgreSQLの戻り値の型が<type>bytea</type>の場合、戻り値は文字列(Python 2)またはbytes(Python 3)に、それぞれ対応するPythonのビルトインを使用して変換され、その結果が<type>bytea</type>に変換されます。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       For all other PostgreSQL return types, the returned Python
       value is converted to a string using the Python
       built-in <literal>str</literal>, and the result is passed to the
       input function of the PostgreSQL data type.
-->
この他のPostgreSQLの戻り値型では、返されるPythonの値はPythonのビルトイン<literal>str</literal>を使用して文字列に変換され、その結果がPostgreSQLデータ型の入力関数に渡されます。
      </para>

      <para>
<!--

       Strings in Python 2 are required to be in the PostgreSQL server
       encoding when they are passed to PostgreSQL.  Strings that are
       not valid in the current server encoding will raise an error,
       but not all encoding mismatches can be detected, so garbage
       data can still result when this is not done correctly.  Unicode
       strings are converted to the correct encoding automatically, so
       it can be safer and more convenient to use those.  In Python 3,
       all strings are Unicode strings.
-->
Python 2における文字列はPostgreSQLに渡される時にPostgreSQLサーバの符号化方式でなければなりません。
現在のサーバ符号化方式で無効な文字列はエラーとなりますが、符号化方式の不一致がすべて検知されることはありません。
このため正確に行われなかった場合にはゴミデータという結果になります。
Unicode文字列は自動的に正しい符号化方式に変換されます。
このためこれを使用することがより安全でより便利です。
Python 3における文字列はすべてUnicode文字列です。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       For nonscalar data types, see below.
-->
スカラデータ型以外については後述します。
      </para>
     </listitem>
    </itemizedlist>

<!--
    Note that logical mismatches between the declared PostgreSQL
    return type and the Python data type of the actual return object
    are not flagged; the value will be converted in any case.
-->
宣言されたPostgreSQLの戻り値型と実際に返されるオブジェクトのPythonデータ型との間の論理的な不整合が伝わらないことに注意してください。
値はいかなる場合でも変換されます。
   </para>
<!--
v9.1で削除のためコメントアウト
   <tip>
    <para>

     <application>PL/Python</application> functions cannot return
     either type <type>RECORD</type> or <type>SETOF RECORD</type>.  A
     workaround is to write a <application>PL/pgSQL</application>
     function that creates a temporary table, have it call the
     <application>PL/Python</application> function to fill the table,
     and then have the <application>PL/pgSQL</application> function
     return the generic <type>RECORD</type> from the temporary table.

<application>PL/Python</application>関数は<type>RECORD</type>型または<type>SETOF RECORD</type>を返すことができません。
回避方法は、次のような<application>PL/pgSQL</application>関数を作成することです。
<application>PL/pgSQL</application>関数で一時テーブルを作成し、その関数から<application>PL/Python</application>関数を呼び出して、一時テーブルに投入し、その後<application>PL/pgSQL</application>関数で一時テーブルから汎用的な<type>RECORD</type>を返します。
    </para>
   </tip>
コメントアウト終わり
-->
  </sect2>

  <sect2>
<!--
   <title>Null, None</title>
-->
   <title>NullとNone</title>
  <para>
<!--
   If an SQL null value<indexterm><primary>null value</primary><secondary
   sortas="PL/Python">in PL/Python</secondary></indexterm> is passed to a
   function, the argument value will appear as <symbol>None</symbol> in

   Python. For example, the function definition of <function>pymax</function>
   shown in <xref linkend="plpython-funcs"> will return the wrong answer for null
   inputs. We could add <literal>STRICT</literal> to the function definition
   to make <productname>PostgreSQL</productname> do something more reasonable:
   if a null value is passed, the function will not be called at all,
   but will just return a null result automatically. Alternatively,
   we could check for null inputs in the function body:
-->
SQLのNULL値が関数に渡されると、その引数値はPythonでは<symbol>None</symbol>となります。
<indexterm><primary>NULL値</primary><secondary sortas="PL/Python">PL/Pythonにおける</secondary></indexterm>
例えば、<xref linkend="plpython-funcs">に示された<function>pymax</function>関数の定義では、NULL入力に対して間違った結果が返されます。
関数定義に<literal>STRICT</literal>を付与して<productname>PostgreSQL</productname>を、NULL値が渡された場合にその関数を呼び出さず、自動的に単にNULL結果を返すという、より理想的に動作させることができます。
他に、関数本体でNULL入力を検査することもできます。

<programlisting>
CREATE FUNCTION pymax (a integer, b integer)
  RETURNS integer
AS $$
  if (a is None) or (b is None):
    return None
  if a &gt; b:
    return a
  return b
$$ LANGUAGE plpythonu;
</programlisting>

<!--
   As shown above, to return an SQL null value from a PL/Python
   function, return the value <symbol>None</symbol>. This can be done whether the
   function is strict or not.
-->
上で示したように、PL/Python関数からSQL NULL値を返すには、<symbol>None</symbol>という値を返してください。
関数を厳密とした場合でも厳密としない場合でも、これを行うことができます。
  </para>
  </sect2>

  <sect2 id="plpython-arrays">
<!--
   <title>Arrays, Lists</title>
-->
   <title>配列、リスト</title>
  <para>
<!--
   SQL array values are passed into PL/Python as a Python list.  To
   return an SQL array value out of a PL/Python function, return a
   Python sequence, for example a list or tuple:
-->
SQL配列値はPythonのリストとしてPL/Pythonに渡されます。
PL/Python関数の外部にSQL配列値を返すためには、Pythonのシーケンス、例えばリストかタプルを返します。

<programlisting>
CREATE FUNCTION return_arr()
  RETURNS int[]
AS $$
return (1, 2, 3, 4, 5)
$$ LANGUAGE plpythonu;

SELECT return_arr();
 return_arr  
-------------
 {1,2,3,4,5}
(1 row)
</programlisting>

<!--
   Note that in Python, strings are sequences, which can have
   undesirable effects that might be familiar to Python programmers:
-->
Pythonでは、文字列はシーケンスであることに注意してください。
これは予想できない影響を与えることがありますが、Pythonプログラマには慣れたものでしょう。

<programlisting>
CREATE FUNCTION return_str_arr()
  RETURNS varchar[]
AS $$
return "hello"
$$ LANGUAGE plpythonu;

SELECT return_str_arr();
 return_str_arr
----------------
 {h,e,l,l,o}
(1 row)
</programlisting>
  </para>
  </sect2>

  <sect2>
<!--
   <title>Composite Types</title>
-->
   <title>複合型</title>
  <para>
<!--
   Composite-type arguments are passed to the function as Python mappings. The
   element names of the mapping are the attribute names of the composite type.
   If an attribute in the passed row has the null value, it has the value
   <symbol>None</symbol> in the mapping. Here is an example:
-->
複合型の引数はPythonのマップとして渡されます。
マップの要素名は複合型の属性名です。
渡された行の属性値がNULLの場合、マップ上では<symbol>None</symbol>という値となります。
以下に例を示します。
<programlisting>
CREATE TABLE employee (
  name text,
  salary integer,
  age integer
);

CREATE FUNCTION overpaid (e employee)
  RETURNS boolean
AS $$
  if e["salary"] &gt; 200000:
    return True
  if (e["age"] &lt; 30) and (e["salary"] &gt; 100000):
    return True
  return False
$$ LANGUAGE plpythonu;
</programlisting>
  </para>

  <para>
<!--
   There are multiple ways to return row or composite types from a Python
   function. The following examples assume we have:
-->
Python関数から行または複合型を返す方法は複数存在します。
以下の例では

<programlisting>
CREATE TYPE named_value AS (
  name   text,
  value  integer
);
</programlisting>
を前提とします。

<!--
   A composite result can be returned as a:
-->
複合型の結果は以下のように返されます。

   <variablelist>
    <varlistentry>
<!--
     <term>Sequence type (a tuple or list, but not a set because
     it is not indexable)</term>
-->
     <term>シーケンス型（タプルまたはリスト。ただしインデック付けができないため<literal>set</literal> は不可）</term>
     <listitem>
      <para>
<!--
       Returned sequence objects must have the same number of items as the
       composite result type has fields. The item with index 0 is assigned to
       the first field of the composite type, 1 to the second and so on. For
       example:
-->
返されるシーケンスオブジェクトは、結果の複合型が持つフィールドと同じ項目数をもたなければなりません。
0というインデックスの項目が複合型の最初のフィールド、1が次のフィールド、などとなります。
以下に例を示します。
<programlisting>
CREATE FUNCTION make_pair (name text, value integer)
  RETURNS named_value
AS $$
  return [ name, value ]
  # or alternatively, as tuple: return ( name, value )
$$ LANGUAGE plpythonu;
</programlisting>

<!--
       To return a SQL null for any column, insert <symbol>None</symbol> at
       the corresponding position.
-->
任意の列でSQL NULL値を返すには、対応する位置に<symbol>None</symbol>を挿入します。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
<!--
     <term>Mapping (dictionary)</term>
-->
     <term>マップ（辞書）</term>
     <listitem>
      <para>
<!--
       The value for each result type column is retrieved from the mapping
       with the column name as key. Example:
-->
結果型の列の値は、列名をキーとして持つマップから取り出されます。
以下に例を示します。

<programlisting>
CREATE FUNCTION make_pair (name text, value integer)
  RETURNS named_value
AS $$
  return { "name": name, "value": value }
$$ LANGUAGE plpythonu;
</programlisting>

<!--
       Any extra dictionary key/value pairs are ignored. Missing keys are
       treated as errors.
       To return a SQL null value for any column, insert
       <symbol>None</symbol> with the corresponding column name as the key.
-->
余計な辞書のキーと値の組み合わせは無視されます。
存在しないキーはエラーとして扱われます。
任意の列でSQL NULLを返すためには、対応する列名をキーとして<symbol>None</symbol>を挿入してください。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
<!--
     <term>Object (any object providing method <literal>__getattr__</literal>)</term>
-->
     <term>オブジェクト（<literal>__getattr__</literal>メソッドを提供する任意のオブジェクト）</term>
     <listitem>
      <para>
<!--
       This works the same as a mapping.
       Example:
-->
これはマップと同じように動作します。
以下に例を示します。

<programlisting>
CREATE FUNCTION make_pair (name text, value integer)
  RETURNS named_value
AS $$
  class named_value:
    def __init__ (self, n, v):
      self.name = n
      self.value = v
  return named_value(name, value)

  # or simply
  class nv: pass
  nv.name = name
  nv.value = value
  return nv
$$ LANGUAGE plpythonu;
</programlisting>
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

   <para>
<!--
    Functions with <literal>OUT</literal> parameters are also supported.  For example:
-->
<literal>OUT</literal>パラメータを用いる関数もサポートされています。
以下に例を示します。
<programlisting>
CREATE FUNCTION multiout_simple(OUT i integer, OUT j integer) AS $$
return (1, 2)
$$ LANGUAGE plpythonu;

SELECT * FROM multiout_simple();
</programlisting>
   </para>
  </sect2>

  <sect2>
<!--
   <title>Set-returning Functions</title>
-->
   <title>集合を返す関数</title>

  <para>
<!--
   A <application>PL/Python</application> function can also return sets of
   scalar or composite types. There are several ways to achieve this because
   the returned object is internally turned into an iterator. The following
   examples assume we have composite type:
-->
また、<application>PL/Python</application>関数はスカラまたは複合型の集合を返すこともできます。
返されるオブジェクトは内部的にイテレータに変換されるため、複数の実現方法があります。
以下の例では、以下の複合型が存在することを仮定します。

<programlisting>
CREATE TYPE greeting AS (
  how text,
  who text
);
</programlisting>

<!--
   A set result can be returned from a:

-->
集合という結果は以下から返されます。
   <variablelist>
    <varlistentry>
<!--
     <term>Sequence type (tuple, list, set)</term>
-->
     <term>シーケンス型（タプル、リスト、セット）</term>
     <listitem>
      <para>
<programlisting>
CREATE FUNCTION greet (how text)
  RETURNS SETOF greeting
AS $$
  # return tuple containing lists as composite types
  # all other combinations work also
  return ( [ how, "World" ], [ how, "PostgreSQL" ], [ how, "PL/Python" ] )
$$ LANGUAGE plpythonu;
</programlisting>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
<!--
     <term>Iterator (any object providing <symbol>__iter__</symbol> and
      <symbol>next</symbol> methods)</term>
-->
     <term>
イテレータ（<symbol>__iter__</symbol>メソッドと<symbol>next</symbol>メソッドを提供する任意のオブジェクト）
     </term>
     <listitem>
      <para>
<programlisting>
CREATE FUNCTION greet (how text)
  RETURNS SETOF greeting
AS $$
  class producer:
    def __init__ (self, how, who):
      self.how = how
      self.who = who
      self.ndx = -1

    def __iter__ (self):
      return self

    def next (self):
      self.ndx += 1
      if self.ndx == len(self.who):
        raise StopIteration
      return ( self.how, self.who[self.ndx] )

  return producer(how, [ "World", "PostgreSQL", "PL/Python" ])
$$ LANGUAGE plpythonu;
</programlisting>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
<!--
     <term>Generator (<literal>yield</literal>)</term>
-->
     <term>ジェネレータ(<literal>yield</literal>)</term>
     <listitem>
      <para>
<programlisting>
CREATE FUNCTION greet (how text)
  RETURNS SETOF greeting
AS $$
  for who in [ "World", "PostgreSQL", "PL/Python" ]:
    yield ( how, who )
$$ LANGUAGE plpythonu;
</programlisting>

       <warning>
        <para>
<!--
         Due to Python
         <ulink url="http://bugs.python.org/issue1483133">bug #1483133</ulink>,
         some debug versions of Python 2.4
         (configured and compiled with option <literal>&#045;&#045;with-pydebug</literal>)
         are known to crash the <productname>PostgreSQL</productname> server
         when using an iterator to return a set result.
         Unpatched versions of Fedora 4 contain this bug.
         It does not happen in production versions of Python or on patched
         versions of Fedora 4.
-->
Pythonの<ulink url="http://bugs.python.org/issue1483133">bug #1483133</ulink>のため、一部のPython 2.4デバッグ版（<literal>--with-pydebug</literal>オプション付きで設定/コンパイルされたPython）が、集合結果を返すためにイテレータを使用する場合に<productname>PostgreSQL</productname>サーバをクラッシュさせることがわかっています。
未パッチのFedora 4にはこの不具合があります。
Python運用版やパッチ適用済みのFedora 4ではこの問題は起こりません。
        </para>
       </warning>
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

   <para>
<!--
    Set-returning functions with <literal>OUT</literal> parameters
    (using <literal>RETURNS SETOF record</literal>) are also
    supported.  For example:
-->
（<literal>RETURNS SETOF record</literal>を使用して）<literal>OUT</literal>パラメータを持つ集合を返す関数もサポートされます。
以下に例を示します。
<programlisting>
CREATE FUNCTION multiout_simple_setof(n integer, OUT integer, OUT integer) RETURNS SETOF record AS $$
return [(1, 2)] * n
$$ LANGUAGE plpythonu;

SELECT * FROM multiout_simple_setof(3);
</programlisting>
   </para>
  </sect2>
 </sect1>

 <sect1 id="plpython-sharing">
<!--
  <title>Sharing Data</title>
-->
  <title>データの共有</title>
  <para>
<!--
   The global dictionary <varname>SD</varname> is available to store
   data between function calls.  This variable is private static data.
   The global dictionary <varname>GD</varname> is public data,
   available to all Python functions within a session.  Use with
   care.<indexterm><primary>global data</>
   <secondary>in PL/Python</></indexterm>
-->
グローバルな<varname>SD</varname>辞書は、関数呼び出し間のデータ保存のために使用することができます。
この変数はプライベートな静的データです。
グローバルな<varname>GD</varname>辞書は、共有データであり、セッション内の全てのPython関数で使用することができます。
注意して使用してください。
<indexterm><primary>グローバルデータ</><secondary>PL/Pythonにおける</></indexterm>
  </para>

  <para>
<!--
   Each function gets its own execution environment in the
   Python interpreter, so that global data and function arguments from
   <function>myfunc</function> are not available to
   <function>myfunc2</function>.  The exception is the data in the
   <varname>GD</varname> dictionary, as mentioned above.
-->
各関数は、Pythonインタプリタ内で自身の実行環境を入手します。
そのため、<function>myfunc</function>によるグローバルデータと関数の引数は<function>myfunc2</function>から使用することはできません。
上記で説明した通り、<varname>GD</varname>辞書内のデータは例外です。
  </para>
 </sect1>

 <sect1 id="plpython-do">
<!--
  <title>Anonymous Code Blocks</title>
-->
  <title>匿名コードブロック</title>

  <para>
<!--
   PL/Python also supports anonymous code blocks called with the
   <xref linkend="sql-do"> statement:
-->
PL/Pythonは<xref linkend="sql-do">文で呼び出される匿名コードブロックもサポートします。

<programlisting>
DO $$
    # PL/Python code
$$ LANGUAGE plpythonu;
</programlisting>

<!--
   An anonymous code block receives no arguments, and whatever value it
   might return is discarded.  Otherwise it behaves just like a function.
-->
匿名コードブロックは引数を持たず、また、何か値を返したとしても破棄されます。
その他は関数とまったく同様に動作します。
  </para>
 </sect1>

 <sect1 id="plpython-trigger">
<!--
  <title>Trigger Functions</title>
-->
  <title>トリガ関数</title>

  <indexterm zone="plpython-trigger">
<!--
   <primary>trigger</primary>
   <secondary>in PL/Python</secondary>
-->
   <primary>トリガ</primary>
   <secondary>PL/Pythonにおける</secondary>
  </indexterm>

  <para>
<!--
   When a function is used as a trigger, the dictionary
   <literal>TD</literal> contains trigger-related values:
-->
トリガとして関数を使用した場合、<literal>TD</literal>辞書にトリガに関連した値が格納されます。
   <variablelist>
    <varlistentry>
     <term><literal>TD["event"]</></term>
     <listitem>
      <para>
<!--
       contains the event as a string:
       <literal>INSERT</>, <literal>UPDATE</>,
       <literal>DELETE</>, or <literal>TRUNCATE</>.
-->
次のイベントが文字列として格納されます。
<literal>INSERT</>、<literal>UPDATE</>、<literal>DELETE</>、<literal>TRUNCATE</>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>TD["when"]</></term>
     <listitem>
      <para>
<!--
       contains one of <literal>BEFORE</>, <literal>AFTER</>, or
       <literal>INSTEAD OF</>.
-->
<literal>BEFORE</>、<literal>AFTER</>、または<literal>INSTEAD OF</>のいずれかが格納されます。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>TD["level"]</></term>
     <listitem>
      <para>
<!--
       contains <literal>ROW</> or <literal>STATEMENT</>.
-->
<literal>ROW</>または<literal>STATEMENT</>が格納されます。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>TD["new"]</></term>
     <term><literal>TD["old"]</></term>
     <listitem>
      <para>
<!--
       For a row-level trigger, one or both of these fields contain
       the respective trigger rows, depending on the trigger event.
-->
行レベルトリガにおいてトリガイベントに依存して、これらのフィールドの片方または両方に対応するトリガ行が格納されます。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>TD["name"]</></term>
     <listitem>
      <para>
<!--
       contains the trigger name.
-->
トリガ名が格納されます。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>TD["table_name"]</></term>
     <listitem>
      <para>
<!--
       contains the name of the table on which the trigger occurred.
-->
トリガの発生元のテーブルの名前が格納されます。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>TD["table_schema"]</></term>
     <listitem>
      <para>
<!--
       contains the schema of the table on which the trigger occurred.
-->
トリガの発生元のテーブルのスキーマが格納されます。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>TD["relid"]</></term>
     <listitem>
      <para>
<!--
       contains the OID of the table on which the trigger occurred.
-->
トリガの発生元テーブルのOIDが格納されます。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>TD["args"]</></term>
     <listitem>
      <para>
<!--
       If the <command>CREATE TRIGGER</> command
       included arguments, they are available in <literal>TD["args"][0]</> to
       <literal>TD["args"][<replaceable>n</>-1]</>.
-->
<command>CREATE TRIGGER</>に引数が含まれていた場合、その引数は<literal>TD["args"][0]</>から<literal>TD["args"][<replaceable>n</>-1]</>までの範囲で使用することができます。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

  <para>
<!--
   If <literal>TD["when"]</literal> is <literal>BEFORE</> or
   <literal>INSTEAD OF</> and
   <literal>TD["level"]</literal> is <literal>ROW</>, you can
   return <literal>None</literal> or <literal>"OK"</literal> from the
   Python function to indicate the row is unmodified,
   <literal>"SKIP"</> to abort the event, or if <literal>TD["event"]</>
   is <command>INSERT</> or <command>UPDATE</> you can return
   <literal>"MODIFY"</> to indicate you've modified the new row.
   Otherwise the return value is ignored.
-->
<literal>TD["when"]</literal>が<literal>BEFORE</>または<literal>INSTEAD OF</>で、かつ、<literal>TD["level"]</literal>が<literal>ROW</>の場合、Pythonの関数から、行が変更されないことを示す<literal>None</literal>または<literal>"OK"</literal>、イベントを中断したことを示す<literal>"SKIP"</>を返すことができます。
また、<literal>TD["event"]</>が<command>INSERT</>または<command>UPDATE</>の場合、行を変更したことを示す<literal>"MODIFY"</>を返すことができます。
さもなければ、戻り値は無視されます。
  </para>
 </sect1>

 <sect1 id="plpython-database">
<!--
  <title>Database Access</title>
-->
  <title>データベースアクセス</title>

  <para>
<!--
   The PL/Python language module automatically imports a Python module
   called <literal>plpy</literal>.  The functions and constants in
   this module are available to you in the Python code as
   <literal>plpy.<replaceable>foo</replaceable></literal>.
-->
PL/Python言語モジュールは自動的に<literal>plpy</literal>というPythonモジュールをインポートします。
このモジュールの関数と定数は、<literal>plpy.<replaceable>foo</replaceable></literal>のように作成したPythonコードから使用することができます。
  </para>

  <sect2>
<!--
    <title>Database Access Functions</title>
-->
    <title>データベースアクセス関数</title>

  <para>
<!--
   The <literal>plpy</literal> module provides several functions to execute
   database commands:
-->
<literal>plpy</literal>モジュールはデータベースコマンドを実行するために数個の関数を用意しています。
  </para>

  <variablelist>
   <varlistentry>
    <term><literal>plpy.<function>execute</function>(<replaceable>query</replaceable> [, <replaceable>max-rows</replaceable>])</literal></term>
    <listitem>
     <para>
<!--
      Calling <function>plpy.execute</function> with a query string and an
      optional row limit argument causes that query to be run and the result to
      be returned in a result object.
-->
<function>plpy.execute</function>を、問い合わせ文字列および省略可能な行数制限引数を付けて呼び出すと、問い合わせが実行され、結果オブジェクトとして問い合わせ結果が返ります。
     </para>

     <para>
<!--
      The result object emulates a list or dictionary object.  The result
      object can be accessed by row number and column name.  For example:
-->
結果オブジェクトはリストもしくは辞書オブジェクトをエミュレートします。
結果オブジェクトは、行番号や列名によってアクセスすることができます。
例を示します。
<programlisting>
rv = plpy.execute("SELECT * FROM my_table", 5)
</programlisting>
<!--
      returns up to 5 rows from <literal>my_table</literal>.  If
      <literal>my_table</literal> has a column
      <literal>my_column</literal>, it would be accessed as:
-->
これは、<literal>my_table</literal>から5行までを返します。
<literal>my_table</literal>に<literal>my_column</literal>列が存在する場合、その列には以下のようにアクセスできます。
<programlisting>
foo = rv[i]["my_column"]
</programlisting>
<!--
      The number of rows returned can be obtained using the built-in
      <function>len</function> function.
-->
戻った行数はビルトイン<function>len</function>関数を使用して取得できます。
     </para>

     <para>
<!--
      The result object has these additional methods:
-->
結果オブジェクトには以下のメソッドが追加されています。
      <variablelist>
       <varlistentry>
        <term><literal><function>nrows</function>()</literal></term>
        <listitem>
         <para>
<!--
          Returns the number of rows processed by the command.  Note that this
          is not necessarily the same as the number of rows returned.  For
          example, an <command>UPDATE</command> command will set this value but
          won't return any rows (unless <literal>RETURNING</literal> is used).
-->
コマンドによる処理の行数を返します。
戻った行数と同じとは限らないことに注意してください。
例えば、<command>UPDATE</command>コマンドではゼロでない値を返しますが、行を戻すことはありません（<literal>RETURNING</literal>を使用したときは別です）。
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal><function>status</function>()</literal></term>
        <listitem>
         <para>
<!--
          The <function>SPI_execute()</function> return value.
-->
<function>SPI_execute()</function>関数の戻り値を返します。
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal><function>colnames</function>()</literal></term>
        <term><literal><function>coltypes</function>()</literal></term>
        <term><literal><function>coltypmods</function>()</literal></term>
        <listitem>
         <para>
<!--
          Return a list of column names, list of column type OIDs, and list of
          type-specific type modifiers for the columns, respectively.
-->
各々、列名のリスト、列の型OIDのリスト、列に関する型独自の型修飾子のリストを返します。
         </para>

         <para>
<!--
          These methods raise an exception when called on a result object from
          a command that did not produce a result set, e.g.,
          <command>UPDATE</command> without <literal>RETURNING</literal>, or
          <command>DROP TABLE</command>.  But it is OK to use these methods on
          a result set containing zero rows.
-->
<literal>RETURNING</literal>を持たない<command>UPDATE</command>や<command>DROP TABLE</command>など、結果セットを生成しないコマンドによる結果オブジェクトに対して呼び出された場合、これらのメソッドは例外を発生します。
しかし、ゼロ行の結果セットに対してこれらのメソッドを使用することには問題ありません。
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </para>

     <para>
<!--
      The result object can be modified.
-->
結果オブジェクトは変更できます。
     </para>

     <para>
<!--
      Note that calling <literal>plpy.execute</literal> will cause the entire
      result set to be read into memory.  Only use that function when you are
      sure that the result set will be relatively small.  If you don't want to
      risk excessive memory usage when fetching large results,
      use <literal>plpy.cursor</literal> rather
      than <literal>plpy.execute</literal>.
-->
<literal>plpy.execute</literal>を呼び出すことにより、結果セット全体がメモリ内に読み込まれることに注意してください。
結果セットが比較的小さいことが確実な場合だけ、この関数を使用してください。
大規模な結果を取り込む場合の過度のメモリ使用に関する危険を回避したい場合は、<literal>plpy.execute</literal>ではなく<literal>plpy.cursor</literal>を使用してください。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>plpy.<function>prepare</function>(<replaceable>query</replaceable> [, <replaceable>argtypes</replaceable>])</literal></term>
    <term><literal>plpy.<function>execute</function>(<replaceable>plan</replaceable> [, <replaceable>arguments</replaceable> [, <replaceable>max-rows</replaceable>]])</literal></term>
    <listitem>
     <para>
<!--
      <indexterm><primary>preparing a query</><secondary>in PL/Python</></indexterm>
      <function>plpy.prepare</function> prepares the execution plan for a
      query.  It is called with a query string and a list of parameter types,
      if you have parameter references in the query.  For example:
-->
<indexterm><primary>問い合わせの準備</><secondary>PL/Pythonにおける</></indexterm>
<function>plpy.prepare</function>は問い合わせの実行計画を準備します。
問い合わせ内にパラメータ参照がある場合、問い合わせ文字列および引数型のリストとともに呼び出されます。
例を示します。
<programlisting>
plan = plpy.prepare("SELECT last_name FROM my_users WHERE first_name = $1", ["text"])
</programlisting>
<!--
      <literal>text</literal> is the type of the variable you will be passing
      for <literal>$1</literal>.  The second argument is optional if you don't
      want to pass any parameters to the query.
-->
<literal>text</literal>は<literal>$1</literal>として渡される変数の型です。
問い合わせにパラメータを渡さない場合、2番目の引数は省略可能です。
     </para>
     <para>
<!--
      After preparing a statement, you use a variant of the
      function <function>plpy.execute</function> to run it:
-->
文を準備した後、それを実行するために関数<function>plpy.execute</function>の亜種を使用します。
<programlisting>
rv = plpy.execute(plan, ["name"], 5)
</programlisting>
<!--
      Pass the plan as the first argument (instead of the query string), and a
      list of values to substitute into the query as the second argument.  The
      second argument is optional if the query does not expect any parameters.
      The third argument is the optional row limit as before.
-->
実行計画を（問い合わせ文字列ではなく）最初の引数として渡してください。
問い合わせに代入する値のリストを、2番目の引数として渡してください。
問い合わせにパラメータがない場合、2番目の引数は省略可能です。
3番目の引数は、前に述べた省略可能な行数制限引数です。
     </para>

     <para>
<!--
      Query parameters and result row fields are converted between PostgreSQL
      and Python data types as described in <xref linkend="plpython-data">.
      The exception is that composite types are currently not supported: They
      will be rejected as query parameters and are converted to strings when
      appearing in a query result.  As a workaround for the latter problem, the
      query can sometimes be rewritten so that the composite type result
      appears as a result row rather than as a field of the result row.
      Alternatively, the resulting string could be parsed apart by hand, but
      this approach is not recommended because it is not future-proof.
-->
問い合わせパラメータおよび結果行のフィールドは<xref linkend="plpython-data">で示した通り、PostgreSQLとPythonのデータ型の間で変換されます。
現在複合型がサポートされていないという例外があります。
複合型は問い合わせパラメータとしては拒絶され、問い合わせの結果に存在する場合は文字列に変換されます。
後者の問題の回避方法として、結果行のフィールドとしてではなく結果行として複合型が存在するように問い合わせを書き換えることができる場合があります。
他に、結果として生じる文字列を手作業で解析して分離することもできますが、この方法は時代に左右されてしまいますので推奨されません。
     </para>

     <para>
<!--
      When you prepare a plan using the PL/Python module it is automatically
      saved.  Read the SPI documentation (<xref linkend="spi">) for a
      description of what this means.  In order to make effective use of this
      across function calls one needs to use one of the persistent storage
      dictionaries <literal>SD</literal> or <literal>GD</literal> (see
      <xref linkend="plpython-sharing">). For example:
-->
PL/Pythonモジュールを使用して準備した計画は自動的に保存されます。
これが何を意味するのかについてはSPIの文書（<xref linkend="spi">）を参照してください。
これを複数呼び出しにおいて効果的に使用するためには、永続的な格納用辞書である<literal>SD</literal>または<literal>GD</literal>（<xref linkend="plpython-sharing">を参照）のいずれかを使用する必要があります。
例を示します。
<programlisting>
CREATE FUNCTION usesavedplan() RETURNS trigger AS $$
    if "plan" in SD:
        plan = SD["plan"]
    else:
        plan = plpy.prepare("SELECT 1")
        SD["plan"] = plan
    # rest of function
$$ LANGUAGE plpythonu;
</programlisting>
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>plpy.<function>cursor</function>(<replaceable>query</replaceable>)</literal></term>
    <term><literal>plpy.<function>cursor</function>(<replaceable>plan</replaceable> [, <replaceable>arguments</replaceable>])</literal></term>
    <listitem>
     <para>
<!--
      The <literal>plpy.cursor</literal> function accepts the same arguments
      as <literal>plpy.execute</literal> (except for the row limit) and returns
      a cursor object, which allows you to process large result sets in smaller
      chunks.  As with <literal>plpy.execute</literal>, either a query string
      or a plan object along with a list of arguments can be used.
-->
<literal>plpy.cursor</literal>関数は<literal>plpy.execute</literal>と同じ引数を受け取り（行数制限引数を除いた）カーソルオブジェクトとして返します。
これにより大規模な結果セットをより小さな塊の中で処理することができます。
<literal>plpy.execute</literal>の場合と同様、問い合わせ文字列または引数リスト付きの計画オブジェクトを使用することができます。
     </para>

     <para>
<!--
      The cursor object provides a <literal>fetch</literal> method that accepts
      an integer parameter and returns a result object.  Each time you
      call <literal>fetch</literal>, the returned object will contain the next
      batch of rows, never larger than the parameter value.  Once all rows are
      exhausted, <literal>fetch</literal> starts returning an empty result
      object.  Cursor objects also provide an
      <ulink url="http://docs.python.org/library/stdtypes.html#iterator-types">iterator
      interface</ulink>, yielding one row at a time until all rows are
      exhausted.  Data fetched that way is not returned as result objects, but
      rather as dictionaries, each dictionary corresponding to a single result
      row.
-->
カーソルオブジェクトは、整数パラメータを受付け、結果オブジェクトを返す<literal>fetch</literal>メソッドを提供します。
<literal>fetch</literal>を呼び出す度に、返されるオブジェクトには次の一群の行が含まれます。
この行数はパラメータ値より多くなることはありません。
全ての行が出し尽くされると、<literal>fetch</literal>は空の結果オブジェクトを返すようになります。
カーソルオブジェクトはまた、すべての行を出し尽くすまで一度に１行を生成する<ulink url="http://docs.python.org/library/stdtypes.html#iterator-types">イテレータインタフェース</ulink>を提供します。
この方法で取り出されたデータは結果オブジェクトとしては返されず、１つの辞書が単一の結果行に対応する辞書群として返されます。
     </para>

     <para>
<!--
      An example of two ways of processing data from a large table is:
-->
大きなテーブルのデータを処理する、2つの方法の例を示します。
<programlisting>
CREATE FUNCTION count_odd_iterator() RETURNS integer AS $$
odd = 0
for row in plpy.cursor("select num from largetable"):
    if row['num'] % 2:
         odd += 1
return odd
$$ LANGUAGE plpythonu;

CREATE FUNCTION count_odd_fetch(batch_size integer) RETURNS integer AS $$
odd = 0
cursor = plpy.cursor("select num from largetable")
while True:
    rows = cursor.fetch(batch_size)
    if not rows:
        break
    for row in rows:
        if row['num'] % 2:
            odd += 1
return odd
$$ LANGUAGE plpythonu;

CREATE FUNCTION count_odd_prepared() RETURNS integer AS $$
odd = 0
plan = plpy.prepare("select num from largetable where num % $1 &lt;&gt; 0", ["integer"])
rows = list(plpy.cursor(plan, [2]))

return len(rows)
$$ LANGUAGE plpythonu;
</programlisting>
     </para>

     <para>
<!--
      Cursors are automatically disposed of.  But if you want to explicitly
      release all resources held by a cursor, use the <literal>close</literal>
      method.  Once closed, a cursor cannot be fetched from anymore.
-->
カーソルは自動的に処分されます。
しかし、カーソルが保有していた資源を明示的に開放したい場合は、<literal>close</literal>メソッドを使用してください。
閉じた後、カーソルからこれ以上取り込むことはできません。
     </para>

     <tip>
      <para>
<!--
        Do not confuse objects created by <literal>plpy.cursor</literal> with
        DB-API cursors as defined by
        the <ulink url="http://www.python.org/dev/peps/pep-0249/">Python
        Database API specification</ulink>.  They don't have anything in common
        except for the name.
-->
<literal>plpy.cursor</literal>によって作成されたオブジェクトと、<ulink url="http://www.python.org/dev/peps/pep-0249/">PythonデータベースAPI仕様</ulink>において定義されたDB-APIカーソルとを混同しないでください。
名称以外の共通点はありません。
      </para>
     </tip>
    </listitem>
   </varlistentry>
  </variablelist>

  </sect2>

  <sect2 id="plpython-trapping">
<!--
   <title>Trapping Errors</title>
-->
   <title>エラーの捕捉</title>

   <para>
<!--
    Functions accessing the database might encounter errors, which
    will cause them to abort and raise an exception.  Both
    <function>plpy.execute</function> and
    <function>plpy.prepare</function> can raise an instance of a subclass of
    <literal>plpy.SPIError</literal>, which by default will terminate
    the function.  This error can be handled just like any other
    Python exception, by using the <literal>try/except</literal>
    construct.  For example:
-->
データベースにアクセスする関数はエラーに遭遇し、エラーが関数をアボートして例外を発生させる原因となります。
<function>plpy.execute</function>および<function>plpy.prepare</function>は、デフォルトでは関数を終了させる<literal>plpy.SPIError</literal>のサブクラスのインスタンスを発生させることができます。
このエラーは、<literal>try/except</literal>構文を使用して、Pythonの他の例外と同様に処理できます。
例を示します。
<programlisting>
CREATE FUNCTION try_adding_joe() RETURNS text AS $$
    try:
        plpy.execute("INSERT INTO users(username) VALUES ('joe')")
    except plpy.SPIError:
<!--
        return "something went wrong"
-->
        "うまくいかなかった" を返す
    else:
<!--
        return "Joe added"
-->
        "Joeが追加された" を返す
$$ LANGUAGE plpythonu;
</programlisting>
   </para>

   <para>
<!--
    The actual class of the exception being raised corresponds to the
    specific condition that caused the error.  Refer
    to <xref linkend="errcodes-table"> for a list of possible
    conditions.  The module
    <literal>plpy.spiexceptions</literal> defines an exception class
    for each <productname>PostgreSQL</productname> condition, deriving
    their names from the condition name.  For
    instance, <literal>division_by_zero</literal>
    becomes <literal>DivisionByZero</literal>, <literal>unique_violation</literal>
    becomes <literal>UniqueViolation</literal>, <literal>fdw_error</literal>
    becomes <literal>FdwError</literal>, and so on.  Each of these
    exception classes inherits from <literal>SPIError</literal>.  This
    separation makes it easier to handle specific errors, for
    instance:
-->
発生される例外の実クラスはエラーを引き起こした特定の条件と対応します。
<xref linkend="errcodes-table">にあり得る条件のリストがありますので参照してください。
<literal>plpy.spiexceptions</literal>モジュールは<productname>PostgreSQL</productname>の条件それぞれに対して、その条件名に因んだ名前の例外クラスを定義しています。
例えば<literal>division_by_zero</literal>は<literal>DivisionByZero</literal>、<literal>unique_violation</literal>は<literal>UniqueViolation</literal>に、<literal>fdw_error</literal>は<literal>FdwError</literal>などのようになります。
これらの例外クラスはそれぞれ<literal>SPIError</literal>を継承したものです。
このように分離することで特定のエラーをより簡単に扱うことができるようになります。
以下に例を示します。
<programlisting>
CREATE FUNCTION insert_fraction(numerator int, denominator int) RETURNS text AS $$
from plpy import spiexceptions
try:
    plan = plpy.prepare("INSERT INTO fractions (frac) VALUES ($1 / $2)", ["int", "int"])
    plpy.execute(plan, [numerator, denominator])
except spiexceptions.DivisionByZero:
    return "denominator cannot equal zero"
except spiexceptions.UniqueViolation:
    return "already have that fraction"
except plpy.SPIError, e:
    return "other error, SQLSTATE %s" % e.sqlstate
else:
    return "fraction inserted"
$$ LANGUAGE plpythonu;
</programlisting>
<!--
    Note that because all exceptions from
    the <literal>plpy.spiexceptions</literal> module inherit
    from <literal>SPIError</literal>, an <literal>except</literal>
    clause handling it will catch any database access error.
-->
<literal>plpy.spiexceptions</literal>モジュールからの全ての例外は<literal>SPIError</literal>を継承するため、例外を処理する<literal>except</literal>句は全てのデータベースアクセスエラーを捕捉することに注意してください。
   </para>

   <para>
<!--
    As an alternative way of handling different error conditions, you
    can catch the <literal>SPIError</literal> exception and determine
    the specific error condition inside the <literal>except</literal>
    block by looking at the <literal>sqlstate</literal> attribute of
    the exception object.  This attribute is a string value containing
    the <quote>SQLSTATE</quote> error code.  This approach provides
    approximately the same functionality
-->
異なったエラー条件を処理する代りの方法として、<literal>SPIError</literal>例外を捕捉して、例外オブジェクトの<literal>sqlstate</literal>属性を調べることにより、<literal>except</literal>ブロック内部の明細なエラー条件を決定できます。
この属性は<quote>SQLSTATE</quote>エラーコードを含む文字列値です。
この方法は、ほぼ同じ機能を提供します。
   </para>
  </sect2>
 </sect1>

 <sect1 id="plpython-subtransaction">
<!--
  <title>Explicit Subtransactions</title>
-->
  <title>明示的サブトランザクション</title>

  <para>
<!--
   Recovering from errors caused by database access as described in
   <xref linkend="plpython-trapping"> can lead to an undesirable
   situation where some operations succeed before one of them fails,
   and after recovering from that error the data is left in an
   inconsistent state.  PL/Python offers a solution to this problem in
   the form of explicit subtransactions.
-->
<xref linkend="plpython-trapping">で説明したデータベースアクセスによって引き起こるエラーからの復旧は、操作の中の１つが失敗する前に、一部の操作が成功し、エラーからの復旧の後一貫性のないデータが残ってしまうという望ましくない状態を導く可能性があります。
PL/Pythonは明示的サブトランザクションにより、この問題の解法を提供します。
  </para>

  <sect2>
<!--
   <title>Subtransaction Context Managers</title>
-->
   <title>サブトランザクションのコンテキスト管理</title>

   <para>
<!--
    Consider a function that implements a transfer between two
    accounts:
-->
2つの口座の間の振替えを実装する関数を考えてみます。
<programlisting>
CREATE FUNCTION transfer_funds() RETURNS void AS $$
try:
    plpy.execute("UPDATE accounts SET balance = balance - 100 WHERE account_name = 'joe'")
    plpy.execute("UPDATE accounts SET balance = balance + 100 WHERE account_name = 'mary'")
except plpy.SPIError, e:
    result = "error transferring funds: %s" % e.args
else:
    result = "funds transferred correctly"
plan = plpy.prepare("INSERT INTO operations (result) VALUES ($1)", ["text"])
plpy.execute(plan, [result])
$$ LANGUAGE plpythonu;
</programlisting>
<!--
    If the second <literal>UPDATE</literal> statement results in an
    exception being raised, this function will report the error, but
    the result of the first <literal>UPDATE</literal> will
    nevertheless be committed.  In other words, the funds will be
    withdrawn from Joe's account, but will not be transferred to
    Mary's account.
-->
2番目の<literal>UPDATE</literal>文が例外を発生させる結果となった場合、この関数はエラーを記録しますが、それにもかかわらず最初の<literal>UPDATE</literal>はコミットされます。
言い換えると、資金はジョーの口座から引き落とされますが、メアリーの口座には移転しません。
   </para>

   <para>
<!--
    To avoid such issues, you can wrap your
    <literal>plpy.execute</literal> calls in an explicit
    subtransaction.  The <literal>plpy</literal> module provides a
    helper object to manage explicit subtransactions that gets created
    with the <literal>plpy.subtransaction()</literal> function.
    Objects created by this function implement the
    <ulink url="http://docs.python.org/library/stdtypes.html#context-manager-types">
    context manager interface</ulink>.  Using explicit subtransactions
    we can rewrite our function as:
-->
こうした問題を防ぐために、<literal>plpy.execute</literal>呼び出しを明示的なサブトランザクションで囲むことができます。
<literal>plpy</literal>モジュールは、<literal>plpy.subtransaction()</literal>関数で作成される明示的なサブトランザクションを管理するための補助オブジェクトを提供します。
この関数によって作成されるオブジェクトは<ulink url="http://docs.python.org/library/stdtypes.html#context-manager-types">コンテキストマネージャインタフェース</ulink>を実装します
明示的なサブトランザクションを使用して、上の関数を以下のように書き換えることができます。
<programlisting>
CREATE FUNCTION transfer_funds2() RETURNS void AS $$
try:
    with plpy.subtransaction():
        plpy.execute("UPDATE accounts SET balance = balance - 100 WHERE account_name = 'joe'")
        plpy.execute("UPDATE accounts SET balance = balance + 100 WHERE account_name = 'mary'")
except plpy.SPIError, e:
    result = "error transferring funds: %s" % e.args
else:
    result = "funds transferred correctly"
plan = plpy.prepare("INSERT INTO operations (result) VALUES ($1)", ["text"])
plpy.execute(plan, [result])
$$ LANGUAGE plpythonu;
</programlisting>
<!--
    Note that the use of <literal>try/catch</literal> is still
    required.  Otherwise the exception would propagate to the top of
    the Python stack and would cause the whole function to abort with
    a <productname>PostgreSQL</productname> error, so that the
    <literal>operations</literal> table would not have any row
    inserted into it.  The subtransaction context manager does not
    trap errors, it only assures that all database operations executed
    inside its scope will be atomically committed or rolled back.  A
    rollback of the subtransaction block occurs on any kind of
    exception exit, not only ones caused by errors originating from
    database access.  A regular Python exception raised inside an
    explicit subtransaction block would also cause the subtransaction
    to be rolled back.
-->
<literal>try/catch</literal>の使用がまだ必要なことに注意してください。
さもないと例外がPythonスタックの最上位まで伝播され、関数全体が<productname>PostgreSQL</productname>エラーにより中断され、この結果、<literal>operations</literal>テーブルには挿入されるはずの行が存在しないことになります。
サブトランザクションのコンテキストマネージャはエラーを捕捉しません。
これはそのスコープの内側で実行されるデータベース操作すべてが、原子的にコミットされるかロールバックされるかだけを保証します。
サブトランザクションブロックのロールバックは、データベースアクセスを元にしたエラーによって引き起こる例外だけではなく、何らかの種類の例外終了でも起こります。
明示的なサブトランザクションブロックの内側で発生した通常のPython例外も同様にサブトランザクションをロールバックさせます。
   </para>
  </sect2>

  <sect2>
<!--
   <title>Older Python Versions</title>
-->
   <title>Pythonの旧式バージョン</title>

   <para>
<!--
    Context managers syntax using the <literal>with</literal> keyword
    is available by default in Python 2.6.  If using PL/Python with an
    older Python version, it is still possible to use explicit
    subtransactions, although not as transparently.  You can call the
    subtransaction manager's <literal>__enter__</literal> and
    <literal>__exit__</literal> functions using the
    <literal>enter</literal> and <literal>exit</literal> convenience
    aliases.  The example function that transfers funds could be
    written as:
-->
デフォルトでは、<literal>with</literal>キーワードを使用したコンテキストマネージャ構文はPython 2.6で利用可能です。
これより古いバージョンのPythonでPL/Pythonを使用する場合でも、透過性がありませんが、明示的なサブトランザクションを使用することができます。
サブトランザクションマネージャの<literal>__enter__</literal>および<literal>__exit__</literal>関数を、<literal>enter</literal>および<literal>exit</literal>という便利な別名を使用して、呼び出すことができます。
資金の振替えを行う関数の例は以下のように記述できます。
<programlisting>
CREATE FUNCTION transfer_funds_old() RETURNS void AS $$
try:
    subxact = plpy.subtransaction()
    subxact.enter()
    try:
        plpy.execute("UPDATE accounts SET balance = balance - 100 WHERE account_name = 'joe'")
        plpy.execute("UPDATE accounts SET balance = balance + 100 WHERE account_name = 'mary'")
    except:
        import sys
        subxact.exit(*sys.exc_info())
        raise
    else:
        subxact.exit(None, None, None)
except plpy.SPIError, e:
    result = "error transferring funds: %s" % e.args
else:
    result = "funds transferred correctly"

plan = plpy.prepare("INSERT INTO operations (result) VALUES ($1)", ["text"])
plpy.execute(plan, [result])
$$ LANGUAGE plpythonu;
</programlisting>
   </para>

   <note>
    <para>
<!--
     Although context managers were implemented in Python 2.5, to use
     the <literal>with</literal> syntax in that version you need to
     use a <ulink
     url="http://docs.python.org/release/2.5/ref/future.html">future
     statement</ulink>.  Because of implementation details, however,
     you cannot use future statements in PL/Python functions.
-->
コンテキストマネージャはPython 2.5で実装されましたが、このバージョンで<literal>with</literal>構文を使用するためには<ulink url="http://docs.python.org/release/2.5/ref/future.html">future文</ulink>を使用する必要があります。
しかし実装上の問題のためPL/Python関数ではfuture文を使用することができません。
    </para>
   </note>
  </sect2>

 </sect1>

 <sect1 id="plpython-util">
<!--
  <title>Utility Functions</title>
-->
  <title>ユーティリティ関数</title>


  <para>
<!--
   The <literal>plpy</literal> module also provides the functions
   <literal>plpy.debug(<replaceable>msg</>)</literal>,
   <literal>plpy.log(<replaceable>msg</>)</literal>,
   <literal>plpy.info(<replaceable>msg</>)</literal>,
   <literal>plpy.notice(<replaceable>msg</>)</literal>,
   <literal>plpy.warning(<replaceable>msg</>)</literal>,
   <literal>plpy.error(<replaceable>msg</>)</literal>, and
   <literal>plpy.fatal(<replaceable>msg</>)</literal>.<indexterm><primary>elog</><secondary>in PL/Python</></indexterm>
   <function>plpy.error</function> and
   <function>plpy.fatal</function> actually raise a Python exception
   which, if uncaught, propagates out to the calling query, causing
   the current transaction or subtransaction to be aborted.
   <literal>raise plpy.Error(<replaceable>msg</>)</literal> and
   <literal>raise plpy.Fatal(<replaceable>msg</>)</literal> are
   equivalent to calling
   <function>plpy.error</function> and
   <function>plpy.fatal</function>, respectively.
   The other functions only generate messages of different
   priority levels.
   Whether messages of a particular priority are reported to the client,
   written to the server log, or both is controlled by the
   <xref linkend="guc-log-min-messages"> and
   <xref linkend="guc-client-min-messages"> configuration
   variables. See <xref linkend="runtime-config"> for more information.
-->
<literal>plpy</literal>では、<literal>plpy.debug(<replaceable>msg</>)</literal>、<literal>plpy.log(<replaceable>msg</>)</literal>、<literal>plpy.info(<replaceable>msg</>)</literal>、<literal>plpy.notice(<replaceable>msg</>)</literal>、<literal>plpy.warning(<replaceable>msg</>)</literal>、<literal>plpy.error(<replaceable>msg</>)</literal>、および<literal>plpy.fatal(<replaceable>msg</>)</literal>関数を提供しています。
<indexterm><primary>elog</><secondary>PL/Pythonにおける</></indexterm>
<function>plpy.error</function>および<function>plpy.fatal</function>は、実際にPythonの例外を発生させます。
これが捕捉されない場合、呼び出し中の問い合わせ外部に伝わり、その結果、現在のトランザクションもしくはサブトランザクションがアボートします。
<literal>raise plpy.Error(<replaceable>msg</>)</literal>および<literal>raise plpy.Fatal(<replaceable>msg</>)</literal>は、それぞれ<function>plpy.error</function>および<function>plpy.fatal</function>の呼び出しと同じです。
他の関数は異なる重要度のメッセージを生成するだけです。
<xref linkend="guc-log-min-messages">と<xref linkend="guc-client-min-messages">設定変数は、特定の重要度のメッセージをクライアントに報告するか、サーバのログに書き出すか、あるいはその両方かを制御します。
詳細は<xref linkend="runtime-config">を参照してください。
  </para>

  <para>
<!--
   Another set of utility functions are
   <literal>plpy.quote_literal(<replaceable>string</>)</literal>,
   <literal>plpy.quote_nullable(<replaceable>string</>)</literal>, and
   <literal>plpy.quote_ident(<replaceable>string</>)</literal>.  They
   are equivalent to the built-in quoting functions described in <xref
   linkend="functions-string">.  They are useful when constructing
   ad-hoc queries.  A PL/Python equivalent of dynamic SQL from <xref
   linkend="plpgsql-quote-literal-example"> would be:
-->
この他のユーティリティ関数群には<literal>plpy.quote_literal(<replaceable>string</>)</literal>、<literal>plpy.quote_nullable(<replaceable>string</>)</literal>および<literal>plpy.quote_ident(<replaceable>string</>)</literal>があります。
これらは<xref linkend="functions-string">で説明する組込みの引用符付け関数と同等です。
これらはその場限りの問い合わせを構築する時に有用です。
<xref linkend="plpgsql-quote-literal-example">の動的SQLと同等なPL/Pythonを以下に示します。
<programlisting>
plpy.execute("UPDATE tbl SET %s = %s WHERE key = %s" % (
    plpy.quote_ident(colname),
    plpy.quote_nullable(newvalue),
    plpy.quote_literal(keyvalue)))
</programlisting>
  </para>
 </sect1>

 <sect1 id="plpython-envar">
<!--
  <title>Environment Variables</title>
-->
  <title>環境変数</title>

  <para>
<!--
   Some of the environment variables that are accepted by the Python
   interpreter can also be used to affect PL/Python behavior.  They
   would need to be set in the environment of the main PostgreSQL
   server process, for example in a start script.  The available
   environment variables depend on the version of Python; see the
   Python documentation for details.  At the time of this writing, the
   following environment variables have an affect on PL/Python,
   assuming an adequate Python version:
-->
Pythonインタプリタにより受け付けられる環境変数の一部はまた、PL/Pythonの動作を変更するために使用することができます。
これらは例えば起動スクリプト内など主PostgreSQLサーバプロセスの環境で設定される必要があります。
利用可能な環境変数はPythonのバージョンに依存します。
詳細に付いてはPythonの文書を参照してください。
適切なバージョンのPythonであることが前提ですが、本章の執筆時点では以下の環境変数がPL/Pythonに影響を与えます。
   <itemizedlist>
    <listitem>
     <para><envar>PYTHONHOME</envar></para>
    </listitem>

    <listitem>
     <para><envar>PYTHONPATH</envar></para>
    </listitem>

    <listitem>
     <para><envar>PYTHONY2K</envar></para>
    </listitem>

    <listitem>
     <para><envar>PYTHONOPTIMIZE</envar></para>
    </listitem>

    <listitem>
     <para><envar>PYTHONDEBUG</envar></para>
    </listitem>

    <listitem>
     <para><envar>PYTHONVERBOSE</envar></para>
    </listitem>

    <listitem>
     <para><envar>PYTHONCASEOK</envar></para>
    </listitem>

    <listitem>
     <para><envar>PYTHONDONTWRITEBYTECODE</envar></para>
    </listitem>

    <listitem>
     <para><envar>PYTHONIOENCODING</envar></para>
    </listitem>

    <listitem>
     <para><envar>PYTHONUSERBASE</envar></para>
    </listitem>

    <listitem>
     <para><envar>PYTHONHASHSEED</envar></para>
    </listitem>
   </itemizedlist>

<!--
   (It appears to be a Python implementation detail beyond the control
   of PL/Python that some of the environment variables listed on
   the <command>python</command> man page are only effective in a
   command-line interpreter and not an embedded Python interpreter.)
-->
（<command>python</command>マニュアルページに列挙された環境変数の一部はコマンドラインインタプリタでのみ影響を与え埋め込みPythonインタプリタには影響しないというPL/Pythonの制御を超えたPythonの詳細実装があるようです。）
  </para>
 </sect1>
</chapter>
