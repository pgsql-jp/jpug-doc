<!-- doc/src/sgml/trigger.sgml -->

 <chapter id="triggers">
<!--
  <title>Triggers</title>
-->
<title>トリガ</title>

  <indexterm zone="triggers">
<!--
   <primary>trigger</primary>
-->
   <primary>トリガ</primary>
  </indexterm>

  <para>
<!--
   This chapter provides general information about writing trigger functions.
   Trigger functions can be written in most of the available procedural
   languages, including
   <application>PL/pgSQL</application> (<xref linkend="plpgsql">),
   <application>PL/Tcl</application> (<xref linkend="pltcl">),
   <application>PL/Perl</application> (<xref linkend="plperl">), and
   <application>PL/Python</application> (<xref linkend="plpython">).
   After reading this chapter, you should consult the chapter for
   your favorite procedural language to find out the language-specific
   details of writing a trigger in it.
-->
本章ではトリガ関数の作成に関する一般的な情報を示します。
トリガ関数は、<application>PL/pgSQL</application> (<xref linkend="plpgsql">)、<application>PL/Tcl</application> (<xref linkend="pltcl">)、<application>PL/Perl</application> (<xref linkend="plperl">)、<application>PL/Python</application> (<xref linkend="plpython">)など、利用可能な手続き言語のほとんどで作成することができます。
本章を読んだ後、好みの手続き言語に関する章を参照して、トリガ作成に関する言語特有の詳細を確認すべきです。
  </para>

  <para>
<!--
   It is also possible to write a trigger function in C, although
   most people find it easier to use one of the procedural languages.
   It is not currently possible to write a trigger function in the
   plain SQL function language.
-->
また、C言語でトリガ関数を作成することができます。
しかし、ほとんどの方は、手続き言語のいずれかで作成する方が簡単であることに気づくでしょう。
現時点では、普通のSQL関数言語ではトリガ関数を作成することはできません。
  </para>

  <sect1 id="trigger-definition">
<!--
   <title>Overview of Trigger Behavior</title>
-->
   <title>トリガ動作の概要</title>

   <para>
<!--
    A trigger is a specification that the database should automatically
    execute a particular function whenever a certain type of operation is
    performed.  Triggers can be attached to tables, views, and foreign tables.
-->
トリガとは、データベースが、ある特定の操作が行われた時に常に自動的に実行しなければならない特定の機能に関する規定です。
トリガはテーブル、ビュー、外部テーブルに付与することができます。
  </para>

  <para>
<!--
    On tables and foreign tables, triggers can be defined to execute either
    before or after any <command>INSERT</command>, <command>UPDATE</command>,
    or <command>DELETE</command> operation, either once per modified row,
    or once per <acronym>SQL</acronym> statement.
    <command>UPDATE</command> triggers can moreover be set to fire only if
    certain columns are mentioned in the <literal>SET</literal> clause of the
    <command>UPDATE</command> statement.
    Triggers can also fire for <command>TRUNCATE</command> statements.
    If a trigger event occurs, the trigger's function is called at the
    appropriate time to handle the event.  Foreign tables do not support the
    TRUNCATE statement at all.
-->
テーブルおよび外部テーブル上では、トリガを<command>INSERT</command>、<command>UPDATE</command>または<command>DELETE</command>操作の前後に、行を変更する度、あるいは<acronym>SQL</acronym>文ごとに実行するように定義することができます。
<command>UPDATE</command>トリガについては、特定のカラムが<command>UPDATE</command>文の<literal>SET</literal>句の対象になった時のみ発動するよう設定することができます。また、トリガは<command>TRUNCATE</command>文についても実行できます。
トリガイベントが起こると、トリガ関数がそのイベントを扱う適切な時点で呼び出されます。
外部テーブルはTRUNCATEを全くサポートしません。
   </para>

   <para>
<!--
    On views, triggers can be defined to execute instead of
    <command>INSERT</command>, <command>UPDATE</command>, or
    <command>DELETE</command> operations.  <literal>INSTEAD OF</> triggers
    are fired once for each row that needs to be modified in the view.
    It is the responsibility of the
    trigger's function to perform the necessary modifications to the
    underlying base tables and, where appropriate, return the modified
    row as it will appear in the view.  Triggers on views can also be defined
    to execute once per <acronym>SQL</acronym> statement, before or after
    <command>INSERT</command>, <command>UPDATE</command>, or
    <command>DELETE</command> operations.
-->
ビュー上では、トリガを<command>INSERT</command>、<command>UPDATE</command>または<command>DELETE</command>操作の代わりに実行するものとして定義できます。<literal>INSTEAD OF</>トリガは、ビュー内の変更を行うために必要となる行それぞれに対して一度発行されます。
元になっているテーブルへの必要な変更の実施、そして必要に応じて、ビュー上で見えるであろう変更された行を返却するのは、トリガ関数の責任です。ビューへのトリガは、<acronym>SQL</acronym>文ごとに、<command>INSERT</command>、<command>UPDATE</command>または<command>DELETE</command>操作の前後で実行させるよう定義することができます。
   </para>

   <para>
<!--
    The trigger function must be defined before the trigger itself can be
    created.  The trigger function must be declared as a
    function taking no arguments and returning type <literal>trigger</>.
    (The trigger function receives its input through a specially-passed
    <structname>TriggerData</> structure, not in the form of ordinary function
    arguments.)
-->
トリガ関数は、トリガ自体が作成される前までに定義しておく必要があります。
トリガ関数は、引数を取らない、<literal>trigger</>型を返す関数として宣言される必要があります
（トリガ関数は、通常の関数で使用される引数という形ではなく、<structname>TriggerData</>構造体で入力を受け取ります）。
   </para>

   <para>
<!--
    Once a suitable trigger function has been created, the trigger is
    established with
    <xref linkend="sql-createtrigger">.
    The same trigger function can be used for multiple triggers.
-->
適切なトリガ関数が作成されると、<xref linkend="sql-createtrigger">を使用してトリガを構築することができます。
同一のトリガ関数を複数のトリガに使用することができます。
   </para>

   <para>
<!--
    <productname>PostgreSQL</productname> offers both <firstterm>per-row</>
    triggers and <firstterm>per-statement</> triggers.  With a per-row
    trigger, the trigger function
    is invoked once for each row that is affected by the statement
    that fired the trigger. In contrast, a per-statement trigger is
    invoked only once when an appropriate statement is executed,
    regardless of the number of rows affected by that statement. In
    particular, a statement that affects zero rows will still result
    in the execution of any applicable per-statement triggers. These
    two types of triggers are sometimes called <firstterm>row-level</>
    triggers and <firstterm>statement-level</> triggers,
    respectively. Triggers on <command>TRUNCATE</command> may only be
    defined at statement level.  On views, triggers that fire before or
    after may only be defined at statement level, while triggers that fire
    instead of an <command>INSERT</command>, <command>UPDATE</command>,
    or <command>DELETE</command> may only be defined at row level.
-->
<productname>PostgreSQL</productname>は、<firstterm>行単位の</>トリガと<firstterm>文単位の</>トリガの両方を提供します。
行単位のトリガでは、トリガを発行した文によって影響を受ける行ごとにトリガ関数が呼び出されます。
反対に、文単位のトリガでは、適切な文が実行された時に、その文で何行が影響を受けたかどうかは関係なく、一度だけ呼び出されます。
特に、行に影響を与えない文であっても、適切な文単位のトリガがあれば実行されます。
この2種類のトリガはそれぞれ<firstterm>行レベル</>トリガと<firstterm>文レベル</>トリガと呼ばれることがあります。<command>TRUNCATE</command>に対するトリガは文レベルトリガのみに定義することができます。
ビューでは、文レベルでのみ、処理の前後での実行をするよう定義することができるでしょう。一方、<command>INSERT</command>、<command>UPDATE</command>または<command>DELETE</command>の代わりに実行するトリガは行レベルでのみ定義できるでしょう。
   </para>

   <para>
<!--
    Triggers are also classified according to whether they fire
    <firstterm>before</>, <firstterm>after</>, or
    <firstterm>instead of</> the operation. These are referred to
    as <literal>BEFORE</> triggers, <literal>AFTER</> triggers, and
    <literal>INSTEAD OF</> triggers respectively.
    Statement-level <literal>BEFORE</> triggers naturally fire before the
    statement starts to do anything, while statement-level <literal>AFTER</>
    triggers fire at the very end of the statement.  These types of
    triggers may be defined on tables or views.  Row-level <literal>BEFORE</>
    triggers fire immediately before a particular row is operated on,
    while row-level <literal>AFTER</> triggers fire at the end of the
    statement (but before any statement-level <literal>AFTER</> triggers).
    These types of triggers may only be defined on tables and foreign tables.
    Row-level <literal>INSTEAD OF</> triggers may only be defined on views,
    and fire immediately as each row in the view is identified as needing to
    be operated on.
-->
また、トリガはそれらが操作の<firstterm>前</>、<firstterm>後</>または<firstterm>代わり</>のどれで実行されるかに応じて分けられます。
これらはそれぞれ<literal>BEFORE</>トリガ、<literal>AFTER</>トリガ、そして<literal>INSTEAD OF</>トリガと呼ばれます。
文レベルの<literal>BEFORE</>トリガは、もちろん文が何かを始める前に発行され、文レベルの<literal>AFTER</>トリガは文の本当に最後に発行されます。
これらのタイプのトリガはテーブルまたはビューで定義されるでしょう。
行レベルの<literal>BEFORE</>トリガは、特定の行が操作される直前に発行され、行レベルの<literal>AFTER</>トリガは文の終わり（ただし、全ての文レベルの<literal>AFTER</>トリガの前）に発行されます。
これらのタイプのトリガはテーブルと外部テーブルにのみ定義されるでしょう。
行レベルの<literal>INSTEAD OF</>トリガはビューにのみ定義され、ビュー上の行ごとに操作が必要と判断された場合に即座に発行されます。
   </para>

   <para>
<!--
    Trigger functions invoked by per-statement triggers should always
    return <symbol>NULL</symbol>. Trigger functions invoked by per-row
    triggers can return a table row (a value of
    type <structname>HeapTuple</structname>) to the calling executor,
    if they choose.  A row-level trigger fired before an operation has
    the following choices:
-->
文単位のトリガによって呼び出されるトリガ関数は常に<symbol>NULL</symbol>を返さなければなりません。
行単位のトリガによって呼び出されるトリガ関数は呼び出し元のエクゼキュータにテーブル行（<structname>HeapTuple</structname>型の値）を返すように選択することができます。
操作前に発行された行レベルのトリガでは以下の選択肢があります。

    <itemizedlist>
     <listitem>
      <para>
<!--
       It can return <symbol>NULL</> to skip the operation for the
       current row. This instructs the executor to not perform the
       row-level operation that invoked the trigger (the insertion,
       modification, or deletion of a particular table row).
-->
<symbol>NULL</>を返して、現在の行への操作を飛ばすことができます。
これは、エクゼキュータにトリガの元になった行レベルの操作（特定のテーブル行の挿入、更新、削除）を行わないよう指示します。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       For row-level <command>INSERT</command>
       and <command>UPDATE</command> triggers only, the returned row
       becomes the row that will be inserted or will replace the row
       being updated.  This allows the trigger function to modify the
       row being inserted or updated.
-->
行レベルの<command>INSERT</command>および<command>UPDATE</command>トリガの場合のみ、返される行が挿入される、もしくは実際に更新される行になります。
これにより、トリガ関数で、挿入される行もしくは更新される行を変更することができます。
      </para>
     </listitem>
    </itemizedlist>

<!--
    A row-level <literal>BEFORE</> trigger that does not intend to cause
    either of these behaviors must be careful to return as its result the same
    row that was passed in (that is, the <varname>NEW</varname> row
    for <command>INSERT</command> and <command>UPDATE</command>
    triggers, the <varname>OLD</varname> row for
    <command>DELETE</command> triggers).
-->
これらの動作をさせたくない行レベルの<literal>BEFORE</>トリガについては、渡された行（つまり、<command>INSERT</command>および<command>UPDATE</command>トリガでは<varname>NEW</varname>行、<command>DELETE</command>の場合は<varname>OLD</varname>行）と同じ行結果を返すように気を付ける必要があります。
   </para>

   <para>
<!--
    A row-level <literal>INSTEAD OF</> trigger should either return
    <symbol>NULL</> to indicate that it did not modify any data from
    the view's underlying base tables, or it should return the view
    row that was passed in (the <varname>NEW</varname> row
    for <command>INSERT</command> and <command>UPDATE</command>
    operations, or the <varname>OLD</varname> row for
    <command>DELETE</command> operations). A nonnull return value is
    used to signal that the trigger performed the necessary data
    modifications in the view.  This will cause the count of the number
    of rows affected by the command to be incremented. For
    <command>INSERT</> and <command>UPDATE</> operations, the trigger
    may modify the <varname>NEW</> row before returning it.  This will
    change the data returned by
    <command>INSERT RETURNING</> or <command>UPDATE RETURNING</>,
    and is useful when the view will not show exactly the same data
    that was provided.
-->
行レベルの<literal>INSTEAD OF</>トリガは、ビューの元となった元テーブルのデータをまったく変更しないことを表す<symbol>NULL</>、または、渡されたビューの行（<command>INSERT</command>と<command>UPDATE</command>操作の場合<varname>NEW</varname>行、<command>DELETE</command>操作の場合<varname>OLD</varname>行）を返さなければなりません。
非NULLの戻り値は、そのトリガがビューにおいて必要なデータ変更を実行したことを通知するために使用されます。
これにより影響を受けた行数を数えるカウンタは増加されます。
<command>INSERT</>と<command>UPDATE</>操作では、トリガは戻す前に<varname>NEW</>行を変更することができます。
これは<command>INSERT RETURNING</>または<command>UPDATE RETURNING</>で返されるデータを変更しますので、ビューが提供されたデータと正確に同じ結果を返さない場合に有益です。
   </para>

   <para>
<!--
    The return value is ignored for row-level triggers fired after an
    operation, and so they can return <symbol>NULL</>.
-->
操作の後に発生する行レベルトリガでは戻り値は無視されますので、これらは<symbol>NULL</>を返すことができます。
   </para>

   <para>
<!--
    If more than one trigger is defined for the same event on the same
    relation, the triggers will be fired in alphabetical order by
    trigger name.  In the case of <literal>BEFORE</> and
    <literal>INSTEAD OF</> triggers, the possibly-modified row returned by
    each trigger becomes the input to the next trigger.  If any
    <literal>BEFORE</> or <literal>INSTEAD OF</> trigger returns
    <symbol>NULL</>, the operation is abandoned for that row and subsequent
    triggers are not fired (for that row).
-->
同一リレーション、同一イベントに対して1つ以上のトリガが定義された場合、トリガはその名前のアルファベット順に発生します。
<literal>BEFORE</>トリガと<literal>INSTEAD OF</>トリガの場合では、各トリガで返される、変更された可能性がある行が次のトリガの入力となります。
もし、ある<literal>BEFORE</>トリガや<literal>INSTEAD OF</>トリガが<symbol>NULL</>を返したら、(いまのところ)操作はその行で中断し、残りのトリガは発生しません。
   </para>

   <para>
<!--
    A trigger definition can also specify a Boolean <literal>WHEN</>
    condition, which will be tested to see whether the trigger should
    be fired.  In row-level triggers the <literal>WHEN</> condition can
    examine the old and/or new values of columns of the row.  (Statement-level
    triggers can also have <literal>WHEN</> conditions, although the feature
    is not so useful for them.)  In a <literal>BEFORE</> trigger, the
    <literal>WHEN</>
    condition is evaluated just before the function is or would be executed,
    so using <literal>WHEN</> is not materially different from testing the
    same condition at the beginning of the trigger function.  However, in
    an <literal>AFTER</> trigger, the <literal>WHEN</> condition is evaluated
    just after the row update occurs, and it determines whether an event is
    queued to fire the trigger at the end of statement.  So when an
    <literal>AFTER</> trigger's
    <literal>WHEN</> condition does not return true, it is not necessary
    to queue an event nor to re-fetch the row at end of statement.  This
    can result in significant speedups in statements that modify many
    rows, if the trigger only needs to be fired for a few of the rows.
    <literal>INSTEAD OF</> triggers do not support
    <literal>WHEN</> conditions.
-->
トリガ定義は、トリガを発動するかどうかを<literal>WHEN</>句の論理条件で指定することも可能です。行レベルトリガにおいて、<literal>WHEN</>条件は行の列の古い値と(あるいは)新しい値を検索することができます。(あまり有用ではありませんが、文レベルトリガでも<literal>WHEN</>条件で同じことができます。)<literal>BEFORE</>トリガでは、実質的にトリガ関数の開始時と同じ条件で検査できるように、<literal>WHEN</>条件の評価が関数の実施直前になされます。しかし<literal>AFTER</>トリガでは、<literal>WHEN</>条件の評価は行の更新直後に行われ、文の終わり(コミット時)にトリガを発動するためのイベントを待ち行列に入れるかどうかを決めます。そのため、ある<literal>AFTER</>トリガの<literal>WHEN</>条件が真を返さなかった場合は、イベントを待ち行列に入れる必要も文の終わりに行を再取得する必要もありません。これは、大量の行の変更が発生するけれども、トリガがその内の少数の行に対してのみ発動させる必要がある、といった文の処理速度を大幅に上げる効果があります。<literal>INSTEAD OF</>トリガは<literal>WHEN</>条件をサポートしていません。
   </para>

   <para>
<!--
    Typically, row-level <literal>BEFORE</> triggers are used for checking or
    modifying the data that will be inserted or updated.  For example,
    a <literal>BEFORE</> trigger might be used to insert the current time into a
    <type>timestamp</type> column, or to check that two elements of the row are
    consistent. Row-level <literal>AFTER</> triggers are most sensibly
    used to propagate the updates to other tables, or make consistency
    checks against other tables.  The reason for this division of labor is
    that an <literal>AFTER</> trigger can be certain it is seeing the final
    value of the row, while a <literal>BEFORE</> trigger cannot; there might
    be other <literal>BEFORE</> triggers firing after it.  If you have no
    specific reason to make a trigger <literal>BEFORE</> or
    <literal>AFTER</>, the <literal>BEFORE</> case is more efficient, since
    the information about
    the operation doesn't have to be saved until end of statement.
-->
通常、行レベルの<literal>BEFORE</>トリガは、挿入あるいは更新される予定のデータの検査や変更のために使用されます。
例えば、<literal>BEFORE</>トリガは、<type>timestamp</type>型の列に現在時刻を挿入するために、あるいは行の2つの要素の整合性を検査するために使用される可能性があります。
行レベルの<literal>AFTER</>トリガは、ほとんど常識的に他のテーブルに更新を伝播させるために、あるいは他のテーブルとの整合性を検査するために使用されます。
こうした仕事の切り分け理由は、<literal>AFTER</>トリガは行の最終値を見ることができ、<literal>BEFORE</>トリガは見ることができないという点です。
トリガを<literal>BEFORE</>にするか<literal>AFTER</>にするかを決める時に特別な理由がないのであれば、操作の情報を行が終わるまで保持する必要がない分、<literal>BEFORE</>を使う方が効率的です。
   </para>

   <para>
<!--
    If a trigger function executes SQL commands then these
    commands might fire triggers again. This is known as cascading
    triggers.  There is no direct limitation on the number of cascade
    levels.  It is possible for cascades to cause a recursive invocation
    of the same trigger; for example, an <command>INSERT</command>
    trigger might execute a command that inserts an additional row
    into the same table, causing the <command>INSERT</command> trigger
    to be fired again.  It is the trigger programmer's responsibility
    to avoid infinite recursion in such scenarios.
-->
トリガ関数がSQLコマンドを処理する場合、これらの問い合わせがトリガを再度発行することがあります。
これはカスケードされたトリガと呼ばれます。
カスケードの段数に直接的な制限はありません。
カスケードの場合、同じトリガを再帰的に呼び出すことが可能です。
例えば、<command>INSERT</command>トリガで同じテーブルに追加の行を挿入する問い合わせが実行された場合、その結果として<command>INSERT</command>トリガが再度発行されます。
こうした状況で無限再帰を防ぐのは、トリガプログラマの責任です。
   </para>

   <para>
    <indexterm>
<!--
     <primary>trigger</>
     <secondary>arguments for trigger functions</>
-->
     <primary>トリガ</>
     <secondary>トリガ関数の引数</>
    </indexterm>
<!--
    When a trigger is being defined, arguments can be specified for
    it. The purpose of including arguments in the
    trigger definition is to allow different triggers with similar
    requirements to call the same function.  As an example, there
    could be a generalized trigger function that takes as its
    arguments two column names and puts the current user in one and
    the current time stamp in the other.  Properly written, this
    trigger function would be independent of the specific table it is
    triggering on.  So the same function could be used for
    <command>INSERT</command> events on any table with suitable
    columns, to automatically track creation of records in a
    transaction table for example. It could also be used to track
    last-update events if defined as an <command>UPDATE</command>
    trigger.
-->
トリガを定義する時、そのトリガ用の引数を指定することができます。
トリガ定義に引数を含めた目的は、似たような要求の異なるトリガに同じ関数を呼び出すことができるようにすることです。
例えば、2つの列名を引数とし、片方に現在のユーザをもう片方に現在のタイムスタンプを取る、汎化トリガ関数があるとします。
適切に作成すれば、この関数が特定のトリガの発行元となるテーブルに依存することはなくなります。
同じ関数を使用して、例えば、トランザクションテーブルに作成記録を自動的に登録させるために、適切な列を持つ任意のテーブルの<command>INSERT</command>イベントに使用することができます。
また、<command>UPDATE</command>として定義すれば、最終更新イベントを追跡するために使用することも可能です。
   </para>

   <para>
<!--
    Each programming language that supports triggers has its own method
    for making the trigger input data available to the trigger function.
    This input data includes the type of trigger event (e.g.,
    <command>INSERT</command> or <command>UPDATE</command>) as well as any
    arguments that were listed in <command>CREATE TRIGGER</>.
    For a row-level trigger, the input data also includes the
    <varname>NEW</varname> row for <command>INSERT</command> and
    <command>UPDATE</command> triggers, and/or the <varname>OLD</varname> row
    for <command>UPDATE</command> and <command>DELETE</command> triggers.
    Statement-level triggers do not currently have any way to examine the
    individual row(s) modified by the statement.
-->
トリガをサポートするプログラミング言語はそれぞれ独自の方法で、トリガ関数で利用できるトリガの入力データを作成します。
この入力データにはトリガイベント種類（例えば<command>INSERT</command>や<command>UPDATE</command>など、<command>CREATE TRIGGER</>で指定された全ての引数）が含まれます。
行レベルトリガの入力データには、<command>INSERT</command>および<command>UPDATE</command>トリガの場合は<varname>NEW</varname>行が、<command>UPDATE</command>および<command>DELETE</command>トリガの場合は<varname>OLD</varname>行が含まれます。
文レベルトリガには現在、文によって変更される個々の行を検査するための手段がありません。
   </para>

  </sect1>

  <sect1 id="trigger-datachanges">
<!--
   <title>Visibility of Data Changes</title>
-->
   <title>データ変更の可視性</title>

   <para>
<!--
    If you execute SQL commands in your trigger function, and these
    commands access the table that the trigger is for, then
    you need to be aware of the data visibility rules, because they determine
    whether these SQL commands will see the data change that the trigger
    is fired for.  Briefly:
-->
トリガ関数内でSQLコマンドを実行し、このコマンドがトリガの元となったテーブルにアクセスする場合、データの可視性規則に注意する必要があります。
この規則が、SQLコマンドがトリガの発行原因となったデータ変更を見ることができるかどうかを決定するからです。
簡単に以下に示します。

    <itemizedlist>

     <listitem>
      <para>
<!--
       Statement-level triggers follow simple visibility rules: none of
       the changes made by a statement are visible to statement-level
       triggers that are invoked before the statement, whereas all
       modifications are visible to statement-level <literal>AFTER</>
       triggers.
-->
文レベルトリガは次に示す簡単な可視性規則に従います。
文によってなされた変更は、文の前に呼び出される文レベルトリガでは不可視です。
一方、文レベルの<literal>AFTER</>トリガでは全ての変更が可視です。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       The data change (insertion, update, or deletion) causing the
       trigger to fire is naturally <emphasis>not</emphasis> visible
       to SQL commands executed in a row-level <literal>BEFORE</> trigger,
       because it hasn't happened yet.
-->
当然ながら行レベルの<literal>BEFORE</>トリガ内のSQLコマンドでは、トリガの発生原因となったデータ変更（挿入、更新、削除）はまだ発生していませんので、可視<emphasis>ではありません</emphasis>。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       However, SQL commands executed in a row-level <literal>BEFORE</>
       trigger <emphasis>will</emphasis> see the effects of data
       changes for rows previously processed in the same outer
       command.  This requires caution, since the ordering of these
       change events is not in general predictable; a SQL command that
       affects multiple rows can visit the rows in any order.
-->
しかし、行レベルの<literal>BEFORE</>トリガで実行されるSQLコマンドは、その外側のコマンドで以前に処理された行へのデータ変更の影響を見る<emphasis>ことになるでしょう</emphasis>。
これらの変更イベントの順序は一般的に予測できませんので、注意が必要です。
複数行に影響するSQLコマンドはどのような順番でもその行を更新することができます。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       Similarly, a row-level <literal>INSTEAD OF</> trigger will see the
       effects of data changes made by previous firings of <literal>INSTEAD
       OF</> triggers in the same outer command.
-->
同様に、行レベルの<literal>INSTEAD OF</>トリガは、同じ外側のコマンドで以前に処理された<literal>INSTEAD OF</>トリガよる変更結果を見ることになるでしょう。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       When a row-level <literal>AFTER</> trigger is fired, all data
       changes made
       by the outer command are already complete, and are visible to
       the invoked trigger function.
-->
行レベルの<literal>AFTER</>トリガが発生すると、その外側のコマンドによってなされた全ての変更は既に完了していますので、呼び出されたトリガ関数から可視になります。
      </para>
     </listitem>
    </itemizedlist>
   </para>

   <para>
<!--
    If your trigger function is written in any of the standard procedural
    languages, then the above statements apply only if the function is
    declared <literal>VOLATILE</>.  Functions that are declared
    <literal>STABLE</> or <literal>IMMUTABLE</> will not see changes made by
    the calling command in any case.
-->
もし、あなたのトリガが標準的な手続き型言語のいずれかで記述されている時、上記の可視性は関数が<literal>VOLATILE</>で定義されている場合のみ適用されます。
<literal>STABLE</>、もしくは<literal>IMMUTABLE</>で定義されている関数は、どのようなケースにおいても、呼び出しコマンドによる変更は見ないでしょう。
   </para>

   <para>
<!--
    Further information about data visibility rules can be found in
    <xref linkend="spi-visibility">.  The example in <xref
    linkend="trigger-example"> contains a demonstration of these rules.
-->
データ可視性規則に関する詳細は<xref linkend="spi-visibility">にあります。
<xref linkend="trigger-example">の例にこの規則を示します。
   </para>
  </sect1>

  <sect1 id="trigger-interface">
<!--
   <title>Writing Trigger Functions in C</title>
-->
   <title>Cによるトリガ関数の作成</title>

   <indexterm zone="trigger-interface">
<!--
    <primary>trigger</primary>
    <secondary>in C</secondary>
-->
    <primary>トリガ</primary>
    <secondary>Cによる</secondary>
   </indexterm>

   <para>
<!--
    This section describes the low-level details of the interface to a
    trigger function.  This information is only needed when writing
    trigger functions in C.  If you are using a higher-level language then
    these details are handled for you.  In most cases you should consider
    using a procedural language before writing your triggers in C.  The
    documentation of each procedural language explains how to write a
    trigger in that language.
-->
本節ではトリガ関数とのインタフェースについて低レベルな詳細を説明します。
この情報はC言語でトリガ関数を作成する時にのみ必要です。
高レベルな言語で作成すれば、こうした詳細は代わりに扱ってもらえます。
たいていの場合、Cでトリガを作成する前に手続き言語を使用することを検討すべきです。
各手続き言語の文書で、その言語を使用したトリガの作成方法を説明します。
   </para>

   <para>
<!--
    Trigger functions must use the <quote>version 1</> function manager
    interface.
-->
トリガ関数は<quote>version 1</>関数マネージャインタフェースを使わなくてはいけません。
   </para>

   <para>
<!--
    When a function is called by the trigger manager, it is not passed
    any normal arguments, but it is passed a <quote>context</>
    pointer pointing to a <structname>TriggerData</> structure.  C
    functions can check whether they were called from the trigger
    manager or not by executing the macro:
-->
関数がトリガマネージャから呼び出される時は、通常の引数が渡されるのではなく、<structname>TriggerData</>構造体を指す<quote>context</>ポインタが渡されます。
C関数は、トリガマネージャから呼び出されたのかどうかを以下のマクロを実行することで検査することができます。
<programlisting>
CALLED_AS_TRIGGER(fcinfo)
</programlisting>
<!--
    which expands to:
-->
これは以下に展開されます。
<programlisting>
((fcinfo)-&gt;context != NULL &amp;&amp; IsA((fcinfo)-&gt;context, TriggerData))
</programlisting>
<!--
    If this returns true, then it is safe to cast
    <literal>fcinfo-&gt;context</> to type <literal>TriggerData
    *</literal> and make use of the pointed-to
    <structname>TriggerData</> structure.  The function must
    <emphasis>not</emphasis> alter the <structname>TriggerData</>
    structure or any of the data it points to.
-->
もしこれが真を返す場合、<literal>fcinfo-&gt;context</>を<literal>TriggerData *</literal>型にキャストし、指された<structname>TriggerData</>構造体を使用することは安全です。
その関数は、<structname>TriggerData</>構造体やそれが指すどのようなデータも変更しては<emphasis>いけません</emphasis>。
   </para>

   <para>
<!--
    <structname>struct TriggerData</structname> is defined in
    <filename>commands/trigger.h</filename>:
-->
<structname>struct TriggerData</structname>は<filename>commands/trigger.h</filename>の中で定義されています。

<programlisting>
typedef struct TriggerData
{
    NodeTag       type;
    TriggerEvent  tg_event;
    Relation      tg_relation;
    HeapTuple     tg_trigtuple;
    HeapTuple     tg_newtuple;
    Trigger      *tg_trigger;
    Buffer        tg_trigtuplebuf;
    Buffer        tg_newtuplebuf;
} TriggerData;
</programlisting>

<!--
    where the members are defined as follows:
-->
メンバは下記のように定義されています。

    <variablelist>
     <varlistentry>
      <term><structfield>type</></term>
      <listitem>
       <para>
<!--
        Always <literal>T_TriggerData</literal>.
-->
常に<literal>T_TriggerData</literal>です。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><structfield>tg_event</></term>
      <listitem>
       <para>
<!--
        Describes the event for which the function is called. You can use the
        following macros to examine <literal>tg_event</literal>:
-->
その関数が呼び出されたイベントを記述します。
<literal>tg_event</literal>を調べるためには下記のマクロを使うことができます。

        <variablelist>
         <varlistentry>
          <term><literal>TRIGGER_FIRED_BEFORE(tg_event)</literal></term>
          <listitem>
           <para>
<!--
            Returns true if the trigger fired before the operation.
-->
トリガが操作の前に(before)発行された場合真を返します。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>TRIGGER_FIRED_AFTER(tg_event)</literal></term>
          <listitem>
           <para>
<!--
            Returns true if the trigger fired after the operation.
-->
トリガが操作の後に(after)発行された場合真を返します。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>TRIGGER_FIRED_INSTEAD(tg_event)</literal></term>
          <listitem>
           <para>
<!--
            Returns true if the trigger fired instead of the operation.
-->
トリガがINSTEAD OFで発行された場合真を返します。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>TRIGGER_FIRED_FOR_ROW(tg_event)</literal></term>
          <listitem>
           <para>
<!--
            Returns true if the trigger fired for a row-level event.
-->
トリガが行レベルのイベントで発行された場合真を返します。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>TRIGGER_FIRED_FOR_STATEMENT(tg_event)</literal></term>
          <listitem>
           <para>
<!--
            Returns true if the trigger fired for a statement-level event.
-->
トリガが文レベルのイベントで発行された場合真を返します。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>TRIGGER_FIRED_BY_INSERT(tg_event)</literal></term>
          <listitem>
           <para>
<!--
            Returns true if the trigger was fired by an <command>INSERT</command> command.
-->
トリガが<command>INSERT</command>コマンドで発行された場合真を返します。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>TRIGGER_FIRED_BY_UPDATE(tg_event)</literal></term>
          <listitem>
           <para>
<!--
            Returns true if the trigger was fired by an <command>UPDATE</command> command.
-->
トリガが<command>UPDATE</command>コマンドで発行された場合真を返します。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>TRIGGER_FIRED_BY_DELETE(tg_event)</literal></term>
          <listitem>
           <para>
<!--
            Returns true if the trigger was fired by a <command>DELETE</command> command.
-->
トリガが<command>DELETE</command>コマンドで発行された場合真を返します。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>TRIGGER_FIRED_BY_TRUNCATE(tg_event)</literal></term>
          <listitem>
           <para>
<!--
            Returns true if the trigger was fired by a <command>TRUNCATE</command> command.
-->
トリガが<command>TRUNCATE</command>コマンドで発行された場合真を返します。
           </para>
          </listitem>
         </varlistentry>
        </variablelist>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><structfield>tg_relation</></term>
      <listitem>
       <para>
<!--
        A pointer to a structure describing the relation that the trigger fired for.
        Look at <filename>utils/rel.h</> for details about
        this structure.  The most interesting things are
        <literal>tg_relation-&gt;rd_att</> (descriptor of the relation
        tuples) and <literal>tg_relation-&gt;rd_rel-&gt;relname</>
        (relation name; the type is not <type>char*</> but
        <type>NameData</>; use
        <literal>SPI_getrelname(tg_relation)</> to get a <type>char*</> if you
        need a copy of the name).
-->
トリガの発行元のリレーションを記述する構造体へのポインタです。
この構造体についての詳細は、<filename>utils/rel.h</>を参照してください。
最も興味深いのは、<literal>tg_relation-&gt;rd_att</>（リレーションタプルの記述子）と<literal>tg_relation-&gt;rd_rel->relname</>です（リレーション名、これは<type>char*</>ではなく<type>NameData</>です。
名前のコピーが必要な場合は、<type>char*</>を得るために<literal>SPI_getrelname(tg_relation)</>を使用してください）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><structfield>tg_trigtuple</></term>
      <listitem>
       <para>
<!--
        A pointer to the row for which the trigger was fired. This is
        the row being inserted, updated, or deleted.  If this trigger
        was fired for an <command>INSERT</command> or
        <command>DELETE</command> then this is what you should return
        from the function if you don't want to replace the row with
        a different one (in the case of <command>INSERT</command>) or
        skip the operation.  For triggers on foreign tables, values of system
        columns herein are unspecified.
-->
トリガが発行された行へのポインタです。
これは挿入される、削除される、あるいは更新される行です。
もし<command>INSERT</command>/<command>DELETE</command>でこのトリガが発行された時、この行を別のもので置き換えたくない（<command>INSERT</command>の場合）場合や、その操作を飛ばしたくない場合は、これをこの関数から返してください。
外部テーブルのトリガに対しては、システム列の値はここでは指定されません。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><structfield>tg_newtuple</></term>
      <listitem>
       <para>
<!--
        A pointer to the new version of the row, if the trigger was
        fired for an <command>UPDATE</command>, and <symbol>NULL</> if
        it is for an <command>INSERT</command> or a
        <command>DELETE</command>. This is what you have to return
        from the function if the event is an <command>UPDATE</command>
        and you don't want to replace this row by a different one or
        skip the operation.  For triggers on foreign tables, values of system
        columns herein are unspecified.
-->
トリガが<command>UPDATE</command>で発行された場合は、行の新しいバージョンへのポインタです。
<command>INSERT</command>もしくは<command>DELETE</command>の場合は、<symbol>NULL</>です。
<command>UPDATE</command>イベントの時、この行を別のもので置き換えたくない場合や操作を飛ばしたくない場合は、これをこの関数から返してください。
外部テーブルのトリガに対しては、システム列の値はここでは指定されません。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><structfield>tg_trigger</></term>
      <listitem>
       <para>
<!--
        A pointer to a structure of type <structname>Trigger</>,
        defined in <filename>utils/reltrigger.h</>:
-->
以下のように<filename>utils/reltrigger.h</>で定義された、<structname>Trigger</>構造体へのポインタです。

<programlisting>
typedef struct Trigger
{
    Oid         tgoid;
    char       *tgname;
    Oid         tgfoid;
    int16       tgtype;
    char        tgenabled;
    bool        tgisinternal;
    Oid         tgconstrrelid;
    Oid         tgconstrindid;
    Oid         tgconstraint;
    bool        tgdeferrable;
    bool        tginitdeferred;
    int16       tgnargs;
    int16       tgnattr;
    int16      *tgattr;
    char      **tgargs;
    char       *tgqual;
} Trigger;
</programlisting>

<!--
       where <structfield>tgname</> is the trigger's name,
       <structfield>tgnargs</> is the number of arguments in
       <structfield>tgargs</>, and <structfield>tgargs</> is an array of
       pointers to the arguments specified in the <command>CREATE
       TRIGGER</command> statement. The other members are for internal use
       only.
-->
ここで、<structfield>tgname</>がトリガの名前、<structfield>tgnargs</>が<structfield>tgargs</>内の引数の数、<structfield>tgargs</>は<command>CREATE TRIGGER</command>文で指定された引数へのポインタの配列です。
他のメンバは内部でのみ使用されます。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><structfield>tg_trigtuplebuf</></term>
      <listitem>
       <para>
<!--
        The buffer containing <structfield>tg_trigtuple</structfield>, or <symbol>InvalidBuffer</symbol> if there
        is no such tuple or it is not stored in a disk buffer.
-->
<structfield>tg_trigtuple</structfield>を含むバッファです。
そうしたタプルが存在しない場合やディスクバッファ内に格納されていない場合は<symbol>InvalidBuffer</symbol>です。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><structfield>tg_newtuplebuf</></term>
      <listitem>
       <para>
<!--
        The buffer containing <structfield>tg_newtuple</structfield>, or <symbol>InvalidBuffer</symbol> if there
        is no such tuple or it is not stored in a disk buffer.
-->
<structfield>tg_newtuple</structfield>を含むバッファです。
そうしたタプルが存在しない場合やディスクバッファ内に格納されていない場合は<symbol>InvalidBuffer</symbol>です。
       </para>
      </listitem>
     </varlistentry>

    </variablelist>
   </para>

   <para>
<!--
    A trigger function must return either a
    <structname>HeapTuple</> pointer or a <symbol>NULL</> pointer
    (<emphasis>not</> an SQL null value, that is, do not set <parameter>isNull</parameter> true).
    Be careful to return either
    <structfield>tg_trigtuple</> or <structfield>tg_newtuple</>,
    as appropriate, if you don't want to modify the row being operated on.
-->
トリガ関数は<structname>HeapTuple</>ポインタもしくは<symbol>NULL</>ポインタ（SQLのNULLでは<emphasis>ありません</>。
したがって、<parameter>isNull</parameter>は真にはなりません）のどちらかを返さなければなりません。
操作対象の行を変更したくない場合は、注意して、<structfield>tg_trigtuple</>か<structfield>tg_newtuple</>の適切な方を返してください。
   </para>
  </sect1>

  <sect1 id="trigger-example">
<!--
   <title>A Complete Trigger Example</title>
-->
   <title>完全なトリガの例</title>

   <para>
<!--
    Here is a very simple example of a trigger function written in C.
    (Examples of triggers written in procedural languages can be found
    in the documentation of the procedural languages.)
-->
C言語で作成したトリガ関数に関するとても簡単な例をここに示します
（手続き言語で作成したトリガの例は、その手続き言語の文書に記載されています。）
   </para>

   <para>
<!--
    The function <function>trigf</> reports the number of rows in the
    table <structname>ttest</> and skips the actual operation if the
    command attempts to insert a null value into the column
    <structfield>x</>. (So the trigger acts as a not-null constraint but
    doesn't abort the transaction.)
-->
<function>trigf</>関数は、<structname>ttest</>テーブル内にある行数を報告し、問い合わせが<structfield>x</>にNULL値を挿入しようとしていた場合は、その操作を飛ばします
（つまり、このトリガは、トランザクションを中断させないNOT NULL制約のような動作をします。）
   </para>

   <para>
<!--
    First, the table definition:
-->
まず、以下のようにテーブルを定義します。
<programlisting>
CREATE TABLE ttest (
    x integer
);
</programlisting>
   </para>

   <para>
<!--
    This is the source code of the trigger function:
-->
以下がトリガ関数のソースコードです。
<programlisting><![CDATA[
#include "postgres.h"
]]>

<!--
#include "executor/spi.h"       /* this is what you need to work with SPI */
#include "commands/trigger.h"   /* ... triggers ... */
#include "utils/rel.h"          /* ... and relations */
-->

<![CDATA[
#include "executor/spi.h"       /* これはSPIを使用する場合に必要なもの */
#include "commands/trigger.h"   /* これはトリガで必要なもの */
#include "utils/rel.h"          /* これはリレーションで必要なもの */

#ifdef PG_MODULE_MAGIC
PG_MODULE_MAGIC;
#endif

extern Datum trigf(PG_FUNCTION_ARGS);

PG_FUNCTION_INFO_V1(trigf);

Datum
trigf(PG_FUNCTION_ARGS)
{
    TriggerData *trigdata = (TriggerData *) fcinfo->context;
    TupleDesc   tupdesc;
    HeapTuple   rettuple;
    char       *when;
    bool        checknull = false;
    bool        isnull;
    int         ret, i;

]]>

<!--
    /* make sure it's called as a trigger at all */
-->

<![CDATA[
    /* トリガとして呼び出されたかどうかを確認 */
    if (!CALLED_AS_TRIGGER(fcinfo))
        elog(ERROR, "trigf: not called by trigger manager");
]]>

<!--
    /* tuple to return to executor */
-->

<![CDATA[
    /* エクゼキュータに返すタプル */
    if (TRIGGER_FIRED_BY_UPDATE(trigdata->tg_event))
        rettuple = trigdata->tg_newtuple;
    else
        rettuple = trigdata->tg_trigtuple;
]]>

<!--
    /* check for null values */
-->

<![CDATA[
    /* NULL値をチェック */
    if (!TRIGGER_FIRED_BY_DELETE(trigdata->tg_event)
        && TRIGGER_FIRED_BEFORE(trigdata->tg_event))
        checknull = true;

    if (TRIGGER_FIRED_BEFORE(trigdata->tg_event))
        when = "before";
    else
        when = "after ";

    tupdesc = trigdata->tg_relation->rd_att;
]]>

<!--
    /* connect to SPI manager */
-->

<![CDATA[
    /* SPIマネージャに接続 */
    if ((ret = SPI_connect()) < 0)
        elog(ERROR, "trigf (fired %s): SPI_connect returned %d", when, ret);
]]>

<!--
    /* get number of rows in table */
-->

<![CDATA[
    /* テーブル中の行数を取得 */
    ret = SPI_exec("SELECT count(*) FROM ttest", 0);

    if (ret < 0)
        elog(ERROR, "trigf (fired %s): SPI_exec returned %d", when, ret);
]]>

<!--
    /* count(*) returns int8, so be careful to convert */
-->

<![CDATA[
    /* count(*)はint8を返す。変換に注意してください*/
    i = DatumGetInt64(SPI_getbinval(SPI_tuptable->vals[0],
                                    SPI_tuptable->tupdesc,
                                    1,
                                    &isnull));

    elog (INFO, "trigf (fired %s): there are %d rows in ttest", when, i);

    SPI_finish();

    if (checknull)
    {
        SPI_getbinval(rettuple, tupdesc, 1, &isnull);
        if (isnull)
            rettuple = NULL;
    }

    return PointerGetDatum(rettuple);
}
]]>
</programlisting>
   </para>

   <para>
<!--
    After you have compiled the source code (see <xref
    linkend="dfunc">), declare the function and the triggers:
-->
ソースコードをコンパイル（<xref linkend="dfunc">を参照してください）した後に、以下の様に関数とトリガを宣言します。
<programlisting>
CREATE FUNCTION trigf() RETURNS trigger
    AS '<replaceable>filename</>'
    LANGUAGE C;

CREATE TRIGGER tbefore BEFORE INSERT OR UPDATE OR DELETE ON ttest
    FOR EACH ROW EXECUTE PROCEDURE trigf();

CREATE TRIGGER tafter AFTER INSERT OR UPDATE OR DELETE ON ttest
    FOR EACH ROW EXECUTE PROCEDURE trigf();
</programlisting>
   </para>

   <para>
<!--
    Now you can test the operation of the trigger:
-->
これで、トリガの操作を確認することができます。
<screen>
=&gt; INSERT INTO ttest VALUES (NULL);
INFO:  trigf (fired before): there are 0 rows in ttest
INSERT 0 0

<!--
&#045;&#045; Insertion skipped and AFTER trigger is not fired
-->
-- 挿入操作は飛ばされ、また、AFTERトリガも発行されません。

=&gt; SELECT * FROM ttest;
 x
---
(0 rows)

=&gt; INSERT INTO ttest VALUES (1);
INFO:  trigf (fired before): there are 0 rows in ttest
INFO:  trigf (fired after ): there are 1 rows in ttest
                                       ^^^^^^^^
<!--
                             remember what we said about visibility.
-->
                             可視性の説明を思い出してください。
INSERT 167793 1
vac=&gt; SELECT * FROM ttest;
 x
---
 1
(1 row)

=&gt; INSERT INTO ttest SELECT x * 2 FROM ttest;
INFO:  trigf (fired before): there are 1 rows in ttest
INFO:  trigf (fired after ): there are 2 rows in ttest
                                       ^^^^^^
<!--
                             remember what we said about visibility.
-->
                             可視性の説明を思い出してください。
INSERT 167794 1
=&gt; SELECT * FROM ttest;
 x
---
 1
 2
(2 rows)

=&gt; UPDATE ttest SET x = NULL WHERE x = 2;
INFO:  trigf (fired before): there are 2 rows in ttest
UPDATE 0
=&gt; UPDATE ttest SET x = 4 WHERE x = 2;
INFO:  trigf (fired before): there are 2 rows in ttest
INFO:  trigf (fired after ): there are 2 rows in ttest
UPDATE 1
vac=&gt; SELECT * FROM ttest;
 x
---
 1
 4
(2 rows)

=&gt; DELETE FROM ttest;
INFO:  trigf (fired before): there are 2 rows in ttest
INFO:  trigf (fired before): there are 1 rows in ttest
INFO:  trigf (fired after ): there are 0 rows in ttest
INFO:  trigf (fired after ): there are 0 rows in ttest
                                       ^^^^^^
<!--
                             remember what we said about visibility.
-->
                             可視性の説明を思い出してください。
DELETE 2
=&gt; SELECT * FROM ttest;
 x
---
(0 rows)
</screen>

   </para>

   <para>
<!--
    There are more complex examples in
    <filename>src/test/regress/regress.c</filename> and
    in <xref linkend="contrib-spi">.
-->
<filename>src/test/regress/regress.c</filename>と<xref linkend="contrib-spi">にはもっと複雑な例があります。
   </para>
  </sect1>
 </chapter>
