<!-- doc/src/sgml/libpq.sgml -->

<chapter id="libpq">
<!--
 <title><application>libpq</application> - C Library</title>
-->
 <title><application>libpq</application> - C ライブラリ</title>

 <indexterm zone="libpq">
  <primary>libpq</primary>
 </indexterm>

 <indexterm zone="libpq">
  <primary>C</primary>
 </indexterm>

 <para>
<!--
  <application>libpq</application> is the <acronym>C</acronym>
  application programmer's interface to <productname>PostgreSQL</>.
  <application>libpq</> is a set of library functions that allow
  client programs to pass queries to the <productname>PostgreSQL</>
  backend server and to receive the results of these queries.
-->
<application>libpq</application>は、<acronym>C</acronym>言語によるアプリケーションプログラマ用の<productname>PostgreSQL</productname>インタフェースです。
<application>libpq</application>は、クライアントプログラムから<productname>PostgreSQL</productname>のバックエンドサーバに問い合わせを渡し、その結果を受け取るためのライブラリ関数の集合です。
 </para>

 <para>
<!--
  <application>libpq</> is also the underlying engine for several
  other <productname>PostgreSQL</> application interfaces, including
  those written for C++, Perl, Python, Tcl and <application>ECPG</>.
  So some aspects of <application>libpq</>'s behavior will be
  important to you if you use one of those packages.  In particular,
  <xref linkend="libpq-envars">,
  <xref linkend="libpq-pgpass"> and
  <xref linkend="libpq-ssl">
  describe behavior that is visible to the user of any application
  that uses <application>libpq</>.
-->
<application>libpq</application>は、C++、Perl、Python、Tcl、<application>ECPG</application>などを含む、<productname>PostgreSQL</productname>の他の各種アプリケーションインタフェースを支えるエンジンでもあります。
従って、<application>libpq</>の動作は、これらのパッケージを使用する人にとって重要なものになります。
特に、<xref linkend="libpq-envars">、<xref linkend="libpq-pgpass">および<xref linkend="libpq-ssl">にて、<application>libpq</>を使用するすべてのアプリケーションのユーザから見える動作を説明します。
 </para>

 <para>
<!--
  Some short programs are included at the end of this chapter (<xref linkend="libpq-example">) to show how
  to write programs that use <application>libpq</application>.  There are also several
  complete examples of <application>libpq</application> applications in the
  directory <filename>src/test/examples</filename> in the source code distribution.
-->
本章の最後に、<filename>libpq</filename>の使い方を示す、いくつかの短いプログラム(<xref linkend="libpq-example">)があります。  
また、ソースコード配布物内の<filename>src/test/examples</filename>ディレクトリに、<application>libpq</application>を利用したアプリケーションプログラム一式の例があります。
 </para>

 <para>
<!--
  Client programs that use <application>libpq</application> must
  include the header file
  <filename>libpq-fe.h</filename><indexterm><primary>libpq-fe.h</></>
  and must link with the <application>libpq</application> library.
-->
<application>libpq</application>を使用してフロントエンドプログラムを作成するには、<filename>libpq-fe.h</filename>ヘッダファイルのインクルードと、<application>libpq</application> ライブラリとのリンクが必要です。
<indexterm><primary>libpq-fe.h</></>
 </para>

 <sect1 id="libpq-connect">
<!--
  <title>Database Connection Control Functions</title>
-->
  <title>データベース接続制御関数</title>

  <para>
<!--
   The following functions deal with making a connection to a
   <productname>PostgreSQL</productname> backend server.  An
   application program can have several backend connections open at
   one time.  (One reason to do that is to access more than one
   database.)  Each connection is represented by a
   <structname>PGconn</><indexterm><primary>PGconn</></> object, which
   is obtained from the function <function>PQconnectdb</>,
   <function>PQconnectdbParams</>, or
   <function>PQsetdbLogin</>.  Note that these functions will always
   return a non-null object pointer, unless perhaps there is too
   little memory even to allocate the <structname>PGconn</> object.
   The <function>PQstatus</> function should be called to check
   the return value for a successful connection before queries are sent
   via the connection object.
-->
<productname>PostgreSQL</productname>のバックエンドサーバとの接続を作成するには、以下の関数を使用します。
アプリケーションプログラムはバックエンドとの接続を一度に複数個開くことができます。
（1つの理由として、複数のデータベースへのアクセスが挙げられます。）
個々の接続は、<function>PQconnectdb</>、<function>PQconnectdbParams</>または<function>PQsetdbLogin</>関数を呼び出すことで得られる<structname>PGconn</><indexterm><primary>PGconn</></>オブジェクトによって表されます。
なお、これらの関数は、<structname>PGconn</>オブジェクトに割り当てるほんのわずかなメモリの余裕さえもない場合を除き、NULLではなく常にオブジェクトのポインタを返します。
また、この接続オブジェクトを通じて問い合わせを送る前に、<function>PQstatus</>関数を呼び出して、データベースとの接続に成功したか戻り値を検査しなければなりません。

   <warning>
    <para>
<!--
     On Unix, forking a process with open libpq connections can lead to
     unpredictable results because the parent and child processes share
     the same sockets and operating system resources.  For this reason,
     such usage is not recommended, though doing an <function>exec</> from
     the child process to load a new executable is safe.
-->
Unix上で、libpq接続を開いたプロセスのフォークは、親と子のプロセスが同じソケットとオペレーティングシステムの資源を共有するため、予期せぬ結果を招くことがあります。
この理由により、新規実行形式を子プロセスが読み込むため<function>exec</>を行うことが安全と言っても、このような使用法は推奨されません。
    </para>
   </warning>

   <note>
    <para>
<!--
     On Windows, there is a way to improve performance if a single
     database connection is repeatedly started and shutdown.  Internally,
     libpq calls <function>WSAStartup()</> and <function>WSACleanup()</> for connection startup
     and shutdown, respectively.  <function>WSAStartup()</> increments an internal
     Windows library reference count which is decremented by <function>WSACleanup()</>.
     When the reference count is just one, calling <function>WSACleanup()</> frees
     all resources and all DLLs are unloaded.  This is an expensive
     operation.  To avoid this, an application can manually call
     <function>WSAStartup()</> so resources will not be freed when the last database
     connection is closed.
-->
Windowsでは、単一のデータベース接続が反復して開始と終了を繰り返す場合、性能を向上させる方法があります。
内部的には、接続開始と終了に対して、libpqはそれぞれ<function>WSAStartup()</>と<function>WSACleanup()</>を呼び出します。
<function>WSAStartup()</>は<function>WSACleanup()</>で値が減少させられた内部Windowsライブラリ参照カウントを増加させます。
参照カウントがたった１の場合、<function>WSACleanup()</>呼び出しはすべてのリソースを解放し、すべてのDLLはアンロードされます。
これは高価な操作です。
これを回避するには、最後のデータベース接続が閉じられる時、リソースが解放されないようにアプリケーションが手動で<function>WSAStartup()</>を呼び出すことができます。
    </para>
   </note>

   <variablelist>
    <varlistentry id="libpq-pqconnectdbparams">
     <term><function>PQconnectdbParams</function><indexterm><primary>PQconnectdbParams</></></term>
     <listitem>
      <para>
<!--
       Makes a new connection to the database server.
-->
新たにデータベースサーバへの接続を作成します。

<synopsis>
PGconn *PQconnectdbParams(const char * const *keywords,
                          const char * const *values,
                          int expand_dbname);
</synopsis>
      </para>

      <para>
<!--
       This function opens a new database connection using the parameters taken
       from two <symbol>NULL</symbol>-terminated arrays. The first,
       <literal>keywords</literal>, is defined as an array of strings, each one
       being a key word. The second, <literal>values</literal>, gives the value
       for each key word. Unlike <function>PQsetdbLogin</> below, the parameter
       set can be extended without changing the function signature, so use of
       this function (or its nonblocking analogs <function>PQconnectStartParams</>
       and <function>PQconnectPoll</function>) is preferred for new application
       programming.
-->
この関数は、2つの<symbol>NULL</symbol>終端の配列から取得したパラメータを使用して、データベースとの接続を新たに1つ確立します。
1つ目は文字列配列として定義される<literal>keywords</literal>で、それぞれがキーワードとなります。
2つ目は<literal>values</literal>で、各キーワードの値を提供します。
後述の<function>PQsetdbLogin</>とは異なり、関数のシグネチャを変更せずにパラメータ集合を拡張できますので、アプリケーションプログラムを新たに作成する際には、この関数(もしくは非ブロックモードでよく似た処理をする<function>PQconnectStartParams</>と<function>PQconnectPoll</function>)を使用することをお勧めします。
      </para>

      <para>
<!--
       The currently recognized parameter key words are listed in
       <xref linkend="libpq-paramkeywords">.
-->
現在有効なパラメータキーワードを<xref linkend="libpq-paramkeywords">に示します。
      </para>

      <para>
<!--
       When <literal>expand_dbname</literal> is non-zero, the
       <parameter>dbname</parameter> key word value is allowed to be recognized
       as a connection string. Only the first occurrence of
       <parameter>dbname</parameter> is expanded this way, any subsequent
       <parameter>dbname</parameter> value is processed as plain database name. More
       details on the possible connection string formats appear in
       <xref linkend="libpq-connstring">.
-->
<literal>expand_dbname</literal>が非ゼロの場合、<parameter>dbname</parameter>キーワードの値を接続文字列として認識させることができます。
最初に出現した<parameter>dbname</parameter>だけがこのように展開され、後続の<parameter>dbname</parameter>値は通常のデータベース名として処理されます。
接続文字列の取り得る書式に関する詳細については<xref linkend="libpq-connstring">を参照してください。
      </para>

      <para>
<!--
       The passed arrays can be empty to use all default parameters, or can
       contain one or more parameter settings. They should be matched in length.
       Processing will stop at the first <symbol>NULL</symbol> element
       in the <literal>keywords</literal> array.
-->
空の配列を渡してすべてデフォルトパラメータを使用することができます。
また渡される配列に1つ以上のパラメータ設定を持たせることもできます。
これらの長さは一致しなければなりません。
<literal>keywords</literal>配列の最初の<symbol>NULL</symbol>要素で処理は停止します。
      </para>

      <para>
<!--
       If  any  parameter is <symbol>NULL</symbol> or an emptry string, the corresponding
       environment variable (see <xref linkend="libpq-envars">) is checked.
       If the  environment  variable is not set either, then the indicated
       built-in defaults are used.
-->
パラメータが<symbol>NULL</symbol>や空文字列の場合には、対応する環境変数が検査されます（<xref linkend="libpq-envars">を参照してください）。
環境変数も設定されていない場合は、指定された組み込みのデフォルト値が使用されます。
      </para>

      <para>
<!--
       In general key words are processed from the beginning of these arrays in index
       order. The effect of this is that when key words are repeated, the last processed
       value is retained. Therefore, through careful placement of the
       <parameter>dbname</parameter> key word, it is possible to determine what may
       be overridden by a <parameter>conninfo</parameter> string, and what may not.
-->
一般的にキーワードはこれらの配列の先頭からインデックス順で処理されます。
この影響はキーワードが繰り返された場合で、最後に処理された値が残ることになります。
このため、<parameter>dbname</parameter>キーワードの記述場所に注意することで、<parameter>conninfo</parameter>文字列により何が上書きされるか、何が上書きされないかを決定することができます。
      </para>

     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqconnectdb">
     <term><function>PQconnectdb</function><indexterm><primary>PQconnectdb</></></term>
     <listitem>
      <para>
<!--
       Makes a new connection to the database server.
-->
新たにデータベースサーバへの接続を作成します。

<synopsis>
PGconn *PQconnectdb(const char *conninfo);
</synopsis>
      </para>

      <para>
<!--
       This function opens a new database connection using the parameters taken
       from the string <literal>conninfo</literal>.
-->
この関数は<literal>conninfo</literal>文字列から取得されるパラメータを使用して、新しいデータベース接続を開きます。
      </para>

      <para>
<!--
       The passed string can be empty to use all default parameters, or it can
       contain one or more parameter settings separated by whitespace,
       or it can contain a <acronym>URI</acronym>.
       See <xref linkend="libpq-connstring"> for details.
-->
空の文字列を渡してすべてデフォルトパラメータを使用することができます。
また空白文字で区切ることで1つ以上のパラメータ設定を持たせることもできます。
さらに<acronym>URI</acronym>を含めることができます。
詳細については<xref linkend="libpq-connstring">を参照してください。
     </para>


    </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqsetdblogin">
     <term><function>PQsetdbLogin</function><indexterm><primary>PQsetdbLogin</></></term>
     <listitem>
      <para>
<!--
       Makes a new connection to the database server.
-->
新たにデータベースサーバへの接続を作成します。
<synopsis>
PGconn *PQsetdbLogin(const char *pghost,
                     const char *pgport,
                     const char *pgoptions,
                     const char *pgtty,
                     const char *dbName,
                     const char *login,
                     const char *pwd);
</synopsis>
       </para>

       <para>
<!--
        This is the predecessor of <function>PQconnectdb</function> with a fixed
        set of parameters.  It has the same functionality except that the
        missing parameters will always take on default values.  Write <symbol>NULL</symbol> or an
        empty string for any one of the fixed parameters that is to be defaulted.
-->
これはパラメータ群を固定した<function>PQconnectdb</function>の前身です。
設定できないパラメータが常にデフォルト値になる点を除き、同一の機能を持ちます。
固定のパラメータに対して<symbol>NULL</symbol>もしくは空文字列とすると、それはデフォルトを使用することになります。
      </para>

      <para>
<!--
        If the <parameter>dbName</parameter> contains
        an <symbol>=</symbol> sign or has a valid connection <acronym>URI</acronym> prefix, it
        is taken as a <parameter>conninfo</parameter> string in exactly the same way as
        if it had been passed to <function>PQconnectdb</function>, and the remaining
        parameters are then applied as specified for <function>PQconnectdbParams</>.
-->
<parameter>dbName</parameter>内に<symbol>=</symbol>記号が含まれる場合、または有効な接続<acronym>URI</acronym>接頭辞を持つ場合、<function>PQconnectdb</function>に渡された場合とまったく同じ扱いで<parameter>conninfo</parameter>文字列として扱われます。
その後残りのパラメータが<function>PQconnectdbParams</>の指定のように適用されます。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqsetdb">
     <term><function>PQsetdb</function><indexterm><primary>PQsetdb</></></term>
     <listitem>
      <para>
<!--
   Makes a new connection to the database server.
-->
新たにデータベースサーバへの接続を作成します。
<synopsis>
PGconn *PQsetdb(char *pghost,
                char *pgport,
                char *pgoptions,
                char *pgtty,
                char *dbName);
</synopsis>
     </para>

     <para>
<!--
      This is a macro that calls <function>PQsetdbLogin</function> with null pointers
      for the <parameter>login</> and <parameter>pwd</> parameters.  It is provided
      for backward compatibility with very old programs.
-->
これは、<parameter>login</>と<parameter>pwd</>にNULLポインタを設定する<function>PQsetdbLogin</function>を呼び出すマクロです。
非常に古いプログラムへの後方互換性のために提供されています。
     </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqconnectstartparams">
     <term><function>PQconnectStartParams</function><indexterm><primary>PQconnectStartParams</></></term>
     <term><function>PQconnectStart</function><indexterm><primary>PQconnectStart</></></term>
     <term><function>PQconnectPoll</function><indexterm><primary>PQconnectPoll</></></term>
     <listitem>
      <para>
<!--
       <indexterm><primary>nonblocking connection</primary></indexterm>
-->
       <indexterm><primary>非ブロック接続</primary></indexterm>
<!--
       Make a connection to the database server in a nonblocking manner.
-->
ブロックしない方法で、データベースサーバへの接続を作成します。

<synopsis>
PGconn *PQconnectStartParams(const char * const *keywords,
                             const char * const *values,
                             int expand_dbname);

PGconn *PQconnectStart(const char *conninfo);

PostgresPollingStatusType PQconnectPoll(PGconn *conn);
</synopsis>
      </para>

      <para>
<!--
       These three functions are used to open a connection to a database server such
       that your application's thread of execution is not blocked on remote I/O
       whilst doing so. The point of this approach is that the waits for I/O to
       complete can occur in the application's main loop, rather than down inside
       <function>PQconnectdbParams</> or <function>PQconnectdb</>, and so the
       application can manage this operation in parallel with other activities.
-->
これら3つの関数は、リモートI/Oの実行時にアプリケーションスレッドの実行がブロックされないようなデータベースサーバへの接続を作成するために使われます。
この手法の利点は、I/Oの終了待ちが<function>PQconnectdbParams</>または<function>PQconnectdb</>内部ではなく、アプリケーションプログラムのメインループでできることにあります。
これによって、アプリケーションは他の処理と並行してこの処理を管理することができます。
      </para>

      <para>
<!--
       With <function>PQconnectStartParams</function>, the database connection is made
       using the parameters taken from the <literal>keywords</literal> and
       <literal>values</literal> arrays, and controlled by <literal>expand_dbname</literal>,
       as described above for <function>PQconnectdbParams</function>.
-->
<function>PQconnectStartParams</function>では、上で<function>PQconnectdbParams</function>で説明したように、データベース接続は<literal>keywords</literal>および<literal>values</literal>配列から取得され、<literal>expand_dbname</literal>によって制御されたパラメータを使用して確立します。
      </para>

      <para>
<!--
       With <function>PQconnectStart</function>, the database connection is made
       using the parameters taken from the string <literal>conninfo</literal> as
       described above for <function>PQconnectdb</function>.
-->
<function>PQconnectStart</function>では、上で<function>PQconnectdb</function>で説明したように、<literal>conninfo</literal>文字列から取得されたパラメータを使用してデータベース接続を確立します。
      </para>

      <para>
<!--
       Neither <function>PQconnectStartParams</function> nor <function>PQconnectStart</function>
       nor <function>PQconnectPoll</function> will block, so long as a number of
       restrictions are met:
-->
<function>PQconnectStartParams</function>、<function>PQconnectStart</function>と<function>PQconnectPoll</function>のどちらも以下の制限に適合する場合ブロックしません。
       <itemizedlist>
        <listitem>
         <para>
<!--
          The <literal>hostaddr</> and <literal>host</> parameters are used appropriately to ensure that
          name and reverse name queries are not made. See the documentation of
          these parameters in <xref linkend="libpq-paramkeywords"> for details.
-->
<literal>hostaddr</>と<literal>host</>パラメータは、ホスト名からのIPアドレス検索やホスト名の逆引きが起こらないように適切に使用されなければいけません。
詳細に付いては<xref linkend="libpq-paramkeywords">内のパラメータ説明を参照してください。
         </para>
        </listitem>

        <listitem>
         <para>
<!--
          If you call <function>PQtrace</function>, ensure that the stream object
          into which you trace will not block.
-->
<function>PQtrace</function>を呼び出す場合は、トレースに使用するストリームオブジェクトがブロックされないことが保証されていなくてはなりません。
         </para>
        </listitem>

        <listitem>
         <para>
<!--
          You ensure that the socket is in the appropriate state
          before calling <function>PQconnectPoll</function>, as described below.
-->
プログラマ自身が、後に示すように、<function>PQconnectPoll</function>を呼び出す前にソケットが適切な状態にあることを保証しなくてはいけません。
         </para>
        </listitem>
       </itemizedlist>
      </para>

      <para>
<!--
       Note: use of <function>PQconnectStartParams</> is analogous to
       <function>PQconnectStart</> shown below.
-->
注意：<function>PQconnectStartParams</>の使用は後述の<function>PQconnectStart</>と類似しています。
      </para>

      <para>
<!--
       To begin a nonblocking connection request, call <literal>conn = PQconnectStart("<replaceable>connection_info_string</>")</literal>.
       If <varname>conn</varname> is null, then <application>libpq</> has been unable to allocate a new <structname>PGconn</>
       structure. Otherwise, a valid <structname>PGconn</> pointer is returned (though not yet
       representing a valid connection to the database). On return from
       <function>PQconnectStart</function>, call <literal>status = PQstatus(conn)</literal>. If <varname>status</varname> equals
       <symbol>CONNECTION_BAD</symbol>, <function>PQconnectStart</function> has failed.
-->
非ブロック接続要求を始めるにはまず、<literal>conn=PQconnectStart("<replaceable>connection_info_string</>")</literal>を呼び出します。
<varname>conn</varname>がNULLの場合、<application>libpq</>が新たに<structname>PGconn</>構造体を割り当てられなかったことを表します。
そうでない場合は、適切な<structname>PGconn</>へのポインタが返されます
（ただし、データベースに正しく接続されていることを表しているわけではありません）。
<function>PQconnectStart</function>から値が返ってきた段階で、<literal>status=PQstatus(conn)</literal>を呼び出します。
もし、<varname>status</varname>が<symbol>CONNECTION_BAD</symbol>と等しい場合には、<function>PQconnectStart</function>が失敗しています。
      </para>

      <para>
<!--
       If <function>PQconnectStart</> succeeds, the next stage is to poll
       <application>libpq</> so that it can proceed with the connection sequence.
       Use <function>PQsocket(conn)</function> to obtain the descriptor of the
       socket underlying the database connection.
       Loop thus: If <function>PQconnectPoll(conn)</function> last returned
       <symbol>PGRES_POLLING_READING</symbol>, wait until the socket is ready to
       read (as indicated by <function>select()</>, <function>poll()</>, or
       similar system function).
       Then call <function>PQconnectPoll(conn)</function> again.
       Conversely, if <function>PQconnectPoll(conn)</function> last returned
       <symbol>PGRES_POLLING_WRITING</symbol>, wait until the socket is ready
       to write, then call <function>PQconnectPoll(conn)</function> again.
       If you have yet to call
       <function>PQconnectPoll</function>, i.e., just after the call to
       <function>PQconnectStart</function>, behave as if it last returned
       <symbol>PGRES_POLLING_WRITING</symbol>.  Continue this loop until
       <function>PQconnectPoll(conn)</function> returns
       <symbol>PGRES_POLLING_FAILED</symbol>, indicating the connection procedure
       has failed, or <symbol>PGRES_POLLING_OK</symbol>, indicating the connection
       has been successfully made.
-->
<function>PQconnectStart</>が成功したら、次は接続シーケンスを進めるために、<application>libpq</>をポーリングします。
データベース接続の背後にあるソケットの記述子を取り出すには、<function>PQsocket(conn)</function>を使用します。
以下の繰り返しです。
直前の<function>PQconnectPoll(conn)</function>が<symbol>PGRES_POLLING_READING</symbol>の場合、ソケットの読み込み準備が整うまで待機します。
（<function>select()</>や<function>poll()</>などのシステム関数で示されます。）
そして、再度<function>PQconnectPoll(conn)</function>を呼び出します。
反対に直前の<function>PQconnectPoll(conn)</function>が<symbol>PGRES_POLLING_WRITING</symbol>の場合、ソケットの書き込み準備が整うまで待機し、その後、<function>PQconnectPoll(conn)</function>を再度呼び出します。
まだ<function>PQconnectPoll</function>を呼び出していない場合、つまり、<function>PQconnectStart</function>の呼び出し直後では、直前が<symbol>PGRES_POLLING_WRITING</symbol>であった場合と同様の処理を行ないます。
この繰り返しを<function>PQconnectPoll(conn)</function>が、接続手続きの失敗を示す<symbol>PGRES_POLLING_FAILED</symbol>、もしくは、接続確立に成功したことを示す<symbol>PGRES_POLLING_OK</symbol>を返すまで継続します。
      </para>

      <para>
<!--
       At any time during connection, the status of the connection can be
       checked by calling <function>PQstatus</>. If this call returns <symbol>CONNECTION_BAD</>, then the
       connection procedure has failed; if the call returns <function>CONNECTION_OK</>, then the
       connection is ready.  Both of these states are equally detectable
       from the return value of <function>PQconnectPoll</>, described above. Other states might also occur
       during (and only during) an asynchronous connection procedure. These
       indicate the current stage of the connection procedure and might be useful
       to provide feedback to the user for example. These statuses are:
-->
接続している間は、いつでも<function>PQstatus</>を呼び出すことで、接続の状態を検査することができます。
この関数呼び出しが<symbol>CONNECTION_BAD</>を返す場合、接続手続きは失敗しており、<symbol>CONNECTION_OK</>を返す場合、接続が確立しています。
上述のように、このいずれの状態も、<function>PQconnectPoll</>の戻り値から同様に検出できます。
これ以外の状態は、非同期の接続手続きの間（のみに）現れることがあります。 
これらは、接続手続きの現在の段階を示すものであり、例えばユーザへのフィードバックを提供することに使用できます。 
以下の状態があります。

       <variablelist>
        <varlistentry id="libpq-connection-started">
         <term><symbol>CONNECTION_STARTED</symbol></term>
         <listitem>
          <para>
<!--
           Waiting for connection to be made.
-->
接続の確立待ち状態です。
          </para>
         </listitem>
        </varlistentry>

        <varlistentry id="libpq-connection-made">
         <term><symbol>CONNECTION_MADE</symbol></term>
         <listitem>
          <para>
<!--
           Connection OK; waiting to send.
-->
接続はOKです。送信待ち状態です。
          </para>
         </listitem>
        </varlistentry>

        <varlistentry id="libpq-connection-awaiting-response">
         <term><symbol>CONNECTION_AWAITING_RESPONSE</symbol></term>
         <listitem>
          <para>
<!--
           Waiting for a response from the server.
-->
サーバからの応答待ち状態です。
          </para>
         </listitem>
        </varlistentry>

        <varlistentry id="libpq-connection-auth-ok">
         <term><symbol>CONNECTION_AUTH_OK</symbol></term>
         <listitem>
          <para>
<!--
           Received authentication; waiting for backend start-up to finish.
-->
        認証済みです。バックエンドの起動待ち状態です。
          </para>
         </listitem>
        </varlistentry>

        <varlistentry id="libpq-connection-ssl-startup">
         <term><symbol>CONNECTION_SSL_STARTUP</symbol></term>
         <listitem>
          <para>
<!--
           Negotiating SSL encryption.
-->
SSL暗号化の調停状態です。
          </para>
         </listitem>
        </varlistentry>

        <varlistentry id="libpq-connection-setenv">
         <term><symbol>CONNECTION_SETENV</symbol></term>
         <listitem>
          <para>
<!--
           Negotiating environment-driven parameter settings.
-->
環境が提供するパラメータ設定の調停状態です。
          </para>
         </listitem>
        </varlistentry>
       </variablelist>

<!--
       Note that, although these constants will remain (in order to maintain
       compatibility), an application should never rely upon these occurring in a
       particular order, or at all, or on the status always being one of these
       documented values. An application might do something like this:
-->
これらの定数は（互換性を保つため）なくなることはありませんが、アプリケーションは、これらが特定の順で出現したり、本書に書いてある値のどれかに必ずステータス値が該当するということを決して当てにしてはいけません。 
アプリケーションは、以下に示すようにするべきです。

<programlisting>
switch(PQstatus(conn))
{
        case CONNECTION_STARTED:
            feedback = "Connecting...";
            break;

        case CONNECTION_MADE:
            feedback = "Connected to server...";
            break;
.
.
.
        default:
            feedback = "Connecting...";
}
</programlisting>
      </para>

      <para>
<!--
       The <literal>connect_timeout</literal> connection parameter is ignored
       when using <function>PQconnectPoll</function>; it is the application's
       responsibility to decide whether an excessive amount of time has elapsed.
       Otherwise, <function>PQconnectStart</function> followed by a
       <function>PQconnectPoll</function> loop is equivalent to
       <function>PQconnectdb</function>.
-->
<function>PQconnectPoll</function>を使用する場合、<literal>connect_timeout</literal>接続パラメータは無視されます。
経過時間が長過ぎるかどうかの判定はアプリケーションの責任で行ないます。
さもないと、<function>PQconnectStart</function>の後の<function>PQconnectPoll</function>の繰り返しが<function>PQconnectdb</function>と同じになります。
      </para>

      <para>
<!--
       Note that if <function>PQconnectStart</function> returns a non-null pointer, you must call
       <function>PQfinish</function> when you are finished with it, in order to dispose of
       the structure and any associated memory blocks. This must be done even if
       the connection attempt fails or is abandoned.
-->
<function>PQconnectStart</function>が非NULLポインタを返した場合、処理を終了する際には、構造体や関連するメモリブロックを始末するために、<function>PQfinish</function>を呼び出さなくてはならないことに注意してください。
この処理は、接続試行が失敗した場合やその試行を中断する場合にも、必ず実行されなければいけません。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqconndefaults">
     <term><function>PQconndefaults</function><indexterm><primary>PQconndefaults</></></term>
     <listitem>
      <para>
<!--
       Returns the default connection options.
-->
デフォルトの接続オプションを返します。
<synopsis>
PQconninfoOption *PQconndefaults(void);

typedef struct
{
<!--
    char   *keyword;   /* The keyword of the option */
    char   *envvar;    /* Fallback environment variable name */
    char   *compiled;  /* Fallback compiled in default value */
    char   *val;       /* Option's current value, or NULL */
    char   *label;     /* Label for field in connect dialog */
    char   *dispchar;  /* Indicates how to display this field
                          in a connect dialog. Values are:
                          ""        Display entered value as is
                          "*"       Password field - hide value
                          "D"       Debug option - don't show by default */
    int     dispsize;  /* Field size in characters for dialog */
-->
    char   *keyword;   /* このオプションのキーワード */
    char   *envvar;    /* 代替となる環境変数の名前 */
    char   *compiled;  /* 代替となるコンパイル時に組み込まれたデフォルト値 */
    char   *val;       /* オプションの現在値、もしくは、NULL */
    char   *label;     /* 接続ダイアログ内の当該フィールドのラベル */
    char   *dispchar;  /* 接続ダイアログ内の当該フィールドをどのように表示するかの指示
                          値:
                          ""        入力された値をそのまま表示
                          "*"       値を隠すパスワードフィールド用
                          "D"       デバッグオプション。デフォルトで何も表示しません */
    int     dispsize;  /* ダイアログ用のフィールドの大きさ(文字数単位) */
} PQconninfoOption;
</synopsis>
      </para>

      <para>
<!--
       Returns a connection options array.  This can be used to determine
       all possible <function>PQconnectdb</function> options and their
       current default values.  The return value points to an array of
       <structname>PQconninfoOption</structname> structures, which ends
       with an entry having a null <structfield>keyword</> pointer.  The
       null pointer is returned if memory could not be allocated. Note that
       the current default values (<structfield>val</structfield> fields)
       will depend on environment variables and other context.  A
       missing or invalid service file will be silently ignored.  Callers
       must treat the connection options data as read-only.
-->
接続オプションの配列を返します。
これは、使用可能な<function>PQconnectdb</function>用オプションのすべてや、その時点でのデフォルト値を決定するために使用することができます。
戻り値は、<structname>PQconninfoOption</structname>構造体の配列へのポインタで、<structfield>keyword</>ポインタがヌルとなる項目が配列の末尾にきます。
メモリが確保できなかった場合にはヌルポインタを返します。
現在のデフォルト値(<structfield>val</structfield> フィールド）は、環境変数や他のコンテキストに依存します。
呼び出し側では、接続オプションの情報は、読み込み専用として取り扱わなければいけません。
      </para>

      <para>
<!--
       After processing the options array, free it by passing it to
       <function>PQconninfoFree</function>.  If this is not done, a small amount of memory
       is leaked for each call to <function>PQconndefaults</function>.
-->
オプションの配列を処理した後は、それを<function>PQconninfoFree</function>に渡して解放します。
この処理をしないと、<function>PQconndefaults</function>が呼び出されるたびに少しずつメモリリークが発生します。
      </para>

     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqconninfo">
     <term><function>PQconninfo</function><indexterm><primary>PQconninfo</></></term>
     <listitem>
      <para>
<!--
       Returns the connection options used by a live connection.
-->
所在する接続で使用される接続オプションを返します。
<synopsis>
PQconninfoOption *PQconninfo(PGconn *conn);
</synopsis>
      </para>

      <para>
<!--
       Returns a connection options array.  This can be used to determine
       all possible <function>PQconnectdb</function> options and the
       values that were used to connect to the server. The return
       value points to an array of <structname>PQconninfoOption</structname>
       structures, which ends with an entry having a null <structfield>keyword</>
       pointer. All notes above for <function>PQconndefaults</function> also
       apply to the result of <function>PQconninfo</function>.
-->
接続オプション配列を返します。これは全ての可能性のある<function>PQconnectdb</function>オプションとサーバに接続するのに使用される値を確定するために使用することができます。
返り値は<structname>PQconninfoOption</structname>構造体の配列を指し示めます。それはnull <structfield>keyword</> ポインタを持つ項目で終結します。<function>PQconndefaults</function>に対する上記の全ての注釈はまた<function>PQconninfo</function>の結果に適用されます。
      </para>

     </listitem>
    </varlistentry>


    <varlistentry id="libpq-pqconninfoparse">
     <term><function>PQconninfoParse</function><indexterm><primary>PQconninfoParse</></></term>
     <listitem>
      <para>
<!--
       Returns parsed connection options from the provided connection string.
-->
提供された接続文字列から構文解析された接続オプションを返します。

<synopsis>
PQconninfoOption *PQconninfoParse(const char *conninfo, char **errmsg);
</synopsis>
      </para>

      <para>
<!--
       Parses a connection string and returns the resulting options as an
       array; or returns <symbol>NULL</> if there is a problem with the connection
       string.  This function can be used to extract
       the <function>PQconnectdb</function> options in the provided
       connection string.  The return value points to an array of
       <structname>PQconninfoOption</structname> structures, which ends
       with an entry having a null <structfield>keyword</> pointer.
-->
接続文字列の構文解析を行い、配列として結果オプションを返すか、または接続文字列に問題があった場合に<symbol>NULL</>を返します。
この関数を提供された接続文字列の中の<function>PQconnectdb</function>オプションを取り出すために使用することができます。
戻り値は<structname>PQconninfoOption</structname>構造体の配列を指し示し、それはヌルの<structfield>keyword</>ポインタを持つ項目で終結します。
      </para>

      <para>
<!--
       All legal options will be present in the result array, but the
       <literal>PQconninfoOption</literal> for any option not present
       in the connection string will have <literal>val</literal> set to
       <literal>NULL</literal>; default values are not inserted.
-->
正規なオプションはすべて、結果配列内に現れます。
しかし接続文字列内に現れない、何らかのオプション用の<literal>PQconninfoOption</literal>は<literal>NULL</literal>に設定された<literal>val</literal>を持ちます。
デフォルトは挿入されません。
      </para>

      <para>
<!--
       If <literal>errmsg</> is not <symbol>NULL</>, then <literal>*errmsg</> is set
       to <symbol>NULL</> on success, else to a <function>malloc</>'d error string explaining
       the problem.  (It is also possible for <literal>*errmsg</> to be
       set to <symbol>NULL</> and the function to return <symbol>NULL</>;
       this indicates an out-of-memory condition.)
-->
<literal>errmsg</>が非<symbol>NULL</>であれば、成功した場合<literal>*errmsg</>は<symbol>NULL</>に設定され、そうでなければ、問題を説明した<function>malloc</>されたエラー文字列になります。
（<literal>*errmsg</>が<symbol>NULL</>に設定され、かつ、この関数が<symbol>NULL</>を返すこともあり得ます。
これはメモリ不足状態を意味します。）
      </para>

      <para>
<!--
       After processing the options array, free it by passing it to
       <function>PQconninfoFree</function>.  If this is not done, some memory
       is leaked for each call to <function>PQconninfoParse</function>.
       Conversely, if an error occurs and <literal>errmsg</> is not <symbol>NULL</>,
       be sure to free the error string using <function>PQfreemem</>.
-->
オプション配列を処理した後、それを<function>PQconninfoFree</function>に渡して解放してください。
これが行われない場合、<function>PQconninfoParse</function>へのそれぞれの呼び出しに対してメモリーリークが起こります。
反対に、エラーが起こり、そして<literal>errmsg</>が非<symbol>NULL</>であれば、<function>PQfreemem</>を使用してエラー文字列を必ず解放してください。
      </para>

   </listitem>
    </varlistentry>


    <varlistentry id="libpq-pqfinish">
     <term><function>PQfinish</function><indexterm><primary>PQfinish</></></term>
     <listitem>
      <para>
<!--
       Closes  the  connection to the server.  Also frees
       memory used by the <structname>PGconn</structname> object.
-->
サーバとの接続を閉ざします。
また、<structname>PGconn</structname>オブジェクトが占めるメモリも解放します。
<synopsis>
void PQfinish(PGconn *conn);
</synopsis>
      </para>

      <para>
<!--
       Note that even if the server connection attempt fails (as
       indicated by <function>PQstatus</function>), the application should call <function>PQfinish</function>
       to free the memory used by the <structname>PGconn</structname> object.
       The <structname>PGconn</> pointer must not be used again after
       <function>PQfinish</function> has been called.
-->
たとえサーバへの接続試行が失敗しても（<function>PQstatus</function>で調べます）、アプリケーションは<function>PQfinish</function>を呼び出し<structname>PGconn</structname>オブジェクトが占めるメモリを解放するべきです。
そして<function>PQfinish</function>を呼び出したら、もう<structname>PGconn</structname>へのポインタを使ってはいけません。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqreset">
     <term><function>PQreset</function><indexterm><primary>PQreset</></></term>
     <listitem>
      <para>
<!--
       Resets the communication channel to the server.
-->
サーバへの通信チャンネルをリセットします。
<synopsis>
void PQreset(PGconn *conn);
</synopsis>
      </para>

      <para>
<!--
       This function will close the connection
       to the server and attempt to  reestablish  a  new
       connection to the same server, using all the same
       parameters previously used.  This might be useful for
       error recovery if a working connection is lost.
-->
この関数はサーバへの接続を閉じ、以前使用したパラメータをすべて使用して、同一のサーバへ新しく接続を確立します。
これは、作業中の接続が失われた場合のエラーの修復に役立つでしょう。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqresetstart">
     <term><function>PQresetStart</function><indexterm><primary>PQresetStart</></></term>
     <term><function>PQresetPoll</function><indexterm><primary>PQresetPoll</></></term>
     <listitem>
      <para>
<!--
       Reset the communication channel to the server, in a nonblocking manner.
-->
非ブロッキング方式で、サーバへの接続チャンネルをリセットします。

<synopsis>
int PQresetStart(PGconn *conn);

PostgresPollingStatusType PQresetPoll(PGconn *conn);
</synopsis>
      </para>

      <para>
<!--
       These functions will close the connection to the server and attempt to
       reestablish a new connection to the same server, using all the same
       parameters previously used. This can be useful for error recovery if a
       working connection is lost. They differ from <function>PQreset</function> (above) in that they
       act in a nonblocking manner. These functions suffer from the same
       restrictions as <function>PQconnectStartParams</>, <function>PQconnectStart</>
       and <function>PQconnectPoll</>.
-->
これらの関数はサーバへの接続を閉じ、それから再度、以前使用したパラメータをすべて使用して、同じサーバと新たな接続を確立しようとします。
これらは作業中の接続が失われた場合のエラー修復に役立つでしょう。
<function>PQreset</function>（前述）との違いは、この2つの関数が非ブロック方式で動作することです。
また、これらの関数は<function>PQconnectStartParams</>、<function>PQconnectStart</>および<function>PQconnectPoll</>と同じ制限を受けます。
      </para>

      <para>
<!--
       To initiate a connection reset, call
       <function>PQresetStart</function>. If it returns 0, the reset has
       failed. If it returns 1, poll the reset using
       <function>PQresetPoll</function> in exactly the same way as you
       would create the connection using <function>PQconnectPoll</function>.
-->
接続のリセットを始めるためには<function>PQresetStart</function>を呼び出します。
この関数がゼロを返す場合、リセットに失敗しています。
戻り値が1ならば、<function>PQconnectPoll</function>を使って接続を確立した時とまったく同じに、<function>PQresetPoll</function>を使用してリセットのポーリングを行います。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqpingparams">
     <term><function>PQpingParams</function><indexterm><primary>PQpingParams</></></term>
     <listitem>
      <para>
<!--
       <function>PQpingParams</function> reports the status of the
       server.  It accepts connection parameters identical to those of
       <function>PQconnectdbParams</>, described above.  It is not
       necessary to supply correct user name, password, or database name
       values to obtain the server status; however, if incorrect values
       are provided, the server will log a failed connection attempt.
-->
<function>PQpingParams</function>はサーバの状態を報告します。
この関数は上述の<function>PQconnectdbParams</>と同じ接続パラメータを受け付けます。
サーバの状態を得るために正しいユーザ名、パスワード、データベース名を提供する必要はありません。
しかし、不適切な値が供給されると、サーバは不成功に終わった接続の試みをログに残します。

<synopsis>
PGPing PQpingParams(const char * const *keywords,
                    const char * const *values,
                    int expand_dbname);
</synopsis>

<!--
       The function returns one of the following values:
-->
このサーバは以下の値のいずれかを返します。

       <variablelist>
        <varlistentry id="libpq-pqpingparams-pqping-ok">
         <term><literal>PQPING_OK</literal></term>
         <listitem>
          <para>
<!--
           The server is running and appears to be accepting connections.
-->
サーバは稼動中で、接続を受け付けているようです。
          </para>
         </listitem>
        </varlistentry>

        <varlistentry id="libpq-pqpingparams-pqping-reject">
         <term><literal>PQPING_REJECT</literal></term>
         <listitem>
          <para>
<!--
           The server is running but is in a state that disallows connections
           (startup, shutdown, or crash recovery).
-->
サーバは稼動中ですが、接続を許可しない状態（起動処理中、停止処理中、クラッシュリカバリ中）です。
          </para>
         </listitem>
        </varlistentry>

        <varlistentry id="libpq-pqpingparams-pqping-no-response">
         <term><literal>PQPING_NO_RESPONSE</literal></term>
         <listitem>
          <para>
<!--
           The server could not be contacted.  This might indicate that the
           server is not running, or that there is something wrong with the
           given connection parameters (for example, wrong port number), or
           that there is a network connectivity problem (for example, a
           firewall blocking the connection request).
-->
サーバと通信できません。
これは、サーバが稼動中ではない、指定した接続パラメータの何か（例えばポート番号の間違い）が間違っている、ネットワーク接続性の問題（例えば接続要求をブロックするファイアウォール）があることを示しているかもしれません。
          </para>
         </listitem>
        </varlistentry>

        <varlistentry id="libpq-pqpingparams-pqping-no-attempt">
         <term><literal>PQPING_NO_ATTEMPT</literal></term>
         <listitem>
          <para>
<!--
           No attempt was made to contact the server, because the supplied
           parameters were obviously incorrect or there was some client-side
           problem (for example, out of memory).
-->
指定されたパラメータが明らかに間違っている、または、（メモリ不足など）クライアント側の問題があったため、サーバとの通信を試行しませんでした。
          </para>
         </listitem>
        </varlistentry>
       </variablelist>

      </para>

     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqping">
     <term><function>PQping</function><indexterm><primary>PQping</></></term>
     <listitem>
      <para>
<!--
       <function>PQping</function> reports the status of the
       server.  It accepts connection parameters identical to those of
       <function>PQconnectdb</>, described above.  It is not
       necessary to supply correct user name, password, or database name
       values to obtain the server status; however, if incorrect values
       are provided, the server will log a failed connection attempt.
-->
<function>PQping</function>はサーバの状態を報告します。
この関数は上述の<function>PQconnectdb</>と同じ接続パラメータを受け付けます。
サーバの状態を得るために正しいユーザ名、パスワード、データベース名を提供する必要はありません。
しかし、不適切な値が供給されると、サーバは不成功に終わった接続の試みをログに残します。
サーバの状態を入手するためには現在のユーザ名、パスワード、またはデータベース名などの値を供給する必要はありませんが、不適切な値が供給されると、サーバは不成功に終わった接続の試みをログに残します。

<synopsis>
PGPing PQping(const char *conninfo);
</synopsis>
      </para>

      <para>
<!--
       The return values are the same as for <function>PQpingParams</>.
-->
戻り値は<function>PQpingParams</>と同じです。
      </para>

     </listitem>
    </varlistentry>

   </variablelist>
  </para>

  <sect2 id="libpq-connstring">
<!--
   <title>Connection Strings</title>
-->
   <title>接続文字列</title>

   <indexterm zone="libpq-connstring">
    <primary><literal>conninfo</literal></primary>
   </indexterm>

   <indexterm zone="libpq-connstring">
    <primary><literal>URI</literal></primary>
   </indexterm>

   <para>
<!--
    Several <application>libpq</> functions parse a user-specified string to obtain
    connection parameters.  There are two accepted formats for these strings:
    plain <literal>keyword = value</literal> strings
    and <ulink url="http://www.ietf.org/rfc/rfc3986.txt">RFC
    3986</ulink> URIs.
-->
複数の<application>libpq</>関数は、接続パラメータを得るためにユーザが指定した文字列の解析を行います。
この文字列として、普通の<literal>keyword = value</literal>文字列と<ulink url="http://www.ietf.org/rfc/rfc3986.txt">RFC 3986</ulink>のURIという２種類の書式が受け付けられます。
   </para>

   <sect3>
<!--
    <title>Keyword/Value Connection Strings</title>
-->
    <title>キーワード/値形式の接続文字列</title>

   <para>
<!--
    In the first format, each parameter setting is in the form
    <literal>keyword = value</literal>.  Spaces around the equal sign are
    optional. To write an empty value, or a value containing spaces, surround it
    with single quotes, e.g., <literal>keyword = 'a value'</literal>. Single
    quotes and backslashes within
    the value must be escaped with a backslash, i.e., <literal>\'</literal> and
    <literal>\\</literal>.
-->
最初の書式では、各パラメータ設定は<literal>keyword = value</literal>という形式です。
等号記号の前後の空白文字は省略可能です。
空の値を書く、または空白文字を含む値を書くためには、<literal>keyword = 'a value'</literal>のように単一引用符で値を括ります。
値内部の単一引用符とバックスラッシュはバックスラッシュでエスケープしなければなりません。
つまり<literal>\'</literal>と<literal>\\</literal>です。
   </para>

   <para>
<!--
    Example:
-->
以下に例を示します。
<programlisting>
host=localhost port=5432 dbname=mydb connect_timeout=10
</programlisting>
   </para>

   <para>
<!--
    The recognized parameter key words are listed in <xref
    linkend="libpq-paramkeywords">.
-->
有効なパラメータキーワードを<xref linkend="libpq-paramkeywords">に示します。
   </para>
   </sect3>

   <sect3>
<!--
    <title>Connection URIs</title>
-->
    <title>接続URI</title>

   <para>
<!--
   The general form for a connection <acronym>URI</acronym> is:
-->
接続<acronym>URI</acronym>の一般的な形式を以下に示します。
<synopsis>
postgresql://[user[:password]@][netloc][:port][/dbname][?param1=value1&amp;...]
</synopsis>
   </para>

   <para>
<!--
    The <acronym>URI</acronym> scheme designator can be either
    <literal>postgresql://</literal> or <literal>postgres://</literal>.  Each
    of the <acronym>URI</acronym> parts is optional.  The following examples
    illustrate valid <acronym>URI</acronym> syntax uses:
-->
<acronym>URI</acronym>スキーマ指示子は<literal>postgresql://</literal>または<literal>postgres://</literal>のいずれかを取ることができます。
個々の<acronym>URI</acronym>部品は省略可能です。
以下の例で有効な<acronym>URI</acronym>構文の使用例を示します。
<programlisting>
postgresql://
postgresql://localhost
postgresql://localhost:5433
postgresql://localhost/mydb
postgresql://user@localhost
postgresql://user:secret@localhost
postgresql://other@localhost/otherdb?connect_timeout=10&amp;application_name=myapp
</programlisting>
<!--
    Components of the hierarchical part of the <acronym>URI</acronym> can also
    be given as parameters.  For example:
-->
<acronym>URI</acronym>の階層部品の要素をパラメータとして与えることができます。
以下に例を示します。
<programlisting>
postgresql:///mydb?host=localhost&amp;port=5433
</programlisting>
   </para>

   <para>
<!--
    Percent-encoding may be used to include symbols with special meaning in any
    of the <acronym>URI</acronym> parts.
-->
パーセント符号化を使用して、<acronym>URI</acronym>部品のいずれかに特殊な意味を持つ記号を含めることができます。
   </para>

   <para>
<!--
    Any connection parameters not corresponding to key words listed in <xref
    linkend="libpq-paramkeywords"> are ignored and a warning message about them
    is sent to <filename>stderr</filename>.
-->
<xref linkend="libpq-paramkeywords">に示されたキーワードに対応しない接続パラメータは無視され、これに関する警告メッセージが<filename>stderr</filename>に書き出されます。
   </para>

   <para>
<!--
    For improved compatibility with JDBC connection <acronym>URI</acronym>s,
    instances of parameter <literal>ssl=true</literal> are translated into
    <literal>sslmode=require</literal>.
-->
JDBCの接続<acronym>URI</acronym>構文との互換性を高めるために、<literal>ssl=true</literal>パラメータインスタンスは<literal>sslmode=require</literal>に変換されます。
   </para>

   <para>
<!--
    The host part may be either host name or an IP address.  To specify an
    IPv6 host address, enclose it in square brackets:
-->
ホスト部分にはホスト名またはIPアドレスを書くことができます。
IPv6ホストアドレスを指定するためには角括弧で括ります。
<synopsis>
postgresql://[2001:db8::1234]/database
</synopsis>
   </para>

   <para>
<!--
    The host component is interpreted as described for the parameter <xref
    linkend="libpq-connect-host">.  In particular, a Unix-domain socket
    connection is chosen if the host part is either empty or starts with a
    slash, otherwise a TCP/IP connection is initiated.  Note, however, that the
    slash is a reserved character in the hierarchical part of the URI.  So, to
    specify a non-standard Unix-domain socket directory, either omit the host
    specification in the URI and specify the host as a parameter, or
    percent-encode the path in the host component of the URI:
-->
ホスト要素は<xref linkend="libpq-connect-host">で説明したように解釈されます。
具体的には、ホスト部品が空またはスラッシュで始まる場合Unixドメインソケット接続が選択され、さもなければTCP/IP接続で初期化されます。
しかしURIの階層部ではスラッシュが予約された文字であることに注意してください。
このため、標準以外のUnixドメインソケットディレクトリを指定するためには、URIからホスト指定を省き、パラメータとしてホストを指定するか、URIのホスト要素内のパスをパーセントエスケープするかどちらかを行ってください。
<programlisting>
postgresql:///dbname?host=/var/lib/postgresql
postgresql://%2Fvar%2Flib%2Fpostgresql/dbname
</programlisting>
   </para>
   </sect3>
  </sect2>

  <sect2 id="libpq-paramkeywords">
<!--
   <title>Parameter Key Words</title>
-->
   <title>パラメータキーワード</title>

   <para>
<!--
    The currently recognized parameter key words are:
-->
現時点で有効なパラメータのキーワードは以下に示す通りです。

    <variablelist>
     <varlistentry id="libpq-connect-host" xreflabel="host">
      <term><literal>host</literal></term>
      <listitem>
       <para>
<!--
        Name of host to connect to.<indexterm><primary>host name</></>
        If this begins with a slash, it specifies Unix-domain
        communication rather than TCP/IP communication; the value is the
        name of the directory in which the socket file is stored.  The
        default behavior when <literal>host</literal> is not specified
        is to connect to a Unix-domain
        socket<indexterm><primary>Unix domain socket</></> in
        <filename>/tmp</filename> (or whatever socket directory was specified
        when <productname>PostgreSQL</> was built). On machines without
        Unix-domain sockets, the default is to connect to <literal>localhost</>.
-->
接続するホスト名を指定します。
<indexterm><primary>ホスト名</></> この引数をスラッシュで始めた場合、TCP/IPによる通信ではなく、Unixドメインの通信を明示することになります。
その場合、この値はソケットファイルを格納するディレクトリの名前になります。
<literal>host</literal>が指定されなかった場合のデフォルトは、<filename>/tmp</filename>にあるUnixドメインのソケットに接続することです。
<indexterm><primary>Unixドメインソケット</></> （または、<productname>PostgreSQL</>の構築時に指定した別のディレクトリにあるソケットです。）
Unixドメインソケットを持たないマシンにおけるデフォルトは、<literal>localhost</>に接続することです。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-hostaddr" xreflabel="hostaddr">
      <term><literal>hostaddr</literal></term>
      <listitem>
       <para>
<!--
        Numeric IP address of host to connect to.  This should be in the
        standard IPv4 address format, e.g., <literal>172.28.40.9</>.  If
        your machine supports IPv6, you can also use those addresses.
        TCP/IP communication is
        always used when a nonempty string is specified for this parameter.
-->
接続するホストのIPアドレスを指定します。
これは、<literal>172.28.40.9</>といった標準的なIPv4アドレス書式でなければなりません。
使用するマシンでIPv6をサポートする場合は、そのアドレスを使用することもできます。
このパラメータに空以外の文字列が指定されると、TCP/IP通信が常に使用されます。
       </para>

       <para>
<!--
        Using <literal>hostaddr</> instead of <literal>host</> allows the
        application to avoid a host name look-up, which might be important
        in applications with time constraints. However, a host name is
        required for GSSAPI or SSPI authentication
        methods, as well as for <literal>verify-full</> SSL
        certificate verification.  The following rules are used:
-->
<literal>host</>の代わりに<literal>hostaddr</>を使用することで、アプリケーションがホスト名の検索を行なわずに済みます。
特に時間的制約があるアプリケーションでは重要になるでしょう。
しかし、GSSAP、SSPI認証方式では、ホスト名が必要になります。
<literal>verify-full</>SSL証明書検証を行う場合も同様です。
以下の規則が使用されます。
        <itemizedlist>
         <listitem>
          <para>
<!--
           If <literal>host</> is specified without <literal>hostaddr</>,
           a host name lookup occurs.
-->
<literal>hostaddr</>を使わずに<literal>host</>を指定した場合は、ホスト名の検索が発生します。
          </para>
         </listitem>
         <listitem>
          <para>
<!--
           If <literal>hostaddr</> is specified without <literal>host</>,
           the value for <literal>hostaddr</> gives the server network address.
           The connection attempt will fail if the authentication
           method requires a host name.
-->
<literal>host</>を使わずに<literal>hostaddr</>を指定した場合、<literal>hostaddr</>の値はサーバのネットワークアドレスとなります。
認証方式がホスト名を必要する場合は接続試行が失敗します。
          </para>
         </listitem>
         <listitem>
          <para>
<!--
           If both <literal>host</> and <literal>hostaddr</> are specified,
           the value for <literal>hostaddr</> gives the server network address.
           The value for <literal>host</> is ignored unless the
           authentication method requires it, in which case it will be
           used as the host name.
-->
<literal>host</>と<literal>hostaddr</>の両方を指定した場合、<literal>hostaddr</>がサーバのネットワークアドレスとなります。
<literal>host</>の値は認証方式で必要とされない限り無視され、必要とされる場合にはホスト名として使用されます。
          </para>
         </listitem>
        </itemizedlist>
<!--
        Note that authentication is likely to fail if <literal>host</>
        is not the name of the server at network address <literal>hostaddr</>.
        Also, note that <literal>host</> rather than <literal>hostaddr</>
        is used to identify the connection in <filename>~/.pgpass</> (see
        <xref linkend="libpq-pgpass">).
-->
<literal>host</>が<literal>hostaddr</>ネットワークアドレスに対応するマシンの名前と一致しない場合は、認証に失敗する可能性があるので注意してください。
また、<literal>hostaddr</>ではなく<literal>host</>が<filename>~/.pgpass</>(<xref linkend="libpq-pgpass">を参照)での接続の識別に使用されます。
       </para>

       <para>
<!--
        Without either a host name or host address,
        <application>libpq</application> will connect using a
        local Unix-domain socket; or on machines without Unix-domain
        sockets, it will attempt to connect to <literal>localhost</>.
-->
ホスト名もホストのアドレスも用いない場合、<application>libpq</application>はローカルのUnixドメインソケットを使用して接続します。
ただし、Unixドメインソケットを持たないマシンでは、<literal>localhost</>への接続を試みます。
       </para>
       </listitem>
      </varlistentry>

      <varlistentry id="libpq-connect-port" xreflabel="port">
       <term><literal>port</literal></term>
       <listitem>
       <para>
<!--
        Port number to connect to at the server host, or socket file
        name extension for Unix-domain
        connections.<indexterm><primary>port</></>
-->
サーバホストでの接続用のポート番号、または、Unixドメイン接続の場合は、ソケットファイルの拡張子を指定します。
<indexterm><primary>port</></>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-dbname" xreflabel="dbname">
      <term><literal>dbname</literal></term>
      <listitem>
      <para>
<!--
       The database name.  Defaults to be the same as the user name.
       In certain contexts, the value is checked for extended
       formats; see <xref linkend="libpq-connstring"> for more details on
       those.
-->
データベース名を指定します。
デフォルトはユーザ名と同じです。
特定の文脈では、この値は拡張書式で検査されます。
詳細については<xref linkend="libpq-connstring">を参照してください。
      </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-user" xreflabel="user">
      <term><literal>user</literal></term>
      <listitem>
      <para>
<!--
       <productname>PostgreSQL</productname> user name to connect as.
       Defaults to be the same as the operating system name of the user
       running the application.
-->
データベースへ接続する<productname>PostgreSQL</productname>ユーザ名を指定します。
デフォルトは、そのアプリケーションを実行しているユーザのオペレーティングシステム上の名前と同じです。
      </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-password" xreflabel="password">
      <term><literal>password</literal></term>
      <listitem>
      <para>
<!--
       Password to be used if the server demands password authentication.
-->
サーバがパスワードによる認証を必要とした場合に使用されるパスワードを指定します。
      </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-connect-timeout" xreflabel="connect_timeout">
      <term><literal>connect_timeout</literal></term>
      <listitem>
      <para>
<!--
       Maximum wait for connection, in seconds (write as a decimal integer
       string). Zero or not specified means wait indefinitely.  It is not
       recommended to use a timeout of less than 2 seconds.
-->
接続用の最大待機時間を秒単位(10進数整数で表した文字列として記述してください)で指定します。
ゼロもしくは未設定は、無限時間の待機を意味します。
2秒未満の待機時間を使用することは勧めません。
      </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-client-encoding" xreflabel="client_encoding">
      <term><literal>client_encoding</literal></term>
      <listitem>
      <para>
<!--
       This sets the <varname>client_encoding</varname>
       configuration parameter for this connection.  In addition to
       the values accepted by the corresponding server option, you
       can use <literal>auto</literal> to determine the right
       encoding from the current locale in the client
       (<envar>LC_CTYPE</envar> environment variable on Unix
       systems).
-->
接続用の<varname>client_encoding</varname>設定パラメータを設定します。
対応するサーバオプションで受け付けられる値の他に、クライアントにおける現在のロケール（Unixシステムの場合は<envar>LC_CTYPE</envar>環境変数）から正しい符号化方式を決定する<literal>auto</literal>を使用することができます。
      </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-options" xreflabel="options">
      <term><literal>options</literal></term>
      <listitem>
       <para>
<!--
        Adds command-line options to send to the server at run-time.
        For example, setting this to <literal>-c geqo=off</> sets the
        session's value of the <varname>geqo</> parameter to
        <literal>off</>.  For a detailed discussion of the available
        options, consult <xref linkend="runtime-config">.
-->
実行時にサーバに送信するコマンドラインオプションを追加します。
例えば、これを<literal>-c geqo=off</>に設定すると、<varname>geqo</>パラメータのセッション値は<literal>off</>になります。
有効なオプションに関する詳細については<xref linkend="runtime-config">を参照してください。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-application-name" xreflabel="application_name">
      <term><literal>application_name</literal></term>
      <listitem>
       <para>
<!--
        Specifies a value for the <xref linkend="guc-application-name">
        configuration parameter.
-->
<xref linkend="guc-application-name">設定パラメータの値を指定します。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-fallback-application-name" xreflabel="fallback_application_name">
      <term><literal>fallback_application_name</literal></term>
      <listitem>
       <para>
<!--
        Specifies a fallback value for the <xref
        linkend="guc-application-name"> configuration parameter.
        This value will be used if no value has been given for
        <literal>application_name</> via a connection parameter or the
        <envar>PGAPPNAME</envar> environment variable.  Specifying
        a fallback name is useful in generic utility programs that
        wish to set a default application name but allow it to be
        overridden by the user.
-->
<xref linkend="guc-application-name">設定パラメータの予備値を指定します。
接続パラメータまたは<envar>PGAPPNAME</envar>環境変数により<literal>application_name</>の値が指定されない場合に、この値が使用されます。
予備の名前を指定することは、デフォルトのアプリケーション名を設定したいが、ユーザにもそれを上書きできるようにしておきたい、一般的なユーティリティプログラムで有用です。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-keepalives" xreflabel="keepalives">
      <term><literal>keepalives</literal></term>
      <listitem>
       <para>
<!--
        Controls whether client-side TCP keepalives are used. The default
        value is 1, meaning on, but you can change this to 0, meaning off,
        if keepalives are not wanted.  This parameter is ignored for
        connections made via a Unix-domain socket.
-->
クライアント側におけるTCPキープアライブの使用を制御します。
デフォルト値は1であり、有効であることを意味します。
しかしキープアライブを望まない場合は、無効であることを意味するゼロに設定することができます。
このパラメータはUnixドメインソケット経由の接続では無視されます。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-keepalives-idle" xreflabel="keepalives_idle">
      <term><literal>keepalives_idle</literal></term>
      <listitem>
       <para>
<!--
        Controls the number of seconds of inactivity after which TCP should
        send a keepalive message to the server.  A value of zero uses the
        system default. This parameter is ignored for connections made via a
        Unix-domain socket, or if keepalives are disabled. It is only supported
        on systems where the <symbol>TCP_KEEPIDLE</> or <symbol>TCP_KEEPALIVE</>
        socket option is available, and on Windows; on other systems, it has no
        effect.
-->
TCPがサーバにキープアライブメッセージを送信した後に活動を行わない期間を秒単位で制御します。
ゼロという値ではシステムのデフォルトを使用します。
Unixドメインソケット経由でなされた接続の場合もしくはキープアライブが無効な場合、このパラメータは無視されます。
これは<symbol>TCP_KEEPIDLE</symbol>ソケットオプションまたは<symbol>TCP_KEEPALIVE</>ソケットオプションが利用できるシステムおよびWindowsでのみサポートされます。
他のシステムでは効果がありません。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-keepalives-interval" xreflabel="keepalives_interval">
      <term><literal>keepalives_interval</literal></term>
      <listitem>
       <para>
<!--
        Controls the number of seconds after which a TCP keepalive message
        that is not acknowledged by the server should be retransmitted.  A
        value of zero uses the system default. This parameter is ignored for
        connections made via a Unix-domain socket, or if keepalives are disabled.
        It is only supported on systems where the <symbol>TCP_KEEPINTVL</>
        socket option is available, and on Windows; on other systems, it has no
        effect.
-->
TCPキープアライブメッセージに対する応答がサーバからない場合に、何秒後に再送を行うかを制御します。
ゼロという値ではシステムのデフォルトを使用します。
Unixドメインソケット経由でなされた接続の場合、またはキープアライブを無効にしている場合、このパラメータは無視されます。
これは<symbol>TCP_KEEPINTVL</symbol>ソケットオプションが利用できるシステムおよびWindowsでのみサポートされます。
他のシステムでは効果がありません。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-keepalives-count" xreflabel="keepalives_count">
      <term><literal>keepalives_count</literal></term>
      <listitem>
       <para>
<!--
        Controls the number of TCP keepalives that can be lost before the
        client's connection to the server is considered dead.  A value of
        zero uses the system default. This parameter is ignored for
        connections made via a Unix-domain socket, or if keepalives are disabled.
        It is only supported on systems where the <symbol>TCP_KEEPCNT</>
        socket option is available; on other systems, it has no effect.
-->
サーバへのクライアント接続が不要になったとみなすまで、何回キープアライブの欠落を認めるかを制御します。
ゼロという値ではシステムのデフォルトを使用します。
Unixドメインソケット経由でなされた接続の場合、またはキープアライブを無効にしている場合、このパラメータは無視されます。
これは<symbol>TCP_KEEPCNT</symbol>ソケットオプションが利用できるシステムでのみサポートされます。
他のシステムでは効果がありません。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-tty" xreflabel="tty">
      <term><literal>tty</literal></term>
      <listitem>
      <para>
<!--
       Ignored (formerly, this specified where to send server debug output).
-->
無視されます(以前は、これはサーバデバッグ出力を送信する場所を指定するものでした)。
      </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-sslmode" xreflabel="sslmode">
      <term><literal>sslmode</literal></term>
      <listitem>
       <para>
<!--
        This option determines whether or with what priority a secure
        <acronym>SSL</> TCP/IP connection will be negotiated with the
        server. There are six modes:
-->
このオプションは、どの<acronym>SSL</>による安全なTCP/IP接続の優先度でサーバと調停するかを決定します。
6つのモードがあります。

        <variablelist>
         <varlistentry>
          <term><literal>disable</literal></term>
          <listitem>
           <para>
<!--
            only try a non-<acronym>SSL</> connection
-->
非<acronym>SSL</>接続のみ試行
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>allow</literal></term>
          <listitem>
           <para>
<!--
            first try a non-<acronym>SSL</> connection; if that
            fails, try an <acronym>SSL</> connection
-->
最初に非<acronym>SSL</>接続を試行し、失敗したら、<acronym>SSL</>接続を試行
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
<!--
          <term><literal>prefer</literal> (default)</term>
-->
          <term><literal>prefer</literal> （デフォルト）</term>
          <listitem>
           <para>
<!--
            first try an <acronym>SSL</> connection; if that fails,
            try a non-<acronym>SSL</> connection
-->
最初に<acronym>SSL</>接続を試行し、失敗したら、非<acronym>SSL</>接続を試行
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>require</literal></term>
          <listitem>
           <para>
<!--
            only try an <acronym>SSL</> connection. If a root CA
            file is present, verify the certificate in the same way as
            if <literal>verify-ca</literal> was specified
-->
<acronym>SSL</>接続のみ試行。
ルートCAファイルが存在する場合、<literal>verify-ca</literal>が指定された場合と同じ方法で証明書が検証されます。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>verify-ca</literal></term>
          <listitem>
           <para>
<!--
            only try an <acronym>SSL</> connection, and verify that
            the server certificate is issued by a trusted
            certificate authority (<acronym>CA</>)
-->
<acronym>SSL</>接続のみ試行し、サーバ証明書が信用された認証局（<acronym>CA</>）から発行されたかを検証
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>verify-full</literal></term>
          <listitem>
           <para>
<!--
            only try an <acronym>SSL</> connection, verify that the
            server certificate is issued by a
            trusted <acronym>CA</> and that the server host name
            matches that in the certificate
-->
<acronym>SSL</>接続のみ試行し、サーバ証明書が信用された<acronym>CA</>から発行されたか、およびそのサーバホスト名が証明書内のものと一致するかを検証
           </para>
          </listitem>
         </varlistentry>
        </variablelist>

<!--
        See <xref linkend="libpq-ssl"> for a detailed description of how
        these options work.
-->
これらのオプションがどのように動くのかについては<xref linkend="libpq-ssl">を参照してください。
       </para>

       <para>
<!--
        <literal>sslmode</> is ignored for Unix domain socket
        communication.
        If <productname>PostgreSQL</> is compiled without SSL support,
        using options <literal>require</>, <literal>verify-ca</>, or
        <literal>verify-full</> will cause an error, while
        options <literal>allow</> and <literal>prefer</> will be
        accepted but <application>libpq</> will not actually attempt
        an <acronym>SSL</>
        connection.<indexterm><primary>SSL</><secondary
        sortas="libpq">with libpq</></indexterm>
-->
<literal>sslmode</>はUnixドメインソケット通信では無視されます。
SSLサポートなしで<productname>PostgreSQL</>がコンパイルされた場合に、<literal>require</>、<literal>verify-ca</>、<literal>verify-full</>を使用するとエラーになります。
一方、<literal>allow</>と<literal>prefer</>は使用できますが、実際に<application>libpq</>は<acronym>SSL</>接続を受け付けません。
<indexterm><primary>SSL</><secondary sortas="libpq">libpqでの</></indexterm>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-requiressl" xreflabel="requiressl">
      <term><literal>requiressl</literal></term>
      <listitem>
       <para>
<!--
        This option is deprecated in favor of the <literal>sslmode</>
        setting.
-->
このオプションは<literal>sslmode</>設定を支持する観点から廃止予定になっています。
       </para>

       <para>
<!--
        If set to 1, an <acronym>SSL</acronym> connection to the server
        is required (this is equivalent to <literal>sslmode</>
        <literal>require</>).  <application>libpq</> will then refuse
        to connect if the server does not accept an
        <acronym>SSL</acronym> connection.  If set to 0 (default),
        <application>libpq</> will negotiate the connection type with
        the server (equivalent to <literal>sslmode</>
        <literal>prefer</>).  This option is only available if
        <productname>PostgreSQL</> is compiled with SSL support.
-->
1に設定することで、サーバへの<acronym>SSL</acronym>接続が必要になります
(これは<literal>sslmode</>の<literal>require</>と同じです)。
サーバが<acronym>SSL</acronym>接続を受け付けない場合、<application>libpq</>は接続を拒絶します。
0(デフォルト)に設定することで、サーバと接続形式の調停を行います。
(<literal>sslmode</>の<literal>prefer</>と同じです。)
SSLサポート付きで<productname>PostgreSQL</>をコンパイルした場合にのみ、このオプションが利用できます。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-sslcompression" xreflabel="sslcompression">
      <term><literal>sslcompression</literal></term>
      <listitem>
       <para>
<!--
        If set to 1 (default), data sent over SSL connections will be
        compressed (this requires <productname>OpenSSL</> version
        0.9.8 or later).
        If set to 0, compression will be disabled (this requires
        <productname>OpenSSL</> 1.0.0 or later).
        This parameter is ignored if a connection without SSL is made,
        or if the version of <productname>OpenSSL</> used does not support
        it.
-->
１（デフォルト）に設定することで、SSL接続越えで送信されるデータは圧縮されます（これには<productname>OpenSSL</>バージョン0.9.8以降が必要です）。
０に設定すると、圧縮が無効になります（これには<productname>OpenSSL</>1.0.0以降が必要です）。
このパラメータはSSLが確立していない接続や使用される<productname>OpenSSL</>がサポートしていない場合は無視されます。
       </para>
       <para>
<!--
        Compression uses CPU time, but can improve throughput if
        the network is the bottleneck.
        Disabling compression can improve response time and throughput
        if CPU performance is the limiting factor.
-->
圧縮はCPU処理時間を使用しますが、ネットワークが問題である場合はスループットを改良することができます。
CPU性能が制約要因であれば、圧縮を無効にすることで、応答時間やスループットを改良することができます。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-sslcert" xreflabel="sslcert">
      <term><literal>sslcert</literal></term>
      <listitem>
       <para>
<!--
        This parameter specifies the file name of the client SSL
        certificate, replacing the default
        <filename>~/.postgresql/postgresql.crt</>.
        This parameter is ignored if an SSL connection is not made.
-->
このパラメータは、<filename>~/.postgresql/postgresql.crt</>というデフォルトを置き換えるクライアントSSL証明書のファイル名を指定します。
このパラメータはSSL接続が確立していない場合は無視されます。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-sslkey" xreflabel="sslkey">
      <term><literal>sslkey</literal></term>
      <listitem>
       <para>
<!--
        This parameter specifies the location for the secret key used for
        the client certificate. It can either specify a file name that will
        be used instead of the default
        <filename>~/.postgresql/postgresql.key</>, or it can specify a key
        obtained from an external <quote>engine</> (engines are
        <productname>OpenSSL</> loadable modules).  An external engine
        specification should consist of a colon-separated engine name and
        an engine-specific key identifier.  This parameter is ignored if an
        SSL connection is not made.
-->
このパラメータはクライアント証明書に対して使用される秘密鍵の場所を指定します。
デフォルトの<filename>~/.postgresql/postgresql.key</>の代わりに使用されるファイル名、または外部<quote>エンジン</>（エンジンとは<productname>OpenSSL</>ロード可能なモジュール）から得られるキーを指定することも可能です。
外部エンジンの指定にはコロンで区切ったエンジン名とエンジン特有の鍵識別子を含んでいなければなりません。
SSL接続が確立していない場合このパラメータは無視されます。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-sslrootcert" xreflabel="sslrootcert">
      <term><literal>sslrootcert</literal></term>
      <listitem>
       <para>
<!--
        This parameter specifies the name of a file containing SSL
        certificate authority (<acronym>CA</>) certificate(s).
        If the file exists, the server's certificate will be verified
        to be signed by one of these authorities.  The default is
        <filename>~/.postgresql/root.crt</>.
-->
このパラメータはSSL認証局(<acronym>CA</>)の証明書のファイル名を指定します。
このファイルが存在する場合、サーバ証明書はこれらの認証局の1つで署名されているかどうか検証されます。
デフォルトは<filename>~/.postgresql/root.crt</>です。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-sslcrl" xreflabel="sslcrl">
      <term><literal>sslcrl</literal></term>
      <listitem>
       <para>
<!--
        This parameter specifies the file name of the SSL certificate
        revocation list (CRL).  Certificates listed in this file, if it
        exists, will be rejected while attempting to authenticate the
        server's certificate.  The default is
        <filename>~/.postgresql/root.crl</>.
-->
このパラメータはSSL証明書失効リスト（CRL）のファイル名を指定します。
このファイルに列挙された証明書が存在した場合、それはサーバ証明書を承認しようとする時に拒絶されます。
デフォルトは<filename>~/.postgresql/root.crl</>です。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-requirepeer" xreflabel="requirepeer">
      <term><literal>requirepeer</literal></term>
      <listitem>
       <para>
<!--
        This parameter specifies the operating-system user name of the
        server, for example <literal>requirepeer=postgres</literal>.
        When making a Unix-domain socket connection, if this
        parameter is set, the client checks at the beginning of the
        connection that the server process is running under the specified
        user name; if it is not, the connection is aborted with an error.
        This parameter can be used to provide server authentication similar
        to that available with SSL certificates on TCP/IP connections.
        (Note that if the Unix-domain socket is in
        <filename>/tmp</filename> or another publicly writable location,
        any user could start a server listening there.  Use this parameter
        to ensure that you are connected to a server run by a trusted user.)
        This option is only supported on platforms for which the
        <literal>peer</> authentication method is implemented; see
        <xref linkend="auth-peer">.
-->
このパラメータは、例えば<literal>requirepeer=postgres</literal>のようにサーバのオペレーティングシステムのユーザ名を指定します。
Unixドメインソケット接続を確立する時に、このパラメータが設定された場合、クライアントは接続開始時にサーバプロセスが指定されたユーザ名で稼動しているか検査し、稼動していない場合は接続をエラーとして中断します。
このパラメータは、TCP/IP接続においてSSL証明書で実現するようなサーバ認証を実現するために使用することができます。
（Unixドメインソケットが<filename>/tmp</filename>などの誰にでも書き込むことができる場所にある場合、誰でもそこで接続を監視するサーバを起動できることに注意してください。
信頼できるユーザが起動したサーバに接続することを確実に行うために、このパラメータを使用してください。）
このオプションは<literal>peer</>認証方式が実装されたプラットフォームでのみでサポートされます。
<xref linkend="auth-peer">を参照してください。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-krbsrvname" xreflabel="krbsrvname">
      <term><literal>krbsrvname</literal></term>
      <listitem>
       <para>
<!--
        Kerberos service name to use when authenticating with GSSAPI.
        This must match the service name specified in the server
        configuration for Kerberos authentication to succeed. (See also
        <xref linkend="gssapi-auth">.)
-->
GSSAPIの認証時に使われるKerberosサービス名です。
成功するためには、これはサーバのKerberos認証設定のサービス名と一致していなければなりません。
(<xref linkend="gssapi-auth">も参照してください。)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-gsslib" xreflabel="gsslib">
      <term><literal>gsslib</literal></term>
      <listitem>
       <para>
<!--
        GSS library to use for GSSAPI authentication. Only used on Windows.
        Set to <literal>gssapi</literal> to force libpq to use the GSSAPI
        library for authentication instead of the default SSPI.
-->
GSSAPI認証で使用されるGSSライブラリです。
Windows上のみで使用されます。
libpqの認証がデフォルトのSSPIではなく、強制的にGSSAPIライブラリを使用させるには<literal>gssapi</literal>を設定してください。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-connect-service" xreflabel="service">
      <term><literal>service</literal></term>
      <listitem>
       <para>
<!--
        Service name to use for additional parameters.  It specifies a service
        name in <filename>pg_service.conf</filename> that holds additional connection parameters.
        This allows applications to specify only a service name so connection parameters
        can be centrally maintained. See <xref linkend="libpq-pgservice">.
-->
追加のパラメータ用に使用されるサービス名です。
<filename>pg_service.conf</filename>内の追加的な接続パラメータを保持するサービス名を指定します。
これによりアプリケーションはサービス名だけを指定でき、接続パラメータを集中的に保守できるようになります。
<xref linkend="libpq-pgservice">を参照してください。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </sect2>

 </sect1>

 <sect1 id="libpq-status">
<!--
  <title>Connection Status Functions</title>
-->
  <title>接続状態関数</title>

  <para>
<!--
   These functions can be used to interrogate the status
   of an existing database connection object.
-->
これらの関数を使用して、既存のデータベース接続オブジェクトの状態を調べることができます。
  </para>

  <tip>
   <para>
    <indexterm><primary>libpq-fe.h</></>
    <indexterm><primary>libpq-int.h</></>
<!--
    <application>libpq</application> application programmers should be careful to
    maintain the <structname>PGconn</structname> abstraction.  Use the accessor
    functions described below to get at the contents of <structname>PGconn</structname>.
    Reference to internal <structname>PGconn</structname> fields using
    <filename>libpq-int.h</> is not recommended because they are subject to change
    in the future.
-->
<application>libpq</application>アプリケーションのプログラマは注意して<structname>PGconn</structname>という抽象化を維持してください。
<structname>PGconn</structname>の内容は以下に挙げるアクセス用関数を使って取り出してください。
<structname>PGconn</structname>構造体中のフィールドは将来予告なく変更されることがありますので、<filename>libpq-int.h</>を使用したフィールドの参照は避けてください。
   </para>
  </tip>

  <para>
<!--
   The following functions return parameter values established at connection.
   These values are fixed for the life of the <structname>PGconn</> object.
-->
以下の関数は、接続で確立したパラメータの値を返します。
これらの値は<structname>PGconn</>の存続期間中で固定されます。

   <variablelist>
    <varlistentry id="libpq-pqdb">
     <term>
      <function>PQdb</function>
      <indexterm>
       <primary>PQdb</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
<!--
       Returns the database name of the connection.
-->
接続したデータベース名を返します。
<synopsis>
char *PQdb(const PGconn *conn);
</synopsis>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pquser">
     <term>
      <function>PQuser</function>
      <indexterm>
       <primary>PQuser</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
<!--
       Returns the user name of the connection.
-->
接続したユーザ名を返します。
<synopsis>
char *PQuser(const PGconn *conn);
</synopsis>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqpass">
     <term>
      <function>PQpass</function>
      <indexterm>
       <primary>PQpass</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
<!--
       Returns the password of the connection.
-->
接続したパスワードを返します。
<synopsis>
char *PQpass(const PGconn *conn);
</synopsis>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqhost">
     <term>
      <function>PQhost</function>
      <indexterm>
       <primary>PQhost</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
<!--
       Returns the server host name of the connection.
-->
接続したサーバホスト名を返します。
<synopsis>
char *PQhost(const PGconn *conn);
</synopsis>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqport">
     <term>
      <function>PQport</function>
      <indexterm>
       <primary>PQport</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
<!--
       Returns the port of the connection.
-->
接続したポートを返します。

<synopsis>
char *PQport(const PGconn *conn);
</synopsis>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqtty">
     <term>
      <function>PQtty</function>
      <indexterm>
       <primary>PQtty</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
<!--
       Returns the debug <acronym>TTY</acronym> of the connection.
       (This is obsolete, since the server no longer pays attention
       to the <acronym>TTY</acronym> setting, but the function remains
       for backward compatibility.)
-->
接続のデバッグ用<acronym>TTY</acronym>を返します。
(これは廃れたものです。サーバはもはや<acronym>TTY</acronym>設定を参照しません。
後方互換性のためにこの関数が残っています。)

<synopsis>
char *PQtty(const PGconn *conn);
</synopsis>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqoptions">
     <term>
      <function>PQoptions</function>
      <indexterm>
       <primary>PQoptions</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
<!--
       Returns the command-line options passed in the connection request.
-->
接続要求時に渡されたコマンドラインオプションを返します。
<synopsis>
char *PQoptions(const PGconn *conn);
</synopsis>
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

  <para>
<!--
   The following functions return status data that can change as operations
   are executed on the <structname>PGconn</> object.
-->
以下の関数は、<structname>PGconn</>オブジェクトに対して操作を行うことで変更可能な状態データを返します。

   <variablelist>
    <varlistentry id="libpq-pqstatus">
     <term>
      <function>PQstatus</function>
      <indexterm>
       <primary>PQstatus</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
<!--
       Returns the status of the connection.
-->
接続の状態を返します。
<synopsis>
ConnStatusType PQstatus(const PGconn *conn);
</synopsis>
      </para>

      <para>
<!--
       The status can be one of a number of values.  However, only two of
       these are seen outside of an asynchronous connection procedure:
       <literal>CONNECTION_OK</literal> and
       <literal>CONNECTION_BAD</literal>. A good connection to the database
       has the status <literal>CONNECTION_OK</literal>.  A failed
       connection attempt is signaled by status
       <literal>CONNECTION_BAD</literal>.  Ordinarily, an OK status will
       remain so until <function>PQfinish</function>, but a communications
       failure might result in the status changing to
       <literal>CONNECTION_BAD</literal> prematurely.  In that case the
       application could try to recover by calling
       <function>PQreset</function>.
-->
この状態は多くの値の中の１つとなるはずです。
しかし非同期接続手順の外部からは、その中でたった２つ、<literal>CONNECTION_OK</literal>と<literal>CONNECTION_BAD</literal>だけが現れます。
データベースへの接続に問題がなければ、<literal>CONNECTION_OK</literal>状態になります。
接続に失敗している場合は<literal>CONNECTION_BAD</literal>状態となります。
通常、OK状態は<function>PQfinish</function>まで維持されますが、通信失敗のために早まって<literal>CONNECTION_BAD</literal>になることもあります。
その場合、アプリケーションは<function>PQreset</function>を呼び出して修復を試みることができます。
      </para>

      <para>
<!--
       See the entry for <function>PQconnectStartParams</>, <function>PQconnectStart</>
       and <function>PQconnectPoll</> with regards to other status codes that
       might be returned.
-->
返される可能性があるその他の状態コードについては<function>PQconnectStartParams</>、<function>PQconnectStart</>および<function>PQconnectPoll</>の項目を参照してください。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqtransactionstatus">
     <term>
      <function>PQtransactionStatus</function>
      <indexterm>
       <primary>PQtransactionStatus</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
<!--
       Returns the current in-transaction status of the server.
-->
サーバの現在のトランザクション内部状態を返します。

<synopsis>
PGTransactionStatusType PQtransactionStatus(const PGconn *conn);
</synopsis>

<!--
       The status can be <literal>PQTRANS_IDLE</literal> (currently idle),
       <literal>PQTRANS_ACTIVE</literal> (a command is in progress),
       <literal>PQTRANS_INTRANS</literal> (idle, in a valid transaction block),
       or <literal>PQTRANS_INERROR</literal> (idle, in a failed transaction block).
       <literal>PQTRANS_UNKNOWN</literal> is reported if the connection is bad.
       <literal>PQTRANS_ACTIVE</literal> is reported only when a query
       has been sent to the server and not yet completed.
-->
この状態は、<literal>PQTRANS_IDLE</literal> (現在待機中)、<literal>PQTRANS_ACTIVE</literal> (コマンド実行中)、<literal>PQTRANS_INTRANS</literal> (有効なトランザクションブロック内で待機中)、<literal>PQTRANS_INERROR</literal> (無効なトランザクションブロック内で待機中)となり得ます。
接続に問題がある場合のみ<literal>PQTRANS_UNKNOWN</literal>が報告されます。
サーバへ問い合わせが送信されたが、まだ完了していない場合のみ<literal>PQTRANS_ACTIVE</literal>が報告されます。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqparameterstatus">
     <term>
      <function>PQparameterStatus</function>
      <indexterm>
       <primary>PQparameterStatus</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
<!--
       Looks up a current parameter setting of the server.
-->
サーバの現在のパラメータ設定を検索します。

<synopsis>
const char *PQparameterStatus(const PGconn *conn, const char *paramName);
</synopsis>

<!--
       Certain parameter values are reported by the server automatically at
       connection startup or whenever their values change.
       <function>PQparameterStatus</> can be used to interrogate these settings.
       It returns the current value of a parameter if known, or <symbol>NULL</symbol>
       if the parameter is not known.
-->
あるパラメータ値は、接続開始時に、もしくは、その値が変更された時は常にサーバによって自動的に報告されます。
<function>PQparameterStatus</>はそれらの設定の調査に役立ちます。
パラメータの現在値がわかればその値を、わからない場合は<symbol>NULL</symbol>を返します。
      </para>

      <para>
<!--
       Parameters reported as of the current release include
       <varname>server_version</>,
       <varname>server_encoding</>,
       <varname>client_encoding</>,
       <varname>application_name</>,
       <varname>is_superuser</>,
       <varname>session_authorization</>,
       <varname>DateStyle</>,
       <varname>IntervalStyle</>,
       <varname>TimeZone</>,
       <varname>integer_datetimes</>, and
       <varname>standard_conforming_strings</>.
       (<varname>server_encoding</>, <varname>TimeZone</>, and
       <varname>integer_datetimes</> were not reported by releases before 8.0;
       <varname>standard_conforming_strings</> was not reported by releases
       before 8.1;
       <varname>IntervalStyle</> was not reported by releases before 8.4;
       <varname>application_name</> was not reported by releases before 9.0.)
       Note that
       <varname>server_version</>,
       <varname>server_encoding</> and
       <varname>integer_datetimes</>
       cannot change after startup.
-->
現在のリリースで報告されるパラメータには、<varname>server_version</>、<varname>server_encoding</>、<varname>client_encoding</>、<varname>application_name</>、<varname>is_superuser</>、<varname>session_authorization</>、<varname>DateStyle</>、<varname>IntervalStyle</>、<varname>TimeZone</>、<varname>integer_datetimes</>および<varname>standard_conforming_strings</>があります。
（8.0より前では<varname>server_encoding</>、<varname>TimeZone</>および<varname>integer_datetimes</>が、8.1より前では<literal>standard_conforming_strings</>が、そして8.4より前では<varname>IntervalStyle</>が、9.0より前では<varname>application_name</>が報告されませんでした。 ）
<varname>server_version</>、<varname>server_encoding</>および<varname>integer_datetimes</>は起動後変更できないことに注意してください。
      </para>

      <para>
<!--
       Pre-3.0-protocol servers do not report parameter settings, but
       <application>libpq</> includes logic to obtain values for
       <varname>server_version</> and <varname>client_encoding</> anyway.
       Applications are encouraged to use <function>PQparameterStatus</>
       rather than <foreignphrase>ad hoc</> code to determine these values.
       (Beware however that on a pre-3.0 connection, changing
       <varname>client_encoding</> via <command>SET</> after connection
       startup will not be reflected by <function>PQparameterStatus</>.)
       For <varname>server_version</>, see also
       <function>PQserverVersion</>, which returns the information in a
       numeric form that is much easier to compare against.
-->
プロトコル3.0より前のサーバはパラメータ設定を報告しません。
しかし、<application>libpq</>には<varname>server_version</>と<varname>client_encoding</>の値を取り出す仕組みがとりあえずあります。
アプリケーションは、<foreignphrase>付け焼き刃な</>コードでこれらの値を決定するのではなく、<function>PQparameterStatus</>を使用することが求められています。
(しかし、3.0より前の接続では、接続開始後に<command>SET</>による<varname>client_encoding</>の変更は<function>PQparameterStatus</>に反映されないことに注意してください。)
<varname>server_version</>については、この情報をより比較し易い数値形式で返す<function>PQserverVersion</>も参照してください。
      </para>

      <para>
<!--
       If no value for <varname>standard_conforming_strings</> is reported,
       applications can assume it is <literal>off</>, that is, backslashes
       are treated as escapes in string literals.  Also, the presence of
       this parameter can be taken as an indication that the escape string
       syntax (<literal>E'...'</>) is accepted.
-->
<varname>standard_conforming_strings</>の値がないと報告された場合、アプリケーションは<literal>off</>と推測することができます。
つまり、バックスラッシュは文字リテラル中のエスケープ文字として扱います。
また、このパラメータが存在すると、エスケープ文字構文(<literal>E'...'</>)が受付けられることを意味するものと取られます。
      </para>

      <para>
<!--
       Although the returned pointer is declared <literal>const</>, it in fact
       points to mutable storage associated with the <literal>PGconn</> structure.
       It is unwise to assume the pointer will remain valid across queries.
-->
返されるポインタは<literal>const</>と宣言されていますが、実際には<literal>PGconn</>構造体に関連付けされた変化する領域を指し示します。
このポインタが諸問い合わせに渡って有効なままであるとみなすのは賢明ではありません。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqprotocolversion">
     <term>
      <function>PQprotocolVersion</function>
      <indexterm>
       <primary>PQprotocolVersion</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
<!--
       Interrogates the frontend/backend protocol being used.
-->
使用されるフロントエンド/バックエンドプロトコルを調査します。
<synopsis>
int PQprotocolVersion(const PGconn *conn);
</synopsis>
<!--
       Applications might wish to use this function to determine whether certain
       features are supported.  Currently, the possible values are 2 (2.0
       protocol), 3 (3.0 protocol), or zero (connection bad).  The
       protocol version will
       not change after connection startup is complete, but it could
       theoretically change during a connection reset.  The 3.0 protocol
       will normally be used when communicating with
       <productname>PostgreSQL</> 7.4 or later servers; pre-7.4 servers
       support only protocol 2.0.  (Protocol 1.0 is obsolete and not
       supported by <application>libpq</application>.)
-->
ある機能がサポートされているかどうかを決定するために、アプリケーションはこの関数を使用することができます。
現在、取り得る値は2(2.0プロトコル)、3(3.0プロトコル)、あるいは0(接続不良)です。
このプロトコルバージョンは接続の開始が完了した後で変更することはできません。
しかし、理論的には接続のリセット時に変更可能です。
<productname>PostgreSQL</> 7.4以降での通信時、通常3.0プロトコルが使用されます。
7.4より前のサーバでは2.0プロトコルのみをサポートします。
(1.0プロトコルは廃止され、<application>libpq</application>ではサポートされていません。)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqserverversion">
     <term>
      <function>PQserverVersion</function>
      <indexterm>
       <primary>PQserverVersion</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
<!--
       Returns an integer representing the backend version.
-->
バックエンドのバージョンの整数表現を返します。
<synopsis>
int PQserverVersion(const PGconn *conn);
</synopsis>
<!--
       Applications might use this function to determine the version of the database
       server they are connected to. The number is formed by converting
       the major, minor, and revision numbers into two-decimal-digit
       numbers and appending them together. For example, version 8.1.5
       will be returned as 80105, and version 8.2 will be returned as
       80200 (leading zeroes are not shown).  Zero is returned if the
       connection is bad.
-->
この関数を使用してアプリケーションは接続したデータベースサーバのバージョンを決定することができます。
この数値の形式は、メジャー、マイナー、リビジョン番号を2桁の10進数に変換し、連結させたものです。
例えば、バージョン8.1.5では80105を返し、バージョン8.2では80200を返します。
（先頭の0は現れません。）
接続不良の場合は0が返されます。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqerrormessage">
     <term>
      <function>PQerrorMessage</function>
      <indexterm>
       <primary>PQerrorMessage</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
<!--
       <indexterm><primary>error message</></> Returns the error message
       most recently generated by an operation on the connection.
-->

       <indexterm><primary>エラーメッセージ</></>
接続における操作において、最も最近に生成されたエラーメッセージを返します。
<synopsis>
char *PQerrorMessage(const PGconn *conn);
</synopsis>

      </para>

      <para>
<!--
       Nearly all <application>libpq</> functions will set a message for
       <function>PQerrorMessage</function> if they fail.  Note that by
       <application>libpq</application> convention, a nonempty
       
       <function>PQerrorMessage</function> result can consist of multiple lines,
       and will include a trailing newline. The caller should not free
       the result directly. It will be freed when the associated
       <structname>PGconn</> handle is passed to
       <function>PQfinish</function>.  The result string should not be
       expected to remain the same across operations on the
       <literal>PGconn</> structure.
-->
ほとんどすべての<application>libpq</>関数は、失敗時に<function>PQerrorMessage</function>用のメッセージを設定します。
<application>libpq</>での決まりとして、空でない<function>PQerrorMessage</function>の結果は複数行に渡ることも可能で、最後に改行が含まれることがある点に注意してください。
呼び出し元はこの結果を直接解放してはいけません。
関連する<structname>PGconn</>ハンドルが<function>PQfinish</function>に渡された時にこれは解放されます。
<literal>PGconn</>構造体への操作を跨って、この結果文字列が同一であると想定してはいけません。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqsocket">
     <term><function>PQsocket</function><indexterm><primary>PQsocket</></></term>
     <listitem>
      <para>
<!--
       Obtains the file descriptor number of the connection socket to
       the server.  A valid descriptor will be greater than or equal
       to 0; a result of -1 indicates that no server connection is
       currently open.  (This will not change during normal operation,
       but could change during connection setup or reset.)
-->
サーバとの接続ソケットに対するファイル記述子番号を得ます。   
有効な記述子なら値は0以上です。 
-1の場合は、サーバとの接続がまだ開いていないことを示します。
(これは通常の操作では変更することはできません。
接続設定中やリセット中に変更されます。)

<synopsis>
int PQsocket(const PGconn *conn);
</synopsis>

      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqbackendpid">
     <term><function>PQbackendPID</function><indexterm><primary>PQbackendPID</></></term>
     <listitem>
      <para>
<!--
       Returns the process <acronym>ID</acronym> (PID)<indexterm>
        <primary>PID</>
        <secondary>determining PID of server process</>
        <tertiary>in libpq</>
       </indexterm>
       of the backend process handling this connection.
-->
接続を処理するバックエンドのプロセス<acronym>ID</acronym>(PID)を返します。
<indexterm><primary>PID</><secondary>サーバプロセスのPIDの決定</><tertiary>libpqにおける</></>

<synopsis>
int PQbackendPID(const PGconn *conn);
</synopsis>
      </para>

      <para>
<!--
       The backend <acronym>PID</acronym> is useful for debugging
       purposes and for comparison to <command>NOTIFY</command>
       messages (which include the <acronym>PID</acronym> of the
       notifying backend process).  Note that the
       <acronym>PID</acronym> belongs to a process executing on the
       database server host, not the local host!
-->
バックエンドの<acronym>PID</acronym>は、デバッグする場合や<command>NOTIFY</command>メッセージ（これは通知を発行したバックエンドプロセスの<acronym>PID</acronym>を含んでいます）の比較に便利です。
この<acronym>PID</acronym>はデータベースサーバホスト上で実行されているプロセスのものであり、ローカルホスト側のものではありません！ 
注意してください。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqconnectionneedspassword">
     <term><function>PQconnectionNeedsPassword</function><indexterm><primary>PQconnectionNeedsPassword</></></term>
     <listitem>
      <para>
<!--
       Returns true (1) if the connection authentication method
       required a password, but none was available.
       Returns false (0) if not.
-->
接続認証方式がパスワードを要求し、利用可能なパスワードがない場合真（1）を返します。
さもなくば偽（0）を返します。

<synopsis>
int PQconnectionNeedsPassword(const PGconn *conn);
</synopsis>

      </para>

      <para>
<!--
       This function can be applied after a failed connection attempt
       to decide whether to prompt the user for a password.
-->
この関数を、接続試行に失敗した後でユーザにパスワード入力を促すかどうかを決定するために適用することができます。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqconnectionusedpassword">
     <term><function>PQconnectionUsedPassword</function><indexterm><primary>PQconnectionUsedPassword</></></term>
     <listitem>
      <para>
<!--
       Returns true (1) if the connection authentication method
       used a password. Returns false (0) if not.
-->
接続認証方式でパスワードを使用する場合は真（1）、さもなくば偽（0）を返します。

<synopsis>
int PQconnectionUsedPassword(const PGconn *conn);
</synopsis>

      </para>

      <para>
<!--
       This function can be applied after either a failed or successful
       connection attempt to detect whether the server demanded a password.
-->
この関数は、接続の試みが失敗したか成功したかの後に、サーバがパスワードを要求したかどうかを検出するために適用できます。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqgetssl">
     <term><function>PQgetssl</function><indexterm><primary>PQgetssl</></></term>
     <listitem>
      <para>
<!--
       <indexterm><primary>SSL</><secondary sortas="libpq">in libpq</secondary></indexterm>
-->
       <indexterm><primary>SSL</><secondary sortas="libpq">libpqにおける</secondary></indexterm>
<!--
       Returns the SSL structure used in the connection, or null
       if SSL is not in use.
-->
接続で使用されているSSL構造体を返します。 
SSLが使用されていない場合はヌルを返します。

<synopsis>
void *PQgetssl(const PGconn *conn);
</synopsis>
      </para>

      <para>
<!--
       This structure can be used to verify encryption levels, check server
       certificates, and more. Refer to the <productname>OpenSSL</>
       documentation for information about this structure.
-->
この構造体は暗号化レベルの検証やサーバ証明書の検査などに役立ちます。
この構造体については<productname>OpenSSL</>の文書を参照してください。
      </para>

      <para>
<!--
       The actual return value is of type <type>SSL *</type>,
       where <type>SSL</type> is a type defined by
       the <productname>OpenSSL</productname> library, but it is not declared
       this way to avoid requiring the <productname>OpenSSL</productname>
       header files.  To use this function, code along the following lines
       could be used:
-->
実際の返り値は<type>SSL *</type>であって、ここで<type>SSL</type>は<productname>OpenSSL</productname>ライブラリで定義された型です。しかし<productname>OpenSSL</productname>ヘッダファイルを要求することを回避するためこのように宣言されません。
この関数を使用するためには以下に示す行の並びに従ってコードを書いてください。
<programlisting><![CDATA[
#include <libpq-fe.h>
#include <openssl/ssl.h>

...

    SSL *ssl;

    dbconn = PQconnectdb(...);
    ...

    ssl = PQgetssl(dbconn);
    if (ssl)
    {
]]><!--
        /* use OpenSSL functions to access ssl */
--><![CDATA[
        /* sslにアクセスするためOpenSSLの関数を使う */
    }
]]></programlisting>
      </para>
     </listitem>
    </varlistentry>

   </variablelist>
  </para>

 </sect1>

 <sect1 id="libpq-exec">
<!--
  <title>Command Execution Functions</title>
-->
<title>コマンド実行関数</title>

  <para>
<!--
   Once a connection to a database server has been successfully
   established, the functions described here are used to perform
   SQL queries and commands.
-->
いったんデータベースサーバへの接続の確立が成功すれば、本節で説明する関数を使ってSQLの問い合わせやコマンドを実行します。
  </para>

  <sect2 id="libpq-exec-main">
<!--
   <title>Main Functions</title>
-->
   <title>主要な関数</title>

   <para>
    <variablelist>
     <varlistentry id="libpq-pqexec">
      <term>
       <function>PQexec</function>
       <indexterm>
        <primary>PQexec</primary>
       </indexterm>
      </term>

      <listitem>
       <para>
<!--
        Submits a command to the server and waits for the result.
-->
コマンドをサーバに送信し、結果を待機します。

<synopsis>
PGresult *PQexec(PGconn *conn, const char *command);
</synopsis>
       </para>

       <para>
<!--
        Returns a <structname>PGresult</structname> pointer or possibly a null
        pointer.  A non-null pointer will generally be returned except in
        out-of-memory conditions or serious errors such as inability to send
        the command to the server.  The <function>PQresultStatus</> function
        should be called to check the return value for any errors (including
        the value of a null pointer, in which case it will return
        <symbol>PGRES_FATAL_ERROR</symbol>).  Use
        <function>PQerrorMessage</function> to get more information about such
        errors.
-->
戻り値は<structname>PGresult</structname>へのポインタ、場合によってはヌルポインタです。
メモリ不足の状態、あるいはサーバへのコマンド送信が不可能といった深刻なエラーの場合を除けば、通常非ヌルのポインタが返ります。
<function>PQresultStatus</>関数を呼び出して、何かエラー（ヌルポインタ値を含むエラー。この場合は<symbol>PGRES_FATAL_ERROR</symbol>が返されます）がないか戻り値を検査しなければなりません。
こうしたエラーの詳しい情報は<function>PQerrorMessage</function>で得ることができます。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>

<!--
    The command string can include multiple SQL commands
    (separated by semicolons).  Multiple queries sent in a single
    <function>PQexec</> call are processed in a single transaction, unless
    there are explicit <command>BEGIN</command>/<command>COMMIT</command>
    commands included in the query string to divide it into multiple
    transactions.  Note however that the returned
    <structname>PGresult</structname> structure describes only the result
    of the last command executed from the string.  Should one of the
    commands fail, processing of the string stops with it and the returned
    <structname>PGresult</structname> describes the error condition.
-->
コマンド文字列には(セミコロンで区切った)複数のSQLコマンドを含めることができます。
単一の<function>PQexec</>呼び出しで送信された複数の問い合わせは、単一トランザクションで処理されます。
ただし、問い合わせ文字列内に明示的な<command>BEGIN</command>/<command>COMMIT</command>がある場合は、複数のトランザクションに分離されます。
しかし、返される<structname>PGresult</structname>構造体はその文字列内で最後に実行されたコマンドの結果のみが含まれることに注意してください。
そのコマンドの1つが失敗したとすると、文字列の処理はそこで中断し、エラー条件が含まれる<structname>PGresult</structname>が返されます。
   </para>

   <para>
    <variablelist>
     <varlistentry id="libpq-pqexecparams">
      <term>
       <function>PQexecParams</function>
       <indexterm>
        <primary>PQexecParams</primary>
       </indexterm>
      </term>

      <listitem>
       <para>
<!--
        Submits a command to the server and waits for the result,
        with the ability to pass parameters separately from the SQL
        command text.
-->
サーバにコマンドを送信し、結果を待ちます。
ただし、SQLコマンドテキストとは別にパラメータを渡すことができます。

<synopsis>
PGresult *PQexecParams(PGconn *conn,
                       const char *command,
                       int nParams,
                       const Oid *paramTypes,
                       const char * const *paramValues,
                       const int *paramLengths,
                       const int *paramFormats,
                       int resultFormat);
</synopsis>
       </para>

       <para>
<!--
        <function>PQexecParams</> is like <function>PQexec</>, but offers additional
        functionality: parameter values can be specified separately from the command
        string proper, and query results can be requested in either text or binary
        format.  <function>PQexecParams</> is supported only in protocol 3.0 and later
        connections; it will fail when using protocol 2.0.
-->
<function>PQexecParams</>と<function>PQexec</>は似ていますが、前者は次の機能が追加されています。
パラメータ値をコマンド文字列とは別に適切に指定することができ、また、問い合わせの結果をテキスト書式としてでもバイナリ書式としてでも要求できます。
<function>PQexecParams</>はプロトコル3.0以降でのみサポートされ、プロトコル2.0で使用した場合は失敗します。
       </para>

       <para>
<!--
        The function arguments are:
-->
この関数の引数を以下に示します。

        <variablelist>
         <varlistentry>
          <term><parameter>conn</parameter></term>

          <listitem>
           <para>
<!--
            The connection object to send the command through.
-->
接続オブジェクトです。これを通してコマンドを送信します。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><parameter>command</parameter></term>
          <listitem>
           <para>
<!--
            The SQL command string to be executed. If parameters are used,
            they are referred to in the command string as <literal>$1</>,
            <literal>$2</>, etc.
-->
実行させるSQLコマンド文字列です。
パラメータが使用される場合は、コマンド文字列内で<literal>$1</>、<literal>$2</>などのように参照されます。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><parameter>nParams</parameter></term>
          <listitem>
           <para>
<!--
            The number of parameters supplied; it is the length of the arrays
            <parameter>paramTypes[]</>, <parameter>paramValues[]</>,
            <parameter>paramLengths[]</>, and <parameter>paramFormats[]</>. (The
            array pointers can be <symbol>NULL</symbol> when <parameter>nParams</>
            is zero.)
-->
提供されるパラメータ数です。
これは配列<parameter>paramTypes[]</>、<parameter>paramValues[]</>、<parameter>paramLengths[]</>、<parameter>paramFormats[]</>の要素数です。
（この配列ポインタは、<parameter>nParams</>が0の場合、<symbol>NULL</symbol>とすることができます。）
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><parameter>paramTypes[]</parameter></term>
          <listitem>
           <para>
<!--
            Specifies, by OID, the data types to be assigned to the
            parameter symbols.  If <parameter>paramTypes</> is
            <symbol>NULL</symbol>, or any particular element in the array
            is zero, the server infers a data type for the parameter symbol
            in the same way it would do for an untyped literal string.
-->
パラメータシンボルに代入されるデータ型をOIDで指定したものです。
<parameter>paramTypes</>が<symbol>NULL</symbol>、または、ある配列要素が0の場合、サーバは、型指定のないリテラル文字列に対して行う推定方法と同じ方法を使用して、パラメータシンボルのデータ型を推定します。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><parameter>paramValues[]</parameter></term>
          <listitem>
           <para>
<!--
            Specifies the actual values of the parameters.  A null pointer
            in this array means the corresponding parameter is null;
            otherwise the pointer points to a zero-terminated text string
            (for text format) or binary data in the format expected by the
            server (for binary format).
-->
パラメータの実際の値を指定します。
配列内のヌルポインタは対応するパラメータがNULLであることを意味します。
さもなくば、このポインタはゼロ終端のテキスト文字列（テキスト書式）、または、サーバで想定している書式によるバイナリデータ（バイナリ書式）を指し示します。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><parameter>paramLengths[]</parameter></term>
          <listitem>
           <para>
<!--
            Specifies the actual data lengths of binary-format parameters.
            It is ignored for null parameters and text-format parameters.
            The array pointer can be null when there are no binary parameters.
-->
バイナリ書式のパラメータの実データ長を指定します。
NULLパラメータおよびテキスト書式のパラメータでは無視されます。
バイナリパラメータが存在しない場合、この配列ポインタはヌルとしてもかまいません。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><parameter>paramFormats[]</parameter></term>
          <listitem>
           <para>
<!--
            Specifies whether parameters are text (put a zero in the
            array entry for the corresponding parameter) or binary (put
            a one in the array entry for the corresponding parameter).
            If the array pointer is null then all parameters are presumed
            to be text strings.
-->
パラメータがテキスト（パラメータに対応する配列要素に0を設定）か、バイナリ（パラメータに対応する配列要素に1を設定）かを指定します。
この配列ポインタがヌルの場合、すべてのパラメータはテキスト文字列であると仮定されます。
           </para>
           <para>
<!--
            Values passed in binary format require knowledge of
            the internal representation expected by the backend.
            For example, integers must be passed in network byte
            order.  Passing <type>numeric</> values requires
            knowledge of the server storage format, as implemented
            in
            <filename>src/backend/utils/adt/numeric.c::numeric_send()</> and
            <filename>src/backend/utils/adt/numeric.c::numeric_recv()</>.
-->
バイナリ書式で渡された値は、バックエンドが想定する内部表現の知識を必要とします。
例えば、整数はネットワークバイト順に渡されなければなりません。
<type>numeric</>による値は、<filename>src/backend/utils/adt/numeric.c::numeric_send()</>および<filename>src/backend/utils/adt/numeric.c::numeric_recv()</>で実装されたようにサーバストレージ書式の知識を必要とします。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><parameter>resultFormat</parameter></term>
          <listitem>
           <para>
<!--
            Specify zero to obtain results in text format, or one to obtain
            results in binary format.  (There is not currently a provision
            to obtain different result columns in different formats,
            although that is possible in the underlying protocol.)
-->
結果をテキスト書式で取り出したい場合は0を、バイナリ書式で取り出したい場合は1を指定します。
（現時点では、プロトコル内部では実現可能ですが、結果の列ごとに異なる書式を指定して取り出す機構は存在しません。）
           </para>
          </listitem>
         </varlistentry>
        </variablelist>
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>

   <para>
<!--
    The primary advantage of <function>PQexecParams</> over
    <function>PQexec</> is that parameter values can be separated from the
    command string, thus avoiding the need for tedious and error-prone
    quoting and escaping.
-->
<function>PQexec</>に対する<function>PQexecParams</>の主要な利点は、コマンド文字列とパラメータ値を分離することができることです。
これにより、面倒でエラーを招きやすい引用符付けやエスケープ処理を行なう必要がなくなります。
   </para>

   <para>
<!--
    Unlike <function>PQexec</>, <function>PQexecParams</> allows at most
    one SQL command in the given string.  (There can be semicolons in it,
    but not more than one nonempty command.)  This is a limitation of the
    underlying protocol, but has some usefulness as an extra defense against
    SQL-injection attacks.
-->
<function>PQexec</>と異なり、<function>PQexecParams</>は、文字列内に最大でも1つのSQLコマンドを入れることができます。
（セミコロンを入れることはできますが、空でないコマンドを2つ以上入れることはできません。）
これは、プロトコル自体の制限ですが、SQLインジェクション攻撃に対する追加の防御となりますので、多少役に立ちます。
   </para>

   <tip>
    <para>
<!--
     Specifying parameter types via OIDs is tedious, particularly if you prefer
     not to hard-wire particular OID values into your program.  However, you can
     avoid doing so even in cases where the server by itself cannot determine the
     type of the parameter, or chooses a different type than you want.  In the
     SQL command text, attach an explicit cast to the parameter symbol to show what
     data type you will send.  For example:
-->
OID経由のパラメータ型の指定は、特にプログラムの中で特定のOID値がソースに直接書き込まれることを好まない場合には退屈です。
しかしながら、パラメータの型をサーバ自身で決定できない場合や、望む型と異なる型を選択する場合であっても、これを避けることができます。
SQLコマンドテキストでどのデータ型を送信するかを示すためにパラメータシンボルに明示的なキャストをつけてください。
以下が例です。

<programlisting>
SELECT * FROM mytable WHERE x = $1::bigint;
</programlisting>
<!--
     This forces parameter <literal>$1</> to be treated as <type>bigint</>, whereas
     by default it would be assigned the same type as <literal>x</>.  Forcing the
     parameter type decision, either this way or by specifying a numeric type OID,
     is strongly recommended when sending parameter values in binary format, because
     binary format has less redundancy than text format and so there is less chance
     that the server will detect a type mismatch mistake for you.
-->
デフォルトではパラメータ<literal>$1</>の型は<literal>x</>と同じデータ型に割り当てられますが、これにより強制的に<type>bigint</>として扱われます。
この方法または型のOIDを数字で指定する方法で、パラメータの型を強制的に決定することがバイナリ書式においてパラメータ値を送る時に強く推奨されます。
これは、バイナリ書式はテキスト書式より情報が少なく、そのために、サーバが型の不一致という問題を検出する機会が少なくなるためです。
    </para>
   </tip>

   <para>
    <variablelist>
     <varlistentry id="libpq-pqprepare">
      <term><function>PQprepare</function>
       <indexterm>
        <primary>PQprepare</primary>
       </indexterm>
      </term>

      <listitem>
       <para>
<!--
        Submits a request to create a prepared statement with the
        given parameters, and waits for completion.
-->
指定パラメータを持つプリペアド文の作成要求を送信し、その完了を待ちます。
<synopsis>
PGresult *PQprepare(PGconn *conn,
                    const char *stmtName,
                    const char *query,
                    int nParams,
                    const Oid *paramTypes);
</synopsis>
       </para>

       <para>
<!--
        <function>PQprepare</> creates a prepared statement for later
        execution with <function>PQexecPrepared</>.  This feature allows
        commands that will be used repeatedly to be parsed and planned just
        once, rather than each time they are executed.
        <function>PQprepare</> is supported only in protocol 3.0 and later
        connections; it will fail when using protocol 2.0.
-->
<function>PQprepare</>は、後で<function>PQexecPrepared</>を使用して実行するプリペアド文を作成します。
この機能を使用して、繰り返し使用されるコマンドの解析と計画作成を実行時に毎回行うのではなく、一回のみ行うようにすることができます。
<function>PQprepare</>はプロトコル3.0以降でのみサポートされ、プロトコル2.0を使用している場合は失敗します。
       </para>

       <para>
<!--
        The function creates a prepared statement named
        <parameter>stmtName</> from the <parameter>query</> string, which
        must contain a single SQL command.  <parameter>stmtName</> can be
        <literal>""</> to create an unnamed statement, in which case any
        pre-existing unnamed statement is automatically replaced; otherwise
        it is an error if the statement name is already defined in the
        current session.  If any parameters are used, they are referred
        to in the query as <literal>$1</>, <literal>$2</>, etc.
        <parameter>nParams</> is the number of parameters for which types
        are pre-specified in the array <parameter>paramTypes[]</>.  (The
        array pointer can be <symbol>NULL</symbol> when
        <parameter>nParams</> is zero.) <parameter>paramTypes[]</>
        specifies, by OID, the data types to be assigned to the parameter
        symbols.  If <parameter>paramTypes</> is <symbol>NULL</symbol>,
        or any particular element in the array is zero, the server assigns
        a data type to the parameter symbol in the same way it would do
        for an untyped literal string.  Also, the query can use parameter
        symbols with numbers higher than <parameter>nParams</>; data types
        will be inferred for these symbols as well.  (See
        <function>PQdescribePrepared</function> for a means to find out
        what data types were inferred.)
-->
この関数は<parameter>query</>文字列から<parameter>stmtName</>という名前のプリペアド文を作成します。
<parameter>query</>は単一のSQLコマンドでなければなりません。
<parameter>stmtName</>を<literal>""</>にして、無名の文を作成することができます。
もし、無名の文が既に存在していた場合は自動的に置き換えられます。
その他の場合、文の名前が現在のセッションで既に存在するとエラーになります。
何らかのパラメータが使用される場合、問い合わせ内では<literal>$1</>、<literal>$2</>などで参照します。
<parameter>nParams</>はパラメータ数です。
その型については事前に<parameter>paramTypes[]</>配列で指定されています。
(<parameter>nParams</>がゼロの場合、この配列ポインタは<symbol>NULL</symbol>にすることができます。)
<parameter>paramTypes[]</>は、OIDによりパラメータシンボルに割り当てるデータ型を指定します。
<parameter>paramTypes</>が<symbol>NULL</symbol>の場合、もしくは、配列内の特定要素がゼロの場合、サーバはそのパラメータシンボルに対して、型指定の無いリテラル文字列に対する処理と同等の方法でデータ型を割り当てます。
また、問い合わせでは<parameter>nParams</>より多くのパラメータシンボルを使用することができます。
これらのシンボルに対するデータ型も同様に推測されます。
（どのようなデータ型が推測されるかを検出する手法については<function>PQdescribePrepared</function>を参照してください。）
       </para>

       <para>
<!--
        As with <function>PQexec</>, the result is normally a
        <structname>PGresult</structname> object whose contents indicate
        server-side success or failure.  A null result indicates
        out-of-memory or inability to send the command at all.  Use
        <function>PQerrorMessage</function> to get more information about
        such errors.
-->
<function>PQexec</>同様、結果は通常<structname>PGresult</structname>オブジェクトで、その内容でサーバ側の成功や失敗を示します。
ヌルという結果はメモリ不足や全くコマンドを送信することができなかったことを示します。
こうしたエラーの詳細情報を入手するには<function>PQerrorMessage</function>を使用してください。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>

<!--
    Prepared statements for use with <function>PQexecPrepared</> can also
    be created by executing SQL <xref linkend="sql-prepare">
    statements.  Also, although there is no <application>libpq</>
    function for deleting a prepared statement, the SQL <xref
    linkend="sql-deallocate"> statement
    can be used for that purpose.
-->
<function>PQexecPrepared</>で使用するためのプリペアド文は、<xref linkend="sql-prepare"> SQL文を実行することでも作成可能です。
また、プリペアド文を削除する<application>libpq</>関数はありませんが、この目的のために<xref linkend="sql-deallocate">SQL文を使用することができます。
   </para>

   <para>
    <variablelist>
     <varlistentry id="libpq-pqexecprepared">
      <term>
       <function>PQexecPrepared</function>
       <indexterm>
        <primary>PQexecPrepared</primary>
       </indexterm>
      </term>

      <listitem>
       <para>
<!--
        Sends a request to execute a prepared statement with given
        parameters, and waits for the result.
-->
指定パラメータによるプリペアド文の実行要求を送信し、結果を待ちます。
<synopsis>
PGresult *PQexecPrepared(PGconn *conn,
                         const char *stmtName,
                         int nParams,
                         const char * const *paramValues,
                         const int *paramLengths,
                         const int *paramFormats,
                         int resultFormat);
</synopsis>
       </para>

       <para>
<!--
        <function>PQexecPrepared</> is like <function>PQexecParams</>,
        but the command to be executed is specified by naming a
        previously-prepared statement, instead of giving a query string.
        This feature allows commands that will be used repeatedly to be
        parsed and planned just once, rather than each time they are
        executed.  The statement must have been prepared previously in
        the current session.  <function>PQexecPrepared</> is supported
        only in protocol 3.0 and later connections; it will fail when
        using protocol 2.0.
-->
<function>PQexecPrepared</>と<function>PQexecParams</>は似ていますが、前者では実行されるコマンドは、問い合わせ文字列を与えるのではなく、事前にプリペアド文を指名することで指定されます。
この機能により、繰り返し使用する予定のコマンドを実行する度にではなく、一度だけ解析、計画作成を行うことができます。
この文は現在のセッションで事前に準備されていなければなりません。
<function>PQexecPrepared</>は、プロトコル3.0以降の接続でのみサポートされます。
プロトコル2.0で使用した場合は失敗します。
       </para>

       <para>
<!--
        The parameters are identical to <function>PQexecParams</>, except that the
        name of a prepared statement is given instead of a query string, and the
        <parameter>paramTypes[]</> parameter is not present (it is not needed since
        the prepared statement's parameter types were determined when it was created).
-->
パラメータは、問い合わせ文字列ではなく指定されたプリペアド文の名前を与える点を除き、<function>PQexecParams</>と同じです。
また、<parameter>paramTypes[]</>パラメータは存在しません。
(プリペアド文のパラメータ型はその作成時点で決定されているため、これは不要です。)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-pqdescribeprepared">
      <term>
       <function>PQdescribePrepared</function>
       <indexterm>
        <primary>PQdescribePrepared</primary>
       </indexterm>
      </term>

      <listitem>
       <para>
<!--
        Submits a request to obtain information about the specified
        prepared statement, and waits for completion.
-->
指定したプリペアド文に関する情報入手要求を送り、入手完了まで待機します。

<synopsis>
PGresult *PQdescribePrepared(PGconn *conn, const char *stmtName);
</synopsis>
       </para>

       <para>
<!--
        <function>PQdescribePrepared</> allows an application to obtain
        information about a previously prepared statement.
        <function>PQdescribePrepared</> is supported only in protocol 3.0
        and later connections; it will fail when using protocol 2.0.
-->
<function>PQdescribePrepared</>により、アプリケーションは事前にプリペアド文に関する情報を入手できます。
<function>PQdescribePrepared</>はプロトコル3.0以降の接続でのみサポートされます。
プロトコル2.0で使用すると失敗します。
       </para>

       <para>
<!--
        <parameter>stmtName</> can be <literal>""</> or <symbol>NULL</> to reference
        the unnamed statement, otherwise it must be the name of an existing
        prepared statement.  On success, a <structname>PGresult</> with
        status <literal>PGRES_COMMAND_OK</literal> is returned.  The
        functions <function>PQnparams</function> and
        <function>PQparamtype</function> can be applied to this
        <structname>PGresult</> to obtain information about the parameters
        of the prepared statement, and the functions
        <function>PQnfields</function>, <function>PQfname</function>,
        <function>PQftype</function>, etc provide information about the
        result columns (if any) of the statement.
-->
<parameter>stmtName</>を<literal>""</>または<symbol>NULL</>とすることで、無名の文を参照することができます。
これ以外では、存在するプリペアド文の名前でなければなりません。
成功すると、<literal>PGRES_COMMAND_OK</literal>というステータスの<structname>PGresult</>が返されます。
<function>PQnparams</function>および<function>PQparamtype</function>関数をこの<structname>PGresult</>に適用して、プリペアド文のパラメータに関する情報を得ることができます。
また、<function>PQnfields</function>、<function>PQfname</function>、<function>PQftype</function>関数などを使用して、文の結果列（もしあれば）に関する情報を提供できます。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-pqdescribeportal">
      <term>
       <function>PQdescribePortal</function>
       <indexterm>
        <primary>PQdescribePortal</primary>
       </indexterm>
      </term>

      <listitem>
       <para>
<!--
        Submits a request to obtain information about the specified
        portal, and waits for completion.
-->
指定したポータルに関する情報入手要求を送信し、完了まで待機します。

<synopsis>
PGresult *PQdescribePortal(PGconn *conn, const char *portalName);
</synopsis>
       </para>

       <para>
<!--
        <function>PQdescribePortal</> allows an application to obtain
        information about a previously created portal.
        (<application>libpq</> does not provide any direct access to
        portals, but you can use this function to inspect the properties
        of a cursor created with a <command>DECLARE CURSOR</> SQL command.)
        <function>PQdescribePortal</> is supported only in protocol 3.0
        and later connections; it will fail when using protocol 2.0.
-->
<function>PQdescribePortal</>により、アプリケーションは事前に作成されたポータルの情報を入手することができます。
（<application>libpq</>はポータルへの直接アクセスする方法を提供していませんが、この関数を使用して<command>DECLARE CURSOR</> SQLコマンドで作成したカーソルの属性を確認することができます。）
<function>PQdescribePortal</>はプロトコル3.0以降の接続でのみサポートされます。
プロトコル2.0で使用すると失敗します。
       </para>

       <para>
<!--
        <parameter>portalName</> can be <literal>""</> or <symbol>NULL</> to reference
        the unnamed portal, otherwise it must be the name of an existing
        portal.  On success, a <structname>PGresult</> with status
        <literal>PGRES_COMMAND_OK</literal> is returned.  The functions
        <function>PQnfields</function>, <function>PQfname</function>,
        <function>PQftype</function>, etc can be applied to the
        <structname>PGresult</> to obtain information about the result
        columns (if any) of the portal.
-->
<parameter>portalName</>に<literal>""</>または<symbol>NULL</>を指定して、無名のポータルを参照することができます。
これ以外では、既存のポータルの名前でなければなりません。
成功すると、<literal>PGRES_COMMAND_OK</literal>というステータスの<structname>PGresult</>が返されます。
<function>PQnfields</function>、<function>PQfname</function>、<function>PQftype</function>関数などをこの<structname>PGresult</>に適用して、ポータルの結果列（もしあれば）に関する情報を得ることができます。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>

   <para>
<!--
    The <structname>PGresult</structname><indexterm><primary>PGresult</></>
    structure encapsulates the result returned by the server.
    <application>libpq</application> application programmers should be
    careful to maintain the <structname>PGresult</structname> abstraction.
    Use the accessor functions below to get at the contents of
    <structname>PGresult</structname>.  Avoid directly referencing the
    fields of the <structname>PGresult</structname> structure because they
    are subject to change in the future.
-->
<structname>PGresult</structname>構造体はサーバから返された結果をカプセル化します。
<indexterm><primary>PGresult</></>
<application>libpq</>アプリケーションのプログラマは注意して<structname>PGresult</structname>という抽象化を維持してください。
以下のアクセス用関数を使用して、<structname>PGresult</structname>の内容を取り出してください。
将来の変更に影響されますので、<structname>PGresult</structname>構造体のフィールドを直接参照することは避けてください。

    <variablelist>
     <varlistentry id="libpq-pqresultstatus">
      <term>
       <function>PQresultStatus</function>
       <indexterm>
        <primary>PQresultStatus</primary>
       </indexterm>
      </term>

      <listitem>
       <para>
<!--
        Returns the result status of the command.
-->
コマンドの結果状態を返します。
<synopsis>
ExecStatusType PQresultStatus(const PGresult *res);
</synopsis>
       </para>

       <para>
<!--
        <function>PQresultStatus</function> can return one of the following values:
-->
<function>PQresultStatus</function>は以下のいずれかの値を返します。

        <variablelist>
         <varlistentry id="libpq-pgres-empty-query">
          <term><literal>PGRES_EMPTY_QUERY</literal></term>
          <listitem>
           <para>
<!--
            The string sent to the server was empty.
-->
サーバに送信された文字列が空でした。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pgres-command-ok">
          <term><literal>PGRES_COMMAND_OK</literal></term>
          <listitem>
           <para>
<!--
            Successful completion of a command returning no data.
-->
データを返さないコマンドが正常終了しました。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pgres-tuples-ok">
          <term><literal>PGRES_TUPLES_OK</literal></term>
          <listitem>
           <para>
<!--
            Successful completion of a command returning data (such as
            a <command>SELECT</> or <command>SHOW</>).
-->
データを返すコマンド(<command>SELECT</>や<command>SHOW</>など)が正常終了しました。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pgres-copy-out">
          <term><literal>PGRES_COPY_OUT</literal></term>
          <listitem>
           <para>
<!--
            Copy Out (from server) data transfer started.
-->
(サーバからの)コピーアウトデータ転送が始まりました。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pgres-copy-in">
          <term><literal>PGRES_COPY_IN</literal></term>
          <listitem>
           <para>
<!--
            Copy In (to server) data transfer started.
-->
(サーバへの)コピーインデータ転送が始まりました。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pgres-bad-response">
          <term><literal>PGRES_BAD_RESPONSE</literal></term>
          <listitem>
           <para>
<!--
            The server's response was not understood.
-->
サーバが不明な応答を返しました。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pgres-nonfatal-error">
          <term><literal>PGRES_NONFATAL_ERROR</literal></term>
          <listitem>
           <para>
<!--
            A nonfatal error (a notice or warning) occurred.
-->
致命的ではない(注意喚起もしくは警告)エラーが発生しました。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pgres-fatal-error">
          <term><literal>PGRES_FATAL_ERROR</literal></term>
          <listitem>
           <para>
<!--
            A fatal error occurred.
-->
致命的なエラーが発生しました。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pgres-copy-both">
          <term><literal>PGRES_COPY_BOTH</literal></term>
          <listitem>
           <para>
<!--
            Copy In/Out (to and from server) data transfer started.  This
            feature is currently used only for streaming replication,
            so this status should not occur in ordinary applications.
-->
（サーバからおよびサーバへの）コピーイン/アウトデータ転送が始まりました。
現在こればストリーミングレプリケーションのみで使用されます。
このためこの状態は通常のアプリケーションでは起こりません。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pgres-single-tuple">
          <term><literal>PGRES_SINGLE_TUPLE</literal></term>
          <listitem>
           <para>
<!--
            The <structname>PGresult</> contains a single result tuple
            from the current command.  This status occurs only when
            single-row mode has been selected for the query
            (see <xref linkend="libpq-single-row-mode">).
-->
<structname>PGresult</>には現在のコマンドからの結果タプルが１つ含まれます。
この状態は問い合わせで単一行モードが選択された場合（<xref linkend="libpq-single-row-mode">参照）のみ起こります。
           </para>
          </listitem>
         </varlistentry>
        </variablelist>

<!--
        If the result status is <literal>PGRES_TUPLES_OK</literal> or
        <literal>PGRES_SINGLE_TUPLE</literal>, then
        the functions described below can be used to retrieve the rows
        returned by the query.  Note that a <command>SELECT</command>
        command that happens to retrieve zero rows still shows
        <literal>PGRES_TUPLES_OK</literal>.
        <literal>PGRES_COMMAND_OK</literal> is for commands that can never
        return rows (<command>INSERT</command> or <command>UPDATE</command>
        without a <literal>RETURNING</literal> clause,
        etc.). A response of <literal>PGRES_EMPTY_QUERY</literal> might
        indicate a bug in the client software.
-->
結果状態が<literal>PGRES_TUPLES_OK</literal>または<literal>PGRES_SINGLE_TUPLE</literal>であれば、以下で説明する関数を使って問い合わせが返した行を取り出すことができます。  
ただし、たまたま<command>SELECT</command>コマンドが返す行が０個だったような場合でも<literal>PGRES_TUPLES_OK</literal>となることに注意してください。
<literal>PGRES_COMMAND_OK</literal>は、行を決して返さない(<command>INSERT</command>または<command>UPDATE</command>など<literal>RETURNING</literal>の無い句など)コマンド用です。
<literal>PGRES_EMPTY_QUERY</literal>という応答はクライアントソフトウェアの不具合を示しているかもしれません。
       </para>

       <para>
<!--
        A result of status <symbol>PGRES_NONFATAL_ERROR</symbol> will
        never be returned directly by <function>PQexec</function> or other
        query execution functions; results of this kind are instead passed
        to the notice processor (see <xref
        linkend="libpq-notice-processing">).
-->
<symbol>PGRES_NONFATAL_ERROR</symbol>状態の場合、結果は<function>PQexec</function>や他の問い合わせ実行関数によって直接返されません。
その代わりに、この種の結果は注意喚起プロセッサ(<xref linkend="libpq-notice-processing">参照)に渡されます。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-pqresstatus">
      <term>
       <function>PQresStatus</function>
       <indexterm>
        <primary>PQresStatus</primary>
       </indexterm>
      </term>

      <listitem>
       <para>
<!--
        Converts the enumerated type returned by
        <function>PQresultStatus</> into a string constant describing the
        status code. The caller should not free the result.
-->
<function>PQresultStatus</>が返す列挙型から状態コードを説明する文字列定数に変換します。
呼び出し元はこの結果を解放してはいけません。

<synopsis>
char *PQresStatus(ExecStatusType status);
</synopsis>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-pqresulterrormessage">
      <term>
       <function>PQresultErrorMessage</function>
       <indexterm>
        <primary>PQresultErrorMessage</primary>
       </indexterm>
      </term>

      <listitem>
       <para>
<!--
        Returns the error message associated with the command, or an empty string
        if there was no error.
-->
コマンドに関するエラーメッセージを返します。 
エラーが何もなければ、空の文字列を返します。
<synopsis>
char *PQresultErrorMessage(const PGresult *res);
</synopsis>
<!--
        If there was an error, the returned string will include a trailing
        newline.  The caller should not free the result directly. It will
        be freed when the associated <structname>PGresult</> handle is
        passed to <function>PQclear</function>.
-->
エラーがあった場合、返される文字列の最後には改行が含まれます。
呼び出し元はこの結果を直接解放してはいけません。
関連する<structname>PGresult</>ハンドルが<function>PQclear</function>に渡された時にこれは解放されます。
       </para>

       <para>
<!--
        Immediately following a <function>PQexec</function> or
        <function>PQgetResult</function> call,
        <function>PQerrorMessage</function> (on the connection) will return
        the same string as <function>PQresultErrorMessage</function> (on
        the result).  However, a <structname>PGresult</structname> will
        retain its error message until destroyed, whereas the connection's
        error message will change when subsequent operations are done.
        Use <function>PQresultErrorMessage</function> when you want to
        know the status associated with a particular
        <structname>PGresult</structname>; use
        <function>PQerrorMessage</function> when you want to know the
        status from the latest operation on the connection.
-->
（接続に対する）<function>PQerrorMessage</function>も、<function>PQexec</function>または<function>PQgetResult</function>呼び出しの直後なら（結果に対する）<function>PQresultErrorMessage</function>と同じ文字列を返します。  
しかし、接続に対するエラーメッセージは続いて操作を行うと変化してしまうのに対し、<structname>PGresult</structname>は自身が破棄されるまでそのエラーメッセージを維持し続けます。  
この<function>PQresultErrorMessage</function>は個々の<structname>PGresult</structname>に結び付けられた状態を確認する時に、そして<function>PQerrorMessage</function>は接続における最後の操作の状態を確認する時に使用してください。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-pqresulterrorfield">
      <term><function>PQresultErrorField</function><indexterm><primary>PQresultErrorField</></></term>
      <listitem>
       <para>
<!--
        Returns an individual field of an error report.
-->
エラー報告の個々のフィールドを返します。
<synopsis>
char *PQresultErrorField(const PGresult *res, int fieldcode);
</synopsis>
<!--
        <parameter>fieldcode</> is an error field identifier; see the symbols
        listed below.  <symbol>NULL</symbol> is returned if the
        <structname>PGresult</structname> is not an error or warning result,
        or does not include the specified field.  Field values will normally
        not include a trailing newline. The caller should not free the
        result directly. It will be freed when the
        associated <structname>PGresult</> handle is passed to
        <function>PQclear</function>.
-->
<parameter>fieldcode</>はエラーフィールド識別子です。
以下に示すシンボルを参照してください。
<structname>PGresult</structname>がエラーではない、もしくは、警告付きの結果である場合や指定したフィールドを含まない場合、<symbol>NULL</symbol>が返されます。
通常フィールド値には改行が含まれません。
フィールド値は関連する<structname>PGresult</>ハンドルが<function>PQclear</function>に渡された時に解放されます。
       </para>

       <para>
<!--
        The following field codes are available:
-->
以下のフィールドコードが使用できます。
        <variablelist>
         <varlistentry id="libpq-pg-diag-severity">
          <term><symbol>PG_DIAG_SEVERITY</></term>
          <listitem>
           <para>
<!--
            The severity; the field contents are <literal>ERROR</>,
            <literal>FATAL</>, or <literal>PANIC</> (in an error message),
            or <literal>WARNING</>, <literal>NOTICE</>, <literal>DEBUG</>,
            <literal>INFO</>, or <literal>LOG</> (in a notice message), or
            a localized translation of one of these.  Always present.
-->
深刻度。
このフィールドの内容は(エラーメッセージの場合)<literal>ERROR</>、<literal>FATAL</>、もしくは、<literal>PANIC</>、(注意喚起メッセージの場合)<literal>WARNING</>、<literal>NOTICE</>、<literal>DEBUG</>、<literal>INFO</>、もしくは、<literal>LOG</>です。
これらは、多言語化により翻訳されている可能性があります。
常に存在します。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-sqlstate">
          <term>
           <symbol>PG_DIAG_SQLSTATE</>
          <indexterm>
<!--
           <primary>error codes</primary>
-->
           <primary>エラーコード</primary>
           <secondary>libpq</secondary>
          </indexterm>
          </term>
          <listitem>
           <para>
<!--
            The SQLSTATE code for the error. The SQLSTATE code identifies
            the type of error that has occurred; it can be used by
            front-end applications to perform specific operations (such
            as error handling) in response to a particular database error.
            For a list of the possible SQLSTATE codes, see <xref
            linkend="errcodes-appendix">. This field is not localizable,
            and is always present.
-->
エラーのSQLSTATEコードです。
SQLSTATEコードは発生したエラーの種類を識別します。
フロントエンドアプリケーションにより、特定のデータベースエラーに対して所定の操作（エラー処理など）を行うために使用できます。
起こり得るSQLSTATEコードの一覧については<xref linkend="errcodes-appendix">を参照してください。
このフィールドは多言語化されず、また、常に存在します。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-message-primary">
          <term><symbol>PG_DIAG_MESSAGE_PRIMARY</></term>
          <listitem>
           <para>
<!--
            The primary human-readable error message (typically one line).
            Always present.
-->
可読性を高めた主要エラーメッセージです。
(通常は1行です。)
常に存在します。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-message-detail">
          <term><symbol>PG_DIAG_MESSAGE_DETAIL</></term>
          <listitem>
           <para>
<!--
            Detail: an optional secondary error message carrying more
            detail about the problem.  Might run to multiple lines.
-->
詳細です。
問題に関するより詳細を表す補助的なエラーメッセージです。
複数行に跨る可能性があります。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-message-hint">
          <term><symbol>PG_DIAG_MESSAGE_HINT</></term>
          <listitem>
           <para>
<!--
            Hint: an optional suggestion what to do about the problem.
            This is intended to differ from detail in that it offers advice
            (potentially inappropriate) rather than hard facts.  Might
            run to multiple lines.
-->
ヒントです。
問題の対応方法についての補助的な提言です。
これは、詳細(detail)とは異なり、問題の事象ではなく、(適切でない可能性がありますが)アドバイスを提供することを目的としています。
複数行に跨る可能性があります。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-statement-position">
          <term><symbol>PG_DIAG_STATEMENT_POSITION</></term>
          <listitem>
           <para>
<!--
            A string containing a decimal integer indicating an error cursor
            position as an index into the original statement string.  The
            first character has index 1, and positions are measured in
            characters not bytes.
-->
元の問い合わせ文字列のインデックスとなる、エラーが発生したカーソル位置を示す10進整数を持つ文字列です。
先頭文字がインデックス1となり、また、バイトではなく、文字数で数えた位置です。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-internal-position">
          <term><symbol>PG_DIAG_INTERNAL_POSITION</></term>
          <listitem>
           <para>
<!--
            This is defined the same as the
            <symbol>PG_DIAG_STATEMENT_POSITION</> field, but it is used
            when the cursor position refers to an internally generated
            command rather than the one submitted by the client.  The
            <symbol>PG_DIAG_INTERNAL_QUERY</> field will always appear when
            this field appears.
-->
この定義は<symbol>PG_DIAG_STATEMENT_POSITION</>フィールドと同じです。
しかし、これは、クライアントが発行したコマンドではなく、カーソル位置が内部生成コマンドを参照する場合に使用されます。
このフィールドが存在する時は常に<symbol>PG_DIAG_INTERNAL_QUERY</>フィールドが存在します。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-internal-query">
          <term><symbol>PG_DIAG_INTERNAL_QUERY</></term>
          <listitem>
           <para>
<!--
            The text of a failed internally-generated command.  This could
            be, for example, a SQL query issued by a PL/pgSQL function.
-->
失敗した内部生成コマンドのテキストです。
これは、例えば、PL/pgSQL関数で発行されたSQL問い合わせになります。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-context">
          <term><symbol>PG_DIAG_CONTEXT</></term>
          <listitem>
           <para>
<!--
            An indication of the context in which the error occurred.
            Presently this includes a call stack traceback of active
            procedural language functions and internally-generated queries.
            The trace is one entry per line, most recent first.
-->
エラーが発生した文脈を示すものです。
今の所、これは活動中の手続き言語関数や内部生成問い合わせの呼び出しスタックの追跡情報が含まれます。
この追跡は行単位で1項目であり、その順番は呼び出し順の反対になります。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-schema-name">
          <term><symbol>PG_DIAG_SCHEMA_NAME</></term>
          <listitem>
           <para>
<!--
            If the error was associated with a specific database object,
            the name of the schema containing that object, if any.
-->
そのエラーが特定のデータベースオブジェクトに付随する場合、もしあれば、そのオブジェクトを含むスキーマ名です。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-table-name">
          <term><symbol>PG_DIAG_TABLE_NAME</></term>
          <listitem>
           <para>
<!--
            If the error was associated with a specific table, the name of the
            table.  (Refer to the schema name field for the name of the
            table's schema.)
-->
そのエラーが特定のテーブルに付随する場合のテーブル名です。
（テーブルのスキーマ名についてはスキーマ名フィールドを参照ください。）
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-column-name">
          <term><symbol>PG_DIAG_COLUMN_NAME</></term>
          <listitem>
           <para>
<!--
            If the error was associated with a specific table column, the name
            of the column.  (Refer to the schema and table name fields to
            identify the table.)
-->
そのエラーが特定のテーブル列に付随する場合の列名です。
（テーブルを識別するにはスキーマとテーブル名フィールドを参照ください。）
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-datatype-name">
          <term><symbol>PG_DIAG_DATATYPE_NAME</></term>
          <listitem>
           <para>
<!--
            If the error was associated with a specific data type, the name of
            the data type.  (Refer to the schema name field for the name of
            the data type's schema.)
-->
そのエラーが特定のデータ型に付随する場合のデータ型名です。
（データ型のスキーマ名についてはスキーマ名フィールドを参照ください。）
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-constraint-name">
          <term><symbol>PG_DIAG_CONSTRAINT_NAME</></term>
          <listitem>
           <para>
<!--
            If the error was associated with a specific constraint, the name
            of the constraint.  Refer to fields listed above for the
            associated table or domain.  (For this purpose, indexes are
            treated as constraints, even if they weren't created with
            constraint syntax.)
-->
そのエラーが特定の制約に付随する場合の制約名です。
付随するテーブルまたはドメインについては上記にリストされたフィールドを参照ください。
（この目的のために、制約は制約構文で作成されていなくてもインデックスは制約として扱われます。）
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-source-file">
          <term><symbol>PG_DIAG_SOURCE_FILE</></term>
          <listitem>
           <para>
<!--
            The file name of the source-code location where the error was
            reported.
-->
エラーが報告された場所のソースコードのファイル名です。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-source-line">
          <term><symbol>PG_DIAG_SOURCE_LINE</></term>
          <listitem>
           <para>
<!--
            The line number of the source-code location where the error
            was reported.
-->
エラーが報告された場所のソースコードにおける行番号です。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry id="libpq-pg-diag-source-function">
          <term><symbol>PG_DIAG_SOURCE_FUNCTION</></term>
          <listitem>
           <para>
<!--
            The name of the source-code function reporting the error.
-->
エラーを報告した、ソースコードにおける関数名です。
           </para>
          </listitem>
         </varlistentry>
        </variablelist>
       </para>

       <note>
        <para>
<!--
         The fields for schema name, table name, column name, data type name,
         and constraint name are supplied only for a limited number of error
         types; see <xref linkend="errcodes-appendix">.  Do not assume that
         the presence of any of these fields guarantees the presence of
         another field.  Core error sources observe the interrelationships
         noted above, but user-defined functions may use these fields in other
         ways.  In the same vein, do not assume that these fields denote
         contemporary objects in the current database.
-->
スキーマ名、テーブル名、列名、データ型名、および制約名に対するフィールドは限定的なエラー型に対してのみ提供されます。<xref linkend="errcodes-appendix">を参照ください。
これらのフィールドのいかなる存在もその他のフィールドの存在を保証すると推測してはなりません。
コアエラーの出所は上に記載の相互関係を監視しますが、ユーザ定義関数はこれらフィールドを別目的で使用しているかもしれません。
同様の脈絡で、使用しているデータベースで
これらのフィールドが同時に存在するオブジェクトを意味すると推測してはなりません。
        </para>
       </note>

       <para>
<!--
        The client is responsible for formatting displayed information to meet
        its needs; in particular it should break long lines as needed.
        Newline characters appearing in the error message fields should be
        treated as paragraph breaks, not line breaks.
-->
表示情報の必要に応じた整形はクライアントの責任です。
具体的には、必要に応じて長い行を分割しなければなりません。
エラーメッセージフィールド内の改行文字は、改行としてではなく段落として分かれたものとして取扱うべきです。
       </para>

       <para>
<!--
        Errors generated internally by <application>libpq</application> will
        have severity and primary message, but typically no other fields.
        Errors returned by a pre-3.0-protocol server will include severity and
        primary message, and sometimes a detail message, but no other fields.
-->
<application>libpq</application>で内部的に生成されたエラーは、深刻度と主要メッセージを持ちますが、通常は他のフィールドを持ちません。
3.0より前のプロトコルのサーバで返されるエラーは、深刻度と主要メッセージ、場合によって詳細メッセージを持ちますが、他のフィールドを持ちません。
       </para>

       <para>
<!--
        Note that error fields are only available from
        <structname>PGresult</structname> objects, not
        <structname>PGconn</structname> objects; there is no
        <function>PQerrorField</function> function.
-->
エラーフィールドは<structname>PGresult</structname>からのみ利用でき、<structname>PGconn</structname>からは利用できません。
<function>PQerrorField</function>という関数はありません。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="libpq-pqclear">
      <term><function>PQclear</function><indexterm><primary>PQclear</></></term>
      <listitem>
       <para>
<!--
        Frees  the  storage  associated with a
        <structname>PGresult</structname>.  Every command result should be
        freed via <function>PQclear</function> when it  is  no  longer
        needed.
-->
<structname>PGresult</structname>に割り当てられた記憶領域を解放します。
個々の問い合わせ結果は、必要なくなった時に<function>PQclear</function>で解放するべきです。

<synopsis>
void PQclear(PGresult *res);
</synopsis>
       </para>

       <para>
<!--
        You can keep a <structname>PGresult</structname> object around for
        as long as you need it; it does not go away when you issue a new
        command, nor even if you close the connection.  To get rid of it,
        you must call <function>PQclear</function>.  Failure to do this
        will result in memory leaks in your application.
-->
<structname>PGresult</structname>オブジェクトは必要な間保持することができます。 
新しい問い合わせを発行する場合でも、接続を閉じてしまうまでは<structname>PGresult</structname>は消えません。  
<structname>PGresult</structname>を解放するには、<function>PQclear</function>を呼び出さなくてはいけません。  
その操作に失敗してしまうと、アプリケーションのメモリリークを引き起こしてしまいます。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </sect2>

  <sect2 id="libpq-exec-select-info">
<!--
   <title>Retrieving Query Result Information</title>
-->
  <title>問い合わせ結果の情報の取り出し</title>

   <para>
<!--
    These functions are used to extract information from a
    <structname>PGresult</structname> object that represents a successful
    query result (that is, one that has status
    <literal>PGRES_TUPLES_OK</literal> or <literal>PGRES_SINGLE_TUPLE</>).
    They can also be used to extract
    information from a successful Describe operation: a Describe's result
    has all the same column information that actual execution of the query
    would provide, but it has zero rows.  For objects with other status values,
    these functions will act as though the result has zero rows and zero columns.
-->
これらの関数を使用して、正常終了した問い合わせ結果を示す(つまり、その状態が<literal>PGRES_TUPLES_OK</literal>または<literal>PGRES_SINGLE_TUPLE</>となっている)<structname>PGresult</structname>オブジェクトから情報を抽出することができます。
また、成功したDescribe操作から情報を抽出することもできます。
Describeの結果はすべて、実際に問い合わせを実行した時に提供されるものと同じ列情報を持ちますが、行はありません。
他の状態値を持つオブジェクトでは、これらの関数は、結果が0行0列であるものと同様に動作します。
   </para>

   <variablelist>
    <varlistentry id="libpq-pqntuples">
     <term>
      <function>PQntuples</function>
      <indexterm>
       <primary>PQntuples</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
<!--
       Returns the number of rows (tuples) in the query result.  Because
       it returns an integer result, large result sets might overflow the
       return value on 32-bit operating systems.
-->
問い合わせ結果内の行(タプル)数を返します。
これは整数を結果として返しますので、32ビットオペレーティングシステムでは、大規模な結果セットの戻り値はオーバーフローする可能性があります。

<synopsis>
int PQntuples(const PGresult *res);
</synopsis>

      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqnfields">
     <term>
      <function>PQnfields</function>
      <indexterm>
       <primary>PQnfields</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
<!--
       Returns the number of columns (fields) in each row of the query
       result.
-->
問い合わせ結果の各行の列(フィールド)の数を返します。

<synopsis>
int PQnfields(const PGresult *res);
</synopsis>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqfname">
     <term>
      <function>PQfname</function>
      <indexterm>
       <primary>PQfname</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
<!--
       Returns the column name associated with the given column number.
       Column numbers start at 0. The caller should not free the result
       directly. It will be freed when the associated
       <structname>PGresult</> handle is passed to
       <function>PQclear</function>.
-->
指定した列番号に対応する列の名前を返します。
列番号は0から始まります。
呼び出し元はこの結果を直接解放してはいけません。
関連する<structname>PGresult</>ハンドルが<function>PQclear</function>に渡された時にこれは解放されます。
<synopsis>
char *PQfname(const PGresult *res,
              int column_number);
</synopsis>
      </para>

      <para>
<!--
       <symbol>NULL</symbol> is returned if the column number is out of range.
-->
列番号が範囲外であった場合、<symbol>NULL</symbol>が返ります。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqfnumber">
     <term>
      <function>PQfnumber</function>
      <indexterm>
       <primary>PQfnumber</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
<!--
       Returns the column number associated with the given column name.
-->
指定した列名に関連する列番号を返します。
<synopsis>
int PQfnumber(const PGresult *res,
              const char *column_name);
</synopsis>
      </para>

      <para>
<!--
       -1 is returned if the given name does not match any column.
-->
指定した名前に一致する列がなければ、-1が返ります。
      </para>

      <para>
<!--
       The given name is treated like an identifier in an SQL command,
       that is, it is downcased unless double-quoted.  For example, given
       a query result generated from the SQL command:
-->
指定した名前はSQLコマンドの識別子同様に扱われます。
つまり、二重引用符でくくられていない限り、小文字化されます。
例えば、以下のSQLで生成された問い合わせ結果を考えます。
<programlisting>
SELECT 1 AS FOO, 2 AS "BAR";
</programlisting>
<!--
       we would have the results:
-->
以下により、結果を取り出すことができます。
<programlisting>
PQfname(res, 0)              <lineannotation>foo</lineannotation>
PQfname(res, 1)              <lineannotation>BAR</lineannotation>
PQfnumber(res, "FOO")        <lineannotation>0</lineannotation>
PQfnumber(res, "foo")        <lineannotation>0</lineannotation>
PQfnumber(res, "BAR")        <lineannotation>-1</lineannotation>
PQfnumber(res, "\"BAR\"")    <lineannotation>1</lineannotation>
</programlisting>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqftable">
     <term>
      <function>PQftable</function>
      <indexterm>
       <primary>PQftable</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
<!--
       Returns the OID of the table from which the given column was
       fetched.  Column numbers start at 0.
-->
指定した列の抽出元であるテーブルのOIDを返します。
列番号は0から始まります。
<synopsis>
Oid PQftable(const PGresult *res,
             int column_number);
</synopsis>
      </para>

      <para>
<!--
       <literal>InvalidOid</> is returned if the column number is out of range,
       or if the specified column is not a simple reference to a table column,
       or when using pre-3.0 protocol.
       You can query the system table <literal>pg_class</literal> to determine
       exactly which table is referenced.
-->
列番号が範囲外の場合や指定した列がテーブル列への単純な参照でない場合、3.0より前のプロトコルを使用している場合は、<literal>InvalidOid</>が返されます。
<literal>pg_class</literal>システムテーブルに問い合わせ、どのテーブルが参照されているのかを正確に求めることができます。
      </para>

      <para>
<!--
       The type <type>Oid</type> and the constant
       <literal>InvalidOid</literal> will be defined when you include
       the <application>libpq</application> header file. They will both
       be some integer type.
-->
<application>libpq</application>ヘッダファイルをインクルードすると、<type>Oid</type>型と<literal>InvalidOid</literal>定数が定義されます。
これらは両方とも何らかの整数型です。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqftablecol">
     <term>
      <function>PQftablecol</function>
      <indexterm>
       <primary>PQftablecol</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
<!--
       Returns the column number (within its table) of the column making
       up the specified query result column.  Query-result column numbers
       start at 0, but table columns have nonzero numbers.
-->
指定した問い合わせ結果の列を作成した列の(それが属するテーブル内での)列番号を返します。
問い合わせ結果の列番号は0から始まりますが、テーブル列には0以外の番号が付けられています。
<synopsis>
int PQftablecol(const PGresult *res,
                int column_number);
</synopsis>
      </para>

      <para>
<!--
       Zero is returned if the column number is out of range, or if the
       specified column is not a simple reference to a table column, or
       when using pre-3.0 protocol.
-->
列番号が範囲外の場合や指定した列がテーブル列への単純な参照でなかった場合、3.0より前のプロトコルを使用している場合は、ゼロが返されます。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqfformat">
     <term>
      <function>PQfformat</function>
      <indexterm>
       <primary>PQfformat</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
<!--
       Returns the format code indicating the format of the given
       column.  Column numbers start at 0.
-->
指定した列の書式を示す書式コードを返します。
列番号は0から始まります。
<synopsis>
int PQfformat(const PGresult *res,
              int column_number);
</synopsis>
      </para>

      <para>
<!--
       Format code zero indicates textual data representation, while format
       code one indicates binary representation.  (Other codes are reserved
       for future definition.)
-->
ゼロという書式コードはテキストデータ表現を示し、1という書式コードはバイナリ表現を示します。
(他のコードは将来の定義のために予約されています。)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqftype">
     <term>
      <function>PQftype</function>
      <indexterm>
       <primary>PQftype</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
<!--
       Returns the data type associated with the given  column number.
       The  integer  returned is the internal OID number of the type.
       Column numbers start at 0.
-->
指定した列番号に関連したデータ型を返します。
返された整数はその型の内部的なOID番号です。
列番号は0から始まります。
<synopsis>
Oid PQftype(const PGresult *res,
            int column_number);
</synopsis>
      </para>

      <para>
<!--
       You can query the system table <literal>pg_type</literal> to
       obtain the names and properties of the various data types. The
       <acronym>OID</acronym>s of the built-in data types are defined
       in the file <filename>src/include/catalog/pg_type.h</filename>
       in the source tree.
-->
<literal>pg_type</literal>システムテーブルに問い合わせて、各種データ型の名前や属性を得ることができます。
組み込みデータ型の<acronym>OID</acronym>は、ソースツリー内の<filename>src/include/catalog/pg_type.h</filename>ファイル内で定義されています。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqfmod">
     <term>
      <function>PQfmod</function>
      <indexterm>
       <primary>PQfmod</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
<!--
       Returns  the type modifier of the column associated with the
       given column number.  Column numbers start at 0.
-->
指定した列番号に関連した列の型修飾子を返します。
列番号は0から始まります。
<synopsis>
int PQfmod(const PGresult *res,
           int column_number);
</synopsis>
      </para>

      <para>
<!--
       The interpretation of modifier values is type-specific; they
       typically indicate precision or size limits.  The value -1 is
       used to indicate <quote>no information available</>.  Most data
       types do not use modifiers, in which case the value is always
       -1.
-->
修飾子の値の解釈は型に固有なものです。
通常これらは精度やサイズの制限を示します。
-1という値は<quote>使用できる情報がない</>ことを示します。
ほとんどのデータ型は修飾子を使用しません。
この場合は常に-1という値になります。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqfsize">
     <term>
      <function>PQfsize</function>
      <indexterm>
       <primary>PQfsize</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
<!--
       Returns  the  size  in bytes of the column associated with the
       given column number.  Column numbers start at 0.
-->
指定した列番号に関連した列のバイト単位のサイズを返します。
列番号は0から始まります。
<synopsis>
int PQfsize(const PGresult *res,
            int column_number);
</synopsis>
      </para>

      <para>
<!--
       <function>PQfsize</> returns the space allocated for this column
       in a database row, in other words the size of the server's
       internal representation of the data type.  (Accordingly, it is
       not really very useful to clients.) A negative value indicates
       the data type is variable-length.
-->
<function>PQfsize</>はデータベース行内でその列用に割り当てられる領域を返します。
言い替えると、そのデータ型についてのサーバでの内部表現のサイズです。
(従って、実際にはクライアントから見るとあまり役には立ちません。)
負の値は可変長データ型を示します。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqbinarytuples">
     <term>
      <function>PQbinaryTuples</function>
      <indexterm>
       <primary>PQbinaryTuples</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
<!--
       Returns 1 if the <structname>PGresult</> contains binary data
       and 0 if it contains text data.
-->
<structname>PGresult</>がバイナリデータを持つ場合は1を、テキストデータを持つ場合は0を返します。
<synopsis>
int PQbinaryTuples(const PGresult *res);
</synopsis>
      </para>

      <para>
<!--
       This function is deprecated (except for its use in connection with
       <command>COPY</>), because it is possible for a single
       <structname>PGresult</> to contain text data in some columns and
       binary data in others.  <function>PQfformat</> is preferred.
       <function>PQbinaryTuples</> returns 1 only if all columns of the
       result are binary (format 1).
-->
この関数は廃れたものです。
(<command>COPY</>を行う接続での使用を除きます。)
単一の<structname>PGresult</>で、ある列はテキストデータを持ち、他の列ではバイナリデータを持つことが可能であるためです。
<function>PQfformat</>の利用が推奨されます。
結果のすべての列がバイナリ(書式1)の場合のみ<function>PQbinaryTuples</>は1を返します。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqgetvalue">
     <term>
      <function>PQgetvalue</function>
       <indexterm>
        <primary>PQgetvalue</primary>
       </indexterm>
     </term>

     <listitem>
      <para>
<!--
       Returns a single field value of one row of a
       <structname>PGresult</structname>.  Row and column numbers start
       at 0.  The caller should not free the result directly.  It will
       be freed when the associated <structname>PGresult</> handle is
       passed to <function>PQclear</function>.
-->
<structname>PGresult</structname>の1行における単一フィールドの値を返します。
行番号と列番号は0から始まります。
呼び出し元はこの結果を直接解放してはいけません。
関連する<structname>PGresult</>ハンドルが<function>PQclear</function>に渡された時に、これは解放されます。
<synopsis>
char *PQgetvalue(const PGresult *res,
                 int row_number,
                 int column_number);
</synopsis>
      </para>

      <para>
<!--
       For data in text format, the value returned by
       <function>PQgetvalue</function> is a null-terminated character
       string  representation of the field value.  For data in binary
       format, the value is in the binary representation determined by
       the data type's <function>typsend</> and <function>typreceive</>
       functions.  (The value is actually followed by a zero byte in
       this case too, but that is not ordinarily useful, since the
       value is likely to contain embedded nulls.)
-->
テキスト書式のデータでは、<function>PQgetvalue</function>で返される値はフィールド値のヌル終端の文字列表現となります。
バイナリ書式のデータでは、この値はデータ型の<function>typsend</>関数と<function>typreceive</>関数で決まるバイナリ表現となります。
(実際にはこの場合でも値の終わりにゼロというバイトが付与されます。
しかし、この値の内部には大抵の場合ヌルが埋め込まれていますので、通常このバイトは有用ではありません。)
      </para>

      <para>
<!--
       An empty string is returned if the field value is null.  See
       <function>PQgetisnull</> to distinguish null values from
       empty-string values.
-->
フィールド値がNULLの場合、空文字列が返されます。
NULL値と空文字列という値とを区別する方法は<function>PQgetisnull</>を参照してください。
      </para>

      <para>
<!--
       The pointer returned  by  <function>PQgetvalue</function> points
       to storage that is part of the <structname>PGresult</structname>
       structure.  One should not modify the data it points to, and one
       must explicitly copy the data into other storage if it is to be
       used past the lifetime of the  <structname>PGresult</structname>
       structure itself.
-->
<function>PQgetvalue</function>によって返されるポインタは<structname>PGresult</structname>構造体の一部の格納領域を指し示します。
このポインタが指し示すデータを変更すべきではありません。
また、<structname>PGresult</structname>構造体を解放した後も使用し続ける場合は、データを別の格納領域に明示的にコピーしなければなりません。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqgetisnull">
     <term>
      <function>PQgetisnull</function>
      <indexterm>
       <primary>PQgetisnull</primary>
      </indexterm>
      <indexterm>
<!--
       <primary>null value</primary>
       <secondary sortas="libpq">in libpq</secondary>
-->
       <primary>NULL値</primary>
       <secondary sortas="libpq">libpqにおける</secondary>
      </indexterm>
     </term>

     <listitem>
      <para>
<!--
       Tests a field for a null value.  Row and column numbers start
       at 0.
-->
フィールドがNULL値かどうか検査します。
行番号と列番号は0から始まります。
<synopsis>
int PQgetisnull(const PGresult *res,
                int row_number,
                int column_number);
</synopsis>
      </para>

      <para>
<!--
       This function returns  1 if the field is null and 0 if it
       contains a non-null value.  (Note that
       <function>PQgetvalue</function> will return an empty string,
       not a null pointer, for a null field.)
-->
この関数は、フィールドがNULLの場合に1を、フィールドが非NULL値を持つ場合は0を返します。
(<function>PQgetvalue</function>では、NULLフィールドはヌルポインタではなく空文字列を返すことに注意してください。)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqgetlength">
     <term>
     <function>PQgetlength</function>
     <indexterm>
      <primary>PQgetlength</primary>
     </indexterm></term>

     <listitem>
      <para>
<!--
       Returns the actual length of a field value in bytes.  Row and
       column numbers start at 0.
-->
実際のフィールド値の長さをバイト単位で返します。
行番号と列番号は0から始まります。
<synopsis>
int PQgetlength(const PGresult *res,
                int row_number,
                int column_number);
</synopsis>
      </para>

      <para>
<!--
       This is the actual data length for the particular data value,
       that is, the size of the object pointed to by
       <function>PQgetvalue</function>.  For text data format this is
       the same as <function>strlen()</>.  For binary format this is
       essential information.  Note that one should <emphasis>not</>
       rely on <function>PQfsize</function> to obtain the actual data
       length.
-->
これは特定のデータ値についての実際のデータ長です。
つまり、<function>PQgetvalue</function>によって指し示されるオブジェクトのサイズです。
テキストデータ書式では<function>strlen()</>と同一です。
バイナリ書式ではこれは重要な情報です。
実際のデータ長を取り出すために<function>PQfsize</function>を信用しては<emphasis>なりません</>。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqnparams">
     <term>
      <function>PQnparams</function>
      <indexterm>
       <primary>PQnparams</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
<!--
       Returns the number of parameters of a prepared statement.
-->
プリペアド文のパラメータ数を返します。
<synopsis>
int PQnparams(const PGresult *res);
</synopsis>
      </para>

      <para>
<!--
       This function is only useful when inspecting the result of
       <function>PQdescribePrepared</>.  For other types of queries it
       will return zero.
-->
この関数は<function>PQdescribePrepared</>の結果を確認する時にのみ有用です。
他の種類の問い合わせではゼロを返します。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqparamtype">
     <term>
      <function>PQparamtype</function>
      <indexterm>
       <primary>PQparamtype</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
<!--
       Returns the data type of the indicated statement parameter.
       Parameter numbers start at 0.
-->
指定された文パラメータのデータ型を返します。
パラメータ番号は0から始まります。
<synopsis>
Oid PQparamtype(const PGresult *res, int param_number);
</synopsis>
      </para>

      <para>
<!--
       This function is only useful when inspecting the result of
       <function>PQdescribePrepared</>.  For other types of queries it
       will return zero.
-->
この関数は、<function>PQdescribePrepared</>の結果を確認する時にのみ有用です。
他の種類の問い合わせではゼロを返します。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqprint">
     <term>
      <function>PQprint</function>
      <indexterm>
       <primary>PQprint</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
<!--
       Prints out all the rows and,  optionally,  the column names  to
       the specified output stream.
-->
すべての行と列名(省略可能)を指定した出力ストリームに表示します。
<synopsis>
<!--
void PQprint(FILE *fout,      /* output stream */
             const PGresult *res,
             const PQprintOpt *po);
typedef struct
{
    pqbool  header;      /* print output field headings and row count */
    pqbool  align;       /* fill align the fields */
    pqbool  standard;    /* old brain dead format */
    pqbool  html3;       /* output HTML tables */
    pqbool  expanded;    /* expand tables */
    pqbool  pager;       /* use pager for output if needed */
    char    *fieldSep;   /* field separator */
    char    *tableOpt;   /* attributes for HTML table element */
    char    *caption;    /* HTML table caption */
    char    **fieldName; /* null-terminated array of replacement field names */
} PQprintOpt;
-->
void PQprint(FILE *fout,      /* 出力ストリーム */
             const PGresult *res,
             const PQprintOpt *po);

typedef struct
{
    pqbool  header;      /* フィールドヘッダ情報と行数の表示出力 */
    pqbool  align;       /* 位置揃えのためのフィールドへの埋め込み */
    pqbool  standard;    /* 古い、無くなりそうな書式 */
    pqbool  html3;       /* HTML表出力 */
    pqbool  expanded;    /* 拡張テーブル */
    pqbool  pager;       /* 必要に応じたページャの使用 */
    char    *fieldSep;   /* フィールド区切り文字 */
    char    *tableOpt;   /* HTML表要素の属性 */
    char    *caption;    /* HTML 表の表題 */
    char    **fieldName; /* フィールド名を置き換えるNULL終端の配列 */
} PQprintOpt;
</synopsis>
      </para>

      <para>
<!--
       This function was formerly used by <application>psql</application>
       to print query results, but this is no longer the case.  Note
       that it assumes all the data is in text format.
-->
この関数は以前に問い合わせ結果を表示するために<application>psql</application>で使用されていましたが、今ではもう使用されていません。
これはすべてのデータがテキスト書式であるという前提で動作することに注意してください。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>

  <sect2 id="libpq-exec-nonselect">
<!--
   <title>Retrieving Other Result Information</title>
-->
   <title>他の結果情報の取り出し</title>

   <para>
<!--
    These functions are used to extract other information from
    <structname>PGresult</structname> objects.
-->
これらの関数は<structname>PGresult</structname>オブジェクトからその他の情報を取り出すために使用されます。
   </para>

   <variablelist>
    <varlistentry id="libpq-pqcmdstatus">
     <term>
      <function>PQcmdStatus</function>
      <indexterm>
       <primary>PQcmdStatus</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
<!--
       Returns the command status tag from the SQL command that generated
       the <structname>PGresult</structname>.
-->
<structname>PGresult</structname>を生成したSQLコマンドのコマンド状態タグを返します。
<synopsis>
char *PQcmdStatus(PGresult *res);
</synopsis>
      </para>

      <para>
<!--
       Commonly this is just the name of the command, but it might include
       additional data such as the number of rows processed. The caller
       should not free the result directly. It will be freed when the
       associated <structname>PGresult</> handle is passed to
       <function>PQclear</function>.
-->
これは通常単なるコマンド名ですが、処理行数など追加情報が含まれる場合もあります。
呼び出し元はこの戻り値を直接解放してはいけません。
関連する<structname>PGresult</>ハンドルが<function>PQclear</function>に渡された時にこれは解放されます。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqcmdtuples">
     <term>
      <function>PQcmdTuples</function>
      <indexterm>
       <primary>PQcmdTuples</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
<!--
       Returns the number of rows affected by the SQL command.
-->
SQLコマンドにより影響を受けた行数を返します。
<synopsis>
char *PQcmdTuples(PGresult *res);
</synopsis>
      </para>

      <para>
<!--
       This function returns a string containing the number of rows
       affected by the <acronym>SQL</> statement that generated the
       <structname>PGresult</>. This function can only be used following
       the execution of a <command>SELECT</>, <command>CREATE TABLE AS</>,
       <command>INSERT</>, <command>UPDATE</>, <command>DELETE</>,
       <command>MOVE</>, <command>FETCH</>, or <command>COPY</> statement,
       or an <command>EXECUTE</> of a prepared query that contains an
       <command>INSERT</>, <command>UPDATE</>, or <command>DELETE</> statement.
       If the command that generated the <structname>PGresult</> was anything
       else, <function>PQcmdTuples</> returns an empty string. The caller
       should not free the return value directly. It will be freed when
       the associated <structname>PGresult</> handle is passed to
       <function>PQclear</function>.
-->
この関数は<structname>PGresult</structname>を生成した<acronym>SQL</acronym>コマンドにより影響を受けた行数を含む文字列を返します。
この関数は<command>SELECT</>、<command>CREATE TABLE AS</>、<command>INSERT</>、<command>UPDATE</>、<command>DELETE</command>、<command>MOVE</>、<command>FETCH</>、<command>COPY</>文の実行、あるいは、<command>INSERT</>、<command>UPDATE</>、<command>DELETE</>を含むプリペアド問い合わせの<command>EXECUTE</>文の後でのみ使用することができます。
<structname>PGresult</>を生成したコマンドが他のコマンドであった場合、<function>PQcmdTuples</>は空文字列を返します。
呼び出し元はこの戻り値を直接解放してはいけません。
関連する<structname>PGresult</>ハンドルが<function>PQclear</function>に渡された時にこれは解放されます。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqoidvalue">
     <term>
      <function>PQoidValue</function>
      <indexterm>
       <primary>PQoidValue</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
<!--
       Returns the OID<indexterm><primary>OID</><secondary>in libpq</></>
       of the inserted row, if the <acronym>SQL</> command was an
       <command>INSERT</> that inserted exactly one row into a table that
       has OIDs, or a <command>EXECUTE</> of a prepared query containing
       a suitable <command>INSERT</> statement.  Otherwise, this function
       returns <literal>InvalidOid</literal>. This function will also
       return <literal>InvalidOid</literal> if the table affected by the
       <command>INSERT</> statement does not contain OIDs.
-->
<acronym>SQL</acronym>コマンドが、OIDを持つテーブル内に1行のみを挿入する<command>INSERT</command>だった場合、あるいは、適切な<command>INSERT</>を持つプリペアド問い合わせの<command>EXECUTE</>だった場合に、挿入された行のOIDを返します。
さもなくば<literal>InvalidOid</literal>を返します。
また、<command>INSERT</>文の影響を受けたテーブルがOIDを持たなかった場合、この関数は<literal>InvalidOid</literal>を返します。
<synopsis>
Oid PQoidValue(const PGresult *res);
</synopsis>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqoidstatus">
     <term>
      <function>PQoidStatus</function>
      <indexterm>
       <primary>PQoidStatus</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
<!--
       This function is deprecated in favor of
       <function>PQoidValue</function> and is not thread-safe.
       It returns a string with the OID of the inserted row, while
       <function>PQoidValue</function> returns the OID value.
-->
この関数は<function>PQoidValue</function>のため廃止予定になりました。
またこれはスレッドセーフではありません。
これは挿入された行のOIDを文字列として返します。
一方<function>PQoidValue</function>はOID値を返します。
<synopsis>
char *PQoidStatus(const PGresult *res);
</synopsis>
      </para>

     </listitem>
    </varlistentry>
   </variablelist>

  </sect2>

  <sect2 id="libpq-exec-escape-string">
<!--
   <title>Escaping Strings for Inclusion in SQL Commands</title>
-->
  <title>SQLコマンドに含めるための文字列のエスケープ処理</title>

   <indexterm zone="libpq-exec-escape-string">
<!--
    <primary>escaping strings</primary>
    <secondary>in libpq</secondary>
-->
    <primary>文字列のエスケープ</>
    <secondary>libpqにおける</secondary>
   </indexterm>

   <variablelist>
    <varlistentry id="libpq-pqescapeliteral">
     <term>
      <function>PQescapeLiteral</function>
      <indexterm>
       <primary>PQescapeLiteral</primary>
      </indexterm>
     </term>

     <listitem>
     <para>
<synopsis>
char *PQescapeLiteral(PGconn *conn, const char *str, size_t length);
</synopsis>
     </para>

     <para>
<!--
      <function>PQescapeLiteral</function> escapes a string for
      use within an SQL command.  This is useful when inserting data
      values as literal constants in SQL commands.  Certain characters
      (such as quotes and backslashes) must be escaped to prevent them
      from being interpreted specially by the SQL parser.
      <function>PQescapeLiteral</> performs this operation.
-->
<function>PQescapeLiteral</function>は、SQLコマンド内で使用するために文字列をエスケープします。
これは、SQLコマンド内のリテラル定数としてデータ値を挿入する時に有用です。
特定の文字(引用符やバックスラッシュ)は、SQLパーサによって特殊な解釈がなされないようにエスケープされなければなりません。
<function>PQescapeLiteral</function>はこの操作を行います。
     </para>

     <para>
<!--
      <function>PQescapeLiteral</> returns an escaped version of the
      <parameter>str</parameter> parameter in memory allocated with
      <function>malloc()</>.  This memory should be freed using
      <function>PQfreemem()</> when the result is no longer needed.
      A terminating zero byte is not required, and should not be
      counted in <parameter>length</>.  (If a terminating zero byte is found
      before <parameter>length</> bytes are processed,
      <function>PQescapeLiteral</> stops at the zero; the behavior is
      thus rather like <function>strncpy</>.) The
      return string has all special characters replaced so that they can
      be properly processed by the <productname>PostgreSQL</productname>
      string literal parser.  A terminating zero byte is also added.  The
      single quotes that must surround <productname>PostgreSQL</productname>
      string literals are included in the result string.
-->
<function>PQescapeLiteral</>は<parameter>str</parameter>パラメータをエスケープしたものを<function>malloc()</>で割り当てたメモリ内に返します。
その結果が不要になったら、そのメモリを<function>PQfreemem()</>を使用して解放しなければなりません。
ゼロバイト終端は必要なく、<parameter>length</>に含めて数えてはいけません。
(<parameter>length</>バイトを処理する前にゼロバイト終端が見つかると、<function>PQescapeLiteral</>はそのゼロで終了します。
この動作は<function>strncpy</>と似ています。)
返される文字列では、<productname>PostgreSQL</productname>文字列リテラルパーサで適切に処理することができるように、すべての特殊文字は置換されます。
ゼロバイト終端も追加されます。
<productname>PostgreSQL</productname>の文字列リテラルでは前後に必要となる単一引用符も、その結果文字列には含まれています。
     </para>

     <para>
<!--
      On error, <function>PQescapeLiteral</> returns <symbol>NULL</> and a suitable
      message is stored in the <parameter>conn</> object.
-->
エラー時、<function>PQescapeLiteral</>は<symbol>NULL</>を返し、<parameter>conn</>オブジェクト内に適切なメッセージを残します。
     </para>

     <tip>
      <para>
<!--
       It is especially important to do proper escaping when handling
       strings that were received from an untrustworthy source.
       Otherwise there is a security risk: you are vulnerable to
       <quote>SQL injection</> attacks wherein unwanted SQL commands are
       fed to your database.
-->
信用できない入力元から受けとった文字列を扱う場合に適切なエスケープ処理を行なうことは非常に重要です。
さもなくば、セキュリティ上の危険性が発生します。
<quote>SQLインジェクション</>攻撃という弱点となり、好ましくないSQLコマンドがデータベースに流れてしまいます。
      </para>
     </tip>

     <para>
<!--
      Note that it is not necessary nor correct to do escaping when a data
      value is passed as a separate parameter in <function>PQexecParams</> or
      its sibling routines.
-->
<function>PQexecParams</>または同義のルーチン内で別のパラメータとしてデータ値が渡される場合は、エスケープすることは必要でもなければ正しくもないことに注意してください。
     </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqescapeidentifier">
     <term>
      <function>PQescapeIdentifier</function>
      <indexterm>
       <primary>PQescapeIdentifier</primary>
      </indexterm>
     </term>

     <listitem>
     <para>
<synopsis>
char *PQescapeIdentifier(PGconn *conn, const char *str, size_t length);
</synopsis>
     </para>

     <para>
<!--
      <function>PQescapeIdentifier</function> escapes a string for
      use as an SQL identifier, such as a table, column, or function name.
      This is useful when a user-supplied identifier might contain
      special characters that would otherwise not be interpreted as part
      of the identifier by the SQL parser, or when the identifier might
      contain upper case characters whose case should be preserved.
-->
<function>PQescapeIdentifier</function>は、テーブル、列、関数名などのSQL識別子として使用できるように文字列をエスケープします。
これはユーザが提供した識別子に、そのままではSQLパーサで識別子として解釈されない特殊な文字が含まれる可能性がある場合、または、大文字小文字の違いを維持しなければならない状況で識別子に大文字が含まれる可能性がある場合に有用です。
     </para>

     <para>
<!--
      <function>PQescapeIdentifier</> returns a version of the
      <parameter>str</parameter> parameter escaped as an SQL identifier
      in memory allocated with <function>malloc()</>.  This memory must be
      freed using <function>PQfreemem()</> when the result is no longer
      needed.  A terminating zero byte is not required, and should not be
      counted in <parameter>length</>.  (If a terminating zero byte is found
      before <parameter>length</> bytes are processed,
      <function>PQescapeIdentifier</> stops at the zero; the behavior is
      thus rather like <function>strncpy</>.) The
      return string has all special characters replaced so that it
      will be properly processed as an SQL identifier.  A terminating zero byte
      is also added.  The return string will also be surrounded by double
      quotes.
-->
<function>PQescapeIdentifier</>は<parameter>str</parameter>パラメータをSQL識別子としてエスケープしたものを<function>malloc()</>で割り当てたメモリ内に返します。
その結果が不要になったら、そのメモリを<function>PQfreemem()</>を使用して解放しなければなりません。
ゼロバイト終端は必要なく、<parameter>length</>に含めて数えてはいけません。
(<parameter>length</>バイトを処理する前にゼロバイト終端が見つかると、<function>PQescapeIdentifier</>はそのゼロで終了します。
この動作は<function>strncpy</>と似ています。)
返される文字列では、SQL識別子として適切に処理することができるように、すべての特殊文字は置換されます。
ゼロバイト終端も追加されます。
その結果文字列の前後には二重引用符が付与されます。
     </para>

     <para>
<!--
      On error, <function>PQescapeIdentifier</> returns <symbol>NULL</> and a suitable
      message is stored in the <parameter>conn</> object.
-->
エラー時、<function>PQescapeIdentifier</>は<symbol>NULL</>を返し、<parameter>conn</>オブジェクト内に適切なメッセージを残します。
     </para>

     <tip>
      <para>
<!--
       As with string literals, to prevent SQL injection attacks,
       SQL identifiers must be escaped when they are received from an
       untrustworthy source.
-->
文字列リテラルと同様、SQLインジェクション攻撃を防ぐために、信頼できない入力元から受けとる場合にはSQL識別子をエスケープしなければなりません。
      </para>
     </tip>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqescapestringconn">
     <term>
      <function>PQescapeStringConn</function>
      <indexterm>
       <primary>PQescapeStringConn</primary>
      </indexterm>
     </term>

     <listitem>
     <para>
<synopsis>
size_t PQescapeStringConn(PGconn *conn,
                          char *to, const char *from, size_t length,
                          int *error);
</synopsis>
     </para>

     <para>
<!--
      <function>PQescapeStringConn</> escapes string literals, much like
      <function>PQescapeLiteral</>.  Unlike <function>PQescapeLiteral</>,
      the caller is responsible for providing an appropriately sized buffer.
      Furthermore, <function>PQescapeStringConn</> does not generate the
      single quotes that must surround <productname>PostgreSQL</> string
      literals; they should be provided in the SQL command that the
      result is inserted into.  The parameter <parameter>from</> points to
      the first character of the string that is to be escaped, and the
      <parameter>length</> parameter gives the number of bytes in this
      string.  A terminating zero byte is not required, and should not be
      counted in <parameter>length</>.  (If a terminating zero byte is found
      before <parameter>length</> bytes are processed,
      <function>PQescapeStringConn</> stops at the zero; the behavior is
      thus rather like <function>strncpy</>.) <parameter>to</> shall point
      to a buffer that is able to hold at least one more byte than twice
      the value of <parameter>length</>, otherwise the behavior is undefined.
      Behavior is likewise undefined if the <parameter>to</> and
      <parameter>from</> strings overlap.
-->
<function>PQescapeStringConn</>は、<function>PQescapeLiteral</>とほぼ同様に文字列リテラルをエスケープします。
<function>PQescapeLiteral</>とは異なり、呼び出し元が適切な大きさのバッファを提供することに責任を持ちます。
さらに<function>PQescapeStringConn</>は<productname>PostgreSQL</>の文字リテラルとして囲まれなければならない単一引用符を生成しません。
これは、結果をSQLコマンドに挿入するときに付与しなければなりません。
<parameter>from</>パラメータはエスケープ対象の文字列の先頭を指すポインタです。
<parameter>length</>パラメータはこの文字列のバイト数を示します。
ゼロバイト終端は必要なく、また、<parameter>lenth</>ではこれを数えてはなりません。
(もし<parameter>length</>バイト処理する前にゼロバイト終端が存在すると、<function>PQescapeStringConn</>はそのゼロで終了します。
この動作は<function>strncpy</>と同様です。)
<parameter>to</>は、最低でも<parameter>length</>の2倍よりも1バイト多い文字を保持可能なバッファへのポインタにしなければなりません。
さもないと、動作は不定になります。
<parameter>to</>と<parameter>from</>文字領域が重なる場合の動作も不定です。
     </para>

     <para>
<!--
      If the <parameter>error</> parameter is not <symbol>NULL</>, then
      <literal>*error</> is set to zero on success, nonzero on error.
      Presently the only possible error conditions involve invalid multibyte
      encoding in the source string.  The output string is still generated
      on error, but it can be expected that the server will reject it as
      malformed.  On error, a suitable message is stored in the
      <parameter>conn</> object, whether or not <parameter>error</> is <symbol>NULL</>.
-->
<parameter>error</>パラメータが<symbol>NULL</>でなければ、<literal>*error</>には成功の0か、エラーの0以外が設定されます。
現時点であり得る唯一のエラー条件は、元文字列に無効なマルチバイト符号が含まれている場合です。
出力文字列はエラーであっても生成されますが、サーバが不整合として却下することが想定できます。
エラーの際、適切なメッセージは<parameter>error</>が<symbol>NULL</>かどうかにかかわらず<parameter>conn</>オブジェクト内に格納されます。
     </para>

     <para>
<!--
      <function>PQescapeStringConn</> returns the number of bytes written
      to <parameter>to</>, not including the terminating zero byte.
-->
<function>PQescapeStringConn</>は<parameter>to</>に書き出したバイト数を返します。
ただし、文字数にはゼロバイト終端は含まれません。
     </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqescapestring">
     <term>
      <function>PQescapeString</function>
      <indexterm>
       <primary>PQescapeString</primary>
      </indexterm>
     </term>

     <listitem>
     <para>
<!--
       <function>PQescapeString</> is an older, deprecated version of
       <function>PQescapeStringConn</>.
-->
<function>PQescapeString</>は<function>PQescapeStringConn</>の推奨されない古いものです。
<synopsis>
size_t PQescapeString (char *to, const char *from, size_t length);
</synopsis>
     </para>

     <para>
<!--
      The only difference from <function>PQescapeStringConn</> is that
      <function>PQescapeString</> does not take <structname>PGconn</>
      or <parameter>error</> parameters.
      Because of this, it cannot adjust its behavior depending on the
      connection properties (such as character encoding) and therefore
      <emphasis>it might give the wrong results</>.  Also, it has no way
      to report error conditions.
-->
<function>PQescapeStringConn</>との唯一の違いは、<function>PQescapeString</>は<structname>PGconn</>や<parameter>error</>パラメータを取らないことです。
このため(文字符号化方式のような)接続属性に依存する振舞いを調整できません。
その結果<emphasis>間違った結果を返す可能性があります</>。
また、エラー状態を通知する機能がありません。
     </para>

     <para>
<!--
      <function>PQescapeString</> can be used safely in
      client programs that work with only one <productname>PostgreSQL</>
      connection at a time (in this case it can find out what it needs to
      know <quote>behind the scenes</>).  In other contexts it is a security
      hazard and should be avoided in favor of
      <function>PQescapeStringConn</>.
-->
<function>PQescapeString</>は、一度に1つの<productname>PostgreSQL</>接続のみで動作するクライアントプログラムでは安全に利用できます。
(この場合知らなければならない<quote>裏側に隠された情報</>を知ることができるからです。)
他の場合には、セキュリティ要因であり<function>PQescapeStringConn</>を利用することで避けなければなりません。
     </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqescapebyteaconn">
     <term>
      <function>PQescapeByteaConn</function>
      <indexterm>
       <primary>PQescapeByteaConn</primary>
      </indexterm>
     </term>

     <listitem>
     <para>
<!--
       Escapes binary data for use within an SQL command with the type
       <type>bytea</type>.  As with <function>PQescapeStringConn</function>,
       this is only used when inserting data directly into an SQL command string.
-->
<type>bytea</type>型としてSQLコマンド内で使用するバイナリデータをエスケープします。
<function>PQescapeStringConn</function>と同様、これは、SQLコマンド文字列にデータを直接含める場合にのみに使用されます。
<synopsis>
unsigned char *PQescapeByteaConn(PGconn *conn,
                                 const unsigned char *from,
                                 size_t from_length,
                                 size_t *to_length);
</synopsis>
      </para>

      <para>
<!--
       Certain byte values must be escaped when used as part of a
       <type>bytea</type> literal in an <acronym>SQL</acronym> statement.
       <function>PQescapeByteaConn</function> escapes bytes using
       either hex encoding or backslash escaping.  See <xref
       linkend="datatype-binary"> for more information.
-->
<acronym>SQL</acronym>文内の<type>bytea</type>リテラルの一部として使用する場合、特定のバイト値はエスケープされなければなりません。
<function>PQescapeByteaConn</function>は16進数符号化またはバックスラッシュエスケープ処理を使用してバイトをエスケープします。
詳しくは<xref linkend="datatype-binary">を参照してください。
      </para>

      <para>
<!--
       The <parameter>from</parameter> parameter points to the first
       byte of the string that is to be escaped, and the
       <parameter>from_length</parameter> parameter gives the number of
       bytes in this binary string.  (A terminating zero byte is
       neither necessary nor counted.)  The <parameter>to_length</parameter>
       parameter points to a variable that will hold the resultant
       escaped string length. This result string length includes the terminating
       zero byte of the result.
-->
<parameter>from</parameter>パラメータはエスケープ対象の文字列の先頭バイトを指し示すポインタです。
<parameter>from_length</parameter>パラメータは、このバイナリ列内のバイト数を指定します。
(ゼロバイト終端は不要、かつ、数えられません。)
<parameter>to_length</parameter>パラメータは結果となるエスケープされた文字列の長さを保持する変数へのポインタです。
この結果文字列長は、結果内のゼロバイト終端を含みます。
      </para>

      <para>
<!--
       <function>PQescapeByteaConn</> returns an escaped version of the
       <parameter>from</parameter> parameter binary string in memory
       allocated with <function>malloc()</>.  This memory should be freed using
       <function>PQfreemem()</> when the result is no longer needed.  The
       return string has all special characters replaced so that they can
       be properly processed by the <productname>PostgreSQL</productname>
       string literal parser, and the <type>bytea</type> input function. A
       terminating zero byte is also added.  The single quotes that must
       surround <productname>PostgreSQL</productname> string literals are
       not part of the result string.
-->
<function>PQescapeByteaConn</>は、<parameter>from</parameter>パラメータが示すバイナリ文字列をエスケープしたものを<function>malloc()</>で確保したメモリ内に返します。
その結果が不要になったら、このメモリを<function>PQfreemem</>を使用して解放しなければなりません。
返される文字列では、<productname>PostgreSQL</productname>リテラル文字列パーサと<type>bytea</type>入力関数によって適切に処理できるように、すべての特殊な文字が置換されています。
ゼロバイト終端も追加されます。
<productname>PostgreSQL</productname>のリテラル文字列をくくる単一引用符は結果文字列には含まれません。
      </para>

      <para>
<!--
       On error, a null pointer is returned, and a suitable error message
       is stored in the <parameter>conn</> object.  Currently, the only
       possible error is insufficient memory for the result string.
-->
エラー時、ヌルポインタを返し適切なエラーメッセージを<parameter>conn</>オブジェクトに格納します。
現在、唯一あり得るエラーは結果文字列のメモリ不足です。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqescapebytea">
     <term>
      <function>PQescapeBytea</function>
      <indexterm>
       <primary>PQescapeBytea</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
<!--
       <function>PQescapeBytea</> is an older, deprecated version of
       <function>PQescapeByteaConn</>.
-->
<function>PQescapeBytea</>は、<function>PQescapeByteaConn</>の推奨されない古いものです。
<synopsis>
unsigned char *PQescapeBytea(const unsigned char *from,
                             size_t from_length,
                             size_t *to_length);
</synopsis>
      </para>

      <para>
<!--
       The only difference from <function>PQescapeByteaConn</> is that
       <function>PQescapeBytea</> does not take a <structname>PGconn</>
       parameter.  Because of this, <function>PQescapeBytea</> can
       only be used safely in client programs that use a single
       <productname>PostgreSQL</> connection at a time (in this case
       it can find out what it needs to know <quote>behind the
       scenes</>).  It <emphasis>might give the wrong results</> if
       used in programs that use multiple database connections (use
       <function>PQescapeByteaConn</> in such cases).
-->
<function>PQescapeBytea</>の<function>PQescapeByteaConn</>との唯一の違いは、<structname>PGconn</>パラメータです。
このため<function>PQescapeBytea</>は、一度に１つの<productname>PostgreSQL</>接続を使用するクライアントプログラムのみで安全に利用することができます。
(この場合知らなければならない<quote>裏側に隠された情報</>を知ることができるからです。)
複数のデータベース接続を使用するプログラムでは<emphasis>間違った結果を返す可能性があります</>。
（このような場合は<function>PQescapeByteaConn</>を使用してください。）
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqunescapebytea">
     <term>
      <function>PQunescapeBytea</function>
      <indexterm>
       <primary>PQunescapeBytea</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
<!--
       Converts a string representation of binary data into binary data
       &mdash; the reverse of <function>PQescapeBytea</function>.  This
       is needed when retrieving <type>bytea</type> data in text format,
       but not when retrieving it in binary format.
-->
バイナリデータの文字列表現をバイナリデータに変換します。
つまり、<function>PQescapeBytea</function>の逆です。
これは、<type>bytea</type>データをテキスト書式で受けとった場合に必要とされます。
しかし、バイナリ書式で受けとった場合は不要です。

<synopsis>
unsigned char *PQunescapeBytea(const unsigned char *from, size_t *to_length);
</synopsis>
      </para>

      <para>
<!--
       The <parameter>from</parameter> parameter points to a string
       such as might be returned by <function>PQgetvalue</function> when applied
       to a <type>bytea</type> column. <function>PQunescapeBytea</function>
       converts this string representation into its binary representation.
       It returns a pointer to a buffer allocated with
       <function>malloc()</function>, or <symbol>NULL</> on error, and puts the size of
       the buffer in <parameter>to_length</parameter>. The result must be
       freed using <function>PQfreemem</> when it is no longer needed.
-->
<parameter>from</parameter>パラメータは、例えば、<type>bytea</type>列に<function>PQgetvalue</function>を行なった場合に返される可能性がある、文字列を指し示すポインタです。
<function>PQunescapeBytea</function>は、この文字列表現をバイナリ表現に変換します。
<function>malloc()</function>で確保したバッファへのポインタを返します。
エラー時は<symbol>NULL</>です。
また、このバッファのサイズを<parameter>to_length</parameter>に格納します。
不要になったら、この結果を<function>PQfreemem</>を使用して解放しなければなりません。
      </para>

      <para>
<!--
       This conversion is not exactly the inverse of
       <function>PQescapeBytea</function>, because the string is not expected
       to be <quote>escaped</> when received from <function>PQgetvalue</function>.
       In particular this means there is no need for string quoting considerations,
       and so no need for a <structname>PGconn</> parameter.
-->
この変換は、<function>PQescapeBytea</function>の逆ではありません。
文字列は<function>PQgetvalue</function>から受け取る場合<quote>エスケープされた</>ことを予想しないためです。
特にこれは、文字列の引用符付けを意識する必要がなく、そのため<structname>PGconn</>パラメータを持つ必要がないことを意味します。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>

  </sect2>

 </sect1>

 <sect1 id="libpq-async">
<!--
  <title>Asynchronous Command Processing</title>
-->
<title>非同期コマンドの処理</title>

  <indexterm zone="libpq-async">
<!--
   <primary>nonblocking connection</primary>
-->
  <primary>非ブロッキング接続</primary>
  </indexterm>

  <para>
<!--
   The <function>PQexec</function> function is adequate for submitting
   commands in normal, synchronous applications.  It has a few
   deficiencies, however, that can be of importance to some users:
-->
<function>PQexec</function>関数は普通の同期処理のアプリケーションにおけるコマンドの送信に適したものです。
しかし、一部のユーザにとって重要な問題となり得る、数個の問題があります。

   <itemizedlist>
    <listitem>
     <para>
<!--
      <function>PQexec</function> waits for the command to be completed.
      The application might have other work to do (such as maintaining a
      user interface), in which case it won't want to block waiting for
      the response.
-->
<function>PQexec</function> はコマンドが完了するまで待機します。
アプリケーションによっては(例えばユーザインタフェースの調整処理など)他に行うべき作業があります。
この場合は応答待ちでブロックさせたくはありません。
     </para>
    </listitem>

    <listitem>
     <para>
<!--
      Since the execution of the client application is suspended while it
      waits for the result, it is hard for the application to decide that
      it would like to try to cancel the ongoing command.  (It can be done
      from a signal handler, but not otherwise.)
-->
クライアントアプリケーションの実行が結果を待っている間停止されるため、アプリケーションで送信したコマンドをキャンセルさせる指示を行うことは困難です。
(シグナルハンドラを使って達成することができますが、他の方法はありません。)
     </para>
    </listitem>

    <listitem>
     <para>
<!--
      <function>PQexec</function> can return only one
      <structname>PGresult</structname> structure.  If the submitted command
      string contains multiple <acronym>SQL</acronym> commands, all but
      the last <structname>PGresult</structname> are discarded by
      <function>PQexec</function>.
-->
<function>PQexec</function>が返すことができる<structname>PGresult</structname>構造体は1つだけです。
もし送信した問い合わせ文字列が複数の<acronym>SQL</acronym>コマンドを含んでいる場合、<function>PQexec</function>は最後のものだけを除いて、残りすべての<structname>PGresult</structname>を破棄してしまいます。
     </para>
    </listitem>

    <listitem>
     <para>
<!--
      <function>PQexec</function> always collects the command's entire result,
      buffering it in a single <structname>PGresult</structname>.  While
      this simplifies error-handling logic for the application, it can be
      impractical for results containing many rows.
-->
<function>PQexec</function>は常にコマンドの結果全体を収集し、１つの<structname>PGresult</structname>内に保管します。
アプリケーションにおけるエラー処理を簡単にしますが、多くの行になる結果では非現実的になるかもしれません。
     </para>
    </listitem>
   </itemizedlist>
  </para>

  <para>
<!--
   Applications that do not like these limitations can instead use the
   underlying functions that <function>PQexec</function> is built from:
   <function>PQsendQuery</function> and <function>PQgetResult</function>.
   There are also
   <function>PQsendQueryParams</function>,
   <function>PQsendPrepare</function>,
   <function>PQsendQueryPrepared</function>,
   <function>PQsendDescribePrepared</function>, and
   <function>PQsendDescribePortal</function>,
   which can be used with <function>PQgetResult</function> to duplicate
   the functionality of
   <function>PQexecParams</function>,
   <function>PQprepare</function>,
   <function>PQexecPrepared</function>,
   <function>PQdescribePrepared</function>, and
   <function>PQdescribePortal</function>
   respectively.
-->
アプリケーションにとってこのような制限が望ましくない場合は、代わりに<function>PQexec</function>を構成する関数<function>PQsendQuery</function>と<function>PQgetResult</function>を使用してください。
また、<function>PQsendQueryParams</function>と<function>PQsendPrepare</function>、<function>PQsendQueryPrepared</function>、<function>PQsendDescribePrepared</function>、<function>PQsendDescribePortal</function>もあり、<function>PQgetResult</function>を使用して、それぞれ<function>PQexecParams</function>と<function>PQprepare</function>、<function>PQexecPrepared</function>、<function>PQdescribePrepared</function>、<function>PQdescribePortal</function>と同等の機能を行うことができます。

   <variablelist>
    <varlistentry id="libpq-pqsendquery">
     <term>
      <function>PQsendQuery</function>
      <indexterm>
       <primary>PQsendQuery</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
<!--
       Submits a command to the server without waiting for the result(s).
       1 is returned if the command was successfully dispatched and 0 if
       not (in which case, use <function>PQerrorMessage</> to get more
       information about the failure).
-->
結果を待つことなく、サーバにコマンドを発行します。
コマンドの登録に成功した場合1が、失敗した場合0が返されます。
(後者の場合、<function>PQerrorMessage</>を使用して失敗についてのより多くの情報を取り出してください。)
<synopsis>
int PQsendQuery(PGconn *conn, const char *command);
</synopsis>

<!--
       After successfully calling <function>PQsendQuery</function>, call
       <function>PQgetResult</function> one or more times to obtain the
       results.  <function>PQsendQuery</function> cannot be called again
       (on the same connection) until <function>PQgetResult</function>
       has returned a null pointer, indicating that the command is done.
-->
<function>PQsendQuery</function>呼び出しが成功したら、<function>PQgetResult</function>を繰り返し呼び出して、実行結果を取得します。
<function>PQgetResult</function>がヌルポインタを返し、コマンドが完了したことを示すまでは、(同じ接続で)<function>PQsendQuery</function>を再度呼び出すことはできません。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqsendqueryparams">
     <term>
      <function>PQsendQueryParams</function>
      <indexterm>
       <primary>PQsendQueryParams</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
<!--
       Submits a command and separate parameters to the server without
       waiting for the result(s).
-->
結果を待つことなく、サーバにコマンドとパラメータとを分けて発行します。
<synopsis>
int PQsendQueryParams(PGconn *conn,
                      const char *command,
                      int nParams,
                      const Oid *paramTypes,
                      const char * const *paramValues,
                      const int *paramLengths,
                      const int *paramFormats,
                      int resultFormat);
</synopsis>

<!--
       This is equivalent to <function>PQsendQuery</function> except that
       query parameters can be specified separately from the query string.
       The function's parameters are handled identically to
       <function>PQexecParams</function>.  Like
       <function>PQexecParams</function>, it will not work on 2.0-protocol
       connections, and it allows only one command in the query string.
-->
これは、問い合わせのパラメータが問い合わせ文字列と分けて指定できる点を除き、<function>PQsendQuery</function>と同じです。
この関数のパラメータは<function>PQexecParams</function>と同様に扱われます。
<function>PQexecParams</function>同様、これは2.0プロトコルでは動作しませんし、問い合わせ文字列には1つのコマンドしか指定できません。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqsendprepare">
     <term>
      <function>PQsendPrepare</>
      <indexterm>
       <primary>PQsendPrepare</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
<!--
       Sends a request to create a prepared statement with the given
       parameters, without waiting for completion.
-->
指定パラメータを持つプリペアド文の作成要求を送信します。
その完了を待ちません。
<synopsis>
int PQsendPrepare(PGconn *conn,
                  const char *stmtName,
                  const char *query,
                  int nParams,
                  const Oid *paramTypes);
</synopsis>

<!--
       This is an asynchronous version of <function>PQprepare</>: it
       returns 1 if it was able to dispatch the request, and 0 if not.
       After a successful call, call <function>PQgetResult</function> to
       determine whether the server successfully created the prepared
       statement.  The function's parameters are handled identically to
       <function>PQprepare</function>.  Like
       <function>PQprepare</function>, it will not work on 2.0-protocol
       connections.
-->
これは<function>PQprepare</>の非同期版です。
要求の登録に成功した場合1が、失敗した場合0が返されます。
呼び出しの成功の後、サーバがプリペアド文の生成に成功したかを確認するためには<function>PQgetResult</function>を呼び出してください。
この関数のパラメータは<function>PQprepare</function>と同様に扱われます。
<function>PQprepare</function>同様、これは2.0プロトコルの接続では動作しません。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqsendqueryprepared">
     <term>
      <function>PQsendQueryPrepared</function>
      <indexterm>
       <primary>PQsendQueryPrepared</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
<!--
       Sends a request to execute a prepared statement with given
       parameters, without waiting for the result(s).
-->
結果を待つことなく、指定したパラメータでプリペアド文の実行要求を送信します。
<synopsis>
int PQsendQueryPrepared(PGconn *conn,
                        const char *stmtName,
                        int nParams,
                        const char * const *paramValues,
                        const int *paramLengths,
                        const int *paramFormats,
                        int resultFormat);
</synopsis>

<!--
       This is similar to <function>PQsendQueryParams</function>, but
       the command to be executed is specified by naming a
       previously-prepared statement, instead of giving a query string.
       The function's parameters are handled identically to
       <function>PQexecPrepared</function>.  Like
       <function>PQexecPrepared</function>, it will not work on
       2.0-protocol connections.
-->
これは<function>PQsendQueryParams</function>と似ていますが、実行されるコマンドは問い合わせ文字列ではなく、事前に準備された文の名前で指定されます。
この関数のパラメータは<function>PQexecPrepared</function>と同様に扱われます。
<function>PQexecPrepared</function>同様、これは2.0プロトコルでは動作しません。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqsenddescribeprepared">
     <term>
      <function>PQsendDescribePrepared</>
      <indexterm>
       <primary>PQsendDescribePrepared</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
<!--
       Submits a request to obtain information about the specified
       prepared statement, without waiting for completion.
-->
指定したプリペアド文に関する情報入手要求を送ります。
入手完了まで待機しません。
<synopsis>
int PQsendDescribePrepared(PGconn *conn, const char *stmtName);
</synopsis>

<!--
       This is an asynchronous version of <function>PQdescribePrepared</>:
       it returns 1 if it was able to dispatch the request, and 0 if not.
       After a successful call, call <function>PQgetResult</function> to
       obtain the results.  The function's parameters are handled
       identically to <function>PQdescribePrepared</function>.  Like
       <function>PQdescribePrepared</function>, it will not work on
       2.0-protocol connections.
-->
これは<function>PQdescribePrepared</>の非同期版です。
要求の受付けが可能であれば1が返されます。不可能であれば0が返されます。
呼び出しに成功した後、<function>PQgetResult</function>を呼び出して結果を入手してください。
この関数のパラメータは<function>PQdescribePrepared</function>と同じように扱われます。
<function>PQdescribePrepared</function>同様、2.0プロトコル接続では動作しません。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqsenddescribeportal">
     <term>
      <function>PQsendDescribePortal</>
      <indexterm>
       <primary>PQsendDescribePortal</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
<!--
       Submits a request to obtain information about the specified
       portal, without waiting for completion.
-->
指定したポータルに関する情報入手要求を送信します。
完了まで待機しません。
<synopsis>
int PQsendDescribePortal(PGconn *conn, const char *portalName);
</synopsis>

<!--
       This is an asynchronous version of <function>PQdescribePortal</>:
       it returns 1 if it was able to dispatch the request, and 0 if not.
       After a successful call, call <function>PQgetResult</function> to
       obtain the results.  The function's parameters are handled
       identically to <function>PQdescribePortal</function>.  Like
       <function>PQdescribePortal</function>, it will not work on
       2.0-protocol connections.
-->
これは<function>PQdescribePortal</>の非同期版です。
要求の受付けが可能であれば1が返されます。不可能であれば0が返されます。
呼び出しに成功した後、<function>PQgetResult</function>を呼び出して結果を入手してください。
この関数のパラメータは<function>PQdescribePortal</function>と同じように扱われます。
<function>PQdescribePortal</function>同様、2.0プロトコル接続では動作しません。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqgetresult">
     <term>
      <function>PQgetResult</function>
      <indexterm>
       <primary>PQgetResult</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
<!--
       Waits for the next result from a prior
       <function>PQsendQuery</function>,
       <function>PQsendQueryParams</function>,
       <function>PQsendPrepare</function>,
       <function>PQsendQueryPrepared</function>,
       <function>PQsendDescribePrepared</function>, or
       <function>PQsendDescribePortal</function>
       call, and returns it.
       A null pointer is returned when the command is complete and there
       will be no more results.
-->
以前に呼び出した<function>PQsendQuery</function>、<function>PQsendQueryParams</function>、<function>PQsendPrepare</function>、<function>PQsendQueryPrepared</function>、<function>PQsendDescribePrepared</function>、<function>PQsendDescribePortal</function>から次の結果を待ち、その結果を返します。
コマンドが完了し、これ以上結果がない場合は、ヌルポインタが返されます。
<synopsis>
PGresult *PQgetResult(PGconn *conn);
</synopsis>
      </para>

      <para>
<!--
       <function>PQgetResult</function> must be called repeatedly until
       it returns a null pointer, indicating that the command is done.
       (If called when no command is active,
       <function>PQgetResult</function> will just return a null pointer
       at once.) Each non-null result from
       <function>PQgetResult</function> should be processed using the
       same <structname>PGresult</> accessor functions previously
       described.  Don't forget to free each result object with
       <function>PQclear</function> when done with it.  Note that
       <function>PQgetResult</function> will block only if a command is
       active and the necessary response data has not yet been read by
       <function>PQconsumeInput</function>.
-->
<function>PQgetResult</function>は、コマンドの完了を示すヌルポインタが返るまで、繰り返し呼び出さなければなりません。
(コマンド実行中以外での呼び出しでは、<function>PQgetResult</function>は単にヌルポインタを返します。)
<function>PQgetResult</function>の非ヌルの結果はそれぞれ前述と同じ<structname>PGresult</>アクセス用関数を使用して処理されなければなりません。
各結果オブジェクトに対する処理が終わったら、そのオブジェクトを<function>PQclear</function>を使用して解放することを忘れないでください。
コマンドが活動中、かつ、必要な応答データがまだ<function>PQconsumeInput</function>で読み込まれていない場合にのみ、<function>PQgetResult</function>がブロックすることに注意してください。
      </para>

      <note>
       <para>
<!--
        Even when <function>PQresultStatus</function> indicates a fatal
        error, <function>PQgetResult</function> should be called until it
        returns a null pointer, to allow <application>libpq</> to
        process the error information completely.
-->
<function>PQresultStatus</function>が致命的なエラーを示した場合であっても、<application>libpq</>がエラー情報を完全に処理できるようにヌルポインタが返されるまで<function>PQgetResult</function>を呼び出さなければなりません。
       </para>
      </note>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

  <para>
<!--
   Using <function>PQsendQuery</function> and
   <function>PQgetResult</function> solves one of
   <function>PQexec</function>'s problems:  If a command string contains
   multiple <acronym>SQL</acronym> commands, the results of those commands
   can be obtained individually.  (This allows a simple form of overlapped
   processing, by the way: the client can be handling the results of one
   command while the server is still working on later queries in the same
   command string.)
-->
<function>PQsendQuery</function>と<function>PQgetResult</function>を使うことで<function>PQexec</function>の問題は1つ解決します。
つまり、コマンドが複数の<acronym>SQL</acronym>コマンドを含んでいる場合でも、これらのコマンドの結果を個々に得ることができるわけです
（これは多重処理を単純な形で実現します。
単一のコマンド文字列に含まれる複数の問い合わせの内、後ろのものが処理中でもフロントエンドは先に完了した結果から扱うことができるからです）。
  </para>

  <para>
<!--
   Another frequently-desired feature that can be obtained with
   <function>PQsendQuery</function> and <function>PQgetResult</function>
   is retrieving large query results a row at a time.  This is discussed
   in <xref linkend="libpq-single-row-mode">.
-->
<function>PQsendQuery</function>および<function>PQgetResult</function>で得られる、その他のよく望まれる機能は多くの問い合わせ結果を一度に1行受け取ることです。
これについては<xref linkend="libpq-single-row-mode">で説明します。
  </para>

  <para>
<!--
   By itself, calling <function>PQgetResult</function>
   will still cause the client to block until the server completes the
   next <acronym>SQL</acronym> command.  This can be avoided by proper
   use of two more functions:
-->
サーバが次の<acronym>SQL</acronym>コマンドの処理に入ると、それが完了するまでやはり<function>PQgetResult</function>の呼び出しがフロントエンドをブロックしてしまいます。
さらに以下の2つの関数をうまく使用してこれを防ぐことができます。

   <variablelist>
    <varlistentry id="libpq-pqconsumeinput">
     <term>
      <function>PQconsumeInput</function>
      <indexterm>
       <primary>PQconsumeInput</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
<!--
       If input is available from the server, consume it.
-->
サーバからの入力が可能になった場合、それを吸い取ります。
<synopsis>
int PQconsumeInput(PGconn *conn);
</synopsis>
      </para>

      <para>
<!--
       <function>PQconsumeInput</function> normally returns 1 indicating
       <quote>no error</quote>, but returns 0 if there was some kind of
       trouble (in which case <function>PQerrorMessage</function> can be
       consulted).  Note that the result does not say whether any input
       data was actually collected. After calling
       <function>PQconsumeInput</function>, the application can check
       <function>PQisBusy</function> and/or
       <function>PQnotifies</function> to see if their state has changed.
-->
<function>PQconsumeInput</function>は通常、<quote>エラーなし</quote>を示す1を返しますが、何らかの障害があると0を返します（この場合は、<function>PQerrorMessage</function>を参考にしてください）。
この結果は、何らかの入力データが実際に収集されたかどうかを示しているのではないことに注意してください。
<function>PQconsumeInput</function>の呼び出し後、アプリケーションは<function>PQisBusy</function>、または必要があれば<function>PQnotifies</function>を呼び出して状態に変化がないか調べることができます。
      </para>

      <para>
<!--
       <function>PQconsumeInput</function> can be called even if the
       application is not prepared to deal with a result or notification
       just yet.  The function will read available data and save it in
       a buffer, thereby causing a <function>select()</function>
       read-ready indication to go away.  The application can thus use
       <function>PQconsumeInput</function> to clear the
       <function>select()</function> condition immediately, and then
       examine the results at leisure.
-->
<function>PQconsumeInput</function>は、結果や通知を扱うようにまだ準備していないアプリケーションからでも呼び出すことができます。
この関数は有効なデータを読み込んでバッファに保存し、結果として<function>select</function>による読み込み準備完了の通知をリセットします。
従ってアプリケーションは<function>PQconsumeInput</function>を使うと<function>select()</function>の検査条件をただちに満たすことができますから、あとはゆっくりと結果を調べてやればいいわけです。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqisbusy">
     <term>
      <function>PQisBusy</function>
      <indexterm>
       <primary>PQisBusy</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
<!--
       Returns 1 if a command is busy, that is,
       <function>PQgetResult</function> would block waiting for input.
       A 0 return indicates that <function>PQgetResult</function> can be
       called with assurance of not blocking.
-->
この関数が1を返したのであれば、問い合わせは処理の最中で、<function>PQgetResult</function>も入力を待ったままブロック状態になってしまうでしょう。
0が返ったのであれば、<function>PQgetResult</function>を呼び出してもブロックされないことが保証されます。
<synopsis>
int PQisBusy(PGconn *conn);
</synopsis>
      </para>

      <para>
<!--
       <function>PQisBusy</function> will not itself attempt to read data
       from the server; therefore <function>PQconsumeInput</function>
       must be invoked first, or the busy state will never end.
-->
<function>PQisBusy</function>自身はサーバからデータを読み込む操作をしません。
ですから、まず最初に<function>PQconsumeInput</function>を呼び出す必要があります。
そうしないとビジー状態がいつまでも続きます。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

  <para>
<!--
   A typical application using these functions will have a main loop that
   uses <function>select()</function> or <function>poll()</> to wait for
   all the conditions that it must respond to.  One of the conditions
   will be input available from the server, which in terms of
   <function>select()</function> means readable data on the file
   descriptor identified by <function>PQsocket</function>.  When the main
   loop detects input ready, it should call
   <function>PQconsumeInput</function> to read the input.  It can then
   call <function>PQisBusy</function>, followed by
   <function>PQgetResult</function> if <function>PQisBusy</function>
   returns false (0).  It can also call <function>PQnotifies</function>
   to detect <command>NOTIFY</> messages (see <xref
   linkend="libpq-notify">).
-->
これら3関数を使用するアプリケーションは通常、<function>select()</function>もしくは<function>poll()</>を使用するメインループを持ち、対応しなければならないすべての状態を待機しています。
その内の1つの条件は、サーバからの利用可能な入力となるでしょう。
これは、<function>select()</function>の見地からは、<function>PQsocket</function>で識別されるファイル記述子上で読み込み可能なデータがあることを意味します。
メインループが入力準備完了を検出すると、その入力を読み込むために<function>PQconsumeInput</function>を呼び出さなければなりません。
そして、<function>PQisBusy</function>を、更に<function>PQisBusy</function>が偽(0)を返す場合に<function>PQgetResult</function>も呼び出すことができます。
また、<function>PQnotifies</function>を呼び出して、<command>NOTIFY</>メッセージ( <xref linkend="libpq-notify">を参照)を検出することもできます。
  </para>

  <para>
<!--
   A client that uses
   <function>PQsendQuery</function>/<function>PQgetResult</function>
   can also attempt to cancel a command that is still being processed
   by the server; see <xref linkend="libpq-cancel">.  But regardless of
   the return value of <function>PQcancel</function>, the application
   must continue with the normal result-reading sequence using
   <function>PQgetResult</function>.  A successful cancellation will
   simply cause the command to terminate sooner than it would have
   otherwise.
-->
また、<function>PQsendQuery</function>/<function>PQgetResult</function>を使用するクライアントは、サーバで処理中のコマンドに対してキャンセルを試行することができます。
<xref linkend="libpq-cancel">を参照してください。
しかし、<function>PQcancel</function>の戻り値と関係なく、アプリケーションは<function>PQgetResult</function>を使用した通常の結果読み取り手順を続けなければなりません。
キャンセル手続きの成功は単に、そのコマンドを通常よりも早めに終わらせるだけです。
  </para>

  <para>
<!--
   By using the functions described above, it is possible to avoid
   blocking while waiting for input from the database server.  However,
   it is still possible that the application will block waiting to send
   output to the server.  This is relatively uncommon but can happen if
   very long SQL commands or data values are sent.  (It is much more
   probable if the application sends data via <command>COPY IN</command>,
   however.)  To prevent this possibility and achieve completely
   nonblocking database operation, the following additional functions
   can be used.
-->
上述の関数を使用して、データベースサーバからの入力待ちのためのブロックを行わずに済みます。
しかしまだ、サーバへの出力送信を待つためにアプリケーションはブロックする可能性があります。
これは比較的あまり発生しませんが、非常に長いSQLコマンドやデータ値が送信される場合に発生することがあります。
(しかし、アプリケーションが<command>COPY IN</command>経由でデータを送信する場合よく発生します。)
この発生を防ぎ、完全な非ブロックのデータベース操作を行うためには、さらに以下の関数を使用してください。

   <variablelist>
    <varlistentry id="libpq-pqsetnonblocking">
     <term>
      <function>PQsetnonblocking</function>
      <indexterm>
       <primary>PQsetnonblocking</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
<!--
       Sets the nonblocking status of the connection.
-->
接続の非ブロック状態を設定します。
<synopsis>
int PQsetnonblocking(PGconn *conn, int arg);
</synopsis>
      </para>

      <para>
<!--
       Sets the state of the connection to nonblocking if
       <parameter>arg</parameter> is 1, or blocking if
       <parameter>arg</parameter> is 0.  Returns 0 if OK, -1 if error.
-->
<parameter>arg</parameter>が1の場合、接続状態を非ブロックに設定します。
<parameter>arg</parameter>が0の場合はブロックに設定します。
問題がなければ0が、エラー時は-1が返ります。
      </para>

      <para>
<!--
       In the nonblocking state, calls to
       <function>PQsendQuery</function>, <function>PQputline</function>,
       <function>PQputnbytes</function>, and
       <function>PQendcopy</function> will not block but instead return
       an error if they need to be called again.
-->
非ブロック状態では<function>PQsendQuery</function>、<function>PQputline</function>、<function>PQputnbytes</function>および<function>PQendcopy</function>の呼び出しはブロックされませんが、再度呼び出さなければならない場合、エラーが返ります。
      </para>

      <para>
<!--
       Note that <function>PQexec</function> does not honor nonblocking
       mode; if it is called, it will act in blocking fashion anyway.
-->
<function>PQexec</function>は非ブロックモードにはしたがわないことに注意してください。
この関数の呼び出しは、必ずブロック方式で動作します。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqisnonblocking">
     <term>
      <function>PQisnonblocking</function>
      <indexterm>
       <primary>PQisnonblocking</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
<!--
       Returns the blocking status of the database connection.
-->
データベース接続のブロック状態を返します。
<synopsis>
int PQisnonblocking(const PGconn *conn);
</synopsis>
      </para>

      <para>
<!--
       Returns 1 if the connection is set to nonblocking mode and 0 if
       blocking.
-->
接続が非ブロック状態の場合は1が、ブロック状態の場合は0が返ります。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqflush">
     <term>
      <function>PQflush</function>
       <indexterm>
        <primary>PQflush</primary>
       </indexterm>
      </term>

      <listitem>
       <para>
<!--
       Attempts to flush any queued output data to the server.  Returns
       0 if successful (or if the send queue is empty), -1 if it failed
       for some reason, or 1 if it was unable to send all the data in
       the send queue yet (this case can only occur if the connection
       is nonblocking).
-->
キューに蓄えられたサーバへの出力データの吐き出しを行います。
成功時(および送信キューが空の場合)は0が返ります。
何らかの原因で失敗した場合は-1が、送信キュー内のデータをすべて送信できなかった場合は1が返ります。
(これは接続が非ブロックの場合にのみ発生します。)
<synopsis>
int PQflush(PGconn *conn);
</synopsis>
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

  <para>
<!--
   After sending any command or data on a nonblocking connection, call
   <function>PQflush</function>.  If it returns 1, wait for the socket
   to be write-ready and call it again; repeat until it returns 0.  Once
   <function>PQflush</function> returns 0, wait for the socket to be
   read-ready and then read the response as described above.
-->
非ブロック接続時にはコマンドやデータを送信した後に、<function>PQflush</function>を呼び出してください。
1が返った場合、ソケットの書き込み準備ができるまで待ち、再度呼び出してください。
これを0が返るまで繰り返してください。
<function>PQflush</function>が0を返した後は、ソケットの読み込み準備が整うまで待ち、上述のように応答を読み取ってください。
  </para>

 </sect1>

 <sect1 id="libpq-single-row-mode">
<!--
  <title>Retrieving Query Results Row-By-Row</title>
-->
  <title>１行１行問い合わせ結果を受け取る</title>

  <indexterm zone="libpq-single-row-mode">
   <primary>libpq</primary>
<!--
   <secondary>single-row mode</secondary>
-->
   <secondary>単一行モード</secondary>
  </indexterm>

  <para>
<!--
   Ordinarily, <application>libpq</> collects a SQL command's
   entire result and returns it to the application as a single
   <structname>PGresult</structname>.  This can be unworkable for commands
   that return a large number of rows.  For such cases, applications can use
   <function>PQsendQuery</function> and <function>PQgetResult</function> in
   <firstterm>single-row mode</>.  In this mode, the result row(s) are
   returned to the application one at a time, as they are received from the
   server.
-->
通常、<application>libpq</>はSQLコマンドの結果全体を収集し、それを１つの<type>PGresult</type>としてアプリケーションに返します。
これは、多くの行数を返すコマンドでは動作しなくなるかもしれません。
こうした場合、アプリケーションは<function>PQsendQuery</function>と<function>PQgetResult</function>を<firstterm>単一行モード</>で使用することができます。
このモードでは、結果行は、サーバから受け取ったかのように、アプリケーションに１度に１行返されます。
  </para>

  <para>
<!--
   To enter single-row mode, call <function>PQsetSingleRowMode</function>
   immediately after a successful call of <function>PQsendQuery</function>
   (or a sibling function).  This mode selection is effective only for the
   currently executing query.  Then call <function>PQgetResult</function>
   repeatedly, until it returns null, as documented in <xref
   linkend="libpq-async">.  If the query returns any rows, they are returned
   as individual <structname>PGresult</structname> objects, which look like
   normal query results except for having status code
   <literal>PGRES_SINGLE_TUPLE</literal> instead of
   <literal>PGRES_TUPLES_OK</literal>.  After the last row, or immediately if
   the query returns zero rows, a zero-row object with status
   <literal>PGRES_TUPLES_OK</literal> is returned; this is the signal that no
   more rows will arrive.  (But note that it is still necessary to continue
   calling <function>PQgetResult</function> until it returns null.)  All of
   these <structname>PGresult</structname> objects will contain the same row
   description data (column names, types, etc) that an ordinary
   <structname>PGresult</structname> object for the query would have.
   Each object should be freed with <function>PQclear</function> as usual.
-->
単一行モードに入るためには、<function>PQsendQuery</function>（または同系列の関数）の呼び出しに成功した直後に<function>PQsetSingleRowMode</function>を呼び出してください。
このモード選択は、現在実行中の問い合わせに対してのみ有効です。
その後、<xref linkend="libpq-async">の説明通りに、ヌルを返すようになるまで<function>PQgetResult</function>を繰り返し呼び出してください。
問い合わせが何らかの行を返す場合、<literal>PGRES_TUPLES_OK</literal>ではなく<literal>PGRES_SINGLE_TUPLE</literal>状態コードを持つ以外通常の問い合わせ結果と同じように見える、個々の<structname>PGresult</structname>オブジェクトを返します。
最後の行の後、または問い合わせがゼロ行を返す場合は即座に、<literal>PGRES_TUPLES_OK</literal>状態のゼロ行のオブジェクトが返されます。
これはもう行が届かないことを通知するものです。
（しかしヌルが返るまで<function>PQgetResult</function>を呼び出さなければならないことに注意してください。）
<structname>PGresult</structname>オブジェクトのすべては、その問い合わせに対する通常の<structname>PGresult</structname>と同一の行説明データ（列名、型など）を持ちます。
各オブジェクトは通常通り<function>PQclear</function>で解放しなければなりません。
  </para>

  <para>
   <variablelist>
    <varlistentry id="libpq-pqsetsinglerowmode">
     <term>
      <function>PQsetSingleRowMode</function>
      <indexterm>
       <primary>PQsetSingleRowMode</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
<!--
       Select single-row mode for the currently-executing query.
-->
現在実行中の問い合わせについて単一行モードを選択します。

<synopsis>
int PQsetSingleRowMode(PGconn *conn);
</synopsis>
      </para>

      <para>
<!--
       This function can only be called immediately after
       <function>PQsendQuery</function> or one of its sibling functions,
       before any other operation on the connection such as
       <function>PQconsumeInput</function> or
       <function>PQgetResult</function>.  If called at the correct time,
       the function activates single-row mode for the current query and
       returns 1.  Otherwise the mode stays unchanged and the function
       returns 0.  In any case, the mode reverts to normal after
       completion of the current query.
-->
この関数は<function>PQsendQuery</function>またはその系列の関数のいずれかの後即座に、<function>PQconsumeInput</function>や<function>PQgetResult</function>など接続に対する何らかの他の操作を行う前のみに呼び出すことができます。
正しい時点で呼び出された場合、この関数は現在の問い合わせに対して単一行モードを有効にし、１を返します。
この他の場合、モードは変更されず、関数はゼロを返します。
いずれの場合でも、現在の問い合わせが完了した後に通常モードに戻ります。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

  <caution>
   <para>
<!--
    While processing a query, the server may return some rows and then
    encounter an error, causing the query to be aborted.  Ordinarily,
    <application>libpq</> discards any such rows and reports only the
    error.  But in single-row mode, those rows will have already been
    returned to the application.  Hence, the application will see some
    <literal>PGRES_SINGLE_TUPLE</literal> <structname>PGresult</structname>
    objects followed by a <literal>PGRES_FATAL_ERROR</literal> object.  For
    proper transactional behavior, the application must be designed to
    discard or undo whatever has been done with the previously-processed
    rows, if the query ultimately fails.
-->
問い合わせを処理している間、サーバはいくつか行を返した後にエラーになり、問い合わせがアボートする可能性があります。
通常の<application>libpq</>では、こうした行を破棄しエラーのみを報告します。
しかし単一行モードでは、これらの行はすでにアプリケーションに返されています。
このためアプリケーションは<literal>PGRES_SINGLE_TUPLE</literal>状態の<structname>PGresult</structname>オブジェクトをいくつか見た後に<literal>PGRES_FATAL_ERROR</literal>オブジェクトを見るかもしれません。
適切な振る舞いのトランザクションのために、最終的に問い合わせが失敗した場合、アプリケーションはこれまで処理した行を破棄するまたは取り消すように設計しなければなりません。
   </para>
  </caution>

 </sect1>

 <sect1 id="libpq-cancel">
<!--
  <title>Canceling Queries in Progress</title>
-->
  <title>処理中の問い合わせのキャンセル</title>

  <indexterm zone="libpq-cancel">
<!--
   <primary>canceling</primary>
   <secondary>SQL command</secondary>
-->
   <primary>キャンセル</primary>
   <secondary>SQLコマンドの</secondary>
  </indexterm>

  <para>
<!--
   A client application can request cancellation of a command that is
   still being processed by the server, using the functions described in
   this section.
-->
本節で説明する関数を使用して、クライアントアプリケーションはサーバで処理中のコマンドをキャンセルする要求を行うことができます。

   <variablelist>
    <varlistentry id="libpq-pqgetcancel">
     <term>
      <function>PQgetCancel</function>
      <indexterm>
       <primary>PQgetCancel</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
<!--
       Creates a data structure containing the information needed to cancel
       a command issued through a particular database connection.
-->
特定のデータベース接続を通して発行されたコマンドをキャンセルするために必要な情報を持つデータ構造を作成します。
<synopsis>
PGcancel *PQgetCancel(PGconn *conn);
</synopsis>
      </para>

      <para>
<!--
       <function>PQgetCancel</function> creates a
       <structname>PGcancel</><indexterm><primary>PGcancel</></> object
       given a <structname>PGconn</> connection object.  It will return
       <symbol>NULL</> if the given <parameter>conn</> is <symbol>NULL</> or an invalid
       connection.  The <structname>PGcancel</> object is an opaque
       structure that is not meant to be accessed directly by the
       application; it can only be passed to <function>PQcancel</function>
       or <function>PQfreeCancel</function>.
-->
<function>PQgetCancel</function>は、与えられた<structname>PGconn</>接続オブジェクトの<structname>PGcancel</><indexterm><primary>PGcancel</></>オブジェクトを作成します。
与えられた<parameter>conn</>が<symbol>NULL</>もしくは無効な接続であった場合、<symbol>NULL</>が返されます。
<structname>PGcancel</>オブジェクトは不透明な構造体であり、アプリケーションから直接アクセスすることができません。
これは<function>PQcancel</function>もしくは<function>PQfreeCancel</function>に渡すことしかできません。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqfreecancel">
     <term>
      <function>PQfreeCancel</function>
      <indexterm>
       <primary>PQfreeCancel</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
<!--
       Frees a data structure created by <function>PQgetCancel</function>.
-->
<function>PQgetCancel</function>で作成されたデータ構造を解放します。
<synopsis>
void PQfreeCancel(PGcancel *cancel);
</synopsis>
      </para>

      <para>
<!--
       <function>PQfreeCancel</function> frees a data object previously created
       by <function>PQgetCancel</function>.
-->
<function>PQfreeCancel</function>は事前に<function>PQgetCancel</function>で作成されたデータオブジェクトを解放します。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqcancel">
     <term>
      <function>PQcancel</function>
      <indexterm>
       <primary>PQcancel</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
<!--
       Requests that the server abandon processing of the current command.
-->
サーバに現在のコマンドの廃棄処理を要求します。
<synopsis>
int PQcancel(PGcancel *cancel, char *errbuf, int errbufsize);
</synopsis>
      </para>

      <para>
<!--
       The return value is 1 if the cancel request was successfully
       dispatched and 0 if not.  If not, <parameter>errbuf</> is filled
       with an explanatory error message.  <parameter>errbuf</>
       must be a char array of size <parameter>errbufsize</> (the
       recommended size is 256 bytes).
-->
キャンセル要求の受け入れが成功すれば1を、そうでなければ0を返します。
失敗した場合、<parameter>errbuf</>にそれを説明するエラーメッセージが収納されます。
<parameter>errbuf</>は<parameter>errbufsize</>サイズの文字配列でなければなりません。
(推奨サイズは256バイトです。)
      </para>

      <para>
<!--
       Successful dispatch is no guarantee that the request will have
       any effect, however.  If the cancellation is effective, the current
       command will terminate early and return an error result.  If the
       cancellation fails (say, because the server was already done
       processing the command), then there will be no visible result at
       all.
-->
しかし、要求の受け入れが成功したとしても、その要求の効果が出ることは全く保証していません。
もしキャンセル操作が有効であれば、現在のコマンドは間もなく中断され、エラーが結果として返ります。  
キャンセル操作に失敗した場合（例えばバックエンドがすでにコマンド処理を終了していたため）、目に見える結果は何も出てこなくなります。
      </para>

      <para>
<!--
       <function>PQcancel</function> can safely be invoked from a signal
       handler, if the <parameter>errbuf</> is a local variable in the
       signal handler.  The <structname>PGcancel</> object is read-only
       as far as <function>PQcancel</function> is concerned, so it can
       also be invoked from a thread that is separate from the one
       manipulating the <structname>PGconn</> object.
-->
<parameter>errbuf</>がシグナルハンドラ内のローカル変数であれば、<function>PQrequestCancel</function>はシグナルハンドラから起動しても問題ありません。
<function>PQcancel</function>の実行中、<structname>PGcancel</>は読み取りのみです。
従って、<structname>PGconn</>オブジェクトを操作するスレッドと別のスレッドからこの関数を呼び出すこともできます。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>

   <variablelist>
    <varlistentry id="libpq-pqrequestcancel">
     <term>
      <function>PQrequestCancel</function>
      <indexterm>
       <primary>PQrequestCancel</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
<!--
       <function>PQrequestCancel</function> is a deprecated variant of
       <function>PQcancel</function>.
-->
<function>PQrequestCancel</function>は<function>PQcancel</function>の廃止予定の変形版です。

<synopsis>
int PQrequestCancel(PGconn *conn);
</synopsis>
      </para>

      <para>
<!--
       Requests that the server abandon processing of the current
       command.  It operates directly on the
       <structname>PGconn</> object, and in case of failure stores the
       error message in the <structname>PGconn</> object (whence it can
       be retrieved by <function>PQerrorMessage</function>).  Although
       the functionality is the same, this approach creates hazards for
       multiple-thread programs and signal handlers, since it is possible
       that overwriting the <structname>PGconn</>'s error message will
       mess up the operation currently in progress on the connection.
-->
サーバに現在のコマンドの廃棄処理を要求します。
これは<structname>PGconn</>オブジェクトを直接扱い、また、失敗した場合エラーメッセージは<structname>PGconn</>オブジェクト内に収納されます。
(<function>PQerrorMessage</function>により取り出すことができます。)
機能的には同一ですが、<structname>PGconn</>のエラーメッセージが上書きされることにより、その接続で現在進行中の操作が壊れてしまうため、この方法は複数スレッドプログラムやシグナルハンドラでは問題が起こります。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

 </sect1>

 <sect1 id="libpq-fastpath">
<!--
  <title>The Fast-Path Interface</title>
-->
  <title>近道インタフェース</title>

  <indexterm zone="libpq-fastpath">
<!--
   <primary>fast path</primary>
-->
   <primary>近道</primary>
  </indexterm>

  <para>
<!--
   <productname>PostgreSQL</productname> provides a fast-path interface
   to send simple function calls to the server.
-->
<productname>PostgreSQL</productname>は、サーバへの簡単な関数呼び出しを送信する近道 (fast-path) インタフェースを用意しています。
  </para>

  <tip>
   <para>
<!--
    This interface is somewhat obsolete, as one can achieve similar
    performance and greater functionality by setting up a prepared
    statement to define the function call.  Then, executing the statement
    with binary transmission of parameters and results substitutes for a
    fast-path function call.
-->
この関数はどちらかというと廃れたものです。
同様の性能やそれ以上の機能を、関数呼び出しを定義したプリペアド文を設定することで達成できるからです。
そして、その文をパラメータと結果をバイナリ転送するように実行すれば、近道関数呼び出しを置き換えることになります。
   </para>
  </tip>

  <para>
<!--
   The function <function>PQfn</function><indexterm><primary>PQfn</></>
   requests execution of a server function via the fast-path interface:
-->
<function>PQfn</function>関数は近道インタフェースを使ってサーバ関数の実行を要求します。
<synopsis>
PGresult *PQfn(PGconn *conn,
               int fnid,
               int *result_buf,
               int *result_len,
               int result_is_int,
               const PQArgBlock *args,
               int nargs);

typedef struct
{
    int len;
    int isint;
    union
    {
        int *ptr;
        int integer;
    } u;
} PQArgBlock;
</synopsis>
  </para>

  <para>
<!--
   The <parameter>fnid</> argument is the OID of the function to be
   executed.  <parameter>args</> and <parameter>nargs</> define the
   parameters to be passed to the function; they must match the declared
   function argument list.  When the <parameter>isint</> field of a
   parameter structure is true, the <parameter>u.integer</> value is sent
   to the server as an integer of the indicated length (this must be 1,
   2, or 4 bytes); proper byte-swapping occurs.  When <parameter>isint</>
   is false, the indicated number of bytes at <parameter>*u.ptr</> are
   sent with no processing; the data must be in the format expected by
   the server for binary transmission of the function's argument data
   type.  <parameter>result_buf</parameter> is the buffer in which to
   place the return value.  The caller must  have  allocated sufficient
   space to store the return value.  (There is no check!) The actual result
   length will be returned in the integer pointed to  by
   <parameter>result_len</parameter>.  If a 1, 2, or 4-byte integer result
   is expected, set <parameter>result_is_int</parameter> to 1, otherwise
   set it to 0.  Setting <parameter>result_is_int</parameter> to 1 causes
   <application>libpq</> to byte-swap the value if necessary, so that it
   is delivered as a proper <type>int</type> value for the client machine.
   When <parameter>result_is_int</> is 0, the binary-format byte string
   sent by the server is returned unmodified.
-->
<parameter>fnid</>引数は実行する関数のOIDです。
<parameter>args</>と<parameter>nargs</>は関数に渡すパラメータを定義します。
これらは関数宣言における引数リストに一致しなければなりません。
パラメータ構造体の<parameter>isint</>が真の場合、<parameter>u.integer</>の値はサーバに指定長の整数として送信されます。
(これは1、2もしくは4バイトでなければなりません。)
この時、適切なバイト順の交換が行なわれます。
<parameter>isint</>が偽の場合は、<parameter>*u.ptr</>で指定されたバイト数が無処理で送信されます。
関数のパラメータデータ型をバイナリ転送で行うために、このデータはサーバで想定する書式である必要があります。
<parameter>result_buf</parameter>は戻り値を格納するバッファです。
呼び出し側は戻り値を格納するのに十分な領域を確保しておかなければいけません。
（ライブラリ側ではこの検査はしていません！）
結果の実データ長は<parameter>result_len</parameter>が指す整数で返されます。   
結果が1、2、4バイト整数だと想定できるなら<parameter>result_is_int</parameter>を1に、そうでなければ0を設定します。
<parameter>result_is_int</parameter>を1にすれば、必要に応じて値のバイト順を入れ換えるよう<application>libpq</>に指示することになります。 
そしてクライアントマシン上で正しい<type>int</type>値となるように転送します。  
<parameter>result_is_int</>が0の場合は、バックエンドが送ったバイナリ書式のバイト列を何も修正せずに返します。
  </para>

  <para>
<!--
   <function>PQfn</function> always returns a valid
   <structname>PGresult</structname> pointer. The result status should be
   checked before the result is used.   The caller is responsible for
   freeing  the  <structname>PGresult</structname>  with
   <function>PQclear</function> when it is no longer needed.
-->
<function>PQfn</function>は常に有効な<structname>PGresult*</structname>を返します。
結果を使う前にはまず、結果ステータスを調べておくべきでしょう。
結果が必要なくなった時点で、<function>PQclear</function>によって、<structname>PGresult</structname>を解放するのは、呼び出し側の責任です。
  </para>

  <para>
<!--
   Note that it is not possible to handle null arguments, null results,
   nor set-valued results when using this interface.
-->
このインタフェースを使用した場合、NULL引数やNULL結果、セット値の結果を扱うことができないことに注意してください。
  </para>

 </sect1>

 <sect1 id="libpq-notify">
<!--
  <title>Asynchronous Notification</title>
-->
<title>非同期通知</title>

  <indexterm zone="libpq-notify">
   <primary>NOTIFY</primary>
<!--
   <secondary>in libpq</secondary>
-->
   <secondary>libpqにおける</secondary>
  </indexterm>

  <para>
<!--
   <productname>PostgreSQL</productname> offers asynchronous notification
   via the <command>LISTEN</command> and <command>NOTIFY</command>
   commands.  A client session registers its interest in a particular
   notification channel with the <command>LISTEN</command> command (and
   can stop listening with the <command>UNLISTEN</command> command).  All
   sessions listening on a particular channel will be notified
   asynchronously when a <command>NOTIFY</command> command with that
   channel name is executed by any session. A <quote>payload</> string can
   be passed to communicate additional data to the listeners.
-->
<productname>PostgreSQL</productname>は、<command>LISTEN</command>と<command>NOTIFY</command>コマンドを使用した、非同期通知をサポートします。
クライアントセッションは、<command>LISTEN</command>コマンドを使用して処理対象とする特定の通知チャネルを登録します。
（通知監視を取り止めるには<command>UNLISTEN</command>コマンドを使用します。）
任意のセッションでそのチャネル名による<command>NOTIFY</command>コマンドが実行されると、特定チャネルを監視しているすべてのセッションは非同期に通知を受け取ります。
監視者に追加データを通信するために<quote>ペイロード</>文字列を渡すことができます。
  </para>

  <para>
<!--
   <application>libpq</application> applications submit
   <command>LISTEN</command>, <command>UNLISTEN</command>,
   and <command>NOTIFY</command> commands as
   ordinary SQL commands.  The arrival of <command>NOTIFY</command>
   messages can subsequently be detected by calling
   <function>PQnotifies</function>.<indexterm><primary>PQnotifies</></>
-->
<application>libpq</application>アプリケーションは、通常のSQLによる問い合わせと同じように<command>LISTEN</command>、<command>UNLISTEN</command>および<command>NOTIFY</command>コマンドを発行することができます。  
<command>NOTIFY</command>メッセージの到着は、続いて<function>PQnotifies</function>を呼び出せば検出できます。
<indexterm><primary>PQnotifies</></>
  </para>

  <para>
<!--
   The function <function>PQnotifies</function> returns the next notification
   from a list of unhandled notification messages received from the server.
   It returns a null pointer if there are no pending notifications.  Once a
   notification is returned from <function>PQnotifies</>, it is considered
   handled and will be removed from the list of notifications.
-->
<function>PQnotifies</function>関数は、サーバから受信した通知メッセージの未処理リストから次の通知を返します。  
保留中の通知がなくなればヌルポインタを返します。
<function>PQnotifies</>が通知を返すと、その通知は処理済みとみなされ、通知リストから取り除かれます。

<synopsis>
PGnotify *PQnotifies(PGconn *conn);

typedef struct pgNotify
{
<!--
    char *relname;              /* notification channel name */
    int  be_pid;                /* process ID of notifying server process */
    char *extra;                /* notification payload string */
-->
    char *relname;              /* 通知チャネル名 */
    int  be_pid;                /* 通知元サーバプロセスのプロセスID */
    char *extra;                /* 通知ペイロード文字列 */
} PGnotify;
</synopsis>

<!--
   After processing a <structname>PGnotify</structname> object returned
   by <function>PQnotifies</function>, be sure to free it with
   <function>PQfreemem</function>.  It is sufficient to free the
   <structname>PGnotify</structname> pointer; the
   <structfield>relname</structfield> and <structfield>extra</structfield>
   fields do not represent separate allocations.  (The names of these fields
   are historical; in particular, channel names need not have anything to
   do with relation names.)
-->
<function>PQnotifies</function>で返された<structname>PGnotify</structname>オブジェクトの処理が終わったら、<function>PQfreemem</function>を使用して確実に解放してください。
<structname>PGnotify</structname>ポインタを解放することは重要です。
<structfield>relname</structfield>と<structfield>extra</structfield>フィールドは別の割り当てを表していません。
(これらのフィールド名は歴史的なものです。特にチャネル名はリレーション名と関係するものである必要はありません。)
  </para>

  <para>
<!--
   <xref linkend="libpq-example-2"> gives a sample program that illustrates
   the use of asynchronous notification.
-->
<xref linkend="libpq-example-2">で非同期通知を使用したサンプルプログラムを示しています。
  </para>

  <para>
<!--
   <function>PQnotifies</function> does not actually read data from the
   server; it just returns messages previously absorbed by another
   <application>libpq</application> function.  In prior releases of
   <application>libpq</application>, the only way to ensure timely receipt
   of <command>NOTIFY</> messages was to constantly submit commands, even
   empty ones, and then check <function>PQnotifies</function> after each
   <function>PQexec</function>.  While this still works, it is deprecated
   as a waste of processing power.
-->
<function>PQnotifies()</function>は実際にサーバのデータを読み出すわけではありません。
これは単に、他の<application>libpq</application>関数が吸収してしまっていた通知メッセージを返すだけです。
<application>libpq</application>の以前のリリースでは、通知メッセージを適切な時点で確実に受け取るには、空の問い合わせでも何でも、とにかく一定時間ごとに問い合わせを送り、そして<function>PQexec()</function>を実行するたびに<function>PQnotifies()</function>を検査するしかありませんでした。
今でもこの方法は動作しますが、処理能力の無駄使いをすることになるのでやめておくべきでしょう。
  </para>

  <para>
<!--
   A better way to check for <command>NOTIFY</> messages when you have no
   useful commands to execute is to call
   <function>PQconsumeInput</function>, then check
   <function>PQnotifies</function>.  You can use
   <function>select()</function> to wait for data to arrive from the
   server, thereby using no <acronym>CPU</acronym> power unless there is
   something to do.  (See <function>PQsocket</function> to obtain the file
   descriptor number to use with <function>select()</function>.) Note that
   this will work OK whether you submit commands with
   <function>PQsendQuery</function>/<function>PQgetResult</function> or
   simply use <function>PQexec</function>.  You should, however, remember
   to check <function>PQnotifies</function> after each
   <function>PQgetResult</function> or <function>PQexec</function>, to
   see if any notifications came in during the processing of the command.
-->
実行すべき問い合わせがない時に通知メッセージを検査するよい方法は、まず<function>PQconsumeInput()</function>を呼び出し、それから<function>PQnotifies()</function>を検査することです。
サーバからのデータの到着を<function>select()</function>で待つことができ、不必要な動作で<acronym>CPU</acronym>パワーを消費してしまうことがありません。
（<function>select()</function>で使用するファイル記述子番号の取得については、<function>PQsocket()</function>を参照してください。）
なお、これは問い合わせに<function>PQsendQuery</function>と<function>PQgetResult</function>を使った時でも、またはおなじみの<function>PQexec</function>を使った時でも動作します。  
しかし通知がコマンドの処理中に届いていないかどうか、<function>PQgetResult</function>あるいは<function>PQexec</function>の実行ごとに<function>PQnotifies()</function>を調べることを忘れないようにしておくべきです。
  </para>

 </sect1>

 <sect1 id="libpq-copy">
<!--
  <title>Functions Associated with the <command>COPY</command> Command</title>
-->
<title><command>COPY</command>コマンド関連関数</title>

  <indexterm zone="libpq-copy">
   <primary>COPY</primary>
<!--
   <secondary>with libpq</secondary>
-->
   <secondary>libpqを使用した</secondary>
  </indexterm>

  <para>
<!--
   The <command>COPY</command> command in
   <productname>PostgreSQL</productname> has options to read from or write
   to the network connection used by <application>libpq</application>.
   The functions described in this section allow applications to take
   advantage of this capability by supplying or consuming copied data.
-->
<productname>PostgreSQL</productname>の<command>COPY</command>コマンドでは、<application>libpq</application>が使っているネットワーク接続に対して読み込み、あるいは書き込みを選ぶことができるようになっています。
本節で説明する関数により、アプリケーションはコピーするデータの提供やコピーされるデータの使用が可能になるという利点を持ちます。
  </para>

  <para>
<!--
   The overall process is that the application first issues the SQL
   <command>COPY</command> command via <function>PQexec</function> or one
   of the equivalent functions.  The response to this (if there is no
   error in the command) will be a <structname>PGresult</> object bearing
   a status code of <literal>PGRES_COPY_OUT</literal> or
   <literal>PGRES_COPY_IN</literal> (depending on the specified copy
   direction).  The application should then use the functions of this
   section to receive or transmit data rows.  When the data transfer is
   complete, another <structname>PGresult</> object is returned to indicate
   success or failure of the transfer.  Its status will be
   <literal>PGRES_COMMAND_OK</literal> for success or
   <literal>PGRES_FATAL_ERROR</literal> if some problem was encountered.
   At this point further SQL commands can be issued via
   <function>PQexec</function>.  (It is not possible to execute other SQL
   commands using the same connection while the <command>COPY</command>
   operation is in progress.)
-->
全体的な処理として、アプリケーションはまず<function>PQexec</function>もしくは同等な関数経由で<command>COPY</command> SQLコマンドを発行します。
（コマンドでエラーが発生しなければ）この応答は、（指定したコピーの方向に応じて）<literal>PGRES_COPY_OUT</literal>もしくは<literal>PGRES_COPY_IN</literal>という状態コードを持った<structname>PGresult</>になります。
その後、アプリケーションは本節の関数を使用して、行データを受信、もしくは、送信しなければなりません。
データの転送が完了した時、転送に成功したか失敗したかを示す別の<structname>PGresult</>オブジェクトが返されます。
その状態は、成功時には<literal>PGRES_COMMAND_OK</literal>になり、何らかの問題が起きていた時には <literal>PGRES_FATAL_ERROR</literal>になります。
この時点で、別のSQLコマンドを<function>PQexec</function>経由で発行することができます。
（<command>COPY</command>操作の実行中は、同じ接続を使用して他のSQLコマンドを実行することはできません。）
  </para>

  <para>
<!--
   If a <command>COPY</command> command is issued via
   <function>PQexec</function> in a string that could contain additional
   commands, the application must continue fetching results via
   <function>PQgetResult</> after completing the <command>COPY</command>
   sequence.  Only when <function>PQgetResult</> returns
   <symbol>NULL</symbol> is it certain that the <function>PQexec</function>
   command string is done and it is safe to issue more commands.
-->
<command>COPY</command>コマンドが、他にもコマンドを含んだ文字列として<function>PQexec</function>経由で発行された場合、アプリケーションは<command>COPY</command>処理を終えた後に、<function>PQgetResult</>経由で結果の取り出しを続けなければなりません。
<function>PQexec</function>コマンド文字列が完了し、その後のコマンドが安全に発行できることが確実になるのは、<function>PQgetResult</>が<symbol>NULL</symbol>を返す時のみです。
  </para>

  <para>
<!--
   The functions of this section should be executed only after obtaining
   a result status of <literal>PGRES_COPY_OUT</literal> or
   <literal>PGRES_COPY_IN</literal> from <function>PQexec</function> or
   <function>PQgetResult</function>.
-->
本節の関数は、<function>PQexec</function>もしくは<function>PQgetResult</function>から<literal>PGRES_COPY_OUT</literal>もしくは<literal>PGRES_COPY_IN</literal>という結果状態を得た後のみに実行されなければなりません。
  </para>

  <para>
<!--
   A <structname>PGresult</> object bearing one of these status values
   carries some additional data about the <command>COPY</command> operation
   that is starting.  This additional data is available using functions
   that are also used in connection with query results:
-->
これらの状態値の一つを持つ<structname>PGresult</>オブジェクトは、開始した<command>COPY</command>操作に関する追加データを持ちます。
この追加データは、以下の問い合わせ結果を持つ接続で使用される関数を使用して利用することができます。

   <variablelist>
    <varlistentry id="libpq-pqnfields-1">
     <term>
      <function>PQnfields</function>
      <indexterm>
       <primary>PQnfields</primary>
       <secondary>with COPY</secondary>
      </indexterm>
     </term>

     <listitem>
      <para>
<!--
       Returns the number of columns (fields) to be copied.
-->
コピーされる列(フィールド)数を返します。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqbinarytuples-1">
     <term>
      <function>PQbinaryTuples</function>
      <indexterm>
       <primary>PQbinaryTuples</primary>
       <secondary>with COPY</secondary>
      </indexterm>
     </term>

     <listitem>
      <para>
<!--
       0 indicates the overall copy format is textual (rows separated by
       newlines, columns separated by separator characters, etc).  1
       indicates the overall copy format is binary.  See <xref
       linkend="sql-copy"> for more information.
-->
0は、コピー全体の書式がテキスト(改行で区切られた行、区切り文字で区切られた列など)であることを示します。
1は、コピー全体の書式がバイナリであることを示します。
詳細は<xref linkend="sql-copy">を参照してください。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqfformat-1">
     <term>
      <function>PQfformat</function>
      <indexterm>
       <primary>PQfformat</primary>
       <secondary>with COPY</secondary>
      </indexterm>
     </term>

     <listitem>
      <para>
<!--
       Returns the format code (0 for text, 1 for binary) associated with
       each column of the copy operation.  The per-column format codes
       will always be zero when the overall copy format is textual, but
       the binary format can support both text and binary columns.
       (However, as of the current implementation of <command>COPY</>,
       only binary columns appear in a binary copy; so the per-column
       formats always match the overall format at present.)
-->
コピー操作対象の列それぞれに関した書式コード(テキストでは0、バイナリでは1)を返します。
コピー全体の書式がテキストの場合は、列単位の書式コードは常にゼロです。
しかし、バイナリ書式はテキスト列もバイナリ列もサポートすることができます。
(しかし、現在の<command>COPY</>実装では、バイナリコピーでのみバイナリ列が発生します。
そのため、今の所列単位の書式は常に全体の書式と一致します。)
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

  <note>
   <para>
<!--
    These additional data values are only available when using protocol
    3.0.  When using protocol 2.0, all these functions will return 0.
-->
これらの追加データ値はプロトコル3.0を使用した場合にのみ利用可能です。
プロトコル2.0を使用する場合は、これらの関数はすべて0を返します。
   </para>
  </note>

  <sect2 id="libpq-copy-send">
<!--
   <title>Functions for Sending <command>COPY</command> Data</title>
-->
   <title><command>COPY</command>データ送信用関数</title>

   <para>
<!--
    These functions are used to send data during <literal>COPY FROM
    STDIN</>.  They will fail if called when the connection is not in
    <literal>COPY_IN</> state.
-->
これらの関数は、<literal>COPY FROM STDIN</>期間にデータを送信するために使用されます。
接続が<literal>COPY_IN</>状態でない時に呼び出された場合、これらは失敗します。
   </para>

   <variablelist>
    <varlistentry id="libpq-pqputcopydata">
     <term>
      <function>PQputCopyData</function>
      <indexterm>
       <primary>PQputCopyData</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
<!--
       Sends data to the server during <literal>COPY_IN</> state.
-->
<literal>COPY_IN</>状態の間、サーバにデータを送信します。
<synopsis>
int PQputCopyData(PGconn *conn,
                  const char *buffer,
                  int nbytes);
</synopsis>
      </para>

      <para>
<!--
       Transmits the <command>COPY</command> data in the specified
       <parameter>buffer</>, of length <parameter>nbytes</>, to the server.
       The result is 1 if the data was sent, zero if it was not sent
       because the attempt would block (this case is only possible if the
       connection is in nonblocking mode), or -1 if an error occurred.
       (Use <function>PQerrorMessage</function> to retrieve details if
       the return value is -1.  If the value is zero, wait for write-ready
       and try again.)
-->
指定した<parameter>buffer</>にある<command>COPY</command>データを<parameter>nbytes</>長分、サーバに送信します。
データが送信された場合、この結果は1になります。
送信試行がブロックされたために送信できなかった場合はゼロになります。
（これは、接続が非ブロックモードの場合にのみ起こります。）
エラーが発生した場合は-1になります。
（戻り値が-1の場合、詳細を取り出すためには<function>PQerrorMessage</function>を使用してください。
戻り値がゼロの場合は書き込み準備が整うまで待ち、再実行してください。）
      </para>

      <para>
<!--
       The application can divide the <command>COPY</command> data stream
       into buffer loads of any convenient size.  Buffer-load boundaries
       have no semantic significance when sending.  The contents of the
       data stream must match the data format expected by the
       <command>COPY</> command; see <xref linkend="sql-copy"> for details.
-->
アプリケーションは<command>COPY</command>データストリームを使いやすい大きさのバッファに分けて読み込むことができます。
送信時の読み込みバッファの境界には意味的な重要性はありません。
データストリームの内容は、<command>COPY</>コマンドで想定しているデータ書式に一致している必要があります。
詳細は<xref linkend="sql-copy">を参照してください。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqputcopyend">
     <term>
      <function>PQputCopyEnd</function>
      <indexterm>
       <primary>PQputCopyEnd</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
<!--
       Sends end-of-data indication to the server during <literal>COPY_IN</> state.
-->
<literal>COPY_IN</>状態の間に、サーバにデータ終了指示を送信します。
<synopsis>
int PQputCopyEnd(PGconn *conn,
                 const char *errormsg);
</synopsis>
      </para>

      <para>
<!--
       Ends the <literal>COPY_IN</> operation successfully if
       <parameter>errormsg</> is <symbol>NULL</symbol>.  If
       <parameter>errormsg</> is not <symbol>NULL</symbol> then the
       <command>COPY</> is forced to fail, with the string pointed to by
       <parameter>errormsg</> used as the error message.  (One should not
       assume that this exact error message will come back from the server,
       however, as the server might have already failed the
       <command>COPY</> for its own reasons.  Also note that the option
       to force failure does not work when using pre-3.0-protocol
       connections.)
-->
<parameter>errormsg</>が<symbol>NULL</symbol>の場合は、<literal>COPY_IN</>操作の終了に成功しました。
<parameter>errormsg</>が<symbol>NULL</symbol>でない場合は、<command>COPY</>は強制的に失敗させられました。
<parameter>errormsg</>が指し示す文字列はエラーメッセージとして使用されます。
（しかし、このエラーメッセージが正しくサーバから返ったものであるとは仮定すべきではありません。
サーバは既に別の原因で<command>COPY</>に失敗していた可能性があります。
また、この強制的な失敗は3.0より前のプロトコルの接続を使用している場合は動作しません。）
      </para>

      <para>
<!--
       The result is 1 if the termination data was sent, zero if it was
       not sent because the attempt would block (this case is only possible
       if the connection is in nonblocking mode), or -1 if an error
       occurred.  (Use <function>PQerrorMessage</function> to retrieve
       details if the return value is -1.  If the value is zero, wait for
       write-ready and try again.)
-->
終端データが送信された場合は結果は1になります。
送信試行がブロックされたため送信できなかった場合はゼロになります。
（これは、接続が非ブロックモードの場合にのみ起こります。）
エラーが発生した場合は-1になります。
（戻り値が-1の場合、詳細を取り出すためには<function>PQerrorMessage</function>を使用してください。
戻り値がゼロの場合は書き込み準備が整うまで待ち、再実行してください。）
      </para>

      <para>
<!--
       After successfully calling <function>PQputCopyEnd</>, call
       <function>PQgetResult</> to obtain the final result status of the
       <command>COPY</> command.  One can wait for this result to be
       available in the usual way.  Then return to normal operation.
-->
<function>PQputCopyEnd</>の呼び出しに成功した後、<function>PQgetResult</>を呼び出して<command>COPY</>コマンドの最終的な結果状態を取り出してください。
通常の方法でこの結果が使用できるようになるまで待機しても構いません。
そして、通常の操作に戻ってください。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>

  </sect2>

  <sect2 id="libpq-copy-receive">
<!--
   <title>Functions for Receiving <command>COPY</command> Data</title>
-->
   <title><command>COPY</command>データ受信用関数</title>

   <para>
<!--
    These functions are used to receive data during <literal>COPY TO
    STDOUT</>.  They will fail if called when the connection is not in
    <literal>COPY_OUT</> state.
-->
これらの関数は<literal>COPY TO STDOUT</>時にデータを受信するために使用されます。
<literal>COPY_OUT</>状態以外の接続で呼び出すと、失敗します。
   </para>

   <variablelist>
    <varlistentry id="libpq-pqgetcopydata">
     <term>
      <function>PQgetCopyData</function>
      <indexterm>
       <primary>PQgetCopyData</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
<!--
       Receives data from the server during <literal>COPY_OUT</> state.
-->
<literal>COPY_OUT</>状態時にサーバからデータを受信します。

<synopsis>
int PQgetCopyData(PGconn *conn,
                  char **buffer,
                  int async);
</synopsis>
      </para>

      <para>
<!--
       Attempts to obtain another row of data from the server during a
       <command>COPY</command>.  Data is always returned one data row at
       a time; if only a partial row is available, it is not returned.
       Successful return of a data row involves allocating a chunk of
       memory to hold the data.  The <parameter>buffer</> parameter must
       be non-<symbol>NULL</symbol>.  <parameter>*buffer</> is set to
       point to the allocated memory, or to <symbol>NULL</symbol> in cases
       where no buffer is returned.  A non-<symbol>NULL</symbol> result
       buffer should be freed using <function>PQfreemem</> when no longer
       needed.
-->
<command>COPY</command>期間中、サーバから別の行データの入手を試みます。
常に1度に1つの行データが返されます。
部分的な行のみが利用可能な場合は返されません。
行データの取得に成功することは、そのデータを保持するためのメモリチャンクの割り当てを意味します。
<parameter>buffer</>パラメータは非<symbol>NULL</symbol>でなければなりません。
<parameter>*buffer</>は割り当てられたメモリへのポインタに、バッファが返されなかった場合は<symbol>NULL</symbol>に設定されます。
非<symbol>NULL</symbol>の結果バッファは、不要になったら<function>PQfreemem</>を使用して解放しなければなりません。
      </para>

      <para>
<!--
       When a row is successfully returned, the return value is the number
       of data bytes in the row (this will always be greater than zero).
       The returned string is always null-terminated, though this is
       probably only useful for textual <command>COPY</command>.  A result
       of zero indicates that the <command>COPY</command> is still in
       progress, but no row is yet available (this is only possible when
       <parameter>async</> is true).  A result of -1 indicates that the
       <command>COPY</command> is done.  A result of -2 indicates that an
       error occurred (consult <function>PQerrorMessage</> for the reason).
-->
行の取り込みに成功した時、戻り値は行内のデータのバイト数になります。
(これは常に0より大きくなります。)
返された文字列は常にヌル終端ですが、おそらくテキスト<command>COPY</command>でのみ有用になるでしょう。
ゼロという結果は、<command>COPY</command>が進行中で、行がまだ利用できない状態であることを示します。
(<parameter>async</>が真の場合にのみ発生することがあります。)
-1という結果は、<command>COPY</command>が完了したことを示します。
-2という結果はエラーが発生したことを示します。
(その理由については<function>PQerrorMessage</>を参照してください。)
      </para>

      <para>
<!--
       When <parameter>async</> is true (not zero),
       <function>PQgetCopyData</> will not block waiting for input; it
       will return zero if the <command>COPY</command> is still in progress
       but no complete row is available.  (In this case wait for read-ready
       and then call <function>PQconsumeInput</> before calling
       <function>PQgetCopyData</> again.)  When <parameter>async</> is
       false (zero), <function>PQgetCopyData</> will block until data is
       available or the operation completes.
-->
<parameter>async</>が真(非0)の場合、<function>PQgetCopyData</>は入力待ちのためのブロックを行いません。
<command>COPY</command>実行中で完全な行を取り出せない場合<function>PQgetCopyData</>は0を返します。
(この場合、再試行の前に読み込み準備が整うまで待機してください。
<function>PQconsumeInput</>を呼び出したかどうかは関係ありません。)
<parameter>async</>が偽(0)の場合、<function>PQgetCopyData</>はデータが利用できるようになるまで、もしくは、操作が完了するまでブロックします。
      </para>

      <para>
<!--
       After <function>PQgetCopyData</> returns -1, call
       <function>PQgetResult</> to obtain the final result status of the
       <command>COPY</> command.  One can wait for this result to be
       available in the usual way.  Then return to normal operation.
-->
<function>PQgetCopyData</>が-1を返した後、<function>PQgetResult</>を呼び出して、<command>COPY</>コマンドの最終結果状態を取り出してください。
通常の方法で結果が利用できるようになるまで待機しても構いません。
そして、通常の操作に戻ってください。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>

  </sect2>

  <sect2 id="libpq-copy-deprecated">
<!--
   <title>Obsolete Functions for <command>COPY</command></title>
-->
   <title>廃れた<command>COPY</command>用関数</title>

   <para>
<!--
    These functions represent older methods of handling <command>COPY</>.
    Although they still work, they are deprecated due to poor error handling,
    inconvenient methods of detecting end-of-data, and lack of support for binary
    or nonblocking transfers.
-->
以下の関数は<command>COPY</>を取扱う、古めの手法を行います。
これらはまだ動作しますが、エラーの取扱いが貧弱であることやデータの終端を検知する方法が不便であることより使用を奨めません。
   </para>

   <variablelist>
    <varlistentry id="libpq-pqgetline">
     <term>
      <function>PQgetline</function>
      <indexterm>
       <primary>PQgetline</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
<!--
       Reads  a  newline-terminated  line  of  characters (transmitted
       by the server) into a buffer string of size <parameter>length</>.
-->
改行で終端する文字列（サーバから送信されたもの）を長さ<parameter>length</>のバッファ用文字列に読み込みます。
<synopsis>
int PQgetline(PGconn *conn,
              char *buffer,
              int length);
</synopsis>
      </para>

      <para>
<!--
       This function copies up to <parameter>length</>-1 characters into
       the buffer and converts the terminating newline into a zero byte.
       <function>PQgetline</function> returns <symbol>EOF</symbol> at the
       end of input, 0 if the entire line has been read, and 1 if the
       buffer is full but the terminating newline has not yet been read.
-->
この関数はバッファに<parameter>length</>-1個までの文字をコピーし、終端の改行を1バイトのゼロに置き換えます。
<function>PQgetline</function>は、入力の終端では<literal>EOF</literal>を、行全体が読み込まれれば0を返します。
そしてまだ終端の改行が読み込まれていないうちにバッファがいっぱいになってしまった場合は1を返します。
       </para>
       <para>
<!--
       Note that the application must check to see if a new line consists
       of  the  two characters  <literal>\.</literal>, which  indicates
       that the server has finished sending the results  of  the
       <command>COPY</command> command.  If  the  application might receive
       lines that are more than <parameter>length</>-1  characters  long,
       care is needed to be sure it recognizes the <literal>\.</literal>
       line correctly (and does not, for example, mistake the end of a
       long data line for a terminator line).
-->
アプリケーションは新しく読み込んだ行が、<literal>\.</literal>という2文字であるかどうか確認しなければいけません。 
この2文字は、<command>COPY</command>コマンドの結果をサーバが送信し終えたことを示すものです。
アプリケーションには、仮に<parameter>length</>-1文字より長い行を受け取るようなことがあっても、間違いなく<literal>\.</literal>行を認識するような配慮が必要です
（また例えば長いデータの行の終端を、最終行と取り違えないようにもしてください）。 
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqgetlineasync">
     <term>
      <function>PQgetlineAsync</function>
      <indexterm>
       <primary>PQgetlineAsync</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
<!--
       Reads a row of <command>COPY</command> data (transmitted  by the
       server) into a buffer without blocking.
-->
<command>COPY</command>データ行（サーバから送信されたもの）を、ブロッキングなしでバッファに読み込みます。
<synopsis>
int PQgetlineAsync(PGconn *conn,
                   char *buffer,
                   int bufsize);
</synopsis>
      </para>

      <para>
<!--
       This function is similar to <function>PQgetline</function>, but it can be used
       by applications
       that must read <command>COPY</command> data asynchronously, that is, without blocking.
       Having issued the <command>COPY</command> command and gotten a <literal>PGRES_COPY_OUT</literal>
       response, the
       application should call <function>PQconsumeInput</function> and
       <function>PQgetlineAsync</function> until the
       end-of-data signal is detected.
-->
<function>PQgetline</function>と似ていますが、<command>COPY</command>のデータを非同期的に、つまりブロッキングなしで読み出さなければならないアプリケーションで使用することができます。
<command>COPY</command>コマンドを発行し、そして<literal>PGRES_COPY_OUT</literal>応答を受け取ったら、アプリケーションはデータ終了の合図を受け取るまで<function>PQconsumeInput</function>と<function>PQgetlineAsync</function>を呼び出します。  
       </para>
       <para>
<!--
       Unlike <function>PQgetline</function>, this function takes
       responsibility for detecting end-of-data.
-->
<function>PQgetline</function>と違い、この関数はデータ終了の検出に対して責任を持ちます。 
      </para>

      <para>
<!--
       On each call, <function>PQgetlineAsync</function> will return data if a
       complete data row is available in <application>libpq</>'s input buffer.
       Otherwise, no data is returned until the rest of the row arrives.
       The function returns -1 if the end-of-copy-data marker has been recognized,
       or 0 if no data is available, or a positive number giving the number of
       bytes of data returned.  If -1 is returned, the caller must next call
       <function>PQendcopy</function>, and then return to normal processing.
-->
<function>PQgetlineAsync</function>の個々の呼び出しでは、<application>libpq</>の入力バッファ内で完全な行データが利用できる場合にデータを返します。
さもなければ、行の残りが届くまでデータは返されません。
この関数は、コピーデータの終端を示す符号を認識すると-1を、また何もデータがなければ0を、そしてデータを返す場合はそのバイト数を正の値で返します。
もし-1が返されたら、呼び出し側は次に<function>PQendcopy</function>を呼び出さなければいけません。 
それから通常の処理に戻ります。 
      </para>

      <para>
<!--
       The data returned will not extend beyond a data-row boundary.  If possible
       a whole row will be returned at one time.  But if the buffer offered by
       the caller is too small to hold a row sent by the server, then a partial
       data row will be returned.  With textual data this can be detected by testing
       whether the last returned byte is <literal>\n</literal> or not.  (In a binary
       <command>COPY</>, actual parsing of the <command>COPY</> data format will be needed to make the
       equivalent determination.)
       The returned string is not null-terminated.  (If you want to add a
       terminating null, be sure to pass a <parameter>bufsize</parameter> one smaller
       than the room actually available.)
-->
返されるデータは行データの境界を越えて拡張されることはありません。
可能であれば行全体を一度に返します。
しかし呼び出し側が準備したバッファが少なすぎ、サーバから送られてくる行を保持しておくことができない場合には、分割された行データを返します。
テキストデータでは、これは最後の1バイトが<literal>\n</literal>かどうかを確認すれば検出できます。 
（バイナリ<command>COPY</>の場合に同様の検出を行うためには、実際に<command>COPY</>データの書式を解析しなければなりません。）
なお、返される文字列はヌル終端ではありません。
（ヌル終端を後から付け加えるのであれば、実際に確保するバッファサイズ-1を<parameter>bufsize</parameter>として渡すようにしてください。）
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqputline">
     <term>
      <function>PQputline</function>
      <indexterm>
       <primary>PQputline</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
<!--
       Sends  a  null-terminated  string  to  the server.  Returns 0 if
       OK and <symbol>EOF</symbol> if unable to send the string.
-->
サーバにヌル終端の文字列を送信します。
問題なければ0を返します。
文字列の送信ができなかった場合は<symbol>EOF</symbol>を返します。
<synopsis>
int PQputline(PGconn *conn,
              const char *string);
</synopsis>
      </para>

      <para>
<!--
       The <command>COPY</command> data stream sent by a series of calls
       to <function>PQputline</function> has the same format as that
       returned by <function>PQgetlineAsync</function>, except that
       applications are not obliged to send exactly one data row per
       <function>PQputline</function> call; it is okay to send a partial
       line or multiple lines per call.
-->
<function>PQputline</function>の呼び出しによって送信される<command>COPY</command>データストリームは、<function>PQgetlineAsync</function>で返される書式と同じ書式を持ちます。
ただし、アプリケーションは、<function>PQputline</function>毎に正確に1つのデータ行を送信するように強制されていません。
呼び出し毎に行の一部や複数の行を送信しても問題ありません。
      </para>

      <note>
       <para>
<!--
        Before <productname>PostgreSQL</productname> protocol 3.0, it was necessary
        for the application to explicitly send the two characters
        <literal>\.</literal> as a final line to indicate to the server that it had
        finished sending <command>COPY</> data.  While this still works, it is deprecated and the
        special meaning of <literal>\.</literal> can be expected to be removed in a
        future release.  It is sufficient to call <function>PQendcopy</function> after
        having sent the actual data.
-->
<productname>PostgreSQL</productname>プロトコル3.0より前では、アプリケーションは、サーバに対して<command>COPY</>データの送信を完了したことを通知するために、最終の行として<literal>\.</literal>という2文字を明示的に送信する必要がありました。
これはまだ動作します。
しかし、これは廃れたものとして、<literal>\.</literal>の特殊な意味は将来のリリースで無くなることが予想されます。
実際のデータの送信完了後に<function>PQendcopy</function>を呼び出すことが重要です。
       </para>
      </note>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqputnbytes">
     <term>
      <function>PQputnbytes</function>
      <indexterm>
       <primary>PQputnbytes</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
<!--
       Sends  a  non-null-terminated  string  to  the server.  Returns
       0 if OK and <symbol>EOF</symbol> if unable to send the string.
-->
ヌル終端ではない文字列をサーバに送信します。
問題なければ0を返します。
文字列の送信ができなかった場合は<symbol>EOF</symbol>を返します。
<synopsis>
int PQputnbytes(PGconn *conn,
                const char *buffer,
                int nbytes);
</synopsis>
      </para>

      <para>
<!--
       This is exactly like <function>PQputline</function>, except that the data
       buffer need not be null-terminated since the number of bytes to send is
       specified directly.  Use this procedure when sending binary data.
-->
これはまさに<function>PQputline</function>と同様です。
ただし、直接送信バイト数を指定するため、ヌル終端である必要がありません。
バイナリデータを送信する時はこのプロシージャを使用してください。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqendcopy">
     <term>
      <function>PQendcopy</function>
      <indexterm>
       <primary>PQendcopy</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
<!--
       Synchronizes with the server.
-->
サーバと同期します。
<synopsis>
int PQendcopy(PGconn *conn);
</synopsis>
<!--
       This function waits until the  server  has  finished  the copying.
       It should either be issued when the  last  string  has  been sent
       to  the  server using <function>PQputline</function> or when the
       last string has been  received  from  the  server using
       <function>PGgetline</function>.  It must be issued or the server
       will get <quote>out of sync</quote> with  the client.   Upon return
       from this function, the server is ready to receive the next SQL
       command.  The return value is 0  on  successful  completion,
       nonzero otherwise.  (Use <function>PQerrorMessage</function> to
       retrieve details if the return value is nonzero.)
-->
この関数はサーバがコピーを完了するのを待ちます。
この関数は、<function>PQputline</function>を使ったサーバへの文字列送信が完了した時点、あるいは<function>PGgetline</function>を使ったサーバからの文字列受信が完了した時点のいずれでも呼び出さなければなりません。
これを発行しないと、サーバはクライアントとの<quote>同期がずれた</quote>状態になってしまいます。   
この関数から戻った時点で、サーバは次のSQLコマンドを受ける準備が整います。
正常に終了した場合、返り値は0です。 さもなくば、非ゼロです。
（戻り値が非ゼロの場合、<function>PQerrorMessage</function>を使用して詳細を取り出してください。）
      </para>

      <para>
<!--
       When using <function>PQgetResult</function>, the application should
       respond to a <literal>PGRES_COPY_OUT</literal> result by executing
       <function>PQgetline</function> repeatedly, followed by
       <function>PQendcopy</function> after the terminator line is seen.
       It should then return to the <function>PQgetResult</function> loop
       until <function>PQgetResult</function> returns a null pointer.
       Similarly a <literal>PGRES_COPY_IN</literal> result is processed
       by a series of <function>PQputline</function> calls followed by
       <function>PQendcopy</function>, then return to the
       <function>PQgetResult</function> loop.  This arrangement will
       ensure that a <command>COPY</command> command embedded in a series
       of <acronym>SQL</acronym> commands will be executed correctly.
-->
<function>PQgetResult</function>を使う場合、アプリケーションは<function>PQgetline</function>を繰り返し呼び出して<literal>PGRES_COPY_OUT</literal>に応答し、終端行を見つけたら続いて<function>PQendcopy</function>を呼び出さなければなりません。
それから、<function>PQgetResult</function>がヌルポインタを返すまで、<function>PQgetResult</function>のループに戻らなければなりません。
同じように <literal>PGRES_COPY_IN</literal>は連続した<function>PQputline</function>で処理し、それから<function>PQendcopy</function>で締めくくった後に<function>PQgetResult</function>のループに戻ります。
このようにすることで、一連の<acronym>SQL</acronym>コマンド群に含めた<command>COPY</command>コマンドを確実に、また正しく実行できるはずです。
      </para>

      <para>
<!--
       Older applications are likely to submit a <command>COPY</command>
       via <function>PQexec</function> and assume that the transaction
       is done after <function>PQendcopy</function>.  This will work
       correctly only if the <command>COPY</command> is the only
       <acronym>SQL</acronym> command in the command string.
-->
比較的古いアプリケーションでは、<command>COPY</command>を<function>PQexec</function>で実行し、<function>PQendcopy</function>の実行でトランザクションは完了する、と想定していることがよくあります。 
これはコマンド文字列中の<acronym>SQL</acronym>が<command>COPY</command>だけであった時にのみ正しく動作します。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>

  </sect2>

 </sect1>

 <sect1 id="libpq-control">
<!--
  <title>Control Functions</title>
-->
  <title>制御関数</title>

  <para>
<!--
   These functions control miscellaneous details of <application>libpq</>'s
   behavior.
-->
これらの関数は<application>libpq</>の動作の各種詳細を制御します。
  </para>

  <variablelist>
   <varlistentry id="libpq-pqclientencoding">
    <term>
     <function>PQclientEncoding</function>
     <indexterm>
      <primary>PQclientEncoding</primary>
     </indexterm>
    </term>

    <listitem>
     <para>
<!--
      Returns the client encoding.
-->
クライアント符号化方式を返します。
<synopsis>
int PQclientEncoding(const PGconn *<replaceable>conn</replaceable>);
</synopsis>

<!--
      Note that it returns the encoding ID, not a symbolic string
      such as <literal>EUC_JP</literal>. If unsuccessful, it returns -1.
      To convert an encoding ID to an encoding name, you
      can use:
-->
これが<literal>EUC_JP</literal>などのシンボル文字列ではなく符号化方式IDを返すことに注意してください。
成功しなかった場合には、-1が返ります。
符号化方式IDを符号化方式名に変換するためには以下を使用してください。

<synopsis>
char *pg_encoding_to_char(int <replaceable>encoding_id</replaceable>);
</synopsis>
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-pqsetclientencoding">
    <term>
     <function>PQsetClientEncoding</function>
     <indexterm>
      <primary>PQsetClientEncoding</primary>
     </indexterm>
    </term>

    <listitem>
     <para>
<!--
      Sets the client encoding.
-->
クライアント符号化方式を設定します。
<synopsis>
int PQsetClientEncoding(PGconn *<replaceable>conn</replaceable>, const char *<replaceable>encoding</replaceable>);
</synopsis>

<!--
      <replaceable>conn</replaceable> is a connection to the server,
      and <replaceable>encoding</replaceable> is the encoding you want to
      use. If the function successfully sets the encoding, it returns 0,
      otherwise -1. The current encoding for this connection can be
      determined by using <function>PQclientEncoding</>.
-->
<replaceable>conn</replaceable>はサーバへの接続、<replaceable>encoding</replaceable>は使用したい符号化方式です。
この関数は符号化方式の設定に成功すると、ゼロを返します。
さもなくば-1を返します。
この接続における現在の符号化方式は<function>PQclientEncoding</>を使用して決定することができます。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-pqseterrorverbosity">
    <term>
     <function>PQsetErrorVerbosity</function>
     <indexterm>
      <primary>PQsetErrorVerbosity</primary>
     </indexterm>
    </term>

    <listitem>
     <para>
<!--
      Determines the verbosity of messages returned by
      <function>PQerrorMessage</> and <function>PQresultErrorMessage</>.
-->
<function>PQerrorMessage</>と<function>PQresultErrorMessage</>で返されるメッセージの冗長度を決定します。
<synopsis>
typedef enum
{
    PQERRORS_TERSE,
    PQERRORS_DEFAULT,
    PQERRORS_VERBOSE
} PGVerbosity;

PGVerbosity PQsetErrorVerbosity(PGconn *conn, PGVerbosity verbosity);
</synopsis>

<!--
      <function>PQsetErrorVerbosity</> sets the verbosity mode, returning
      the connection's previous setting.  In <firstterm>TERSE</> mode,
      returned messages include severity, primary text, and position only;
      this will normally fit on a single line.  The default mode produces
      messages that include the above plus any detail, hint, or context
      fields (these might span multiple lines).  The <firstterm>VERBOSE</>
      mode includes all available fields.  Changing the verbosity does not
      affect the messages available from already-existing
      <structname>PGresult</> objects, only subsequently-created ones.
-->
<function>PQsetErrorVerbosity</>は冗長度モードを設定し、接続における以前の状態を返します。
<firstterm>TERSE</>モードでは、返されるメッセージには深刻度、主テキスト、位置のみが含まれます。
これは通常単一行に収まります。
デフォルトモードでは、上に加え、詳細、ヒント、文脈フィールドが含まれるメッセージが生成されます。
（これは複数行に跨るかもしれません。）
<firstterm>VERBOSE</>モードでは、すべての利用可能なフィールドが含まれます。
冗長度の変更は、既に存在する<structname>PGresult</>オブジェクト内から取り出せるメッセージには影響を与えません。
その後に作成されたオブジェクトにのみ影響を与えます。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-pqtrace">
    <term>
     <function>PQtrace</function>
     <indexterm>
      <primary>PQtrace</primary>
     </indexterm>
    </term>

    <listitem>
     <para>
<!--
      Enables  tracing of the client/server communication to a debugging file stream.
-->
クライアント／サーバ間の通信トレースを有効にし、デバッグ用のファイルストリームに書き出します。
<synopsis>
void PQtrace(PGconn *conn, FILE *stream);
</synopsis>
     </para>

     <note>
      <para>
<!--
       On Windows, if the <application>libpq</> library and an application are
       compiled with different flags, this function call will crash the
       application because the internal representation of the <literal>FILE</>
       pointers differ.  Specifically, multithreaded/single-threaded,
       release/debug, and static/dynamic flags should be the same for the
       library and all applications using that library.
-->
Windowsにおいて、<application>libpq</>ライブラリとアプリケーションを異なるフラグでコンパイルすると、この関数呼び出しで<literal>FILE</>ポインタの内部表現の違いによりアプリケーションはクラッシュするでしょう。
特に、このライブラリを使用するアプリケーションでは、マルチスレッド/シングルスレッド、リリース/デバッグ、静的リンク/動的リンクに関して、ライブラリと同じフラグを使わなければなりません。
      </para>
     </note>

    </listitem>
   </varlistentry>

   <varlistentry id="libpq-pquntrace">
    <term>
     <function>PQuntrace</function>
     <indexterm>
      <primary>PQuntrace</primary>
     </indexterm>
    </term>

    <listitem>
     <para>
<!--
      Disables tracing started by <function>PQtrace</function>.
-->
<function>PQtrace</function>によって起動されたトレース処理を無効にします。
<synopsis>
void PQuntrace(PGconn *conn);
</synopsis>
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

 </sect1>

 <sect1 id="libpq-misc">
<!--
  <title>Miscellaneous Functions</title>
-->
<title>雑多な関数</title>

  <para>
<!--
   As always, there are some functions that just don't fit anywhere.
-->
よくあることですが、うまく分類できない関数がいくつか存在します。
  </para>

  <variablelist>
   <varlistentry id="libpq-pqfreemem">
    <term>
     <function>PQfreemem</function>
     <indexterm>
      <primary>PQfreemem</primary>
     </indexterm>
    </term>

    <listitem>
     <para>
<!--
      Frees memory allocated by <application>libpq</>.
-->
<application>libpq</>が割り当てたメモリを解放します。
<synopsis>
void PQfreemem(void *ptr);
</synopsis>
     </para>

     <para>
<!--
      Frees memory allocated by <application>libpq</>, particularly
      <function>PQescapeByteaConn</function>,
      <function>PQescapeBytea</function>,
      <function>PQunescapeBytea</function>,
      and <function>PQnotifies</function>.
      It is particularly important that this function, rather than
      <function>free()</>, be used on Microsoft Windows.  This is because
      allocating memory in a DLL and releasing it in the application works
      only if multithreaded/single-threaded, release/debug, and static/dynamic
      flags are the same for the DLL and the application.  On non-Microsoft
      Windows platforms, this function is the same as the standard library
      function <function>free()</>.
-->
具体的には<function>PQescapeByteaConn</function>、<function>PQescapeBytea</function>、<function>PQunescapeBytea</function>および<function>PQnotifies</function>により<application>libpq</>が割り当てたメモリを解放します。
Microsoft Windowsにおいて<function>free()</>ではなく、この関数を使用することが特に重要です。
DLLにおけるメモリ割り当てとアプリケーションにおけるその解放が、DLLとアプリケーションとでマルチスレッド/シングルスレッド、リリース用/デバッグ用、静的/動的フラグが同じ場合でのみ動作するためです。
Microsoft Windowsプラットフォーム以外では、この関数は標準ライブラリの<function>free()</>関数と同じです。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-pqconninfofree">
    <term>
     <function>PQconninfoFree</function>
     <indexterm>
      <primary>PQconninfoFree</primary>
     </indexterm>
    </term>

    <listitem>
     <para>
<!--
      Frees the data structures allocated by
      <function>PQconndefaults</> or <function>PQconninfoParse</>.
-->
<function>PQconndefaults</>もしくは<function>PQconninfoParse</>が割り当てたデータ構造を解放します。
<synopsis>
void PQconninfoFree(PQconninfoOption *connOptions);
</synopsis>
     </para>

     <para>
<!--
      A simple <function>PQfreemem</function> will not do for this, since
      the array contains references to subsidiary strings.
-->
単純な<function>PQfreemem</function>は、配列が補助文字列への参照を含んでいることから、このためには作業しません。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-pqencryptpassword">
    <term>
     <function>PQencryptPassword</function>
     <indexterm>
      <primary>PQencryptPassword</primary>
     </indexterm>
    </term>

    <listitem>
     <para>
<!--
      Prepares the encrypted form of a <productname>PostgreSQL</> password.
-->
<productname>PostgreSQL</>パスワードの暗号化された形式を準備します。
<synopsis>
char * PQencryptPassword(const char *passwd, const char *user);
</synopsis>
<!--
      This function is intended to be used by client applications that
      wish to send commands like <literal>ALTER USER joe PASSWORD
      'pwd'</>.  It is good practice not to send the original cleartext
      password in such a command, because it might be exposed in command
      logs, activity displays, and so on.  Instead, use this function to
      convert the password to encrypted form before it is sent.  The
      arguments are the cleartext password, and the SQL name of the user
      it is for.  The return value is a string allocated by
      <function>malloc</function>, or <symbol>NULL</symbol> if out of
      memory.  The caller can assume the string doesn't contain any
      special characters that would require escaping.  Use
      <function>PQfreemem</> to free the result when done with it.
-->
この関数は、<literal>ALTER USER joe PASSWORD 'pwd'</>のようなコマンドを送信したいクライアントアプリケーションで使用されることを意図したものです。
こうしたコマンドでは、コマンドログが活動の監視などで晒されてしまうため、元々の平文テキストでパスワードを送信しないことが推奨されています。
その代わりに、この関数を使用して送信前にパスワードを暗号化形式に変換してください。
引数は平文のパスワードとそのSQL上のユーザ名です。
戻り値は<function>malloc</function>で割り当てられた文字列です。
メモリ不足の場合に<symbol>NULL</symbol>が返されます。
呼び出し元は、その文字列にエスケープしなければならない特殊な文字列が含まれていないことを仮定することができます。
処理が終わった時に<function>PQfreemem</>を使用して結果を解放してください。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-pqmakeemptypgresult">
    <term>
     <function>PQmakeEmptyPGresult</function>
     <indexterm>
      <primary>PQmakeEmptyPGresult</primary>
     </indexterm>
    </term>

    <listitem>
     <para>
<!--
      Constructs an empty <structname>PGresult</structname> object with the given status.
-->
与えられたステータスで空の<structname>PGresult</structname>オブジェクトを構築します。
      
<synopsis>
PGresult *PQmakeEmptyPGresult(PGconn *conn, ExecStatusType status);
</synopsis>
     </para>

     <para>
<!--
      This is <application>libpq</>'s internal function to allocate and
      initialize an empty <structname>PGresult</structname> object.  This
      function returns <symbol>NULL</> if memory could not be allocated. It is
      exported because some applications find it useful to generate result
      objects (particularly objects with error status) themselves.  If
      <parameter>conn</parameter> is not null and <parameter>status</>
      indicates an error, the current error message of the specified
      connection is copied into the <structname>PGresult</structname>.
      Also, if <parameter>conn</parameter> is not null, any event procedures
      registered in the connection are copied into the
      <structname>PGresult</structname>.  (They do not get
      <literal>PGEVT_RESULTCREATE</> calls, but see
      <function>PQfireResultCreateEvents</function>.)
      Note that <function>PQclear</function> should eventually be called
      on the object, just as with a <structname>PGresult</structname>
      returned by <application>libpq</application> itself.
-->
これは空の<structname>PGresult</structname>オブジェクトを割り当てて、初期化する<application>libpq</>の内部関数です。
メモリが割り当てられなかった場合、この関数は<symbol>NULL</>を返します。
一部のアプリケーションで結果オブジェクト（特にエラーステータスを伴ったオブジェクト）それ自身を生成することが便利であることが分かりましたので、外部公開されました。
<parameter>conn</parameter>が非ヌルで、<parameter>status</>がエラーを示唆している場合、特定された接続の現在のエラーメッセージは<structname>PGresult</structname>にコピーされます。
同時に、<parameter>conn</parameter>が非ヌルの場合、接続で登録された任意のイベントプロシージャは<structname>PGresult</structname>にコピーされます。
（それらは<literal>PGEVT_RESULTCREATE</>呼び出しを受けませんが、<function>PQfireResultCreateEvents</function>を理解します。）
<application>libpq</application>自身で返された<structname>PGresult</structname>と同様に、最終的にはこのオブジェクトに対して<function>PQclear</function>を呼び出さなければならないことに注意してください。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-pqfireresultcreateevents">
    <term>
     <function>PQfireResultCreateEvents</function>
     <indexterm>
      <primary>PQfireResultCreateEvents</primary>
     </indexterm>
    </term>
    <listitem>
     <para>
<!--
      Fires a <literal>PGEVT_RESULTCREATE</literal> event (see <xref
      linkend="libpq-events">) for each event procedure registered in the
      <structname>PGresult</structname> object.  Returns non-zero for success,
      zero if any event procedure fails.
-->
<structname>PGresult</structname>オブジェクトに登録されたそれぞれのイベントプロシージャに対し、<literal>PGEVT_RESULTCREATE</literal>イベント（<xref linkend="libpq-events">を参照）を発行します。
イベントプロシージャが成功の場合は非ゼロ、失敗の場合はゼロを返します。

<synopsis>
int PQfireResultCreateEvents(PGconn *conn, PGresult *res);
</synopsis>
     </para>

     <para>
<!--
      The <literal>conn</> argument is passed through to event procedures
      but not used directly.  It can be <symbol>NULL</> if the event
      procedures won't use it.
-->
<literal>conn</>引数はイベントプロシージャに渡されますが、直接には使用されません。
イベントプロシージャが使用しない場合は<symbol>NULL</>で構いません。
     </para>

     <para>
<!--
      Event procedures that have already received a
      <literal>PGEVT_RESULTCREATE</> or <literal>PGEVT_RESULTCOPY</> event
      for this object are not fired again.
-->
このオブジェクトに対し、<literal>PGEVT_RESULTCREATE</>もしくは<literal>PGEVT_RESULTCOPY</>イベントを過去に受け取ったイベントプロシージャは再び発行されません。
     </para>

     <para>
<!--
      The main reason that this function is separate from
      <function>PQmakeEmptyPGResult</function> is that it is often appropriate
      to create a <structname>PGresult</structname> and fill it with data
      before invoking the event procedures.
-->
この関数が<function>PQmakeEmptyPGResult</function>と分離されている主たる理由は、多くの場合イベントプロシージャを呼び出す前に<structname>PGresult</structname>を作成し、データを挿入するのが適切であることによります。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-pqcopyresult">
    <term>
     <function>PQcopyResult</function>
     <indexterm>
      <primary>PQcopyResult</primary>
     </indexterm>
    </term>

    <listitem>
     <para>
<!--
      Makes a copy of a <structname>PGresult</structname> object.  The copy is
      not linked to the source result in any way and
      <function>PQclear</function> must be called when the copy is no longer
      needed.  If the function fails, <symbol>NULL</> is returned.
-->
<structname>PGresult</structname>オブジェクトのコピーを作ります。
コピーは元の結果にいかなる方法でもリンクされず、コピーが不要になった時に<function>PQclear</function>を呼び出されなければなりません。
関数が失敗すると<symbol>NULL</>が返されます。

<synopsis>
PGresult *PQcopyResult(const PGresult *src, int flags);
</synopsis>
     </para>

     <para>
<!--
      This is not intended to make an exact copy.  The returned result is
      always put into <literal>PGRES_TUPLES_OK</literal> status, and does not
      copy any error message in the source.  (It does copy the command status
      string, however.)  The <parameter>flags</parameter> argument determines
      what else is copied.  It is a bitwise OR of several flags.
      <literal>PG_COPYRES_ATTRS</literal> specifies copying the source
      result's attributes (column definitions).
      <literal>PG_COPYRES_TUPLES</literal> specifies copying the source
      result's tuples.  (This implies copying the attributes, too.)
      <literal>PG_COPYRES_NOTICEHOOKS</literal> specifies
      copying the source result's notify hooks.
      <literal>PG_COPYRES_EVENTS</literal> specifies copying the source
      result's events.  (But any instance data associated with the source
      is not copied.)
-->
これは正確なコピーの作成を目的としたものではありません。
返された結果は常に<literal>PGRES_TUPLES_OK</literal>状態の中に置かれ、元の結果におけるエラーメッセージはまったくコピーされません。
（しかしコマンド状態文字列をコピーします。）
<parameter>flags</parameter>引数はその他にコピーするものがないかを決定します。
それはいくつかのフラグのビット単位のORです。
<literal>PG_COPYRES_ATTRS</literal>は元の結果の属性（列定義）のコピーを指定します。
<literal>PG_COPYRES_TUPLES</literal>は元の結果のタプルのコピーを指定します。
（これは属性もコピーされることを意味しています。）
<literal>PG_COPYRES_NOTICEHOOKS</literal>は元の結果の警告フックのコピーを指定します。
<literal>PG_COPYRES_EVENTS</literal>は元の結果イベントのコピーを指定します。
（しかし、元の結果に関連したインスタンスデータはまったくコピーされません。）
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-pqsetresultattrs">
    <term>
     <function>PQsetResultAttrs</function>
     <indexterm>
      <primary>PQsetResultAttrs</primary>
     </indexterm>
    </term>

    <listitem>
     <para>
<!--
      Sets the attributes of a <structname>PGresult</structname> object.
-->
<structname>PGresult</structname>オブジェクトの属性を設定します。
<synopsis>
int PQsetResultAttrs(PGresult *res, int numAttributes, PGresAttDesc *attDescs);
</synopsis>
     </para>

     <para>
<!--
      The provided <parameter>attDescs</parameter> are copied into the result.
      If the <parameter>attDescs</parameter> pointer is <symbol>NULL</> or
      <parameter>numAttributes</parameter> is less than one, the request is
      ignored and the function succeeds.  If <parameter>res</parameter>
      already contains attributes, the function will fail.  If the function
      fails, the return value is zero.  If the function succeeds, the return
      value is non-zero.
-->
提供された<parameter>attDescs</parameter>は結果にコピーされます。
もし<parameter>attDescs</parameter>ポインタが<symbol>NULL</>、または<parameter>numAttributes</parameter>が１未満の場合、要求は無視され、関数は成功します。
<parameter>res</parameter>が既に属性を所有している場合、関数は失敗に終わります。
関数が失敗すると、戻り値はゼロです。
関数が成功すると戻り値は非ゼロになります。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-pqsetvalue">
    <term>
     <function>PQsetvalue</function>
     <indexterm>
      <primary>PQsetvalue</primary>
     </indexterm>
    </term>

    <listitem>
     <para>
<!--
      Sets a tuple field value of a <structname>PGresult</structname> object.
-->
<structname>PGresult</structname>オブジェクトのタプルフィールド値を設定します。
<synopsis>
int PQsetvalue(PGresult *res, int tup_num, int field_num, char *value, int len);
</synopsis>
     </para>

     <para>
<!--
      The function will automatically grow the result's internal tuples array
      as needed.  However, the <parameter>tup_num</parameter> argument must be
      less than or equal to <function>PQntuples</function>, meaning this
      function can only grow the tuples array one tuple at a time.  But any
      field of any existing tuple can be modified in any order.  If a value at
      <parameter>field_num</parameter> already exists, it will be overwritten.
      If <parameter>len</parameter> is -1 or
      <parameter>value</parameter> is <symbol>NULL</>, the field value
      will be set to an SQL null value.  The
      <parameter>value</parameter> is copied into the result's private storage,
      thus is no longer needed after the function
      returns.  If the function fails, the return value is zero.  If the
      function succeeds, the return value is non-zero.
-->
必要に応じて関数は自動的に結果の内部タプル配列を肥大化させます。
しかし、<parameter>tup_num</parameter>引数は<function>PQntuples</function>と同じか、もしくは小さくなければなりません。
その意味は、この関数は一回にタプル配列を１タプル大きくさせるだけだからです。
とは言っても、存在するいかなるタプルの任意のフィールドも、順序を問わず変更できます。
もし<parameter>field_num</parameter>に値が既に存在すれば、書き換えられます。
<parameter>len</parameter>が-1、または<parameter>value</parameter>が<symbol>NULL</>であれば、フィールドの値はSQLのNULLに設定されます。
<parameter>value</parameter>は結果のプライベート格納領域にコピーされるため、関数が返った後ではもう必要がなくなります。
関数が失敗すると、戻り値はゼロです。
関数が成功すると戻り値は非ゼロになります。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-pqresultalloc">
    <term>
     <function>PQresultAlloc</function>
     <indexterm>
      <primary>PQresultAlloc</primary>
     </indexterm>
    </term>

    <listitem>
     <para>
<!--
      Allocate subsidiary storage for a <structname>PGresult</structname> object.
-->
<structname>PGresult</structname>オブジェクトに補助ストレージを割り当てます。
<synopsis>
void *PQresultAlloc(PGresult *res, size_t nBytes);
</synopsis>
     </para>

     <para>
<!--
      Any memory allocated with this function will be freed when
      <parameter>res</parameter> is cleared.  If the function fails,
      the return value is <symbol>NULL</>.  The result is
      guaranteed to be adequately aligned for any type of data,
      just as for <function>malloc</>.
-->
<parameter>res</parameter>が消去された時、この関数で割り付けられたメモリは解放されます。
関数が失敗すると戻り値は<symbol>NULL</>です。
<function>malloc</>と同じように、どのような種類のデータでも結果は適切に整列されることが保証されています。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="libpq-pqlibversion">
    <term>
     <function>PQlibVersion</function>
     <indexterm>
      <primary>PQlibVersion</primary>
      <seealso>PQserverVersion</seealso>
     </indexterm>
    </term>

    <listitem>
     <para>
<!--
      Return the version of <productname>libpq</> that is being used.
-->
使用中の<productname>libpq</>のバージョンを返します。
<synopsis>
int PQlibVersion(void);
</synopsis>
     </para>

     <para>
<!--
      The result of this function can be used to determine, at
      run time, if specific functionality is available in the currently
      loaded version of libpq. The function can be used, for example,
      to determine which connection options are available for
      <function>PQconnectdb</> or if the <literal>hex</> <type>bytea</>
      output added in PostgreSQL 9.0 is supported.
-->
この関数の結果を使用して、実行時に現在読み込まれているバージョンのlibpqで特定の機能が利用可能かどうかを決定することができます。
例えばこの関数を使用して、<function>PQconnectdb</>でどの接続オプションが利用できるか、PostgreSQL 9.0で追加された<literal>hex</> <type>bytea</>出力をサポートするかを確認することができます。
     </para>

     <para>
<!--
      The number is formed by converting the major, minor, and revision
      numbers into two-decimal-digit numbers and appending them together.
      For example, version 9.1 will be returned as 90100, and version
      9.1.2 will be returned as 90102 (leading zeroes are not shown).
-->
この数値の形式は、メジャー、マイナー、リビジョン番号を2桁の10進数に変換し、連結させたものです。
例えば、バージョン9.1では90100を返し、バージョン9.1.2では90102を返します。
（先頭の0は現れません。）
     </para>

     <note>
      <para>
<!--
       This function appeared in <productname>PostgreSQL</> version 9.1, so
       it cannot be used to detect required functionality in earlier
       versions, since linking to it will create a link dependency
       on version 9.1.
-->
この関数は<productname>PostgreSQL</>バージョン9.1で追加されました。
このため以前のバージョンにおいて要求される機能を検知するために使用することができません。
この関数へのリンク処理がバージョン9.1とのリンク依存性を作成するためです。
      </para>
     </note>
    </listitem>
   </varlistentry>

  </variablelist>

 </sect1>

 <sect1 id="libpq-notice-processing">
<!--
  <title>Notice Processing</title>
-->
  <title>警告処理</title>

  <indexterm zone="libpq-notice-processing">
<!--
   <primary>notice processing</primary>
   <secondary>in libpq</secondary>
-->
   <primary>警告処理</primary>
   <secondary>libpqでの</secondary>
  </indexterm>

  <para>
<!--
   Notice and warning messages generated by the server are not returned
   by the query execution functions, since they do not imply failure of
   the query.  Instead they are passed to a notice handling function, and
   execution continues normally after the handler returns.  The default
   notice handling function prints the message on
   <filename>stderr</filename>, but the application can override this
   behavior by supplying its own handling function.
-->
問い合わせ実行関数では、サーバにより生成された通知と警告メッセージは、問い合わせの失敗を意味していないので返されません。
その代わり、それらは通知処理関数に渡され、ハンドラから返った後も実行は通常通り継続します。
デフォルトの通知処理関数は<filename>stderr</filename>にメッセージを出力しますが、アプリケーションは自身の処理関数を提供することでこの動作を書き換えることができます。
  </para>

  <para>
<!--
   For historical reasons, there are two levels of notice handling, called
   the notice receiver and notice processor.  The default behavior is for
   the notice receiver to format the notice and pass a string to the notice
   processor for printing.  However, an application that chooses to provide
   its own notice receiver will typically ignore the notice processor
   layer and just do all the work in the notice receiver.
-->
歴史的理由で、通知レシーバと通知プロセッサと呼ばれる２階層の通知処理が存在します。
デフォルトの動作は、通知レシーバが通知を書式化し、出力のため通知プロセッサに文字列を渡します。
しかし、独自の通知レシーバを提供することを選んだアプリケーションでは、通常、通知プロセッサ層を無視し、すべての作業を単に通知レシーバで行います。
  </para>

  <para>
<!--
   The function <function>PQsetNoticeReceiver</function>
   <indexterm><primary>notice receiver</></>
   <indexterm><primary>PQsetNoticeReceiver</></> sets or
   examines the current notice receiver for a connection object.
   Similarly, <function>PQsetNoticeProcessor</function>
   <indexterm><primary>notice processor</></>
   <indexterm><primary>PQsetNoticeProcessor</></> sets or
   examines the current notice processor.
-->
関数<function>PQsetNoticeReceiver</function><indexterm><primary>通知レシーバ</></><indexterm><primary>PQsetNoticeReceiver</></>は接続オブジェクトに対し現在の通知レシーバを設定もしくは確認します。
同様に、<function>PQsetNoticeProcessor</function>は現在の通知プロセッサの設定もしくは確認を行います。
<indexterm><primary>通知プロセッサ</></><indexterm><primary>PQsetNoticeProcessor</></>

<synopsis>
typedef void (*PQnoticeReceiver) (void *arg, const PGresult *res);

PQnoticeReceiver
PQsetNoticeReceiver(PGconn *conn,
                    PQnoticeReceiver proc,
                    void *arg);

typedef void (*PQnoticeProcessor) (void *arg, const char *message);

PQnoticeProcessor
PQsetNoticeProcessor(PGconn *conn,
                     PQnoticeProcessor proc,
                     void *arg);
</synopsis>

<!--
   Each of these functions returns the previous notice receiver or
   processor function pointer, and sets the new value.  If you supply a
   null function pointer, no action is taken, but the current pointer is
   returned.
-->
各関数は、以前の通知レシーバもしくは通知プロセッサ用の関数へのポインタを返し、新しい値を設定します。
関数ポインタにヌルを渡した場合、何も変更されず、現在のポインタが返されるだけです。
  </para>

  <para>
<!--
   When a notice or warning message is received from the server, or
   generated internally by <application>libpq</application>, the notice
   receiver function is called.  It is passed the message in the form of
   a <symbol>PGRES_NONFATAL_ERROR</symbol>
   <structname>PGresult</structname>.  (This allows the receiver to extract
   individual fields using <function>PQresultErrorField</>, or the complete
   preformatted message using <function>PQresultErrorMessage</>.) The same
   void pointer passed to <function>PQsetNoticeReceiver</function> is also
   passed.  (This pointer can be used to access application-specific state
   if needed.)
-->
サーバから注意/警告メッセージを受け取ると、あるいは、<application>libpq</application>内部で注意/警告メッセージが生成されると、通知レシーバ関数が呼び出されます。
<symbol>PGRES_NONFATAL_ERROR</symbol> <structname>PGresult</structname>という形でメッセージが渡されます。
（これにより、レシーバは<function>PQresultErrorField</>を使用して個々のフィールドを取り出すことや、<function>PQresultErrorMessage</>を使用して事前に整形された完全なメッセージを取り出すことができます。）
<function>PQsetNoticeReceiver</function>に渡されたvoidポインタと同じものも渡されます。
（このポインタを使用して、必要に応じてアプリケーション特有の状態にアクセスすることができます。）
  </para>

  <para>
<!--
   The default notice receiver simply extracts the message (using
   <function>PQresultErrorMessage</>) and passes it to the notice
   processor.
-->
デフォルトの通知レシーバは単に（<function>PQresultErrorMessage</>を使用して）メッセージを取り出し、それを通知プロセッサに渡すだけです。
  </para>

  <para>
<!--
   The notice processor is responsible for handling a notice or warning
   message given in text form.  It is passed the string text of the message
   (including a trailing newline), plus a void pointer that is the same
   one passed to <function>PQsetNoticeProcessor</function>.  (This pointer
   can be used to access application-specific state if needed.)
-->
通知プロセッサは、テキスト形式で与えられた注意/警告メッセージの取扱いに責任を持ちます。
メッセージは（最後の改行を含む）文字列テキストで渡され、更に、<function>PQsetNoticeProcessor</function>に渡したものと同じvoidポインタも渡されます。
（このポインタを使用して、必要に応じてアプリケーション特有の状態にアクセスすることができます。）
  </para>

  <para>
<!--
   The default notice processor is simply:
-->
デフォルトの通知プロセッサは以下のような単純なものです。
<programlisting>
static void
defaultNoticeProcessor(void *arg, const char *message)
{
    fprintf(stderr, "%s", message);
}
</programlisting>
  </para>

  <para>
<!--
   Once you have set a notice receiver or processor, you should expect
   that that function could be called as long as either the
   <structname>PGconn</> object or <structname>PGresult</> objects made
   from it exist.  At creation of a <structname>PGresult</>, the
   <structname>PGconn</>'s current notice handling pointers are copied
   into the <structname>PGresult</> for possible use by functions like
   <function>PQgetvalue</function>.
-->
一旦通知レシーバや通知プロセッサを設定したら、<structname>PGconn</>オブジェクトか、それから生成された<structname>PGresult</>オブジェクトが存在している間は、その関数が呼び出される可能性があると考えておくべきです。
<structname>PGresult</>の生成時には、<structname>PGconn</>の現在の警告処理用のポインタが、<function>PQgetvalue</function>のような関数で使用可能であるように、<structname>PGresult</>へコピーされます。
  </para>

 </sect1>

 <sect1 id="libpq-events">
<!--
  <title>Event System</title>
-->
  <title>イベントシステム</title>

  <para>
<!--
   <application>libpq</application>'s event system is designed to notify
   registered event handlers about interesting
   <application>libpq</application> events, such as the creation or
   destruction of <structname>PGconn</structname> and
   <structname>PGresult</structname> objects.  A principal use case is that
   this allows applications to associate their own data with a
   <structname>PGconn</structname> or <structname>PGresult</structname>
   and ensure that that data is freed at an appropriate time.
-->
<application>libpq</application>のイベントシステムは、<structname>PGconn</structname>および<structname>PGresult</structname>オブジェクトの作成と削除のような関心を引く<application>libpq</application>イベントについて登録されたイベントハンドラに通知を行うため設計されています。
主たる使用状況は、アプリケーションがそれ自身のデータを<structname>PGconn</structname>または<structname>PGresult</structname>と提携させ、データが適切な時間に解放されることを保証するものです。
  </para>

  <para>
<!--
   Each registered event handler is associated with two pieces of data,
   known to <application>libpq</application> only as opaque <literal>void *</>
   pointers.  There is a <firstterm>passthrough</> pointer that is provided
   by the application when the event handler is registered with a
   <structname>PGconn</>.  The passthrough pointer never changes for the
   life of the <structname>PGconn</> and all <structname>PGresult</>s
   generated from it; so if used, it must point to long-lived data.
   In addition there is an <firstterm>instance data</> pointer, which starts
   out <symbol>NULL</> in every <structname>PGconn</> and <structname>PGresult</>.
   This pointer can be manipulated using the
   <function>PQinstanceData</function>,
   <function>PQsetInstanceData</function>,
   <function>PQresultInstanceData</function> and
   <function>PQsetResultInstanceData</function> functions.  Note that
   unlike the passthrough pointer, instance data of a <structname>PGconn</>
   is not automatically inherited by <structname>PGresult</>s created from
   it.  <application>libpq</application> does not know what passthrough
   and instance data pointers point to (if anything) and will never attempt
   to free them &mdash; that is the responsibility of the event handler.
-->
それぞれの登録されたイベントハンドラは、<application>libpq</application>からは曖昧とした<literal>void *</>ポインタとしてだけ知られる２つのデータの断片と提携します。
イベントハンドラが<structname>PGconn</>で登録された時にアプリケーションが提供する<firstterm>通過地点</>ポインタがあります。
通過地点ポインタは<structname>PGconn</>やそれから生成されたすべての（複数の）<structname>PGresult</>が有効な間決して変わることはありません。
したがって使用された場合、長期間生存しているデータを指し示します。
さらに、<firstterm>インスタンスデータ</>ポインタがあって、それはすべての<structname>PGconn</>と<structname>PGresult</>で<symbol>NULL</>から開始します。
ポインタは、<function>PQinstanceData</function>、<function>PQsetInstanceData</function>、<function>PQresultInstanceData</function>および<function>PQsetResultInstanceData</function>関数を使って操作することができます。
通過地点ポインタとは異なり、<structname>PGconn</>のインスタンスデータはそれから作成された<structname>PGresult</>により自動的に継承されません。
<application>libpq</application>は通過地点とインスタンスデータポインタが（もしあったとしても）何を指し示すのか判らず、決して解放しようとは試みません。
それはイベントハンドラの責任です。
  </para>

  <sect2 id="libpq-events-types">
<!--
   <title>Event Types</title>
-->
   <title>イベントの種類</title>

   <para>
<!--
    The enum <literal>PGEventId</> names the types of events handled by
    the event system.  All its values have names beginning with
    <literal>PGEVT</literal>.  For each event type, there is a corresponding
    event info structure that carries the parameters passed to the event
    handlers.  The event types are:
-->
<literal>PGEventId</>列挙はイベントシステムにより処理されるイベントの種類に名前をつけます。
その値はすべて<literal>PGEVT</literal>で始まる名前を持っています。
それぞれのイベントの種類に対し、イベントハンドラに渡されるパラメータを運ぶ関連したイベント情報構造体があります。
イベントの種類を以下に示します。
   </para>

   <variablelist>
    <varlistentry id="libpq-pgevt-register">
     <term><literal>PGEVT_REGISTER</literal></term>
     <listitem>
      <para>
<!--
       The register event occurs when <function>PQregisterEventProc</function>
       is called.  It is the ideal time to initialize any
       <literal>instanceData</literal> an event procedure may need.  Only one
       register event will be fired per event handler per connection.  If the
       event procedure fails, the registration is aborted.
-->
登録イベントは<function>PQregisterEventProc</function>が呼ばれたとき発生します。
イベントプロシージャが必要とするかもしれない任意の<literal>instanceData</literal>を初期化するために、これは理想的な時間です。
接続毎、イベントハンドラ毎でたった１つの登録イベントが発行されます。
イベントプロシージャが失敗すると、登録は中止されます。

<synopsis>
typedef struct
{
    PGconn *conn;
} PGEventRegister;
</synopsis>

<!--
       When a <literal>PGEVT_REGISTER</literal> event is received, the
       <parameter>evtInfo</parameter> pointer should be cast to a
       <structname>PGEventRegister *</structname>.  This structure contains a
       <structname>PGconn</structname> that should be in the
       <literal>CONNECTION_OK</literal> status; guaranteed if one calls
       <function>PQregisterEventProc</function> right after obtaining a good
       <structname>PGconn</structname>.  When returning a failure code, all
       cleanup must be performed as no <literal>PGEVT_CONNDESTROY</literal>
       event will be sent.
-->
<literal>PGEVT_REGISTER</literal>イベントが受け取られると、<parameter>evtInfo</parameter>ポインタは<structname>PGEventRegister *</structname>にキャストされなければなりません。
この構造体は<literal>CONNECTION_OK</literal>状態ではなくてはならない<structname>PGconn</structname>を含んでいます。
そしてそれは、効果のある<structname>PGconn</structname>を取得した直後、<function>PQregisterEventProc</function>を呼び出せば、保証されます。
失敗コードを返すとき、<literal>PGEVT_CONNDESTROY</literal>イベントが送られないので、すべての消去が実行されなければなりません。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pgevt-connreset">
     <term><literal>PGEVT_CONNRESET</literal></term>
     <listitem>
      <para>
<!--
       The connection reset event is fired on completion of
       <function>PQreset</function> or <function>PQresetPoll</function>.  In
       both cases, the event is only fired if the reset was successful.  If
       the event procedure fails, the entire connection reset will fail; the
       <structname>PGconn</structname> is put into
       <literal>CONNECTION_BAD</literal> status and
       <function>PQresetPoll</function> will return
       <literal>PGRES_POLLING_FAILED</literal>.
-->
接続初期化イベントは<function>PQreset</function>または<function>PQresetPoll</function>の完了時点で発行されます。
どちらの場合も、初期化が成功したときのみ発行されます。
イベントプロシージャが失敗すると、接続初期化全体が失敗します。
<structname>PGconn</structname>は<literal>CONNECTION_BAD</literal>状態になり、<function>PQresetPoll</function>は<literal>PGRES_POLLING_FAILED</literal>を返します。

<synopsis>
typedef struct
{
    PGconn *conn;
} PGEventConnReset;
</synopsis>

<!--
       When a <literal>PGEVT_CONNRESET</literal> event is received, the
       <parameter>evtInfo</parameter> pointer should be cast to a
       <structname>PGEventConnReset *</structname>.  Although the contained
       <structname>PGconn</structname> was just reset, all event data remains
       unchanged.  This event should be used to reset/reload/requery any
       associated <literal>instanceData</literal>.  Note that even if the
       event procedure fails to process <literal>PGEVT_CONNRESET</>, it will
       still receive a <literal>PGEVT_CONNDESTROY</> event when the connection
       is closed.
-->
<literal>PGEVT_CONNRESET</literal>イベントが受け取られた時、<parameter>evtInfo</parameter>ポインタは<structname>PGEventConnReset *</structname>にキャストされなければなりません。
含まれた<structname>PGconn</structname>は単に初期化されますが、すべてのイベントデータは変更されずに残ります。
このイベントはすべての関連した<literal>instanceData</literal>の初期化・再読み込み・再問い合わせに使用されなければなりません。
イベントプロシージャが<literal>PGEVT_CONNRESET</>処理に失敗したとしても、接続が閉じられた時<literal>PGEVT_CONNDESTROY</>イベントを依然として受け付けることに注意してください。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pgevt-conndestroy">
     <term><literal>PGEVT_CONNDESTROY</literal></term>
     <listitem>
      <para>
<!--
       The connection destroy event is fired in response to
       <function>PQfinish</function>.  It is the event procedure's
       responsibility to properly clean up its event data as libpq has no
       ability to manage this memory.  Failure to clean up will lead
       to memory leaks.
-->
接続破棄イベントは<function>PQfinish</function>に対応して発行されます。
libpqはこのメモリを管理する機能がありませんので、そのイベントデータを的確に消去するのはイベントプロシージャの責任です。
消去の失敗はメモリーリークに通じます。

<synopsis>
typedef struct
{
    PGconn *conn;
} PGEventConnDestroy;
</synopsis>

<!--
       When a <literal>PGEVT_CONNDESTROY</literal> event is received, the
       <parameter>evtInfo</parameter> pointer should be cast to a
       <structname>PGEventConnDestroy *</structname>.  This event is fired
       prior to <function>PQfinish</function> performing any other cleanup.
       The return value of the event procedure is ignored since there is no
       way of indicating a failure from <function>PQfinish</function>.  Also,
       an event procedure failure should not abort the process of cleaning up
       unwanted memory.
-->
<literal>PGEVT_CONNDESTROY</literal>イベントが受け取られた時、<parameter>evtInfo</parameter>ポインタは<structname>PGEventConnDestroy *</structname>にキャストされなければなりません。
このイベントは<function>PQfinish</function>が他のすべての消去を行う前に発行されます。
イベントプロシージャの戻り値は、<function>PQfinish</function>から失敗を示唆する方法がないので無視されます。
同時に、イベントプロシージャの失敗が不要なメモリ消去処理を中止してはなりません。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pgevt-resultcreate">
     <term><literal>PGEVT_RESULTCREATE</literal></term>
     <listitem>
      <para>
<!--
       The result creation event is fired in response to any query execution
       function that generates a result, including
       <function>PQgetResult</function>.  This event will only be fired after
       the result has been created successfully.
-->
結果作成イベントは、<function>PQgetResult</function>を含み、結果を生成する任意の問い合わせ実行関数に対応して発行されます。
このイベントは結果が成功裏に作成されたときのみ発行されます。

<synopsis>
typedef struct
{
    PGconn *conn;
    PGresult *result;
} PGEventResultCreate;
</synopsis>

<!--
       When a <literal>PGEVT_RESULTCREATE</literal> event is received, the
       <parameter>evtInfo</parameter> pointer should be cast to a
       <structname>PGEventResultCreate *</structname>.  The
       <parameter>conn</parameter> is the connection used to generate the
       result.  This is the ideal place to initialize any
       <literal>instanceData</literal> that needs to be associated with the
       result.  If the event procedure fails, the result will be cleared and
       the failure will be propagated.  The event procedure must not try to
       <function>PQclear</> the result object for itself.  When returning a
       failure code, all cleanup must be performed as no
       <literal>PGEVT_RESULTDESTROY</literal> event will be sent.
-->
<literal>PGEVT_RESULTCREATE</literal>イベントが受け取られた時、<parameter>evtInfo</parameter>ポインタは<structname>PGEventResultCreate *</structname>にキャストされなければなりません。
<parameter>conn</parameter>は結果を生成するために使われた接続です。
これは、結果と関連しなければならないすべての<literal>instanceData</literal>を初期化するために、理想的な場所です。
イベントプロシージャが失敗すると、結果は消去され、失敗が伝播します。
イベントプロシージャはそれ自身の結果オブジェクトを<function>PQclear</>しようと試みてはいけません。
失敗コードを返す時、<literal>PGEVT_RESULTDESTROY</literal>イベントは送られないのですべての消去が行われなくてはなりません。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pgevt-resultcopy">
     <term><literal>PGEVT_RESULTCOPY</literal></term>
     <listitem>
      <para>
<!--
       The result copy event is fired in response to
       <function>PQcopyResult</function>.  This event will only be fired after
       the copy is complete.  Only event procedures that have
       successfully handled the <literal>PGEVT_RESULTCREATE</literal>
       or <literal>PGEVT_RESULTCOPY</literal> event for the source result
       will receive <literal>PGEVT_RESULTCOPY</literal> events.
-->
結果コピーイベントは<function>PQcopyResult</function>の応答として発行されます。
このイベントはコピーが完了した後にのみ発行されます。
元の結果に対する<literal>PGEVT_RESULTCREATE</literal>もしくは<literal>PGEVT_RESULTCOPY</literal>イベントを成功裏に処理したイベントプロシージャのみ、<literal>PGEVT_RESULTCOPY</literal>イベントを受け取ります。

<synopsis>
typedef struct
{
    const PGresult *src;
    PGresult *dest;
} PGEventResultCopy;
</synopsis>

<!--
       When a <literal>PGEVT_RESULTCOPY</literal> event is received, the
       <parameter>evtInfo</parameter> pointer should be cast to a
       <structname>PGEventResultCopy *</structname>.  The
       <parameter>src</parameter> result is what was copied while the
       <parameter>dest</parameter> result is the copy destination.  This event
       can be used to provide a deep copy of <literal>instanceData</literal>,
       since <literal>PQcopyResult</literal> cannot do that.  If the event
       procedure fails, the entire copy operation will fail and the
       <parameter>dest</parameter> result will be cleared.   When returning a
       failure code, all cleanup must be performed as no
       <literal>PGEVT_RESULTDESTROY</literal> event will be sent for the
       destination result.
-->
<literal>PGEVT_RESULTCOPY</literal>イベントが受け取られた時、<parameter>evtInfo</parameter>ポインタは<structname>PGEventResultCopy *</structname>にキャストされなければなりません。
<parameter>src</parameter>結果はコピーされるものであり、一方で<parameter>dest</parameter>結果はコピー先です。
このイベントは<literal>instanceData</literal>のディープコピーを提供するために使用されます。
<literal>PQcopyResult</literal>ではこれを行うことができないためです。
もしイベントプロシージャが失敗すると、コピー操作全体は失敗になり、<parameter>dest</parameter>結果は消去されます。
失敗コードを返す時、<literal>PGEVT_RESULTDESTROY</literal>イベントがコピー先の結果に対し送られないため、すべての消去を行われなければなりません。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pgevt-resultdestroy">
     <term><literal>PGEVT_RESULTDESTROY</literal></term>
     <listitem>
      <para>
<!--
       The result destroy event is fired in response to a
       <function>PQclear</function>.  It is the event procedure's
       responsibility to properly clean up its event data as libpq has no
       ability to manage this memory.  Failure to clean up will lead
       to memory leaks.
-->
結果破棄イベントは<function>PQclear</function>に対応して発行されます。
libpqはこのメモリを管理する機能がありませんので、そのイベントデータを的確に消去するのはイベントプロシージャの責任です。
消去の失敗はメモリーリークに通じます。

<synopsis>
typedef struct
{
    PGresult *result;
} PGEventResultDestroy;
</synopsis>

<!--
       When a <literal>PGEVT_RESULTDESTROY</literal> event is received, the
       <parameter>evtInfo</parameter> pointer should be cast to a
       <structname>PGEventResultDestroy *</structname>.  This event is fired
       prior to <function>PQclear</function> performing any other cleanup.
       The return value of the event procedure is ignored since there is no
       way of indicating a failure from <function>PQclear</function>.  Also,
       an event procedure failure should not abort the process of cleaning up
       unwanted memory.
-->
<literal>PGEVT_RESULTDESTROY</literal>が受け取られた時、<parameter>evtInfo</parameter>ポインタは<structname>PGEventResultDestroy *</structname>にキャストされなければなりません。
このイベントは<function>PQclear</function>がその他の消去を行う以前に起動されなければなりません。
イベントプロシージャの戻り値は、<function>PQclear</function>から失敗を示唆する方法がないので無視されます。
同時に、イベントプロシージャの失敗が不要なメモリ消去処理を中止してはなりません。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>

  <sect2 id="libpq-events-proc">
<!--
   <title>Event Callback Procedure</title>
-->
   <title>イベントコールバックプロシージャ</title>

   <variablelist>
    <varlistentry id="libpq-pgeventproc">
     <term>
      <literal>PGEventProc</literal>
      <indexterm>
       <primary>PGEventProc</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
<!--
       <literal>PGEventProc</literal> is a typedef for a pointer to an
       event procedure, that is, the user callback function that receives
       events from libpq.  The signature of an event procedure must be
-->
<literal>PGEventProc</literal>はイベントプロシージャへのポインタに対するtypedefです。
つまり、libpqからイベントを受け取るユーザコールバック関数です。
イベントプロシージャのシグネチャは以下でなければなりません。

<synopsis>
int eventproc(PGEventId evtId, void *evtInfo, void *passThrough)
</synopsis>

<!--
       The <parameter>evtId</parameter> parameter indicates which
       <literal>PGEVT</literal> event occurred.  The
       <parameter>evtInfo</parameter> pointer must be cast to the appropriate
       structure type to obtain further information about the event.
       The <parameter>passThrough</parameter> parameter is the pointer
       provided to <function>PQregisterEventProc</function> when the event
       procedure was registered.  The function should return a non-zero value
       if it succeeds and zero if it fails.
-->
<parameter>evtId</parameter>パラメータはどの<literal>PGEVT</literal>イベントが発生したかを示します。
<parameter>evtInfo</parameter>ポインタは、イベントに対する追加情報を入手するため適切な構造体型にキャストされなければなりません。
<parameter>passThrough</parameter>パラメータは、イベントプロシージャが登録された時、<function>PQregisterEventProc</function>に提供されるポインタです。
関数は成功した場合非ゼロを、失敗した場合ゼロを返さなければなりません。
      </para>

      <para>
<!--
       A particular event procedure can be registered only once in any
       <structname>PGconn</>.  This is because the address of the procedure
       is used as a lookup key to identify the associated instance data.
-->
特定のイベントプロシージャは任意の<structname>PGconn</>において一回だけ登録できます。
これは、プロシージャのアドレスが関連するインスタンスデータを特定する検索キーとして用いられるからです。
      </para>

      <caution>
       <para>
<!--
        On Windows, functions can have two different addresses: one visible
        from outside a DLL and another visible from inside the DLL.  One
        should be careful that only one of these addresses is used with
        <application>libpq</>'s event-procedure functions, else confusion will
        result.  The simplest rule for writing code that will work is to
        ensure that event procedures are declared <literal>static</>.  If the
        procedure's address must be available outside its own source file,
        expose a separate function to return the address.
-->
Windowsにおいて、関数は２つの異なるアドレスを持つことができます。
外部から可視のDLLと内部から可視のDLLです。
<application>libpq</>のイベントプロシージャ関数ではこれらのアドレスのうちの１つだけが使用されることに注意してください。
さもないと、混乱が起きます。
正常に機能するコードを書く最も単純な規則は、イベントプロシージャが<literal>static</>として宣言されることを確実にすることです。
もし、プロシージャのアドレスがそれ自身のファイルの外部から有効とならなければならない場合、アドレスを返すため別の関数を公開します。
       </para>
      </caution>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>

  <sect2 id="libpq-events-funcs">
<!--
   <title>Event Support Functions</title>
-->
   <title>イベントサポート関数</title>

    <variablelist>
    <varlistentry id="libpq-pqregistereventproc">
     <term>
      <function>PQregisterEventProc</function>
      <indexterm>
       <primary>PQregisterEventProc</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
<!--
       Registers an event callback procedure with libpq.
-->
libpqでイベントコールバックプロシージャを登録します。

<synopsis>
int PQregisterEventProc(PGconn *conn, PGEventProc proc,
                        const char *name, void *passThrough);
</synopsis>
      </para>

      <para>
<!--
       An event procedure must be registered once on each
       <structname>PGconn</> you want to receive events about.  There is no
       limit, other than memory, on the number of event procedures that
       can be registered with a connection.  The function returns a non-zero
       value if it succeeds and zero if it fails.
-->
そのイベントを取得したいそれぞれの<structname>PGconn</>で１回イベントプロシージャは登録されなければなりません。
一つの接続に登録できるイベントプロシージャの数には、メモリ以外の制限はありません。
関数は成功した場合非ゼロ、失敗の場合ゼロを返します。
      </para>

      <para>
<!--
       The <parameter>proc</parameter> argument will be called when a libpq
       event is fired.  Its memory address is also used to lookup
       <literal>instanceData</literal>.  The <parameter>name</parameter>
       argument is used to refer to the event procedure in error messages.
       This value cannot be <symbol>NULL</> or a zero-length string.  The name string is
       copied into the <structname>PGconn</>, so what is passed need not be
       long-lived.  The <parameter>passThrough</parameter> pointer is passed
       to the <parameter>proc</parameter> whenever an event occurs. This
       argument can be <symbol>NULL</>.
-->
libpqイベントが発行されたとき<parameter>proc</parameter>引数が呼ばれます。
そのメモリアドレスは<literal>instanceData</literal>を検索するのにも使用されます。
<parameter>name</parameter>引数はエラーメッセージ内でイベントプロシージャを参照するために使用されます。
この値は<symbol>NULL</>もしくは空文字列であってはなりません。
このname文字列は<structname>PGconn</>にコピーされますので、渡されたものは長寿命である必要がありません。
<parameter>passThrough</parameter>ポインタはイベントが発生した時はいつでも<parameter>proc</parameter>に渡されます。
この引数は<symbol>NULL</>であっても構いません。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqsetinstancedata">
     <term>
      <function>PQsetInstanceData</function>
      <indexterm>
       <primary>PQsetInstanceData</primary>
      </indexterm>
     </term>
     <listitem>
      <para>
<!--
       Sets the connection <parameter>conn</>'s <literal>instanceData</>
       for procedure <parameter>proc</> to <parameter>data</>.  This
       returns non-zero for success and zero for failure.  (Failure is
       only possible if <parameter>proc</> has not been properly
       registered in <parameter>conn</>.)
-->
<parameter>proc</>プロシージャに対する<parameter>conn</>接続の<literal>instanceData</>を<parameter>data</>に設定します。
成功の場合非ゼロ、失敗の場合ゼロが返ります。
（<parameter>conn</>で<parameter>proc</>が正しく登録されていない場合のみ失敗する可能性があります。）

<synopsis>
int PQsetInstanceData(PGconn *conn, PGEventProc proc, void *data);
</synopsis>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqinstancedata">
     <term>
      <function>PQinstanceData</function>
      <indexterm>
       <primary>PQinstanceData</primary>
      </indexterm>
     </term>
     <listitem>
      <para>
<!--
       Returns the
       connection <parameter>conn</>'s <literal>instanceData</literal>
       associated with procedure <parameter>proc</>,
       or <symbol>NULL</symbol> if there is none.
-->
<parameter>proc</>プロシージャに関連した<parameter>conn</>接続の<literal>instanceData</literal>、または存在しなければ<symbol>NULL</symbol>を返します。

<synopsis>
void *PQinstanceData(const PGconn *conn, PGEventProc proc);
</synopsis>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqresultsetinstancedata">
     <term>
      <function>PQresultSetInstanceData</function>
      <indexterm>
       <primary>PQresultSetInstanceData</primary>
      </indexterm>
     </term>
     <listitem>
      <para>
<!--
       Sets the result's <literal>instanceData</>
       for <parameter>proc</> to <parameter>data</>.  This returns
       non-zero for success and zero for failure.  (Failure is only
       possible if <parameter>proc</> has not been properly registered
       in the result.)
-->
<parameter>proc</>に対する結果の<literal>instanceData</>を<parameter>data</>に設定します。
成功の場合非ゼロ、失敗の場合ゼロが返ります。
（結果で<parameter>proc</>正しく登録されていない場合のみ失敗する可能性があります。）

<synopsis>
int PQresultSetInstanceData(PGresult *res, PGEventProc proc, void *data);
</synopsis>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqresultinstancedata">
     <term>
      <function>PQresultInstanceData</function>
      <indexterm>
       <primary>PQresultInstanceData</primary>
      </indexterm>
     </term>
     <listitem>
      <para>
<!--
       Returns the result's <literal>instanceData</> associated with <parameter>proc</>, or <symbol>NULL</>
       if there is none.
-->
<parameter>proc</>に関連した結果の<literal>instanceData</>、または存在しなければ<symbol>NULL</>を返します。

<synopsis>
void *PQresultInstanceData(const PGresult *res, PGEventProc proc);
</synopsis>
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>

  <sect2 id="libpq-events-example">
<!--
   <title>Event Example</title>
-->
   <title>イベント事例</title>

   <para>
<!--
    Here is a skeleton example of managing private data associated with
    libpq connections and results.
-->
以下にlibpq接続と結果に関連したプライベートデータを管理する例の大枠を示します。
   </para>

<programlisting>
<![CDATA[
]]><!--
/* required header for libpq events (note: includes libpq-fe.h) */
--><![CDATA[
/* libpqイベントに必要なヘッダ（覚書：libpq-fe.hのインクルード) */
#include <libpq-events.h>

]]><!--
/* The instanceData */
--><![CDATA[
/* instanceData */
typedef struct
{
    int n;
    char *str;
} mydata;

/* PGEventProc */
static int myEventProc(PGEventId evtId, void *evtInfo, void *passThrough);

int
main(void)
{
    mydata *data;
    PGresult *res;
    PGconn *conn = PQconnectdb("dbname = postgres");

    if (PQstatus(conn) != CONNECTION_OK)
    {
        fprintf(stderr, "Connection to database failed: %s",
                PQerrorMessage(conn));
        PQfinish(conn);
        return 1;
    }

]]><!--
    /* called once on any connection that should receive events.
     * Sends a PGEVT_REGISTER to myEventProc.
     */
--><![CDATA[
    /* イベントを受け取るべきすべての接続で１回呼ばれる
     * myEventProcにPGEVT_REGISTERを送る
     */
    if (!PQregisterEventProc(conn, myEventProc, "mydata_proc", NULL))
    {
        fprintf(stderr, "Cannot register PGEventProc\n");
        PQfinish(conn);
        return 1;
    }

]]><!--
    /* conn instanceData is available */
--><![CDATA[
    /* conn instanceDataが有効 */
    data = PQinstanceData(conn, myEventProc);

]]><!--
    /* Sends a PGEVT_RESULTCREATE to myEventProc */
--><![CDATA[
    /* myEventProcにPGEVT_RESULTCREATEを送る */
    res = PQexec(conn, "SELECT 1 + 1");

]]><!--
    /* result instanceData is available */
--><![CDATA[
    /* 結果 instanceDataが有効 */
    data = PQresultInstanceData(res, myEventProc);

]]><!--
    /* If PG_COPYRES_EVENTS is used, sends a PGEVT_RESULTCOPY to myEventProc */
--><![CDATA[
    /* PG_COPYRES_EVENTSが使われた場合、PGEVT_RESULTCOPYをmyEventProcに送る */
    res_copy = PQcopyResult(res, PG_COPYRES_TUPLES | PG_COPYRES_EVENTS);

]]><!--
    /* result instanceData is available if PG_COPYRES_EVENTS was
     * used during the PQcopyResult call.
     */
--><![CDATA[
    /* PQcopyResult呼び出しの過程でPG_COPYRES_EVENTSが使用された場合、
     * 結果 instanceDataが有効
     */
    data = PQresultInstanceData(res_copy, myEventProc);

]]><!--
    /* Both clears send a PGEVT_RESULTDESTROY to myEventProc */
--><![CDATA[
    /* 双方のclearがPGEVT_RESULTDESTROYをmyEventProcに送る */
    PQclear(res);
    PQclear(res_copy);

]]><!--
    /* Sends a PGEVT_CONNDESTROY to myEventProc */
--><![CDATA[
    /* PGEVT_CONNDESTROYをmyEventProcに送る */
    PQfinish(conn);

    return 0;
}

static int
myEventProc(PGEventId evtId, void *evtInfo, void *passThrough)
{
    switch (evtId)
    {
        case PGEVT_REGISTER:
        {
            PGEventRegister *e = (PGEventRegister *)evtInfo;
            mydata *data = get_mydata(e->conn);

]]><!--
            /* associate app specific data with connection */
--><![CDATA[
            /* アプリ特有のデータを接続に関連付ける */
            PQsetInstanceData(e->conn, myEventProc, data);
            break;
        }

        case PGEVT_CONNRESET:
        {
            PGEventConnReset *e = (PGEventConnReset *)evtInfo;
            mydata *data = PQinstanceData(e->conn, myEventProc);

            if (data)
              memset(data, 0, sizeof(mydata));
            break;
        }

        case PGEVT_CONNDESTROY:
        {
            PGEventConnDestroy *e = (PGEventConnDestroy *)evtInfo;
            mydata *data = PQinstanceData(e->conn, myEventProc);

]]><!--
            /* free instance data because the conn is being destroyed */
--><![CDATA[
            /* connが破棄されたのでインスタンスデータを開放 */
            if (data)
              free_mydata(data);
            break;
        }

        case PGEVT_RESULTCREATE:
        {
            PGEventResultCreate *e = (PGEventResultCreate *)evtInfo;
            mydata *conn_data = PQinstanceData(e->conn, myEventProc);
            mydata *res_data = dup_mydata(conn_data);

]]><!--
            /* associate app specific data with result (copy it from conn) */
--><![CDATA[
            /* アプリ特有のデータを結果と（connから複写して）関連付ける */
            PQsetResultInstanceData(e->result, myEventProc, res_data);
            break;
        }

        case PGEVT_RESULTCOPY:
        {
            PGEventResultCopy *e = (PGEventResultCopy *)evtInfo;
            mydata *src_data = PQresultInstanceData(e->src, myEventProc);
            mydata *dest_data = dup_mydata(src_data);

]]><!--
            /* associate app specific data with result (copy it from a result) */
--><![CDATA[
            /* アプリ特有のデータを結果と（結果から複写して）関連付ける */
            PQsetResultInstanceData(e->dest, myEventProc, dest_data);
            break;
        }

        case PGEVT_RESULTDESTROY:
        {
            PGEventResultDestroy *e = (PGEventResultDestroy *)evtInfo;
            mydata *data = PQresultInstanceData(e->result, myEventProc);

]]><!--
            /* free instance data because the result is being destroyed */
--><![CDATA[
            /* 結果が破棄されたためインスタンスデータを開放 */
            if (data)
              free_mydata(data);
            break;
        }

]]><!--
        /* unknown event ID, just return TRUE. */
--><![CDATA[
        /* 未知のイベント識別子。単にTRUEを返す */
        default:
            break;
    }

]]><!--
    return TRUE; /* event processing succeeded */
--><![CDATA[
    return TRUE; /* イベント処理成功 */
}
]]>
</programlisting>
  </sect2>
 </sect1>

 <sect1 id="libpq-envars">
<!--
  <title>Environment Variables</title>
-->
<title>環境変数</title>

  <indexterm zone="libpq-envars">
<!--
   <primary>environment variable</primary>
-->
   <primary>環境変数</primary>
  </indexterm>

  <para>
<!--
   The following environment variables can be used to select default
   connection parameter values, which will be used by
   <function>PQconnectdb</>, <function>PQsetdbLogin</> and
   <function>PQsetdb</> if no value is directly specified by the calling
   code.  These are useful to avoid hard-coding database connection
   information into simple client applications, for example.
-->
以下の環境変数を使用して、呼び出し側のプログラムで直接値を指定しなかった場合の接続パラメータのデフォルト値を選ぶことができます。 
この値は、<function>PQconnectdb</>、<function>PQsetdbLogin</>および<function>PQsetdb</>で使用されます。
例えば、簡単なクライアントアプリケーションでは、データベース接続情報を直接プログラムに記述しない方が便利です。

   <itemizedlist>
    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGHOST</envar></primary>
      </indexterm>
<!--
      <envar>PGHOST</envar> behaves the same as the <xref
      linkend="libpq-connect-host"> connection parameter.
-->
<envar>PGHOST</envar>は<xref linkend="libpq-connect-host">接続パラメータと同様に動作します。
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGHOSTADDR</envar></primary>
      </indexterm>
<!--
      <envar>PGHOSTADDR</envar> behaves the same as the <xref
      linkend="libpq-connect-hostaddr"> connection parameter.
      This can be set instead of or in addition to <envar>PGHOST</envar>
      to avoid DNS lookup overhead.
-->
<envar>PGHOSTADDR</envar>は<xref linkend="libpq-connect-hostaddr">接続パラメータと同様に動作します。
<envar>PGHOST</envar>の代わりに設定して、または、<envar>PGHOST</envar>に追加して、DNS検索に要するオーバヘッドをなくすことができます。
     </para>

    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGPORT</envar></primary>
      </indexterm>
<!--
      <envar>PGPORT</envar> behaves the same as the <xref
      linkend="libpq-connect-port"> connection parameter.
-->
<envar>PGPORT</envar>は<xref linkend="libpq-connect-port">接続パラメータと同様に動作します。
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGDATABASE</envar></primary>
      </indexterm>
<!--
      <envar>PGDATABASE</envar> behaves the same as the <xref
      linkend="libpq-connect-dbname"> connection parameter.
-->
<envar>PGDATABASE</envar>は<xref linkend="libpq-connect-dbname">接続パラメータと同様に動作します。
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGUSER</envar></primary>
      </indexterm>
<!--
      <envar>PGUSER</envar> behaves the same as the <xref
      linkend="libpq-connect-user"> connection parameter.
-->
<envar>PGUSER</envar>は<xref linkend="libpq-connect-user">接続パラメータと同様に動作します。
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGPASSWORD</envar></primary>
      </indexterm>
<!--
      <envar>PGPASSWORD</envar> behaves the same as the <xref
      linkend="libpq-connect-password"> connection parameter.
      Use of this environment variable
      is not recommended for security reasons, as some operating systems
      allow non-root users to see process environment variables via
      <application>ps</>; instead consider using the
      <filename>~/.pgpass</> file (see <xref linkend="libpq-pgpass">).
-->
<envar>PGPASSWORD</envar>は<xref linkend="libpq-connect-password">接続パラメータと同様に動作します。
この環境変数は、一部のオペレーティングシステムではroot以外のユーザが<application>ps</>コマンド経由で環境変数を見ることができるなど、セキュリティ上の理由から現在では推奨されていません。 
代わりに<filename>~/.pgpass</>(<xref linkend="libpq-pgpass">を参照してください)を使用することを検討してください。
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGPASSFILE</envar></primary>
      </indexterm>
<!--
      <envar>PGPASSFILE</envar> specifies the name of the password file to
      use for lookups.  If not set, it defaults to <filename>~/.pgpass</>
      (see <xref linkend="libpq-pgpass">).
-->
<envar>PGPASSFILE</envar>は検索に使用するパスワードファイルの名前を指定します。
指定していなければ、デフォルトの<filename>~/.pgpass</>（<xref linkend="libpq-pgpass">を参照してください）となります。
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGSERVICE</envar></primary>
      </indexterm>
<!--
      <envar>PGSERVICE</envar> behaves the same as the <xref
      linkend="libpq-connect-service"> connection parameter.
-->
<envar>PGSERVICE</envar>は<xref linkend="libpq-connect-service">接続パラメータと同様に動作します。
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGSERVICEFILE</envar></primary>
      </indexterm>
<!--
      <envar>PGSERVICEFILE</envar> specifies the name of the per-user
      connection service file.  If not set, it defaults
      to <filename>~/.pg_service.conf</>
      (see <xref linkend="libpq-pgservice">).
-->
<envar>PGSERVICEFILE</envar>はユーザごとの接続サービスファイルを指定します。
設定されていない場合、デフォルトは<filename>~/.pg_service.conf</>（<xref linkend="libpq-pgservice">参照）となります。
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGREALM</envar></primary>
      </indexterm>
<!--
      <envar>PGREALM</envar> sets the Kerberos realm to use with
      <productname>PostgreSQL</productname>, if  it is different from the
      local realm.  If <envar>PGREALM</envar> is set,
      <application>libpq</application> applications will attempt
      authentication  with  servers for this realm and use separate ticket
      files to avoid conflicts with local ticket files.   This
      environment  variable is only used if GSSAPI authentication is
      selected by the server.
-->
<envar>PGREALM</envar>は、<productname>PostgreSQL</productname>で使用するKerberosのレルムがローカルのものと異なる場合に、そのレルムを設定します。
<envar>PGREALM</envar>が設定されると、<application>libpq</application>アプリケーションは設定されたレルム用のサーバと認証を行い、また、別のチケットファイルを使って、ローカルのチケットファイルと競合しないようにします。
この環境変数は、サーバがGSSAPIによる認証を選択した場合にのみ使われます。
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGOPTIONS</envar></primary>
      </indexterm>
<!--
      <envar>PGOPTIONS</envar> behaves the same as the <xref
      linkend="libpq-connect-options"> connection parameter.
-->
<envar>PGOPTIONS</envar>は<xref linkend="libpq-connect-options">接続パラメータと同様に動作します。
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGAPPNAME</envar></primary>
      </indexterm>
<!--
      <envar>PGAPPNAME</envar> behaves the same as the <xref
      linkend="libpq-connect-application-name"> connection parameter.
-->
<envar>PGAPPNAME</envar>は<xref linkend="libpq-connect-application-name">接続パラメータと同様に動作します。
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGSSLMODE</envar></primary>
      </indexterm>
<!--
      <envar>PGSSLMODE</envar> behaves the same as the <xref
      linkend="libpq-connect-sslmode"> connection parameter.
-->
<envar>PGSSLMODE</envar>は<xref linkend="libpq-connect-sslmode">接続パラメータと同様に動作します。
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGREQUIRESSL</envar></primary>
      </indexterm>
<!--
      <envar>PGREQUIRESSL</envar> behaves the same as the <xref
      linkend="libpq-connect-requiressl"> connection parameter.
-->
<envar>PGREQUIRESSL</envar>は<xref linkend="libpq-connect-requiressl">接続パラメータと同様に動作します。
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGSSLCOMPRESSION</envar></primary>
      </indexterm>
<!--
      <envar>PGSSLCOMPRESSION</envar> behaves the same as the <xref
      linkend="libpq-connect-sslcompression"> connection parameter.
-->
<envar>PGSSLCOMPRESSION</envar>は<xref linkend="libpq-connect-sslcompression">接続パラメータと同様に動作します。
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGSSLCERT</envar></primary>
      </indexterm>
<!--
      <envar>PGSSLCERT</envar> behaves the same as the <xref
      linkend="libpq-connect-sslcert"> connection parameter.
-->
<envar>PGSSLCERT</envar>は<xref linkend="libpq-connect-sslcert">接続パラメータと同様に動作します。
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGSSLKEY</envar></primary>
      </indexterm>
<!--
      <envar>PGSSLKEY</envar> behaves the same as the <xref
      linkend="libpq-connect-sslkey"> connection parameter.
-->
<envar>PGSSLKEY</envar>は<xref linkend="libpq-connect-sslkey">接続パラメータと同様に動作します。
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGSSLROOTCERT</envar></primary>
      </indexterm>
<!--
      <envar>PGSSLROOTCERT</envar>  behaves the same as the <xref
      linkend="libpq-connect-sslrootcert"> connection parameter.
-->
<envar>PGSSLROOTCERT</envar>は<xref linkend="libpq-connect-sslrootcert">接続パラメータと同様に動作します。
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGSSLCRL</envar></primary>
      </indexterm>
<!--
      <envar>PGSSLCRL</envar>  behaves the same as the <xref
      linkend="libpq-connect-sslcrl"> connection parameter.
-->
<envar>PGSSLCRL</envar>は<xref linkend="libpq-connect-sslcrl">接続パラメータと同様に動作します。
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGREQUIREPEER</envar></primary>
      </indexterm>
<!--
      <envar>PGREQUIREPEER</envar> behaves the same as the <xref
      linkend="libpq-connect-requirepeer"> connection parameter.
-->
<envar>PGREQUIREPEER</envar>は<xref linkend="libpq-connect-requirepeer">接続パラメータと同様に動作します。
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGKRBSRVNAME</envar></primary>
      </indexterm>
<!--
      <envar>PGKRBSRVNAME</envar>  behaves the same as the <xref
      linkend="libpq-connect-krbsrvname"> connection parameter.
-->
<envar>PGKRBSRVNAME</envar>は<xref linkend="libpq-connect-krbsrvname">接続パラメータと同様に動作します。
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGGSSLIB</envar></primary>
      </indexterm>
<!--
      <envar>PGGSSLIB</envar> behaves the same as the <xref
      linkend="libpq-connect-gsslib"> connection parameter.
-->
<envar>PGGSSLIB</envar>は<xref linkend="libpq-connect-gsslib">接続パラメータと同様に動作します。
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGCONNECT_TIMEOUT</envar></primary>
      </indexterm>
<!--
      <envar>PGCONNECT_TIMEOUT</envar>  behaves the same as the <xref
      linkend="libpq-connect-connect-timeout"> connection parameter.
-->
<envar>PGCONNECT_TIMEOUT</envar>は<xref linkend="libpq-connect-connect-timeout">接続パラメータと同様に動作します。
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGCLIENTENCODING</envar></primary>
      </indexterm>
<!--
      <envar>PGCLIENTENCODING</envar> behaves the same as the <xref
      linkend="libpq-connect-client-encoding"> connection parameter.
-->
<envar>PGCLIENTENCODING</envar>は<xref linkend="libpq-connect-client-encoding">接続パラメータと同様に動作します。
     </para>
    </listitem>
   </itemizedlist>
  </para>

  <para>
<!--
   The following environment variables can be used to specify default
   behavior for each <productname>PostgreSQL</productname> session.  (See
   also the <xref linkend="sql-alterrole">
   and <xref linkend="sql-alterdatabase">
   commands for ways to set default behavior on a per-user or per-database
   basis.)
-->
以下の環境変数を使用して、<productname>PostgreSQL</productname>セッション毎のデフォルト動作を指定することができます。
(また、ユーザ毎、もしくは、データベース毎を単位としたデフォルト動作の設定方法については<xref linkend="sql-alterrole">および<xref linkend="sql-alterdatabase">コマンドを参照してください。)

   <itemizedlist>
    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGDATESTYLE</envar></primary>
      </indexterm>
<!--
      <envar>PGDATESTYLE</envar> sets the default style of date/time
      representation.  (Equivalent to <literal>SET datestyle TO
      ...</literal>.)
-->
<envar>PGDATESTYLE</envar>はデフォルトの日付/時刻表現形式を設定します。
(<literal>SET datestyle TO ...</literal>と等価です。)
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGTZ</envar></primary>
      </indexterm>
<!--
      <envar>PGTZ</envar> sets the default time zone.  (Equivalent to
      <literal>SET timezone TO ...</literal>.)
-->
<envar>PGTZ</envar>はデフォルトの時間帯を設定します。
(<literal>SET timezone TO ...</literal>と等価です。)
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGGEQO</envar></primary>
      </indexterm>
<!--
      <envar>PGGEQO</envar> sets the default mode for the genetic query
      optimizer.  (Equivalent to <literal>SET geqo TO ...</literal>.)
-->
<envar>PGGEQO</envar>は遺伝的問い合わせオプティマイザのデフォルトのモードを設定します。
(<literal>SET geqo TO ...</literal>と等価です。)
     </para>
    </listitem>
   </itemizedlist>

<!--
   Refer to the <acronym>SQL</acronym> command <xref linkend="sql-set">
   for information on correct values for these
   environment variables.
-->
これらの環境変数の正確な値については、<xref linkend="sql-set"> <acronym>SQL</acronym>コマンドを参照してください。
  </para>

  <para>
<!--
   The following environment variables determine internal behavior of
   <application>libpq</application>; they override compiled-in defaults.
-->
以下の環境変数は、<application>libpq</application>の内部動作を決定します。
これらはコンパイル時のデフォルトを上書きします。

   <itemizedlist>
    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGSYSCONFDIR</envar></primary>
      </indexterm>
<!--
      <envar>PGSYSCONFDIR</envar> sets the directory containing the
      <filename>pg_service.conf</> file and in a future version
      possibly other system-wide configuration files.
-->
<envar>PGSYSCONFDIR</envar>は<filename>pg_service.conf</>ファイルがあるディレクトリを設定します。
また今後のバージョンでは他のシステム全体の設定ファイルとなるかもしれません。
     </para>
    </listitem>

    <listitem>
     <para>
      <indexterm>
       <primary><envar>PGLOCALEDIR</envar></primary>
      </indexterm>
<!--
      <envar>PGLOCALEDIR</envar> sets the directory containing the
      <literal>locale</> files for message internationalization.
-->
<envar>PGLOCALEDIR</envar>は国際化メッセージ用の<literal>locale</>ファイルがあるディレクトリを設定します。
     </para>
    </listitem>
   </itemizedlist>
  </para>

 </sect1>


 <sect1 id="libpq-pgpass">
<!--
  <title>The Password File</title>
-->
  <title>パスワードファイル</title>

  <indexterm zone="libpq-pgpass">
<!--
   <primary>password file</primary>
-->
   <primary>パスワードファイル</primary>
  </indexterm>
  <indexterm zone="libpq-pgpass">
   <primary>.pgpass</primary>
  </indexterm>

  <para>
<!--
   The file <filename>.pgpass</filename> in a user's home directory or the
   file referenced by <envar>PGPASSFILE</envar> can contain passwords to
   be used if the connection requires a password (and no password has been
   specified  otherwise). On Microsoft Windows the file is named
   <filename>%APPDATA%\postgresql\pgpass.conf</> (where
   <filename>%APPDATA%</> refers to the Application Data subdirectory in
   the user's profile).
-->
ユーザのホームディレクトリの<filename>.pgpass</filename>または<envar>PGPASSFILE</envar>で設定されるファイルは、接続にパスワードが必要な場合(かつ、他に指定されたパスワードが無かった場合)に使用するパスワードを格納するファイルです。
Microsoft Windowsでは、このファイルの名前は<filename>%APPDATA%\postgresql\pgpass.conf</>(ここで<filename>%APPDATA%</>はユーザのプロファイル内のアプリケーションデータディレクトリ)です。
  </para>

  <para>
<!--
   This file should contain lines of the following format:
-->
このファイル内の行の書式は次の通りです。
<synopsis>
<replaceable>hostname</replaceable>:<replaceable>port</replaceable>:<replaceable>database</replaceable>:<replaceable>username</replaceable>:<replaceable>password</replaceable>
</synopsis>
<!--
   (You can add a reminder comment to the file by copying the line above and
   preceding it with <literal>#</>.)
   Each of the first four fields can be a literal value, or
   <literal>*</literal>, which matches anything.  The password field from
   the first line that matches the current connection parameters will be
   used.  (Therefore, put more-specific entries first when you are using
   wildcards.) If an entry needs to contain <literal>:</literal> or
   <literal>\</literal>, escape this character with <literal>\</literal>.
   A host name of <literal>localhost</> matches both TCP (host name
   <literal>localhost</>) and Unix domain socket (<literal>pghost</> empty
   or the default socket directory) connections coming from the local
   machine. In a standby server, a database name of <literal>replication</>
   matches streaming replication connections made to the master server.
   The <literal>database</> field is of limited usefulness because
   users have the same password for all databases in the same cluster.
-->
（このファイルでは、上のような行をコピーし、その先頭に<literal>#</>をつけて忘れないようにコメントとして残すことができます。）
先頭の4フィールドはそれぞれリテラル値にすることも、あるいはすべてに一致する<literal>*</literal>を使用することもできます。
最初に現在の接続パラメータと一致した行のパスワードフィールドが使用されます。
(従って、ワイルドカードを使用する場合は、始めの方により具体的な項目を入力してください。)
項目内に<literal>:</literal>または<literal>\</literal>を含める必要があれば、<literal>\</literal>でこれらの文字をエスケープする必要があります。
<literal>localhost</>ホスト名は、ローカルマシンからのTCP接続（ホスト名が<literal>localhost</>）とUnixドメインソケット接続（<literal>pghost</>が空またはデフォルトのソケットディレクトリ）の両方に一致します。
スタンバイサーバでは、<literal>replication</>という名称のデータベースは、マスタサーバとの間でなされるストリーミングレプリケーション用の接続に一致します。
同一のクラスタ内のすべてのデータベースに対するパスワードは同じものですので、<literal>database</>フィールドの有用性は限定的なものです。
  </para>

  <para>
<!--
   On Unix systems, the permissions on <filename>.pgpass</filename> must
   disallow any access to world or group; achieve this by the command
   <command>chmod 0600 ~/.pgpass</command>.  If the permissions are less
   strict than this, the file will be ignored.  On Microsoft Windows, it
   is assumed that the file is stored in a directory that is secure, so
   no special permissions check is made.
-->
Unixシステムにおいて、<filename>.pgpass</filename>の権限はグループ、他者へのアクセスをすべて拒否しなければなりません。
これは<command>chmod 0600 ~/.pgpass</command>といったコマンドによって行います。
権限をこれよりも緩くすると、このファイルは無視されます。
Microsoft Windowsにおいては、このファイルが安全なディレクトリに格納されていることを前提としていますので、特別に行われる権限の検査はありません。
  </para>
 </sect1>


 <sect1 id="libpq-pgservice">
<!--
  <title>The Connection Service File</title>
-->
  <title>接続サービスファイル</title>

  <indexterm zone="libpq-pgservice">
<!--
   <primary>connection service file</primary>
-->
   <primary>接続サービスファイル</primary>
  </indexterm>
  <indexterm zone="libpq-pgservice">
   <primary>pg_service.conf</primary>
  </indexterm>
  <indexterm zone="libpq-pgservice">
   <primary>.pg_service.conf</primary>
  </indexterm>

  <para>
<!--
   The connection service file allows libpq connection parameters to be
   associated with a single service name. That service name can then be
   specified by a libpq connection, and the associated settings will be
   used. This allows connection parameters to be modified without requiring
   a recompile of the libpq application. The service name can also be
   specified using the <envar>PGSERVICE</envar> environment variable.
-->
接続サービスファイルにより、libpq接続パラメータをひとつのサービス名に関連付けることができます。
サービス名は、libpq接続によって指定され、関連付けられた設定が利用されます。
これは、接続パラメータをlibpqアプリケーションの再コンパイルをせずに修正できるというものです。
サービス名は<envar>PGSERVICE</envar>環境変数を利用することで使用できます。
  </para>

  <para>
<!--
   The connection service file can be a per-user service file
   at <filename>~/.pg_service.conf</filename> or the location
   specified by the environment variable <envar>PGSERVICEFILE</envar>,
   or it can be a system-wide file
   at <filename>etc/pg_service.conf</filename> or in the directory
   specified by the environment variable
   <envar>PGSYSCONFDIR</envar>.  If service definitions with the same
   name exist in the user and the system file, the user file takes
   precedence.
-->
この接続サービスファイルは、ユーザごとに<filename>~/.pg_service.conf</filename>というサービスファイルとすること、または、<envar>PGSERVICEFILE</envar>環境変数で指定される場所にすることができます。
また、システム全体についてのファイルとして<filename>etc/pg_service.conf</filename>とすること、<envar>PGSYSCONFDIR</envar>環境変数で指定されたディレクトリに置くことができます。
ユーザ用、システム用のファイルで同名のサービス定義が存在する場合、ユーザ用のものが優先されます。
  </para>

  <para>
<!--
   The file uses an <quote>INI file</quote> format where the section
   name is the service name and the parameters are connection
   parameters; see <xref linkend="libpq-paramkeywords"> for a list.  For
   example:
-->
このファイルは<quote>INIファイル</quote>書式を使用します。
セクション名がサービス名となり、パラメータが接続パラメータです。
<xref linkend="libpq-paramkeywords">のリストを参照してください。
以下に例を示します。
<programlisting>
# comment
[mydb]
host=somehost
port=5433
user=admin
</programlisting>
<!--
   An example file is provided at
   <filename>share/pg_service.conf.sample</filename>.
-->
例となるファイルが<filename>share/pg_service.conf.sample</filename>にあります。
  </para>
 </sect1>


 <sect1 id="libpq-ldap">
<!--
  <title>LDAP Lookup of Connection Parameters</title>
-->
  <title>接続パラメータのLDAP検索</title>

  <indexterm zone="libpq-ldap">
<!--
   <primary>LDAP connection parameter lookup</primary>
-->
   <primary>LDAPによる接続パラメータ検索</primary>
  </indexterm>

  <para>
<!--
   If <application>libpq</application> has been compiled with LDAP support (option
   <literal><option>&#045;&#045;with-ldap</option></literal> for <command>configure</command>)
   it is possible to retrieve connection options like <literal>host</literal>
   or <literal>dbname</literal> via LDAP from a central server.
   The advantage is that if the connection parameters for a database change,
   the connection information doesn't have to be updated on all client machines.
-->
<application>libpq</application>がLDAPサポート（<command>configure</command>時の<literal><option>--with-ldap</option></literal>オプション）付きでコンパイルされている場合、中央サーバからLDAPを通して<literal>host</literal>や<literal>dbname</literal>などの接続オプションを取り出すことができます。
この利点は、データベースの接続パラメータが変わった場合に、すべてのクライアントマシンで接続情報を更新しなくても済む点です。
  </para>

  <para>
<!--
   LDAP connection parameter lookup uses the connection service file
   <filename>pg_service.conf</filename> (see <xref
   linkend="libpq-pgservice">).  A line in a
   <filename>pg_service.conf</filename> stanza that starts with
   <literal>ldap://</literal> will be recognized as an LDAP URL and an
   LDAP query will be performed. The result must be a list of
   <literal>keyword = value</literal> pairs which will be used to set
   connection options.  The URL must conform to RFC 1959 and be of the
   form
<synopsis>
ldap://[<replaceable>hostname</replaceable>[:<replaceable>port</replaceable>]]/<replaceable>search_base</replaceable>?<replaceable>attribute</replaceable>?<replaceable>search_scope</replaceable>?<replaceable>filter</replaceable>
</synopsis>
   where <replaceable>hostname</replaceable> defaults to
   <literal>localhost</literal> and <replaceable>port</replaceable>
   defaults to 389.
-->
LDAP接続パラメータ検索は、<filename>pg_service.conf</filename>という接続サービスファイル（<xref linkend="libpq-pgservice">を参照）を使用します。
<filename>pg_service.conf</filename>内の<literal>ldap://</literal>から始まる行は、LDAP URLとして認識され、LDAP問い合わせが実行されることを示します。
その結果は、<literal>keyword = value</literal>という組み合わせのリストでなければなりません。
これらが接続用オプションの設定に使用されます。
このURLはRFC 1959に従ったもので、以下のような形式でなければなりません。
<synopsis>
ldap://[<replaceable>hostname</replaceable>[:<replaceable>port</replaceable>]]/<replaceable>search_base</replaceable>?<replaceable>attribute</replaceable>?<replaceable>search_scope</replaceable>?<replaceable>filter</replaceable>
</synopsis>
ここで、<replaceable>hostname</replaceable>のデフォルトは<literal>localhost</literal>、<replaceable>port</replaceable>のデフォルトは389です。
  </para>

  <para>
<!--
   Processing of <filename>pg_service.conf</filename> is terminated after
   a successful LDAP lookup, but is continued if the LDAP server cannot
   be contacted.  This is to provide a fallback with further LDAP URL
   lines that point to different LDAP servers, classical <literal>keyword
   = value</literal> pairs, or default connection options.  If you would
   rather get an error message in this case, add a syntactically incorrect
   line after the LDAP URL.
-->
<filename>pg_service.conf</filename>の処理はLDAP検索が成功した時に終わります。
しかし、もしLDAPサーバへのアクセスができなかった場合は継続します。
これはアクセスに失敗した時に、異なるLDAPサーバを指し示す他のLDAP行や以前からの<literal>keyword = value</literal>の組み合わせ、デフォルトの接続オプションを参照する予備機能を提供します。
この場合にエラーメッセージを受け取りたい場合は、LDAP URL行の後に文法的に不正な行を記載してください。
  </para>

  <para>
<!--
   A sample LDAP entry that has been created with the LDIF file
-->
LDIFファイルとして作成されたLDAP項目の例を以下に示します。
<programlisting>
version:1
dn:cn=mydatabase,dc=mycompany,dc=com
changetype:add
objectclass:top
objectclass:device
cn:mydatabase
description:host=dbserver.mycompany.com
description:port=5439
description:dbname=mydb
description:user=mydb_user
description:sslmode=require
</programlisting>
<!--
   might be queried with the following LDAP URL:
-->
これは、以下のようなLDAP URLから得られます。
<programlisting>
ldap://ldap.mycompany.com/dc=mycompany,dc=com?description?one?(cn=mydatabase)
</programlisting>
  </para>

  <para>
<!--
   You can also mix regular service file entries with LDAP lookups.
   A complete example for a stanza in <filename>pg_service.conf</filename>
   would be:
-->
また、LDAP検索と通常のサービスファイル項目とを混在させることもできます。
<filename>pg_service.conf</filename>の一節について完全な例を以下に示します。
<programlisting>
# only host and port are stored in LDAP, specify dbname and user explicitly
[customerdb]
dbname=customer
user=appuser
ldap://ldap.acme.com/cn=dbserver,cn=hosts?pgconnectinfo?base?(objectclass=*)
</programlisting>
  </para>

 </sect1>


 <sect1 id="libpq-ssl">
<!--
  <title>SSL Support</title>
-->
  <title>SSLサポート</title>

  <indexterm zone="libpq-ssl">
   <primary>SSL</primary>
  </indexterm>

  <para>
<!--
   <productname>PostgreSQL</> has native support for using <acronym>SSL</>
   connections to encrypt client/server communications for increased
   security. See <xref linkend="ssl-tcp"> for details about the server-side
   <acronym>SSL</> functionality.
-->
<productname>PostgreSQL</>は、セキュリティを高めるためにクライアントサーバ間の通信を暗号化する<acronym>SSL</>接続の使用を元来サポートしています。
サーバ側の<acronym>SSL</>機能についての詳細は<xref linkend="ssl-tcp">を参照してください。
  </para>

  <para>
<!--
   <application>libpq</application> reads the system-wide
   <productname>OpenSSL</productname> configuration file. By default, this
   file is named <filename>openssl.cnf</filename> and is located in the
   directory reported by <literal>openssl version -d</>.  This default
   can be overridden by setting environment variable
   <envar>OPENSSL_CONF</envar> to the name of the desired configuration
   file.
-->
<application>libpq</application>はシステム全体に対する<productname>OpenSSL</productname>設定ファイルを読み込みます。
デフォルトでは、ファイル名は<filename>openssl.cnf</filename>で、<literal>openssl version -d</>で報告されるディレクトリに格納されています。
このデフォルトは<envar>OPENSSL_CONF</envar>環境変数に希望する設定ファイル名を設定することで変更することができます。
  </para>

 <sect2 id="libq-ssl-certificates">
<!--
  <title>Client Verification of Server Certificates</title>
-->
  <title>サーバ証明書のクライアント検証</title>

  <para>
<!--
   By default, <productname>PostgreSQL</> will not perform any verification of
   the server certificate. This means that it is possible to spoof the server
   identity (for example by modifying a DNS record or by taking over the server
   IP address) without the client knowing. In order to prevent spoofing,
   <acronym>SSL</> certificate verification must be used.
-->
デフォルトでは<productname>PostgreSQL</>はサーバ証明書の検証をまったく行いません。
これは、（例えば、DNSレコードを変更したり、もしくはサーバのIPアドレスを接収したりして）クライアントに知られずにサーバの属性をなりすませることを意味します。
なりすましを防止するには<acronym>SSL</>証明書検証を使用しなければなりません。
  </para>

  <para>
<!--
   If the parameter <literal>sslmode</> is set to <literal>verify-ca</>,
   libpq will verify that the server is trustworthy by checking the
   certificate chain up to a trusted certificate authority
   (<acronym>CA</>). If <literal>sslmode</> is set to <literal>verify-full</>,
   libpq will <emphasis>also</> verify that the server host name matches its
   certificate. The SSL connection will fail if the server certificate cannot
   be verified. <literal>verify-full</> is recommended in most
   security-sensitive environments.
-->
パラメータ<literal>sslmode</>が<literal>verify-ca</>に設定されている場合、libpqは信頼される認証局(<acronym>CA</>)までの証明書連鎖を検査することで、サーバが信用に足るかを検証します。
<literal>sslmode</>が<literal>verify-full</>に設定されていると、libpqは<emphasis>同時に</>サーバホスト名が証明書のそれと一致するかを検証します。
SSL接続はサーバ証明書が検証されない場合失敗します。
安全性に慎重を期するほとんどのサーバ環境では<literal>verify-full</>を推奨します。
  </para>

  <para>
<!--
   In <literal>verify-full</> mode, the <literal>cn</> (Common Name) attribute
   of the certificate is matched against the host name. If the <literal>cn</>
   attribute starts with an asterisk (<literal>*</>), it will be treated as
   a wildcard, and will match all characters <emphasis>except</> a dot
   (<literal>.</>). This means the certificate will not match subdomains.
   If the connection is made using an IP address instead of a host name, the
   IP address will be matched (without doing any DNS lookups).
-->
<literal>verify-full</>モードでは証明書の<literal>cn</>（コモンネーム）属性はホスト名と一致させられます。
<literal>cn</>属性がアスタリスク（<literal>*</>）で始まると、それはワイルドカードとして取り扱われ、ドット（<literal>.</>）を除くすべての文字と一致します。
これは、証明書がサブドメインと一致しないことを意味します。
もし接続がホスト名ではなくIPアドレスを使用するのであれば、（いかなるDNS検索もせず）IPアドレスが一致させられます。
  </para>

  <para>
<!--
   To allow server certificate verification, the certificate(s) of one or more
   trusted <acronym>CA</>s must be
   placed in the file <filename>~/.postgresql/root.crt</> in the user's home
   directory. If intermediate <acronym>CA</>s appear in
   <filename>root.crt</filename>, the file must also contain certificate
   chains to their root <acronym>CA</>s. (On Microsoft Windows the file is named
   <filename>%APPDATA%\postgresql\root.crt</filename>.)
-->
サーバ証明書の検証を可能にするには、1つ以上の信頼する<acronym>CA</>の証明書を、ユーザのホームディレクトリの<filename>~/.postgresql/root.crt</>ファイルに置かなければなりません。
中間<acronym>CA</>が<filename>root.crt</filename>にあるのであれば、そのファイルはそのルート<acronym>CA</>への証明書チェーンも含まなければなりません。
（Microsoft Windowsの場合、このファイルの名前は<filename>%APPDATA%\postgresql\root.crt</filename>です。）
  </para>

  <para>
<!--
   Certificate Revocation List (CRL) entries are also checked
   if the file <filename>~/.postgresql/root.crl</filename> exists
   (<filename>%APPDATA%\postgresql\root.crl</filename> on Microsoft
   Windows).
-->
<filename>~/.postgresql/root.crl</filename>ファイル（Microsoft Windowsでは<filename>%APPDATA%\postgresql\root.crl</filename>）が存在する場合、証明書失効リスト（CRL）の項目もまた検査されます。
  </para>

  <para>
<!--
   The location of the root certificate file and the CRL can be changed by
   setting
   the connection parameters <literal>sslrootcert</> and <literal>sslcrl</>
   or the environment variables <envar>PGSSLROOTCERT</> and <envar>PGSSLCRL</>.
-->
ルート証明書ファイルとCRLの格納場所を接続パラメータ<literal>sslrootcert</>と<literal>sslcrl</>、もしくは環境変数<envar>PGSSLROOTCERT</>と<envar>PGSSLCRL</>で変更することができます。
  </para>

  <note>
   <para>
<!--
    For backwards compatibility with earlier versions of PostgreSQL, if a
    root CA file exists, the behavior of
    <literal>sslmode</literal>=<literal>require</literal> will be the same
    as that of <literal>verify-ca</literal>, meaning the server certificate
    is validated against the CA. Relying on this behavior is discouraged,
    and applications that need certificate validation should always use
    <literal>verify-ca</literal> or <literal>verify-full</literal>.
-->
より古いバージョンのPostgreSQLとの後方互換性のために、ルートCAファイルが存在する場合、<literal>sslmode</literal>=<literal>require</literal>の動作は<literal>verify-ca</literal>の場合と同じになっています。
つまり、サーバ証明書がCAに対して検証されます。
この動作に依存することは勧めません。
また証明書の検証を必要とするアプリケーションは常に<literal>verify-ca</literal>または<literal>verify-full</literal>を使用すべきです。
   </para>
  </note>
 </sect2>

 <sect2 id="libpq-ssl-clientcert">
<!--
  <title>Client Certificates</title>
-->
  <title>クライアント証明書</title>

  <para>
<!--
   If the server requests a trusted client certificate,
   <application>libpq</application> will send the certificate stored in
   file <filename>~/.postgresql/postgresql.crt</> in the user's home
   directory.  The certificate must be signed by one of the certificate
   authorities (<acronym>CA</acronym>) trusted by the server.  A matching
   private key file <filename>~/.postgresql/postgresql.key</> must also
   be present. The private
   key file must not allow any access to world or group; achieve this by the
   command <command>chmod 0600 ~/.postgresql/postgresql.key</command>.
   On Microsoft Windows these files are named
   <filename>%APPDATA%\postgresql\postgresql.crt</filename> and
   <filename>%APPDATA%\postgresql\postgresql.key</filename>, and there
   is no special permissions check since the directory is presumed secure.
   The location of the certificate and key files can be overridden by the
   connection parameters <literal>sslcert</> and <literal>sslkey</> or the
   environment variables <envar>PGSSLCERT</> and <envar>PGSSLKEY</>.
-->
サーバが信頼できるクライアント証明書を要求する場合、<application>libpq</application>はユーザのホームディレクトリにある<filename>~/.postgresql/postgresql.crt</>ファイルに格納された証明書を送信します。
証明書はサーバで信頼された認証局（<acronym>CA</acronym>）のいずれかで署名されなければなりません。
対応する<filename>~/.postgresql/postgresql.key</>秘密キーファイルも存在しなければなりません。
秘密キーファイルは他者やグループからのアクセスを許可してはいけません。
<command>chmod 0600 ~/.postgresql/postgresql.key</command>コマンドでこれを実現してください。
Microsoft Windowsでは、このファイルの名前はそれぞれ<filename>%APPDATA%\postgresql\postgresql.crt</filename>と<filename>%APPDATA%\postgresql\postgresql.key</filename>であり、このディレクトリは安全であると想定されますので、特別な権限検査は行われません。
証明書とキーファイルの格納場所は<literal>sslcert</>および<literal>sslkey</>接続パラメータ、または<envar>PGSSLCERT</>および<envar>PGSSLKEY</>環境変数で上書きされます。
  </para>

  <para>
<!--
   In some cases, the client certificate might be signed by an
   <quote>intermediate</> certificate authority, rather than one that is
   directly trusted by the server.  To use such a certificate, append the
   certificate of the signing authority to the <filename>postgresql.crt</>
   file, then its parent authority's certificate, and so on up to a certificate
   authority, <quote>root</> or <quote>intermediate</>, that is trusted by
   the server, i.e. signed by a certificate in the server's
   <filename>root.crt</filename> file.
-->
クライアント証明書が、サーバにより直接信頼された認証局ではなく、<quote>中間</>認証局で署名されている場合があります。
こうした証明書を使用するためには、署名した認証局の証明書を、さらにその親の認証局の証明書を、サーバにより信頼される<quote>ルート</>もしくは<quote>中間</>認証局まで<filename>postgresql.crt</>ファイルに追加してください。
サーバにより信頼されるとは、すなわちサーバの<filename>root.crt</filename>ファイルにある証明書により署名されているということです。
  </para>

  <para>
<!--
   Note that the client's <filename>~/.postgresql/root.crt</> lists the top-level CAs
   that are considered trusted for signing server certificates.  In principle it need
   considered trusted for signing server certificates.  In principle it need
   not list the CA that signed the client's certificate, though in most cases
   that CA would also be trusted for server certificates.
-->
クライアントの<filename>~/.postgresql/root.crt</>には、サーバ証明書の署名に関して信頼できるとみなされる、最上位のCAが列挙されていることに注意してください。
原理的にはクライアント証明書を署名するCAを列挙する必要はありませんが、ほとんどの場合において、そのCAは同時にサーバ証明書に対しても信頼されています。
  </para>

 </sect2>

 <sect2 id="libpq-ssl-protection">
<!--
  <title>Protection Provided in Different Modes</title>
-->
  <title>異なるモードで提供される保護</title>

  <para>
<!--
   The different values for the <literal>sslmode</> parameter provide different
   levels of protection. SSL can provide
   protection against three types of attacks:
-->
<literal>sslmode</>パラメータ値を変更することで、異なったレベルの保護を提供します。
SSLは以下の３種類の攻撃に対する保護を提供することができます。

   <variablelist>
    <varlistentry>
<!--
     <term>Eavesdropping</term>
-->
     <term>盗聴</term>
     <listitem>
<!--
      <para>If a third party can examine the network traffic between the
       client and the server, it can read both connection information (including
       the user name and password) and the data that is passed. <acronym>SSL</>
       uses encryption to prevent this.
-->
<para>クライアント・サーバ間のネットワークトラフィックを第三者が監視することができれば、（ユーザ名とパスワードを含め）双方の接続情報と通過するデータを読み取ることができます。
<acronym>SSL</>はこれを防止するために暗号を使用します。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
<!--
     <term>Man in the middle (<acronym>MITM</>)</term>
-->
     <term>中間者攻撃（<acronym>MITM</>）</term>
     <listitem>
<!--
      <para>If a third party can modify the data while passing between the
       client and server, it can pretend to be the server and therefore see and
       modify data <emphasis>even if it is encrypted</>. The third party can then
       forward the connection information and data to the original server,
       making it impossible to detect this attack. Common vectors to do this
       include DNS poisoning and address hijacking, whereby the client is directed
       to a different server than intended. There are also several other
       attack methods that can accomplish this. <acronym>SSL</> uses certificate
       verification to prevent this, by authenticating the server to the client.
-->
<para>データがクライアント・サーバ間で渡されている時に、第三者がそのデータを変更できれば、サーバを装うことができ、従って<emphasis>たとえ暗号化されていても</>データを理解し変更することができます。
第三者はそこで、この攻撃を検出不可能にする接続情報とデータを元のサーバに送ることができます。
これを行う共通した媒介はDNSポイズニングとアドレス乗っ取りを含み、それに従ってクライアントは意図したサーバではなく異なったサーバに誘導されます。
同時に、このことを成し遂げるいくつかの異なった攻撃も存在します。
<acronym>SSL</>はクライアントに対しサーバを認証することで、この防止に証明書検証を使用します。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
<!--
     <term>Impersonation</term>
-->
     <term>なりすまし</term>
     <listitem>
<!--
      <para>If a third party can pretend to be an authorized client, it can
       simply access data it should not have access to. Typically this can
       happen through insecure password management. <acronym>SSL</> uses
       client certificates to prevent this, by making sure that only holders
       of valid certificates can access the server.
-->
<para>第三者が認定されたクライアントを装うことができれば、それはアクセスしてはならないデータに簡単にアクセス可能になります。
典型的にこれは心もとないパスワード管理から生じます。
<acronym>SSL</>は有効な証明書の所持者のみサーバにアクセスできることを確実にすることで、この防止策としてクライアント証明書を使用します。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

  <para>
<!--
   For a connection to be known secure, SSL usage must be configured
   on <emphasis>both the client and the server</> before the connection
   is made. If it is only configured on the server, the client may end up
   sending sensitive information (e.g. passwords) before
   it knows that the server requires high security. In libpq, secure
   connections can be ensured
   by setting the <literal>sslmode</> parameter to <literal>verify-full</> or
   <literal>verify-ca</>, and providing the system with a root certificate to
   verify against. This is analogous to using an <literal>https</>
   <acronym>URL</> for encrypted web browsing.
-->
信頼できるとされる接続では、SSLの使用を接続確立前に<emphasis>クライアントとサーバの双方において</>設定されなければなりません。
サーバのみに構成されると、クライアントはサーバが高度なセキュリティを必要とすることが判る以前に、（例えばパスワードのような）機密事項を扱う情報を結局送ることになります。
libpqにおいて、<literal>sslmode</>パラメータを<literal>verify-full</>または<literal>verify-ca</>に設定し、そして対象を検証するためルート証明書をシステムに提供することで、安全な接続を確実に行うことができます。
これは暗号化されたweb閲覧に対する<literal>https</> <acronym>URL</>の使用とよく似ています。
  </para>

  <para>
<!--
   Once the server has been authenticated, the client can pass sensitive data.
   This means that up until this point, the client does not need to know if
   certificates will be used for authentication, making it safe to specify that
   only in the server configuration.
-->
一度サーバが認証されると、クライアントは機密事項を扱うデータを送ることができます。
この意味は、これまでクライアントは認証に証明書が使われているかどうかを知る必要がなく、サーバ構成においてのみこのことを指定しても安全だと言うことです。
  </para>

  <para>
<!--
   All <acronym>SSL</> options carry overhead in the form of encryption and
   key-exchange, so there is a tradeoff that has to be made between performance
   and security. <xref linkend="libpq-ssl-sslmode-statements">
   illustrates the risks the different <literal>sslmode</> values
   protect against, and what statement they make about security and overhead.
-->
すべての<acronym>SSL</>オプションでは暗号化の形式と鍵交換といったオーバヘッドがかかります。
このため性能と安全性との間で決定されるべきトレードオフがあります。
<xref linkend="libpq-ssl-sslmode-statements">は異なる<literal>sslmode</>値が防御する危険性と、安全性とオーバヘッドに対する声明を示したものです。
  </para>

  <table id="libpq-ssl-sslmode-statements">
<!--
   <title>SSL Mode Descriptions</title>
-->
   <title>SSLモードの説明</title>
   <tgroup cols="4">
    <thead>
     <row>
      <entry><literal>sslmode</></entry>
<!--
      <entry>Eavesdropping protection</entry>
      <entry><acronym>MITM</> protection</entry>
      <entry>Statement</entry>
-->
      <entry>盗聴防止</entry>
      <entry><acronym>MITM</>防止</entry>
      <entry>声明</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>disable</></entry>
<!--
      <entry>No</entry>
      <entry>No</entry>
      <entry>I don't care about security, and I don't want to pay the overhead
       of encryption.
      </entry>
-->
      <entry>いいえ</entry>
      <entry>いいえ</entry>
      <entry>セキュリティはどうでもよく、暗号化の負荷を払いたくない
      </entry>
     </row>

     <row>
      <entry><literal>allow</></entry>
<!--
      <entry>Maybe</entry>
      <entry>No</entry>
      <entry>I don't care about security, but I will pay the overhead of
       encryption if the server insists on it.
      </entry>
-->
      <entry>たぶん</entry>
      <entry>いいえ</entry>
      <entry>セキュリティはどうでもよいが、サーバがそれを強く要求するのであれば暗号化のオーバヘッドを払ってもよい
      </entry>
     </row>

     <row>
      <entry><literal>prefer</></entry>
<!--
      <entry>Maybe</entry>
      <entry>No</entry>
      <entry>I don't care about encryption, but I wish to pay the overhead of
       encryption if the server supports it.
      </entry>
-->
      <entry>たぶん</entry>
      <entry>いいえ</entry>
      <entry>セキュリティはどうでもよいが、サーバがそれをサポートするのであれば暗号化のオーバヘッドを払ってもよい
      </entry>
     </row>

     <row>
      <entry><literal>require</></entry>
<!--
      <entry>Yes</entry>
      <entry>No</entry>
      <entry>I want my data to be encrypted, and I accept the overhead. I trust
       that the network will make sure I always connect to the server I want.
      </entry>
-->
      <entry>はい</entry>
      <entry>いいえ</entry>
      <entry>データを暗号化して欲しい。そしてオーバヘッドも受け入れる。意図したサーバに常に接続することをネットワークが確実にしてくれると信用する
      </entry>
     </row>

     <row>
      <entry><literal>verify-ca</></entry>
<!--
      <entry>Yes</entry>
      <entry><literal>Depends on CA</>-policy</entry>
      <entry>I want my data encrypted, and I accept the overhead. I want to be
       sure that I connect to a server that I trust.
      </entry>
-->
      <entry>はい</entry>
      <entry><literal>CA</>の規定に<literal>依存</></entry>
      <entry>データを暗号化して欲しい。そしてオーバヘッドも受け入れる。信頼するサーバに確実に接続したい
      </entry>
     </row>

     <row>
      <entry><literal>verify-full</></entry>
<!--
       <entry>Yes</entry>
       <entry>Yes</entry>
       <entry>I want my data encrypted, and I accept the overhead. I want to be
        sure that I connect to a server I trust, and that it's the one I
        specify.
       </entry>
-->
       <entry>はい</entry>
       <entry>はい</entry>
       <entry>データを暗号化して欲しい。そしてオーバヘッドも受け入れる。信頼するサーバに接続すること、そのサーバが指定したものであることを確実にしたい
       </entry>
      </row>

    </tbody>
   </tgroup>
  </table>

  <para>
<!--
   The difference between <literal>verify-ca</> and <literal>verify-full</>
   depends on the policy of the root <acronym>CA</>. If a public
   <acronym>CA</> is used, <literal>verify-ca</> allows connections to a server
   that <emphasis>somebody else</> may have registered with the <acronym>CA</>.
   In this case, <literal>verify-full</> should always be used. If
   a local <acronym>CA</> is used, or even a self-signed certificate, using
   <literal>verify-ca</> often provides enough protection.
-->
<literal>verify-ca</>と<literal>verify-full</>の差異はルート<acronym>CA</>の規定に依存します。
公的な<acronym>CA</>が使用されるとき、<literal>verify-ca</>はその<acronym>CA</>で<emphasis>他の誰か</>が登録したかもしれないサーバへの接続を許可します。
この場合、<literal>verify-full</>が常に使用されなければなりません。
独自<acronym>CA</>が使用されるとき、または自己署名証明書であったとしても<literal>verify-ca</>は十分な防御策を提供します。
  </para>

  <para>
<!--
   The default value for <literal>sslmode</> is <literal>prefer</>. As is shown
   in the table, this makes no sense from a security point of view, and it only
   promises performance overhead if possible. It is only provided as the default
   for backward compatibility, and is not recommended in secure deployments.
-->
<literal>sslmode</>のデフォルト値は<literal>prefer</>です。
表で示したように、これはセキュリティの視点では意味がなく、可能であれば性能上のオーバヘッドを保証するだけです。
これは後方互換性を提供するためのみにデフォルトとなっているもので、安全性確保の観点からは推奨されません。
  </para>

 </sect2>

 <sect2 id="libpq-ssl-fileusage">
<!--
  <title>SSL Client File Usage</title>
-->
  <title>SSLクライアントファイル使用法</title>

  <para>
<!--
   <xref linkend="libpq-ssl-file-usage"> summarizes the files that are
   relevant to the SSL setup on the client.
-->
<xref linkend="libpq-ssl-file-usage">にクライアントにおけるSSL設定に関連するファイルをまとめます。
  </para>

  <table id="libpq-ssl-file-usage">
<!--
   <title>Libpq/Client SSL File Usage</title>
-->
   <title>libpq/クライアントにおけるSSLファイルの使用方法</title>
   <tgroup cols="3">
    <thead>
     <row>
<!--
      <entry>File</entry>
      <entry>Contents</entry>
      <entry>Effect</entry>
-->
      <entry>ファイル</entry>
      <entry>内容</entry>
      <entry>効果</entry>
     </row>
    </thead>

    <tbody>

     <row>
      <entry><filename>~/.postgresql/postgresql.crt</></entry>
<!--
      <entry>client certificate</entry>
      <entry>requested by server</entry>
-->
      <entry>クライアント証明書</entry>
      <entry>サーバにより要求されます</entry>
     </row>

     <row>
      <entry><filename>~/.postgresql/postgresql.key</></entry>
<!--
      <entry>client private key</entry>
      <entry>proves client certificate sent by owner; does not indicate
      certificate owner is trustworthy</entry>
-->
      <entry>クライアントの秘密キー</entry>
      <entry>所有者により送信されるクライアント証明書を証明します。証明書の所有者が信頼できることを意味していません。</entry>
     </row>

     <row>
      <entry><filename>~/.postgresql/root.crt</></entry>
<!--
      <entry>trusted certificate authorities</entry>
      <entry>checks that server certificate is signed by a trusted certificate
      authority</entry>
-->
      <entry>信頼できる認証局</entry>
      <entry>サーバ証明書が信頼できる認証局により署名されたか検査します。</entry>
     </row>

     <row>
      <entry><filename>~/.postgresql/root.crl</></entry>
<!--
      <entry>certificates revoked by certificate authorities</entry>
      <entry>server certificate must not be on this list</entry>
-->
      <entry>認証局により失効された証明書</entry>
      <entry>サーバ証明書はこのリストにあってはいけません</entry>
     </row>

    </tbody>
   </tgroup>
  </table>
 </sect2>

 <sect2 id="libpq-ssl-initialize">
<!--
  <title>SSL Library Initialization</title>
-->
  <title>SSLライブラリの初期化</title>

  <para>
<!--
   If your application initializes <literal>libssl</> and/or
   <literal>libcrypto</> libraries and <application>libpq</application>
   is built with <acronym>SSL</> support, you should call
   <function>PQinitOpenSSL</> to tell <application>libpq</application>
   that the <literal>libssl</> and/or <literal>libcrypto</> libraries
   have been initialized by your application, so that
   <application>libpq</application> will not also initialize those libraries.
-->
   <!-- 原文コメント If this URL changes replace it with a URL to www.archive.org. -->
<!--
   See <ulink
   url="http://h71000.www7.hp.com/doc/83final/BA554_90007/ch04.html"></ulink>
   for details on the SSL API.
-->
使用するアプリケーションが<literal>libssl</>と<literal>libcrypto</>の両方またはいずれか一方のライブラリを初期化し、<application>libpq</application>が<acronym>SSL</>サポート付きで構築された場合、<literal>libssl</>と<literal>libcrypto</>の両方またはいずれか一方のライブラリはアプリケーションによって初期化されたことを<application>libpq</application>に伝えるため<function>PQinitOpenSSL</>を呼び出さなければなりません。
これにより、<application>libpq</application>はこれらのライブラリを初期化しなくなります。
SSL APIの詳細は<ulink url="http://h71000.www7.hp.com/doc/83final/BA554_90007/ch04.html"></ulink>を参照してください。
  </para>

  <para>
   <variablelist>
    <varlistentry id="libpq-pqinitopenssl">
     <term>
      <function>PQinitOpenSSL</function>
      <indexterm>
       <primary>PQinitOpenSSL</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
<!--
       Allows applications to select which security libraries to initialize.
-->
アプリケーションがどのセキュリティライブラリを初期化するか選択することができます。
<synopsis>
void PQinitOpenSSL(int do_ssl, int do_crypto);
</synopsis>
      </para>

      <para>
<!--
       When <parameter>do_ssl</> is non-zero, <application>libpq</application>
       will initialize the <application>OpenSSL</> library before first
       opening a database connection.  When <parameter>do_crypto</> is
       non-zero, the <literal>libcrypto</> library will be initialized.  By
       default (if <function>PQinitOpenSSL</> is not called), both libraries
       are initialized.  When SSL support is not compiled in, this function is
       present but does nothing.
-->
<parameter>do_ssl</>が非ゼロの時、<application>libpq</application>は最初のデータベース接続を開始する以前に<application>OpenSSL</>ライブラリを初期化します。
<parameter>do_crypto</>が非ゼロの時、<literal>libcrypto</>ライブラリが初期化されます。
デフォルトでは（<function>PQinitOpenSSL</>が呼ばれない場合）、両方のライブラリが初期化されます。
SSLサポートがコンパイルされていない場合、この関数は存在しますが何もしません。
      </para>

      <para>
<!--
       If your application uses and initializes either <application>OpenSSL</>
       or its underlying <literal>libcrypto</> library, you <emphasis>must</>
       call this function with zeroes for the appropriate parameter(s)
       before first opening a database connection.  Also be sure that you
       have done that initialization before opening a database connection.
-->
使用するアプリケーションが<application>OpenSSL</>またはその基礎をなす<literal>libcrypto</>ライブラリのいずれかを使用し、そして初期化するのであれば、最初のデータベース接続開始以前に、適切なパラメータをゼロにしてこの関数を呼び出さなければ<emphasis>なりません</>。
同時に、データベース接続開始前に初期化を行ったことの確認をしてください。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="libpq-pqinitssl">
     <term>
      <function>PQinitSSL</function>
      <indexterm>
       <primary>PQinitSSL</primary>
      </indexterm>
     </term>

     <listitem>
      <para>
<!--
       Allows applications to select which security libraries to initialize.
-->
アプリケーションがどのセキュリティライブラリを初期化するか選択することができます。
<synopsis>
void PQinitSSL(int do_ssl);
</synopsis>
      </para>

      <para>
<!--
       This function is equivalent to
       <literal>PQinitOpenSSL(do_ssl, do_ssl)</>.
       It is sufficient for applications that initialize both or neither
       of <application>OpenSSL</> and <literal>libcrypto</>.
-->
この関数は<literal>PQinitOpenSSL(do_ssl, do_ssl)</>と等価です。
<application>OpenSSL</>および<literal>libcrypto</>の両方を初期化する、もしくは両方ともしないアプリケーションにとっては（この関数で）十分です。
      </para>

      <para>
<!--
       <function>PQinitSSL</> has been present since
       <productname>PostgreSQL</> 8.0, while <function>PQinitOpenSSL</>
       was added in <productname>PostgreSQL</> 8.4, so <function>PQinitSSL</>
       might be preferable for applications that need to work with older
       versions of <application>libpq</application>.
-->
<productname>PostgreSQL</> 8.0以降、<function>PQinitSSL</>は含まれていますが、<function>PQinitOpenSSL</>は<productname>PostgreSQL</> 8.4で追加されました。
従って、旧バージョンの<application>libpq</application>で動かす必要があるアプリケーションでは<function>PQinitSSL</>の方が好ましいかもしれません。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </sect2>

 </sect1>


 <sect1 id="libpq-threading">
<!--
  <title>Behavior in Threaded Programs</title>
-->
  <title>スレッド化プログラムの振舞い</title>

  <indexterm zone="libpq-threading">
<!--
   <primary>threads</primary>
   <secondary>with libpq</secondary>
-->
   <primary>スレッド</primary>
   <secondary>libpqにおける</secondary>
  </indexterm>

  <para>
<!--
   <application>libpq</application> is reentrant and thread-safe by default.
   You might need to use special compiler command-line
   options when you compile your application code.  Refer to your
   system's documentation for information about how to build
   thread-enabled applications, or look in
   <filename>src/Makefile.global</filename> for <literal>PTHREAD_CFLAGS</>
   and <literal>PTHREAD_LIBS</>.  This function allows the querying of
   <application>libpq</application>'s thread-safe status:
-->
デフォルトで<application>libpq</application>は再入可能、かつ、スレッドセーフです。
アプリケーションコードをコンパイルする時にコンパイラの特殊なコマンドラインオプションを使う必要があるかもしれません。
スレッドを有効にしたアプリケーションの構築方法についての情報は、使用するシステムの文書を参照してください。
また、<literal>PTHREAD_CFLAGS</>と<literal>PTHREAD_LIBS</>に関して<filename>src/Makefile.global</filename>も一読してください。
以下の関数により、<application>libpq</application>のスレッドセーフ状態を確認することができます。
  </para>

  <variablelist>
   <varlistentry id="libpq-pqisthreadsafe">
    <term>
     <function>PQisthreadsafe</function>
     <indexterm>
      <primary>PQisthreadsafe</primary>
     </indexterm>
    </term>

    <listitem>
     <para>
<!--
      Returns the thread safety status of the
      <application>libpq</application> library.
-->
<application>libpq</application>ライブラリのスレッドセーフ状態を返します。
<synopsis>
int PQisthreadsafe();
</synopsis>
     </para>

     <para>
<!--
      Returns 1 if the <application>libpq</application> is thread-safe
      and 0 if it is not.
-->
<application>libpq</application>がスレッドセーフの場合1が、さもなくば0が返ります。
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

  <para>
<!--
   One thread restriction is that no two threads attempt to manipulate
   the same <structname>PGconn</> object at the same time. In particular,
   you cannot issue concurrent commands from different threads through
   the same connection object. (If you need to run concurrent commands,
   use multiple connections.)
-->
スレッドに関する1つの制限として、異なるスレッドから同時に同一の<structname>PGconn</>オブジェクトを操作することはできません。
具体的には、異なるスレッドから同一接続オブジェクトを介してコマンドを同時に発行することができません。
(コマンドの同時実行が必要な場合、接続を複数使用してください。)
  </para>

  <para>
<!--
   <structname>PGresult</> objects are normally read-only after creation,
   and so can be passed around freely between threads.  However, if you use
   any of the <structname>PGresult</>-modifying functions described in
   <xref linkend="libpq-misc"> or <xref linkend="libpq-events">, it's up
   to you to avoid concurrent operations on the same <structname>PGresult</>,
   too.
-->
<structname>PGresult</>オブジェクトは生成後、読み込み専用であり、そのためスレッド間で自由に渡すことができます。
しかし<xref linkend="libpq-misc">や<xref linkend="libpq-events">で説明する<structname>PGresult</>を変更する関数のいずれかを使用している場合、同一の<structname>PGresult</>に対する同時操作を防ぐことも、作成者の責任です。
  </para>

  <para>
<!--
   The deprecated functions <function>PQrequestCancel</function> and
   <function>PQoidStatus</function> are not thread-safe and should not be
   used in multithread programs.  <function>PQrequestCancel</function>
   can be replaced by <function>PQcancel</function>.
   <function>PQoidStatus</function> can be replaced by
   <function>PQoidValue</function>.
-->
非推奨の関数、<function>PQrequestCancel</function>や<function>PQoidStatus</function>はスレッドセーフではありませんので、マルチスレッドプログラムでは使用してはなりません。
<function>PQrequestCancel</function>は<function>PQcancel</function>に、<function>PQoidStatus</function>は<function>PQoidValue</function>に置き換えることができます。
  </para>

  <para>
<!--
   If you are using Kerberos inside your application (in addition to inside
   <application>libpq</application>), you will need to do locking around
   Kerberos calls because Kerberos functions are not thread-safe.  See
   function <function>PQregisterThreadLock</> in the
   <application>libpq</application> source code for a way to do cooperative
   locking between <application>libpq</application> and your application.
-->
(<application>libpq</application>の内部に加えて)アプリケーション中でKerberosを利用している場合、Kerberos関数はスレッドセーフではありませんのでKerberos呼び出しの前後をロックする必要があるでしょう。
<application>libpq</application>とアプリケーション間のロック処理を協調させる方法として<application>libpq</application>のソースコードの<function>PQregisterThreadLock</>関数を参照してください。
  </para>

  <para>
<!--
   If you experience problems with threaded applications, run the program
   in <filename>src/tools/thread</> to see if your platform has
   thread-unsafe functions.  This program is run by
   <filename>configure</filename>, but for binary distributions your
   library might not match the library used to build the binaries.
-->
スレッドアプリケーションで問題が起きた場合、<filename>src/tools/thread</>内のプログラムを実行して、プラットフォームがスレッドセーフではない関数を持っていないかどうか確認してください。
このプログラムは<filename>configure</filename>より実行されますが、バイナリ配布物の場合は、バイナリ構築時のライブラリとシステムのライブラリが一致しない可能性があります。
  </para>
 </sect1>


 <sect1 id="libpq-build">
<!--
  <title>Building <application>libpq</application> Programs</title>
-->
  <title><application>libpq</application>プログラムの構築</title>

  <indexterm zone="libpq-build">
<!--
   <primary>compiling</primary>
   <secondary>libpq applications</secondary>
-->
   <primary>コンパイル</primary>
   <secondary>libpq アプリケーション</secondary>
  </indexterm>

  <para>
<!--
   To build (i.e., compile and link) a program using
   <application>libpq</application> you need to do all of the following
   things:
-->
<application>libpq</application>を使用するプログラムの構築(つまり、コンパイルとリンク)を行うためには、以下をすべて実施する必要があります。

   <itemizedlist>
    <listitem>
     <para>
<!--
      Include the <filename>libpq-fe.h</filename> header file:
-->
<filename>libpq-fe.h</filename>ヘッダファイルをインクルードします。
<programlisting>
#include &lt;libpq-fe.h&gt;
</programlisting>
<!--
      If you failed to do that then you will normally get error messages
      from your compiler similar to:
-->
これを忘れると、通常コンパイラから以下のようなエラーメッセージが発生します。
<screen>
foo.c: In function `main':
foo.c:34: `PGconn' undeclared (first use in this function)
foo.c:35: `PGresult' undeclared (first use in this function)
foo.c:54: `CONNECTION_BAD' undeclared (first use in this function)
foo.c:68: `PGRES_COMMAND_OK' undeclared (first use in this function)
foo.c:95: `PGRES_TUPLES_OK' undeclared (first use in this function)
</screen>
     </para>
    </listitem>

    <listitem>
     <para>
<!--
      Point your compiler to the directory where the <productname>PostgreSQL</> header
      files were installed, by supplying the
      <literal>-I<replaceable>directory</replaceable></literal> option
      to your compiler.  (In some cases the compiler will look into
      the directory in question by default, so you can omit this
      option.)  For instance, your compile command line could look
      like:
-->
コンパイラに<literal>-I<replaceable>directory</replaceable></literal>オプションを付与することで、コンパイラに<productname>PostgreSQL</>ヘッダファイルをインストールしたディレクトリを通知します。
（デフォルトでこのディレクトリを検索するコンパイラもあります。
その場合はこのオプションを省くことができます。）
例えば、以下のようなコンパイルコマンドになります。
<programlisting>
cc -c -I/usr/local/pgsql/include testprog.c
</programlisting>
<!--
      If you are using makefiles then add the option to the
      <varname>CPPFLAGS</varname> variable:
-->
Makefileを使用しているのであれば、<varname>CPPFLAGS</varname>変数にこのオプションを追加してください。
<programlisting>
CPPFLAGS += -I/usr/local/pgsql/include
</programlisting>
     </para>

     <para>
<!--
      If there is any chance that your program might be compiled by
      other users then you should not hardcode the directory location
      like that.  Instead, you can run the utility
      <command>pg_config</command><indexterm><primary>pg_config</><secondary
      sortas="libpq">with libpq</></> to find out where the header
      files are on the local system:
-->
他のユーザがそのプログラムをコンパイルする可能性がある場合は、上のようにディレクトリの場所を直接書き込むべきではありません。
その代わりに<command>pg_config</command>ユーティリティを実行して、各システムにおけるヘッダファイルの在処を検索させることができます。
<screen>
<prompt>$</prompt> pg_config --includedir
<computeroutput>/usr/local/include</computeroutput>
</screen>
     </para>

     <para>
<!--
      If you
      have <command>pkg-config</command><indexterm><primary>pkg-config</primary><secondary sortas="libpq">with
      libpq</secondary></indexterm> installed, you can run instead:
-->
もしも、<command>pkg-config</command>がインストールされている場合、代わりとして以下を実行します。<indexterm><primary>pkg-config</primary><secondary sortas="libpq">libpqにおける</secondary></indexterm>
<screen>
<prompt>$</prompt> pkg-config --cflags libpq
<computeroutput>-I/usr/local/include</computeroutput>
</screen>
<!--
      Note that this will already include the <option>-I</option> in front of
      the path.
-->
これは既にパスの最前部で<option>-I</option>が含まれていることに注意してください。
     </para>

     <para>
<!--
      Failure to specify the correct option to the compiler will
      result in an error message such as:
-->
正確なオプションを指定できなかった結果、コンパイラは以下のようなエラーメッセージを生成します。
<screen>
testlibpq.c:8:22: libpq-fe.h: No such file or directory
</screen>
     </para>
    </listitem>

    <listitem>
     <para>
<!--
      When linking the final program, specify the option
      <literal>-lpq</literal> so that the <application>libpq</application>
      library gets pulled in, as well as the option
      <literal>-L<replaceable>directory</replaceable></literal> to point
      the compiler to the directory where the
      <application>libpq</application> library resides.  (Again, the
      compiler will search some directories by default.)  For maximum
      portability, put the <option>-L</option> option before the
      <option>-lpq</option> option.  For example:
-->
最終的なプログラムのリンク時、<literal>-lpq</literal>オプションを指定して、<application>libpq</application>ライブラリを組み込んでください。
同時に<literal>-L<replaceable>directory</replaceable></literal>オプションを指定して、コンパイラに<application>libpq</application>ライブラリの在処を通知してください。
（繰り返しますが、コンパイラはデフォルトでいくつかのディレクトリを検索します。）
移植性を最大にするために、<option>-lpq</option>オプションの前に<option>-L</option>を記述してください。
以下に例を示します。
<programlisting>
cc -o testprog testprog1.o testprog2.o -L/usr/local/pgsql/lib -lpq
</programlisting>
     </para>

     <para>
<!--
      You can find out the library directory using
      <command>pg_config</command> as well:
-->
同様に<command>pg_config</command>を使用してライブラリのあるディレクトリを見つけることもできます。
<screen>
<prompt>$</prompt> pg_config --libdir
<computeroutput>/usr/local/pgsql/lib</computeroutput>
</screen>
     </para>

     <para>
<!--
      Or again use <command>pkg-config</command>:
-->
さもなくば、この場合もやはり<command>pkg-config</command>を使用します。
<screen>
<prompt>$</prompt> pkg-config --libs libpq
<computeroutput>-L/usr/local/pgsql/lib -lpq</computeroutput>
</screen>
<!--
      Note again that this prints the full options, not only the path.
-->
重ねて、これはパスのみならず全てのオプションを表示することに注意してください。
     </para>

     <para>
<!--
      Error messages that point to problems in this area could look like
      the following:
-->
この部分で問題があった場合のエラーメッセージは以下のようなものになります。
<screen>
testlibpq.o: In function `main':
testlibpq.o(.text+0x60): undefined reference to `PQsetdbLogin'
testlibpq.o(.text+0x71): undefined reference to `PQstatus'
testlibpq.o(.text+0xa4): undefined reference to `PQerrorMessage'
</screen>
<!--
      This means you forgot <option>-lpq</option>.
-->
これは<option>-lpq</option>の付け忘れを示します。
<screen>
/usr/bin/ld: cannot find -lpq
</screen>
<!--
      This means you forgot the <option>-L</option> option or did not
      specify the right directory.
-->
これは<option>-L</option>の付け忘れ、あるいは、ディレクトリ指定の間違いを示します。
     </para>
    </listitem>
   </itemizedlist>
  </para>

 </sect1>


 <sect1 id="libpq-example">
<!--
  <title>Example Programs</title>
-->
  <title>サンプルプログラム</title>

  <para>
<!--
   These examples and others can be found in the
   directory <filename>src/test/examples</filename> in the source code
   distribution.
-->
以下を含むサンプルプログラムが、ソースコード配布物内の<filename>src/test/examples</filename>ディレクトリにあります。
  </para>

  <example id="libpq-example-1">
<!--
   <title><application>libpq</application> Example Program 1</title>
-->
   <title><application>libpq</application> サンプルプログラム 1</title>

<programlisting>
<![CDATA[
/*
 * testlibpq.c
 *
]]><!--
 *      Test the C version of libpq, the PostgreSQL frontend library.
--><![CDATA[
 *              C言語PostgreSQLフロントエンドライブラリlibpqの試験
 */
#include <stdio.h>
#include <stdlib.h>
#include <libpq-fe.h>

static void
exit_nicely(PGconn *conn)
{
    PQfinish(conn);
    exit(1);
}

int
main(int argc, char **argv)
{
    const char *conninfo;
    PGconn     *conn;
    PGresult   *res;
    int         nFields;
    int         i,
                j;

    /*
]]><!--
     * If the user supplies a parameter on the command line, use it as the
     * conninfo string; otherwise default to setting dbname=postgres and using
     * environment variables or defaults for all other connection parameters.
--><![CDATA[
     * ユーザがコマンドラインでパラメータを提供した場合、conninfo文字列として使用する。
     * 提供されない場合はデフォルトでdbname=postgresを使用する。
     * その他の接続パラメータについては環境変数やデフォルトを使用する。
     * 
     */
    if (argc > 1)
        conninfo = argv[1];
    else
        conninfo = "dbname = postgres";

]]><!--
    /* Make a connection to the database */
--><![CDATA[
    /* データベースとの接続を確立する */
    conn = PQconnectdb(conninfo);

]]><!--
    /* Check to see that the backend connection was successfully made */
--><![CDATA[
    /* バックエンドとの接続確立に成功したかを確認する */
    if (PQstatus(conn) != CONNECTION_OK)
    {
        fprintf(stderr, "Connection to database failed: %s",
                PQerrorMessage(conn));
        exit_nicely(conn);
    }

    /*
]]><!--
     * Our test case here involves using a cursor, for which we must be inside
     * a transaction block.  We could do the whole thing with a single
     * PQexec() of "select * from pg_database", but that's too trivial to make
     * a good example.
--><![CDATA[
     * この試験ケースではカーソルを使用する。
     * そのため、トランザクションブロック内で実行する必要がある。
     * すべてを単一の"select * from pg_database"というPQexec()で行うこと
     * も可能だが、例としては簡単過ぎる。
     */

]]><!--
    /* Start a transaction block */
--><![CDATA[
    /* トランザクションブロックを開始する。 */
    res = PQexec(conn, "BEGIN");
    if (PQresultStatus(res) != PGRES_COMMAND_OK)
    {
        fprintf(stderr, "BEGIN command failed: %s", PQerrorMessage(conn));
        PQclear(res);
        exit_nicely(conn);
    }

    /*
]]><!--
     * Should PQclear PGresult whenever it is no longer needed to avoid memory
     * leaks
--><![CDATA[
     * 不要になったら、メモリリークを防ぐためにPGresultをPQclearすべき。
     */
    PQclear(res);

    /*
]]><!--
     * Fetch rows from pg_database, the system catalog of databases
--><![CDATA[
     * データベースのシステムカタログpg_databaseから行を取り出す。
     */
    res = PQexec(conn, "DECLARE myportal CURSOR FOR select * from pg_database");
    if (PQresultStatus(res) != PGRES_COMMAND_OK)
    {
        fprintf(stderr, "DECLARE CURSOR failed: %s", PQerrorMessage(conn));
        PQclear(res);
        exit_nicely(conn);
    }
    PQclear(res);

    res = PQexec(conn, "FETCH ALL in myportal");
    if (PQresultStatus(res) != PGRES_TUPLES_OK)
    {
        fprintf(stderr, "FETCH ALL failed: %s", PQerrorMessage(conn));
        PQclear(res);
        exit_nicely(conn);
    }

]]><!--
    /* first, print out the attribute names */
--><![CDATA[
    /* まず属性名を表示する。 */
    nFields = PQnfields(res);
    for (i = 0; i < nFields; i++)
        printf("%-15s", PQfname(res, i));
    printf("\n\n");

]]><!--
    /* next, print out the rows */
--><![CDATA[
    /* そして行を表示する。 */
    for (i = 0; i < PQntuples(res); i++)
    {
        for (j = 0; j < nFields; j++)
            printf("%-15s", PQgetvalue(res, i, j));
        printf("\n");
    }

    PQclear(res);

]]><!--
    /* close the portal ... we don't bother to check for errors ... */
--><![CDATA[
    /* ポータルを閉ざす。ここではエラーチェックは省略した… */
    res = PQexec(conn, "CLOSE myportal");
    PQclear(res);

]]><!--
    /* end the transaction */
--><![CDATA[
    /* トランザクションを終了する */
    res = PQexec(conn, "END");
    PQclear(res);

]]><!--
    /* close the connection to the database and cleanup */
--><![CDATA[
    /* データベースとの接続を閉じ、後始末を行う。 */
    PQfinish(conn);

    return 0;
}
]]>
</programlisting>
  </example>

  <example id="libpq-example-2">
<!--
   <title><application>libpq</application> Example Program 2</title>
-->
   <title><application>libpq</application> サンプルプログラム 2</title>

<programlisting>
<![CDATA[
/*
 * testlibpq2.c
]]><!--
 *      Test of the asynchronous notification interface
--><![CDATA[
 *              非同期通知インタフェースの試験
 *
]]><!--
 * Start this program, then from psql in another window do
 *   NOTIFY TBL2;
 * Repeat four times to get this program to exit.
--><![CDATA[
 * このプログラムを起動し、別ウィンドウからpsqlを使用して以下を実行してください。
 *   NOTIFY TBL2;
 * 4回繰り返すとこのプログラムは終了します。
 *
]]><!--
 * Or, if you want to get fancy, try this:
 * populate a database with the following commands
 * (provided in src/test/examples/testlibpq2.sql):
--><![CDATA[
 * もう少し凝りたければ、以下を実施してください。
 * 以下のコマンド(src/test/examples/testlibpq2.sqlで提供)でデータベースを作成します。
 *
 *   CREATE TABLE TBL1 (i int4);
 *
 *   CREATE TABLE TBL2 (i int4);
 *
 *   CREATE RULE r1 AS ON INSERT TO TBL1 DO
 *     (INSERT INTO TBL2 VALUES (new.i); NOTIFY TBL2);
 *
]]><!--
 * and do this four times:
--><![CDATA[
 * そして、以下を4回実行してください。
 *
 *   INSERT INTO TBL1 VALUES (10);
 */

#ifdef WIN32
#include <windows.h>
#endif
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <sys/time.h>
#include <sys/types.h>
#include "libpq-fe.h"

static void
exit_nicely(PGconn *conn)
{
    PQfinish(conn);
    exit(1);
}

int
main(int argc, char **argv)
{
    const char *conninfo;
    PGconn     *conn;
    PGresult   *res;
    PGnotify   *notify;
    int         nnotifies;

    /*
]]><!--
     * If the user supplies a parameter on the command line, use it as the
     * conninfo string; otherwise default to setting dbname=postgres and using
     * environment variables or defaults for all other connection parameters.
--><![CDATA[
     * ユーザがコマンドラインでパラメータを提供した場合、conninfo文字列として使用する。
     * 提供されない場合はデフォルトでdbname=postgresを使用する。
     * その他の接続パラメータについては環境変数やデフォルトを使用する。
     */
    if (argc > 1)
        conninfo = argv[1];
    else
        conninfo = "dbname = postgres";

]]><!--
    /* Make a connection to the database */
--><![CDATA[
    /* データベースとの接続を確立する。 */
    conn = PQconnectdb(conninfo);

]]><!--
    /* Check to see that the backend connection was successfully made */
--><![CDATA[
    /* バックエンドとの接続確立に成功したかを確認する */
    if (PQstatus(conn) != CONNECTION_OK)
    {
        fprintf(stderr, "Connection to database failed: %s",
                PQerrorMessage(conn));
        exit_nicely(conn);
    }

    /*
]]><!--
     * Issue LISTEN command to enable notifications from the rule's NOTIFY.
--><![CDATA[
     * LISTENコマンドを発行して、INSERTルールによる通知を有効にする。
     */
    res = PQexec(conn, "LISTEN TBL2");
    if (PQresultStatus(res) != PGRES_COMMAND_OK)
    {
        fprintf(stderr, "LISTEN command failed: %s", PQerrorMessage(conn));
        PQclear(res);
        exit_nicely(conn);
    }

    /*
]]><!--
     * should PQclear PGresult whenever it is no longer needed to avoid memory
     * leaks
--><![CDATA[
     * 不要になったら、メモリリークを防ぐためにPGresultをPQclearすべき。
     */
    PQclear(res);

]]><!--
    /* Quit after four notifies are received. */
--><![CDATA[
    /* 4回通知を受けたら終了する。 */
    nnotifies = 0;
    while (nnotifies < 4)
    {
        /*
]]><!--
         * Sleep until something happens on the connection.  We use select(2)
         * to wait for input, but you could also use poll() or similar
         * facilities.
--><![CDATA[
         * その接続で何かが起こるまで待機する。ここでは入力待ちのために
         * select(2)を使用する。poll()や類似機能を使用することも可能
         * である。
         */
        int         sock;
        fd_set      input_mask;

        sock = PQsocket(conn);

        if (sock < 0)
]]><!--
            break;              /* shouldn't happen */
--><![CDATA[
            break;              /* 発生してはならない。 */

        FD_ZERO(&input_mask);
        FD_SET(sock, &input_mask);

        if (select(sock + 1, &input_mask, NULL, NULL, NULL) < 0)
        {
            fprintf(stderr, "select() failed: %s\n", strerror(errno));
            exit_nicely(conn);
        }

]]><!--
        /* Now check for input */
--><![CDATA[
        /* ここで入力を確認する。 */
        PQconsumeInput(conn);
        while ((notify = PQnotifies(conn)) != NULL)
        {
            fprintf(stderr,
                    "ASYNC NOTIFY of '%s' received from backend PID %d\n",
                    notify->relname, notify->be_pid);
            PQfreemem(notify);
            nnotifies++;
        }
    }

    fprintf(stderr, "Done.\n");

]]><!--
    /* close the connection to the database and cleanup */
--><![CDATA[
    /* データベースとの接続を閉じ、後始末を行う。 */
    PQfinish(conn);

    return 0;
}
]]>
</programlisting>
  </example>

  <example id="libpq-example-3">
<!--
   <title><application>libpq</application> Example Program 3</title>
-->
   <title><application>libpq</application> サンプルプログラム 3</title>

<programlisting>
<![CDATA[
/*
 * testlibpq3.c
]]><!--
 *      Test out-of-line parameters and binary I/O.
--><![CDATA[
 *      行以外のパラメータとバイナリI/Oの試験。
 *
]]><!--
 * Before running this, populate a database with the following commands
 * (provided in src/test/examples/testlibpq3.sql):
--><![CDATA[
 * 実行前に、以下のコマンド(src/test/examples/testlibpq3.sqlで提供)を使用して
 * データベースを作成してください。
 *
 * CREATE TABLE test1 (i int4, t text, b bytea);
 *
 * INSERT INTO test1 values (1, 'joe''s place', '\\000\\001\\002\\003\\004');
 * INSERT INTO test1 values (2, 'ho there', '\\004\\003\\002\\001\\000');
 *
]]><!--
 * The expected output is:
--><![CDATA[
 * 以下の出力が想定されます。
 *
 * tuple 0: got
 *  i = (4 bytes) 1
 *  t = (11 bytes) 'joe's place'
 *  b = (5 bytes) \000\001\002\003\004
 *
 * tuple 0: got
 *  i = (4 bytes) 2
 *  t = (8 bytes) 'ho there'
 *  b = (5 bytes) \004\003\002\001\000
 */

#ifdef WIN32
#include <windows.h>
#endif

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <sys/types.h>
#include "libpq-fe.h"

]]><!--
/* for ntohl/htonl */
--><![CDATA[
/* ntohl/htonl用 */
#include <netinet/in.h>
#include <arpa/inet.h>


static void
exit_nicely(PGconn *conn)
{
    PQfinish(conn);
    exit(1);
}

/*
]]><!--
 * This function prints a query result that is a binary-format fetch from
 * a table defined as in the comment above.  We split it out because the
 * main() function uses it twice.
--><![CDATA[
 * この関数は上のコメントで定義したテーブルからバイナリフォーマットでフェッチした
 * クエリ結果を表示します。
 * main() 関数が2度使うので、結果を分割します。
 */
static void
show_binary_results(PGresult *res)
{
    int         i,
                j;
    int         i_fnum,
                t_fnum,
                b_fnum;

]]><!--
    /* Use PQfnumber to avoid assumptions about field order in result */
--><![CDATA[
    /* 結果中の列オーダーの仮定を嫌うので PQfnumber を利用する */
    /* PQfnumber  */
    i_fnum = PQfnumber(res, "i");
    t_fnum = PQfnumber(res, "t");
    b_fnum = PQfnumber(res, "b");

    for (i = 0; i < PQntuples(res); i++)
    {
        char       *iptr;
        char       *tptr;
        char       *bptr;
        int         blen;
        int         ival;

]]><!--
        /* Get the field values (we ignore possibility they are null!) */
--><![CDATA[
        /* 列の値を取得(NULLを出来る限り無視) */
        iptr = PQgetvalue(res, i, i_fnum);
        tptr = PQgetvalue(res, i, t_fnum);
        bptr = PQgetvalue(res, i, b_fnum);

        /*
]]><!--
         * The binary representation of INT4 is in network byte order, which
         * we'd better coerce to the local byte order.
--><![CDATA[
         * INT4のバイナリ表現はネットワークバイトオーダーによる。
         * よって、ローカルバイトオーダーに合わせた方が良い。
         */
        ival = ntohl(*((uint32_t *) iptr));

        /*
]]><!--
         * The binary representation of TEXT is, well, text, and since libpq
         * was nice enough to append a zero byte to it, it'll work just fine
         * as a C string.
--><![CDATA[
         * TEXT型のバイナリ表現も同様にテキスト。
         * 更にlibpqはその最後にゼロバイトを付与するので、
         * C言語の文字列として単純に扱うことができる。
         *
]]><!--
         * The binary representation of BYTEA is a bunch of bytes, which could
         * include embedded nulls so we have to pay attention to field length.
--><![CDATA[
         * BYTEA のバイト表現はバイトの集まりである。 
         * null 埋め込みを含むのでフィールド長に注意を払わなければいけない。
         */
        blen = PQgetlength(res, i, b_fnum);

        printf("tuple %d: got\n", i);
        printf(" i = (%d bytes) %d\n",
               PQgetlength(res, i, i_fnum), ival);
        printf(" t = (%d bytes) '%s'\n",
               PQgetlength(res, i, t_fnum), tptr);
        printf(" b = (%d bytes) ", blen);
        for (j = 0; j < blen; j++)
            printf("\\%03o", bptr[j]);
        printf("\n\n");
    }
}

int
main(int argc, char **argv)
{
    const char *conninfo;
    PGconn     *conn;
    PGresult   *res;
    const char *paramValues[1];
    int         paramLengths[1];
    int         paramFormats[1];
    uint32_t    binaryIntVal;

    /*
]]><!--
     * If the user supplies a parameter on the command line, use it as the
     * conninfo string; otherwise default to setting dbname=postgres and using
     * environment variables or defaults for all other connection parameters.
--><![CDATA[
     * ユーザがコマンドラインでパラメータを提供した場合、conninfo文字列として使用する。
     * 提供されない場合はデフォルトでdbname=postgresを使用する。
     * その他の接続パラメータについては環境変数やデフォルトを使用する。
     */
    if (argc > 1)
        conninfo = argv[1];
    else
        conninfo = "dbname = postgres";

]]><!--
    /* Make a connection to the database */
--><![CDATA[
    /* データベースとの接続を確立する */
    conn = PQconnectdb(conninfo);

]]><!--
    /* Check to see that the backend connection was successfully made */
--><![CDATA[
    /* バックエンドとの接続確立に成功したかを確認する */
    if (PQstatus(conn) != CONNECTION_OK)
    {
        fprintf(stderr, "Connection to database failed: %s",
                PQerrorMessage(conn));
        exit_nicely(conn);
    }

    /*
]]><!--
     * The point of this program is to illustrate use of PQexecParams() with
     * out-of-line parameters, as well as binary transmission of data.
--><![CDATA[
     * このプログラムのポイントは、行外パラメータを持つPQexecParams()の使用方法、
     * および、データのバイナリ転送を示すことである。
     *
]]><!--
     * This first example transmits the parameters as text, but receives the
     * results in binary format.  By using out-of-line parameters we can avoid
     * a lot of tedious mucking about with quoting and escaping, even though
     * the data is text.  Notice how we don't have to do anything special with
     * the quote mark in the parameter value.
--><![CDATA[
     * この最初の例はパラメータをテキストとして渡す。
     * しかし結果はバイナリフォーマットで受ける。
     * 行外パラメータを使うことで、データがテキストであっても引用符付けや
     * エスケープ処理といった多くの長たらしいゴミをなくすことができる。
     * パラメータ値内部の引用符に対して特殊な処理を行う必要がないことに注目して
     * ほしい。
     */

]]><!--
    /* Here is our out-of-line parameter value */
--><![CDATA[
    /* 以下が行外パラメータの値である。 */
    paramValues[0] = "joe's place";

    res = PQexecParams(conn,
                       "SELECT * FROM test1 WHERE t = $1",
]]><!--
                       1,       /* one param */
                       NULL,    /* let the backend deduce param type */
                       paramValues,
                       NULL,    /* don't need param lengths since text */
                       NULL,    /* default to all text params */
                       1);      /* ask for binary results */
--><![CDATA[
                       1,           /* パラメータは1つ。 */
                       NULL,        /* バックエンドにパラメータの型を推測させる。 */
                       paramValues,
                       NULL,        /* テキストのため、パラメータ長は不要。 */
                       NULL,        /* デフォルトですべてのパラメータはテキスト。 */
                       1);          /* バイナリ結果を要求。 */

    if (PQresultStatus(res) != PGRES_TUPLES_OK)
    {
        fprintf(stderr, "SELECT failed: %s", PQerrorMessage(conn));
        PQclear(res);
        exit_nicely(conn);
    }

    show_binary_results(res);

    PQclear(res);

    /*
]]><!--
     * In this second example we transmit an integer parameter in binary form,
     * and again retrieve the results in binary form.
--><![CDATA[
     * 2つ目の例は、バイナリフォームの中で整数値パラメータを渡す。
     * そして再びバイナリフォームで結果を受け取る。
     *
]]><!--
     * Although we tell PQexecParams we are letting the backend deduce
     * parameter type, we really force the decision by casting the parameter
     * symbol in the query text.  This is a good safety measure when sending
     * binary parameters.
--><![CDATA[
     * バックエンドにパラメータタイプを推測させていると PQexecParams に伝えるが、
     * クエリテキストの中にパラメータシンボルを入れることによって 強制的に決定する。
     * これはバイナリパラメータに送るときに安全で良い大きさである。
     */

]]><!--
    /* Convert integer value "2" to network byte order */
--><![CDATA[
    /* 整数値 "2" をネットワークバイトオーダーに変換 */ 
    binaryIntVal = htonl((uint32_t) 2);

]]><!--
    /* Set up parameter arrays for PQexecParams */
--><![CDATA[
    /* PQexecParams 用にパラメータ配列をセットする */
    paramValues[0] = (char *) &binaryIntVal;
    paramLengths[0] = sizeof(binaryIntVal);
]]><!--
    paramFormats[0] = 1;        /* binary */
--><![CDATA[
    paramFormats[0] = 1;        /* バイナリ */

    res = PQexecParams(conn,
                       "SELECT * FROM test1 WHERE i = $1::int4",
]]><!--
                       1,       /* one param */
                       NULL,    /* let the backend deduce param type */
--><![CDATA[
                       1,       /* パラメータは1つ */
                       NULL,    /* バックエンドにパラメータの型を推測させる。 */
                       paramValues,
                       paramLengths,
                       paramFormats,
]]><!--
                       1);      /* ask for binary results */
--><![CDATA[
                       1);      /* バイナリ結果を要求。 */

    if (PQresultStatus(res) != PGRES_TUPLES_OK)
    {
        fprintf(stderr, "SELECT failed: %s", PQerrorMessage(conn));
        PQclear(res);
        exit_nicely(conn);
    }

    show_binary_results(res);

    PQclear(res);

]]><!--
    /* close the connection to the database and cleanup */
--><![CDATA[
    /* データベースとの接続を閉じ、後始末を行う。 */
    PQfinish(conn);

    return 0;
}
]]>
</programlisting>
  </example>

 </sect1>
</chapter>
