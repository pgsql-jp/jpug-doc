<!-- doc/src/sgml/gin.sgml -->

<chapter id="GIN">
<!--
<title>GIN Indexes</title>
-->
<title>GINインデックス</title>

   <indexterm>
<!--
    <primary>index</primary>
-->
    <primary>インデックス</primary>
    <secondary>GIN</secondary>
   </indexterm>

<sect1 id="gin-intro">
<!--
 <title>Introduction</title>
-->
 <title>はじめに</title>

 <para>
<!--
  <acronym>GIN</acronym> stands for Generalized Inverted Index.
  <acronym>GIN</acronym> is designed for handling cases where the items
  to be indexed are composite values, and the queries to be handled by
  the index need to search for element values that appear within
  the composite items.  For example, the items could be documents,
  and the queries could be searches for documents containing specific words.
-->
<acronym>GIN</acronym>とは汎用転置インデックス(Generalized Inverted Index)を表します。
<acronym>GIN</acronym>は、インデックス対象の項目が複合型であり、インデックスにより取り扱われる問い合わせが複合型の項目内に存在する要素値に対して検索する必要がある場合を取り扱うために設計されました。
例えば、項目が文書であり、問い合わせが特定の単語を含む文書を検索することがあり得ます。
 </para>

 <para>
<!--
  We use the word <firstterm>item</> to refer to a composite value that
  is to be indexed, and the word <firstterm>key</> to refer to an element
  value.  <acronym>GIN</acronym> always stores and searches for keys,
  not item values per se.
-->
ここでインデックス対象の複合型の値を参照するために<firstterm>項目</>という単語を使用します。
また、<firstterm>キー</>という単語を要素値を参照するために使用します。
<acronym>GIN</acronym>は本質的に、項目の値ではなく、常にキーを格納し検索します。
 </para>

 <para>
<!--
  A <acronym>GIN</acronym> index stores a set of (key, posting list) pairs,
  where a <firstterm>posting list</> is a set of row IDs in which the key
  occurs.  The same row ID can appear in multiple posting lists, since
  an item can contain more than one key.  Each key value is stored only
  once, so a <acronym>GIN</acronym> index is very compact for cases
  where the same key appears many times.
-->
<acronym>GIN</acronym>インデックスは(キー、投稿されたリスト)の組み合わせの集合を格納します。
ここで<quote>投稿されたリスト</>はキーに合う行IDの集合です。
項目は１つ以上のキーを含むことができますので、同じ行IDが複数の投稿されたリストに現れることがあり得ます。
キー値はそれぞれ一度のみ格納されます。
このため<acronym>GIN</acronym>インデックスの容量は、同じキーが何度も現れる場合に非常に小さくなります。
 </para>

 <para>
<!--
  <acronym>GIN</acronym> is generalized in the sense that the
  <acronym>GIN</acronym> access method code does not need to know the
  specific operations that it accelerates.
  Instead, it uses custom strategies defined for particular data types.
  The strategy defines how keys are extracted from indexed items and
  query conditions, and how to determine whether a row that contains
  some of the key values in a query actually satisfies the query.
-->
<acronym>GIN</acronym>インデックスは、<acronym>GIN</acronym>アクセスメソッドが高速化対象の操作を把握する必要がないという意味で汎用化されています。
その代わり、特定のデータ型に対して定義された独自の戦略を使用します。
戦略は、インデックス付けされた項目と問い合わせ条件からキーを抽出する方法および問い合わせ内のいくつかのキー値を含む行が実際に問い合わせを満たすかどうかを決定する方法を定義します。
 </para>

 <para>
<!--
  One advantage of <acronym>GIN</acronym> is that it allows the development
  of custom data types with the appropriate access methods, by
  an expert in the domain of the data type, rather than a database expert.
  This is much the same advantage as using <acronym>GiST</acronym>.
-->
<acronym>GIN</acronym>の利点の1つは、データベース専門家ではなくデータ型の分野における専門家により、適切なアクセスメソッドを持つ独自のデータ型を開発できるという点です。
これは<acronym>GiST</acronym>の使用とほぼ同じ利点です。
 </para>

 <para>
<!--
  The <acronym>GIN</acronym>
  implementation in <productname>PostgreSQL</productname> is primarily
  maintained by Teodor Sigaev and Oleg Bartunov. There is more
  information about <acronym>GIN</acronym> on their
  <ulink url="http://www.sai.msu.su/~megera/wiki/Gin">website</ulink>.
-->
<productname>PostgreSQL</productname>における<acronym>GIN</acronym>の実装は、主にTeodor SigaevとOleg Bartunovにより保守されています。
<acronym>GIN</acronym>に関する情報は彼らの<ulink url="http://www.sai.msu.su/~megera/wiki/Gin">webサイト</ulink>により多く記載されています。
 </para>
</sect1>

<sect1 id="gin-builtin-opclasses">
<!--
 <title>Built-in Operator Classes</title>
-->
 <title>組込み演算子クラス</title>

 <para>
<!--
  The core <productname>PostgreSQL</> distribution
  includes the <acronym>GIN</acronym> operator classes shown in
  <xref linkend="gin-builtin-opclasses-table">.
  (Some of the optional modules described in <xref linkend="contrib">
  provide additional <acronym>GIN</acronym> operator classes.)
-->
<productname>PostgreSQL</>のコア配布物は<xref linkend="gin-builtin-opclasses-table">に示す<acronym>GIN</acronym>演算子クラスを含みます。
(<xref linkend="contrib">に記載された追加モジュールの中には追加の<acronym>GIN</acronym>演算子クラスを提供するものもあります。)
 </para>

  <table id="gin-builtin-opclasses-table">
<!--
   <title>Built-in <acronym>GIN</acronym> Operator Classes</title>
-->
   <title>組込み<acronym>GIN</acronym>演算子クラス</title>
   <tgroup cols="3">
    <thead>
     <row>
<!--
      <entry>Name</entry>
      <entry>Indexed Data Type</entry>
      <entry>Indexable Operators</entry>
-->
      <entry>名前</entry>
      <entry>インデックス付けするデータ型</entry>
      <entry>インデックス可能演算子</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><literal>_abstime_ops</></entry>
      <entry><type>abstime[]</></entry>
      <entry>
       <literal>&amp;&amp;</>
       <literal>&lt;@</>
       <literal>=</>
       <literal>@&gt;</>
      </entry>
     </row>
     <row>
      <entry><literal>_bit_ops</></entry>
      <entry><type>bit[]</></entry>
      <entry>
       <literal>&amp;&amp;</>
       <literal>&lt;@</>
       <literal>=</>
       <literal>@&gt;</>
      </entry>
     </row>
     <row>
      <entry><literal>_bool_ops</></entry>
      <entry><type>boolean[]</></entry>
      <entry>
       <literal>&amp;&amp;</>
       <literal>&lt;@</>
       <literal>=</>
       <literal>@&gt;</>
      </entry>
     </row>
     <row>
      <entry><literal>_bpchar_ops</></entry>
      <entry><type>character[]</></entry>
      <entry>
       <literal>&amp;&amp;</>
       <literal>&lt;@</>
       <literal>=</>
       <literal>@&gt;</>
      </entry>
     </row>
     <row>
      <entry><literal>_bytea_ops</></entry>
      <entry><type>bytea[]</></entry>
      <entry>
       <literal>&amp;&amp;</>
       <literal>&lt;@</>
       <literal>=</>
       <literal>@&gt;</>
      </entry>
     </row>
     <row>
      <entry><literal>_char_ops</></entry>
      <entry><type>"char"[]</></entry>
      <entry>
       <literal>&amp;&amp;</>
       <literal>&lt;@</>
       <literal>=</>
       <literal>@&gt;</>
      </entry>
     </row>
     <row>
      <entry><literal>_cidr_ops</></entry>
      <entry><type>cidr[]</></entry>
      <entry>
       <literal>&amp;&amp;</>
       <literal>&lt;@</>
       <literal>=</>
       <literal>@&gt;</>
      </entry>
     </row>
     <row>
      <entry><literal>_date_ops</></entry>
      <entry><type>date[]</></entry>
      <entry>
       <literal>&amp;&amp;</>
       <literal>&lt;@</>
       <literal>=</>
       <literal>@&gt;</>
      </entry>
     </row>
     <row>
      <entry><literal>_float4_ops</></entry>
      <entry><type>float4[]</></entry>
      <entry>
       <literal>&amp;&amp;</>
       <literal>&lt;@</>
       <literal>=</>
       <literal>@&gt;</>
      </entry>
     </row>
     <row>
      <entry><literal>_float8_ops</></entry>
      <entry><type>float8[]</></entry>
      <entry>
       <literal>&amp;&amp;</>
       <literal>&lt;@</>
       <literal>=</>
       <literal>@&gt;</>
      </entry>
     </row>
     <row>
      <entry><literal>_inet_ops</></entry>
      <entry><type>inet[]</></entry>
      <entry>
       <literal>&amp;&amp;</>
       <literal>&lt;@</>
       <literal>=</>
       <literal>@&gt;</>
      </entry>
     </row>
     <row>
      <entry><literal>_int2_ops</></entry>
      <entry><type>smallint[]</></entry>
      <entry>
       <literal>&amp;&amp;</>
       <literal>&lt;@</>
       <literal>=</>
       <literal>@&gt;</>
      </entry>
     </row>
     <row>
      <entry><literal>_int4_ops</></entry>
      <entry><type>integer[]</></entry>
      <entry>
       <literal>&amp;&amp;</>
       <literal>&lt;@</>
       <literal>=</>
       <literal>@&gt;</>
      </entry>
     </row>
     <row>
      <entry><literal>_int8_ops</></entry>
      <entry><type>bigint[]</></entry>
      <entry>
       <literal>&amp;&amp;</>
       <literal>&lt;@</>
       <literal>=</>
       <literal>@&gt;</>
      </entry>
     </row>
     <row>
      <entry><literal>_interval_ops</></entry>
      <entry><type>interval[]</></entry>
      <entry>
       <literal>&amp;&amp;</>
       <literal>&lt;@</>
       <literal>=</>
       <literal>@&gt;</>
      </entry>
     </row>
     <row>
      <entry><literal>_macaddr_ops</></entry>
      <entry><type>macaddr[]</></entry>
      <entry>
       <literal>&amp;&amp;</>
       <literal>&lt;@</>
       <literal>=</>
       <literal>@&gt;</>
      </entry>
     </row>
     <row>
      <entry><literal>_money_ops</></entry>
      <entry><type>money[]</></entry>
      <entry>
       <literal>&amp;&amp;</>
       <literal>&lt;@</>
       <literal>=</>
       <literal>@&gt;</>
      </entry>
     </row>
     <row>
      <entry><literal>_name_ops</></entry>
      <entry><type>name[]</></entry>
      <entry>
       <literal>&amp;&amp;</>
       <literal>&lt;@</>
       <literal>=</>
       <literal>@&gt;</>
      </entry>
     </row>
     <row>
      <entry><literal>_numeric_ops</></entry>
      <entry><type>numeric[]</></entry>
      <entry>
       <literal>&amp;&amp;</>
       <literal>&lt;@</>
       <literal>=</>
       <literal>@&gt;</>
      </entry>
     </row>
     <row>
      <entry><literal>_oid_ops</></entry>
      <entry><type>oid[]</></entry>
      <entry>
       <literal>&amp;&amp;</>
       <literal>&lt;@</>
       <literal>=</>
       <literal>@&gt;</>
      </entry>
     </row>
     <row>
      <entry><literal>_oidvector_ops</></entry>
      <entry><type>oidvector[]</></entry>
      <entry>
       <literal>&amp;&amp;</>
       <literal>&lt;@</>
       <literal>=</>
       <literal>@&gt;</>
      </entry>
     </row>
     <row>
      <entry><literal>_reltime_ops</></entry>
      <entry><type>reltime[]</></entry>
      <entry>
       <literal>&amp;&amp;</>
       <literal>&lt;@</>
       <literal>=</>
       <literal>@&gt;</>
      </entry>
     </row>
     <row>
      <entry><literal>_text_ops</></entry>
      <entry><type>text[]</></entry>
      <entry>
       <literal>&amp;&amp;</>
       <literal>&lt;@</>
       <literal>=</>
       <literal>@&gt;</>
      </entry>
     </row>
     <row>
      <entry><literal>_time_ops</></entry>
      <entry><type>time[]</></entry>
      <entry>
       <literal>&amp;&amp;</>
       <literal>&lt;@</>
       <literal>=</>
       <literal>@&gt;</>
      </entry>
     </row>
     <row>
      <entry><literal>_timestamp_ops</></entry>
      <entry><type>timestamp[]</></entry>
      <entry>
       <literal>&amp;&amp;</>
       <literal>&lt;@</>
       <literal>=</>
       <literal>@&gt;</>
      </entry>
     </row>
     <row>
      <entry><literal>_timestamptz_ops</></entry>
      <entry><type>timestamp with time zone[]</></entry>
      <entry>
       <literal>&amp;&amp;</>
       <literal>&lt;@</>
       <literal>=</>
       <literal>@&gt;</>
      </entry>
     </row>
     <row>
      <entry><literal>_timetz_ops</></entry>
      <entry><type>time with time zone[]</></entry>
      <entry>
       <literal>&amp;&amp;</>
       <literal>&lt;@</>
       <literal>=</>
       <literal>@&gt;</>
      </entry>
     </row>
     <row>
      <entry><literal>_tinterval_ops</></entry>
      <entry><type>tinterval[]</></entry>
      <entry>
       <literal>&amp;&amp;</>
       <literal>&lt;@</>
       <literal>=</>
       <literal>@&gt;</>
      </entry>
     </row>
     <row>
      <entry><literal>_varbit_ops</></entry>
      <entry><type>bit varying[]</></entry>
      <entry>
       <literal>&amp;&amp;</>
       <literal>&lt;@</>
       <literal>=</>
       <literal>@&gt;</>
      </entry>
     </row>
     <row>
      <entry><literal>_varchar_ops</></entry>
      <entry><type>character varying[]</></entry>
      <entry>
       <literal>&amp;&amp;</>
       <literal>&lt;@</>
       <literal>=</>
       <literal>@&gt;</>
      </entry>
     </row>
     <row>
      <entry><literal>jsonb_ops</></entry>
      <entry><type>jsonb</></entry>
      <entry>
       <literal>?</>
       <literal>?&amp;</>
       <literal>?|</>
       <literal>@&gt;</>
      </entry>
     </row>
     <row>
      <entry><literal>jsonb_path_ops</></entry>
      <entry><type>jsonb</></entry>
      <entry>
       <literal>@&gt;</>
      </entry>
     </row>
     <row>
      <entry><literal>tsvector_ops</></entry>
      <entry><type>tsvector</></entry>
      <entry>
       <literal>@@</>
       <literal>@@@</>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 <para>
<!--
  Of the two operator classes for type <type>jsonb</>, <literal>jsonb_ops</>
  is the default.  <literal>jsonb_path_ops</> supports fewer operators but
  offers better performance for those operators.
  See <xref linkend="json-indexing"> for details.
-->
<type>jsonb</>型の2つの演算子クラスのうち、<literal>jsonb_ops</>がデフォルトです。
<literal>jsonb_path_ops</>はより少数の演算子しかサポートしませんが、その演算子に対してはより良いパフォーマンスを提供します。
詳細は<xref linkend="json-indexing">を参照してください。
 </para>

</sect1>

<sect1 id="gin-extensibility">
<!--
 <title>Extensibility</title>
-->
 <title>拡張性</title>

 <para>
<!--
   The <acronym>GIN</acronym> interface has a high level of abstraction,
   requiring the access method implementer only to implement the semantics of
   the data type being accessed.  The <acronym>GIN</acronym> layer itself
   takes care of concurrency, logging and searching the tree structure.
-->
<acronym>GIN</acronym>インタフェースは高度に抽象化されています。
アクセスメソッド実装者に要求されることは、アクセスするデータ型の意味を実装することだけです。
<acronym>GIN</acronym>層自体が同時実行性、ログ処理、ツリー構造の検索処理に関する面倒を見ます。
 </para>

 <para>
<!--
   All it takes to get a <acronym>GIN</acronym> access method working is to
   implement a few user-defined methods, which define the behavior of
   keys in the tree and the relationships between keys, indexed items,
   and indexable queries. In short, <acronym>GIN</acronym> combines
   extensibility with generality, code reuse, and a clean interface.
-->
<acronym>GIN</acronym>アクセスメソッドを動作させるために必要なことは、少数のユーザ定義関数を実装することだけです。
これは、ツリー内のキーの動作とキーとインデックス付けされる項目、インデックス可能な問い合わせ間の関係を定義します。
すなわち、<acronym>GIN</acronym>は、一般化、コード再利用、整理されたインタフェースによる拡張性を組み合わせます。
 </para>

 <para>
<!--
   There are three methods that an operator class for
   <acronym>GIN</acronym> must provide:
-->
<acronym>GIN</acronym>用の演算子クラスが提供しなければならないメソッドは3つあります。

 <variablelist>
    <varlistentry>
     <term><function>int compare(Datum a, Datum b)</></term>
     <listitem>
      <para>
<!--
       Compares two keys (not indexed items!) and returns an integer less than
       zero, zero, or greater than zero, indicating whether the first key is
       less than, equal to, or greater than the second.  Null keys are never
       passed to this function.
-->
キー（インデックス付けされる項目ではありません）を比較し、0より小さい、0、または0より大きい整数を返します。
それぞれ、最初のキーが2番目のキーより、小さい、等しい、または大きいことを示します。
NULLキーがこの関数に渡されることはありません。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>Datum *extractValue(Datum itemValue, int32 *nkeys,
        bool **nullFlags)</></term>
     <listitem>
      <para>
<!--
       Returns a palloc'd array of keys given an item to be indexed.  The
       number of returned keys must be stored into <literal>*nkeys</>.
       If any of the keys can be null, also palloc an array of
       <literal>*nkeys</> <type>bool</type> fields, store its address at
       <literal>*nullFlags</>, and set these null flags as needed.
       <literal>*nullFlags</> can be left <symbol>NULL</symbol> (its initial value)
       if all keys are non-null.
       The return value can be <symbol>NULL</symbol> if the item contains no keys.
-->
インデックス対象値に与えられる、pallocで割り当てられたキーの配列を返します。
返されるキーの数は<literal>*nkeys</>に格納しなければなりません。
キーのいずれかがNULLになるかもしれない場合、<literal>*nkeys</>個の<type>bool</type>の配列をpallocで割り当てそのアドレスを<literal>*nullFlags</>に格納し、必要に応じてNULLフラグを設定してください。
すべてのキーが非NULLであれば、<literal>*nullFlags</>を<symbol>NULL</symbol>（初期値）のままにすることができます。
項目がキーを含まない場合、戻り値は<symbol>NULL</symbol>になるかもしれません。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>Datum *extractQuery(Datum query, int32 *nkeys,
        StrategyNumber n, bool **pmatch, Pointer **extra_data,
        bool **nullFlags, int32 *searchMode)</></term>
     <listitem>
      <para>
<!--
       Returns a palloc'd array of keys given a value to be queried; that is,
       <literal>query</> is the value on the right-hand side of an
       indexable operator whose left-hand side is the indexed column.
       <literal>n</> is the strategy number of the operator within the
       operator class (see <xref linkend="xindex-strategies">).
       Often, <function>extractQuery</> will need
       to consult <literal>n</> to determine the data type of
       <literal>query</> and the method it should use to extract key values.
       The number of returned keys must be stored into <literal>*nkeys</>.
       If any of the keys can be null, also palloc an array of
       <literal>*nkeys</> <type>bool</type> fields, store its address at
       <literal>*nullFlags</>, and set these null flags as needed.
       <literal>*nullFlags</> can be left <symbol>NULL</symbol> (its initial value)
       if all keys are non-null.
       The return value can be <symbol>NULL</symbol> if the <literal>query</> contains no keys.
-->
問い合わせ対象の値に与えられる、pallocで割り当てられたキーの配列を返します。
つまり、<literal>query</>はインデックス可能な演算子の右辺の値です。
この左辺はインデックス対象の列です。
<literal>n</>は演算子クラス内の演算子の戦略番号です（<xref linkend="xindex-strategies">を参照）。
<function>extractQuery</>はしばしば、<literal>query</>のデータ型とキー値を抽出するために使用しなければならないメソッドを決定するために、<literal>n</>を調べなければなりません。
返されるキーの数を<literal>*nkeys</>に格納しなければなりません。
キーのいずれかがNULLとなる可能性がある場合はまた、<literal>*nkeys</>個の<type>bool</type>の配列をpallocで割り当て、<literal>*nullFlags</>にそのアドレスを格納し、必要に応じてNULLフラグを設定してください。
すべてのキーが非NULLならば<literal>*nullFlags</>は<symbol>NULL</symbol>（初期値）のままにしておくことができます。
<literal>query</>がキーを含まない場合、戻り値を<symbol>NULL</symbol>にすることができます。
      </para>

      <para>
<!--
       <literal>searchMode</> is an output argument that allows
       <function>extractQuery</> to specify details about how the search
       will be done.
       If <literal>*searchMode</> is set to
       <literal>GIN_SEARCH_MODE_DEFAULT</> (which is the value it is
       initialized to before call), only items that match at least one of
       the returned keys are considered candidate matches.
       If <literal>*searchMode</> is set to
       <literal>GIN_SEARCH_MODE_INCLUDE_EMPTY</>, then in addition to items
       containing at least one matching key, items that contain no keys at
       all are considered candidate matches.  (This mode is useful for
       implementing is-subset-of operators, for example.)
       If <literal>*searchMode</> is set to <literal>GIN_SEARCH_MODE_ALL</>,
       then all non-null items in the index are considered candidate
       matches, whether they match any of the returned keys or not.  (This
       mode is much slower than the other two choices, since it requires
       scanning essentially the entire index, but it may be necessary to
       implement corner cases correctly.  An operator that needs this mode
       in most cases is probably not a good candidate for a GIN operator
       class.)
       The symbols to use for setting this mode are defined in
       <filename>access/gin.h</>.
-->
<literal>searchMode</>は出力引数です。
これにより<function>extractQuery</>は検索がどのように行われるかの詳細を指定することができます。
<literal>*searchMode</>が<literal>GIN_SEARCH_MODE_DEFAULT</>（呼び出し前にこの値に初期化されます。）に設定された場合、返されるキーの少なくとも１つに一致する項目が合致候補とみなされます。
<literal>*searchMode</>が<literal>GIN_SEARCH_MODE_INCLUDE_EMPTY</>に設定された場合、少なくとも１つの一致するキーを含む項目に加え、キーをまったく含まない項目が合致候補とみなされます。
（このモードは例えば何のサブセットかを求める演算子を実装する際に有用です。）
<literal>*searchMode</>が<literal>GIN_SEARCH_MODE_ALL</>に設定された場合、返されるキーのいずれかに一致するかどうかは関係なく、インデックス内の非NULLの項目すべてが合致候補とみなされます。
（このモードは、基本的にインデックス全体のスキャン処理が必要ですので、他の２つの選択肢と比べてかなり低速になります。
しかし境界条件を正確に実装するためにこれが必要になるかもしれません。
おそらく、このモードを必要とする演算子はほとんどの場合、GIN演算子クラス向けに優れた候補ではありません。）
このモードを設定するために使用する記号は<filename>access/gin.h</>で定義されています。
      </para>

      <para>
<!--
       <literal>pmatch</> is an output argument for use when partial match
       is supported.  To use it, <function>extractQuery</> must allocate
       an array of <literal>*nkeys</> booleans and store its address at
       <literal>*pmatch</>.  Each element of the array should be set to TRUE
       if the corresponding key requires partial match, FALSE if not.
       If <literal>*pmatch</> is set to <symbol>NULL</symbol> then GIN assumes partial match
       is not required.  The variable is initialized to <symbol>NULL</symbol> before call,
       so this argument can simply be ignored by operator classes that do
       not support partial match.
-->
<literal>pmatch</>は部分一致が提供されている場合に使用する出力引数です。
使用するには、<function>extractQuery</>が<literal>*nkeys</>論理値の配列を割り当て、そのアドレスを<literal>*pmatch</>に格納しなければなりません。
関連するキーが部分一致を必要とするとき、それぞれの配列要素は真に、そうでなければ偽に設定されなければなりません。
<literal>*pmatch</>が<symbol>NULL</symbol>に設定されている場合、GINは部分一致が必要ないと想定します。
呼び出し前に変数は<symbol>NULL</symbol>に初期化されますので、この引数は部分一致が提供されていない演算子クラスでは、単に無視できます。
      </para>

      <para>
<!--
       <literal>extra_data</> is an output argument that allows
       <function>extractQuery</> to pass additional data to the
       <function>consistent</> and <function>comparePartial</> methods.
       To use it, <function>extractQuery</> must allocate
       an array of <literal>*nkeys</> Pointers and store its address at
       <literal>*extra_data</>, then store whatever it wants to into the
       individual pointers.  The variable is initialized to <symbol>NULL</symbol> before
       call, so this argument can simply be ignored by operator classes that
       do not require extra data.  If <literal>*extra_data</> is set, the
       whole array is passed to the <function>consistent</> method, and
       the appropriate element to the <function>comparePartial</> method.
-->
<literal>extra_data</>は、<function>extractQuery</>が<function>consistent</>と<function>comparePartial</>メソッドに追加データを渡すことができるようにする出力引数です。
使用するには、<function>extractQuery</>が<literal>*nkeys</>ポインタの配列を割り当て、そのアドレスを<literal>*extra_data</>に格納し、そして望まれるものは何でも個別のポインタに格納しなければなりません。
変数は呼び出し前に<symbol>NULL</symbol>に初期化されますので、追加データを必要としない演算子クラスでこの引数は単に無視できます。
もし<literal>*extra_data</>が設定されれば、配列全部が<function>consistent</>メソッドに、適切な要素が<function>comparePartial</>メソッドに渡されます。
      </para>

     </listitem>
    </varlistentry>

  </variablelist>

<!--
  An operator class must also provide a function to check if an indexed item
  matches the query. It comes in two flavors, a boolean <function>consistent</>
  function, and a ternary <function>triConsistent</> function.
  <function>triConsistent</> covers the functionality of both, so providing
  triConsistent alone is sufficient. However, if the boolean variant is
  significantly cheaper to calculate, it can be advantageous to provide both.
  If only the boolean variant is provided, some optimizations that depend on
  refuting index items before fetching all the keys are disabled.
-->
演算子クラスは、インデックス付けされた項目が問い合わせに一致するか確認する関数も提供しなければなりません。
それは2つの方法で行なわれます。
2値の<function>consistent</>関数と3値の<function>triConsistent</>関数です。
<function>triConsistent</>が両方の機能を含みますので、triConsistentだけを提供しても十分です。
しかし、2値の亜種を計算するのが著しく安価であれば、両方を提供することは役に立つかもしれません。
2値の亜種のみが提供されていれば、すべてのキーを取得する前にインデックス項目が一致しないことを確認することに基づく最適化の中には無効となるものもあります。

  <variablelist>
    <varlistentry>
     <term><function>bool consistent(bool check[], StrategyNumber n, Datum query,
        int32 nkeys, Pointer extra_data[], bool *recheck,
        Datum queryKeys[], bool nullFlags[])</></term>
     <listitem>
      <para>
<!--
       Returns TRUE if an indexed item satisfies the query operator with
       strategy number <literal>n</> (or might satisfy it, if the recheck
       indication is returned).  This function does not have direct access
       to the indexed item's value, since <acronym>GIN</acronym> does not
       store items explicitly.  Rather, what is available is knowledge
       about which key values extracted from the query appear in a given
       indexed item.  The <literal>check</> array has length
       <literal>nkeys</>, which is the same as the number of keys previously
       returned by <function>extractQuery</> for this <literal>query</> datum.
       Each element of the
       <literal>check</> array is TRUE if the indexed item contains the
       corresponding query key, i.e., if (check[i] == TRUE) the i-th key of the
       <function>extractQuery</> result array is present in the indexed item.
       The original <literal>query</> datum is
       passed in case the <function>consistent</> method needs to consult it,
       and so are the <literal>queryKeys[]</> and <literal>nullFlags[]</>
       arrays previously returned by <function>extractQuery</>.
       <literal>extra_data</> is the extra-data array returned by
       <function>extractQuery</>, or <symbol>NULL</symbol> if none.
-->
インデックス付けられた項目が戦略番号<literal>n</>を持つ問い合わせ演算子を満たす（または、recheck印が返されたときはたぶん満たすかもしれない）場合に真を返します。
<acronym>GIN</acronym>は項目を明示的に格納しませんので、この関数はインデックス付けされた項目の値に直接アクセスすることができません。
どちらかというと、この問い合わせから取り出される指定された問い合わせで現れるキー値に関する知識が利用できるものです。
<literal>check</>配列は長さ<literal>nkeys</>であり、この<literal>query</>データに対して事前に行われた<function>extractQuery</>が返したキーの数と同じです。
インデックス対象の項目が対応する問い合わせキーを持つ場合、<literal>check</>配列の各要素は真です。
つまり、(check[i] == TRUE)の場合、<function>extractQuery</>の結果配列のi番目のキーがインデックス対象項目内に存在します。
元の<literal>query</>データは、<function>consistent</>メソッドがそれを調査する必要がある場合に、渡されます。
このため<literal>queryKeys[]</>および<literal>nullFlags[]</>は事前に<function>extractQuery</>によって返されます。
<literal>extra_data</>は<function>extractQuery</>により返された追加データ配列で、ない場合は<symbol>NULL</symbol>です。
      </para>

      <para>
<!--
       When <function>extractQuery</> returns a null key in
       <literal>queryKeys[]</>, the corresponding <literal>check[]</> element
       is TRUE if the indexed item contains a null key; that is, the
       semantics of <literal>check[]</> are like <literal>IS NOT DISTINCT
       FROM</>.  The <function>consistent</> function can examine the
       corresponding <literal>nullFlags[]</> element if it needs to tell
       the difference between a regular value match and a null match.
-->
<function>extractQuery</>が<literal>queryKeys[]</>内でNULLキーを返す時、インデックス対象項目がNULLキーを含む場合は対応する<literal>check[]</>要素は真です、
つまり、<literal>check[]</>の意味は<literal>IS NOT DISTINCT FROM</>のようなものです。
<function>consistent</>関数は、通常の値の合致とNULL合致との違いを通知する必要がある場合、対応する<literal>nullFlags[]</>要素を検査することができます。
      </para>

      <para>
<!--
       On success, <literal>*recheck</> should be set to TRUE if the heap
       tuple needs to be rechecked against the query operator, or FALSE if
       the index test is exact.  That is, a FALSE return value guarantees
       that the heap tuple does not match the query; a TRUE return value with
       <literal>*recheck</> set to FALSE guarantees that the heap tuple does
       match the query; and a TRUE return value with
       <literal>*recheck</> set to TRUE means that the heap tuple might match
       the query, so it needs to be fetched and rechecked by evaluating the
       query operator directly against the originally indexed item.
-->
成功の場合、<literal>*recheck</>はヒープタプルが問い合わせ演算子に対し再検査を必要とすれば真で、インデックス検査が的確であれば偽です。
つまり、FALSEという戻り値はヒープタプルが問い合わせに合わないことを保証し、<literal>*recheck</>が付いたTRUEという戻り値はヒープタプルが問い合わせに一致する可能性があるため、それを取り出し、元のインデックス付けされた項目を直接問い合わせ演算子で評価することで再検査する必要があることを意味します。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>GinTernaryValue triConsistent(GinTernaryValue check[], StrategyNumber n, Datum query,
        int32 nkeys, Pointer extra_data[],
        Datum queryKeys[], bool nullFlags[])</></term>
     <listitem>
      <para>
<!--
       <function>triConsistent</> is similar to <function>consistent</>,
       but instead of a boolean <literal>check[]</>, there are three possible
       values for each key: <literal>GIN_TRUE</>, <literal>GIN_FALSE</> and
       <literal>GIN_MAYBE</>. <literal>GIN_FALSE</> and <literal>GIN_TRUE</>
       have the same meaning as regular boolean values.
       <literal>GIN_MAYBE</> means that the presence of that key is not known.
       When <literal>GIN_MAYBE</> values are present, the function should only
       return GIN_TRUE if the item matches whether or not the index item
       contains the corresponding query keys. Likewise, the function must
       return GIN_FALSE only if the item does not match, whether or not it
       contains the GIN_MAYBE keys. If the result depends on the GIN_MAYBE
       entries, i.e. the match cannot be confirmed or refuted based on the
       known query keys, the function must return GIN_MAYBE.
-->
<function>triConsistent</>は<function>consistent</>と似ていますが、論理値<literal>check[]</>の代わりに、各キーに対して3つの可能な値があります。<literal>GIN_TRUE</>、<literal>GIN_FALSE</>、<literal>GIN_MAYBE</>です。
<literal>GIN_FALSE</>と<literal>GIN_TRUE</>は通常の論理値と同じ意味です。
<literal>GIN_MAYBE</>はそのキーの存在が分からないこと意味します。
<literal>GIN_MAYBE</>値があれば、インデックス項目が対応する問い合わせキーを含むかどうかに関わらず、項目が一致する場合にのみ関数はGIN_TRUEを返すべきです。
同様に、GIN_MAYBEを含むかどうかに関わらず項目が一致しない場合にのみ関数はGIN_FALSEを返さなければなりません。
結果がGIN_MAYBE項目に依存する、すなわち、分かっている問い合わせキーに基づいて、一致することもしないことも確認できない場合には、関数はGIN_MAYBEを返さなければなりません。
      </para>
      <para>
<!--
       When there are no GIN_MAYBE values in the <literal>check</> vector,
       <literal>GIN_MAYBE</> return value is equivalent of setting
       <literal>recheck</> flag in the boolean <function>consistent</> function.
-->
<literal>check</>ベクターにGIN_MAYBE値がなければ、<literal>GIN_MAYBE</>戻り値は論理値の<function>consistent</>関数で<literal>recheck</>フラグを設定することと同じです。
      </para>
     </listitem>
    </varlistentry>
  </variablelist>

<!--
  Optionally, an operator class for <acronym>GIN</acronym> can supply the
  following method:
-->
省略可能ですが、<acronym>GIN</acronym>に対する演算子クラスは以下のメソッドを提供します。

  <variablelist>
    <varlistentry>
     <term><function>int comparePartial(Datum partial_key, Datum key, StrategyNumber n,
                              Pointer extra_data)</></term>
     <listitem>
      <para>
<!--
       Compare a partial-match query key to an index key.  Returns an integer
       whose sign indicates the result: less than zero means the index key
       does not match the query, but the index scan should continue; zero
       means that the index key does match the query; greater than zero
       indicates that the index scan should stop because no more matches
       are possible.  The strategy number <literal>n</> of the operator
       that generated the partial match query is provided, in case its
       semantics are needed to determine when to end the scan.  Also,
       <literal>extra_data</> is the corresponding element of the extra-data
       array made by <function>extractQuery</>, or <symbol>NULL</symbol> if none.
       Null keys are never passed to this function.
-->
問い合わせキーとインデックスキーの部分一致を比較します。
符号が結果を示す整数が返ります。
ゼロ未満はインデックスキーは問い合わせに一致しないが、インデックススキャンを続けるべきであることを示します。
ゼロはインデックスキーが問い合わせに一致することを示します。
ゼロより大きな値はこれ以上の一致はありえないためインデックススキャンを停止すべきであることを示します。
スキャンをいつ停止するかを決めるためにセマンテックスが必要とされる場合、部分一致問い合わせを生成した演算子の戦略番号<literal>n</>が提供されます。
また<literal>extra_data</>は<function>extractQuery</>で作成される追加データ配列の対応する要素、もしなければ<symbol>NULL</symbol>です。
NULLキーがこの関数に渡されることはありません。
      </para>
     </listitem>
    </varlistentry>
  </variablelist>
 </para>

 <para>
<!--
  To support <quote>partial match</> queries, an operator class must
  provide the <function>comparePartial</> method, and its
  <function>extractQuery</> method must set the <literal>pmatch</>
  parameter when a partial-match query is encountered.  See
  <xref linkend="gin-partial-match"> for details.
-->
<quote>部分一致</>問い合わせをサポートするためには、演算子クラスは<function>comparePartial</>メソッドを提供しなければなりません。
またその<function>extractQuery</>は、部分一致問い合わせであった時に<literal>pmatch</>パラメータを設定しなければなりません。
詳細については<xref linkend="gin-partial-match">を参照してください。
 </para>

 <para>
<!--
  The actual data types of the various <literal>Datum</> values mentioned
  above vary depending on the operator class.  The item values passed to
  <function>extractValue</> are always of the operator class's input type, and
  all key values must be of the class's <literal>STORAGE</> type.  The type of
  the <literal>query</> argument passed to <function>extractQuery</>,
  <function>consistent</> and <function>triConsistent</> is whatever is
  specified as the right-hand input
  type of the class member operator identified by the strategy number.
  This need not be the same as the item type, so long as key values of the
  correct type can be extracted from it.
-->
上記の各種<literal>Datum</>値の実データ型は、演算子クラスに依存して変動します。
<function>extractValue</>に渡される項目値は常に演算子クラスの入力型であり、キー値はすべてそのクラスの<literal>STORAGE</>型でなければなりません。
<function>extractQuery</>、<function>consistent</>および<function>triConsistent</>に渡される<literal>query</>引数は、戦略番号によって識別されるクラスのメンバ演算子の右辺入力型として指定されたものになります。
正しい型のキー値がそこから抽出できる限り、これは項目の型と同じである必要はありません。
 </para>

</sect1>

<sect1 id="gin-implementation">
<!--
 <title>Implementation</title>
-->
 <title>実装</title>

 <para>
<!--
  Internally, a <acronym>GIN</acronym> index contains a B-tree index
  constructed over keys, where each key is an element of one or more indexed
  items (a member of an array, for example) and where each tuple in a leaf
  page contains either a pointer to a B-tree of heap pointers (a
  <quote>posting tree</>), or a simple list of heap pointers (a <quote>posting
  list</>) when the list is small enough to fit into a single index tuple along
  with the key value.
-->
<acronym>GIN</acronym>インデックスはキー全体に対するB-treeインデックスを持ちます。
そのキーはそれぞれインデックス対象項目の要素（例えば配列のメンバ）であり、リーフページ内のタプルはそれぞれ、ヒープポインタのB-treeへのポインタ（<quote>投稿されたツリー</>）か、もしリストがキー値と共に単一インデックスタプルに合う程度十分に小さければヒープポインタの単純なリスト（<quote>投稿されたリスト</>）です。
 </para>

 <para>
<!--
  As of <productname>PostgreSQL</productname> 9.1, null key values can be
  included in the index.  Also, placeholder nulls are included in the index
  for indexed items that are null or contain no keys according to
  <function>extractValue</>.  This allows searches that should find empty
  items to do so.
-->
<productname>PostgreSQL</productname> 9.1からNULLキー値をインデックスに含められるようになりました。
またプレースホルダとしてのNULLが、NULLまたは<function>extractValue</>によるとキーを含まないインデックス対象項目についてインデックスに含められます。
これにより空の項目を見つけ出すための検索を行うことができます。
 </para>

 <para>
<!--
  Multicolumn <acronym>GIN</acronym> indexes are implemented by building
  a single B-tree over composite values (column number, key value).  The
  key values for different columns can be of different types.
-->
複数列に対する<acronym>GIN</acronym>インデックスは複合型の値（列番号、キー値）全体について単一のB-treeを構築することで実装されます。
異なる列に対するキー値は別の型となるかもしれません。
 </para>

 <sect2 id="gin-fast-update">
<!--
  <title>GIN Fast Update Technique</title>
-->
  <title>GIN高速更新手法</title>

  <para>
<!--
   Updating a <acronym>GIN</acronym> index tends to be slow because of the
   intrinsic nature of inverted indexes: inserting or updating one heap row
   can cause many inserts into the index (one for each key extracted
   from the indexed item). As of <productname>PostgreSQL</productname> 8.4,
   <acronym>GIN</> is capable of postponing much of this work by inserting
   new tuples into a temporary, unsorted list of pending entries.
   When the table is vacuumed, or if the pending list becomes too large
   (larger than <xref linkend="guc-work-mem">), the entries are moved to the
   main <acronym>GIN</acronym> data structure using the same bulk insert
   techniques used during initial index creation.  This greatly improves
   <acronym>GIN</acronym> index update speed, even counting the additional
   vacuum overhead.  Moreover the overhead work can be done by a background
   process instead of in foreground query processing.
-->
1つのヒープ行の挿入または更新によりインデックスへの挿入が多く発生するという、転置インデックスの本質的な性質のため<acronym>GIN</acronym>インデックスの更新は低速になりがちです。
（各キー用のヒープ行はインデックス付けされた項目から取り出されます。）
<productname>PostgreSQL</productname> 8.4から<acronym>GIN</>は、新しいタプルを一時的なソートされていない、待機中の項目リストに挿入することにより、この作業の大部分を遅延させることができるようになりました。
テーブルがバキュームされた時、または、待機中のリストが大きくなりすぎた（<xref linkend="guc-work-mem">よりも大きくなった）時、初期のインデックス作成の際に使用されるものと同様の一括挿入技法を使用して、項目は主<acronym>GIN</acronym>データ構造に移動されます。
これは、バキュームのオーバーヘッドが追加されることを考慮したとしても、<acronym>GIN</acronym>インデックスの更新速度を著しく向上します。
さらに、フォアグラウンドの問い合わせ処理ではなくバックグラウンド処理でこのオーバーヘッド作業を実行することができます。
  </para>

  <para>
<!--
   The main disadvantage of this approach is that searches must scan the list
   of pending entries in addition to searching the regular index, and so
   a large list of pending entries will slow searches significantly.
   Another disadvantage is that, while most updates are fast, an update
   that causes the pending list to become <quote>too large</> will incur an
   immediate cleanup cycle and thus be much slower than other updates.
   Proper use of autovacuum can minimize both of these problems.
-->
この手法の大きな欠点は、検索時に通常のインデックス検索に加え待機中の項目リストのスキャンを行わなければならない点です。
このため、待機中の項目リストが大きくなると検索が顕著に遅くなります。
他の欠点は、ほとんどの更新は高速ですが、待機中の項目リストが<quote>大きくなりすぎる</>きっかけとなった更新は即時の整理処理を招くことになり、他の更新に比べ大きく低速になります。
自動バキュームを適切に使用することで、これらの両方の問題を最小化することができます。
  </para>

  <para>
<!--
   If consistent response time is more important than update speed,
   use of pending entries can be disabled by turning off the
   <literal>FASTUPDATE</literal> storage parameter for a
   <acronym>GIN</acronym> index.  See <xref linkend="sql-createindex">
   for details.
-->
一貫した応答時間が更新速度より重要な場合、<acronym>GIN</acronym>インデックスに対する<literal>FASTUPDATE</literal>格納パラメータを無効にすることにより、待機中の項目の使用を無効にすることができます。
詳細は<xref linkend="sql-createindex">を参照してください。
  </para>
 </sect2>

 <sect2 id="gin-partial-match">
<!--
  <title>Partial Match Algorithm</title>
-->
  <title>部分一致アルゴリズム</title>

  <para>
<!--
   GIN can support <quote>partial match</> queries, in which the query
   does not determine an exact match for one or more keys, but the possible
   matches fall within a reasonably narrow range of key values (within the
   key sorting order determined by the <function>compare</> support method).
   The <function>extractQuery</> method, instead of returning a key value
   to be matched exactly, returns a key value that is the lower bound of
   the range to be searched, and sets the <literal>pmatch</> flag true.
   The key range is then scanned using the <function>comparePartial</>
   method.  <function>comparePartial</> must return zero for a matching
   index key, less than zero for a non-match that is still within the range
   to be searched, or greater than zero if the index key is past the range
   that could match.
-->
GINは<quote>部分一致</>問い合わせをサポートすることができます。
この問い合わせは１つ以上のキーに正確に一致することは決定しませんが、キー値の合理的に狭い（<function>compare</>サポートメソッドで決まるキーのソート順に従った）範囲内に一致する可能性があります。
<function>extractQuery</>は、正確に一致したキー値を返す代わりに、検索される範囲の下限となるキー値を返し、<literal>pmatch</>フラグを真に設定します。
そしてキー範囲を<function>comparePartial</>メソッドを使用して検索します。
<function>comparePartial</>は一致するインデックスキーではゼロを、一致しないが検索すべき範囲内にあればゼロ未満の値を、インデックスキーが一致可能な範囲を超えた場合はゼロより大きな値を返さなければなりません。
  </para>
 </sect2>

</sect1>

<sect1 id="gin-tips">
<!--
<title>GIN Tips and Tricks</title>
-->
<title>GINの小技</title>

 <variablelist>
  <varlistentry>
<!--
   <term>Create vs. insert</term>
-->
   <term>作成と挿入</term>
   <listitem>
    <para>
<!--
     Insertion into a <acronym>GIN</acronym> index can be slow
     due to the likelihood of many keys being inserted for each item.
     So, for bulk insertions into a table it is advisable to drop the GIN
     index and recreate it after finishing bulk insertion.
-->
各項目に対して多くのキーが挿入される可能性がありますので、<acronym>GIN</acronym>インデックスへの挿入は低速になることがあります。
ですので、テーブルに対する大量の挿入では、GINインデックスを削除し、大量の挿入が終わった段階で再作成することを勧めます。
    </para>

    <para>
<!--
     As of <productname>PostgreSQL</productname> 8.4, this advice is less
     necessary since delayed indexing is used (see <xref
     linkend="gin-fast-update"> for details).  But for very large updates
     it may still be best to drop and recreate the index.
-->
<productname>PostgreSQL</productname> 8.4から遅延インデックス作成が使用されるため、この勧告は必要性が薄れました。
（<xref linkend="gin-fast-update">を参照してください。）
しかし非常に大規模な更新では、インデックスの削除と再作成がまだ最善かもしれません。
    </para>
   </listitem>
  </varlistentry>

  <varlistentry>
   <term><xref linkend="guc-maintenance-work-mem"></term>
   <listitem>
    <para>
<!--
     Build time for a <acronym>GIN</acronym> index is very sensitive to
     the <varname>maintenance_work_mem</> setting; it doesn't pay to
     skimp on work memory during index creation.
-->
<acronym>GIN</acronym>インデックスの構築時間は<varname>maintenance_work_mem</>の設定に非常に敏感です。
インデックス作成時に作業メモリをより少なく使用しようとはしません。
    </para>
   </listitem>
  </varlistentry>

  <varlistentry>
   <term><xref linkend="guc-work-mem"></term>
   <listitem>
    <para>
<!--
     During a series of insertions into an existing <acronym>GIN</acronym>
     index that has <literal>FASTUPDATE</> enabled, the system will clean up
     the pending-entry list whenever the list grows larger than
     <varname>work_mem</>.  To avoid fluctuations in observed response time,
     it's desirable to have pending-list cleanup occur in the background
     (i.e., via autovacuum).  Foreground cleanup operations can be avoided by
     increasing <varname>work_mem</> or making autovacuum more aggressive.
     However, enlarging <varname>work_mem</> means that if a foreground
     cleanup does occur, it will take even longer.
-->
既存の<literal>FASTUPDATE</>が有効な<acronym>GIN</acronym>インデックスに対して挿入を繰り返す間、待機中の項目リストが<varname>work_mem</>より大きくなると、システムはこのリストを整理します。
観測される応答時間の変動を防ぐためには、待機中リストの整理をバックグラウンド（例えば自動バキューム）で起きるようにすることが望まれます。
フォアグラウンドでの整理処理は、<varname>work_mem</>を大きくすること、もしくは自動バキュームをより積極的に行うことで防ぐことができます。
しかし<varname>work_mem</>を大きくすることは、フォアグラウンドで整理処理が発生した時により長い時間がかかることを意味します。
    </para>
   </listitem>
  </varlistentry>

  <varlistentry>
   <term><xref linkend="guc-gin-fuzzy-search-limit"></term>
   <listitem>
    <para>
<!--
     The primary goal of developing <acronym>GIN</acronym> indexes was
     to create support for highly scalable full-text search in
     <productname>PostgreSQL</productname>, and there are often situations when
     a full-text search returns a very large set of results.  Moreover, this
     often happens when the query contains very frequent words, so that the
     large result set is not even useful.  Since reading many
     tuples from the disk and sorting them could take a lot of time, this is
     unacceptable for production.  (Note that the index search itself is very
     fast.)
-->
<acronym>GIN</acronym>インデックス開発の主な目的は、スケーラビリティが高い全文検索のサポートを<productname>PostgreSQL</productname>で作成することでした。
全文検索の結果は非常に大規模な結果セットを返します。
さらに、問い合わせが非常に高頻度な単語を持つ場合、こうした状況はよく発生しますが、大規模な結果セットは有用ですらありません。
ディスクから大量のタプルを読み、ソートすることは長い時間がかかりますので、実運用レベルでは受け入れられません。
（インデックス検索自体は非常に高速であることに注意してください。）
    </para>
    <para>
<!--
     To facilitate controlled execution of such queries,
     <acronym>GIN</acronym> has a configurable soft upper limit on the
     number of rows returned: the
     <varname>gin_fuzzy_search_limit</varname> configuration parameter.
     It is set to 0 (meaning no limit) by default.
     If a non-zero limit is set, then the returned set is a subset of
     the whole result set, chosen at random.
-->
こうした問い合わせの実行を簡単に制御できるように、<acronym>GIN</acronym>は返される行数に対して設定可能なソフト上限、<varname>gin_fuzzy_search_limit</varname>設定パラメータを持ちます。
これはデフォルトでは0です（無制限を意味します）。
非0の制限が設定された場合、返されるセットは結果セット全体からランダムに選んだサブセットになります。
    </para>
    <para>
<!--
     <quote>Soft</quote> means that the actual number of returned results
     could differ somewhat from the specified limit, depending on the query
     and the quality of the system's random number generator.
-->
<quote>ソフト</quote>は、問い合わせとシステムの乱数ジェネレータの品質に依存して、返される結果の実際の数が指定した上限より多少異なることを意味します。
    </para>
    <para>
<!--
     From experience, values in the thousands (e.g., 5000 &mdash; 20000)
     work well.
-->
経験上、数千（例えば5000から20000）の値がうまく動作します。
    </para>
   </listitem>
  </varlistentry>
 </variablelist>

</sect1>

<sect1 id="gin-limit">
<!--
 <title>Limitations</title>
-->
 <title>制限</title>

 <para>
<!--
  <acronym>GIN</acronym> assumes that indexable operators are strict.  This
  means that <function>extractValue</> will not be called at all on a null
  item value (instead, a placeholder index entry is created automatically),
  and <function>extractQuery</function> will not be called on a null query
  value either (instead, the query is presumed to be unsatisfiable).  Note
  however that null key values contained within a non-null composite item
  or query value are supported.
-->
<acronym>GIN</acronym>は、インデックス付け可能な演算子は厳密であると仮定します。
これは<function>extractValue</>はNULL項目値についてはまったく呼び出されない（代わりにインデックス項目のプレースホルダが自動的に生成される）こと、および、<function>extractQuery</function>は問い合わせの値がNULLの場合に呼び出されない（代わりに問い合わせは不一致であるとみなされる）ことを意味します。
しかし非NULLの複合型項目内または問い合わせ値内のNULLキー値はサポートされます。
 </para>
</sect1>

<sect1 id="gin-examples">
<!--
 <title>Examples</title>
-->
 <title>例</title>

 <para>
<!--
  The <productname>PostgreSQL</productname> source distribution includes
  <acronym>GIN</acronym> operator classes for <type>tsvector</> and
  for one-dimensional arrays of all internal types.  Prefix searching in
  <type>tsvector</> is implemented using the <acronym>GIN</> partial match
  feature.
  The following <filename>contrib</> modules also contain
  <acronym>GIN</acronym> operator classes:
-->
<productname>PostgreSQL</productname>ソース配布物には<type>tsvector</>とすべての整数型の1次元配列に対する<acronym>GIN</acronym>演算子クラスが含まれています。
<type>tsvector</>にある前置検索は<acronym>GIN</>の部分一致機能の使用で実装されています。
以下の<filename>contrib</>モジュールにも<acronym>GIN</acronym>演算子クラスが含まれています。

 <variablelist>
  <varlistentry>
   <term><filename>btree_gin</></term>
   <listitem>
<!--
    <para>B-tree equivalent functionality for several data types</para>
-->
    <para>さまざまなデータ型に対するB-tree等価の機能</para>
   </listitem>
  </varlistentry>

  <varlistentry>
   <term><filename>hstore</></term>
   <listitem>
<!--
    <para>Module for storing (key, value) pairs</para>
-->
    <para>（キー、値）の組み合わせを格納するモジュール</para>
   </listitem>
  </varlistentry>

  <varlistentry>
   <term><filename>intarray</></term>
   <listitem>
<!--
    <para>Enhanced support for <type>int[]</type></para>
-->
    <para><type>int[]</type>に対する高度サポート</para>
   </listitem>
  </varlistentry>

  <varlistentry>
   <term><filename>pg_trgm</></term>
   <listitem>
<!--
    <para>Text similarity using trigram matching</para>
-->
    <para>トリグラム一致を使用したテキスト類似度</para>
   </listitem>
  </varlistentry>
 </variablelist>
 </para>
</sect1>

</chapter>
