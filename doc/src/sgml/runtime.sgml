<!-- doc/src/sgml/runtime.sgml -->

<chapter id="runtime">
<!--
 <title>Server Setup and Operation</title>
-->
<title>サーバの準備と運用</title>

 <para>
<!--
  This chapter discusses how to set up and run the database server
  and its interactions with the operating system.
-->
本章では、データベースサーバの設定と実行方法、そしてオペレーティングシステムとの相互作用について説明します。
 </para>

 <sect1 id="postgres-user">
<!--
  <title>The <productname>PostgreSQL</productname> User Account</title>
-->
  <title><productname>PostgreSQL</productname>ユーザアカウント</title>

  <indexterm>
<!--
   <primary>postgres user</primary>
-->
<primary>postgresユーザ</primary>
  </indexterm>

  <para>
<!--
   As with any server daemon that is accessible to the outside world,
   it is advisable to run <productname>PostgreSQL</productname> under a
   separate user account. This user account should only own the data
   that is managed by the server, and should not be shared with other
   daemons. (For example, using the user <literal>nobody</literal> is a bad
   idea.) It is not advisable to install executables owned by this
   user because compromised systems could then modify their own
   binaries.
-->
外部へアクセスできるサーバデーモンと同じように、<productname>PostgreSQL</productname>を独立したユーザアカウントで実行することをお勧めします。
このユーザアカウントは、サーバによって管理されるデータのみを所有する必要があります。
また、他のデーモンとアカウントを共有しない方が良いです。
（例えば、<literal>nobody</literal>ユーザの使用はお勧めできません。）
このユーザによって所有される実行プログラムをインストールすることも好ましくありません。
システムが攻撃を受けた場合などに、自分自身のバイナリを変更されてしまう可能性があるからです。
  </para>

  <para>
<!--
   To add a Unix user account to your system, look for a command
   <command>useradd</command> or <command>adduser</command>. The user
   name <systemitem>postgres</systemitem> is often used, and is assumed
   throughout this book, but you can use another name if you like.
-->
システムにUnixのユーザアカウントを追加するためには、コマンド<command>useradd</command>か<command>adduser</command>を使用してください。
<systemitem>postgres</systemitem>というユーザ名がよく使われ、本書全体でも使用していますが、好みの名前を使用しても構いません。
  </para>
 </sect1>

 <sect1 id="creating-cluster">
<!--
  <title>Creating a Database Cluster</title>
-->
  <title>データベースクラスタの作成</title>

  <indexterm>
<!--
   <primary>database cluster</primary>
-->
<primary>データベースクラスタ</primary>
  </indexterm>

  <indexterm>
<!--
   <primary>data area</primary>
   <see>database cluster</see>
-->
<primary>データ領域</primary>
<see>データベースクラスタ</see>
  </indexterm>

  <para>
<!--
   Before you can do anything, you must initialize a database storage
   area on disk. We call this a <firstterm>database cluster</firstterm>.
   (The <acronym>SQL</acronym> standard uses the term catalog cluster.) A
   database cluster is a collection of databases that is managed by a
   single instance of a running database server. After initialization, a
   database cluster will contain a database named <literal>postgres</literal>,
   which is meant as a default database for use by utilities, users and third
   party applications.  The database server itself does not require the
   <literal>postgres</literal> database to exist, but many external utility
   programs assume it exists.  Another database created within each cluster
   during initialization is called
   <literal>template1</literal>.  As the name suggests, this will be used
   as a template for subsequently created databases; it should not be
   used for actual work.  (See <xref linkend="managing-databases"> for
   information about creating new databases within a cluster.)
-->
まず最初に、ディスク上にデータベース格納領域を初期化する必要があります。
この格納領域を<firstterm>データベースクラスタ</firstterm>と呼びます。（標準<acronym>SQL</acronym>ではカタログクラスタという用語が使用されています）。
データベースクラスタはデータベースの集合で、稼働しているデータベースサーバのただ一つのインスタンスを通して管理されます。
初期化が終わると、データベースクラスタには<literal>postgres</literal>という名前のデータベースが含まれています。
このデータベースは、ユーティリティ、ユーザ、サードパーティ製アプリケーションが使用するデフォルトデータベースになります。
データベースサーバ自身はこの<literal>postgres</literal>データベースの存在を必要としていませんが、多くの外部ユーティリティはその存在を想定しています。
初期化中に他にも<literal>template1</literal>というデータベースが各クラスタ内に作成されます。
その名前から推測できるように、これはその後に作成されるデータベースのテンプレートとして使われます。
したがって、実際の作業に使用しない方がよいです。
（クラスタ内における新しいデータベースの作成については<xref linkend="managing-databases">を参照してください。）
  </para>

  <para>
<!--
   In file system terms, a database cluster is a single directory
   under which all data will be stored. We call this the <firstterm>data
   directory</firstterm> or <firstterm>data area</firstterm>. It is
   completely up to you where you choose to store your data.  There is no
   default, although locations such as
   <filename>/usr/local/pgsql/data</filename> or
   <filename>/var/lib/pgsql/data</filename> are popular. To initialize a
   database cluster, use the command <xref
   linkend="app-initdb">,<indexterm><primary>initdb</></> which is
   installed with <productname>PostgreSQL</productname>. The desired
   file system location of your database cluster is indicated by the
   <option>-D</option> option, for example:
-->
ファイルシステムの観点から見ると、データベースクラスタというのは、すべてのデータが格納される1つのディレクトリということになります。
これは<firstterm>データディレクトリ</firstterm>もしくは<firstterm>データ領域</firstterm>と呼ばれます。
どこにデータを格納するかは完全にユーザの自由です。
特にデフォルトの領域はありませんが、一般的によく使われるのは<filename>/usr/local/pgsql/data</filename>か<filename>/var/lib/pgsql/data</filename>です。
データベースクラスタを初期化するためには、<productname>PostgreSQL</productname>と一緒にインストールされるコマンド<xref linkend="app-initdb"><indexterm><primary>initdb</></>を使用してください。
データベースクラスタのファイルシステム上の場所は<option>-D</option>オプションで示します。
例えば次のようにします。
<screen>
<prompt>$</> <userinput>initdb -D /usr/local/pgsql/data</userinput>
</screen>
<!--
   Note that you must execute this command while logged into the
   <productname>PostgreSQL</productname> user account, which is
   described in the previous section.
-->
このコマンドは、前節で説明した<productname>PostgreSQL</productname>ユーザアカウントでログインして実行する必要があります。
  </para>

  <tip>
   <para>
<!--
    As an alternative to the <option>-D</option> option, you can set
    the environment variable <envar>PGDATA</envar>.
-->
<option>-D</option>オプションを使う代わりに<envar>PGDATA</envar>環境変数を設定することもできます。
    <indexterm><primary><envar>PGDATA</envar></primary></indexterm>
   </para>
  </tip>

  <para>
<!--
   Alternatively, you can run <command>initdb</command> via
   the <xref linkend="app-pg-ctl">
   program<indexterm><primary>pg_ctl</></> like so:
-->
他にも以下のように<xref linkend="app-pg-ctl"><indexterm><primary>pg_ctl</></>プログラム経由で<command>initdb</command>を実行することができます。
<screen>
<prompt>$</> <userinput>pg_ctl -D /usr/local/pgsql/data initdb</userinput>
</screen>
<!--
   This may be more intuitive if you are
   using <command>pg_ctl</command> for starting and stopping the
   server (see <xref linkend="server-start">), so
   that <command>pg_ctl</command> would be the sole command you use
   for managing the database server instance.
-->
<command>pg_ctl</command>がデータベースサーバインスタンスの管理に使用する単一のコマンドになりますので、サーバの起動や停止に<command>pg_ctl</command>を使用している場合(<xref linkend="server-start">参照)はこちらの方がより直感的かもしれません。
  </para>

  <para>
<!--
   <command>initdb</command> will attempt to create the directory you
   specify if it does not already exist.  Of course, this will fail if
   <command>initdb</command> does not have permissions to write in the
   parent directory.  It's generally recommendable that the
   <productname>PostgreSQL</productname> user own not just the data
   directory but its parent directory as well, so that this should not
   be a problem.  If the desired parent directory doesn't exist either,
   you will need to create it first, using root privileges if the
   grandparent directory isn't writable.  So the process might look
   like this:
-->
もし指定したディレクトリが存在しない場合は、<command>initdb</command>はその新しいディレクトリを作成しようとします。
もちろん、その親ディレクトリに書き込み権限がない場合<command>initdb</command>は失敗します。
<productname>PostgreSQL</productname>ユーザがデータディレクトリだけでなく、親ディレクトリも所有することを一般的に推奨します。
このようにすると問題になることはありません。
目的の親ディレクトリが存在しない場合は、まずそのディレクトリを作成する必要があります。
親の親ディレクトリが書き込み可能でない場合は、root権限を使用して作成します。
そのため、手順は下記のようになります。
<screen>
root# <userinput>mkdir /usr/local/pgsql</userinput>
root# <userinput>chown postgres /usr/local/pgsql</userinput>
root# <userinput>su postgres</userinput>
postgres$ <userinput>initdb -D /usr/local/pgsql/data</userinput>
</screen>
  </para>

  <para>
<!--
   <command>initdb</command> will refuse to run if the data directory
   exists and already contains files; this is to prevent accidentally
   overwriting an existing installation.
-->
データディレクトリが存在し、すでにファイルが含まれている場合は、<command>initdb</command>は実行を拒否します。これは、誤って既存のインストールを上書きしないようにするためです。
  </para>

  <para>
<!--
   Because the data directory contains all the data stored in the
   database, it is essential that it be secured from unauthorized
   access. <command>initdb</command> therefore revokes access
   permissions from everyone but the
   <productname>PostgreSQL</productname> user.
-->
データディレクトリにはデータベースの中のすべてのデータが保持されるため、権限を持たない人からのアクセスを確実に制限することが不可欠です。
ですから、<command>initdb</command>は<productname>PostgreSQL</productname>ユーザ以外からアクセス権を剥奪します。
  </para>

  <para>
<!--
   However, while the directory contents are secure, the default
   client authentication setup allows any local user to connect to the
   database and even become the database superuser. If you do not
   trust other local users, we recommend you use one of
   <command>initdb</command>'s <option>-W</option>, <option>&#045;&#045;pwprompt</option>
   or <option>&#045;&#045;pwfile</option> options to assign a password to the
   database superuser.<indexterm>
     <primary>password</>
     <secondary>of the superuser</>
   </indexterm>
   Also, specify <option>-A md5</> or
   <option>-A password</> so that the default <literal>trust</> authentication
   mode is not used; or modify the generated <filename>pg_hba.conf</filename>
   file after running <command>initdb</command>, but
   <emphasis>before</> you start the server for the first time. (Other
   reasonable approaches include using <literal>peer</literal> authentication
   or file system permissions to restrict connections. See <xref
   linkend="client-authentication"> for more information.)
-->
しかし、ディレクトリの内容は安全ですが、デフォルトのクライアント認証の設定では、すべてのローカルユーザはデータベースに接続でき、データベーススーパーユーザになることさえ可能です。
他のローカルユーザを信用しない場合、<command>initdb</command>の<option>-W</option>、<option>--pwprompt</option>、<option>--pwfile</option>オプションのいずれか1つを使用して、データベーススーパーユーザにパスワードを付与することを推奨します。
   <indexterm>
     <primary>パスワード</>
     <secondary>スーパーユーザの</>
   </indexterm>
また、デフォルトの<literal>trust</>認証モードを使用しないように、<option>-A md5</>もしくは<option>-A password</>を指定してください。
もしくは、<command>initdb</command>の後、初回のサーバの起動の<emphasis>前</>に、生成済みの<filename>pg_hba.conf</filename>ファイルを変更してください。
（他の穏当な方法として、<literal>peer</literal>認証やファイルシステムの権限を使用して、接続を制限することもできます。
詳細については<xref linkend="client-authentication">を参照してください。）
  </para>

  <para>
<!--
   <command>initdb</command> also initializes the default
   locale<indexterm><primary>locale</></> for the database cluster.
   Normally, it will just take the locale settings in the environment
   and apply them to the initialized database.  It is possible to
   specify a different locale for the database; more information about
   that can be found in <xref linkend="locale">.  The default sort order used
   within the particular database cluster is set by
   <command>initdb</command>, and while you can create new databases using
   different sort order, the order used in the template databases that initdb
   creates cannot be changed without dropping and recreating them.
   There is also a performance impact for using locales
   other than <literal>C</> or <literal>POSIX</>. Therefore, it is
   important to make this choice correctly the first time.
-->
<command>initdb</command>はまた、データベースクラスタのデフォルトのロケール<indexterm><primary>ロケール</></>を初期化します。
通常は、環境のロケール設定を初期化されたデータベースにそのまま適用します。
データベースに異なるロケールを指定することも可能です。
詳細については<xref linkend="locale">を参照してください。
特定のデータベースクラスタ内で使用されるデフォルトのソート順は<command>initdb</command>で設定されます。
異なるソート順を使用する新しいデータベースを作成することもできますが、initdbが作成するテンプレートデータベースで使用される順は削除して再作成しない限り変更することができません。
また、<literal>C</>や<literal>POSIX</>以外のロケールを使用する場合には性能上の影響もあります。
ですので初回にこれを正しく選択することが重要です。
  </para>

  <para>
<!--
   <command>initdb</command> also sets the default character set encoding
   for the database cluster.  Normally this should be chosen to match the
   locale setting.  For details see <xref linkend="multibyte">.
-->
また<command>initdb</command>は、データベースクラスタのデフォルトの文字セット符号化方式も設定します。
通常これは、ロケールの設定と合うものが選ばれなければなりません。
詳細は<xref linkend="multibyte">を参照してください。
  </para>

  <para>
<!--
   Non-<literal>C</> and non-<literal>POSIX</> locales rely on the
   operating system's collation library for character set ordering.
   This controls the ordering of keys stored in indexes.  For this reason,
   a cluster cannot switch to an incompatible collation library version,
   either through snapshot restore, binary streaming replication, a
   different operating system, or an operating system upgrade.
-->
非<literal>C</>および非<literal>POSIX</>のロケールでは、文字セットのソート順はオペレーティングシステムの照合ライブラリに依存しています。
これは、インデックスに格納されているキーの順序を制御します。
このためにクラスタは、スナップショットのリストア、バイナリストリーミングレプリケーション、異なるオペレーティングシステム、またはオペレーティングシステムのアップグレードのいずれでも互換性のない照合ライブラリバージョンに切り替えることは出来ません。
  </para>

  <sect2 id="creating-cluster-mount-points">
<!--
   <title>Use of Secondary File Systems</title>
-->
   <title>セカンダリファイルシステムの使用</title>

   <indexterm zone="creating-cluster-mount-points">
<!--
    <primary>file system mount points</primary>
-->
    <primary>ファイルシステムマウントポイント</primary>
   </indexterm>

   <para>
<!--
    Many installations create their database clusters on file systems
    (volumes) other than the machine's <quote>root</> volume.  If you
    choose to do this, it is not advisable to try to use the secondary
    volume's topmost directory (mount point) as the data directory.
    Best practice is to create a directory within the mount-point
    directory that is owned by the <productname>PostgreSQL</productname>
    user, and then create the data directory within that.  This avoids
    permissions problems, particularly for operations such
    as <application>pg_upgrade</>, and it also ensures clean failures if
    the secondary volume is taken offline.
-->
多くのインストールでは、マシンの<quote>ルート</>ボリューム以外のファイルシステム（ボリューム）上にデータベースクラスタを作成します。
この選択をした場合、セカンダリボリュームの最上位ディレクトリ（マウントポイント）をデータディレクトリとして使用することはお勧めできません。
最善の方法はマウントポイントディレクトリ内に<productname>PostgreSQL</productname>ユーザが所有するディレクトリを作成し、その中にデータディレクトリを作成することです。
これにより、権限の問題、特に<application>pg_upgrade</>などの操作での問題を避けることができ、またセカンダリボリュームがオフラインになったときに、確実にきれいなエラーを起こすようになります。
   </para>

  </sect2>

  <sect2 id="creating-cluster-nfs">
<!--
   <title>Use of Network File Systems</title>
-->
   <title>ネットワークファイルシステムの使用</title>

   <indexterm zone="creating-cluster-nfs">
<!--
    <primary>Network File Systems</primary>
-->
    <primary>ネットワークファイルシステム</primary>
   </indexterm>
<!--
   <indexterm><primary><acronym>NFS</></><see>Network File Systems</></>
-->
   <indexterm><primary><acronym>NFS</></><see>ネットワークファイルシステム</></>
<!--
   <indexterm><primary>Network Attached Storage (<acronym>NAS</>)</><see>Network File Systems</></>
-->
   <indexterm><primary>ネットワークアタッチドストレージ（<acronym>NAS</>）</><see>ネットワークファイルシステム</></>

   <para>
<!--
    Many installations create their database clusters on network file
    systems.  Sometimes this is done via <acronym>NFS</>, or by using a
    Network Attached Storage (<acronym>NAS</>) device that uses
    <acronym>NFS</> internally.  <productname>PostgreSQL</> does nothing
    special for <acronym>NFS</> file systems, meaning it assumes
    <acronym>NFS</> behaves exactly like locally-connected drives.
    If the client or server <acronym>NFS</> implementation does not
    provide standard file system semantics, this can
    cause reliability problems (see <ulink
    url="http://www.time-travellers.org/shane/papers/NFS_considered_harmful.html"></ulink>).
    Specifically, delayed (asynchronous) writes to the <acronym>NFS</>
    server can cause data corruption problems.  If possible, mount the
    <acronym>NFS</> file system synchronously (without caching) to avoid
    this hazard.  Also, soft-mounting the <acronym>NFS</> file system is
    not recommended.
-->
多くのインストレーションはネットワークファイルシステム上にデータベースクラスタを作成します。
直接<acronym>NFS</>を介して行うこともありますし、<acronym>NFS</>を内部的に使うネットワークアタッチドストレージ（<acronym>NAS</>）デバイスを使用することもあります。
<productname>PostgreSQL</>は<acronym>NFS</>ファイルシステムに特別なことを何も行いません。
つまり<acronym>NFS</>はローカル接続のドライブとまったく同様に振る舞うという前提です。
クライアントとサーバの<acronym>NFS</>実装が標準ファイルシステム・セマンティックスを持たないならば、信頼性の問題を引き起こす可能性があります。
（<ulink url="http://www.time-travellers.org/shane/papers/NFS_considered_harmful.html"></ulink>参照）。
具体的には、<acronym>NFS</>サーバへの遅延（非同期）書きこみがデータ破損の問題を引き起こす可能性があります。
可能ならば<acronym>NFS</>ファイルシステムを（キャッシュ無しで）同期マウントし、この危険を防止してください。更に、<acronym>NFS</>をソフトマウントすることは薦められません。
   </para>

   <para>
<!--
    Storage Area Networks (<acronym>SAN</>) typically use communication
    protocols other than <acronym>NFS</>, and may or may not be subject
    to hazards of this sort.  It's advisable to consult the vendor's
    documentation concerning data consistency guarantees.
    <productname>PostgreSQL</productname> cannot be more reliable than
    the file system it's using.
-->
ストレージエリアネットワーク（<acronym>SAN</>）は通常<acronym>NFS</>とは異なる通信プロトコルを使用し、この種の危険がある場合と無い場合があります。
これは、データの整合性の保証に関するベンダのドキュメントを参照することをお勧めします。
<productname>PostgreSQL</productname>は、使用しているファイルシステム以上に信頼性が高くなることはありません。
   </para>

  </sect2>

 </sect1>

 <sect1 id="server-start">
<!--
  <title>Starting the Database Server</title>
-->
  <title>データベースサーバの起動</title>

  <para>
<!--
   Before anyone can access the database, you must start the database
   server. The database server program is called
   <command>postgres</command>.<indexterm><primary>postgres</></>
   The <command>postgres</command> program must know where to
   find the data it is supposed to use. This is done with the
   <option>-D</option> option. Thus, the simplest way to start the
   server is:
-->
データベースにアクセスするためには、まずデータベースサーバを起動しなくてはいけません。
データベースサーバプログラムは<command>postgres</command>という名前です。
<indexterm><primary>postgres</></>
<command>postgres</command>プログラムは自分が使用するデータがどこにあるのかを知っている必要があります。
これは<option>-D</option>オプションで指定されます。
したがって、サーバを起動する一番簡単な方法は、以下のようなコマンドとなります。
<screen>
$ <userinput>postgres -D /usr/local/pgsql/data</userinput>
</screen>
<!--
   which will leave the server running in the foreground. This must be
   done while logged into the <productname>PostgreSQL</productname> user
   account. Without <option>-D</option>, the server will try to use
   the data directory named by the environment variable <envar>PGDATA</envar>.
   If that variable is not provided either, it will fail.
-->
上記のコマンドはサーバをフォアグラウンドで実行させます。
これは、<productname>PostgreSQL</productname>ユーザアカウントにログインして実行されなくてはいけません。
<option>-D</option>オプションが指定されていない場合、サーバは<envar>PGDATA</envar>環境変数で指定されたデータディレクトリを使用しようと試みます。
どちらの変数も指定されていなければ失敗します。
  </para>

  <para>
<!--
   Normally it is better to start <command>postgres</command> in the
   background.  For this, use the usual Unix shell syntax:
-->
通常はバックグラウンドで<command>postgres</command>を起動することをお勧めします。
そのためには以下のように通常のUnixシェルの構文を使います。
<screen>
$ <userinput>postgres -D /usr/local/pgsql/data &gt;logfile 2&gt;&amp;1 &amp;</userinput>
</screen>
<!--
   It is important to store the server's <systemitem>stdout</> and
   <systemitem>stderr</> output somewhere, as shown above. It will help
   for auditing purposes and to diagnose problems. (See <xref
   linkend="logfile-maintenance"> for a more thorough discussion of log
   file handling.)
-->
この例のように、サーバの<systemitem>標準出力</>と<systemitem>標準エラー</>出力をどこかに保管しておくことが重要です。
これは追跡記録的な目的と問題の原因究明に役立ちます。
（ログファイルの取り扱いについての全体的な説明については<xref linkend="logfile-maintenance">を参照してください。）
  </para>

  <para>
<!--
   The <command>postgres</command> program also takes a number of other
   command-line options. For more information, see the
   <xref linkend="app-postgres"> reference page
   and <xref linkend="runtime-config"> below.
-->
<command>postgres</command>プログラムには、この他にも多くのコマンドラインオプションを指定することができます。
詳細は<xref linkend="app-postgres">マニュアルページと後述の<xref linkend="runtime-config">を参照してください。
  </para>

  <para>
<!--
   This shell syntax can get tedious quickly.  Therefore the wrapper
   program
   <xref linkend="app-pg-ctl"><indexterm><primary>pg_ctl</primary></indexterm>
   is provided to simplify some tasks.  For example:
-->
こうしたシェル構文は長くなりがちです。そのため、
<xref linkend="app-pg-ctl"><indexterm><primary>pg_ctl</primary></indexterm>
ラッパプログラムが提供されていて、いくつかのタスクを単純化しています。
以下に例を示します。
<programlisting>
pg_ctl start -l logfile
</programlisting>
<!--
   will start the server in the background and put the output into the
   named log file. The <option>-D</option> option has the same meaning
   here as for <command>postgres</command>. <command>pg_ctl</command>
   is also capable of stopping the server.
-->
これは、サーバをバックグラウンドで起動し、出力を指定されたログファイルに書き出します。
<option>-D</option>オプションは、ここでも<command>postgres</command>の場合と同じ意味を持ちます。
<command>pg_ctl</command>によってサーバを停止させることもできます。
  </para>

  <para>
<!--
   Normally, you will want to start the database server when the
   computer boots.<indexterm>
     <primary>booting</>
     <secondary>starting the server during</>
   </indexterm>
   Autostart scripts are operating-system-specific.
   There are a few distributed with
   <productname>PostgreSQL</productname> in the
   <filename>contrib/start-scripts</> directory. Installing one will require
   root privileges.
-->
通常、コンピュータが起動された時にデータベースサーバも一緒に起動したい場合が多いと思われます。
   <indexterm>
    <primary>マシンの起動</>
    <secondary>時のサーバ起動</>
   </indexterm>
自動起動スクリプトはオペレーティングシステム固有のものです。
いくつかは<productname>PostgreSQL</productname>の<filename>/contrib/start-scripts</>ディレクトリに同梱されています。
このインストールにはおそらくroot権限が必要となります。
  </para>

  <para>
<!--
   Different systems have different conventions for starting up daemons
   at boot time. Many systems have a file
   <filename>/etc/rc.local</filename> or
   <filename>/etc/rc.d/rc.local</filename>. Others use <filename>init.d</filename> or
   <filename>rc.d</> directories. Whatever you do, the server must be
   run by the <productname>PostgreSQL</productname> user account
   <emphasis>and not by root</emphasis> or any other user. Therefore you
   probably should form your commands using
   <literal>su postgres -c '...'</literal>.  For example:
-->
起動時にデーモンを開始する方法はシステムによって異なります。
多くのシステムには<filename>/etc/rc.local</filename>ファイルや<filename>/etc/rc.d/rc.local</filename>ファイルがあります。
他のシステムでは<filename>init.d</filename>や<filename>rc.d</>ディレクトリが使用されます。
何を実行するにしても、サーバは<productname>PostgreSQL</productname>ユーザアカウントで起動させなければなりません。
<emphasis>rootであってはいけません</emphasis>し、他のユーザでもいけません。
したがって、<literal>su postgres -c '...'</literal>を使用してコマンドを実行する必要があるでしょう。
以下に例を示します。
<programlisting>
su postgres -c 'pg_ctl start -D /usr/local/pgsql/data -l serverlog'
</programlisting>
  </para>

  <para>
<!--
   Here are a few more operating-system-specific suggestions. (In each
   case be sure to use the proper installation directory and user
   name where we show generic values.)
-->
さらにいくつかのオペレーティングシステム固有の提案を挙げます。
（ここでは一般的な値で説明していますので、各項目において適切なインストールディレクトリとユーザ名に置き換えて読んでください。）

   <itemizedlist>
    <listitem>
     <para>
<!--
      For <productname>FreeBSD</productname>, look at the file
      <filename>contrib/start-scripts/freebsd</filename> in the
      <productname>PostgreSQL</productname> source distribution.
      <indexterm><primary>FreeBSD</><secondary>start script</secondary></>
-->
<productname>FreeBSD</productname>では、<productname>PostgreSQL</productname>のソース配布物の中にある<filename>contrib/start-scripts/freebsd</filename>ファイルを参照してください。
<indexterm><primary>FreeBSD</><secondary>の起動スクリプト</secondary></>
     </para>
    </listitem>

    <listitem>
     <para>
<!--
      On <productname>OpenBSD</productname>, add the following lines
      to the file <filename>/etc/rc.local</filename>:
      <indexterm><primary>OpenBSD</><secondary>start script</secondary></>
-->
<productname>OpenBSD</productname>では、以下の数行を<filename>/etc/rc.local</filename>ファイルに追加してください。
<indexterm><primary>OpenBSD</><secondary>の起動スクリプト</secondary></>
<programlisting>
if [ -x /usr/local/pgsql/bin/pg_ctl -a -x /usr/local/pgsql/bin/postgres ]; then
    su -l postgres -c '/usr/local/pgsql/bin/pg_ctl start -s -l /var/postgresql/log -D /usr/local/pgsql/data'
    echo -n ' postgresql'
fi
</programlisting>
     </para>
    </listitem>

    <listitem>
     <para>
<!--
      On <productname>Linux</productname> systems either add
      <indexterm><primary>Linux</><secondary>start script</secondary></>
-->
<productname>Linux</productname>システムでは、
<indexterm><primary>Linux</><secondary>の起動スクリプト</secondary></>
<programlisting>
/usr/local/pgsql/bin/pg_ctl start -l logfile -D /usr/local/pgsql/data
</programlisting>
<!--
      to <filename>/etc/rc.d/rc.local</filename>
      or <filename>/etc/rc.local</filename> or look at the file
      <filename>contrib/start-scripts/linux</filename> in the
      <productname>PostgreSQL</productname> source distribution.
-->
を<filename>/etc/rc.d/rc.local</filename>や<filename>/etc/rc.local</filename>に追加してください。
または、<productname>PostgreSQL</productname>のソース配布物の中にある<filename>contrib/start-scripts/linux</filename>ファイルを参照してください。
     </para>

     <para>
<!--
      When using <application>systemd</application>, you can use the following
      service unit file (e.g.,
      at <filename>/etc/systemd/system/postgresql.service</filename>):<indexterm><primary>systemd</primary></indexterm>
-->
<application>systemd</application>を使用する場合は以下のサービスユニットファイルを（例えば<filename>/etc/systemd/system/postgresql.service</filename>として）使用できます。
<programlisting>
[Unit]
Description=PostgreSQL database server
Documentation=man:postgres(1)

[Service]
Type=notify
User=postgres
ExecStart=/usr/local/pgsql/bin/postgres -D /usr/local/pgsql/data
ExecReload=/bin/kill -HUP $MAINPID
KillMode=mixed
KillSignal=SIGINT
TimeoutSec=0

[Install]
WantedBy=multi-user.target
</programlisting>
<!--
      Using <literal>Type=notify</literal> requires that the server binary was
      built with <literal>configure &#045;-with-systemd</literal>.
-->
<literal>Type=notify</literal>を使うには、サーバのバイナリが<literal>configure --with-systemd</literal>でビルドされている必要があります。
     </para>

     <para>
<!--
      Consider carefully the timeout
      setting.  <application>systemd</application> has a default timeout of 90
      seconds as of this writing and will kill a process that does not notify
      readiness within that time.  But a <productname>PostgreSQL</productname>
      server that might have to perform crash recovery at startup could take
      much longer to become ready.  The suggested value of 0 disables the
      timeout logic.
-->
タイムアウトの設定について注意深く考えてみましょう。
この文書を書いている時点で、<application>systemd</application>のデフォルトのタイムアウトは90秒で、その時間内に準備ができたことを通知しないプロセスは終了させられます。
しかし、<productname>PostgreSQL</productname>サーバは起動時にクラッシュリカバリを実行せねばならないことがあり、準備ができるまでにそれよりずっと長い時間を要することがあります。
ここで提案されている0という値は、そのタイムアウトの仕組みを無効にします。
     </para>
    </listitem>

    <listitem>
     <para>
<!--
      On <productname>NetBSD</productname>, use either the
      <productname>FreeBSD</productname> or
      <productname>Linux</productname> start scripts, depending on
      preference.
      <indexterm><primary>NetBSD</><secondary>start script</secondary></>
-->
<productname>NetBSD</productname>では、<productname>FreeBSD</productname>か<productname>Linux</productname>の好きな方の起動スクリプトを使用してください。
<indexterm><primary>NetBSD</><secondary>の起動スクリプト</secondary></>
     </para>
    </listitem>

    <listitem>
     <para>
<!--
      On <productname>Solaris</productname>, create a file called
      <filename>/etc/init.d/postgresql</filename> that contains
      the following line:
      <indexterm><primary>Solaris</><secondary>start script</secondary></>
-->
<productname>Solaris</productname>では、<filename>/etc/init.d/postgresql</filename>というファイルを作成し、そこに以下の1行を記述してください。
<indexterm><primary>Solaris</><secondary>の起動スクリプト</secondary></>
<programlisting>
su - postgres -c "/usr/local/pgsql/bin/pg_ctl start -l logfile -D /usr/local/pgsql/data"
</programlisting>
<!--
      Then, create a symbolic link to it in <filename>/etc/rc3.d</> as
      <filename>S99postgresql</>.
-->
そして、<filename>/etc/rc3.d</>以下に<filename>S99postgresql</>としてそのファイルに対するシンボリックリンクを作成してください。
     </para>
    </listitem>
   </itemizedlist>

  </para>

   <para>
<!--
    While the server is running, its
    <acronym>PID</acronym> is stored in the file
    <filename>postmaster.pid</filename> in the data directory. This is
    used to prevent multiple server instances from
    running in the same data directory and can also be used for
    shutting down the server.
-->
サーバが実行している間は、その<acronym>PID</acronym>はデータディレクトリの中の<filename>postmaster.pid</filename>ファイルに記述されています。
これは同じデータディレクトリで複数のサーバインスタンスが実行されるのを防止し、また、サーバの停止にも使うことができます。
   </para>

   <sect2 id="server-start-failures">
<!--
    <title>Server Start-up Failures</title>
-->
<title>サーバ起動の失敗</title>

    <para>
<!--
     There are several common reasons the server might fail to
     start. Check the server's log file, or start it by hand (without
     redirecting standard output or standard error) and see what error
     messages appear. Below we explain some of the most common error
     messages in more detail.
-->
サーバの起動が失敗する理由として代表的なものがいくつかあります。
サーバのログファイルを点検するか、（標準出力や標準エラーをリダイレクトせずに）手動で起動して、どのようなエラーメッセージが出ているか確認してください。
以下に、よく発生するエラーメッセージのいくつかをより詳細に説明します。
    </para>

    <para>
<screen>
LOG:  could not bind IPv4 address "127.0.0.1": Address already in use
HINT:  Is another postmaster already running on port 5432? If not, wait a few seconds and retry.
FATAL:  could not create any TCP/IP sockets
</screen>
<!--
     This usually means just what it suggests: you tried to start
     another server on the same port where one is already running.
     However, if the kernel error message is not <computeroutput>Address
     already in use</computeroutput> or some variant of that, there might
     be a different problem. For example, trying to start a server
     on a reserved port number might draw something like:
-->
これはたいていの場合メッセージが示す通りの意味です。
既にサーバが動いているポートで別のサーバを起動しようとしたことを示しています。
しかし、カーネルエラーメッセージが<computeroutput>Address already in use</computeroutput>やそれに類似したものではない場合は、別の問題の可能性もあります。
例えば、予約済みのポート番号でサーバを起動しようとすると下記のようなメッセージが出るかもしれません。
<screen>
$ <userinput>postgres -p 666</userinput>
LOG:  could not bind IPv4 address "127.0.0.1": Permission denied
HINT:  Is another postmaster already running on port 666? If not, wait a few seconds and retry.
FATAL:  could not create any TCP/IP sockets
</screen>
    </para>

    <para>
<!--
     A message like:
-->
次のようなメッセージが表示された場合、
<screen>
FATAL:  could not create shared memory segment: Invalid argument
DETAIL:  Failed system call was shmget(key=5440001, size=4011376640, 03600).
</screen>
<!--
     probably means your kernel's limit on the size of shared memory is
     smaller than the work area <productname>PostgreSQL</productname>
     is trying to create (4011376640 bytes in this example). Or it could
     mean that you do not have System-V-style shared memory support
     configured into your kernel at all. As a temporary workaround, you
     can try starting the server with a smaller-than-normal number of
     buffers (<xref linkend="guc-shared-buffers">). You will eventually want
     to reconfigure your kernel to increase the allowed shared memory
     size. You might also see this message when trying to start multiple
     servers on the same machine, if their total space requested
     exceeds the kernel limit.
-->
これは、おそらくカーネルによる共有メモリのサイズの上限が<productname>PostgreSQL</productname>が作ろうとしている作業領域（この例では4011376640バイト）よりも小さいことを示しています。
または、System V方式の共有メモリサポートがカーネルにまったく設定されていない可能性もあります。
一時的な策として、サーバを通常よりも少ないバッファ数（<xref linkend="guc-shared-buffers">）で起動することもできます。
しかし最終的には、カーネルを再設定し、使用可能な共有メモリサイズを増やした方が良いでしょう。
このメッセージは、同じマシン上で複数のサーバを起動しようとした時に、要求された領域の合計がカーネルの上限を超えた場合にも表示されます。
    </para>

    <para>
<!--
     An error like:
-->
下記のようなエラーの場合:
<screen>
FATAL:  could not create semaphores: No space left on device
DETAIL:  Failed system call was semget(5440126, 17, 03600).
</screen>
<!--
     does <emphasis>not</emphasis> mean you've run out of disk
     space. It means your kernel's limit on the number of <systemitem
     class="osname">System V</> semaphores is smaller than the number
     <productname>PostgreSQL</productname> wants to create. As above,
     you might be able to work around the problem by starting the
     server with a reduced number of allowed connections
     (<xref linkend="guc-max-connections">), but you'll eventually want to
     increase the kernel limit.
-->
ディスクの空き容量がなくなったということを示しているわけでは<emphasis>ありません</emphasis>。
これはカーネルの<systemitem class="osname">System V</>セマフォの上限が、<productname>PostgreSQL</productname>が作成しようとしている数よりも小さいということを意味しています。
上記のように、許可される接続の数（<xref linkend="guc-max-connections">）を減らしてサーバを起動させることで問題は回避できるかもしれませんが、最終的にはカーネルの設定を変えてセマフォの上限を増やした方が良いでしょう。
    </para>

    <para>
<!--
     If you get an <quote>illegal system call</> error, it is likely that
     shared memory or semaphores are not supported in your kernel at
     all. In that case your only option is to reconfigure the kernel to
     enable these features.
-->
<quote>不正なシステムコール</>のエラーが発生した場合は、使用しているカーネルでは共有メモリやセマフォがまったくサポートされていない可能性があります。
その場合、これらの機能を使えるようにカーネルを設定し直すことが唯一の選択肢となります。
    </para>

    <para>
<!--
     Details about configuring <systemitem class="osname">System V</>
     <acronym>IPC</> facilities are given in <xref linkend="sysvipc">.
-->
<systemitem class="osname">System V</> <acronym>IPC</>設備の設定についての詳細は<xref linkend="sysvipc">を参照してください。
    </para>
   </sect2>

   <sect2 id="client-connection-problems">
<!--
    <title>Client Connection Problems</title>
-->
<title>クライアント接続の問題</title>

    <para>
<!--
     Although the error conditions possible on the client side are quite
     varied and application-dependent, a few of them might be directly
     related to how the server was started. Conditions other than
     those shown below should be documented with the respective client
     application.
-->
クライアント側で起こり得るエラー状態はきわめて多様で、アプリケーションに依存します。
その中のいくつかはサーバが起動された方法と直接関係するかもしれません。
以下で説明する以外の状態については各々のクライアントアプリケーションの資料を参照してください。
    </para>

    <para>
<screen>
psql: could not connect to server: Connection refused
        Is the server running on host "server.joe.com" and accepting
        TCP/IP connections on port 5432?
</screen>
<!--
     This is the generic <quote>I couldn't find a server to talk
     to</quote> failure. It looks like the above when TCP/IP
     communication is attempted. A common mistake is to forget to
     configure the server to allow TCP/IP connections.
-->
これは一般的な<quote>接続するサーバが見つけられませんでした</quote>という失敗です。
TCP/IP通信を試みた時に上記のように表示されます。
よくある間違いはサーバにTCP/IPを許可する設定を忘れていることです。
    </para>

    <para>
<!--
     Alternatively, you'll get this when attempting Unix-domain socket
     communication to a local server:
-->
代わりに、ローカルのサーバにUnixソケット通信を試みると下記のような表示が出ます。
<screen>
psql: could not connect to server: No such file or directory
        Is the server running locally and accepting
        connections on Unix domain socket "/tmp/.s.PGSQL.5432"?
</screen>
    </para>

    <para>
<!--
     The last line is useful in verifying that the client is trying to
     connect to the right place. If there is in fact no server
     running there, the kernel error message will typically be either
     <computeroutput>Connection refused</computeroutput> or
     <computeroutput>No such file or directory</computeroutput>, as
     illustrated. (It is important to realize that
     <computeroutput>Connection refused</computeroutput> in this context
     does <emphasis>not</emphasis> mean that the server got your
     connection request and rejected it. That case will produce a
     different message, as shown in <xref
     linkend="client-authentication-problems">.) Other error messages
     such as <computeroutput>Connection timed out</computeroutput> might
     indicate more fundamental problems, like lack of network
     connectivity.
-->
最後の行は、クライアントが正しいところに接続しようとしていることを実証するのに役立ちます。
もしそこに動いているサーバがない場合、典型的なカーネルエラーメッセージは、表示されているように<computeroutput>Connection refused</computeroutput>もしくは<computeroutput>No such file or directory</computeroutput>となります。
（この場合の<computeroutput>Connection refused</computeroutput>はサーバが接続要求を受け付けた後に拒否したわけでは<emphasis>ない</emphasis>ということを理解しておくことが大切です。
もしそうだった場合は<xref linkend="client-authentication-problems">で示されるような別のメッセージが表示されます。）
<computeroutput>Connection timed out</computeroutput>のような他のメッセージは、例えばネットワーク接続の欠如のようなもっと根本的な問題を表しています。
    </para>
   </sect2>
  </sect1>

 <sect1 id="kernel-resources">
<!--
  <title>Managing Kernel Resources</title>
-->
  <title>カーネルリソースの管理</title>

  <para>
<!--
   <productname>PostgreSQL</> can sometimes exhaust various operating system
   resource limits, especially when multiple copies of the server are running
   on the same system, or in very large installations.  This section explains
   the kernel resources used by <productname>PostgreSQL</> and the steps you
   can take to resolve problems related to kernel resource consumption.
-->
<productname>PostgreSQL</>は、特に同一システム上で複数のサーバコピーを実行している場合や非常に大規模なインストレーションでは、オペレーティングシステムの様々なリソース制限を超えてしまうことがあります。
本節では、<productname>PostgreSQL</>で使用されるカーネルリソース、およびカーネルリソース消費に関連した問題を解消する時に取ることができる手順について説明します。
  </para>

  <sect2 id="sysvipc">
<!--
   <title>Shared Memory and Semaphores</title>
-->
   <title>共有メモリとセマフォ</title>

   <indexterm zone="sysvipc">
<!--
    <primary>shared memory</primary>
-->
    <primary>共有メモリ</primary>
   </indexterm>

   <indexterm zone="sysvipc">
<!--
    <primary>semaphores</primary>
-->
    <primary>セマフォ</primary>
   </indexterm>

   <para>
<!--
    <productname>PostgreSQL</> requires the operating system to provide
    inter-process communication (<acronym>IPC</>) features, specifically
    shared memory and semaphores.  Unix-derived systems typically provide
    <quote><systemitem class="osname">System V</></> <acronym>IPC</>,
    <quote><systemitem class="osname">POSIX</></> <acronym>IPC</>, or both.
    <systemitem class="osname">Windows</> has its own implementation of
    these features and is not discussed here.
-->
<productname>PostgreSQL</>はオペレーティングシステムが、プロセス間通信(<acronym>IPC</>)特に共有メモリとセマフォ機能を提供することを要求します。
Unix（派生）システムでは、<quote><systemitem class="osname">System V</></> <acronym>IPC</>や、<quote><systemitem class="osname">POSIX</></> <acronym>IPC</>、またはその両方を提供します。
<systemitem class="osname">Windows</>は、これらの機能を独自で実装しているため、ここでは説明しません。
   </para>

   <para>
<!--
    The complete lack of these facilities is usually manifested by an
    <quote><errorname>Illegal system call</></quote> error upon server
    start.  In that case there is no alternative but to reconfigure your
    kernel.  <productname>PostgreSQL</> won't work without them.
    This situation is rare, however, among modern operating systems.
-->
これらの機能の完全な欠落は、サーバ起動時の<quote><errorname>Illegal system call</></quote>エラーによって判明します。
その場合はカーネルを設定し直すしかありません。
<productname>PostgreSQL</>はこれらの機能なしでは動きません。
しかし最近のオペレーティングシステムではこうした状況はまれなものです。
   </para>

   <para>
<!--
    Upon starting the server, <productname>PostgreSQL</> normally allocates
    a very small amount of System V shared memory, as well as a much larger
    amount of POSIX (<function>mmap</>) shared memory.
    In addition a significant number of semaphores, which can be either
    System V or POSIX style, are created at server startup.  Currently,
    POSIX semaphores are used on Linux and FreeBSD systems while other
    platforms use System V semaphores.
-->
サーバの起動時、<productname>PostgreSQL</>は通常、非常に少量のSystem V共有メモリと、もっと大量のPOSIX (<function>mmap</>)共有メモリを持ちます。
さらに、System V又はPOSIXスタイルのどちらかのセマフォがサーバの起動時に作成されます。
現在、LinuxとFreeBSDシステムではPOSIXセマフォが使用され、それ以外のプラットフォームではSystem Vセマフォが使用されます。
   </para>

   <note>
    <para>
<!--
     Prior to <productname>PostgreSQL</> 9.3, only System V shared memory
     was used, so the amount of System V shared memory required to start the
     server was much larger.  If you are running an older version of the
     server, please consult the documentation for your server version.
-->
<productname>PostgreSQL</> 9.3より前では、System V共有メモリだけが使用されていたので、サーバを起動させるために必要なSystem V共有メモリの量は非常に大きなものでした。
より古いバージョンのサーバで実行しているのであれば、該当するバージョンのサーバの文書を参照してください。
    </para>
   </note>

   <para>
<!--
    System V <acronym>IPC</> features are typically constrained by
    system-wide allocation limits.
    When <productname>PostgreSQL</> exceeds one of these limits,
    the server will refuse to start and
    should leave an instructive error message describing the problem
    and what to do about it. (See also <xref
    linkend="server-start-failures">.) The relevant kernel
    parameters are named consistently across different systems; <xref
    linkend="sysvipc-parameters"> gives an overview. The methods to set
    them, however, vary. Suggestions for some platforms are given below.
-->
System V <acronym>IPC</>機能は、通常システム全体の割り当て制限に制約されます。
<productname>PostgreSQL</>がこれらの制限のいずれかを超えると、サーバは起動を拒否し、問題および何をすべきかを説明するエラーメッセージを残します。
（<xref linkend="server-start-failures"> も参照してください。）
関係するカーネルパラメータは別々のシステム上でも統一して名付けられています。
<xref linkend="sysvipc-parameters">で概略がわかります。
しかしこれらを設定するための方法は異なります。
以下に、いくつかのプラットフォームへの提案を挙げます。
   </para>

   <table id="sysvipc-parameters">
<!--
    <title><systemitem class="osname">System V</> <acronym>IPC</> Parameters</title>
-->
    <title><systemitem class="osname">System V</> <acronym>IPC</>パラメータ</title>

    <tgroup cols="3">
     <thead>
      <row>
<!--
       <entry>Name</>
       <entry>Description</>
       <entry>Values needed to run one <productname>PostgreSQL</> instance</>
-->
<entry>名前</>
<entry>説明</>
<entry>一つの<productname>PostgreSQL</>インスタンスに必要な値</>
      </row>
     </thead>

     <tbody>
      <row>
       <entry><varname>SHMMAX</></>
<!--
       <entry>Maximum size of shared memory segment (bytes)</>
       <entry>at least 1kB, but the default is usually much higher</entry>
-->
<entry>共有メモリセグメントの最大サイズ（バイト）</>
<entry>最小でも1キロバイト（ただしデフォルトはもっと多くなっています）</entry>
      </row>

      <row>
       <entry><varname>SHMMIN</></>
<!--
       <entry>Minimum size of shared memory segment (bytes)</>
-->
<entry>共有メモリセグメントの最小サイズ（バイト）</>
       <entry>1</>
      </row>

      <row>
       <entry><varname>SHMALL</></>
<!--
       <entry>Total amount of shared memory available (bytes or pages)</>
       <entry>same as <varname>SHMMAX</varname> if bytes,
        or <literal>ceil(SHMMAX/PAGE_SIZE)</literal> if pages,
        plus room for other applications</>
-->
<entry>使用可能な共有メモリの総量（バイトまたはページ）</>
<entry>バイト指定の場合は<varname>SHMMAX</varname>と同じ。ページ指定の場合は<literal>ceil(SHMMAX/PAGE_SIZE)</literal>。 + 他のアプリケーション用の空間</>
      </row>

      <row>
       <entry><varname>SHMSEG</></>
<!--
       <entry>Maximum number of shared memory segments per process</>
       <entry>only 1 segment is needed, but the default is much higher</>
-->
<entry>プロセスごとの共有メモリセグメントの最大数</>
<entry>必要なのは1セグメントのみ（ただしデフォルトはもっと多くなっています）</>
      </row>

       <row>
        <entry><varname>SHMMNI</></>
<!--
        <entry>Maximum number of shared memory segments system-wide</>
        <entry>like <varname>SHMSEG</> plus room for other applications</>
-->
<entry>システム全体の共有メモリセグメントの最大数</>
<entry><varname>SHMSEG</>と同様 + 他のアプリケーション用の空間</>
       </row>

       <row>
        <entry><varname>SEMMNI</></>
<!--
        <entry>Maximum number of semaphore identifiers (i.e., sets)</>
        <entry>at least <literal>ceil((max_connections + autovacuum_max_workers + max_worker_processes + 5) / 16)</literal> plus room for other applications</>
-->
<entry>セマフォ識別子の最大数（つまりセット）</>
<entry>最低<literal>ceil((max_connections + autovacuum_max_workers + max_worker_processes + 5) / 16)</literal> + 他のアプリケーション用の空間</>
       </row>

       <row>
        <entry><varname>SEMMNS</></>
<!--
        <entry>Maximum number of semaphores system-wide</>
        <entry><literal>ceil((max_connections + autovacuum_max_workers + max_worker_processes + 5) / 16) * 17</literal> plus room for other applications</>
-->
<entry>システム全体のセマフォの最大数</>
<entry><literal>ceil((max_connections + autovacuum_max_workers + max_worker_processes + 5) / 16) * 17</literal> + 他のアプリケーション用の空間</>
       </row>

       <row>
        <entry><varname>SEMMSL</></>
<!--
        <entry>Maximum number of semaphores per set</>
        <entry>at least 17</>
-->
<entry>セットごとのセマフォの最大数</>
        <entry>最低17</>
       </row>

       <row>
        <entry><varname>SEMMAP</></>
<!--
        <entry>Number of entries in semaphore map</>
        <entry>see text</>
-->
<entry>セマフォマップの中の項目の数</>
<entry>本文を参照</>
       </row>

       <row>
        <entry><varname>SEMVMX</></>
<!--
        <entry>Maximum value of semaphore</>
        <entry>at least 1000 (The default is often 32767; do not change unless necessary)</>
-->
<entry>セマフォの最大値</>
<entry>最低1000（デフォルトはしばしば32767ですが、必要がなければ変更しないでください）</>
       </row>

     </tbody>
    </tgroup>
   </table>

   <para>
<!--
    <productname>PostgreSQL</> requires a few bytes of System V shared memory
    (typically 48 bytes, on 64-bit platforms) for each copy of the server.
    On most modern operating systems, this amount can easily be allocated.
    However, if you are running many copies of the server, or if other
    applications are also using System V shared memory, it may be necessary to
    increase <varname>SHMALL</>, which is the total amount of System V shared
    memory system-wide.  Note that <varname>SHMALL</> is measured in pages
    rather than bytes on many systems.
-->
<productname>PostgreSQL</>は、サーバのコピー毎にSystem V共有メモリの数バイト（64ビットプラットフォームでは通常48バイト）を必要とします。
最近のほとんどのオペレーティングシステムでは、このくらいの量は簡単に割り当てられます。
しかし複数のサーバのコピーを実行している場合やSystem V共有メモリを使用する他のアプリケーションを実行している場合は、システム全体のSystem V共有メモリである<varname>SHMALL</>を増加させる必要があるかもしれません。
多くのシステムでは<varname>SHMALL</>をバイト単位ではなくページ単位で測ることに注意してください。
   </para>

   <para>
<!--
    Less likely to cause problems is the minimum size for shared
    memory segments (<varname>SHMMIN</>), which should be at most
    approximately 32 bytes for <productname>PostgreSQL</> (it is
    usually just 1). The maximum number of segments system-wide
    (<varname>SHMMNI</>) or per-process (<varname>SHMSEG</>) are unlikely
    to cause a problem unless your system has them set to zero.
-->
問題が少ないのは共有メモリセグメントの最小サイズ（<varname>SHMMIN</>）で、<productname>PostgreSQL</>では最大でもおよそ32バイトのはずです（通常では1です）。
システム全体のセグメントの最大数（<varname>SHMMNI</>）もしくはプロセスごとのセグメントの最大数（<varname>SHMSEG</>）に関して、使用しているシステムで0に設定されていない限り、問題が起きることはほぼありません。
   </para>

   <para>
<!--
    When using System V semaphores,
    <productname>PostgreSQL</> uses one semaphore per allowed connection
    (<xref linkend="guc-max-connections">), allowed autovacuum worker process
    (<xref linkend="guc-autovacuum-max-workers">) and allowed background
    process (<xref linkend="guc-max-worker-processes">), in sets of 16.
    Each such set will
    also contain a 17th semaphore which contains a <quote>magic
    number</quote>, to detect collision with semaphore sets used by
    other applications. The maximum number of semaphores in the system
    is set by <varname>SEMMNS</>, which consequently must be at least
    as high as <varname>max_connections</> plus
    <varname>autovacuum_max_workers</> plus <varname>max_worker_processes</>,
    plus one extra for each 16
    allowed connections plus workers (see the formula in <xref
    linkend="sysvipc-parameters">).  The parameter <varname>SEMMNI</>
    determines the limit on the number of semaphore sets that can
    exist on the system at one time.  Hence this parameter must be at
    least <literal>ceil((max_connections + autovacuum_max_workers + max_worker_processes + 5) / 16)</>.
    Lowering the number
    of allowed connections is a temporary workaround for failures,
    which are usually confusingly worded <quote>No space
    left on device</>, from the function <function>semget</>.
-->
System V セマフォを使用している場合、<productname>PostgreSQL</>は、許可した接続（<xref linkend="guc-max-connections">）、許可したオートバキュームワーカプロセス（<xref linkend="guc-autovacuum-max-workers">）、許可したバックエンドプロセス(<xref linkend="guc-max-worker-processes">)ごとに1つのセマフォを使用し、16個のセマフォをセットとして扱います。
それぞれそのようなセットは、他のアプリケーションに使われているセマフォセットとの衝突を検出するための<quote>マジックナンバー</quote>が含まれている17個目のセマフォを持っています。
システム内のセマフォの最大数は<varname>SEMMNS</>によって設定され、その結果としてその値は少なくとも<varname>max_connections</>＋<varname>autovacuum_max_workers</>＋<varname>max_worker_processes</>と同じ、ただし、許可された接続とワーカ16個ごとに余分な1個を加えた値以上はなければいけません（<xref linkend="sysvipc-parameters">の公式を参照してください）。
<varname>SEMMNI</>パラメータはシステム上に同時に存在できるセマフォ集合の数の上限を決定します。
ですから、このパラメータは少なくとも<literal>ceil((max_connections + autovacuum_max_workers + max_worker_processes + 5) / 16)</>以上はなくてはいけません。
一時的な失敗の回避策としては許可される接続の数を下げることができますが、<quote>No space left on device</>という紛らわしい言葉が<function>semget</>関数から表示されます。
   </para>

   <para>
<!--
    In some cases it might also be necessary to increase
    <varname>SEMMAP</> to be at least on the order of
    <varname>SEMMNS</>. This parameter defines the size of the semaphore
    resource map, in which each contiguous block of available semaphores
    needs an entry. When a semaphore set is freed it is either added to
    an existing entry that is adjacent to the freed block or it is
    registered under a new map entry. If the map is full, the freed
    semaphores get lost (until reboot). Fragmentation of the semaphore
    space could over time lead to fewer available semaphores than there
    should be.
-->
場合によっては<varname>SEMMAP</>を少なくとも<varname>SEMMNS</>と同程度に増やすことが必要になる場合があるかもしれません。
このパラメータはセマフォリソースマップのサイズを定義し、その中では有効なセマフォのそれぞれの隣接したブロックの項目が必要です。
セマフォ集合が解放されると、解放されたブロックに隣接する既に存在する項目に追加されるか、もしくは新しいマップの項目の下に登録されます。
もしマップが一杯だった場合、解放されたセマフォは（再起動するまで）失われます。
セマフォ空間の断片化により時間が経つごとに、有効なセマフォがあるべき量よりも少なくなる可能性があります。
   </para>

   <para>
<!--
    Various other settings related to <quote>semaphore undo</>, such as
    <varname>SEMMNU</> and <varname>SEMUME</>, do not affect
    <productname>PostgreSQL</>.
-->
<varname>SEMMNU</>と<varname>SEMUME</>のような、その他の様々な<quote>semaphore undo</>に関する設定は<productname>PostgreSQL</>には影響を与えません。
   </para>

   <para>
<!--
    When using POSIX semaphores, the number of semaphores needed is the
    same as for System V, that is one semaphore per allowed connection
    (<xref linkend="guc-max-connections">), allowed autovacuum worker process
    (<xref linkend="guc-autovacuum-max-workers">) and allowed background
    process (<xref linkend="guc-max-worker-processes">).
    On the platforms where this option is preferred, there is no specific
    kernel limit on the number of POSIX semaphores.
-->
POSIXセマフォを使用している場合、System Vと同じ数のセマフォを必要とします。
つまり、許可した接続（<xref linkend="guc-max-connections">）、許可したオートバキュームワーカプロセス（<xref linkend="guc-autovacuum-max-workers">）、許可したバックエンドプロセス(<xref linkend="guc-max-worker-processes">)ごとに1つのセマフォを使用します。
このオプションが優先されるプラットフォームでは、POSIXセマフォの数に特定のカーネル制限はありません。
   </para>


    <variablelist>
     <varlistentry>
      <term><systemitem class="osname">AIX</>
<!--
      <indexterm><primary>AIX</><secondary>IPC configuration</></>
-->
      <indexterm><primary>AIX</><secondary>IPCの設定</></>
      </term>
      <listitem>
       <para>
<!--
        At least as of version 5.1, it should not be necessary to do
        any special configuration for such parameters as
        <varname>SHMMAX</varname>, as it appears this is configured to
        allow all memory to be used as shared memory.  That is the
        sort of configuration commonly used for other databases such
        as <application>DB/2</application>.</para>
-->
少なくともバージョン5.1では、すべてのメモリが共有メモリとして使用できるように設定されているようにみえますので、<varname>SHMMAX</varname>などのパラメータに対して特別な設定は必要ありません。
これは<application>DB/2</application>などの他のデータベースでも使用される、一般的な設定方法です。

       </para>
<!--
       <para> It might, however, be necessary to modify the global
       <command>ulimit</command> information in
       <filename>/etc/security/limits</filename>, as the default hard
       limits for file sizes (<varname>fsize</varname>) and numbers of
       files (<varname>nofiles</varname>) might be too low.
-->
       <para>
しかし、<filename>/etc/security/limits</filename>内の大域的な<command>ulimit</command>情報は変更しなければならないかもしれません。
デフォルトのファイルサイズ（<varname>fsize</varname>）とファイル数（<varname>nofiles</varname>）用のハードリミットは低過ぎるかもしれないためです。
       </para>
      </listitem>
     </varlistentry>


     <varlistentry>
      <term><systemitem class="osname">FreeBSD</>
<!--
      <indexterm><primary>FreeBSD</><secondary>IPC configuration</></>
-->
      <indexterm><primary>FreeBSD</><secondary>IPC設定</></>
      </term>
      <listitem>
       <para>
<!--
        The default settings can be changed using
        the <command>sysctl</command> or
        <command>loader</command> interfaces.  The following
        parameters can be set using <command>sysctl</command>:
-->
デフォルトの設定は<command>sysctl</command>または<command>loader</command>インタフェースを使用して変更を行うことができます。
以下では<command>sysctl</command>を使用してパラメータを変更しています。
<screen>
<prompt>#</prompt> <userinput>sysctl kern.ipc.shmall=32768</userinput>
<prompt>#</prompt> <userinput>sysctl kern.ipc.shmmax=134217728</userinput>
</screen>
<!--
        To make these settings persist over reboots, modify
        <filename>/etc/sysctl.conf</filename>.
-->
これらの設定を再起動しても永続化するには、<filename>/etc/sysctl.conf</filename>を変更します。
       </para>

       <para>
<!--
        These semaphore-related settings are read-only as far as
        <command>sysctl</command> is concerned, but can be set in
        <filename>/boot/loader.conf</filename>:
-->
セマフォ関連の設定は<command>sysctl</command>では読み取りのみとみなされていますが、<filename>/boot/loader.conf</filename>内で設定することができます。
<programlisting>
kern.ipc.semmni=256
kern.ipc.semmns=512
kern.ipc.semmnu=256
</programlisting>
<!--
        After modifying these values a reboot is required for the new
        settings to take effect.
        (Note: FreeBSD does not use <varname>SEMMAP</>.  Older versions
        would accept but ignore a setting for <literal>kern.ipc.semmap</>;
        newer versions reject it altogether.)
-->
これらの値を変更した後、新しい設定を有効にするためには再起動が必要です。
(注意: FreeBSD は<varname>SEMMAP</>を使用しません。古いバージョンは<literal>kern.ipc.semmap</>の設定を受け入れますが無視します; 新しいバージョンでは拒否します。)
       </para>

       <para>
<!--
        You might also want to configure your kernel to lock shared
        memory into RAM and prevent it from being paged out to swap.
        This can be accomplished using the <command>sysctl</command>
        setting <literal>kern.ipc.shm_use_phys</literal>.
-->
また、共有メモリをRAM上に固定して、スワップによってページアウトされるのを避けるために、カーネルを設定したいと考えるかもしれません。
これは<command>sysctl</command>を使用して<literal>kern.ipc.shm_use_phys</literal>を設定することで実現できます。
       </para>

       <para>
<!--
        If running in FreeBSD jails by enabling <application>sysctl</>'s
        <literal>security.jail.sysvipc_allowed</>, <application>postmaster</>s
        running in different jails should be run by different operating system
        users.  This improves security because it prevents non-root users
        from interfering with shared memory or semaphores in different jails,
        and it allows the PostgreSQL IPC cleanup code to function properly.
        (In FreeBSD 6.0 and later the IPC cleanup code does not properly detect
        processes in other jails, preventing the running of postmasters on the
        same port in different jails.)
-->
<application>sysctl</>の<literal>security.jail.sysvipc_allowed</>を有効にしてFreeBSD jailを実行している場合、異なるjailで実行する<application>postmaster</>を別のオペレーティングシステムユーザで実行しなければなりません。
これは、非特権ユーザが別のjailの共有メモリやセマフォに干渉することを防止できるため、セキュリティが向上します。
また、これによりPostgreSQLのIPCを整理するコードを適切に動作させることができます。
（FreeBSD 6.0以降では、IPC整理コードは他のjailにおけるプロセスを適切に検出せず、異なるjailで同一ポートでpostmasterを実行させることができません。）
       </para>

       <para>
<!--
        <systemitem class="osname">FreeBSD</> versions before 4.0 work like
        <systemitem class="osname">OpenBSD</> (see below).
-->
<systemitem class="osname">FreeBSD</>バージョン4.0以前では、（後述の）<systemitem class="osname">OpenBSD</>と同様に動作します。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><systemitem class="osname">NetBSD</>
<!--
      <indexterm><primary>NetBSD</><secondary>IPC configuration</></>
-->
      <indexterm><primary>NetBSD</><secondary>IPC設定</></>
      </term>
      <listitem>
       <para>
<!--
        In <systemitem class="osname">NetBSD</> 5.0 and later,
        IPC parameters can be adjusted using <command>sysctl</command>,
        for example:
-->
<systemitem class="osname">NetBSD</> 5.0以降では、以下の例のようにIPCパラメータを<command>sysctl</command>を用いて調整することができます。
<screen>
<prompt>$</prompt> <userinput>sysctl -w kern.ipc.shmmax=16777216</userinput>
</screen>
<!--
        To have these settings persist over reboots, modify
        <filename>/etc/sysctl.conf</filename>.
-->
この設定を再起動しても永続化させるためには<filename>/etc/sysctl.conf</filename>を編集してください。
       </para>

       <para>
<!--
        You might also want to configure your kernel to lock shared
        memory into RAM and prevent it from being paged out to swap.
        This can be accomplished using the <command>sysctl</command>
        setting <literal>kern.ipc.shm_use_phys</literal>.
-->
また、共有メモリをRAM上に固定して、スワップによってページアウトされるのを避けるために、カーネルを設定したいと考えるかもしれません。
これは<command>sysctl</command>を使用して<literal>kern.ipc.shm_use_phys</literal>を設定することで実現できます。
       </para>

       <para>
<!--
        <systemitem class="osname">NetBSD</> versions before 5.0 work like
        <systemitem class="osname">OpenBSD</> (see below), except that
        parameters should be set with the keyword <literal>options</> not
        <literal>option</>.
-->
5.0より前のバージョンの<systemitem class="osname">NetBSD</>では、（後述の）<systemitem class="osname">OpenBSD</>のように動作します。
ただし、パラメータは<literal>option</>ではなく<literal>options</>キーワードを付けて設定する必要があります。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><systemitem class="osname">OpenBSD</>
<!--
      <indexterm><primary>OpenBSD</><secondary>IPC configuration</></>
-->
      <indexterm><primary>OpenBSD</><secondary>IPC設定</></>
      </term>
      <listitem>
       <para>
<!--
        The options <varname>SYSVSHM</> and <varname>SYSVSEM</> need
        to be enabled when the kernel is compiled. (They are by
        default.) The maximum size of shared memory is determined by
        the option <varname>SHMMAXPGS</> (in pages). The following
        shows an example of how to set the various parameters:
-->
<varname>SYSVSHM</>オプションと<varname>SYSVSEM</>オプションはカーネルのコンパイル時に有効にする必要があります（デフォルトでは有効になっています）。
共有メモリの最大サイズは<varname>SHMMAXPGS</>オプション（ページ数）で決定されます。
以下に様々なパラメータの設定方法の例を示します。
<programlisting>
option        SYSVSHM
option        SHMMAXPGS=4096
option        SHMSEG=256

option        SYSVSEM
option        SEMMNI=256
option        SEMMNS=512
option        SEMMNU=256
option        SEMMAP=256
</programlisting>
       </para>

       <para>
<!--
        You might also want to configure your kernel to lock shared
        memory into RAM and prevent it from being paged out to swap.
        This can be accomplished using the <command>sysctl</command>
        setting <literal>kern.ipc.shm_use_phys</literal>.
-->
また、共有メモリをRAM上に固定して、スワップによってページアウトされるのを避けるために、カーネルを設定したいと考えるかもしれません。
これは<command>sysctl</command>を使用して<literal>kern.ipc.shm_use_phys</literal>を設定することで実現できます。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><systemitem class="osname">HP-UX</>
<!--
      <indexterm><primary>HP-UX</><secondary>IPC configuration</></>
-->
      <indexterm><primary>HP-UX</><secondary>IPC設定</></>
      </term>
      <listitem>
       <para>
<!--
        The default settings tend to suffice for normal installations.
        On <productname>HP-UX</> 10, the factory default for
        <varname>SEMMNS</> is 128, which might be too low for larger
        database sites.
-->
デフォルトの設定は通常のインストールではほぼ十分です。
<productname>HP-UX</> 10では<varname>SEMMNS</>の出荷時のデフォルトは128ですが、これは大規模なデータベースサイトには低過ぎるかもしれません。
       </para>
       <para>
<!--
        <acronym>IPC</> parameters can be set in the <application>System
        Administration Manager</> (<acronym>SAM</>) under
        <menuchoice><guimenu>Kernel
        Configuration</><guimenuitem>Configurable Parameters</></>. Choose
        <guibutton>Create A New Kernel</> when you're done.
-->
<acronym>IPC</>パラメータは<application>システム管理マネージャ</>（<acronym>SAM</>）から<menuchoice><guimenu>Kernel Configuration</><guimenuitem>Configurable Parameters</></>の下で、設定することができます。
終わったら<guibutton>Create A New Kernel</>を選択してください。
       </para>
      </listitem>
     </varlistentry>


     <varlistentry>
      <term><systemitem class="osname">Linux</>
<!--
      <indexterm><primary>Linux</><secondary>IPC configuration</></>
-->
      <indexterm><primary>Linux</><secondary>IPC設定</></>
      </term>
      <listitem>
       <para>
<!--
        The default maximum segment size is 32 MB, and the
        default maximum total size is 2097152
        pages.  A page is almost always 4096 bytes except in unusual
        kernel configurations with <quote>huge pages</quote>
        (use <literal>getconf PAGE_SIZE</literal> to verify).
-->
デフォルトの最大セグメントサイズは32メガバイト、デフォルトの最大総サイズは2097152ページです。
<quote>huge pages</quote>を持つ通常ではないカーネル設定を除き、1ページはほとんど常に4096バイトです。
(検証には<literal>getconf PAGE_SIZE</literal>を使用してください。)
       </para>

       <para>
<!--
        The shared memory size settings can be changed via the
        <command>sysctl</command> interface.  For example, to allow 16 GB:
-->
共有メモリサイズの設定は<command>sysctl</command>インタフェースを使用して変更可能です。
例えば16ギガバイトまで許すには以下のようにします。
<screen>
<prompt>$</prompt> <userinput>sysctl -w kernel.shmmax=17179869184</userinput>
<prompt>$</prompt> <userinput>sysctl -w kernel.shmall=4194304</userinput>
</screen>
<!--
        In addition these settings can be preserved between reboots in
        the file <filename>/etc/sysctl.conf</filename>.  Doing that is
        highly recommended.
-->
更にこれらの設定を再起動時に保持できるように<filename>/etc/sysctl.conf</filename>に保存することができます。
こうすることを大いに勧めます。
       </para>

       <para>
<!--
        Ancient distributions might not have the <command>sysctl</command> program,
        but equivalent changes can be made by manipulating the
        <filename>/proc</filename> file system:
-->
古めのディストリビューションでは<command>sysctl</command>プログラムが存在しない可能性があります。
この場合、<filename>/proc</filename>ファイルシステムに対する操作で同等の変更を行うことができます。
<screen>
<prompt>$</prompt> <userinput>echo 17179869184 &gt;/proc/sys/kernel/shmmax</userinput>
<prompt>$</prompt> <userinput>echo 4194304 &gt;/proc/sys/kernel/shmall</userinput>
</screen>
       </para>

       <para>
<!--
        The remaining defaults are quite generously sized, and usually
        do not require changes.
-->
他のデフォルトはかなり豊富なサイズですので、通常は変更する必要はありません。
       </para>
      </listitem>
     </varlistentry>


     <varlistentry>
      <term><systemitem class="osname">macOS</>
<!--
      <indexterm><primary>macOS</><secondary>IPC configuration</></>
-->
      <indexterm><primary>macOS</><secondary>IPC設定</></>
      </term>
      <listitem>
       <para>
<!--
        The recommended method for configuring shared memory in macOS
        is to create a file named <filename>/etc/sysctl.conf</>,
        containing variable assignments such as:
-->
macOSにおける共有メモリの推奨設定方法は、以下のような変数代入文からなる<filename>/etc/sysctl.conf</>という名称のファイルを作成することです。
<programlisting>
kern.sysv.shmmax=4194304
kern.sysv.shmmin=1
kern.sysv.shmmni=32
kern.sysv.shmseg=8
kern.sysv.shmall=1024
</programlisting>
<!--
        Note that in some macOS versions,
        <emphasis>all five</> shared-memory parameters must be set in
        <filename>/etc/sysctl.conf</>, else the values will be ignored.
-->
一部のバージョンのmacOSでは<filename>/etc/sysctl.conf</>内に共有メモリパラメータ<emphasis>5つすべて</>を設定しなければならないという点に注意してください。
さもなくば値が無視されます。
       </para>

       <para>
<!--
        Beware that recent releases of macOS ignore attempts to set
        <varname>SHMMAX</> to a value that isn't an exact multiple of 4096.
-->
最近のリリースのmacOSは、<varname>SHMMAX</>を4096の倍数以外に設定しようとすると無視しますので、注意してください。
       </para>

       <para>
<!--
        <varname>SHMALL</> is measured in 4 kB pages on this platform.
-->
このプラットフォームでは<varname>SHMALL</>は4キロバイトページ単位です。
       </para>

       <para>
<!--
        In older macOS versions, you will need to reboot to have changes in the
        shared memory parameters take effect.  As of 10.5 it is possible to
        change all but <varname>SHMMNI</> on the fly, using
        <application>sysctl</>.  But it's still best to set up your preferred
        values via <filename>/etc/sysctl.conf</>, so that the values will be
        kept across reboots.
-->
古めのバージョンのmacOSでは、共有メモリパラメータの変更を有効にするために再起動が必要になります。
10.5から<varname>SHMMNI</>以外の変更は、<application>sysctl</>を用いることにより、その場で行うことができます。
しかしいずれにせよ<filename>/etc/sysctl.conf</>経由で望む値に設定することが最善です。
再起動を行っても値が保持されるからです。
       </para>

       <para>
<!--
        The file <filename>/etc/sysctl.conf</> is only honored in macOS
        10.3.9 and later.  If you are running a previous 10.3.x release,
        you must edit the file <filename>/etc/rc</>
        and change the values in the following commands:
-->
<filename>/etc/sysctl.conf</>はmacOS 10.3.9以降でのみ使用されます。
もしこれより前の10.3.xリリースを使用しているのであれば、<filename>/etc/rc</>ファイルを編集し、以下のコマンドで値を変更しなければなりません。
<programlisting>
sysctl -w kern.sysv.shmmax
sysctl -w kern.sysv.shmmin
sysctl -w kern.sysv.shmmni
sysctl -w kern.sysv.shmseg
sysctl -w kern.sysv.shmall
</programlisting>
<!--
        Note that
        <filename>/etc/rc</> is usually overwritten by macOS system updates,
        so you should expect to have to redo these edits after each update.
-->
通常<filename>/etc/rc</>はmacOSのアップデートで上書きされることに注意してください。
ですので、アップデートの度に編集し直す必要があるものと考えなければなりません。
       </para>

       <para>
<!--
        In macOS 10.2 and earlier, instead edit these commands in the file
        <filename>/System/Library/StartupItems/SystemTuning/SystemTuning</>.
-->
macOS 10.2以前では、代わりに<filename>/System/Library/StartupItems/SystemTuning/SystemTuning</>ファイル内にあるこれらのコマンドを編集してください。
       </para>
      </listitem>
     </varlistentry>


     <varlistentry>
<!--
      <term><systemitem class="osname">Solaris</> 2.6 to 2.9 (Solaris
      6 to Solaris 9)
      <indexterm><primary>Solaris</><secondary>IPC configuration</></>
-->
      <term><systemitem class="osname">Solaris</> 2.6から2.9 (Solaris 6からSolaris 9)
      <indexterm><primary>Solaris</><secondary>IPC設定</></>
      </term>
      <listitem>
       <para>
<!--
        The relevant settings can be changed in
        <filename>/etc/system</>, for example:
-->
必要な設定は<filename>/etc/system</>で変えることができ、例えば以下のようになります。
<programlisting>
set shmsys:shminfo_shmmax=0x2000000
set shmsys:shminfo_shmmin=1
set shmsys:shminfo_shmmni=256
set shmsys:shminfo_shmseg=256

set semsys:seminfo_semmap=256
set semsys:seminfo_semmni=512
set semsys:seminfo_semmns=512
set semsys:seminfo_semmsl=32
</programlisting>
<!--
        You need to reboot for the changes to take effect.  See also
        <ulink url="http://sunsite.uakom.sk/sunworldonline/swol-09-1997/swol-09-insidesolaris.html"></ulink>
        for information on shared memory under older versions of Solaris.
-->
変更を反映させるには再起動する必要があります。
古めのバージョンのSolarisにおける共有メモリの情報は<ulink url="http://sunsite.uakom.sk/sunworldonline/swol-09-1997/swol-09-insidesolaris.html"></ulink>を参照してください。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--
      <term><systemitem class="osname">Solaris</> 2.10 (Solaris
      10) and later</term>
-->
      <term><systemitem class="osname">Solaris</> 2.10 (Solaris 10)以降</term>
      <term><systemitem class="osname">OpenSolaris</></term>
      <listitem>
       <para>
<!--
        In Solaris 10 and later, and OpenSolaris, the default shared memory and
        semaphore settings are good enough for most
        <productname>PostgreSQL</> applications.  Solaris now defaults
        to a <varname>SHMMAX</> of one-quarter of system <acronym>RAM</>.
        To further adjust this setting, use a project setting associated
        with the <literal>postgres</> user.  For example, run the
        following as <literal>root</>:
-->
Solaris 10以降とOpenSolarisでは、デフォルトの共有メモリとセマフォ設定は大抵の<productname>PostgreSQL</>アプリケーションで十分あります。
Solarisのデフォルトの<varname>SHMMAX</>はシステムの<acronym>RAM</>の1/4になりました。
さらにこの設定を調整するためには、<literal>postgres</>ユーザに関するプロジェクト設定を使用しなければなりません。
例えば以下を<literal>root</>権限で実行してください。
<programlisting>
projadd -c "PostgreSQL DB User" -K "project.max-shm-memory=(privileged,8GB,deny)" -U postgres -G postgres user.postgres
</programlisting>
       </para>

       <para>
<!--
        This command adds the <literal>user.postgres</> project and
        sets the shared memory maximum for the <literal>postgres</>
        user to 8GB, and takes effect the next time that user logs
        in, or when you restart <productname>PostgreSQL</> (not reload).
        The above assumes that <productname>PostgreSQL</> is run by
        the <literal>postgres</> user in the <literal>postgres</>
        group.  No server reboot is required.
-->
このコマンドは<literal>user.postgres</>プロジェクトを追加し、<literal>postgres</>ユーザの共有メモリの最大サイズを8GBに設定します。
この影響は次にこのユーザがログインした時、または<productname>PostgreSQL</>を再起動した時（再読み込み時ではありません）に有効になります。
上では<productname>PostgreSQL</>は<literal>postgres</>グループに属する<literal>postgres</>ユーザにより実行されていることを前提としています。
サーバの再起動は不要です。
       </para>

       <para>
<!--
        Other recommended kernel setting changes for database servers which will
        have a large number of connections are:
-->
多くの接続を受け付けるデータベースサーバにおいて推奨するカーネル設定にはこの他に以下があります。
<programlisting>
project.max-shm-ids=(priv,32768,deny)
project.max-sem-ids=(priv,4096,deny)
project.max-msg-ids=(priv,4096,deny)
</programlisting>
       </para>

       <para>
<!--
        Additionally, if you are running <productname>PostgreSQL</>
        inside a zone, you may need to raise the zone resource usage
        limits as well.  See "Chapter2:  Projects and Tasks" in the
        <citetitle>System Administrator's Guide</> for more
        information on <literal>projects</> and <command>prctl</>.
-->
さらに、ゾーン内で<productname>PostgreSQL</>を実行している場合、ゾーンのリソース使用上限も上げる必要があるかもしれません。
<literal>projects</>と<command>prctl</>については<citetitle>System Administrator's Guide</>の第2章 プロジェクトとタスクを参照してください。
       </para>
      </listitem>
     </varlistentry>

    </variablelist>

  </sect2>

  <sect2 id="systemd-removeipc">
   <title>systemd RemoveIPC</title>

   <indexterm>
    <primary>systemd</primary>
    <secondary>RemoveIPC</secondary>
   </indexterm>

   <para>
<!--
    If <productname>systemd</productname> is in use, some care must be taken
    that IPC resources (shared memory and semaphores) are not prematurely
    removed by the operating system.  This is especially of concern when
    installing PostgreSQL from source.  Users of distribution packages of
    PostgreSQL are less likely to be affected, as
    the <literal>postgres</literal> user is then normally created as a system
    user.
-->
<productname>systemd</productname>が使用されている場合、IPCリソース（共有メモリとセマフォ）がオペレーティングシステムによって時期尚早に削除されないように注意する必要があります。
これはPostgreSQLをソースからインストールした場合に特に重要です。
PostgreSQLのディストリビューションパッケージのユーザーは、通常<literal>postgres</literal>ユーザーがシステムユーザーで作成されるため、影響を受けにくいでしょう。
   </para>

   <para>
<!--
    The setting <literal>RemoveIPC</literal>
    in <filename>logind.conf</filename> controls whether IPC objects are
    removed when a user fully logs out.  System users are exempt.  This
    setting defaults to on in stock <productname>systemd</productname>, but
    some operating system distributions default it to off.
-->
<filename>logind.conf</filename>の<literal>RemoveIPC</literal>の設定はユーザが完全にログアウトしたときにIPCオブジェクトを削除するかどうかを制御します。
システムユーザは免除されます。
この設定のデフォルトは<productname>systemd</productname>ですが、いくつかのオペレーティングシステムではデフォルトでオフになっています。
   </para>

   <para>
<!--
    A typical observed effect when this setting is on is that the semaphore
    objects used by a PostgreSQL server are removed at apparently random
    times, leading to the server crashing with log messages like
-->
この設定が有効になっている時の典型的な影響は、PostgreSQLサーバが使用しているセマフォオブジェクトがランダムな時間に削除され、サーバが以下のようなログメッセージでクラッシュします。
<screen>
LOG: semctl(1234567890, 0, IPC_RMID, ...) failed: Invalid argument
</screen>
<!--
    Different types of IPC objects (shared memory vs. semaphores, System V
    vs. POSIX) are treated slightly differently
    by <productname>systemd</productname>, so one might observe that some IPC
    resources are not removed in the same way as others.  But it is not
    advisable to rely on these subtle differences.
-->
IPCオブジェクトの違い（共有メモリ vs. セマフォ、System V vs. POSIX）は<productname>systemd</productname>によって若干扱いが異なるため一部のIPCは他のものと違って削除されないことがあります。
しかし、これらの微妙な違いに依存することはお勧めできません。
   </para>

   <para>
<!--
    A <quote>user logging out</quote> might happen as part of a maintenance
    job or manually when an administrator logs in as
    the <literal>postgres</literal> user or something similar, so it is hard
    to prevent in general.
-->
<quote>ユーザーログアウト</quote>は、メンテンスジョブの一環として、又は手動で、管理者が<literal>postgres</literal>ユーザーや類似のユーザでログインする可能性があるため、一般的に防止することは困難です。
   </para>

   <para>
<!--
    What is a <quote>system user</quote> is determined
    at <productname>systemd</productname> compile time from
    the <symbol>SYS_UID_MAX</symbol> setting
    in <filename>/etc/login.defs</filename>.
-->
<quote>システムユーザー</quote>は、<filename>/etc/login.defs</filename>の<symbol>SYS_UID_MAX</symbol>の設定により<productname>systemd</productname>のコンパイル時に決定されます。
   </para>

   <para>
<!--
    Packaging and deployment scripts should be careful to create
    the <literal>postgres</literal> user as a system user by
    using <literal>useradd -r</literal>, <literal>adduser &#045;&#045;system</literal>,
    or equivalent.
-->
パッケージとデプロイスクリプトは、<literal>useradd -r</literal>, <literal>adduser --system</literal>又は同等のコマンドを使用して<literal>postgres</literal>ユーザを作成するように注意する必要があります。
   </para>

   <para>
<!--
    Alternatively, if the user account was created incorrectly or cannot be
    changed, it is recommended to set
-->
また、ユーザアカウントが誤って作成されて変更出来ないような場合は、以下を設定することを推奨します。
<programlisting>
RemoveIPC=no
</programlisting>
<!--
    in <filename>/etc/systemd/logind.conf</filename> or another appropriate
    configuration file.
-->
<filename>/etc/systemd/logind.conf</filename>又はその他の設定ファイルで上記を入れます。
   </para>

   <caution>
    <para>
<!--
     At least one of these two things has to be ensured, or the PostgreSQL
     server will be very unreliable.
-->
これらの２つのうち少なくとも１つが保証されてないとなりません。そうでないとPostgreSQLサーバは非常に信頼性が低くなります。
    </para>
   </caution>
  </sect2>

  <sect2>
<!--
   <title>Resource Limits</title>
-->
   <title>リソースの制限</title>

   <para>
<!--
    Unix-like operating systems enforce various kinds of resource limits
    that might interfere with the operation of your
    <productname>PostgreSQL</productname> server. Of particular
    importance are limits on the number of processes per user, the
    number of open files per process, and the amount of memory available
    to each process. Each of these have a <quote>hard</quote> and a
    <quote>soft</quote> limit. The soft limit is what actually counts
    but it can be changed by the user up to the hard limit. The hard
    limit can only be changed by the root user. The system call
    <function>setrlimit</function> is responsible for setting these
    parameters. The shell's built-in command <command>ulimit</command>
    (Bourne shells) or <command>limit</command> (<application>csh</>) is
    used to control the resource limits from the command line. On
    BSD-derived systems the file <filename>/etc/login.conf</filename>
    controls the various resource limits set during login. See the
    operating system documentation for details. The relevant
    parameters are <varname>maxproc</varname>,
    <varname>openfiles</varname>, and <varname>datasize</varname>. For
    example:
-->
Unixライクなオペレーティングシステムでは<productname>PostgreSQL</productname>サーバの操作と関係する可能性のある様々な種類のリソース制限があります。
特に重要なのは、ユーザごとのプロセス数の制限、プロセスごとのオープンファイルの数、プロセスごとの利用可能なメモリの量です。
これらのそれぞれが<quote>ハード</quote>と<quote>ソフト</quote>の2つの制限を持っています。
ソフト制限が実際に有効な制限ですが、ユーザによってハード制限まで変えることが可能です。
ハード制限はrootユーザによってのみ変えることができます。
<function>setrlimit</function>システムコールがこれらのパラメータの設定を行います。
シェルの組み込みコマンド<command>ulimit</command>（Bourne シェル）もしくは<command>limit</command>（<application>csh</>）は、コマンドラインからリソース制限を制御するために使われます。
BSD派生システム上では<filename>/etc/login.conf</filename>ファイルが、ログイン時に設定される様々なリソース制限を制御します。
詳細はオペレーティングシステムの文書を参照してください。
関連するパラメータは<varname>maxproc</varname>、<varname>openfiles</varname>、<varname>datasize</varname>です。
以下に例を示します。
<programlisting>
default:\
...
        :datasize-cur=256M:\
        :maxproc-cur=256:\
        :openfiles-cur=256:\
...
</programlisting>
<!--
    (<literal>-cur</literal> is the soft limit.  Append
    <literal>-max</literal> to set the hard limit.)
-->
（<literal>-cur</literal>はソフト制限です。
ハード制限を設定するためには<literal>-max</literal>を付けてください。）
   </para>

   <para>
<!--
    Kernels can also have system-wide limits on some resources.
-->
カーネルはいくつかのリソースに対して、システム全体の制限も持つことができます。
    <itemizedlist>
     <listitem>
      <para>
<!--
      On <productname>Linux</productname>
      <filename>/proc/sys/fs/file-max</filename> determines the
      maximum number of open files that the kernel will support.  It can
      be changed by writing a different number into the file or by
      adding an assignment in <filename>/etc/sysctl.conf</filename>.
      The maximum limit of files per process is fixed at the time the
      kernel is compiled; see
      <filename>/usr/src/linux/Documentation/proc.txt</filename> for
      more information.
-->
<productname>Linux</productname>では、<filename>/proc/sys/fs/file-max</filename>が、カーネルがサポートするオープンファイル数の最大を決定します。
この数を変えるためには、そのファイルに別の数を書き込むか、あるいは<filename>/etc/sysctl.conf</filename>に代入式を追加します。
プロセスごとのファイルの最大制限はカーネルがコンパイルされた時に固定されます。
詳しい情報については<filename>/usr/src/linux/Documentation/proc.txt</filename>を参照してください。
      </para>
     </listitem>
    </itemizedlist>
   </para>

   <para>
<!--
    The <productname>PostgreSQL</productname> server uses one process
    per connection so you should provide for at least as many processes
    as allowed connections, in addition to what you need for the rest
    of your system.  This is usually not a problem but if you run
    several servers on one machine things might get tight.
-->
<productname>PostgreSQL</productname>サーバは接続ごとに1つのプロセスを使うので、少なくとも許可された接続の数だけのプロセスに残りのシステムで必要な分を追加したものが必要になります。
通常はこれは問題ではありませんが、1つのマシン上でいくつかのサーバを起動している場合は厳しい状況になるかもしれません。
   </para>

   <para>
<!--
    The factory default limit on open files is often set to
    <quote>socially friendly</quote> values that allow many users to
    coexist on a machine without using an inappropriate fraction of
    the system resources.  If you run many servers on a machine this
    is perhaps what you want, but on dedicated servers you might want to
    raise this limit.
-->
オープンファイルの制限の出荷時のデフォルトは、しばしば大多数のユーザはマシン上でシステムリソースの不正使用をしないという前堤に立った<quote>社会的に友好的な</quote>値を設定してしまいます。
もし1つのマシン上で複数のサーバを起動する場合はそれが必要でしょうが、専用サーバではこの制限を上げたいかもしれません。
   </para>

   <para>
<!--
    On the other side of the coin, some systems allow individual
    processes to open large numbers of files; if more than a few
    processes do so then the system-wide limit can easily be exceeded.
    If you find this happening, and you do not want to alter the
    system-wide limit, you can set <productname>PostgreSQL</>'s <xref
    linkend="guc-max-files-per-process"> configuration parameter to
    limit the consumption of open files.
-->
反対に、個々のプロセスが多数のファイルをオープンすることを許可するシステムもあります。
そのようなプロセスが数個以上あれば、システム全体の制限は簡単に超えてしまいます。
この発生を検知し、システム全体の制限の変更を望まない場合は、<productname>PostgreSQL</productname>の<xref linkend="guc-max-files-per-process">設定パラメータを設定し、オープンファイルの消費を制限することができます。
   </para>
  </sect2>

  <sect2 id="linux-memory-overcommit">
<!--
   <title>Linux Memory Overcommit</title>
-->
   <title>Linuxのメモリオーバーコミット</title>

   <indexterm>
<!--
    <primary>memory overcommit</primary>
-->
    <primary>メモリオーバーコミット</primary>
   </indexterm>

   <indexterm>
    <primary>OOM</primary>
   </indexterm>

   <indexterm>
<!--
    <primary>overcommit</primary>
-->
    <primary>オーバーコミット</primary>
   </indexterm>

   <para>
<!--
    In Linux 2.4 and later, the default virtual memory behavior is not
    optimal for <productname>PostgreSQL</productname>. Because of the
    way that the kernel implements memory overcommit, the kernel might
    terminate the <productname>PostgreSQL</productname> postmaster (the
    master server process) if the memory demands of either
    <productname>PostgreSQL</productname> or another process cause the
    system to run out of virtual memory.
-->
Linux 2.4以降では、デフォルトの仮想メモリの動作は<productname>PostgreSQL</productname>には最適ではありません。
カーネルがメモリオーバーコミットを実装する方法のため、カーネルは、<productname>PostgreSQL</productname>や他のプロセスのメモリ要求がシステムの仮想メモリを枯渇させた場合、<productname>PostgreSQL</productname> postmaster （マスタサーバプロセス）を終了させる可能性があります。
   </para>

   <para>
<!--
    If this happens, you will see a kernel message that looks like
    this (consult your system documentation and configuration on where
    to look for such a message):
-->
これが発生した場合、以下のようなカーネルメッセージが現れます
（こうしたメッセージを検索する場所についてはシステム文書と設定を参照してください）。
<programlisting>
Out of Memory: Killed process 12345 (postgres).
</programlisting>
<!--
    This indicates that the <filename>postgres</filename> process
    has been terminated due to memory pressure.
    Although existing database connections will continue to function
    normally, no new connections will be accepted.  To recover,
    <productname>PostgreSQL</productname> will need to be restarted.
-->
これは、<filename>postgres</filename>プロセスがメモリ不足のために終了してしまったことを示します。
起動中のデータベース接続は正常に動作しますが、新しい接続は受け付けられません。
復旧するには、<productname>PostgreSQL</productname>を再起動しなければなりません。
   </para>

   <para>
<!--
    One way to avoid this problem is to run
    <productname>PostgreSQL</productname> on a machine where you can
    be sure that other processes will not run the machine out of
    memory.  If memory is tight, increasing the swap space of the
    operating system can help avoid the problem, because the
    out-of-memory (OOM) killer is invoked only when physical memory and
    swap space are exhausted.
-->
この問題を防止する1つの方法として、<productname>PostgreSQL</productname>を他のプロセスがそのマシンのメモリを枯渇させないことが確実なマシンで起動するというものがあります。
物理メモリとスワップ領域が消費尽くされた時のみにメモリ不足（OOM）killerが発生するため、メモリが不足する場合、オペレーティングシステムのスワップ領域を増やすことが問題解決の役にたちます。
   </para>

   <para>
<!--
    If <productname>PostgreSQL</productname> itself is the cause of the
    system running out of memory, you can avoid the problem by changing
    your configuration.  In some cases, it may help to lower memory-related
    configuration parameters, particularly
    <link linkend="guc-shared-buffers"><varname>shared_buffers</></link>
    and <link linkend="guc-work-mem"><varname>work_mem</></link>.  In
    other cases, the problem may be caused by allowing too many connections
    to the database server itself.  In many cases, it may be better to reduce
    <link linkend="guc-max-connections"><varname>max_connections</></link>
    and instead make use of external connection-pooling software.
-->
<productname>PostgreSQL</productname>自体が実行中のシステムのメモリ不足を引き起こした場合、設定を変更することで問題を防止することができます。
メモリ関連の設定パラメータ、具体的には<link linkend="guc-shared-buffers"><varname>shared_buffers</></link>および<link linkend="guc-work-mem"><varname>work_mem</></link>、を低くすることで回避できる場合もあります。
個の他にもデータベースサーバ自体への接続が多く許可しすぎることで問題が引き起こされる場合もあります。
多くの場合、<link linkend="guc-max-connections"><varname>max_connections</></link>を減らし、外部のコネクションプールソフトウェアを使用することで改善されます。
   </para>

   <para>
<!--
    On Linux 2.6 and later, it is possible to modify the
    kernel's behavior so that it will not <quote>overcommit</> memory.
    Although this setting will not prevent the <ulink
    url="http://lwn.net/Articles/104179/">OOM killer</> from being invoked
    altogether, it will lower the chances significantly and will therefore
    lead to more robust system behavior.  This is done by selecting strict
    overcommit mode via <command>sysctl</command>:
-->
Linux 2.6以降では、メモリを<quote>オーバーコミット</>させないようにカーネルの動作を変更することができます。
この設定は完全に<ulink url="http://lwn.net/Articles/104179/">OOM killer</>の発生を防ぐことはできませんが、その発生頻度をかなり軽減しますので、システム動作の堅牢性をより高めます。
これは、以下のように<command>sysctl</command>を使用して厳密なオーバーコミットモードを選択すること、もしくは、<filename>/etc/sysctl.conf</>に同等の項目を記述することで実施されます。
<programlisting>
sysctl -w vm.overcommit_memory=2
</programlisting>
<!--
    or placing an equivalent entry in <filename>/etc/sysctl.conf</>.
    You might also wish to modify the related setting
    <varname>vm.overcommit_ratio</>.  For details see the kernel documentation
    file <ulink url="https://www.kernel.org/doc/Documentation/vm/overcommit-accounting"></ulink>.
-->
また、関連する<varname>vm.overcommit_ratio</>設定を変更した方が良いでしょう。
詳細はカーネル文書ファイル<ulink url="https://www.kernel.org/doc/Documentation/vm/overcommit-accounting"></ulink>を参照してください。
   </para>

   <para>
<!--
    Another approach, which can be used with or without altering
    <varname>vm.overcommit_memory</>, is to set the process-specific
    <firstterm>OOM score adjustment</> value for the postmaster process to
    <literal>-1000</>, thereby guaranteeing it will not be targeted by the OOM
    killer.  The simplest way to do this is to execute
-->
<varname>vm.overcommit_memory</>の変更と関係なく使用できるその他の方法は、プロセス固有の<firstterm>OOMスコア調整</>値をpostmasterプロセス向けに<literal>-1000</>に設定することです。
これによりOOM killerの対象とならないことが保証されます。
このための最も簡単な方法は以下をpostmasterの起動スクリプト内でpostmasterを実行する直前に実行することです。
<programlisting>
echo -1000 > /proc/self/oom_score_adj
</programlisting>
<!--
    in the postmaster's startup script just before invoking the postmaster.
    Note that this action must be done as root, or it will have no effect;
    so a root-owned startup script is the easiest place to do it.  If you
    do this, you should also set these environment variables in the startup
    script before invoking the postmaster:
-->
この作業をrootで実行しなければならないことに注意して下さい。
さもないと効果がありません。
このためrootが所有する起動スクリプトが、これを行うための最も簡単な場所です。
その場合には、スタートアップスクリプトのpostmasterの起動前に以下の環境変数を設定することも推奨します。
<programlisting>
export PG_OOM_ADJUST_FILE=/proc/self/oom_score_adj
export PG_OOM_ADJUST_VALUE=0
</programlisting>
<!--
    These settings will cause postmaster child processes to run with the
    normal OOM score adjustment of zero, so that the OOM killer can still
    target them at need.  You could use some other value for
    <envar>PG_OOM_ADJUST_VALUE</> if you want the child processes to run
    with some other OOM score adjustment.  (<envar>PG_OOM_ADJUST_VALUE</>
    can also be omitted, in which case it defaults to zero.)  If you do not
    set <envar>PG_OOM_ADJUST_FILE</>, the child processes will run with the
    same OOM score adjustment as the postmaster, which is unwise since the
    whole point is to ensure that the postmaster has a preferential setting.
-->
これらの設定は、いざという時にpostmasterの子プロセスをOOM killerのターゲットに出来るようにOOMスコア調整を通常のゼロで実行します。
子プロセスを他のOOMスコア調整で実行したい場合には、<envar>PG_OOM_ADJUST_VALUE</>により別の値にすることが出来ます。
（<envar>PG_OOM_ADJUST_VALUE</>は省略することが出来て、その場合はデフォルトのゼロになります。）
<envar>PG_OOM_ADJUST_FILE</>を設定しない場合、子プロセスはpostmasterと同じOOMスコア調整で実行されますが、postmasterが優先される設定にすることが肝心なので、それは賢明とは言えません。
   </para>

   <para>
<!--
    Older Linux kernels do not offer <filename>/proc/self/oom_score_adj</>,
    but may have a previous version of the same functionality called
    <filename>/proc/self/oom_adj</>.  This works the same except the disable
    value is <literal>-17</> not <literal>-1000</>.
-->
古いLinuxカーネルは<filename>/proc/self/oom_score_adj</>を提供していませんが、同様の機能を持つ<filename>/proc/self/oom_adj</>があるでしょう。
これは、無効にするための設定値が<literal>-1000</>ではなく<literal>-17</>であるという点を除いては同じように動作します。
   </para>

   <note>
   <para>
<!--
    Some vendors' Linux 2.4 kernels are reported to have early versions
    of the 2.6 overcommit <command>sysctl</command> parameter.  However, setting
    <literal>vm.overcommit_memory</> to 2
    on a 2.4 kernel that does not have the relevant code will make
    things worse, not better.  It is recommended that you inspect
    the actual kernel source code (see the function
    <function>vm_enough_memory</> in the file <filename>mm/mmap.c</>)
    to verify what is supported in your kernel before you try this in a 2.4
    installation.  The presence of the <filename>overcommit-accounting</>
    documentation file should <emphasis>not</> be taken as evidence that the
    feature is there.  If in any doubt, consult a kernel expert or your
    kernel vendor.
-->
Linux 2.4カーネルのベンダの中には、2.6のオーバーコミット<command>sysctl</command>版を持つものがあることが報告されています。
しかし、関係するコードを持たない2.4カーネルで<literal>vm.overcommit_memory</>を2に設定することはより状況を悪化させます。
2.4のインストレーションではこれを試す前に、実際のカーネルソースコードを調査し、その中でサポートしているかどうかを検証することをお勧めします（<filename>mm/mmap.c</>ファイル内の<function>vm_enough_memory</>関数を参照してください）。
<filename>overcommit-accounting</>文書ファイルの存在は、この機能が存在するかどうかを証明するものでは<emphasis>ありません</>。
疑わしい場合は、使用中のカーネルベンダのカーネル専門家に相談してください。
   </para>
   </note>
  </sect2>

  <sect2 id="linux-huge-pages">
<!--
   <title>Linux Huge Pages</title>
-->
   <title>LinuxのHugePages</title>

   <para>
<!--
    Using huge pages reduces overhead when using large contiguous chunks of
    memory, as <productname>PostgreSQL</productname> does, particularly when
    using large values of <xref linkend="guc-shared-buffers">.  To use this
    feature in <productname>PostgreSQL</productname> you need a kernel
    with <varname>CONFIG_HUGETLBFS=y</varname> and
    <varname>CONFIG_HUGETLB_PAGE=y</varname>. You will also have to adjust
    the kernel setting <varname>vm.nr_hugepages</varname>. To estimate the
    number of huge pages needed, start <productname>PostgreSQL</productname>
    without huge pages enabled and check the
    postmaster's <varname>VmPeak</varname> value, as well as the system's
    huge page size, using the <filename>/proc</> file system.  This might
    look like:
-->
<productname>PostgreSQL</productname>のように、メモリの大きな連続チャンクを使用するとき、特に<xref linkend="guc-shared-buffers">の値が大きい場合に、huge pagesを使用するとオーバーヘッドが減少します。
<productname>PostgreSQL</productname>でこの機能を有効にするには、<varname>CONFIG_HUGETLBFS=y</varname>および<varname>CONFIG_HUGETLB_PAGE=y</varname>としたカーネルが必要です。
またカーネル設定<varname>vm.nr_hugepages</varname>を調整する必要もあるでしょう。
必要なhuge pages数を見積もるには、huge pagesを有効にせずに、<productname>PostgreSQL</productname>を起動し、procファイルシステムを使用してpostmasterの<varname>VmPeak</varname>の値をチェックします。
これは以下のような感じになるでしょう。
<programlisting>
$ <userinput>head -1 $PGDATA/postmaster.pid</userinput>
4170
$ <userinput>grep ^VmPeak /proc/4170/status</userinput>
VmPeak:  6490428 kB
$ <userinput>grep ^Hugepagesize /proc/meminfo</userinput>
Hugepagesize:       2048 kB
</programlisting>
<!--
     <literal>6490428</literal> / <literal>2048</literal> gives approximately
     <literal>3169.154</literal>, so in this example we need at
     least <literal>3170</literal> huge pages, which we can set with:
-->
<literal>6490428</literal> / <literal>2048</literal>はおよそ<literal>3169.154</literal>ですので、この例では少なくとも<literal>3170</literal>のhuge pagesが必要で、それは以下のようにして設定できます。
<programlisting>
$ <userinput>sysctl -w vm.nr_hugepages=3170</userinput>
</programlisting>
<!--
    A larger setting would be appropriate if other programs on the machine
    also need huge pages.  Don't forget to add this setting
    to <filename>/etc/sysctl.conf</filename> so that it will be reapplied
    after reboots.
-->
同じマシン上で他にもhuge pagesが必要なプログラムがあるなら、もっと大きな設定が適切でしょう。
再起動のときにこの設定が適用されるように、これを<filename>/etc/sysctl.conf</filename>に追加するのを忘れないで下さい。
   </para>

   <para>
<!--
    Sometimes the kernel is not able to allocate the desired number of huge
    pages immediately, so it might be necessary to repeat the command or to
    reboot.  (Immediately after a reboot, most of the machine's memory
    should be available to convert into huge pages.)  To verify the huge
    page allocation situation, use:
-->
時には、カーネルは求められた数のhuge pagesを割り当てることができないことがあるので、そのコマンドを繰り返すか、再起動する必要があるかもしれません。
（再起動の直後は、マシンのメモリの大部分はhuge pagesへの変更が可能なはずです。）
huge pagesの割り当ての状況を確認するには、次のようにします。
<programlisting>
$ <userinput>grep Huge /proc/meminfo</userinput>
</programlisting>
   </para>

   <para>
<!--
    It may also be necessary to give the database server's operating system
    user permission to use huge pages by setting
    <varname>vm.hugetlb_shm_group</> via <application>sysctl</>, and/or
    give permission to lock memory with <command>ulimit -l</>.
-->
<application>sysctl</>を使って<varname>vm.hugetlb_shm_group</>を設定する、あるいは<command>ulimit -l</>でメモリをロックする権限を与えることで、データベースサーバのOSユーザにhuge pagesを使用する権限を与える必要もあるかもしれません。
   </para>

   <para>
<!--
    The default behavior for huge pages in
    <productname>PostgreSQL</productname> is to use them when possible and
    to fall back to normal pages when failing. To enforce the use of huge
    pages, you can set <xref linkend="guc-huge-pages">
    to <literal>on</literal> in <filename>postgresql.conf</>.
    Note that with this setting <productname>PostgreSQL</> will fail to
    start if not enough huge pages are available.
-->
<productname>PostgreSQL</productname>のhuge pagesのデフォルトの動作は、可能な場合はhuge pagesを使用し、失敗した場合は通常のページを使用します。
<filename>postgresql.conf</>で<link linkend="guc-huge-pages"><varname>huge_pages</varname></link>を<literal>on</literal>に設定することで、huge pagesの使用を強制することができます。
この設定の場合、十分なhuge pagesが確保できなければ、<productname>PostgreSQL</productname>の起動に失敗することに注意してください。
   </para>

   <para>
<!--
    For a detailed description of the <productname>Linux</productname> huge
    pages feature have a look
    at <ulink url="https://www.kernel.org/doc/Documentation/vm/hugetlbpage.txt"></ulink>.
-->
<productname>Linux</productname>のhuge pages機能の詳細は<ulink url="https://www.kernel.org/doc/Documentation/vm/hugetlbpage.txt"></ulink>を参照してください。
   </para>

  </sect2>
 </sect1>


 <sect1 id="server-shutdown">
<!--
  <title>Shutting Down the Server</title>
-->
  <title>サーバのシャットダウン</title>

  <indexterm zone="server-shutdown">
<!--
   <primary>shutdown</>
-->
   <primary>シャットダウン</>
  </indexterm>

  <para>
<!--
   There are several ways to shut down the database server. You control
   the type of shutdown by sending different signals to the master
   <command>postgres</command> process.
-->
データベースサーバをシャットダウンする方法は複数あります。
マスタ<command>postgres</command>プロセスに異なるシグナルを送ることで、シャットダウンの方法を制御します。

   <variablelist>
    <varlistentry>
     <term><systemitem>SIGTERM</systemitem><indexterm><primary>SIGTERM</></></term>
     <listitem>
      <para>
<!--
       This is the <firstterm>Smart Shutdown</firstterm> mode.
       After receiving <systemitem>SIGTERM</systemitem>, the server
       disallows new connections, but lets existing sessions end their
       work normally. It shuts down only after all of the sessions terminate.
       If the server is in online backup mode, it additionally waits
       until online backup mode is no longer active.  While backup mode is
       active, new connections will still be allowed, but only to superusers
       (this exception allows a superuser to connect to terminate
       online backup mode).  If the server is in recovery when a smart
       shutdown is requested, recovery and streaming replication will be
       stopped only after all regular sessions have terminated.
-->
これは<firstterm>スマートシャットダウン</firstterm>モードです。
<systemitem>SIGTERM</systemitem>を受け取った後で、サーバは新しい接続を禁止しますが、既に存在するセッションは通常通り動作させます。
すべてのセッションが通常に終了するまではシャットダウンしません。
サーバがオンラインバックアップモードである場合、オンラインバックアップモードが活動しなくなるまでさらに待ちます。
バックアップモードが活動している間、新規接続は依然として許可されますが、スーパーユーザに対してだけです
（この例外はスーパーユーザがオンラインバックアップモード停止のための接続を許可します）。
スマートシャットダウンが要求された時にサーバがリカバリ状態である場合、すべての通常のセッションが終了した後のみでリカバリとストリーミングレプリケーションが停止します。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><systemitem>SIGINT</systemitem><indexterm><primary>SIGINT</></></term>
     <listitem>
      <para>
<!--
       This is the <firstterm>Fast Shutdown</firstterm> mode.
       The server disallows new connections and sends all existing
       server processes <systemitem>SIGTERM</systemitem>, which will cause them
       to abort their current transactions and exit promptly. It then
       waits for all server processes to exit and finally shuts down.
       If the server is in online backup mode, backup mode will be
       terminated, rendering the backup useless.
-->
これは<firstterm>高速シャットダウン</firstterm>モードです。
サーバは新しい接続を禁止しすべての存在するサーバプロセスに<systemitem>SIGTERM</systemitem>を送り、この結果サーバプロセスは現在のトランザクションをアボートし、即座に終了します。
そして サーバはすべてのサーバプロセスの終了を待って、最後にシャットダウンします。
サーバがオンラインバックアップモードである場合、バックアップモードは終了しますので、そのバックアップは使用することができなくなります。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><systemitem>SIGQUIT</systemitem><indexterm><primary>SIGQUIT</></></term>
     <listitem>
      <para>
<!--
      This is the <firstterm>Immediate Shutdown</firstterm> mode.
      The server will send <systemitem>SIGQUIT</systemitem> to all child
      processes and wait for them to terminate.  If any do not terminate
      within 5 seconds, they will be sent <systemitem>SIGKILL</systemitem>.
      The master server process exits as soon as all child processes have
      exited, without doing normal database shutdown processing.
      This will lead to recovery (by
      replaying the WAL log) upon next start-up. This is recommended
      only in emergencies.
-->
これは<firstterm>即時シャットダウン</firstterm>モードです。
サーバは、すべての子プロセスに<systemitem>SIGQUIT</systemitem>を送信し、それらが終了するのを待ちます。
5秒以内に終了しないものには、<systemitem>SIGKILL</systemitem>が送られます。
すべての子プロセスが終了したら、マスタサーバプロセスはすぐに終了しますが、このとき通常のデータベースのシャットダウン処理を実行しません。
これは次の起動時に（WALログを再実行することで）リカバリをすることになります。
これは緊急の時にのみ使うことを勧めます。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

  <para>
<!--
   The <xref linkend="app-pg-ctl"> program provides a convenient
   interface for sending these signals to shut down the server.
   Alternatively, you can send the signal directly using <command>kill</>
   on non-Windows systems.
   The <acronym>PID</> of the <command>postgres</command> process can be
   found using the <command>ps</command> program, or from the file
   <filename>postmaster.pid</filename> in the data directory. For
   example, to do a fast shutdown:
-->
<command>pg_ctl</command>プログラムは、サーバをシャットダウンさせるシグナルを送信するための便利なインタフェースを提供します。
他にも、Windows以外のシステムでは<command>kill</>を使用して直接シグナルを送信することもできます。
<command>postgres</command>プロセスの<acronym>PID</>は、<command>ps</command>プログラム、もしくはデータディレクトリの中の<filename>postmaster.pid</filename>ファイルを使用して見つけることができます。
例えば、高速シャットダウンをするためには下記のようになります。
<screen>
$ <userinput>kill -INT `head -1 /usr/local/pgsql/data/postmaster.pid`</userinput>
</screen>
  </para>

  <important>
   <para>
<!--
    It is best not to use <systemitem>SIGKILL</systemitem> to shut down
    the server.  Doing so will prevent the server from releasing
    shared memory and semaphores, which might then have to be done
    manually before a new server can be started.  Furthermore,
    <systemitem>SIGKILL</systemitem> kills the <command>postgres</command>
    process without letting it relay the signal to its subprocesses,
    so it will be necessary to kill the individual subprocesses by hand as
    well.
-->
サーバをシャットダウンするために<systemitem>SIGKILL</systemitem>を使わない方が良いでしょう。
これによってサーバが共有メモリとセマフォを解放できなくなり、新しくサーバを開始する前に、手動でその作業をしなければならなくなる可能性があります。
さらに、<systemitem>SIGKILL</systemitem>は、子プロセスにシグナルを中継することなく<command>postgres</command>を停止させます。
このため、個々の子プロセスを停止させるために、同じ作業を手作業で行わなければならなくなります。
   </para>
  </important>

  <para>
<!--
   To terminate an individual session while allowing other sessions to
   continue, use <function>pg_terminate_backend()</> (see <xref
   linkend="functions-admin-signal-table">) or send a
   <systemitem>SIGTERM</> signal to the child process associated with
   the session.
-->
他のセッションを継続させながら個別のセッションを停止するには<function>pg_terminate_backend()</>（<xref linkend="functions-admin-signal-table">を参照）を使用するか、そのセッションに関連する子プロセスに<systemitem>SIGTERM</>シグナルを送ります。
  </para>
 </sect1>

 <sect1 id="upgrading">
<!--
  <title>Upgrading a <productname>PostgreSQL</> Cluster</title>
-->
  <title><productname>PostgreSQL</>クラスタのアップグレード処理</title>

  <indexterm zone="upgrading">
<!--
   <primary>upgrading</primary>
-->
   <primary>アップグレード処理</primary>
  </indexterm>

  <indexterm zone="upgrading">
<!--
   <primary>version</primary>
   <secondary>compatibility</secondary>
-->
   <primary>バージョン</primary>
   <secondary>互換性</secondary>
  </indexterm>

  <para>
<!--
   This section discusses how to upgrade your database data from one
   <productname>PostgreSQL</> release to a newer one.
-->
本節では<productname>PostgreSQL</>リリースからより新しいリリースにデータベースデータをアップグレードする方法を説明します。
  </para>

  <para>
<!--
   Current <productname>PostgreSQL</productname> version numbers consist of a
   major and a minor version number.  For example, in the version number 10.1,
   the 10 is the major version number and the 1 is the minor version number,
   meaning this would be the first minor release of the major release 10.  For
   releases before <productname>PostgreSQL</productname> version 10.0, version
   numbers consist of three numbers, for example, 9.5.3.  In those cases, the
   major version consists of the first two digit groups of the version number,
   e.g., 9.5, and the minor version is the third number, e.g., 3, meaning this
   would be the third minor release of the major release 9.5.
-->
現在の<productname>PostgreSQL</productname>メジャーバージョンとマイナーバージョンのバージョン番号で構成されます。
例えばバージョン番号は10.1は、10がメジャーバージョンで、1がマイナーバージョンです。メジャーリリース10の最初のマイナーリリースを意味します。
<productname>PostgreSQL</productname>の10.0より前のバージョンは, ３つの番号で構成されています。例えば9.5.3です。
この場合は、最初のメジャーバージョンが２つのグループのバージョン番号、例えば9.5で構成されています。
そしてマイナーバージョンは３つ目の番号で例えば3です。これはメージャーリリース9.5の３番めのマイナーリリースを意味します。
  </para>

  <para>
<!--
   Minor releases never change the internal storage format and are always
   compatible with earlier and later minor releases of the same major version
   number.  For example, version 10.1 is compatible with version 10.0 and
   version 10.6.  Similarly, for example, 9.5.3 is compatible with 9.5.0,
   9.5.1, and 9.5.6.  To update between compatible versions, you simply
   replace the executables while the server is down and restart the server.
   The data directory remains unchanged &mdash; minor upgrades are that
   simple.
-->
マイナーリリースでは内部格納書式が変わることは決してありませんので、同じメジャーバージョンにおける前後のマイナーリリースとの間で常に互換性があります。
例えばバージョン10.1はバージョン10.0やバージョン10.6と互換性があります。
同様に、例えば9.5.3は9.5.0、9.5.1、9.5.6と互換性があります
互換性があるバージョンとの間で更新するためには、サーバを停止させ、実行ファイルを置き換え、サーバを再起動させるだけです。
データディレクトリはまったく変更されません。
マイナーリリースのアップグレードは簡単です。
  </para>

  <para>
<!--
   For <emphasis>major</> releases of <productname>PostgreSQL</>, the
   internal data storage format is subject to change, thus complicating
   upgrades.  The traditional method for moving data to a new major version
   is to dump and reload the database, though this can be slow.  A
   faster method is <xref linkend="pgupgrade">.  Replication methods are
   also available, as discussed below.
-->
<productname>PostgreSQL</>の<emphasis>メジャー</>リリースでは、内部データ格納書式は変更されがちです。
したがって、アップグレードは複雑になります。
新しいメジャーバージョンにデータを移行する伝統的な方法は、遅くなることがありますが、データベースをダンプしてリロードすることです。より速い方法については、<xref linkend="pgupgrade">を参照してください。以下で説明するようにレプリケーションを使用する方法もあります。
  </para>

  <para>
<!--
   New major versions also typically introduce some user-visible
   incompatibilities, so application programming changes might be required.
   All user-visible changes are listed in the release notes (<xref
   linkend="release">);  pay particular attention to the section
   labeled "Migration".  If you are upgrading across several major
   versions, be sure to read the release notes for each intervening
   version.
-->
新しいメジャーバージョンは通常、ユーザにも影響する非互換性がいくつか導入されます。
このためアプリケーションのプログラム変更が必要になる可能性があります。
ユーザに影響する変更はすべてリリースノート（<xref linkend="release">）に列挙されています。
「移行」という名前の節に特に注意してください。
複数のメジャーバージョンをまたいでアップグレードする場合は、関連するバージョンそれぞれのリリースノートを確認してください。
  </para>

  <para>
<!--
   Cautious users will want to test their client applications on the new
   version before switching over fully; therefore, it's often a good idea to
   set up concurrent installations of old and new versions.  When
   testing a <productname>PostgreSQL</> major upgrade, consider the
   following categories of possible changes:
-->
用心深いユーザは、完全に切り替える前に新しいバージョンにおける自身のクライアントアプリケーションを試験したいと考えるでしょう。
このため古いバージョンと新しいバージョンを並行してインストールさせるというのは、よく良い考えとなります。
<productname>PostgreSQL</>メジャーアップグレードを試験する時、以下に示す変更があり得る分野を検討してください。
  </para>

  <variablelist>

   <varlistentry>
<!--
    <term>Administration</term>
-->
    <term>管理</term>
    <listitem>
     <para>
<!--
      The capabilities available for administrators to monitor and control
      the server often change and improve in each major release.
-->
各メジャーリリースにおいて、管理者が利用できるサーバの監視、制御機能はよく変更、向上されます。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>SQL</term>
    <listitem>
     <para>
<!--
      Typically this includes new SQL command capabilities and not changes
      in behavior, unless specifically mentioned in the release notes.
-->
通常、これには新しいSQLコマンド機能が含まれます。
リリースノートに特に記載がない限りその動作には変更はありません。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--
    <term>Library API</term>
-->
    <term>ライブラリAPI</term>
    <listitem>
     <para>
<!--
      Typically libraries like <application>libpq</> only add new
      functionality, again unless mentioned in the release notes.
-->
繰り返しになりますが、リリースノートに記載がない場合のみですが、通常<application>libpq</>のようなライブラリには新しい機能が追加されるだけです。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--
    <term>System Catalogs</term>
-->
    <term>システムカタログ</term>
    <listitem>
     <para>
<!--
      System catalog changes usually only affect database management tools.
-->
システムカタログの変更は通常データベース管理用ツールにのみ影響します。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--
    <term>Server C-language API</term>
-->
    <term>サーバC言語API</term>
    <listitem>
     <para>
<!--
      This involves changes in the backend function API, which is written
      in the C programming language.  Such changes affect code that
      references backend functions deep inside the server.
-->
ここには、Cプログラム言語で作成されたバックエンド関数APIにおける変更が含まれます。
こうした変更は、サーバ内部深くにあるバックエンド関数を参照するコードに影響します。
     </para>
    </listitem>
   </varlistentry>

  </variablelist>

  <sect2 id="upgrading-via-pgdumpall">
<!--
   <title>Upgrading Data via <application>pg_dumpall</></title>
-->
   <title><application>pg_dumpall</>を介したデータのアップグレード</title>

   <para>
<!--
    One upgrade method is to dump data from one major version of
    <productname>PostgreSQL</> and reload it in another &mdash;  to do
    this, you must use a <emphasis>logical</> backup tool like
    <application>pg_dumpall</>; file system
    level backup methods will not work. (There are checks in place that prevent
    you from using a data directory with an incompatible version of
    <productname>PostgreSQL</productname>, so no great harm can be done by
    trying to start the wrong server version on a data directory.)
-->
<productname>PostgreSQL</>のアップグレードの一つの方法は、<productname>PostgreSQL</>の１メジャーバージョンからデータをダンプし、別のバージョンにリロードすることです - これを行うには、<application>pg_dumpall</>のような<emphasis>論理</>バックアップツールを使用しなければなりません。
ファイルシステムレベルのバックアップ方法は動作しません。
（あるデータディレクトリ間違ったバージョンのサーバを起動しようとして、大きな損害が起こることがないように、適所に互換性がないバージョンの<productname>PostgreSQL</>のデータディレクトリが使用されないようにするための検査があります。）
   </para>

   <para>
<!--
    It is recommended that you use the <application>pg_dump</> and
    <application>pg_dumpall</> programs from the <emphasis>newer</>
    version of
    <productname>PostgreSQL</>, to take advantage of enhancements
    that might have been made in these programs.  Current releases of the
    dump programs can read data from any server version back to 7.0.
-->
新しいバージョンの<productname>PostgreSQL</>の<application>pg_dump</>と<application>pg_dumpall</>を使用することを勧めます。
これらのプログラムで拡張された機能を利用する可能性があるためです。
現在のリリースのダンププログラムは7.0以降のバージョンのサーバからデータを読み取ることができます。
   </para>

   <para>
<!--
    These instructions assume that your existing installation is under the
    <filename>/usr/local/pgsql</> directory, and that the data area is in
    <filename>/usr/local/pgsql/data</>.  Substitute your paths
    appropriately.
-->
以下の手順では、既存のインストレーションが<filename>/usr/local/pgsql</>以下にあり、そのデータ領域が<filename>/usr/local/pgsql/data</>にあることを前提としています。
使用しているパスに適切に置き換えてください。
   </para>

   <procedure>
    <step>
     <para>
<!--
      If making a backup, make sure that your database is not being updated.
      This does not affect the integrity of the backup, but the changed
      data would of course not be included. If necessary, edit the
      permissions in the file <filename>/usr/local/pgsql/data/pg_hba.conf</>
      (or equivalent) to disallow access from everyone except you.
      See <xref linkend="client-authentication"> for additional information on
      access control.
-->
バックアップを作成する場合、使用しているデータベースが確実に更新されないようにしてください。
これはバックアップの整合性には影響しませんが、当然ながら変更されたデータがバックアップに含まれません。
必要に応じて、<filename>/usr/local/pgsql/data/pg_hba.conf</>（またはこれと等価なファイル）における権限を変更して、バックアップを行うユーザ以外からのアクセスを禁止してください。
アクセス制御に関する情報は<xref linkend="client-authentication">を参照してください。
     </para>

     <para>
      <indexterm>
       <primary>pg_dumpall</primary>
<!--
       <secondary>use during upgrade</secondary>
-->
       <secondary>アップグレード中の使用</secondary>
      </indexterm>

<!--
      To back up your database installation, type:
-->
データベースインストレーションをバックアップするためには以下を入力してください。
<screen>
<userinput>pg_dumpall &gt; <replaceable>outputfile</></userinput>
</screen>
     </para>

     <para>
<!--
      To make the backup, you can use the <application>pg_dumpall</application>
      command from the version you are currently running;  see <xref
      linkend="backup-dump-all"> for more details.  For best
      results, however, try to use the <application>pg_dumpall</application>
      command from <productname>PostgreSQL</productname> &version;,
      since this version contains bug fixes and improvements over older
      versions.  While this advice might seem idiosyncratic since you
      haven't installed the new version yet, it is advisable to follow
      it if you plan to install the new version in parallel with the
      old version.  In that case you can complete the installation
      normally and transfer the data later.  This will also decrease
      the downtime.
-->
バックアップを作成するために、現在起動中のバージョンの<application>pg_dumpall</application>コマンドを使用することができます。詳細は<xref linkend="backup-dump-all"> を参照してください。
しかし最善の結果を得るためには、<productname>PostgreSQL</productname> &version;の<application>pg_dumpall</application>コマンドを試してください。
このバージョンでは、過去のバージョンに対して、不具合の修正や改良が含まれているからです。
新しいバージョンをまだインストールしていませんので、この勧告は奇異に思えるかもしれませんが、古いバージョンと並行して新しいバージョンをインストールすることを計画しているのであれば、これに従うことを推奨します。
この場合、インストールを普通に完了させてからデータを移行することができます。
これは同時に停止時間を短縮します。
     </para>
    </step>

    <step>
     <para>
<!--
      Shut down the old server:
-->
古いサーバを停止します。
<screen>
<userinput>pg_ctl stop</>
</screen>
<!--
      On systems that have <productname>PostgreSQL</> started at boot time,
      there is probably a start-up file that will accomplish the same thing. For
      example, on a <systemitem class="osname">Red Hat Linux</> system one
      might find that this works:
-->
起動時に<productname>PostgreSQL</>を実行させるようにしているシステムではおそらく、同じことを達成する起動ファイルがあります。
例えば<systemitem class="osname">Red Hat Linux</>システムでは、以下が動作することが分かります。
<screen>
<userinput>/etc/rc.d/init.d/postgresql stop</userinput>
</screen>
<!--
      See <xref linkend="runtime"> for details about starting and
      stopping the server.
-->
サーバの起動と停止については<xref linkend="runtime">を参照してください。
     </para>
    </step>

    <step>
     <para>
<!--
      If restoring from backup, rename or delete the old installation
      directory if it is not version-specific.  It is a good idea to
      rename the directory, rather than
      delete it, in case you have trouble and need to revert to it.  Keep
      in mind the directory might consume significant disk space.  To rename
      the directory, use a command like this:
-->
バックアップからリストアする場合、名前を変更、またはバージョン固有でない場合は古いインストレーションディレクトリを削除してください。
問題があった場合に戻さなければならない場合に備え、削除するよりディレクトリの名前を変更する方を勧めます。
このディレクトリが多くのディスク容量を占めている可能性があることに注意してください。
ディレクトリの名前を変更するためには、以下のようなコマンドを使用してください。
<screen>
<userinput>mv /usr/local/pgsql /usr/local/pgsql.old</>
</screen>
<!--
     (Be sure to move the directory as a single unit so relative paths
     remain unchanged.)
-->
（相対パスが維持されるように確実にディレクトリ単位で移動してください。）
     </para>
    </step>

    <step>
     <para>
<!--
      Install the new version of <productname>PostgreSQL</productname> as
      outlined in <![%standalone-include[the next section.]]>
      <![%standalone-ignore[<xref linkend="install-procedure">.]]>
-->
概要を<![%standalone-include[次節]]> <![%standalone-ignore[<xref linkend="install-procedure">.]]>で示すように、新しいバージョンの<productname>PostgreSQL</productname>をインストールしてください。
     </para>
    </step>

    <step>
     <para>
<!--
      Create a new database cluster if needed.  Remember that you must
      execute these commands while logged in to the special database user
      account (which you already have if you are upgrading).
-->
必要に応じて新しいデータベースクラスタを作成してください。
（アップグレードの場合はすでに存在している）特別なデータベースユーザアカウントでログインして、このコマンドを実行しなければならないことに注意してください。
<programlisting>
<userinput>/usr/local/pgsql/bin/initdb -D /usr/local/pgsql/data</>
</programlisting>
     </para>
    </step>

    <step>
     <para>
<!--
      Restore your previous <filename>pg_hba.conf</> and any
      <filename>postgresql.conf</> modifications.
-->
以前の<filename>pg_hba.conf</>と<filename>postgresql.conf</>に加えた何らかの変更を戻してください。
     </para>
    </step>

    <step>
     <para>
<!--
      Start the database server, again using the special database user
      account:
-->
繰り返しになりますが、特別なデータベースユーザアカウントを使用して、データベースサーバを起動してください。
<programlisting>
<userinput>/usr/local/pgsql/bin/postgres -D /usr/local/pgsql/data</>
</programlisting>
     </para>
    </step>

    <step>
     <para>
<!--
      Finally, restore your data from backup with:
-->
最後に、<emphasis>新しい</><application>psql</>を用いて、バックアップからデータをリストアしてください。
<screen>
<userinput>/usr/local/pgsql/bin/psql -d postgres -f <replaceable>outputfile</></userinput>
</screen>
<!--
      using the <emphasis>new</> <application>psql</>.
-->
     </para>
    </step>
   </procedure>

   <para>
<!--
    The least downtime can be achieved by installing the new server in
    a different directory and running both the old and the new servers
    in parallel, on different ports. Then you can use something like:
-->
新しいサーバを異なるディレクトリにインストールし、古いサーバと新しいサーバを別のポートで並行して実行させることで、停止時間を最小にすることができます。
この場合、データを移行するために以下のようなコマンドを使用することができます。

<programlisting>
pg_dumpall -p 5432 | psql -d postgres -p 5433
</programlisting>
<!--
    to transfer your data.
-->
   </para>

  </sect2>

  <sect2 id="upgrading-via-pg-upgrade">
<!--
   <title>Upgrading Data via <application>pg_upgrade</></title>
-->
   <title><application>pg_upgrade</>を使用したアップグレード方法</title>

   <para>
<!--
    The <xref linkend="pgupgrade"> module allows an installation to
    be migrated in-place from one major <productname>PostgreSQL</>
    version to another.  Upgrades can be performed in minutes,
    particularly with <option>&#045;&#045;link</> mode.  It requires steps similar to
    <application>pg_dumpall</> above, e.g.  starting/stopping the server,
    running <application>initdb</>.  The <application>pg_upgrade</> <link
    linkend="pgupgrade">documentation</> outlines the necessary steps.
-->
<xref linkend="pgupgrade">モジュールにより、<productname>PostgreSQL</>のあるバージョンから次のバージョンにインストレーションをその場で移行することができます。
特に<option>--link</>オプションを使用することで、アップグレードは数分で行うことができます。
これは、<application>pg_dumpall</>と同様の工程を必要とします。
例えば、<application>initdb</>を実行し、サーバの起動／停止をおこないます。
<application>pg_upgrade</> <link linkend="pgupgrade">ドキュメント</>で必要な手順を説明します。
   </para>

  </sect2>

  <sect2 id="upgrading-via-replication">
<!--
   <title>Upgrading Data via Replication</title>
-->
   <title>レプリケーション経由のアップグレード</title>

   <para>
<!--
    It is also possible to use certain replication methods, such as
    <productname>Slony</>, to create a standby server with the updated version of
    <productname>PostgreSQL</>.  This is possible because Slony supports
    replication between different major versions of
    <productname>PostgreSQL</>.  The standby can be on the same computer or
    a different computer.  Once it has synced up with the master server
    (running the older version of <productname>PostgreSQL</>), you can
    switch masters and make the standby the master and shut down the older
    database instance.  Such a switch-over results in only several seconds
    of downtime for an upgrade.
-->
更新対象のバージョンの<productname>PostgreSQL</>をスタンバイサーバとして作成して、<productname>Slony</>などの特定のレプリケーション方式を使用することもできます。
Slonyが異なるメジャーバージョンの<productname>PostgreSQL</>との間でレプリケーションすることができるため、これが実現できます。
スタンバイは同じコンピュータで作成することも異なるコンピュータで作成することもできます。
（古いバージョンの<productname>PostgreSQL</>で実行している）マスタサーバと同期した後、マスタを切り替え、スタンバイをマスタにし、古いデータベースインスタンスを停止することができます。
このようなスイッチオーバの結果、数秒の停止時間でアップグレードされます。
   </para>

  </sect2>
 </sect1>

 <sect1 id="preventing-server-spoofing">
<!--
  <title>Preventing Server Spoofing</title>
-->
  <title>サーバのなりすまし防止</title>

  <indexterm zone="preventing-server-spoofing">
<!--
   <primary>server spoofing</primary>
-->
   <primary>サーバのなりすまし</primary>
  </indexterm>

  <para>
<!--
   While the server is running, it is not possible for a malicious user
   to take the place of the normal database server.  However, when the
   server is down, it is possible for a local user to spoof the normal
   server by starting their own server.  The spoof server could read
   passwords and queries sent by clients, but could not return any data
   because the <varname>PGDATA</> directory would still be secure because
   of directory permissions. Spoofing is possible because any user can
   start a database server; a client cannot identify an invalid server
   unless it is specially configured.
-->
サーバが稼動中、悪意のあるユーザが通常のデータベースサーバに取って代わることはできません。
しかし、サーバが停止している時、ローカルユーザに対し、独自のサーバを起動させることで正常なサーバになりすますことは可能です。
なりすましたサーバで、クライアントから送信されたパスワードを読み取ることも問い合わせを読み取ることも可能です。
しかし、<varname>PGDATA</>ディレクトリの安全性はディレクトリの権限により維持されていますので、データを返すことはできません。
誰もがデータベースサーバを起動させることができるため、なりすましは可能です。
特殊な設定がなされていなければ、クライアントは無効なサーバであることを識別できません。
  </para>

  <para>
<!--
   One way to prevent spoofing of <literal>local</>
   connections is to use a Unix domain socket directory (<xref
   linkend="guc-unix-socket-directories">) that has write permission only
   for a trusted local user.  This prevents a malicious user from creating
   their own socket file in that directory.  If you are concerned that
   some applications might still reference <filename>/tmp</> for the
   socket file and hence be vulnerable to spoofing, during operating system
   startup create a symbolic link <filename>/tmp/.s.PGSQL.5432</> that points
   to the relocated socket file.  You also might need to modify your
   <filename>/tmp</> cleanup script to prevent removal of the symbolic link.
-->
<literal>local</>接続に対してなりすましを防ぐ、ひとつの方法は、信頼できるローカルユーザのみに書き込み権限を付与したUnixドメインソケットディレクトリ（<xref linkend="guc-unix-socket-directories">）を使用することです。
これにより、悪意のあるユーザがそのディレクトリに独自のソケットを作成することを防ぐことができます。
一部のアプリケーションがソケットファイルのために<filename>/tmp</>を参照し、なりすましに対して脆弱であるかもしれないと気にするならば、オペレーティングシステムの起動時に、再割り当てされたソケットファイルを指し示す<filename>/tmp/.s.PGSQL.5432</>というシンボリックリンクを作成してください。
また、このシンボリックリンクが削除されることを防ぐために、<filename>/tmp</>を整理するスクリプトを変更する必要があるかもしれません。
  </para>

  <para>
<!--
   Another option for <literal>local</> connections is for clients to use
   <link linkend="libpq-connect-requirepeer"><literal>requirepeer</></>
   to specify the required owner of the server process connected to
   the socket.
-->
<literal>local</>接続についての別の選択肢は、クライアントが<link linkend="libpq-connect-requirepeer"><literal>requirepeer</></>を使用して、ソケットに接続しているサーバプロセスの必要な所有者を指定することです。
  </para>

  <para>
<!--
   To prevent spoofing on TCP connections, the best solution is to use
   SSL certificates and make sure that clients check the server's certificate.
   To do that, the server
   must be configured to accept only <literal>hostssl</> connections (<xref
   linkend="auth-pg-hba-conf">) and have SSL key and certificate files
   (<xref linkend="ssl-tcp">). The TCP client must connect using
   <literal>sslmode=verify-ca</> or
   <literal>verify-full</> and have the appropriate root certificate
   file installed (<xref linkend="libq-ssl-certificates">).
-->
TCP接続のなりすましを防ぐための最善の方法は、SSL証明書を使用し、クライアントがサーバの証明書を確実に検査することです。
これを行うためには、サーバは<literal>hostssl</>接続（<xref linkend="auth-pg-hba-conf">）のみを受け付け、SSLキーと証明書ファイル（<xref linkend="ssl-tcp">）を持たせる必要があります。
TCPクライアントは<literal>sslmode=verify-ca</>もしくは<literal>verify-full</>を使用して接続し、また、適切なルート証明書ファイルをインストールしなければなりません（<xref linkend="libq-ssl-certificates">）。
  </para>
 </sect1>

 <sect1 id="encryption-options">
<!--
  <title>Encryption Options</title>
-->
  <title>暗号化オプション</title>

  <indexterm zone="encryption-options">
<!--
   <primary>encryption</primary>
-->
   <primary>暗号化</primary>
  </indexterm>

  <para>
<!--
   <productname>PostgreSQL</productname> offers encryption at several
   levels, and provides flexibility in protecting data from disclosure
   due to database server theft, unscrupulous administrators, and
   insecure networks. Encryption might also be required to secure
   sensitive data such as medical records or financial transactions.
-->
<productname>PostgreSQL</productname>は、複数レベルの暗号化を備え、データベースサーバ自身、管理者の注意不足、安全ではないネットワークを原因とした漏洩からデータを柔軟に保護することができます。
また、医療記録や金融取引など高セキュリティが求められるデータを格納する場合に暗号化が必要な場合もあります。
  </para>

  <variablelist>

  <varlistentry>
<<<<<<< HEAD
<!--
   <term>Password Storage Encryption</term>
-->
   <term>パスワード格納に関する暗号化</term>
   <listitem>

    <para>
<!--
     By default, database user passwords are stored as MD5 hashes, so
     the administrator cannot determine the actual password assigned
     to the user. If MD5 encryption is used for client authentication,
     the unencrypted password is never even temporarily present on the
     server because the client MD5-encrypts it before being sent
     across the network.
-->
デフォルトでは、データベースユーザのパスワードはMD5ハッシュとして格納されます。
ですので、ユーザに割り当てられているパスワードは管理者でも分かりません。
MD5暗号化がクライアント認証に使用されている場合、平文のパスワードはサーバ上に一時的にも存在することはありません。
ネットワーク上に流れる前にクライアントがMD5暗号化を行うからです。
=======
   <term>Password Encryption</term>
   <listitem>

    <para>
     Database user passwords are stored as hashes (determined by the setting
     <xref linkend="guc-password-encryption">), so the administrator cannot
     determine the actual password assigned to the user. If SCRAM or MD5
     encryption is used for client authentication, the unencrypted password is
     never even temporarily present on the server because the client encrypts
     it before being sent across the network. SCRAM is preferred, because it
     is an Internet standard and is more secure than the PostgreSQL-specific
     MD5 authentication protocol.
>>>>>>> REL_10_3
    </para>
   </listitem>
  </varlistentry>

  <varlistentry>
<!--
   <term>Encryption For Specific Columns</term>
-->
   <term>特定の列に関する暗号化</term>

   <listitem>
    <para>
<!--
     The <xref linkend="pgcrypto"> module allows certain fields to be
     stored encrypted.
     This is useful if only some of the data is sensitive.
     The client supplies the decryption key and the data is decrypted
     on the server and then sent to the client.
-->
<xref linkend="pgcrypto">モジュールにより、あるフィールドを暗号化して保存することができます。
データの一部が極秘データであるような場合に有用です。
クライアントが提供した復号化用のキーで、サーバ上のデータを復号化し、クライアントに返されます。
    </para>

    <para>
<!--
     The decrypted data and the decryption key are present on the
     server for a brief time while it is being decrypted and
     communicated between the client and server. This presents a brief
     moment where the data and keys can be intercepted by someone with
     complete access to the database server, such as the system
     administrator.
-->
復号化されたデータと復号化用のキーは、復号処理中およびクライアントサーバ間の通信中サーバ上に存在している時間があります。
このため、データベースサーバへのすべてのアクセス権限を持つユーザ（例えばシステム管理者）によって、データとキーが盗まれるわずかな時間があります。
    </para>
   </listitem>
  </varlistentry>

  <varlistentry>
<!--
   <term>Data Partition Encryption</term>
-->
   <term>データパーティションに関する暗号化</term>

   <listitem>
    <para>
<!--
     Storage encryption can be performed at the file system level or the
     block level.  Linux file system encryption options include eCryptfs
     and EncFS, while FreeBSD uses PEFS.  Block level or full disk
     encryption options include dm-crypt + LUKS on Linux and GEOM
     modules geli and gbde on FreeBSD.  Many other operating systems
     support this functionality, including Windows.
-->
ストレージの暗号化は、ファイルシステムレベルまたはブロックレベルで行うことができます。
Linuxファイルシステムの暗号化オプションには、eCryptfsとEncFSがあります。一方、FreeBSDではPEFSを使用します。
ブロックレベルまたはフルディスクの暗号化オプションとして、Linuxにはdm-crypt + LUKS、FreeBSDにはGEOMモジュールのgeliとgbdeがあります。
これにより、ファイルシステムパーティション全体をディスク上で暗号化することができます。
他の多くのオペレーティングシステムは、Windowsを含め、この機能をサポートしています。
    </para>

    <para>
<!--
     This mechanism prevents unencrypted data from being read from the
     drives if the drives or the entire computer is stolen. This does
     not protect against attacks while the file system is mounted,
     because when mounted, the operating system provides an unencrypted
     view of the data. However, to mount the file system, you need some
     way for the encryption key to be passed to the operating system,
     and sometimes the key is stored somewhere on the host that mounts
     the disk.
-->
この機構により、ディスク装置やコンピュータ全体が盗まれた場合でも、ディスクから平文のデータが読み取られることを防止できます。
ファイルシステムがマウントされている時は、この機構による保護は働きません。
マウント時にはオペレーティングシステムが復号化したデータを提供するからです。
しかし、ファイルシステムをマウントするためになんらかの方法で暗号化キーをオペレーティングシステムに渡さなければなりません。
そのディスク装置をマウントするホストのどこかに暗号化キーを格納している場合もあります。
    </para>
   </listitem>
  </varlistentry>

  <varlistentry>
<<<<<<< HEAD
<!--
   <term>Encrypting Passwords Across A Network</term>
-->
   <term>ネットワーク越しのパスワード暗号化</term>

   <listitem>
     <para>
<!--
      The <literal>MD5</> authentication method double-encrypts the
      password on the client before sending it to the server. It first
      MD5-encrypts it based on the user name, and then encrypts it
      based on a random salt sent by the server when the database
      connection was made. It is this double-encrypted value that is
      sent over the network to the server. Double-encryption not only
      prevents the password from being discovered, it also prevents
      another connection from using the same encrypted password to
      connect to the database server at a later time.
-->
<literal>MD5</>認証方式は、サーバにパスワードを送信する前に、パスワードを二重に暗号化します。
まず、ユーザ名を元にパスワードをMD5で暗号化します。
そして、データベース接続が確立した時に、ランダムなソルトを使用して更に暗号化します。
この二重に暗号化された値が、ネットワーク越しにサーバへ渡されます。
二重の暗号化により、パスワードの盗聴を防ぐだけではなく、将来確立する別の接続で同じ暗号化値が使用されなくなります。
     </para>
    </listitem>
  </varlistentry>

  <varlistentry>
<!--
=======
>>>>>>> REL_10_3
   <term>Encrypting Data Across A Network</term>
-->
   <term>ネットワーク越しのデータ暗号化</term>

    <listitem>
     <para>
<!--
      SSL connections encrypt all data sent across the network: the
      password, the queries, and the data returned. The
      <filename>pg_hba.conf</> file allows administrators to specify
      which hosts can use non-encrypted connections (<literal>host</>)
      and which require SSL-encrypted connections
      (<literal>hostssl</>). Also, clients can specify that they
      connect to servers only via SSL. <application>Stunnel</> or
      <application>SSH</> can also be used to encrypt transmissions.
-->
SSL接続により、ネットワーク越しに送信されるデータ（パスワード、問い合わせ、結果のデータ）はすべて暗号化されます。
<filename>pg_hba.conf</>ファイルを使用して、管理者はどのホストは暗号化しない接続を使用し（<literal>host</>）、どのホストがSSLで暗号化された接続を必要とするか（<literal>hostssl</>）を指定することができます。
また、SSL経由のサーバとの接続のみを使用するようにクライアントで指定することもできます。
<application>Stunnel</>や<application>SSH</>を使用して暗号化転送を行うこともできます。
     </para>
    </listitem>
  </varlistentry>

  <varlistentry>
<!--
   <term>SSL Host Authentication</term>
-->
   <term>SSLホスト認証</term>

   <listitem>
    <para>
<!--
     It is possible for both the client and server to provide SSL
     certificates to each other. It takes some extra configuration
     on each side, but this provides stronger verification of identity
     than the mere use of passwords. It prevents a computer from
     pretending to be the server just long enough to read the password
     sent by the client. It also helps prevent <quote>man in the middle</>
     attacks where a computer between the client and server pretends to
     be the server and reads and passes all data between the client and
     server.
-->
クライアントとサーバの両方で証明書を互いに提供することができます。
これには両方で追加の設定を行わなければなりませんが、これにより単なるパスワードの使用よりも強力な身元の検証を行うことができます。
クライアントから送信されたパスワードを盗聴する偽装サーバからコンピュータを保護します。
また、クライアントとサーバとの間にあるコンピュータがサーバになりすまし、クライアントとサーバ間で流れるデータを読み取り中継する、<quote>中間者</>攻撃から保護することもできます。
    </para>
   </listitem>
  </varlistentry>

  <varlistentry>
<!--
   <term>Client-Side Encryption</term>
-->
   <term>クライアントサイドの暗号化</term>

   <listitem>
    <para>
<!--
     If the system administrator for the server's machine cannot be trusted,
     it is necessary
     for the client to encrypt the data; this way, unencrypted data
     never appears on the database server. Data is encrypted on the
     client before being sent to the server, and database results have
     to be decrypted on the client before being used.
-->
サーバマシンのシステム管理者を信頼できない場合、クライアント側でデータを暗号化する必要があります。
この場合、平文のデータはデータベースサーバ上に存在しません。
データはサーバに送信される前にクライアント上で暗号化されます。
また、使用する前にデータベースからの結果をクライアントで復号化しなければなりません。
    </para>
   </listitem>
  </varlistentry>

  </variablelist>

 </sect1>

 <sect1 id="ssl-tcp">
<!--
  <title>Secure TCP/IP Connections with SSL</title>
-->
<title>SSLによる安全なTCP/IP接続</title>

  <indexterm zone="ssl-tcp">
   <primary>SSL</primary>
  </indexterm>

  <para>
<!--
   <productname>PostgreSQL</> has native support for using
   <acronym>SSL</> connections to encrypt client/server communications
   for increased security. This requires that
   <productname>OpenSSL</productname> is installed on both client and
   server systems and that support in <productname>PostgreSQL</> is
   enabled at build time (see <xref linkend="installation">).
-->
<productname>PostgreSQL</>は標準で<acronym>SSL</>接続をサポートし、クライアント/サーバの通信がさらに安全になるよう暗号化します。
そのためには<productname>OpenSSL</productname>がクライアントとサーバシステムの両方にインストールされ、構築時に<productname>PostgreSQL</>におけるそのサポートが有効になっている必要があります（<xref linkend="installation">を参照してください）。
  </para>

  <para>
<!--
   With <acronym>SSL</> support compiled in, the
   <productname>PostgreSQL</> server can be started with
   <acronym>SSL</> enabled by setting the parameter
   <xref linkend="guc-ssl"> to <literal>on</> in
   <filename>postgresql.conf</>.  The server will listen for both normal
   and <acronym>SSL</> connections on the same TCP port, and will negotiate
   with any connecting client on whether to use <acronym>SSL</>.  By
   default, this is at the client's option; see <xref
   linkend="auth-pg-hba-conf"> about how to set up the server to require
   use of <acronym>SSL</> for some or all connections.
-->
<acronym>SSL</>サポートを有効にしてコンパイルされた場合、<productname>PostgreSQL</>サーバは、<filename>postgresql.conf</>において<xref linkend="guc-ssl">パラメータを<literal>on</>にすることで、<acronym>SSL</>サポートを有効にして起動することができます。
サーバは同じTCPポートで通常の接続と<acronym>SSL</>接続の両方を待ち受け、クライアントとの接続に<acronym>SSL</>を使用するかどうかを調停します。
デフォルトでは、これはクライアント側の選択肢です。
一部またはすべての接続で<acronym>SSL</>の使用を必要とさせるためのサーバ側の設定方法に関しては<xref linkend="auth-pg-hba-conf">を参照してください。
  </para>

  <para>
<!--
   <productname>PostgreSQL</productname> reads the system-wide
   <productname>OpenSSL</productname> configuration file. By default, this
   file is named <filename>openssl.cnf</filename> and is located in the
   directory reported by <literal>openssl version -d</>.
   This default can be overridden by setting environment variable
   <envar>OPENSSL_CONF</envar> to the name of the desired configuration file.
-->
<productname>PostgreSQL</productname>は、システム全体用の<productname>OpenSSL</productname>設定ファイルを読み取ります。
デフォルトでは、このファイルの名前は<filename>openssl.cnf</filename>であり、<literal>openssl version -d</>で報告されるディレクトリに存在します。
このデフォルトは、環境変数<envar>OPENSSL_CONF</envar>を希望する設定ファイルの名前に設定することにより変更可能です。
  </para>

  <para>
<!--
   <productname>OpenSSL</productname> supports a wide range of ciphers
   and authentication algorithms, of varying strength.  While a list of
   ciphers can be specified in the <productname>OpenSSL</productname>
   configuration file, you can specify ciphers specifically for use by
   the database server by modifying <xref linkend="guc-ssl-ciphers"> in
   <filename>postgresql.conf</>.
-->
<productname>OpenSSL</productname>は、強度が異なる、多くの暗号化および認証用のアルゴリズムをサポートします。
暗号の一覧は<productname>OpenSSL</productname>設定ファイル内で指定することができますが、<filename>postgresql.conf</>内の<xref linkend="guc-ssl-ciphers">を変更することで、データベースサーバで使用される暗号を指定することができます。
  </para>

  <note>
   <para>
<!--
    It is possible to have authentication without encryption overhead by
    using <literal>NULL-SHA</> or <literal>NULL-MD5</> ciphers.  However,
    a man-in-the-middle could read and pass communications between client
    and server.  Also, encryption overhead is minimal compared to the
    overhead of authentication.  For these reasons NULL ciphers are not
    recommended.
-->
<literal>NULL-SHA</>または<literal>NULL-MD5</>暗号を使用して暗号化のオーバーヘッドなしで認証を行うことが可能です。
しかし、中間者はクライアントサーバ間の通信を読み取り中継することができます。
また、暗号化のオーバーヘッドは認証のオーバーヘッドと比べると最小です。
こうした理由によりNULL暗号は推奨しません。
   </para>
  </note>

  <para>
<!--
   To start in <acronym>SSL</> mode, files containing the server certificate
   and private key must exist.  By default, these files are expected to be
   named <filename>server.crt</> and <filename>server.key</>, respectively, in
   the server's data directory, but other names and locations can be specified
   using the configuration parameters <xref linkend="guc-ssl-cert-file">
   and <xref linkend="guc-ssl-key-file">.
-->
<acronym>SSL</>モードで起動するには、サーバ証明書と秘密鍵を含むファイルが存在していなければなりません。
デフォルトでは、これらのファイルは<filename>server.crt</>および<filename>server.key</>という名前で、それぞれがサーバのデータディレクトリに存在していることが想定されていますが、設定パラメータの<xref linkend="guc-ssl-cert-file">と<xref linkend="guc-ssl-key-file">によって他の名前、他の場所を指定することもできます。
  </para>

  <para>
<!--
   On Unix systems, the permissions on <filename>server.key</filename> must
   disallow any access to world or group; achieve this by the command
   <command>chmod 0600 server.key</command>.  Alternatively, the file can be
   owned by root and have group read access (that is, <literal>0640</literal>
   permissions).  That setup is intended for installations where certificate
   and key files are managed by the operating system.  The user under which
   the <productname>PostgreSQL</productname> server runs should then be made a
   member of the group that has access to those certificate and key files.
-->
Unixシステムでは、<filename>server.key</filename>の権限は所有者以外からのアクセスを許可してはなりません。
これは<command>chmod 0600 server.key</command>というコマンドで実現できます。
あるいは、このファイルの所有者をrootにして、グループに読み取りアクセス権を与える（つまり、パーミッションを<literal>0640</literal>にする）ということもできます。
この設定は、証明書と鍵ファイルがオペレーティングシステムによって管理されるインストレーションのためのものです。
<productname>PostgreSQL</productname>サーバを実行するユーザは、証明書と鍵ファイルにアクセス権のあるグループのメンバーにする必要があります。
  </para>

  <para>
<!--
   If the private key is protected with a passphrase, the
   server will prompt for the passphrase and will not start until it has
   been entered.
   Using a passphrase also disables the ability to change the server's SSL
   configuration without a server restart.
   Furthermore, passphrase-protected private keys cannot be used at all
   on Windows.
-->
秘密キーがパスフレーズで保護されている場合、サーバはパスフレーズの入力を促し、入力されるまでは起動しません。
パスフレーズを使用すると、サーバを再起動せずにサーバのSSL設定を変更する機能も無効になります。
さらに、パスフレーズで保護された秘密鍵は、Windowsではまったく使用できません。
  </para>

  <para>
<<<<<<< HEAD
<!--
   In some cases, the server certificate might be signed by an
   <quote>intermediate</> certificate authority, rather than one that is
   directly trusted by clients.  To use such a certificate, append the
   certificate of the signing authority to the <filename>server.crt</> file,
   then its parent authority's certificate, and so on up to a certificate
   authority, <quote>root</> or <quote>intermediate</>, that is trusted by
   clients, i.e. signed by a certificate in the clients'
   <filename>root.crt</filename> files.
-->
サーバ証明書がクライアントで直接信頼している認証局ではなく、<quote>中間</>認証局により署名されている場合があります。
こうした証明書を使用するために、<filename>server.crt</>ファイルに署名した認証局の証明書を追加し、その後、クライアントが信頼しているルートまたは中間までの認証局証明書を追加します。クライアントが信頼しているとは、クライアントにある<filename>root.crt</filename>ファイルの認証局による署名がある証明書です。
=======
   The first certificate in <filename>server.crt</> must be the
   server's certificate because it must match the server's private key.
   The certificates of <quote>intermediate</> certificate authorities
   can also be appended to the file.  Doing this avoids the necessity of
   storing intermediate certificates on clients, assuming the root and
   intermediate certificates were created with <literal>v3_ca</>
   extensions.  This allows easier expiration of intermediate certificates.
  </para>

  <para>
   It is not necessary to add the root certificate to
   <filename>server.crt</>.  Instead, clients must have the root
   certificate of the server's certificate chain.
>>>>>>> REL_10_3
  </para>

  <sect2 id="ssl-client-certificates">
  <!--
   <title>Using Client Certificates</title>
   -->
   <title>クライアント証明書の使用</title>

  <para>
<<<<<<< HEAD
<!--
   To require the client to supply a trusted certificate, place
   certificates of the certificate authorities (<acronym>CA</acronym>s)
   you trust in the file <filename>root.crt</filename> in the data
=======
   To require the client to supply a trusted certificate,
   place certificates of the root certificate authorities
   (<acronym>CA</>s) you trust in a file in the data
>>>>>>> REL_10_3
   directory, set the parameter <xref linkend="guc-ssl-ca-file"> in
   <filename>postgresql.conf</> to the new file name, and add the
   authentication option <literal>clientcert=1</> to the appropriate
   <literal>hostssl</> line(s) in <filename>pg_hba.conf</>.
   A certificate will then be requested from the client during SSL
   connection startup.  (See <xref linkend="libpq-ssl"> for a description
   of how to set up certificates on the client.)  The server will
   verify that the client's certificate is signed by one of the trusted
   certificate authorities.
-->
クライアントに信頼できる証明書を要求するためには、信頼する認証局（<acronym>CA</acronym>）の証明書をデータディレクトリ内の<filename>root.crt</filename>ファイルに置き、<filename>postgresql.conf</filename>の<xref linkend="guc-ssl-ca-file">パラメータを<literal>root.crt</literal>に設定し、認証オプション<literal>clientcert=1</literal>を<filename>pg_hba.conf</>の適切な<literal>hostssl</>行に追加します。
そうすると、SSL接続の開始時にクライアントへ証明書が要求されます。
（クライアント上での証明書の設定方法については<xref linkend="libpq-ssl">を参照してください。）
サーバは、クライアントの証明書が信頼する認証局のいずれかにより署名されていることを検証します。
  </para>

  <para>
<<<<<<< HEAD
<!--
   If intermediate <acronym>CA</>s appear in
   <filename>root.crt</filename>, the file must also contain certificate
   chains to their root <acronym>CA</>s.  Certificate Revocation List
   (CRL) entries
   are also checked if the parameter <xref linkend="guc-ssl-crl-file"> is set.
-->
   <!--原文コメント If this URL changes replace it with a URL to www.archive.org. -->
<!--
=======
   Intermediate certificates that chain up to existing root certificates
   can also appear in the file <filename>root.crt</filename> if
   you wish to avoid storing them on clients (assuming the root and
   intermediate certificates were created with <literal>v3_ca</>
   extensions).  Certificate Revocation List (CRL) entries are also
   checked if the parameter <xref linkend="guc-ssl-crl-file"> is set.
   <!-- If this URL changes replace it with a URL to www.archive.org. -->
>>>>>>> REL_10_3
   (See <ulink
   url="http://h71000.www7.hp.com/doc/83final/ba554_90007/ch04s02.html"></>
   for diagrams showing SSL certificate usage.)
-->
中間<acronym>CA</>が<filename>root.crt</filename>に記載されている場合、ファイルにはルート<acronym>CA</>までの証明書チェーンが含まれている必要があります。
<xref linkend="guc-ssl-crl-file">パラメータが設定されている場合、証明書失効リスト（CRL）項目も検査されます。
（SSL証明書の使用方法を示す図については<ulink url="http://h71000.www7.hp.com/doc/83final/ba554_90007/ch04s02.html"></>を参照してください。）
  </para>

  <para>
<!--
   The <literal>clientcert</literal> authentication option is available for
   all authentication methods, but only in <filename>pg_hba.conf</> lines
   specified as <literal>hostssl</>.  When <literal>clientcert</literal> is
   not specified or is set to 0, the server will still verify any presented
   client certificates against its CA file, if one is configured &mdash; but
   it will not insist that a client certificate be presented.
-->
認証オプション<literal>clientcert</literal>はすべての認証方式について利用可能ですが、<filename>pg_hba.conf</>の<literal>hostssl</>として指定された行でのみ有効です。
<literal>clientcert</literal>が指定されていない、または0と設定されている場合でも、認証局のリストが設定されていれば、サーバはその認証局に対してクライアント証明書の検証を行いますが、クライアント証明書を提示することを要求しません。
  </para>

  <para>
<<<<<<< HEAD
<!--
   Note that the server's <filename>root.crt</filename> lists the top-level
   CAs that are considered trusted for signing client certificates.
   In principle it need
   not list the CA that signed the server's certificate, though in most cases
   that CA would also be trusted for client certificates.
-->
サーバの<filename>root.crt</filename>は、クライアント証明書の署名に対して信頼できるとみなしている最上位のCAを列挙していることに注意してください。
原理的には、サーバの証明書を署名したCAを列挙する必要はありませんが、ほとんどの場合、そのCAはクライアント証明書でも信頼されています。
  </para>

  <para>
<!--
=======
>>>>>>> REL_10_3
   If you are setting up client certificates, you may wish to use
   the <literal>cert</> authentication method, so that the certificates
   control user authentication as well as providing connection security.
   See <xref linkend="auth-cert"> for details.  (It is not necessary to
   specify <literal>clientcert=1</literal> explicitly when using
   the <literal>cert</> authentication method.)
-->
クライアント証明書を設定している場合、接続の安全性を提供するとともに証明書でユーザ認証を制御できるように<literal>cert</>認証方式を使用したいと考えるかもしれません。
詳細については<xref linkend="auth-cert">を参照してください。
（<literal>cert</>認証方式を使用している場合は、明示的に<literal>clientcert=1</literal>を指定する必要はありません。）
  </para>
  </sect2>

  <sect2 id="ssl-server-files">
<!--
   <title>SSL Server File Usage</title>
-->
   <title>サーバにおけるSSL関連ファイルの利用</title>

   <para>
<!--
    <xref linkend="ssl-file-usage"> summarizes the files that are
    relevant to the SSL setup on the server.  (The shown file names are default
    or typical names.  The locally configured names could be different.)
-->
<xref linkend="ssl-file-usage">にて、サーバにおけるSSLの設定に関連するファイルをまとめます。
（表示されているファイル名はデフォルトまたは一般的な名前です。異なる名前を個別に設定することもできます。）
   </para>

  <table id="ssl-file-usage">
<!--
   <title>SSL Server File Usage</title>
-->
   <title>SSLサーバファイルの使用方法</title>
   <tgroup cols="3">
    <thead>
     <row>
<!--
      <entry>File</entry>
      <entry>Contents</entry>
      <entry>Effect</entry>
-->
      <entry>ファイル</entry>
      <entry>内容</entry>
      <entry>影響</entry>
     </row>
    </thead>

    <tbody>

     <row>
      <entry><xref linkend="guc-ssl-cert-file"> (<filename>$PGDATA/server.crt</>)</entry>
<!--
      <entry>server certificate</entry>
      <entry>sent to client to indicate server's identity</entry>
-->
      <entry>サーバ証明書</entry>
      <entry>サーバの身元を示すためにクライアントに送信します</entry>
     </row>

     <row>
      <entry><xref linkend="guc-ssl-key-file"> (<filename>$PGDATA/server.key</>)</entry>
<!--
      <entry>server private key</entry>
      <entry>proves server certificate was sent by the owner; does not indicate
      certificate owner is trustworthy</entry>
-->
      <entry>サーバの秘密キー</entry>
      <entry>サーバ証明書が所有者によって送られたことを証明します。証明書所有者が信頼できることを意味しません。</entry>
     </row>

     <row>
      <entry><xref linkend="guc-ssl-ca-file"> (<filename>$PGDATA/root.crt</>)</entry>
<!--
      <entry>trusted certificate authorities</entry>
      <entry>checks that client certificate is
      signed by a trusted certificate authority</entry>
-->
      <entry>信頼できる認証局</entry>
      <entry>信頼する認証局により署名されたクライアント証明書か検査します。</entry>
     </row>

     <row>
      <entry><xref linkend="guc-ssl-crl-file"> (<filename>$PGDATA/root.crl</>)</entry>
<!--
      <entry>certificates revoked by certificate authorities</entry>
      <entry>client certificate must not be on this list</entry>
-->
      <entry>認証局により失効された証明書</entry>
      <entry>クライアント証明書はこの一覧にあってはいけません。</entry>
     </row>

    </tbody>
   </tgroup>
  </table>

   <para>
<!--
    The server reads these files at server start and whenever the server
    configuration is reloaded.  On <systemitem class="osname">Windows</>
    systems, they are also re-read whenever a new backend process is spawned
    for a new client connection.
-->
サーバは、サーバ起動時及びサーバ設定がリロードされるたびに、これらのファイルを読み取ります。
<systemitem class="osname">Windows</>システム上では新しいクライアント接続のために新しいバックエンドプロセスが生成されるたびに再読み込みされます。
   </para>

   <para>
<!--
    If an error in these files is detected at server start, the server will
    refuse to start.  But if an error is detected during a configuration
    reload, the files are ignored and the old SSL configuration continues to
    be used.  On <systemitem class="osname">Windows</> systems, if an error in
    these files is detected at backend start, that backend will be unable to
    establish an SSL connection.  In all these cases, the error condition is
    reported in the server log.
-->
サーバ起動時にこれらのファイルのエラーが検出された場合、サーバは起動を拒否します。
ただし、設定のリロード中にエラーが検出された場合、ファイルは無視され、古いSSL設定が引き続き使用されます。
<systemitem class="osname">Windows</>システム上ではバックエンドの開始時にこれらのファイルのエラーが検出された場合、そのバックエンドはSSL接続を確立出来ません。
これらのすべてのケースでは、エラー状態がサーバログに記録されます。
   </para>
  </sect2>

  <sect2 id="ssl-certificate-creation">
<<<<<<< HEAD
<!--
   <title>Creating a Self-signed Certificate</title>
-->
   <title>自己署名証明書の作成</title>

   <para>
<!--
     To create a quick self-signed certificate for the server, valid for 365
     days, use the following <productname>OpenSSL</productname> command,
     replacing <replaceable>yourdomain.com</> with the server's host name:
-->
365日有効なサーバ用の自己署名証明書を簡単に作るためには下記の<productname>OpenSSL</productname>コマンドを実行してください（<replaceable>yourdomain.com</>をサーバのホスト名に置き換えてください）。
=======
   <title>Creating Certificates</title>

   <para>
     To create a simple self-signed certificate for the server, valid for 365
     days, use the following <productname>OpenSSL</productname> command,
     replacing <replaceable>dbhost.yourdomain.com</> with the
     server's host name:
>>>>>>> REL_10_3
<programlisting>
openssl req -new -x509 -days 365 -nodes -text -out server.crt \
  -keyout server.key -subj "/CN=<replaceable>dbhost.yourdomain.com</>"
</programlisting>
<!--
    Then do:
-->
続けて以下も実行します。
<programlisting>
chmod og-rwx server.key
</programlisting>
<!--
    because the server will reject the file if its permissions are more
    liberal than this.
    For more details on how to create your server private key and
    certificate, refer to the <productname>OpenSSL</> documentation.
-->
サーバの秘密キーおよび証明書を作成するための詳しい方法については<productname>OpenSSL</>の文書を参照してください。
   </para>

   <para>
<<<<<<< HEAD
<!--
    A self-signed certificate can be used for testing, but a certificate
    signed by a certificate authority (<acronym>CA</>) (either one of the
    global <acronym>CAs</> or a local one) should be used in production
    so that clients can verify the server's identity. If all the clients
    are local to the organization, using a local <acronym>CA</> is
    recommended.
-->
自己署名証明書を試験のために使用することはできますが、クライアントがサーバの身元を検証できるように、運用時は（グローバルな<acronym>CA</>の1つまたはローカルな認証局のいずれかの）認証局（<acronym>CA</>）により署名された証明書を使用すべきです。
もしすべてのクライアントが組織においてローカルであれば、ローカル<acronym>CA</>の使用が推奨されます。
=======
    While a self-signed certificate can be used for testing, a certificate
    signed by a certificate authority (<acronym>CA</>) (usually an
    enterprise-wide root <acronym>CA</>) should be used in production.
>>>>>>> REL_10_3
   </para>

   <para>
    To create a server certificate whose identity can be validated
    by clients, first create a certificate signing request
    (<acronym>CSR</>) and a public/private key file:
<programlisting>
openssl req -new -nodes -text -out root.csr \
  -keyout root.key -subj "/CN=<replaceable>root.yourdomain.com</>"
chmod og-rwx root.key
</programlisting>
    Then, sign the request with the key to create a root certificate
    authority (using the default <productname>OpenSSL</>
    configuration file location on <productname>Linux</>):
<programlisting>
openssl x509 -req -in root.csr -text -days 3650 \
  -extfile /etc/ssl/openssl.cnf -extensions v3_ca \
  -signkey root.key -out root.crt
</programlisting>
    Finally, create a server certificate signed by the new root certificate
    authority:
<programlisting>
openssl req -new -nodes -text -out server.csr \
  -keyout server.key -subj "/CN=<replaceable>dbhost.yourdomain.com</>"
chmod og-rwx server.key

openssl x509 -req -in server.csr -text -days 365 \
  -CA root.crt -CAkey root.key -CAcreateserial \
  -out server.crt
</programlisting>
    <filename>server.crt</> and <filename>server.key</>
    should be stored on the server, and <filename>root.crt</> should
    be stored on the client so the client can verify that the server's leaf
    certificate was signed by its trusted root certificate. 
    <filename>root.key</> should be stored offline for use in
    creating future certificates.
   </para>

   <para>
    It is also possible to create a chain of trust that includes
    intermediate certificates:
<programlisting>
# root
openssl req -new -nodes -text -out root.csr \
  -keyout root.key -subj "/CN=<replaceable>root.yourdomain.com</>"
chmod og-rwx root.key
openssl x509 -req -in root.csr -text -days 3650 \
  -extfile /etc/ssl/openssl.cnf -extensions v3_ca \
  -signkey root.key -out root.crt

# intermediate
openssl req -new -nodes -text -out intermediate.csr \
  -keyout intermediate.key -subj "/CN=<replaceable>intermediate.yourdomain.com</>"
chmod og-rwx intermediate.key
openssl x509 -req -in intermediate.csr -text -days 1825 \
  -extfile /etc/ssl/openssl.cnf -extensions v3_ca \
  -CA root.crt -CAkey root.key -CAcreateserial \
  -out intermediate.crt

# leaf
openssl req -new -nodes -text -out server.csr \
  -keyout server.key -subj "/CN=<replaceable>dbhost.yourdomain.com</>"
chmod og-rwx server.key
openssl x509 -req -in server.csr -text -days 365 \
  -CA intermediate.crt -CAkey intermediate.key -CAcreateserial \
  -out server.crt
</programlisting>
    <filename>server.crt</> and
    <filename>intermediate.crt</> should be concatenated
    into a certificate file bundle and stored on the server.
    <filename>server.key</> should also be stored on the server.
    <filename>root.crt</> should be stored on the client so
    the client can verify that the server's leaf certificate was signed
    by a chain of certificates linked to its trusted root certificate.
    <filename>root.key</> and <filename>intermediate.key</>
    should be stored offline for use in creating future certificates.
   </para>
  </sect2>

 </sect1>

 <sect1 id="ssh-tunnels">
<!--
  <title>Secure TCP/IP Connections with <application>SSH</application> Tunnels</title>
-->
  <title><application>SSH</application>トンネルを使った安全なTCP/IP接続</title>

  <indexterm zone="ssh-tunnels">
   <primary>ssh</primary>
  </indexterm>

  <para>
<!--
   It is possible to use <application>SSH</application> to encrypt the network
   connection between clients and a
   <productname>PostgreSQL</productname> server. Done properly, this
   provides an adequately secure network connection, even for non-SSL-capable
   clients.
-->
クライアントと<productname>PostgreSQL</productname>サーバ間のネットワーク接続を暗号化するために<application>SSH</application>を使うことができます。
正しく行えば、SSL機能がクライアントになくても、これで十分に安全なネットワーク接続を行うことができます。
  </para>

  <para>
<!--
   First make sure that an <application>SSH</application> server is
   running properly on the same machine as the
   <productname>PostgreSQL</productname> server and that you can log in using
   <command>ssh</command> as some user. Then you can establish a secure
   tunnel with a command like this from the client machine:
-->
まず<application>SSH</application>サーバが<productname>PostgreSQL</productname>サーバと同じマシン上で正しく起動していて、<command>ssh</command>を使ってログインできるユーザが存在することを確かめてください。
そうすると、次に示すコマンドでクライアントマシンから安全なトンネルを確立することができます。
<programlisting>
ssh -L 63333:localhost:5432 joe@foo.com
</programlisting>
<!--
   The first number in the <option>-L</option> argument, 63333, is the
   port number of your end of the tunnel; it can be any unused port.
   (IANA reserves ports 49152 through 65535 for private use.)  The
   second number, 5432, is the remote end of the tunnel: the port
   number your server is using. The name or IP address between the
   port numbers is the host with the database server you are going to
   connect to, as seen from the host you are logging in to, which
   is <literal>foo.com</literal> in this example. In order to connect
   to the database server using this tunnel, you connect to port 63333
   on the local machine:
-->
<option>-L</option>引数の1番目の数字（63333）はトンネルのローカル側のポート番号で、未使用のポートを選択することが可能です。（IANAは49152から65535までのポートを私的使用のため予約しています。）
2番目の数字（5432）は、トンネルのリモート側のサーバが使用しているポート番号です。
2つのポート番号間の名前もしくはアドレスは、ログインしているホスト（この例では、<literal>foo.com</literal>）から見られる、あなたが接続しようとするデータベースサーバホストです。
このトンネルを使ってデータベースサーバに接続するためには、ローカルマシンのポート63333に接続します。
<programlisting>
psql -h localhost -p 63333 postgres
</programlisting>
<!--
   To the database server it will then look as though you are really
   user <literal>joe</literal> on host <literal>foo.com</literal>
   connecting to <literal>localhost</literal> in that context, and it
   will use whatever authentication procedure was configured for
   connections from this user and host.  Note that the server will not
   think the connection is SSL-encrypted, since in fact it is not
   encrypted between the
   <application>SSH</application> server and the
   <productname>PostgreSQL</productname> server.  This should not pose any
   extra security risk as long as they are on the same machine.
-->
データベースサーバにとっては、ユーザが実際にホスト<literal>foo.com</literal>上のユーザ<literal>joe</literal>であるかのように見え、このユーザとホストによる<literal>localhost</literal>接続向けに設定された認証手続きが使用されます。
サーバはこの接続がSSLで暗号化されているとみなさないことに注意してください。
実際、<application>SSH</application>サーバと<productname>PostgreSQL</productname>サーバとの間は暗号化されません。
この2つのサーバが同一マシンにある限り、セキュリティ上の危険性が増すことはありません。
  </para>

  <para>
<!--
   In order for the
   tunnel setup to succeed you must be allowed to connect via
   <command>ssh</command> as <literal>joe@foo.com</literal>, just
   as if you had attempted to use <command>ssh</command> to create a
   terminal session.
-->
トンネルの確立が成功するためには、<command>ssh</command>を使用して端末セッションを作成したのと同様に、<literal>joe@foo.com</literal>ユーザが<command>ssh</command>を通して接続することが許可されていなければいけません。
  </para>

  <para>
<!--
   You could also have set up the port forwarding as
-->
以下に示すようにポートフォワードを設定することができます。
<programlisting>
ssh -L 63333:foo.com:5432 joe@foo.com
</programlisting>
<!--
   but then the database server will see the connection as coming in
   on its <literal>foo.com</literal> interface, which is not opened by
   the default setting <literal>listen_addresses =
   'localhost'</literal>.  This is usually not what you want.
-->
しかしそうすると、データベースサーバはその<literal>foo.com</literal>インタフェースから接続が来たように判断し、デフォルトの設定である<literal>listen_addresses = 'localhost'</literal>では開かれません。
通常これは好ましいことではありません。
  </para>

  <para>
<!--
   If you have to <quote>hop</quote> to the database server via some
   login host, one possible setup could look like this:
-->
どこかのログインホスト経由でデータベースサーバに<quote>跳躍</quote>しなければならない場合、以下のようにすることが可能です。
<programlisting>
ssh -L 63333:db.foo.com:5432 joe@shell.foo.com
</programlisting>
<!--
   Note that this way the connection
   from <literal>shell.foo.com</literal>
   to <literal>db.foo.com</literal> will not be encrypted by the SSH
   tunnel.
   SSH offers quite a few configuration possibilities when the network
   is restricted in various ways.  Please refer to the SSH
   documentation for details.
-->
<literal>shell.foo.com</literal>から<literal>db.foo.com</literal>へのこのような接続はSSHトンネルで暗号化されません。
SSHはいろいろな方法でネットワークが制約されているとき、かなりの数の設定可能性を提供しています。
詳細はSSHの文書を参照してください。
  </para>

  <tip>
   <para>
<!--
    Several other applications exist that can provide secure tunnels using
    a procedure similar in concept to the one just described.
-->
ここで説明してきたものと似た概念の手続きを使用して、安全なトンネルを提供可能なアプリケーションが他にもいくつか存在します。
   </para>
  </tip>

 </sect1>

 <sect1 id="event-log-registration">
<!--
  <title>Registering <application>Event Log</> on <systemitem
  class="osname">Windows</></title>
-->
  <title><systemitem class="osname">Windows</>における<application>Event Log</>の登録</title>

  <indexterm zone="event-log-registration">
   <primary>event log</primary>
   <secondary>event log</secondary>
  </indexterm>

  <para>
<!--
   To register a <systemitem class="osname">Windows</>
   <application>event log</> library with the operating system,
   issue this command:
-->
   <systemitem class="osname">Windows</>の
   OSの<application>event log</>ライブラリに登録するには、以下のコマンドを発行します:
<screen>
<userinput>regsvr32 <replaceable>pgsql_library_directory</>/pgevent.dll</>
</screen>
<!--
   This creates registry entries used by the event viewer, under the default
   event source named <literal>PostgreSQL</literal>.
-->
   このコマンドは、<literal>PostgreSQL</literal>というデフォルトのイベントソース名で、イベントビューアが使用するレジストリエントリを作成します。
  </para>

  <para>
<!--
   To specify a different event source name (see
   <xref linkend="guc-event-source">), use the <literal>/n</literal>
   and <literal>/i</literal> options:
-->
   異なるイベントソース名（<xref linkend="guc-event-source">参照）を指定するには、<literal>/n</literal>および<literal>/i</literal>オプションを使ってください:
<screen>
<userinput>regsvr32 /n /i:<replaceable>event_source_name</> <replaceable>pgsql_library_directory</>/pgevent.dll</>
</screen>
  </para>

  <para>
<!--
   To unregister the <application>event log</> library from
   the operating system, issue this command:
-->
   OSから<application>event log</>ライブラリを削除するには、以下のコマンドを発行します:
<screen>
<userinput>regsvr32 /u [/i:<replaceable>event_source_name</>] <replaceable>pgsql_library_directory</>/pgevent.dll</>
</screen>
  </para>

  <note>
   <para>
<!--
    To enable event logging in the database server, modify
    <xref linkend="guc-log-destination"> to include
    <literal>eventlog</literal> in <filename>postgresql.conf</filename>.
-->
    データベースサーバにおけるイベントロギングを有効にするには、<literal>eventlog</literal>を含むように<filename>postgresql.conf</filename>の<xref linkend="guc-log-destination">を変更してください。
   </para>
  </note>
 </sect1>

</chapter>
