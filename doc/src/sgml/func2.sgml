<!-- 警告：このファイルは直接編集しないでください！
1. func.sgmlを編集したら、split.shを起動します。
2. するとfunc[0-4].sgmlが生成されます。
3. func.sgmlとともにfunc[0-4].sgmlのうち変更されたファイルをcommit/pushしてpull requestを作成してください。
4. レビューはfunc[0-4].sgmlに対して行います。
5. 指摘された点があればfunc.sgmlに反映し、1に戻ります。
6. func.sgmlの変更がなければ、pull requestをマージして終了です。お疲れ様でした！
-->
<!-- split-func2-start -->

  <sect1 id="functions-formatting">
<!--
   <title>Data Type Formatting Functions</title>
-->
   <title>データ型書式設定関数</title>

   <indexterm>
<!--
    <primary>formatting</primary>
-->
    <primary>書式設定</primary>
   </indexterm>

   <para>
<!--
    The <productname>PostgreSQL</productname> formatting functions
    provide a powerful set of tools for converting various data types
    (date/time, integer, floating point, numeric) to formatted strings
    and for converting from formatted strings to specific data types.
    <xref linkend="functions-formatting-table"/> lists them.
    These functions all follow a common calling convention: the first
    argument is the value to be formatted and the second argument is a
    template that defines the output or input format.
-->
<productname>PostgreSQL</productname>の書式設定関数は多彩なデータ型（日付/時刻データ型、整数データ型、浮動小数点数データ型、数値データ型）を整形された文字列に変換したり、整形された文字列を特定のデータ型に変換する強力なツールの一式を提供しています。
<xref linkend="functions-formatting-table"/>にこれらを列挙しています。
これら関数は共通の呼び出し規約を踏襲しています。最初の引数は整形される値で2番目の引数は入力書式または出力書式を定義するテンプレートです。
   </para>

    <table id="functions-formatting-table">
<!--
     <title>Formatting Functions</title>
-->
     <title>書式設定関数</title>
     <tgroup cols="4">
      <thead>
       <row>
<!--
        <entry>Function</entry>
        <entry>Return Type</entry>
        <entry>Description</entry>
        <entry>Example</entry>
-->
        <entry>関数</entry>
        <entry>戻り値</entry>
        <entry>説明</entry>
        <entry>例</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>
         <indexterm>
          <primary>to_char</primary>
         </indexterm>
         <literal><function>to_char(<type>timestamp</type>, <type>text</type>)</function></literal>
        </entry>
        <entry><type>text</type></entry>
<!--
        <entry>convert time stamp to string</entry>
-->
        <entry>タイムスタンプを文字列に変換</entry>
        <entry><literal>to_char(current_timestamp, 'HH12:MI:SS')</literal></entry>
       </row>
       <row>
        <entry><literal><function>to_char(<type>interval</type>, <type>text</type>)</function></literal></entry>
        <entry><type>text</type></entry>
<!--
        <entry>convert interval to string</entry>
-->
        <entry>時間間隔を文字列に変換</entry>
        <entry><literal>to_char(interval '15h&nbsp;2m&nbsp;12s', 'HH24:MI:SS')</literal></entry>
       </row>
       <row>
        <entry><literal><function>to_char(<type>int</type>, <type>text</type>)</function></literal></entry>
        <entry><type>text</type></entry>
<!--
        <entry>convert integer to string</entry>
-->
        <entry>整数を文字列に変換</entry>
        <entry><literal>to_char(125, '999')</literal></entry>
       </row>
       <row>
        <entry><literal><function>to_char</function>(<type>double precision</type>,
        <type>text</type>)</literal></entry>
        <entry><type>text</type></entry>
<!--
        <entry>convert real/double precision to string</entry>
-->
        <entry>実数、倍精度数を文字列に変換</entry>
        <entry><literal>to_char(125.8::real, '999D9')</literal></entry>
       </row>
       <row>
        <entry><literal><function>to_char(<type>numeric</type>, <type>text</type>)</function></literal></entry>
        <entry><type>text</type></entry>
<!--
        <entry>convert numeric to string</entry>
-->
        <entry>数値を文字列に変換</entry>
        <entry><literal>to_char(-125.8, '999D99S')</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>to_date</primary>
         </indexterm>
         <literal><function>to_date(<type>text</type>, <type>text</type>)</function></literal>
        </entry>
        <entry><type>date</type></entry>
<!--
        <entry>convert string to date</entry>
-->
        <entry>文字列を日付に変換</entry>
        <entry><literal>to_date('05&nbsp;Dec&nbsp;2000', 'DD&nbsp;Mon&nbsp;YYYY')</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>to_number</primary>
         </indexterm>
         <literal><function>to_number(<type>text</type>, <type>text</type>)</function></literal>
        </entry>
        <entry><type>numeric</type></entry>
<!--
        <entry>convert string to numeric</entry>
-->
        <entry>文字列を数値に変換</entry>
        <entry><literal>to_number('12,454.8-', '99G999D9S')</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>to_timestamp</primary>
         </indexterm>
         <literal><function>to_timestamp(<type>text</type>, <type>text</type>)</function></literal>
        </entry>
        <entry><type>timestamp with time zone</type></entry>
<!--
        <entry>convert string to time stamp</entry>
-->
        <entry>文字列をタイムスタンプに変換</entry>
        <entry><literal>to_timestamp('05&nbsp;Dec&nbsp;2000', 'DD&nbsp;Mon&nbsp;YYYY')</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <note>
    <para>
<!--
     There is also a single-argument <function>to_timestamp</function>
     function; see <xref linkend="functions-datetime-table"/>.
-->
引数が１つの<function>to_timestamp</function>関数もあります。
<xref linkend="functions-datetime-table"/>を参照して下さい。
    </para>
   </note>

   <tip>
    <para>
<!--
     <function>to_timestamp</function> and <function>to_date</function>
     exist to handle input formats that cannot be converted by
     simple casting.  For most standard date/time formats, simply casting the
     source string to the required data type works, and is much easier.
     Similarly, <function>to_number</function> is unnecessary for standard numeric
     representations.
-->
<function>to_timestamp</function>と<function>to_date</function>は、単純なキャストでは変換できない入力フォーマットを処理するために存在します。
ほとんどの標準的日付および時刻のフォーマットに対しては、入力文字列を必要なデータ型に単純にキャストすれば動作し、その方がずっと簡単です。
同様に、<function>to_number</function>も標準的な数値表現に対しては不要です。
    </para>
   </tip>

   <para>
<!--
    In a <function>to_char</function> output template string, there are certain
    patterns that are recognized and replaced with appropriately-formatted
    data based on the given value.  Any text that is not a template pattern is
    simply copied verbatim.  Similarly, in an input template string (for the
    other functions), template patterns identify the values to be supplied by
    the input data string.  If there are characters in the template string
    that are not template patterns, the corresponding characters in the input
    data string are simply skipped over (whether or not they are equal to the
    template string characters).
-->
<function>to_char</function>用の出力テンプレート文字列には、値に基づいて認識され、適切に整形されたデータで置き換えられるパターンがあります。
テンプレートパターンではない全てのテキストは単にそのままコピーされます。
同様に、（その他の関数用の）入力テンプレート文字列では、テンプレートパターンは入力されたデータ文字列で供給される値を特定します。
テンプレート文字列中にテンプレートパターンではない文字があれば、（テンプレート文字列の文字と同じかどうかにかかわらず）入力文字列データ中の該当文字は単にスキップされます。
   </para>

  <para>
<!--
   <xref linkend="functions-formatting-datetime-table"/> shows the
   template patterns available for formatting date and time values.
-->
<xref linkend="functions-formatting-datetime-table"/>に、日付/時刻型の値の書式に使用可能なテンプレートパターンを示します。
  </para>

    <table id="functions-formatting-datetime-table">
<!--
     <title>Template Patterns for Date/Time Formatting</title>
-->
     <title>日付/時刻型の書式テンプレートパターン</title>
     <tgroup cols="2">
      <thead>
       <row>
<!--
        <entry>Pattern</entry>
        <entry>Description</entry>
-->
        <entry>パターン</entry>
        <entry>説明</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><literal>HH</literal></entry>
<!--
        <entry>hour of day (01-12)</entry>
-->
        <entry>時（01〜12）</entry>
       </row>
       <row>
        <entry><literal>HH12</literal></entry>
<!--
        <entry>hour of day (01-12)</entry>
-->
        <entry>時（01〜12）</entry>
       </row>
       <row>
        <entry><literal>HH24</literal></entry>
<!--
        <entry>hour of day (00-23)</entry>
-->
        <entry>時（00〜23）</entry>
       </row>
       <row>
        <entry><literal>MI</literal></entry>
<!--
        <entry>minute (00-59)</entry>
-->
        <entry>分（00〜59）</entry>
       </row>
       <row>
        <entry><literal>SS</literal></entry>
<!--
        <entry>second (00-59)</entry>
-->
        <entry>秒（00〜59）</entry>
       </row>
       <row>
        <entry><literal>MS</literal></entry>
<!--
        <entry>millisecond (000-999)</entry>
-->
        <entry>ミリ秒（000〜999）</entry>
       </row>
       <row>
        <entry><literal>US</literal></entry>
<!--
        <entry>microsecond (000000-999999)</entry>
-->
        <entry>マイクロ秒（000000〜999999）</entry>
       </row>
       <row>
        <entry><literal>SSSS</literal></entry>
<!--
        <entry>seconds past midnight (0-86399)</entry>
-->
        <entry>深夜0時からの秒数（0〜86399）</entry>
       </row>
       <row>
<!--
        <entry><literal>AM</literal>, <literal>am</literal>,
        <literal>PM</literal> or <literal>pm</literal></entry>
-->
        <entry><literal>AM</literal>、<literal>am</literal>、
        <literal>PM</literal>、または<literal>pm</literal></entry>
<!--
        <entry>meridiem indicator (without periods)</entry>
-->
        <entry>午前/午後の指定（ピリオドなし）</entry>
       </row>
       <row>
<!--
        <entry><literal>A.M.</literal>, <literal>a.m.</literal>,
        <literal>P.M.</literal> or <literal>p.m.</literal></entry>
-->
        <entry><literal>A.M.</literal>、<literal>a.m.</literal>、
        <literal>P.M.</literal>、または<literal>p.m.</literal></entry>
<!--
        <entry>meridiem indicator (with periods)</entry>
-->
        <entry>午前/午後の指定（ピリオド付き）</entry>
       </row>
       <row>
        <entry><literal>Y,YYY</literal></entry>
<!--
        <entry>year (4 or more digits) with comma</entry>
-->
        <entry>コンマ付き年（4桁以上）</entry>
       </row>
       <row>
        <entry><literal>YYYY</literal></entry>
<!--
        <entry>year (4 or more digits)</entry>
-->
        <entry>年（4桁以上）</entry>
       </row>
       <row>
        <entry><literal>YYY</literal></entry>
<!--
        <entry>last 3 digits of year</entry>
-->
        <entry>年の下3桁</entry>
       </row>
       <row>
        <entry><literal>YY</literal></entry>
<!--
        <entry>last 2 digits of year</entry>
-->
        <entry>年の下2桁</entry>
       </row>
       <row>
        <entry><literal>Y</literal></entry>
<!--
        <entry>last digit of year</entry>
-->
        <entry>年の下1桁</entry>
       </row>
       <row>
        <entry><literal>IYYY</literal></entry>
<!--
        <entry>ISO 8601 week-numbering year (4 or more digits)</entry>
-->
        <entry>ISO 8601週番号年（4桁以上）</entry>
       </row>
       <row>
        <entry><literal>IYY</literal></entry>
<!--
        <entry>last 3 digits of ISO 8601 week-numbering year</entry>
-->
        <entry>ISO 8601週番号年の下3桁</entry>
       </row>
       <row>
        <entry><literal>IY</literal></entry>
<!--
        <entry>last 2 digits of ISO 8601 week-numbering year</entry>
-->
        <entry>ISO 8601週番号年の下2桁</entry>
       </row>
       <row>
        <entry><literal>I</literal></entry>
<!--
        <entry>last digit of ISO 8601 week-numbering year</entry>
-->
        <entry>ISO 8601週番号年の下1桁</entry>
       </row>
       <row>
<!--
        <entry><literal>BC</literal>, <literal>bc</literal>,
        <literal>AD</literal> or <literal>ad</literal></entry>
-->
        <entry><literal>BC</literal>、<literal>bc</literal>、
        <literal>AD</literal>、または<literal>ad</literal></entry>
<!--
        <entry>era indicator (without periods)</entry>
-->
        <entry>紀元前後の指定（ピリオドなし）</entry>
       </row>
       <row>
<!--
        <entry><literal>B.C.</literal>, <literal>b.c.</literal>,
        <literal>A.D.</literal> or <literal>a.d.</literal></entry>
-->
        <entry><literal>B.C.</literal>、<literal>b.c.</literal>、
        <literal>A.D.</literal>、または<literal>a.d.</literal></entry>
<!--
        <entry>era indicator (with periods)</entry>
-->
        <entry>紀元前後の指定（ピリオド付き）</entry>
       </row>
       <row>
        <entry><literal>MONTH</literal></entry>
<!--
        <entry>full upper case month name (blank-padded to 9 chars)</entry>
-->
        <entry>大文字での完全な月名（9文字になるように空白文字を埋める）</entry>
       </row>
       <row>
        <entry><literal>Month</literal></entry>
<!--
        <entry>full capitalized month name (blank-padded to 9 chars)</entry>
-->
        <entry>大文字で書き始める完全な月名（9文字になるように空白文字を埋める）</entry>
       </row>
       <row>
        <entry><literal>month</literal></entry>
<!--
        <entry>full lower case month name (blank-padded to 9 chars)</entry>
-->
        <entry>小文字での完全な月名（9文字になるように空白文字を埋める）</entry>
       </row>
       <row>
        <entry><literal>MON</literal></entry>
<!--
        <entry>abbreviated upper case month name (3 chars in English, localized lengths vary)</entry>
-->
        <entry>大文字での短縮形の月名（英語では3文字、現地語化された場合は可変長）</entry>
       </row>
       <row>
        <entry><literal>Mon</literal></entry>
<!--
        <entry>abbreviated capitalized month name (3 chars in English, localized lengths vary)</entry>
-->
        <entry>大文字で書き始める短縮形の月名（英語では3文字。現地語化された場合は可変長）</entry>
       </row>
       <row>
        <entry><literal>mon</literal></entry>
<!--
        <entry>abbreviated lower case month name (3 chars in English, localized lengths vary)</entry>
-->
        <entry>小文字での短縮形の月名（英語では3文字。現地語化された場合は可変長）</entry>
       </row>
       <row>
        <entry><literal>MM</literal></entry>
<!--
        <entry>month number (01-12)</entry>
-->
        <entry>月番号（01〜12）</entry>
       </row>
       <row>
        <entry><literal>DAY</literal></entry>
<!--
        <entry>full upper case day name (blank-padded to 9 chars)</entry>
-->
        <entry>大文字での完全な曜日名（9文字になるように空白文字を埋める）</entry>
       </row>
       <row>
        <entry><literal>Day</literal></entry>
<!--
        <entry>full capitalized day name (blank-padded to 9 chars)</entry>
-->
        <entry>大文字で書き始める完全な曜日名（9文字になるように空白文字を埋める）</entry>
       </row>
       <row>
        <entry><literal>day</literal></entry>
<!--
        <entry>full lower case day name (blank-padded to 9 chars)</entry>
-->
        <entry>小文字での完全な曜日名（9文字になるように空白文字を埋める）</entry>
       </row>
       <row>
        <entry><literal>DY</literal></entry>
<!--
        <entry>abbreviated upper case day name (3 chars in English, localized lengths vary)</entry>
-->
        <entry>短縮形の大文字での短縮形の曜日名（英語では3文字。現地語化された場合は可変長）</entry>
       </row>
       <row>
        <entry><literal>Dy</literal></entry>
<!--
        <entry>abbreviated capitalized day name (3 chars in English, localized lengths vary)</entry>
-->
        <entry>大文字で書き始める短縮形の曜日名（英語では3文字。現地語化された場合は可変長）</entry>
       </row>
       <row>
        <entry><literal>dy</literal></entry>
<!--
        <entry>abbreviated lower case day name (3 chars in English, localized lengths vary)</entry>
-->
        <entry>小文字での短縮形の曜日名（英語では3文字。現地語化された場合は可変長）</entry>
       </row>
       <row>
        <entry><literal>DDD</literal></entry>
<!--
        <entry>day of year (001-366)</entry>
-->
        <entry>通年の日にち番号（001〜366）</entry>
       </row>
       <row>
        <entry><literal>IDDD</literal></entry>
<!--
        <entry>day of ISO 8601 week-numbering year (001-371; day 1 of the year is Monday of the first ISO week)</entry>
-->
        <entry>ISO 8601週番号年の日にち番号（001-371：通年 第１日は最初のISO週の月曜日）</entry>
       </row>
       <row>
        <entry><literal>DD</literal></entry>
<!--
        <entry>day of month (01-31)</entry>
-->
        <entry>月内の日にち番号（01〜31）</entry>
       </row>
       <row>
        <entry><literal>D</literal></entry>
<!--
        <entry>day of the week, Sunday (<literal>1</literal>) to Saturday (<literal>7</literal>)</entry>
-->
        <entry>曜日番号、日曜日（<literal>1</literal>）から土曜日（<literal>7</literal>）まで</entry>
       </row>
       <row>
        <entry><literal>ID</literal></entry>
       </row>
       <row>
<!--
        <entry>ISO 8601 day of the week, Monday (<literal>1</literal>) to Sunday (<literal>7</literal>)</entry>
-->
        <entry>ISO 8601の曜日番号、月曜日（<literal>1</literal>）から日曜日（<literal>7</literal>）まで</entry>
       </row>
       <row>
        <entry><literal>W</literal></entry>
<!--
        <entry>week of month (1-5) (the first week starts on the first day of the month)</entry>
-->
        <entry>月中の週番号（1〜5）（その月の初日がある週が第1週）</entry>
       </row>
       <row>
        <entry><literal>WW</literal></entry>
<!--
        <entry>week number of year (1-53) (the first week starts on the first day of the year)</entry>
-->
        <entry>年間を通じた週番号（1〜53）（元日のある週が第1週）</entry>
       </row>
       <row>
        <entry><literal>IW</literal></entry>
<!--
        <entry>week number of ISO 8601 week-numbering year (01-53; the first Thursday of the year is in week 1)</entry>
-->
        <entry>ISO 8601週番号年の年間を通じた週番号（01 - 53：新年の最初の木曜日がある週が第1週）</entry>
       </row>
       <row>
        <entry><literal>CC</literal></entry>
<!--
        <entry>century (2 digits) (the twenty-first century starts on 2001-01-01)</entry>
-->
        <entry>世紀（2桁。21世紀は2001-01-01から開始）</entry>
       </row>
       <row>
        <entry><literal>J</literal></entry>
<!--
        <entry>Julian Day (integer days since November 24, 4714 BC at midnight UTC)</entry>
-->
        <entry>ユリウス日（UTC紀元前4714年11月24日午前零時からの整数による通算経過日）</entry>
       </row>
       <row>
        <entry><literal>Q</literal></entry>
<!--
        <entry>quarter</entry>
-->
        <entry>四半期</entry>
       </row>
       <row>
        <entry><literal>RM</literal></entry>
<!--
        <entry>month in upper case Roman numerals (I-XII; I=January)</entry>
-->
        <entry>大文字ローマ数字による月（I〜XII、Iは1月）</entry>
       </row>
       <row>
        <entry><literal>rm</literal></entry>
<!--
        <entry>month in lower case Roman numerals (i-xii; i=January)</entry>
-->
        <entry>小文字ローマ数字による月（i〜xii、iは1月）</entry>
       </row>
       <row>
        <entry><literal>TZ</literal></entry>
<!--
        <entry>upper case time-zone abbreviation
         (only supported in <function>to_char</function>)</entry>
-->
        <entry>大文字による時間帯省略名（<function>to_char</function>内でのみサポートされる）</entry>
       </row>
       <row>
        <entry><literal>tz</literal></entry>
<!--
        <entry>lower case time-zone abbreviation
         (only supported in <function>to_char</function>)</entry>
-->
        <entry>小文字による時間帯省略名（<function>to_char</function>内でのみサポートされる）</entry>
       </row>
       <row>
       <entry><literal>TZH</literal></entry>
<!--
        <entry>time-zone hours</entry>
-->
        <entry>time-zoneの時間</entry>
       </row>
       <row>
       <entry><literal>TZM</literal></entry>
<!--
        <entry>time-zone minutes</entry>
-->
        <entry>time-zoneの分</entry>
       </row>
       <row>
        <entry><literal>OF</literal></entry>
<!--
        <entry>time-zone offset from UTC
         (only supported in <function>to_char</function>)</entry>
-->
        <entry>UTCからの時間帯オフセット（<function>to_char</function>内でのみサポートされる）</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
<!--
    Modifiers can be applied to any template pattern to alter its
    behavior.  For example, <literal>FMMonth</literal>
    is the <literal>Month</literal> pattern with the
    <literal>FM</literal> modifier.
    <xref linkend="functions-formatting-datetimemod-table"/> shows the
    modifier patterns for date/time formatting.
-->
どのようなテンプレートパターンに対しても、その振舞いを変更するために修飾子を適用できます。
例えば、<literal>FMMonth</literal>は<literal>FM</literal>修飾子の付いた<literal>Month</literal>パターンです。
<xref linkend="functions-formatting-datetimemod-table"/>に、日付/時刻書式の修飾子パターンを示します。
   </para>

    <table id="functions-formatting-datetimemod-table">
<!--
     <title>Template Pattern Modifiers for Date/Time Formatting</title>
-->
     <title>日付/時刻書式用のテンプレートパターン修飾子</title>
     <tgroup cols="3">
      <thead>
       <row>
<!--
        <entry>Modifier</entry>
        <entry>Description</entry>
        <entry>Example</entry>
-->
        <entry>修飾子</entry>
        <entry>説明</entry>
        <entry>例</entry>
       </row>
      </thead>
      <tbody>
       <row>
<!--
        <entry><literal>FM</literal> prefix</entry>
-->
        <entry><literal>FM</literal>接頭辞</entry>
<!--
        <entry>fill mode (suppress leading zeroes and padding blanks)</entry>
-->
        <entry>字詰めモード（先頭の0、およびを空白のパディングを無効）</entry>
        <entry><literal>FMMonth</literal></entry>
       </row>
       <row>
<!--
        <entry><literal>TH</literal> suffix</entry>
-->
        <entry><literal>TH</literal>接尾辞</entry>
<!--
        <entry>upper case ordinal number suffix</entry>
        <entry><literal>DDTH</literal>, e.g., <literal>12TH</literal></entry>
-->
        <entry><literal>DDTH</literal>、例えば<literal>12TH</literal></entry>
       </row>
       <row>
<!--
        <entry><literal>th</literal> suffix</entry>
-->
        <entry><literal>th</literal>接尾辞</entry>
<!--
        <entry>lower case ordinal number suffix</entry>
        <entry><literal>DDth</literal>, e.g., <literal>12th</literal></entry>
-->
        <entry><literal>DDth</literal>、例えば<literal>12th</literal></entry>
       </row>
       <row>
<!--
        <entry><literal>FX</literal> prefix</entry>
-->
        <entry><literal>FX</literal>接頭辞</entry>
<!--
        <entry>fixed format global option (see usage notes)</entry>
-->
        <entry>固定書式のグローバルオプション（使用上の注意事項を参照）</entry>
        <entry><literal>FX&nbsp;Month&nbsp;DD&nbsp;Day</literal></entry>
       </row>
       <row>
<!--
        <entry><literal>TM</literal> prefix</entry>
-->
        <entry><literal>TM</literal>接頭辞</entry>
<!--
        <entry>translation mode (print localized day and month names based on
         <xref linkend="guc-lc-time"/>)</entry>
-->
        <entry>翻訳モード（<xref linkend="guc-lc-time"/>に基づき、現地語化された曜日、月名を表示します)</entry>
        <entry><literal>TMMonth</literal></entry>
       </row>
       <row>
<!--
        <entry><literal>SP</literal> suffix</entry>
-->
        <entry><literal>SP</literal>接尾辞</entry>
<!--
        <entry>spell mode (not implemented)</entry>
-->
        <entry>スペルモード（未実装）</entry>
        <entry><literal>DDSP</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
<!--
    Usage notes for date/time formatting:
-->
日付/時刻型書式の使用上の注意事項は次のとおりです。

    <itemizedlist>
     <listitem>
      <para>
<!--
       <literal>FM</literal> suppresses leading zeroes and trailing blanks
       that would otherwise be added to make the output of a pattern be
       fixed-width.  In <productname>PostgreSQL</productname>,
       <literal>FM</literal> modifies only the next specification, while in
       Oracle <literal>FM</literal> affects all subsequent
       specifications, and repeated <literal>FM</literal> modifiers
       toggle fill mode on and off.
-->
<literal>FM</literal>は、先頭にはゼロ、末尾には空白を追加してパターンを固定長にする機能を無効にします。
<productname>PostgreSQL</productname>では、<literal>FM</literal>はその次に記述されたものだけを変更します。一方Oracleでは、<literal>FM</literal>はそれに続く全ての記述に対して影響し、<literal>FM</literal>修飾詞を繰り返すと、ゼロや空白を埋めるモードのオンとオフが切り替わります。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       <literal>TM</literal> does not include trailing blanks.
       <function>to_timestamp</function> and <function>to_date</function> ignore
       the <literal>TM</literal> modifier.
-->
<literal>TM</literal>には末尾の空白は含まれません。
<function>to_timestamp</function>と<function>to_date</function>は<literal>TM</literal>修飾詞を無視します。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       <function>to_timestamp</function> and <function>to_date</function>
       skip multiple blank spaces at the beginning of the input string and
       around date and time values unless the <literal>FX</literal> option is used.  For example,
       <literal>to_timestamp('&nbsp;2000&nbsp;&nbsp;&nbsp;&nbsp;JUN', 'YYYY MON')</literal> and
       <literal>to_timestamp('2000 - JUN', 'YYYY-MON')</literal> work, but
       <literal>to_timestamp('2000&nbsp;&nbsp;&nbsp;&nbsp;JUN', 'FXYYYY MON')</literal> returns an error
       because <function>to_timestamp</function> expects only a single space.
       <literal>FX</literal> must be specified as the first item in
       the template.
-->
<literal>FX</literal>オプションが使用されていない場合、<function>to_timestamp</function>と<function>to_date</function>は入力文字列内の複数の空白スペースを無視します。
例えば、<literal>to_timestamp('2000&nbsp;&nbsp;&nbsp;&nbsp;JUN', 'YYYY MON')</literal>は動作しますが、<literal>to_timestamp('2000&nbsp;&nbsp;&nbsp;&nbsp;JUN','FXYYYY MON')</literal>はエラーを返します。
後者の<function>to_timestamp</function>はスペースが1つだけあることを期待するからです。
<literal>FX</literal>はテンプレートの第1項目として指定される必要があります。
      </para>
     </listitem>

     <listitem>
      <para>
       A separator (a space or non-letter/non-digit character) in the template string of
       <function>to_timestamp</function> and <function>to_date</function>
       matches any single separator in the input string or is skipped,
       unless the <literal>FX</literal> option is used.
       For example, <literal>to_timestamp('2000JUN', 'YYYY///MON')</literal> and
       <literal>to_timestamp('2000/JUN', 'YYYY MON')</literal> work, but
       <literal>to_timestamp('2000//JUN', 'YYYY/MON')</literal>
       returns an error because the number of separators in the input string
       exceeds the number of separators in the template.
      </para>
      <para>
       If <literal>FX</literal> is specified, a separator in the template string
       matches exactly one character in the input string.  But note that the
       input string character is not required to be the same as the separator from the template string.
       For example, <literal>to_timestamp('2000/JUN', 'FXYYYY MON')</literal>
       works, but <literal>to_timestamp('2000/JUN', 'FXYYYY&nbsp;&nbsp;MON')</literal>
       returns an error because the second space in the template string consumes
       the letter <literal>J</literal> from the input string.
      </para>
     </listitem>

     <listitem>
      <para>
       A <literal>TZH</literal> template pattern can match a signed number.
       Without the <literal>FX</literal> option, minus signs may be ambiguous,
       and could be interpreted as a separator.
       This ambiguity is resolved as follows:  If the number of separators before
       <literal>TZH</literal> in the template string is less than the number of
       separators before the minus sign in the input string, the minus sign
       is interpreted as part of <literal>TZH</literal>.
       Otherwise, the minus sign is considered to be a separator between values.
       For example, <literal>to_timestamp('2000 -10', 'YYYY TZH')</literal> matches
       <literal>-10</literal> to <literal>TZH</literal>, but
       <literal>to_timestamp('2000 -10', 'YYYY&nbsp;&nbsp;TZH')</literal>
       matches <literal>10</literal> to <literal>TZH</literal>.
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       Ordinary text is allowed in <function>to_char</function>
       templates and will be output literally.  You can put a substring
       in double quotes to force it to be interpreted as literal text
       even if it contains template patterns.  For example, in
       <literal>'"Hello Year "YYYY'</literal>, the <literal>YYYY</literal>
       will be replaced by the year data, but the single <literal>Y</literal> in <literal>Year</literal>
       will not be.
       In <function>to_date</function>, <function>to_number</function>,
       and <function>to_timestamp</function>, literal text and double-quoted
       strings result in skipping the number of characters contained in the
       string; for example <literal>"XX"</literal> skips two input characters
       (whether or not they are <literal>XX</literal>).
-->
<function>to_char</function>テンプレートには、通常のテキストを入れることができ、それはそのまま出力されます。
部分文字列を二重引用符で括ることで、部分文字列にテンプレートパターンがあったとしても、強制的にリテラルテキストとして解釈させることができます。
例えば、<literal>'"Hello Year "YYYY'</literal>では<literal>YYYY</literal>は年データに置換されてしまいますが、<literal>Year</literal>内の<literal>Y</literal>は置換されません。
<function>to_date</function>、<function>to_number</function>、<function>to_timestamp</function>では、二重引用符で括られた文字の数だけ入力された文字をスキップします。例えば<literal>"XX"</literal>は2文字の入力文字（それが<literal>XX</literal>であるかどうかにかかわらず)をスキップします。
      </para>
      <tip>
        <para>
          Prior to <productname>PostgreSQL</productname> 12, it was possible to
          skip arbitrary text in the input string using non-letter or non-digit
          characters. For example,
          <literal>to_timestamp('2000y6m1d', 'yyyy-MM-DD')</literal> used to
          work.  Now you can only use letter characters for this purpose.  For example,
          <literal>to_timestamp('2000y6m1d', 'yyyytMMtDDt')</literal> and
          <literal>to_timestamp('2000y6m1d', 'yyyy"y"MM"m"DD"d"')</literal>
          skip <literal>y</literal>, <literal>m</literal>, and
          <literal>d</literal>.
        </para>
      </tip>
     </listitem>

     <listitem>
      <para>
<!--
       If you want to have a double quote in the output you must
       precede it with a backslash, for example <literal>'\"YYYY
       Month\"'</literal>. <!&#045;&#045; 原文コメント "" font-lock sanity :-) &#045;&#045;>
       Backslashes are not otherwise special outside of double-quoted
       strings.  Within a double-quoted string, a backslash causes the
       next character to be taken literally, whatever it is (but this
       has no special effect unless the next character is a double quote
       or another backslash).
-->
出力に二重引用符を付けたい場合、<literal>'\"YYYY Month\"'</literal>のようにその前にバックスラッシュを付けなければなりません。
バックスラッシュは、二重引用符の外側では特別扱いされません。
二重引用符の内側では、バックスラッシュによって次の文字が何であれ文字通りに扱われるようになります。
（しかし、次の文字が二重引用符であるか、あるいは別のバックスラッシュでない限り、これは特別な効果をもたらしません。）
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       In <function>to_timestamp</function> and <function>to_date</function>,
       if the year format specification is less than four digits, e.g.
       <literal>YYY</literal>, and the supplied year is less than four digits,
       the year will be adjusted to be nearest to the year 2020, e.g.
       <literal>95</literal> becomes 1995.
-->
<function>to_timestamp</function>において<function>to_date</function>、<literal>YYY</literal>の様に4桁未満の年書式が指定され、かつ与えられる年が4桁未満だった場合、年は2020年に最も近くなるよう調整されます。例えば、<literal>95</literal>の場合は1995年になります。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       In <function>to_timestamp</function> and <function>to_date</function>,
       the <literal>YYYY</literal> conversion has a restriction when
       processing years with more than 4 digits. You must
       use some non-digit character or template after <literal>YYYY</literal>,
       otherwise the year is always interpreted as 4 digits. For example
       (with the year 20000):
       <literal>to_date('200001131', 'YYYYMMDD')</literal> will be
       interpreted as a 4-digit year; instead use a non-digit
       separator after the year, like
       <literal>to_date('20000-1131', 'YYYY-MMDD')</literal> or
       <literal>to_date('20000Nov31', 'YYYYMonDD')</literal>.
-->
<function>to_timestamp</function>および<function>to_date</function>において<literal>YYYY</literal>変換は、5桁以上の年数値を処理するときに制限事項があります。
このような場合、<literal>YYYY</literal>の後に数字以外の文字またはテンプレートを使わなければなりません。 そうしないと年は常に4桁と解釈されます。
例えば（20000年として）、<literal>to_date('200001131', 'YYYYMMDD')</literal>は4桁の年と解釈されるので、代わりに<literal>to_date('20000-1131', 'YYYY-MMDD')</literal>または<literal>to_date('20000Nov31', 'YYYYMonDD')</literal>のように数字でない区切り文字を使用してください。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       In <function>to_timestamp</function> and <function>to_date</function>,
       the <literal>CC</literal> (century) field is accepted but ignored
       if there is a <literal>YYY</literal>, <literal>YYYY</literal> or
       <literal>Y,YYY</literal> field. If <literal>CC</literal> is used with
       <literal>YY</literal> or <literal>Y</literal> then the result is
       computed as that year in the specified century.  If the century is
       specified but the year is not, the first year of the century
       is assumed.
-->
<function>to_timestamp</function>および<function>to_date</function>において<literal>YYY</literal>、<literal>YYYY</literal>、もしくは<literal>Y,YYY</literal>フィールドが存在すると<literal>CC</literal>（世紀）フィールドは受け入れられますが、無視されます。
<literal>CC</literal>が<literal>YY</literal>もしくは<literal>Y</literal>と共に使用されると、結果は指定された世紀のその年として計算されます。
世紀が指定され、年が指定されないときは、その世紀の最初の年と想定されます。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       In <function>to_timestamp</function> and <function>to_date</function>,
       weekday names or numbers (<literal>DAY</literal>, <literal>D</literal>,
       and related field types) are accepted but are ignored for purposes of
       computing the result.  The same is true for quarter
       (<literal>Q</literal>) fields.
-->
<function>to_timestamp</function>および<function>to_date</function>において、曜日の名前や数字（<literal>DAY</literal>、<literal>D</literal>および関連したフィールドの型）は受け付けられますが、結果を計算するという目的においては無視されます。
同じことは四半期（<literal>Q</literal>）フィールドにも当てはまります。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       In <function>to_timestamp</function> and <function>to_date</function>,
       an ISO 8601 week-numbering date (as distinct from a Gregorian date)
       can be specified in one of two ways:
-->
<function>to_timestamp</function>および<function>to_date</function>において、
ISO 8601週番号日は（グレゴリオ暦の日付とは異なって）以下の２つの方法のうちのひとつで指定できます。
       <itemizedlist>
        <listitem>
         <para>
<!--
          Year, week number, and weekday:  for
          example <literal>to_date('2006-42-4', 'IYYY-IW-ID')</literal>
          returns the date <literal>2006-10-19</literal>.
          If you omit the weekday it is assumed to be 1 (Monday).
-->
年、通年の週番号、曜日番号。
例えば、<literal>to_date('2006-42-4', 'IYYY-IW-ID')</literal>は、日付<literal>2006-10-19</literal>を返します。
曜日番号を省略した場合、1（月曜日）と想定されます。
         </para>
        </listitem>
        <listitem>
         <para>
<!--
          Year and day of year:  for example <literal>to_date('2006-291',
          'IYYY-IDDD')</literal> also returns <literal>2006-10-19</literal>.
-->
年と通年の日付番号。例えば、<literal>to_date('2006-291', 'IYYY-IDDD')</literal>も<literal>2006-10-19</literal>を返します。
         </para>
        </listitem>
       </itemizedlist>
      </para>
      <para>
<!--
       Attempting to enter a date using a mixture of ISO 8601 week-numbering
       fields and Gregorian date fields is nonsensical, and will cause an
       error.  In the context of an ISO 8601 week-numbering year, the
       concept of a <quote>month</quote> or <quote>day of month</quote> has no
       meaning.  In the context of a Gregorian year, the ISO week has no
       meaning.
-->
ISO 8601週番号とグレゴリオ暦日のフィールドを混在して使用して日付を構築する試みは無意味なことで、エラーの原因になります。
ISO 8601週番号年の文脈では、<quote>月</quote>、あるいは<quote>月内の日付番号</quote>は意味を持ちません。
グレゴリオ暦の年の文脈では、ISO週番号は意味を持ちません。
      </para>
      <caution>
       <para>
<!--
        While <function>to_date</function> will reject a mixture of
        Gregorian and ISO week-numbering date
        fields, <function>to_char</function> will not, since output format
        specifications like <literal>YYYY-MM-DD (IYYY-IDDD)</literal> can be
        useful.  But avoid writing something like <literal>IYYY-MM-DD</literal>;
        that would yield surprising results near the start of the year.
        (See <xref linkend="functions-datetime-extract"/> for more
        information.)
-->
<function>to_date</function>はグレゴリオとISO週番号日のフィールドの混在を拒否しますが、<function>to_char</function>はそうではありません。<literal>YYYY-MM-DD (IYYY-IDDD)</literal>のような出力書式指定が有用な場合があるからです。
しかし、<literal>IYYY-MM-DD</literal>のような書き方は避けてください。年の初めの近くで驚くべき結果になるでしょう。
(より詳細な情報は<xref linkend="functions-datetime-extract"/>を参照してください。)
       </para>
      </caution>
     </listitem>

     <listitem>
      <para>
<!--
       In <function>to_timestamp</function>, millisecond
       (<literal>MS</literal>) or microsecond (<literal>US</literal>)
       fields are used as the
       seconds digits after the decimal point. For example
       <literal>to_timestamp('12.3', 'SS.MS')</literal> is not 3 milliseconds,
       but 300, because the conversion treats it as 12 + 0.3 seconds.
       So, for the format <literal>SS.MS</literal>, the input values
       <literal>12.3</literal>, <literal>12.30</literal>,
       and <literal>12.300</literal> specify the
       same number of milliseconds. To get three milliseconds, one must write
       <literal>12.003</literal>, which the conversion treats as
       12 + 0.003 = 12.003 seconds.
-->
<function>to_timestamp</function>において、ミリ秒（<literal>MS</literal>）およびマイクロ秒（<literal>US</literal>）フィールドは小数点の後の秒の桁として使用されます。
例えば、<literal>to_timestamp('12.3', 'SS.MS')</literal>は3ミリ秒ではなく300ミリ秒です。なぜなら変換においてこれは12 + 0.3秒と計算されるからです。
従って<literal>SS.MS</literal>書式に対して入力値<literal>12.3</literal>、<literal>12.30</literal>、<literal>12.300</literal>は同じミリ秒数を指定することになります。
3ミリ秒が必要な場合には<literal>12:003</literal>のようにしなければなりません。この時、変換において12 + 0.003 = 12.003秒と計算します。
      </para>

      <para>
<!--
       Here is a more
       complex example:
       <literal>to_timestamp('15:12:02.020.001230', 'HH24:MI:SS.MS.US')</literal>
       is 15 hours, 12 minutes, and 2 seconds + 20 milliseconds +
       1230 microseconds = 2.021230 seconds.
-->
もう少し複雑な例を挙げます。
<literal>to_timestamp('15:12:02.020.001230','HH:MI:SS.MS.US')</literal>は15時間12分と2秒+20ミリ秒+1230マイクロ秒 = 2.021230秒です。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
        <function>to_char(..., 'ID')</function>'s day of the week numbering
        matches the <function>extract(isodow from ...)</function> function, but
        <function>to_char(..., 'D')</function>'s does not match
        <function>extract(dow from ...)</function>'s day numbering.
-->
<function>to_char(..., 'ID')</function>の曜日番号付けは<function>extract(isodow from ...)</function>関数に一致しますが、<function>to_char(..., 'D')</function>の曜日番号付けは<function>extract(dow from ...)</function>の曜日番号付けに一致しません。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
        <function>to_char(interval)</function> formats <literal>HH</literal> and
        <literal>HH12</literal> as shown on a 12-hour clock, for example zero hours
        and 36 hours both output as <literal>12</literal>, while <literal>HH24</literal>
        outputs the full hour value, which can exceed 23 in
        an <type>interval</type> value.
-->
<function>to_char(interval)</function>関数は、<literal>HH</literal>と<literal>HH12</literal>を12時間の時計に表示されるように整形します。
例えば0時間と36時間はいずれも<literal>12</literal>として出力します。
一方<literal>HH24</literal>は時間の値をそのまま出力し、<type>interval</type>の値であれば23を超えることも可能です。
      </para>
     </listitem>

    </itemizedlist>
   </para>

  <para>
<!--
   <xref linkend="functions-formatting-numeric-table"/> shows the
   template patterns available for formatting numeric values.
-->
<xref linkend="functions-formatting-numeric-table"/>に、数値の書式設定に使用可能なテンプレートパターンを示します。
  </para>

    <table id="functions-formatting-numeric-table">
<!--
     <title>Template Patterns for Numeric Formatting</title>
-->
     <title>数値書式用のテンプレートパターン</title>
     <tgroup cols="2">
      <thead>
       <row>
<!--
        <entry>Pattern</entry>
        <entry>Description</entry>
-->
        <entry>パターン</entry>
        <entry>説明</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><literal>9</literal></entry>
<!--
        <entry>digit position (can be dropped if insignificant)</entry>
-->
        <entry>数字の位置（必要ないときは表示しない）</entry>
       </row>
       <row>
        <entry><literal>0</literal></entry>
<!--
        <entry>digit position (will not be dropped, even if insignificant)</entry>
-->
        <entry>数字の位置（必要ないときでも表示する）</entry>
       </row>
       <row>
<!--
        <entry><literal>.</literal> (period)</entry>
        <entry>decimal point</entry>
-->
        <entry><literal>.</literal>（ピリオド）</entry>
        <entry>小数点</entry>
       </row>
       <row>
<!--
        <entry><literal>,</literal> (comma)</entry>
        <entry>group (thousands) separator</entry>
-->
        <entry><literal>,</literal> (コンマ)</entry>
        <entry>千単位で区切る符号</entry>
       </row>
       <row>
        <entry><literal>PR</literal></entry>
<!--
        <entry>negative value in angle brackets</entry>
-->
        <entry>負の値の角括弧表示</entry>
       </row>
       <row>
        <entry><literal>S</literal></entry>
<!--
        <entry>sign anchored to number (uses locale)</entry>
-->
        <entry>符号付き値（ロケールを使用）</entry>
       </row>
       <row>
        <entry><literal>L</literal></entry>
<!--
        <entry>currency symbol (uses locale)</entry>
-->
        <entry>通貨記号（ロケールを使用）</entry>
       </row>
       <row>
        <entry><literal>D</literal></entry>
<!--
        <entry>decimal point (uses locale)</entry>
-->
        <entry>小数点（ロケールを使用）</entry>
       </row>
       <row>
        <entry><literal>G</literal></entry>
<!--
        <entry>group separator (uses locale)</entry>
-->
        <entry>グループ区切り文字（ロケールを使用）</entry>
       </row>
       <row>
        <entry><literal>MI</literal></entry>
<!--
        <entry>minus sign in specified position (if number &lt; 0)</entry>
-->
        <entry>（数値 &lt; 0であれば）指定位置にマイナス記号</entry>
       </row>
       <row>
        <entry><literal>PL</literal></entry>
<!--
        <entry>plus sign in specified position (if number &gt; 0)</entry>
-->
        <entry>（数値 &gt; 0であれば）指定位置にプラス記号</entry>
       </row>
       <row>
        <entry><literal>SG</literal></entry>
<!--
        <entry>plus/minus sign in specified position</entry>
-->
        <entry>指定された位置にプラス/マイナス記号</entry>
       </row>
       <row>
        <entry><literal>RN</literal></entry>
<!--
        <entry>Roman numeral (input between 1 and 3999)</entry>
-->
        <entry>ローマ数字（入力は1～3999）</entry>
       </row>
       <row>
<!--
        <entry><literal>TH</literal> or <literal>th</literal></entry>
        <entry>ordinal number suffix</entry>
-->
        <entry><literal>TH</literal>または<literal>th</literal></entry>
        <entry>序数接尾辞</entry>
       </row>
       <row>
        <entry><literal>V</literal></entry>
<!--
        <entry>shift specified number of digits (see notes)</entry>
-->
        <entry><replaceable>n</replaceable> 桁シフト（注意事項を参照）</entry>
       </row>
       <row>
        <entry><literal>EEEE</literal></entry>
<!--
        <entry>exponent for scientific notation</entry>
-->
        <entry>科学技術表記法用の指数</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
<!--
    Usage notes for numeric formatting:
-->
数値型書式の使用上の注意事項は次のとおりです。

    <itemizedlist>
     <listitem>
      <para>
<!--
       <literal>0</literal> specifies a digit position that will always be printed,
       even if it contains a leading/trailing zero.  <literal>9</literal> also
       specifies a digit position, but if it is a leading zero then it will
       be replaced by a space, while if it is a trailing zero and fill mode
       is specified then it will be deleted.  (For <function>to_number()</function>,
       these two pattern characters are equivalent.)
-->
<literal>0</literal>は、それが先頭あるいは末尾のゼロであっても必ず表示する数字の位置を指定します。
<literal>9</literal>も数字の位置を指定しますが、先頭のゼロであればそれは空白で置換され、また末尾のゼロで字詰めモードが指定されているときは削除されます。
（<function>to_number()</function>では、これら2つのパターン文字は同じ意味になります。）
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       The pattern characters <literal>S</literal>, <literal>L</literal>, <literal>D</literal>,
       and <literal>G</literal> represent the sign, currency symbol, decimal point,
       and thousands separator characters defined by the current locale
       (see <xref linkend="guc-lc-monetary"/>
       and <xref linkend="guc-lc-numeric"/>).  The pattern characters period
       and comma represent those exact characters, with the meanings of
       decimal point and thousands separator, regardless of locale.
-->
パターン文字<literal>S</literal>、<literal>L</literal>、<literal>D</literal>、<literal>G</literal>はそれぞれ現在のロケールで定義された符号、通貨記号、小数点、3桁区切り文字を表します（<xref linkend="guc-lc-monetary"/>および<xref linkend="guc-lc-numeric"/>を参照）。
パターン文字のピリオドとカンマはいずれもその文字そのものを表し、ロケールとは関係なく小数点と3桁区切り文字の意味を持ちます。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       If no explicit provision is made for a sign
       in <function>to_char()</function>'s pattern, one column will be reserved for
       the sign, and it will be anchored to (appear just left of) the
       number.  If <literal>S</literal> appears just left of some <literal>9</literal>'s,
       it will likewise be anchored to the number.
-->
<function>to_char()</function>のパターンで符号について明示的な条件付けがない場合、符号のために一桁が予約され、それは数に繋げられます（すぐ左側に置かれます）。
<literal>S</literal>がいくつかの<literal>9</literal>のすぐ左に置かれた場合、同様に数に繋げられます。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       A sign formatted using <literal>SG</literal>, <literal>PL</literal>, or
       <literal>MI</literal> is not anchored to
       the number; for example,
       <literal>to_char(-12, 'MI9999')</literal> produces <literal>'-&nbsp;&nbsp;12'</literal>
       but <literal>to_char(-12, 'S9999')</literal> produces <literal>'&nbsp;&nbsp;-12'</literal>.
       (The Oracle implementation does not allow the use of
       <literal>MI</literal> before <literal>9</literal>, but rather
       requires that <literal>9</literal> precede
       <literal>MI</literal>.)
-->
<literal>SG</literal>、<literal>PL</literal>、または<literal>MI</literal>で整形された符号は、数値と関連付けられません。
例えば、<literal>to_char(-12, 'MI9999')</literal>は<literal>'-&nbsp;&nbsp;12'</literal>となる一方、<literal>to_char(-12, 'S9999')</literal>は<literal>'&nbsp;&nbsp;-12'</literal>となります。
（Oracleの実装では<literal>9</literal>の前に<literal>MI</literal>が置かれてはならず、<literal>9</literal>の後に<literal>MI</literal>が置かれることを要求しています。）
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       <literal>TH</literal> does not convert values less than zero
       and does not convert fractional numbers.
-->
<literal>TH</literal>はゼロ未満の値と小数は変換しません
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       <literal>PL</literal>, <literal>SG</literal>, and
       <literal>TH</literal> are <productname>PostgreSQL</productname>
       extensions.
-->
<literal>PL</literal>、<literal>SG</literal>、および<literal>TH</literal>は<productname>PostgreSQL</productname>の拡張です。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       In <function>to_number</function>, if non-data template patterns such
       as <literal>L</literal> or <literal>TH</literal> are used, the
       corresponding number of input characters are skipped, whether or not
       they match the template pattern, unless they are data characters
       (that is, digits, sign, decimal point, or comma).  For
       example, <literal>TH</literal> would skip two non-data characters.
-->
<function>to_number</function>において、<literal>L</literal>あるいは<literal>TH</literal>のように非データテンプレートが使われた場合には、それがデータ文字（すなわち、数字、符号、10進小数点あるいはカンマ）でない限りテンプレートパターンにマッチするかどうかにかかわらず、該当する数分だけの入力文字がスキップされます。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       <literal>V</literal> with <function>to_char</function>
       multiplies the input values by
       <literal>10^<replaceable>n</replaceable></literal>, where
       <replaceable>n</replaceable> is the number of digits following
       <literal>V</literal>.  <literal>V</literal> with
       <function>to_number</function> divides in a similar manner.
       <function>to_char</function> and <function>to_number</function>
       do not support the use of
       <literal>V</literal> combined with a decimal point
       (e.g., <literal>99.9V99</literal> is not allowed).
-->
<literal>V</literal>を<function>to_char</function>につけると、入力値を<literal>10^<replaceable>n</replaceable></literal>倍します。
ここで<replaceable>n</replaceable>は<literal>V</literal>に続く桁数です。
<literal>V</literal>を<function>to_number</function>につけると、同じように割り算をします。
<function>to_char</function>および<function>to_number</function>は、小数点と<literal>V</literal>との混在をサポートしません（例えば、<literal>99.9V99</literal> とはできません）。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       <literal>EEEE</literal> (scientific notation) cannot be used in
       combination with any of the other formatting patterns or
       modifiers other than digit and decimal point patterns, and must be at the end of the format string
       (e.g., <literal>9.99EEEE</literal> is a valid pattern).
-->
<literal>EEEE</literal>(科学技術表記)は、桁と小数点のパターンを除き、他の書式パターンや修飾子と組み合わせて使うことはできず、また必ず書式文字列の最後に位置しなければなりません(例えば、<literal>9.99EEEE</literal>は正しい表記となります)。
      </para>
     </listitem>
    </itemizedlist>
   </para>

   <para>
<!--
    Certain modifiers can be applied to any template pattern to alter its
    behavior.  For example, <literal>FM99.99</literal>
    is the <literal>99.99</literal> pattern with the
    <literal>FM</literal> modifier.
    <xref linkend="functions-formatting-numericmod-table"/> shows the
    modifier patterns for numeric formatting.
-->
すべてのテンプレートについて、その動作を変えるために、いくつかの修飾子を適用できます。
例えば、<literal>FM99.99</literal>は<literal>FM</literal>修飾子が付いた<literal>99.99</literal>パターンです。
<xref linkend="functions-formatting-numericmod-table"/>に、数値の書式用の修飾子パターンを示します。
   </para>

    <table id="functions-formatting-numericmod-table">
<!--
     <title>Template Pattern Modifiers for Numeric Formatting</title>
-->
     <title>数値の書式用テンプレートパターン修飾子</title>
     <tgroup cols="3">
      <thead>
       <row>
<!--
        <entry>Modifier</entry>
        <entry>Description</entry>
        <entry>Example</entry>
-->
        <entry>修飾子</entry>
        <entry>説明</entry>
        <entry>例</entry>
       </row>
      </thead>
      <tbody>
       <row>
<!--
        <entry><literal>FM</literal> prefix</entry>
-->
        <entry><literal>FM</literal>添え字</entry>
<!--
        <entry>fill mode (suppress trailing zeroes and padding blanks)</entry>
        <entry><literal>FM99.99</literal></entry>
-->
        <entry>字詰めモード（末尾の0と空白の埋め字を無効にする）</entry>
        <entry><literal>FM99.99</literal></entry>
       </row>
       <row>
<!--
        <entry><literal>TH</literal> suffix</entry>
-->
        <entry><literal>TH</literal>添え字</entry>
<!--
        <entry>upper case ordinal number suffix</entry>
-->
        <entry>大文字による序数添え字</entry>
        <entry><literal>999TH</literal></entry>
       </row>
       <row>
<!--
        <entry><literal>th</literal> suffix</entry>
-->
        <entry><literal>th</literal>添え字</entry>
<!--
        <entry>lower case ordinal number suffix</entry>
-->
        <entry>子文字による序数添え字</entry>
        <entry><literal>999th</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

  <para>
<!--
   <xref linkend="functions-formatting-examples-table"/> shows some
   examples of the use of the <function>to_char</function> function.
-->
<xref linkend="functions-formatting-examples-table"/>に、<function>to_char</function>関数を使用した例をいくつか示します。
  </para>

    <table id="functions-formatting-examples-table">
<!--
     <title><function>to_char</function> Examples</title>
-->
     <title><function>to_char</function>の例</title>
     <tgroup cols="2">
      <thead>
       <row>
<!--
        <entry>Expression</entry>
        <entry>Result</entry>
-->
        <entry>式</entry>
        <entry>結果</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><literal>to_char(current_timestamp, 'Day,&nbsp;DD&nbsp;&nbsp;HH12:MI:SS')</literal></entry>
        <entry><literal>'Tuesday&nbsp;&nbsp;,&nbsp;06&nbsp;&nbsp;05:39:18'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(current_timestamp, 'FMDay,&nbsp;FMDD&nbsp;&nbsp;HH12:MI:SS')</literal></entry>
        <entry><literal>'Tuesday,&nbsp;6&nbsp;&nbsp;05:39:18'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(-0.1, '99.99')</literal></entry>
        <entry><literal>'&nbsp;&nbsp;-.10'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(-0.1, 'FM9.99')</literal></entry>
        <entry><literal>'-.1'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(-0.1, 'FM90.99')</literal></entry>
        <entry><literal>'-0.1'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(0.1, '0.9')</literal></entry>
        <entry><literal>'&nbsp;0.1'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(12, '9990999.9')</literal></entry>
        <entry><literal>'&nbsp;&nbsp;&nbsp;&nbsp;0012.0'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(12, 'FM9990999.9')</literal></entry>
        <entry><literal>'0012.'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485, '999')</literal></entry>
        <entry><literal>'&nbsp;485'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(-485, '999')</literal></entry>
        <entry><literal>'-485'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485, '9&nbsp;9&nbsp;9')</literal></entry>
        <entry><literal>'&nbsp;4&nbsp;8&nbsp;5'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(1485, '9,999')</literal></entry>
        <entry><literal>'&nbsp;1,485'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(1485, '9G999')</literal></entry>
        <entry><literal>'&nbsp;1&nbsp;485'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(148.5, '999.999')</literal></entry>
        <entry><literal>'&nbsp;148.500'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(148.5, 'FM999.999')</literal></entry>
        <entry><literal>'148.5'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(148.5, 'FM999.990')</literal></entry>
        <entry><literal>'148.500'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(148.5, '999D999')</literal></entry>
        <entry><literal>'&nbsp;148,500'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(3148.5, '9G999D999')</literal></entry>
        <entry><literal>'&nbsp;3&nbsp;148,500'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(-485, '999S')</literal></entry>
        <entry><literal>'485-'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(-485, '999MI')</literal></entry>
        <entry><literal>'485-'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485, '999MI')</literal></entry>
        <entry><literal>'485&nbsp;'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485, 'FM999MI')</literal></entry>
        <entry><literal>'485'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485, 'PL999')</literal></entry>
        <entry><literal>'+485'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485, 'SG999')</literal></entry>
        <entry><literal>'+485'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(-485, 'SG999')</literal></entry>
        <entry><literal>'-485'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(-485, '9SG99')</literal></entry>
        <entry><literal>'4-85'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(-485, '999PR')</literal></entry>
        <entry><literal>'&lt;485&gt;'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485, 'L999')</literal></entry>
        <entry><literal>'DM&nbsp;485'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485, 'RN')</literal></entry>
        <entry><literal>'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CDLXXXV'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485, 'FMRN')</literal></entry>
        <entry><literal>'CDLXXXV'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(5.2, 'FMRN')</literal></entry>
        <entry><literal>'V'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(482, '999th')</literal></entry>
        <entry><literal>'&nbsp;482nd'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485, '"Good&nbsp;number:"999')</literal></entry>
        <entry><literal>'Good&nbsp;number:&nbsp;485'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485.8, '"Pre:"999"&nbsp;Post:"&nbsp;.999')</literal></entry>
        <entry><literal>'Pre:&nbsp;485&nbsp;Post:&nbsp;.800'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(12, '99V999')</literal></entry>
        <entry><literal>'&nbsp;12000'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(12.4, '99V999')</literal></entry>
        <entry><literal>'&nbsp;12400'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(12.45, '99V9')</literal></entry>
        <entry><literal>'&nbsp;125'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(0.0004859, '9.99EEEE')</literal></entry>
        <entry><literal>' 4.86e-04'</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

  </sect1>


  <sect1 id="functions-datetime">
<!--
   <title>Date/Time Functions and Operators</title>
-->
   <title>日付/時刻関数と演算子</title>

  <para>
<!--
   <xref linkend="functions-datetime-table"/> shows the available
   functions for date/time value processing, with details appearing in
   the following subsections.  <xref
   linkend="operators-datetime-table"/> illustrates the behaviors of
   the basic arithmetic operators (<literal>+</literal>,
   <literal>*</literal>, etc.).  For formatting functions, refer to
   <xref linkend="functions-formatting"/>.  You should be familiar with
   the background information on date/time data types from <xref
   linkend="datatype-datetime"/>.
-->
<xref linkend="functions-datetime-table"/>は、日付/時刻型の値の処理で使用可能な関数を示しています。詳細は、以下の副節で説明します。
<xref linkend="operators-datetime-table"/>は、（<literal>+</literal>、<literal>*</literal>等の）基本的な算術演算子の振舞いを説明しています。
書式設定関数については<xref linkend="functions-formatting"/>を参照してください。
<xref linkend="datatype-datetime"/>を参照して、日付/時刻データ型についての背景となっている情報に精通していなければなりません。
  </para>

  <para>
<!--
   All the functions and operators described below that take <type>time</type> or <type>timestamp</type>
   inputs actually come in two variants: one that takes <type>time with time zone</type> or <type>timestamp
   with time zone</type>, and one that takes <type>time without time zone</type> or <type>timestamp without time zone</type>.
   For brevity, these variants are not shown separately.  Also, the
   <literal>+</literal> and <literal>*</literal> operators come in commutative pairs (for
   example both date + integer and integer + date); we show only one of each
   such pair.
-->
以下の<type>time</type>もしくは<type>timestamp</type>型の入力を受け取る関数および演算子は全て、実際には2つの種類があります。1つは<type>time with time zone</type>型または<type>timestamp with time zone</type>型を取るもので、もう1つは<type>time without time zone</type>型もしくは<type>timestamp without time zone</type>型を取るものです。
簡略化のため、これらの種類の違いは個別に示していません。
また、<literal>+</literal>と<literal>*</literal>演算子は可換な2項をとります（例えばdate + integerとinteger + date）。こうした組み合わせは片方のみ示します。
  </para>

    <table id="operators-datetime-table">
<!--
     <title>Date/Time Operators</title>
-->
     <title>日付/時刻演算子</title>

     <tgroup cols="3">
      <thead>
       <row>
<!--
        <entry>Operator</entry>
        <entry>Example</entry>
        <entry>Result</entry>
-->
        <entry>演算子名</entry>
        <entry>例</entry>
        <entry>結果</entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry> <literal>+</literal> </entry>
        <entry><literal>date '2001-09-28' + integer '7'</literal></entry>
        <entry><literal>date '2001-10-05'</literal></entry>
       </row>

       <row>
        <entry> <literal>+</literal> </entry>
        <entry><literal>date '2001-09-28' + interval '1 hour'</literal></entry>
        <entry><literal>timestamp '2001-09-28 01:00:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>+</literal> </entry>
        <entry><literal>date '2001-09-28' + time '03:00'</literal></entry>
        <entry><literal>timestamp '2001-09-28 03:00:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>+</literal> </entry>
        <entry><literal>interval '1 day' + interval '1 hour'</literal></entry>
        <entry><literal>interval '1 day 01:00:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>+</literal> </entry>
        <entry><literal>timestamp '2001-09-28 01:00' + interval '23 hours'</literal></entry>
        <entry><literal>timestamp '2001-09-29 00:00:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>+</literal> </entry>
        <entry><literal>time '01:00' + interval '3 hours'</literal></entry>
        <entry><literal>time '04:00:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>-</literal> </entry>
        <entry><literal>- interval '23 hours'</literal></entry>
        <entry><literal>interval '-23:00:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>-</literal> </entry>
        <entry><literal>date '2001-10-01' - date '2001-09-28'</literal></entry>
<!--
        <entry><literal>integer '3'</literal> (days)</entry>
-->
        <entry><literal>integer '3'</literal>（日付）</entry>
       </row>

       <row>
        <entry> <literal>-</literal> </entry>
        <entry><literal>date '2001-10-01' - integer '7'</literal></entry>
        <entry><literal>date '2001-09-24'</literal></entry>
       </row>

       <row>
        <entry> <literal>-</literal> </entry>
        <entry><literal>date '2001-09-28' - interval '1 hour'</literal></entry>
        <entry><literal>timestamp '2001-09-27 23:00:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>-</literal> </entry>
        <entry><literal>time '05:00' - time '03:00'</literal></entry>
        <entry><literal>interval '02:00:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>-</literal> </entry>
        <entry><literal>time '05:00' - interval '2 hours'</literal></entry>
        <entry><literal>time '03:00:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>-</literal> </entry>
        <entry><literal>timestamp '2001-09-28 23:00' - interval '23 hours'</literal></entry>
        <entry><literal>timestamp '2001-09-28 00:00:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>-</literal> </entry>
        <entry><literal>interval '1 day' - interval '1 hour'</literal></entry>
        <entry><literal>interval '1 day -01:00:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>-</literal> </entry>
        <entry><literal>timestamp '2001-09-29 03:00' - timestamp '2001-09-27 12:00'</literal></entry>
        <entry><literal>interval '1 day 15:00:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>*</literal> </entry>
        <entry><literal>900 * interval '1 second'</literal></entry>
        <entry><literal>interval '00:15:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>*</literal> </entry>
        <entry><literal>21 * interval '1 day'</literal></entry>
        <entry><literal>interval '21 days'</literal></entry>
       </row>

       <row>
        <entry> <literal>*</literal> </entry>
        <entry><literal>double precision '3.5' * interval '1 hour'</literal></entry>
        <entry><literal>interval '03:30:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>/</literal> </entry>
        <entry><literal>interval '1 hour' / double precision '1.5'</literal></entry>
        <entry><literal>interval '00:40:00'</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

    <table id="functions-datetime-table">
<!--
     <title>Date/Time Functions</title>
-->
     <title>日付/時刻関数</title>
     <tgroup cols="5">
      <thead>
       <row>
<!--
        <entry>Function</entry>
        <entry>Return Type</entry>
        <entry>Description</entry>
        <entry>Example</entry>
        <entry>Result</entry>
-->
        <entry>関数名</entry>
        <entry>戻り値型</entry>
        <entry>説明</entry>
        <entry>例</entry>
        <entry>結果</entry>
    
       </row>
      </thead>

      <tbody>
       <row>
        <entry>
         <indexterm>
          <primary>age</primary>
         </indexterm>
         <literal><function>age(<type>timestamp</type>, <type>timestamp</type>)</function></literal>
        </entry>
        <entry><type>interval</type></entry>
<!--
        <entry>Subtract arguments, producing a <quote>symbolic</quote> result that
        uses years and months, rather than just days</entry>
-->
        <entry>引数間の減算。日数だけでなく年と月を使用した<quote>言葉による</quote>結果を生成</entry>
        <entry><literal>age(timestamp '2001-04-10', timestamp '1957-06-13')</literal></entry>
        <entry><literal>43 years 9 mons 27 days</literal></entry>
       </row>

       <row>
        <entry><literal><function>age(<type>timestamp</type>)</function></literal></entry>
        <entry><type>interval</type></entry>
<!--
        <entry>Subtract from <function>current_date</function> (at midnight)</entry>
-->
        <entry><function>current_date</function>（午前零時）から減算</entry>
        <entry><literal>age(timestamp '1957-06-13')</literal></entry>
        <entry><literal>43 years 8 mons 3 days</literal></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>clock_timestamp</primary>
         </indexterm>
         <literal><function>clock_timestamp()</function></literal>
        </entry>
        <entry><type>timestamp with time zone</type></entry>
<!--
        <entry>Current date and time (changes during statement execution);
         see <xref linkend="functions-datetime-current"/>
-->
        <entry>現在の日付と時刻（文実行中に変化する）。<xref linkend="functions-datetime-current"/>を参照。
        </entry>
        <entry></entry>
        <entry></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>current_date</primary>
         </indexterm>
         <literal><function>current_date</function></literal>
        </entry>
        <entry><type>date</type></entry>
<!--
        <entry>Current date;
         see <xref linkend="functions-datetime-current"/>
-->
        <entry>現在の日付。<xref linkend="functions-datetime-current"/>を参照
        </entry>
        <entry></entry>
        <entry></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>current_time</primary>
         </indexterm>
         <literal><function>current_time</function></literal>
        </entry>
        <entry><type>time with time zone</type></entry>
<!--
        <entry>Current time of day;
         see <xref linkend="functions-datetime-current"/>
-->
        <entry>現在の時刻。<xref linkend="functions-datetime-current"/>を参照。
        </entry>
        <entry></entry>
        <entry></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>current_timestamp</primary>
         </indexterm>
         <literal><function>current_timestamp</function></literal>
        </entry>
        <entry><type>timestamp with time zone</type></entry>
<!--
        <entry>Current date and time (start of current transaction);
         see <xref linkend="functions-datetime-current"/>
-->
        <entry>現在の日付と時刻（現在のトランザクションの開始時）。<xref linkend="functions-datetime-current"/>を参照。
        </entry>
        <entry></entry>
        <entry></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>date_part</primary>
         </indexterm>
         <literal><function>date_part(<type>text</type>, <type>timestamp</type>)</function></literal>
        </entry>
        <entry><type>double precision</type></entry>
<!--
        <entry>Get subfield (equivalent to <function>extract</function>);
         see <xref linkend="functions-datetime-extract"/>
-->
        <entry>部分フィールドの取得（<function>extract</function>と同じ）。<xref linkend="functions-datetime-extract"/>を参照。
        </entry>
        <entry><literal>date_part('hour', timestamp '2001-02-16 20:38:40')</literal></entry>
        <entry><literal>20</literal></entry>
       </row>

       <row>
        <entry><literal><function>date_part(<type>text</type>, <type>interval</type>)</function></literal></entry>
        <entry><type>double precision</type></entry>
<!--
        <entry>Get subfield (equivalent to
         <function>extract</function>); see <xref linkend="functions-datetime-extract"/>
-->
        <entry>部分フィールドの取得（<function>extract</function>と同じ）。<xref linkend="functions-datetime-extract"/>を参照。
        </entry>
        <entry><literal>date_part('month', interval '2 years 3 months')</literal></entry>
        <entry><literal>3</literal></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>date_trunc</primary>
         </indexterm>
         <literal><function>date_trunc(<type>text</type>, <type>timestamp</type>)</function></literal>
        </entry>
        <entry><type>timestamp</type></entry>
<!--
        <entry>Truncate to specified precision; see <xref linkend="functions-datetime-trunc"/>
-->
        <entry>指定された精度で切り捨て。<xref linkend="functions-datetime-trunc"/>も参照。
        </entry>
        <entry><literal>date_trunc('hour', timestamp '2001-02-16 20:38:40')</literal></entry>
        <entry><literal>2001-02-16 20:00:00</literal></entry>
       </row>

       <row>
        <entry><literal><function>date_trunc(<type>text</type>, <type>timestamp with time zone</type>, <type>text</type>)</function></literal></entry>
        <entry><type>timestamp with time zone</type></entry>
        <entry>Truncate to specified precision in the specified time zone; see <xref linkend="functions-datetime-trunc"/>
        </entry>
        <entry><literal>date_trunc('day', timestamptz '2001-02-16 20:38:40+00', 'Australia/Sydney')</literal></entry>
        <entry><literal>2001-02-16 13:00:00+00</literal></entry>
       </row>

       <row>
        <entry><literal><function>date_trunc(<type>text</type>, <type>interval</type>)</function></literal></entry>
        <entry><type>interval</type></entry>
<!--
        <entry>Truncate to specified precision; see <xref linkend="functions-datetime-trunc"/>
-->
        <entry>指定された精度で切り捨て。<xref linkend="functions-datetime-trunc"/>も参照。
        </entry>
        <entry><literal>date_trunc('hour', interval '2 days 3 hours 40 minutes')</literal></entry>
        <entry><literal>2 days 03:00:00</literal></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>extract</primary>
         </indexterm>
         <literal><function>extract</function>(<parameter>field</parameter> from
         <type>timestamp</type>)</literal>
        </entry>
        <entry><type>double precision</type></entry>
<!--
        <entry>Get subfield; see <xref linkend="functions-datetime-extract"/>
-->
        <entry>部分フィールドの取得。<xref linkend="functions-datetime-extract"/>を参照。
        </entry>
        <entry><literal>extract(hour from timestamp '2001-02-16 20:38:40')</literal></entry>
        <entry><literal>20</literal></entry>
       </row>

       <row>
        <entry><literal><function>extract</function>(<parameter>field</parameter> from
         <type>interval</type>)</literal></entry>
        <entry><type>double precision</type></entry>
<!--
        <entry>Get subfield; see <xref linkend="functions-datetime-extract"/>
-->
        <entry>部分フィールドの取得。<xref linkend="functions-datetime-extract"/>を参照。
        </entry>
        <entry><literal>extract(month from interval '2 years 3 months')</literal></entry>
        <entry><literal>3</literal></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>isfinite</primary>
         </indexterm>
         <literal><function>isfinite(<type>date</type>)</function></literal>
        </entry>
        <entry><type>boolean</type></entry>
<!--
        <entry>Test for finite date (not +/-infinity)</entry>
-->
        <entry>日付が有限（+/-無限でない）かどうかの検査</entry>
        <entry><literal>isfinite(date '2001-02-16')</literal></entry>
        <entry><literal>true</literal></entry>
       </row>

       <row>
        <entry><literal><function>isfinite(<type>timestamp</type>)</function></literal></entry>
        <entry><type>boolean</type></entry>
<!--
        <entry>Test for finite time stamp (not +/-infinity)</entry>
-->
        <entry>タイムスタンプが有限（+/-無限でない）かどうかの検査</entry>
        <entry><literal>isfinite(timestamp '2001-02-16 21:28:30')</literal></entry>
        <entry><literal>true</literal></entry>
       </row>

       <row>
        <entry><literal><function>isfinite(<type>interval</type>)</function></literal></entry>
        <entry><type>boolean</type></entry>
<!--
        <entry>Test for finite interval</entry>
-->
        <entry>時間間隔が有限かどうかの検査</entry>
        <entry><literal>isfinite(interval '4 hours')</literal></entry>
        <entry><literal>true</literal></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>justify_days</primary>
         </indexterm>
         <literal><function>justify_days(<type>interval</type>)</function></literal>
        </entry>
        <entry><type>interval</type></entry>
<!--
        <entry>Adjust interval so 30-day time periods are represented as months</entry>
-->
        <entry>30日周期が1月を表すように時間間隔を調整</entry>
        <entry><literal>justify_days(interval '35 days')</literal></entry>
        <entry><literal>1 mon 5 days</literal></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>justify_hours</primary>
         </indexterm>
         <literal><function>justify_hours(<type>interval</type>)</function></literal>
        </entry>
        <entry><type>interval</type></entry>
<!--
        <entry>Adjust interval so 24-hour time periods are represented as days</entry>
-->
        <entry>24時間を1日とする時間間隔の調整</entry>
        <entry><literal>justify_hours(interval '27 hours')</literal></entry>
        <entry><literal>1 day 03:00:00</literal></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>justify_interval</primary>
         </indexterm>
         <literal><function>justify_interval(<type>interval</type>)</function></literal>
        </entry>
        <entry><type>interval</type></entry>
<!--
        <entry>Adjust interval using <function>justify_days</function> and <function>justify_hours</function>, with additional sign adjustments</entry>
-->
        <entry><function>justify_days</function>および<function>justify_hours</function>を使用し、さらに符号による調整を行っての時間間隔の調整</entry>
        <entry><literal>justify_interval(interval '1 mon -1 hour')</literal></entry>
        <entry><literal>29 days 23:00:00</literal></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>localtime</primary>
         </indexterm>
         <literal><function>localtime</function></literal>
        </entry>
        <entry><type>time</type></entry>
<!--
        <entry>Current time of day;
         see <xref linkend="functions-datetime-current"/>
-->
        <entry>現在の時刻。<xref linkend="functions-datetime-current"/>を参照。
        </entry>
        <entry></entry>
        <entry></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>localtimestamp</primary>
         </indexterm>
         <literal><function>localtimestamp</function></literal>
        </entry>
        <entry><type>timestamp</type></entry>
<!--
        <entry>Current date and time (start of current transaction);
         see <xref linkend="functions-datetime-current"/>
-->
        <entry>現在の日付と時刻（現在のトランザクションの開始時）。<xref linkend="functions-datetime-current"/>を参照。
        </entry>
        <entry></entry>
        <entry></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>make_date</primary>
         </indexterm>
         <literal>
            <function>
             make_date(<parameter>year</parameter> <type>int</type>,
             <parameter>month</parameter> <type>int</type>,
             <parameter>day</parameter> <type>int</type>)
            </function>
         </literal>
        </entry>
        <entry><type>date</type></entry>
        <entry>
<!--
         Create date from year, month and day fields
-->
         年、月、日フィールドから日付を作成
        </entry>
        <entry><literal>make_date(2013, 7, 15)</literal></entry>
        <entry><literal>2013-07-15</literal></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>make_interval</primary>
         </indexterm>
         <literal>
          <function>
           make_interval(<parameter>years</parameter> <type>int</type> DEFAULT 0,
           <parameter>months</parameter> <type>int</type> DEFAULT 0,
           <parameter>weeks</parameter> <type>int</type> DEFAULT 0,
           <parameter>days</parameter> <type>int</type> DEFAULT 0,
           <parameter>hours</parameter> <type>int</type> DEFAULT 0,
           <parameter>mins</parameter> <type>int</type> DEFAULT 0,
           <parameter>secs</parameter> <type>double precision</type> DEFAULT 0.0)
          </function>
         </literal>
        </entry>
        <entry><type>interval</type></entry>
        <entry>
<!--
         Create interval from years, months, weeks, days, hours, minutes and
         seconds fields
-->
         年、月、週、日、時間、分、秒フィールドから時間間隔を作成
        </entry>
        <entry><literal>make_interval(days =&gt; 10)</literal></entry>
        <entry><literal>10 days</literal></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>make_time</primary>
         </indexterm>
         <literal>
          <function>
           make_time(<parameter>hour</parameter> <type>int</type>,
           <parameter>min</parameter> <type>int</type>,
           <parameter>sec</parameter> <type>double precision</type>)
          </function>
         </literal>
        </entry>
        <entry><type>time</type></entry>
        <entry>
<!--
         Create time from hour, minute and seconds fields
-->
         時、分、秒フィールドから時刻を作成
        </entry>
        <entry><literal>make_time(8, 15, 23.5)</literal></entry>
        <entry><literal>08:15:23.5</literal></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>make_timestamp</primary>
         </indexterm>
         <literal>
          <function>
           make_timestamp(<parameter>year</parameter> <type>int</type>,
           <parameter>month</parameter> <type>int</type>,
           <parameter>day</parameter> <type>int</type>,
           <parameter>hour</parameter> <type>int</type>,
           <parameter>min</parameter> <type>int</type>,
           <parameter>sec</parameter> <type>double precision</type>)
          </function>
         </literal>
        </entry>
        <entry><type>timestamp</type></entry>
        <entry>
<!--
         Create timestamp from year, month, day, hour, minute and seconds fields
-->
         年、月、日、時、分、秒フィールドから時刻を作成
        </entry>
        <entry><literal>make_timestamp(2013, 7, 15, 8, 15, 23.5)</literal></entry>
        <entry><literal>2013-07-15 08:15:23.5</literal></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>make_timestamptz</primary>
         </indexterm>
         <literal>
          <function>
           make_timestamptz(<parameter>year</parameter> <type>int</type>,
           <parameter>month</parameter> <type>int</type>,
           <parameter>day</parameter> <type>int</type>,
           <parameter>hour</parameter> <type>int</type>,
           <parameter>min</parameter> <type>int</type>,
           <parameter>sec</parameter> <type>double precision</type>,
           <optional> <parameter>timezone</parameter> <type>text</type> </optional>)
          </function>
         </literal>
        </entry>
        <entry><type>timestamp with time zone</type></entry>
        <entry>
<!--
         Create timestamp with time zone from year, month, day, hour, minute
         and seconds fields; if <parameter>timezone</parameter> is not
         specified, the current time zone is used
-->
         年、月、日、時、分、秒フィールドから時間帯付きの時刻を作成。<parameter>timezone</parameter>が指定されていなければ、現在の時間帯が使われる。
        </entry>
        <entry><literal>make_timestamptz(2013, 7, 15, 8, 15, 23.5)</literal></entry>
        <entry><literal>2013-07-15 08:15:23.5+01</literal></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>now</primary>
         </indexterm>
         <literal><function>now()</function></literal>
        </entry>
        <entry><type>timestamp with time zone</type></entry>
<!--
        <entry>Current date and time (start of current transaction);
         see <xref linkend="functions-datetime-current"/>
-->
        <entry>現在の日付と時刻（現在のトランザクションの開始時）。
<xref linkend="functions-datetime-current"/>を参照。
        </entry>
        <entry></entry>
        <entry></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>statement_timestamp</primary>
         </indexterm>
         <literal><function>statement_timestamp()</function></literal>
        </entry>
        <entry><type>timestamp with time zone</type></entry>
<!--
        <entry>Current date and time (start of current statement);
         see <xref linkend="functions-datetime-current"/>
-->
        <entry>現在の日付と時刻（現在の文の開始時）。
<xref linkend="functions-datetime-current"/>を参照。
        </entry>
        <entry></entry>
        <entry></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>timeofday</primary>
         </indexterm>
         <literal><function>timeofday()</function></literal>
        </entry>
        <entry><type>text</type></entry>
<!--
        <entry>Current date and time
         (like <function>clock_timestamp</function>, but as a <type>text</type> string);
         see <xref linkend="functions-datetime-current"/>
-->
        <entry>現在の日付と時刻（<function>clock_timestamp</function>と似ているが、<type>text</type>型文字列として返す）。<xref linkend="functions-datetime-current"/>を参照。
        </entry>
        <entry></entry>
        <entry></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>transaction_timestamp</primary>
         </indexterm>
         <literal><function>transaction_timestamp()</function></literal>
        </entry>
        <entry><type>timestamp with time zone</type></entry>
<!--
        <entry>Current date and time (start of current transaction);
         see <xref linkend="functions-datetime-current"/>
-->
        <entry>現在の日付と時刻（現在のトランザクションの開始時）。
<xref linkend="functions-datetime-current"/>を参照。
        </entry>
        <entry></entry>
        <entry></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>to_timestamp</primary>
         </indexterm>
         <literal><function>to_timestamp(<type>double precision</type>)</function></literal>
        </entry>
        <entry><type>timestamp with time zone</type></entry>
<!--
        <entry>Convert Unix epoch (seconds since 1970-01-01 00:00:00+00) to
         timestamp</entry>
-->
        <entry>Unixエポック時間（1970-01-01 00:00:00+00からの経過秒数）をタイムスタンプに変換</entry>
        <entry><literal>to_timestamp(1284352323)</literal></entry>
        <entry><literal>2010-09-13 04:32:03+00</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
    <indexterm>
      <primary>OVERLAPS</primary>
    </indexterm>
<!--
    In addition to these functions, the SQL <literal>OVERLAPS</literal> operator is
    supported:
-->
これらの関数に加え、<literal>OVERLAPS</literal> SQL演算子がサポートされています。
<synopsis>
(<replaceable>start1</replaceable>, <replaceable>end1</replaceable>) OVERLAPS (<replaceable>start2</replaceable>, <replaceable>end2</replaceable>)
(<replaceable>start1</replaceable>, <replaceable>length1</replaceable>) OVERLAPS (<replaceable>start2</replaceable>, <replaceable>length2</replaceable>)
</synopsis>
<!--
    This expression yields true when two time periods (defined by their
    endpoints) overlap, false when they do not overlap.  The endpoints
    can be specified as pairs of dates, times, or time stamps; or as
    a date, time, or time stamp followed by an interval.  When a pair
    of values is provided, either the start or the end can be written
    first; <literal>OVERLAPS</literal> automatically takes the earlier value
    of the pair as the start.  Each time period is considered to
    represent the half-open interval <replaceable>start</replaceable> <literal>&lt;=</literal>
    <replaceable>time</replaceable> <literal>&lt;</literal> <replaceable>end</replaceable>, unless
    <replaceable>start</replaceable> and <replaceable>end</replaceable> are equal in which case it
    represents that single time instant.  This means for instance that two
    time periods with only an endpoint in common do not overlap.
-->
この式は、2つの時間間隔（その両端で定義されます）が重なる時に真を返します。重ならない場合は偽を返します。
両端は2つの日付、時刻、タイムスタンプとして、もしくは、日付/時刻/タイムスタンプとそれに続く時間間隔として指定できます。
値の組み合わせで指定する場合、開始と終了のいずれを先に記述しても構いません。<literal>OVERLAPS</literal>は与えられた値のうち、早い方を開始として扱います。
各時間間隔は、<replaceable>start</replaceable> <literal>&lt;=</literal> <replaceable>time</replaceable> <literal>&lt;</literal> <replaceable>end</replaceable>という半開区間として見なされます。ただし、<replaceable>start</replaceable>と<replaceable>end</replaceable>が同じ値の場合には単一の時間点となります。
これは、例えば端点のみが共通である2つの時間間隔は、重ならないということを意味します。
   </para>

<screen>
SELECT (DATE '2001-02-16', DATE '2001-12-21') OVERLAPS
       (DATE '2001-10-30', DATE '2002-10-30');
<lineannotation>Result: </lineannotation><computeroutput>true</computeroutput>
SELECT (DATE '2001-02-16', INTERVAL '100 days') OVERLAPS
       (DATE '2001-10-30', DATE '2002-10-30');
<lineannotation>Result: </lineannotation><computeroutput>false</computeroutput>
SELECT (DATE '2001-10-29', DATE '2001-10-30') OVERLAPS
       (DATE '2001-10-30', DATE '2001-10-31');
<lineannotation>Result: </lineannotation><computeroutput>false</computeroutput>
SELECT (DATE '2001-10-30', DATE '2001-10-30') OVERLAPS
       (DATE '2001-10-30', DATE '2001-10-31');
<lineannotation>Result: </lineannotation><computeroutput>true</computeroutput>
</screen>

  <para>
<!--
   When adding an <type>interval</type> value to (or subtracting an
   <type>interval</type> value from) a <type>timestamp with time zone</type>
   value, the days component advances or decrements the date of the
   <type>timestamp with time zone</type> by the indicated number of days.
   Across daylight saving time changes (when the session time zone is set to a
   time zone that recognizes DST), this means <literal>interval '1 day'</literal>
   does not necessarily equal <literal>interval '24 hours'</literal>.
   For example, with the session time zone set to <literal>CST7CDT</literal>,
   <literal>timestamp with time zone '2005-04-02 12:00-07' + interval '1 day'</literal>
   will produce <literal>timestamp with time zone '2005-04-03 12:00-06'</literal>,
   while adding <literal>interval '24 hours'</literal> to the same initial
   <type>timestamp with time zone</type> produces
   <literal>timestamp with time zone '2005-04-03 13:00-06'</literal>, as there is
   a change in daylight saving time at <literal>2005-04-03 02:00</literal> in time zone
   <literal>CST7CDT</literal>.
-->
<type>timestamp with time zone</type>の値に<type>interval</type>の値を加える時（または<type>interval</type>の値を引く時）、日にちの部分は、<type>timestamp with time zone</type>の日付を指定された日数だけ先に進める、もしくは後に戻します。
（セッションの時間帯がDSTを認識する設定の場合）夏時間の移行に跨っての変化に関しては、<literal>interval '1 day'</literal>が<literal>interval '24 hours'</literal>に等しいとは限りません。
例えば、セッションの時間帯が <literal>CST7CDT</literal>に設定されている時に、 <literal>timestamp with time zone '2005-04-02 12:00-07' + interval '1 day' </literal>は、<literal>timestamp with time zone '2005-04-03 12:00-06'</literal>となります。一方、元の同じ<type>timestamp with time zone</type>に<literal>interval '24 hours'</literal>を加えると、<literal>timestamp with time zone '2005-04-03 13:00-06'</literal>という結果になります。その理由は<literal>CST7CDT</literal>時間帯で<literal>2005-04-03 02:00</literal>に夏時間への変更があるからです。
  </para>

  <para>
<!--
   Note there can be ambiguity in the <literal>months</literal> field returned by
   <function>age</function> because different months have different numbers of
   days.  <productname>PostgreSQL</productname>'s approach uses the month from the
   earlier of the two dates when calculating partial months.  For example,
   <literal>age('2004-06-01', '2004-04-30')</literal> uses April to yield
   <literal>1 mon 1 day</literal>, while using May would yield <literal>1 mon 2
   days</literal> because May has 31 days, while April has only 30.
-->
異なる月では日数が異なりますので<function>age</function>で返される<literal>months</literal>フィールドにはあいまいさがあります。
<productname>PostgreSQL</productname>のやり方は月をまたがる２つの日付の計算において、日付の早いほうの月を使用します。
例えば、<literal>age('2004-06-01', '2004-04-30')</literal>は4月を使用して<literal>1 mon 1 day</literal>を得ます。5月は31日あり、4月は30日のため、もし5月を使用するなら結果は<literal>1 mon 2 days</literal>となるでしょう。
  </para>

  <para>
<!--
   Subtraction of dates and timestamps can also be complex.  One conceptually
   simple way to perform subtraction is to convert each value to a number
   of seconds using <literal>EXTRACT(EPOCH FROM ...)</literal>, then subtract the
   results; this produces the
   number of <emphasis>seconds</emphasis> between the two values.  This will adjust
   for the number of days in each month, timezone changes, and daylight
   saving time adjustments.  Subtraction of date or timestamp
   values with the <quote><literal>-</literal></quote> operator
   returns the number of days (24-hours) and hours/minutes/seconds
   between the values, making the same adjustments.  The <function>age</function>
   function returns years, months, days, and hours/minutes/seconds,
   performing field-by-field subtraction and then adjusting for negative
   field values.  The following queries illustrate the differences in these
   approaches.  The sample results were produced with <literal>timezone
   = 'US/Eastern'</literal>; there is a daylight saving time change between the
   two dates used:
-->
日付とタイムスタンプの引き算は複雑になることがあります。
引き算をする概念的に単純な方法は、それぞれの値を秒数に<literal>EXTRACT(EPOCH FROM ...)</literal>で変換してから、結果を引き算する方法です。この結果は2つの値の間の<emphasis>秒</emphasis>数になります。
これは各月の日数、時間帯の変更、夏時間の調整に対して調整されるでしょう。
<quote><literal>-</literal></quote>演算子での日付やタイムスタンプの引き算は値の間の(24時間の)日数と時間/分/秒を、同様に調整して返します。
<function>age</function>関数は年、月、日、時間/分/秒をフィールド毎に引き算し、負のフィールドの値を調整します。
以下の問い合わせは上の各方法の違いを説明する例です。
例の結果は<literal>timezone = 'US/Eastern'</literal>で生成されました。2つの日付の間には夏時間の変更があります。
  </para>

<screen>
SELECT EXTRACT(EPOCH FROM timestamptz '2013-07-01 12:00:00') -
       EXTRACT(EPOCH FROM timestamptz '2013-03-01 12:00:00');
<!--
<lineannotation>Result: </lineannotation><computeroutput>10537200</computeroutput>
-->
<lineannotation>結果: </lineannotation><computeroutput>10537200</computeroutput>
SELECT (EXTRACT(EPOCH FROM timestamptz '2013-07-01 12:00:00') -
        EXTRACT(EPOCH FROM timestamptz '2013-03-01 12:00:00'))
        / 60 / 60 / 24;
<!--
<lineannotation>Result: </lineannotation><computeroutput>121.958333333333</computeroutput>
-->
<lineannotation>結果: </lineannotation><computeroutput>121.958333333333</computeroutput>
SELECT timestamptz '2013-07-01 12:00:00' - timestamptz '2013-03-01 12:00:00';
<!--
<lineannotation>Result: </lineannotation><computeroutput>121 days 23:00:00</computeroutput>
-->
<lineannotation>結果: </lineannotation><computeroutput>121 days 23:00:00</computeroutput>
SELECT age(timestamptz '2013-07-01 12:00:00', timestamptz '2013-03-01 12:00:00');
<!--
<lineannotation>Result: </lineannotation><computeroutput>4 mons</computeroutput>
-->
<lineannotation>結果: </lineannotation><computeroutput>4 mons</computeroutput>
</screen>

  <sect2 id="functions-datetime-extract">
   <title><function>EXTRACT</function>, <function>date_part</function></title>

   <indexterm>
    <primary>date_part</primary>
   </indexterm>
   <indexterm>
    <primary>extract</primary>
   </indexterm>

<synopsis>
EXTRACT(<replaceable>field</replaceable> FROM <replaceable>source</replaceable>)
</synopsis>

   <para>
<!--
    The <function>extract</function> function retrieves subfields
    such as year or hour from date/time values.
    <replaceable>source</replaceable> must be a value expression of
    type <type>timestamp</type>, <type>time</type>, or <type>interval</type>.
    (Expressions of type <type>date</type> are
    cast to <type>timestamp</type> and can therefore be used as
    well.)  <replaceable>field</replaceable> is an identifier or
    string that selects what field to extract from the source value.
    The <function>extract</function> function returns values of type
    <type>double precision</type>.
    The following are valid field names:
-->
<function>extract</function>関数は、日付/時刻の値から年や時などの部分フィールドを抽出します。
<replaceable>source</replaceable>は<type>timestamp</type>型、<type>time</type>型、または<type>interval</type>型の評価式でなければなりません（<type>date</type>型の式は<type>timestamp</type>型にキャストされますので、同様に使用可能です）。
<replaceable>field</replaceable>はsourceの値からどのフィールドを抽出するかを選択する識別子もしくは文字列です。
<function>extract</function>関数は<type>double precision</type>型の値を返します。以下に有効なフィールド名を示します。

    <!-- alphabetical -->
    <variablelist>
     <varlistentry>
      <term><literal>century</literal></term>
      <listitem>
       <para>
<!--
        The century
-->
世紀
       </para>

<screen>
SELECT EXTRACT(CENTURY FROM TIMESTAMP '2000-12-16 12:21:13');
<lineannotation>Result: </lineannotation><computeroutput>20</computeroutput>
SELECT EXTRACT(CENTURY FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>21</computeroutput>
</screen>

       <para>
<!--
        The first century starts at 0001-01-01 00:00:00 AD, although
        they did not know it at the time. This definition applies to all
        Gregorian calendar countries. There is no century number 0,
        you go from -1 century to 1 century.

        If you disagree with this, please write your complaint to:
        Pope, Cathedral Saint-Peter of Roma, Vatican.
-->
当時の人々にはそのような意識はありませんでしたが、最初の世紀は0001-01-01 00:00:00 ADから始まります。
この定義は全てのグレゴリオ暦を使用する国で適用されています。
0という値の世紀はありません。-1世紀の次は1世紀です。

この定義に納得できなければ、苦情をバチカンローマ聖パウロ大聖堂のローマ法王に伝えてください。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>day</literal></term>
      <listitem>
       <para>
<!--
        For <type>timestamp</type> values, the day (of the month) field
        (1 - 31) ; for <type>interval</type> values, the number of days
-->
<type>timestamp</type>値については、(月内の)日付フィールド(1〜31)。<type>interval</type>値については日数。
       </para>

<screen>
SELECT EXTRACT(DAY FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>16</computeroutput>

SELECT EXTRACT(DAY FROM INTERVAL '40 days 1 minute');
<lineannotation>Result: </lineannotation><computeroutput>40</computeroutput>
</screen>



      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>decade</literal></term>
      <listitem>
       <para>
<!--
        The year field divided by 10
-->
年フィールドを10で割ったもの
       </para>

<screen>
SELECT EXTRACT(DECADE FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>200</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>dow</literal></term>
      <listitem>
       <para>
<!--
        The day of the week as Sunday (<literal>0</literal>) to
        Saturday (<literal>6</literal>)
-->
日曜日（<literal>0</literal>）から土曜日（<literal>6</literal>）までの曜日
       </para>

<screen>
SELECT EXTRACT(DOW FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>5</computeroutput>
</screen>
       <para>
<!--
        Note that <function>extract</function>'s day of the week numbering
        differs from that of the <function>to_char(...,
        'D')</function> function.
-->
<function>extract</function>関数の曜日番号は<function>to_char(...,'D')</function>関数のそれとは異なる点に注意してください。
       </para>

      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>doy</literal></term>
      <listitem>
       <para>
<!--
        The day of the year (1 - 365/366)
-->
年内での通算日数（1〜365/366）
       </para>

<screen>
SELECT EXTRACT(DOY FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>47</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>epoch</literal></term>
      <listitem>
       <para>
<!--
        For <type>timestamp with time zone</type> values, the
        number of seconds since 1970-01-01 00:00:00 UTC (can be negative);
        for <type>date</type> and <type>timestamp</type> values, the
        number of seconds since 1970-01-01 00:00:00 local time;
        for <type>interval</type> values, the total number
        of seconds in the interval
-->
<type>timestamp with time zone</type>型の値において、1970-01-01 00:00:00 UTCからの秒数（負の数の場合もあり）。<type>date</type>と<type>timestamp</type>型の値において、ローカルタイムの1970-01-01 00:00:00からの秒数。<type>interval</type>型の値ではその時間間隔における全体の秒数。
       </para>

<screen>
SELECT EXTRACT(EPOCH FROM TIMESTAMP WITH TIME ZONE '2001-02-16 20:38:40.12-08');
<lineannotation>Result: </lineannotation><computeroutput>982384720.12</computeroutput>

SELECT EXTRACT(EPOCH FROM INTERVAL '5 days 3 hours');
<lineannotation>Result: </lineannotation><computeroutput>442800</computeroutput>
</screen>

       <para>
<!--
        You can convert an epoch value back to a time stamp
        with <function>to_timestamp</function>:
-->
<function>to_timestamp</function>で経過秒数をタイムスタンプ値に変換することができます。
       </para>
<screen>
SELECT to_timestamp(982384720.12);
<lineannotation>Result: </lineannotation><computeroutput>2001-02-17 04:38:40.12+00</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>hour</literal></term>
      <listitem>
       <para>
<!--
        The hour field (0 - 23)
-->
時のフィールド（0〜23）
       </para>

<screen>
SELECT EXTRACT(HOUR FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>20</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>isodow</literal></term>
      <listitem>
       <para>
<!--
        The day of the week as Monday (<literal>1</literal>) to
        Sunday (<literal>7</literal>)
-->
月曜日（<literal>1</literal>）から日曜日（<literal>7</literal>）までの曜日
       </para>

<screen>
SELECT EXTRACT(ISODOW FROM TIMESTAMP '2001-02-18 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>7</computeroutput>
</screen>
       <para>
<!--
        This is identical to <literal>dow</literal> except for Sunday.  This
        matches the <acronym>ISO</acronym> 8601 day of the week numbering.
-->
日曜日を除き<literal>dow</literal>と同一です。
これは<acronym>ISO</acronym> 8601曜日番号付けに一致します。
       </para>

      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>isoyear</literal></term>
      <listitem>
       <para>
<!--
        The <acronym>ISO</acronym> 8601 week-numbering year that the date
        falls in (not applicable to intervals)
-->
日付に当てはまる<acronym>ISO</acronym> 8601週番号年（intervalには適用できない）。
       </para>

<screen>
SELECT EXTRACT(ISOYEAR FROM DATE '2006-01-01');
<lineannotation>Result: </lineannotation><computeroutput>2005</computeroutput>
SELECT EXTRACT(ISOYEAR FROM DATE '2006-01-02');
<lineannotation>Result: </lineannotation><computeroutput>2006</computeroutput>
</screen>

       <para>
<!--
        Each <acronym>ISO</acronym> 8601 week-numbering year begins with the
        Monday of the week containing the 4th of January, so in early
        January or late December the <acronym>ISO</acronym> year may be
        different from the Gregorian year.  See the <literal>week</literal>
        field for more information.
-->
すべての<acronym>ISO</acronym> 8601週番号年は1月4日を含む週の月曜日から開始されます。従って、1月上旬、または12月下旬で<acronym>ISO</acronym>年がグレゴリオ年と異なる可能性があります。
より詳細は<literal>week</literal>フィールドを参照してください。
       </para>
       <para>
<!--
        This field is not available in PostgreSQL releases prior to 8.3.
-->
このフィールドは8.3より前のPostgreSQLリリースでは有効でありません。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>microseconds</literal></term>
      <listitem>
       <para>
<!--
        The seconds field, including fractional parts, multiplied by 1
        000 000;  note that this includes full seconds
-->
端数部分も含む秒フィールドに、1,000,000を乗じた値。秒の整数部を含むことに注意。
       </para>

<screen>
SELECT EXTRACT(MICROSECONDS FROM TIME '17:12:28.5');
<lineannotation>Result: </lineannotation><computeroutput>28500000</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>millennium</literal></term>
      <listitem>
       <para>
<!--
        The millennium
-->
ミレニアム（千年期）
       </para>

<screen>
SELECT EXTRACT(MILLENNIUM FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>3</computeroutput>
</screen>

       <para>
<!--
        Years in the 1900s are in the second millennium.
        The third millennium started January 1, 2001.
-->
1900年代の年は第2ミレニアムです。第3ミレニアムは2001年1月1日から始まりました。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>milliseconds</literal></term>
      <listitem>
       <para>
<!--
        The seconds field, including fractional parts, multiplied by
        1000.  Note that this includes full seconds.
-->
端数部分も含む秒フィールドに、1000を乗た値。秒の整数部を含むことに注意してください。
       </para>

<screen>
SELECT EXTRACT(MILLISECONDS FROM TIME '17:12:28.5');
<lineannotation>Result: </lineannotation><computeroutput>28500</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>minute</literal></term>
      <listitem>
       <para>
<!--
        The minutes field (0 - 59)
-->
分フィールド（0〜59）
       </para>

<screen>
SELECT EXTRACT(MINUTE FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>38</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>month</literal></term>
      <listitem>
       <para>
<!--
        For <type>timestamp</type> values, the number of the month
        within the year (1 - 12) ; for <type>interval</type> values,
        the number of months, modulo 12 (0 - 11)
-->
<type>timestamp</type>型の値に対しては年内の月番号（1〜12）。<type>interval</type>型の値に対しては月数を12で割った余り（0〜11）。
       </para>

<screen>
SELECT EXTRACT(MONTH FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>2</computeroutput>

SELECT EXTRACT(MONTH FROM INTERVAL '2 years 3 months');
<lineannotation>Result: </lineannotation><computeroutput>3</computeroutput>

SELECT EXTRACT(MONTH FROM INTERVAL '2 years 13 months');
<lineannotation>Result: </lineannotation><computeroutput>1</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>quarter</literal></term>
      <listitem>
       <para>
<!--
        The quarter of the year (1 - 4) that the date is in
-->
その日付が含まれる年の四半期（1〜4）。
       </para>

<screen>
SELECT EXTRACT(QUARTER FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>1</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>second</literal></term>
      <listitem>
       <para>
<!--
        The seconds field, including fractional parts (0 -
        59<footnote><simpara>60 if leap seconds are
        implemented by the operating system</simpara></footnote>)
-->
端数を含んだ秒フィールド（0〜59<footnote><simpara>オペレーティングシステムでうるう秒が実装されている場合は60まで。</simpara></footnote>）。
       </para>

<screen>
SELECT EXTRACT(SECOND FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>40</computeroutput>

SELECT EXTRACT(SECOND FROM TIME '17:12:28.5');
<lineannotation>Result: </lineannotation><computeroutput>28.5</computeroutput>
</screen>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>timezone</literal></term>
      <listitem>
       <para>
<!--
        The time zone offset from UTC, measured in seconds.  Positive values
        correspond to time zones east of UTC, negative values to
        zones west of UTC.  (Technically,
        <productname>PostgreSQL</productname> does not use UTC because
        leap seconds are not handled.)
-->
秒単位のUTCからの時間帯オフセット。正の値はUTCより東の時間帯に対応し、負の値はUTCより西の時間帯に対応。
(技術的に言えば、<productname>PostgreSQL</productname>はうるう秒を制御しないためUTCを使用していない。)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>timezone_hour</literal></term>
      <listitem>
       <para>
<!--
        The hour component of the time zone offset
-->
時間帯オフセットの時の成分。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>timezone_minute</literal></term>
      <listitem>
       <para>
<!--
        The minute component of the time zone offset
-->
時間帯オフセットの分の成分。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>week</literal></term>
      <listitem>
       <para>
<!--
        The number of the <acronym>ISO</acronym> 8601 week-numbering week of
        the year.  By definition, ISO weeks start on Mondays and the first
        week of a year contains January 4 of that year.  In other words, the
        first Thursday of a year is in week 1 of that year.
-->
<acronym>ISO</acronym> 8601週番号。
定義ではISO週は月曜日から始まり、その年の1月4日を含む週をその年の第1週としています。
つまり、年の最初の木曜日がある週がその年の第1週となります。
       </para>
       <para>
<!--
        In the ISO week-numbering system, it is possible for early-January
        dates to be part of the 52nd or 53rd week of the previous year, and for
        late-December dates to be part of the first week of the next year.
        For example, <literal>2005-01-01</literal> is part of the 53rd week of year
        2004, and <literal>2006-01-01</literal> is part of the 52nd week of year
        2005, while <literal>2012-12-31</literal> is part of the first week of 2013.
        It's recommended to use the <literal>isoyear</literal> field together with
        <literal>week</literal> to get consistent results.
-->
ISO週番号システムでは、1月の早い日にちは前年の第52週もしくは第53週となることがあり、12月の遅い日にちには次年の最初の週の一部となることがあります。
例えば、<literal>2005-01-01</literal>は2004年の第53週であり、<literal>2006-01-01</literal>は2005年の第52週の一部です、一方<literal>2012-12-31</literal>は2013年の第1週の一部となります。
整合性のある結果を得るため、<literal>isoyear</literal>フィールドと<literal>week</literal>を併用することを推奨します。
       </para>

<screen>
SELECT EXTRACT(WEEK FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>7</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>year</literal></term>
      <listitem>
       <para>
<!--
        The year field.  Keep in mind there is no <literal>0 AD</literal>, so subtracting
        <literal>BC</literal> years from <literal>AD</literal> years should be done with care.
-->
年フィールド。<literal>AD零年</literal>が存在しないことは忘れないでください。このため<literal>AD</literal>の年から<literal>BC</literal>の年を減ずる時には注意が必要です。
       </para>

<screen>
SELECT EXTRACT(YEAR FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>2001</computeroutput>
</screen>
      </listitem>
     </varlistentry>

    </variablelist>
   </para>

   <note>
    <para>
<!--
     When the input value is +/-Infinity, <function>extract</function> returns
     +/-Infinity for monotonically-increasing fields (<literal>epoch</literal>,
     <literal>julian</literal>, <literal>year</literal>, <literal>isoyear</literal>,
     <literal>decade</literal>, <literal>century</literal>, and <literal>millennium</literal>).
     For other fields, NULL is returned.  <productname>PostgreSQL</productname>
     versions before 9.6 returned zero for all cases of infinite input.
-->
入力値が+/-無限大の場合、<function>extract</function>は単調増加するフィールド（<literal>epoch</literal>、<literal>julian</literal>、<literal>year</literal>、<literal>isoyear</literal>、<literal>decade</literal>、<literal>century</literal>、<literal>millennium</literal>）に対し、+/-無限大を返します。
その他のフィールドに対してはNULLが返されます。
<productname>PostgreSQL</productname>の9.6より前のバージョンでは、入力が無限大のすべての場合に対してゼロを返していました。
    </para>
   </note>

   <para>
<!--
    The <function>extract</function> function is primarily intended
    for computational processing.  For formatting date/time values for
    display, see <xref linkend="functions-formatting"/>.
-->
<function>extract</function>関数は主に演算処理を意図しています。
日付/時刻の値を表示する目的での書式については<xref linkend="functions-formatting"/>を参照してください。
   </para>

   <para>
<!--
    The <function>date_part</function> function is modeled on the traditional
    <productname>Ingres</productname> equivalent to the
    <acronym>SQL</acronym>-standard function <function>extract</function>:
-->
<function>date_part</function>関数は伝統的な<productname>Ingres</productname>上で設計されたもので、標準<acronym>SQL</acronym>の<function>extract</function>関数と等価です。
<synopsis>
date_part('<replaceable>field</replaceable>', <replaceable>source</replaceable>)
</synopsis>
<!--
    Note that here the <replaceable>field</replaceable> parameter needs to
    be a string value, not a name.  The valid field names for
    <function>date_part</function> are the same as for
    <function>extract</function>.
-->
ここで<replaceable>field</replaceable>パラメータが名前ではなく文字列値である必要があることに注意してください。
<function>date_part</function>で有効なフィールド名は<function>extract</function>と同じです。
   </para>

<screen>
SELECT date_part('day', TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>16</computeroutput>

SELECT date_part('hour', INTERVAL '4 hours 3 minutes');
<lineannotation>Result: </lineannotation><computeroutput>4</computeroutput>
</screen>

  </sect2>

  <sect2 id="functions-datetime-trunc">
   <title><function>date_trunc</function></title>

   <indexterm>
    <primary>date_trunc</primary>
   </indexterm>

   <para>
<!--
    The function <function>date_trunc</function> is conceptually
    similar to the <function>trunc</function> function for numbers.
-->
<function>date_trunc</function>関数は概念的に数値に対する<function>trunc</function>関数と類似しています。
   </para>

   <para>
<synopsis>
date_trunc(<replaceable>field</replaceable>, <replaceable>source</replaceable> [, <replaceable>time_zone</replaceable> ])
</synopsis>
<!--
    <replaceable>source</replaceable> is a value expression of type
    <type>timestamp</type>, <type>timestamp with time zone</type>,
    or <type>interval</type>.
    (Values of type <type>date</type> and
    <type>time</type> are cast automatically to <type>timestamp</type> or
    <type>interval</type>, respectively.)
    <replaceable>field</replaceable> selects to which precision to
    truncate the input value.  The return value is likewise of type
    <type>timestamp</type>, <type>timestamp with time zone</type>,
    or <type>interval</type>,
    and it has all fields that are less significant than the
    selected one set to zero (or one, for day and month).
-->
<replaceable>source</replaceable>は、データ型<type>timestamp</type>もしくは<type>interval</type>の評価式です
（<type>date</type>型と<type>time</type>型の値はそれぞれ自動的に<type>timestamp</type>もしくは<type>interval</type>にキャストされます。）
<replaceable>field</replaceable>は、入力値の値をどの精度で切り捨てるかを選択します。
戻り値は<type>timestamp</type>もしくは<type>interval</type>型で、指定した精度より下のすべてのフィールドがゼロに設定（日と月については1に設定）されます。
   </para>

   <para>
<!--
    Valid values for <replaceable>field</replaceable> are:
-->
<replaceable>field</replaceable>の有効値には次のものがあります。
    <simplelist>
     <member><literal>microseconds</literal></member>
     <member><literal>milliseconds</literal></member>
     <member><literal>second</literal></member>
     <member><literal>minute</literal></member>
     <member><literal>hour</literal></member>
     <member><literal>day</literal></member>
     <member><literal>week</literal></member>
     <member><literal>month</literal></member>
     <member><literal>quarter</literal></member>
     <member><literal>year</literal></member>
     <member><literal>decade</literal></member>
     <member><literal>century</literal></member>
     <member><literal>millennium</literal></member>
    </simplelist>
   </para>

   <para>
    When the input value is of type <type>timestamp with time zone</type>,
    the truncation is performed with respect to a particular time zone;
    for example, truncation to <literal>day</literal> produces a value that
    is midnight in that zone.  By default, truncation is done with respect
    to the current <xref linkend="guc-timezone"/> setting, but the
    optional <replaceable>time_zone</replaceable> argument can be provided
    to specify a different time zone.  The time zone name can be specified
    in any of the ways described in <xref linkend="datatype-timezones"/>.
   </para>

   <para>
    A time zone cannot be specified when processing <type>timestamp without
    time zone</type> or <type>interval</type> inputs.  These are always
    taken at face value.
   </para>

   <para>
<!--
    Examples (assuming the local time zone is <literal>America/New_York</literal>):
-->
例：
<screen>
SELECT date_trunc('hour', TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>2001-02-16 20:00:00</computeroutput>

SELECT date_trunc('year', TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>2001-01-01 00:00:00</computeroutput>

SELECT date_trunc('day', TIMESTAMP WITH TIME ZONE '2001-02-16 20:38:40+00');
<lineannotation>Result: </lineannotation><computeroutput>2001-02-16 00:00:00-05</computeroutput>

SELECT date_trunc('day', TIMESTAMP WITH TIME ZONE '2001-02-16 20:38:40+00', 'Australia/Sydney');
<lineannotation>Result: </lineannotation><computeroutput>2001-02-16 08:00:00-05</computeroutput>

SELECT date_trunc('hour', INTERVAL '3 days 02:47:33');
<lineannotation>Result: </lineannotation><computeroutput>3 days 02:00:00</computeroutput>
</screen>
   </para>
  </sect2>

  <sect2 id="functions-datetime-zoneconvert">
   <title><literal>AT TIME ZONE</literal></title>

   <indexterm>
<!--
    <primary>time zone</primary>
    <secondary>conversion</secondary>
-->
    <primary>時間帯</primary>
    <secondary>変換</secondary>
   </indexterm>

   <indexterm>
    <primary>AT TIME ZONE</primary>
   </indexterm>

   <para>
<!--
    The <literal>AT TIME ZONE</literal> converts time
    stamp <emphasis>without time zone</emphasis> to/from
    time stamp <emphasis>with time zone</emphasis>, and
    <emphasis>time</emphasis> values to different time zones. <xref
    linkend="functions-datetime-zoneconvert-table"/> shows its variants.
-->
<function>AT TIME ZONE</function>構文を使用することにより、time stamp <emphasis>without time zone</emphasis>からtime stamp <emphasis>with time zone</emphasis>へ、あるいはtime stamp <emphasis>with time zone</emphasis>からtime stamp <emphasis>without time zone</emphasis>へ変換でき、また<emphasis>時刻</emphasis>値を異なる時間帯に変換することができます。
<xref linkend="functions-datetime-zoneconvert-table"/>にその種類を示します。
   </para>

    <table id="functions-datetime-zoneconvert-table">
<!--
     <title><literal>AT TIME ZONE</literal> Variants</title>
-->
     <title><literal>AT TIME ZONE</literal>の種類</title>
     <tgroup cols="3">
      <thead>
       <row>
<!--
        <entry>Expression</entry>
        <entry>Return Type</entry>
        <entry>Description</entry>
-->
        <entry>式</entry>
        <entry>戻り値</entry>
        <entry>説明</entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry>
         <literal><type>timestamp without time zone</type> AT TIME ZONE <replaceable>zone</replaceable></literal>
        </entry>
        <entry><type>timestamp with time zone</type></entry>
<!--
        <entry>Treat given time stamp <emphasis>without time zone</emphasis> as located in the specified time zone</entry>
-->
        <entry>与えられた<emphasis>時間帯なし</emphasis>タイムスタンプを指定された時間帯にあるとして取り扱います。</entry>
       </row>

       <row>
        <entry>
         <literal><type>timestamp with time zone</type> AT TIME ZONE <replaceable>zone</replaceable></literal>
        </entry>
        <entry><type>timestamp without time zone</type></entry>
<!--
        <entry>Convert given time stamp <emphasis>with time zone</emphasis> to the new time
        zone, with no time zone designation</entry>
-->
        <entry>与えられた<emphasis>時間帯付き</emphasis>タイムスタンプを新規の時間帯に、時間帯の指定なく変換します。</entry>
       </row>

       <row>
        <entry>
         <literal><type>time with time zone</type> AT TIME ZONE <replaceable>zone</replaceable></literal>
        </entry>
        <entry><type>time with time zone</type></entry>
<!--
        <entry>Convert given time <emphasis>with time zone</emphasis> to the new time zone</entry>
-->
        <entry>与えられた時刻<emphasis>with time zone</emphasis>を新しい時間帯に変換します。</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
<!--
    In these expressions, the desired time zone <replaceable>zone</replaceable> can be
    specified either as a text string (e.g., <literal>'America/Los_Angeles'</literal>)
    or as an interval (e.g., <literal>INTERVAL '-08:00'</literal>).
    In the text case, a time zone name can be specified in any of the ways
    described in <xref linkend="datatype-timezones"/>.
-->
これらの式では、設定する時間帯<replaceable>zone</replaceable>は、（<literal>'America/Los_Angeles'</literal>のような）テキスト文字列、または（<literal>INTERVAL '-08:00'</literal>のような）時間間隔で指定することができます。
テキストの場合、<xref linkend="datatype-timezones"/>に示した方法で時間帯名称を指定することができます。
   </para>

   <para>
<!--
    Examples (assuming the local time zone is <literal>America/Los_Angeles</literal>):
-->
以下に例を示します（ローカル時間帯を<literal>America/Los_Angeles</literal>と想定しています）。
<screen>
SELECT TIMESTAMP '2001-02-16 20:38:40' AT TIME ZONE 'America/Denver';
<lineannotation>Result: </lineannotation><computeroutput>2001-02-16 19:38:40-08</computeroutput>

SELECT TIMESTAMP WITH TIME ZONE '2001-02-16 20:38:40-05' AT TIME ZONE 'America/Denver';
<lineannotation>Result: </lineannotation><computeroutput>2001-02-16 18:38:40</computeroutput>

SELECT TIMESTAMP '2001-02-16 20:38:40-05' AT TIME ZONE 'Asia/Tokyo' AT TIME ZONE 'America/Chicago';
<lineannotation>Result: </lineannotation><computeroutput>2001-02-16 05:38:40</computeroutput>
</screen>
<!--
    The first example adds a time zone to a value that lacks it, and
    displays the value using the current <varname>TimeZone</varname>
    setting.  The second example shifts the time stamp with time zone value
    to the specified time zone, and returns the value without a time zone.
    This allows storage and display of values different from the current
    <varname>TimeZone</varname> setting.  The third example converts
    Tokyo time to Chicago time.   Converting <emphasis>time</emphasis>
    values to other time zones uses the currently active time zone rules
    since no date is supplied.
-->
最初の例は、時間帯のない値に時間帯を追加し、現在の<varname>TimeZone</varname>設定を使ってその値を表示します。
2番目の例は、time stamp with time zone値を指定したタイムゾーンに変換し、その値をwithout a time zoneで返しています。
これは、<varname>TimeZone</varname>設定とは異なる値の格納と表示を可能にします。
3番目の例は、東京時間をシカゴ時間に変換します。
データが与えられていないので、現在有効なタイムゾーンルールを使って、<emphasis>時刻</emphasis>値を変換しています。
   </para>

   <para>
<!--
    The function <literal><function>timezone</function>(<replaceable>zone</replaceable>,
    <replaceable>timestamp</replaceable>)</literal> is equivalent to the SQL-conforming construct
    <literal><replaceable>timestamp</replaceable> AT TIME ZONE
    <replaceable>zone</replaceable></literal>.
-->
関数<function>timezone</function>(<replaceable>zone</replaceable>, <replaceable>timestamp</replaceable>)は、SQL準拠の構文<literal><replaceable>timestamp</replaceable> AT TIME ZONE <replaceable>zone</replaceable></literal>と等価です。
   </para>
  </sect2>

  <sect2 id="functions-datetime-current">
<!--
   <title>Current Date/Time</title>
-->
   <title>現在の日付/時刻</title>

   <indexterm>
<!--
    <primary>date</primary>
    <secondary>current</secondary>
-->
    <primary>日付</primary>
    <secondary>現在</secondary>
   </indexterm>

   <indexterm>
<!--
    <primary>time</primary>
    <secondary>current</secondary>
-->
    <primary>時刻</primary>
    <secondary>現在</secondary>
   </indexterm>

   <para>
<!--
    <productname>PostgreSQL</productname> provides a number of functions
    that return values related to the current date and time.  These
    SQL-standard functions all return values based on the start time of
    the current transaction:
-->
<productname>PostgreSQL</productname>は、現在の日付時刻に関した値を返す多くの関数を提供します。
これらの標準SQL関数はすべて、現在のトランザクションの開始時刻に基づいた値を返します。
<synopsis>
CURRENT_DATE
CURRENT_TIME
CURRENT_TIMESTAMP
CURRENT_TIME(<replaceable>precision</replaceable>)
CURRENT_TIMESTAMP(<replaceable>precision</replaceable>)
LOCALTIME
LOCALTIMESTAMP
LOCALTIME(<replaceable>precision</replaceable>)
LOCALTIMESTAMP(<replaceable>precision</replaceable>)
</synopsis>
    </para>

    <para>
<!--
     <function>CURRENT_TIME</function> and
     <function>CURRENT_TIMESTAMP</function> deliver values with time zone;
     <function>LOCALTIME</function> and
     <function>LOCALTIMESTAMP</function> deliver values without time zone.
-->
<function>CURRENT_TIME</function>および<function>CURRENT_TIMESTAMP</function>関数では、時間帯を伴う値を扱います。一方、<function>LOCALTIME</function>および<function>LOCALTIMESTAMP</function>関数では、時間帯を伴わない値を扱います。
    </para>

    <para>
<!--
     <function>CURRENT_TIME</function>,
     <function>CURRENT_TIMESTAMP</function>,
     <function>LOCALTIME</function>, and
     <function>LOCALTIMESTAMP</function>
     can optionally take
     a precision parameter, which causes the result to be rounded
     to that many fractional digits in the seconds field.  Without a precision parameter,
     the result is given to the full available precision.
-->
<function>CURRENT_TIME</function>、<function>CURRENT_TIMESTAMP</function>、<function>LOCALTIME</function>、および<function>LOCALTIMESTAMP</function>関数では、精度のパラメータをオプションで取ることができ、それに合わせて秒フィールドの端数桁を丸める結果をもたらします。
精度のパラメータがない場合、結果は使用可能な最大精度で出力されます。
    </para>

   <para>
<!--
    Some examples:
-->
例：
<screen>
SELECT CURRENT_TIME;
<lineannotation>Result: </lineannotation><computeroutput>14:39:53.662522-05</computeroutput>

SELECT CURRENT_DATE;
<lineannotation>Result: </lineannotation><computeroutput>2001-12-23</computeroutput>

SELECT CURRENT_TIMESTAMP;
<lineannotation>Result: </lineannotation><computeroutput>2001-12-23 14:39:53.662522-05</computeroutput>

SELECT CURRENT_TIMESTAMP(2);
<lineannotation>Result: </lineannotation><computeroutput>2001-12-23 14:39:53.66-05</computeroutput>

SELECT LOCALTIMESTAMP;
<lineannotation>Result: </lineannotation><computeroutput>2001-12-23 14:39:53.662522</computeroutput>
</screen>
   </para>

   <para>
<!--
    Since these functions return
    the start time of the current transaction, their values do not
    change during the transaction. This is considered a feature:
    the intent is to allow a single transaction to have a consistent
    notion of the <quote>current</quote> time, so that multiple
    modifications within the same transaction bear the same
    time stamp.
-->
これらの関数は現在のトランザクションの開始時刻を返すため、その値はトランザクションが実行されている間は変化しません。
これは仕様であると考えられており、その意図は、単一のトランザクションが一貫性のある<quote>現在</quote>時刻の概念を持ち、同一トランザクション内の複数の変更が同一のタイムスタンプを持つようにすることにあります。
   </para>

   <note>
    <para>
<!--
     Other database systems might advance these values more
     frequently.
-->
他のデータベースシステムでは、これらの値をより頻繁に増加させることがあります。
    </para>
   </note>

   <para>
<!--
    <productname>PostgreSQL</productname> also provides functions that
    return the start time of the current statement, as well as the actual
    current time at the instant the function is called.  The complete list
    of non-SQL-standard time functions is:
-->
<productname>PostgreSQL</productname>はまた、関数を呼び出した時の実際の現在時刻や現在の文の開始時刻を返す関数も提供します。
非標準SQLの時間関数の全一覧を以下に示します。
<synopsis>
transaction_timestamp()
statement_timestamp()
clock_timestamp()
timeofday()
now()
</synopsis>
   </para>

   <para>
<!--
    <function>transaction_timestamp()</function> is equivalent to
    <function>CURRENT_TIMESTAMP</function>, but is named to clearly reflect
    what it returns.
    <function>statement_timestamp()</function> returns the start time of the current
    statement (more specifically, the time of receipt of the latest command
    message from the client).
    <function>statement_timestamp()</function> and <function>transaction_timestamp()</function>
    return the same value during the first command of a transaction, but might
    differ during subsequent commands.
    <function>clock_timestamp()</function> returns the actual current time, and
    therefore its value changes even within a single SQL command.
    <function>timeofday()</function> is a historical
    <productname>PostgreSQL</productname> function.  Like
    <function>clock_timestamp()</function>, it returns the actual current time,
    but as a formatted <type>text</type> string rather than a <type>timestamp
    with time zone</type> value.
    <function>now()</function> is a traditional <productname>PostgreSQL</productname>
    equivalent to <function>transaction_timestamp()</function>.
-->
<function>transaction_timestamp()</function>は<function>CURRENT_TIMESTAMP</function>と等価ですが、明確に何を返すかを反映する名前になっています。
<function>statement_timestamp()</function>は現在の文の実行開始時刻を返すものです（より具体的にいうと、直前のコマンドメッセージをクライアントから受け取った時刻です）。
<function>statement_timestamp()</function>および<function>transaction_timestamp()</function>はトランザクションの最初のコマンドでは同じ値を返しますが、その後に引き続くコマンドでは異なる可能性があります。
<function>clock_timestamp()</function>は実際の現在時刻を返しますので、その値は単一のSQLコマンドであっても異なります。
<function>timeofday()</function>は<productname>PostgreSQL</productname>の歴史的な関数です。
<function>clock_timestamp()</function>同様、実際の現在時刻を返しますが、<type>timestamp with time zone</type>型の値ではなく、整形された<type>text</type>文字列を返します。<function>now()</function>は<function>transaction_timestamp()</function>と同じもので、伝統的な<productname>PostgreSQL</productname>関数です。
   </para>

   <para>
<!--
    All the date/time data types also accept the special literal value
    <literal>now</literal> to specify the current date and time (again,
    interpreted as the transaction start time).  Thus,
    the following three all return the same result:
-->
すべての日付/時刻型はまた、特殊なリテラル値 <literal>now</literal>を受け付け、これは現在の日付と時刻（ここでも、トランザクションの開始時刻として解釈されます）を表します。
したがって、下記の３つの実行結果は全て同じものとなります。
<programlisting>
SELECT CURRENT_TIMESTAMP;
SELECT now();
<!--
SELECT TIMESTAMP 'now';  &#045;- incorrect for use with DEFAULT
-->
SELECT TIMESTAMP 'now';  -- DEFAULTで使用するのは正しくない
</programlisting>
   </para>

    <tip>
     <para>
<!--
      You do not want to use the third form when specifying a <literal>DEFAULT</literal>
      clause while creating a table.  The system will convert <literal>now</literal>
      to a <type>timestamp</type> as soon as the constant is parsed, so that when
      the default value is needed,
      the time of the table creation would be used!  The first two
      forms will not be evaluated until the default value is used,
      because they are function calls.  Thus they will give the desired
      behavior of defaulting to the time of row insertion.
-->
テーブルを作成する時、<literal>DEFAULT</literal>句を指定するのに3番目の形式を使おうとは思わないでしょう。
システムは<literal>now</literal>という定数を解析すると、すぐにそれを<type>timestamp</type>に変換するので、デフォルト値が必要が時には、テーブルが作成された時刻が使われます。最初の2つの形式は関数呼び出しなので、デフォルト値が使用されるまで評価されません。ですから、これらの関数は列の挿入時間をデフォルトとする、望ましい振舞いをします。
     </para>
    </tip>
  </sect2>

  <sect2 id="functions-datetime-delay">
<!--
   <title>Delaying Execution</title>
-->
   <title>遅延実行</title>

   <indexterm>
    <primary>pg_sleep</primary>
   </indexterm>
   <indexterm>
    <primary>pg_sleep_for</primary>
   </indexterm>
   <indexterm>
    <primary>pg_sleep_until</primary>
   </indexterm>
   <indexterm>
<!--
    <primary>sleep</primary>
-->
    <primary>休止</primary>
   </indexterm>
   <indexterm>
<!--
    <primary>delay</primary>
-->
    <primary>遅延</primary>
   </indexterm>

   <para>
<!--
    The following functions are available to delay execution of the server
    process:
-->
以下の関数は、サーバプロセスの実行を遅延させるために使用可能です。
<synopsis>
pg_sleep(<replaceable>seconds</replaceable>)
pg_sleep_for(<type>interval</type>)
pg_sleep_until(<type>timestamp with time zone</type>)
</synopsis>

<!--
    <function>pg_sleep</function> makes the current session's process
    sleep until <replaceable>seconds</replaceable> seconds have
    elapsed.  <replaceable>seconds</replaceable> is a value of type
    <type>double precision</type>, so fractional-second delays can be specified.
    <function>pg_sleep_for</function> is a convenience function for larger
    sleep times specified as an <type>interval</type>.
    <function>pg_sleep_until</function> is a convenience function for when
    a specific wake-up time is desired.
    For example:
-->
<function>pg_sleep</function>は、<replaceable>seconds</replaceable>秒経過するまで、現在のセッションのプロセスを休止させます。
<replaceable>seconds</replaceable>は<type>double precision</type>型の値です。そのため、小数単位で休止秒数を指定することができます。
<function>pg_sleep_for</function>は<type>interval</type>でより長い休止時間を指定する便利な関数です。
<function>pg_sleep_until</function>は特定の起床時刻が望まれる場合に便利な関数です。
以下に例を示します。

<programlisting>
SELECT pg_sleep(1.5);
SELECT pg_sleep_for('5 minutes');
SELECT pg_sleep_until('tomorrow 03:00');
</programlisting>
   </para>

   <note>
     <para>
<!--
      The effective resolution of the sleep interval is platform-specific;
      0.01 seconds is a common value.  The sleep delay will be at least as long
      as specified. It might be longer depending on factors such as server load.
      In particular, <function>pg_sleep_until</function> is not guaranteed to
      wake up exactly at the specified time, but it will not wake up any earlier.
-->
休止時間の有効な分解能はプラットフォームに依存します。0.01秒が一般的な値です。
休止による遅延は最短で指定した時間と同じになります。
サーバの負荷などが要因となり、より長くなる可能性があります。
特に、<function>pg_sleep_until</function>は指定した時刻ちょうどに起床する保証はありませんが、それより早く起床することはありません。
     </para>
   </note>

   <warning>
     <para>
<!--
      Make sure that your session does not hold more locks than necessary
      when calling <function>pg_sleep</function> or its variants.  Otherwise
      other sessions might have to wait for your sleeping process, slowing down
      the entire system.
-->
<function>pg_sleep</function>またはその亜種を呼び出す時、セッションが必要以上のロックを保持していないことを確実にしてください。
さもないと、他のセッションが休止中のプロセスを待機しなければならないかもしれません。そのためシステム全体の速度が低下することになるかもしれません。
     </para>
   </warning>
  </sect2>

 </sect1>


 <sect1 id="functions-enum">
<!--
  <title>Enum Support Functions</title>
-->
  <title>列挙型サポート関数</title>

  <para>
<!--
   For enum types (described in <xref linkend="datatype-enum"/>),
   there are several functions that allow cleaner programming without
   hard-coding particular values of an enum type.
   These are listed in <xref linkend="functions-enum-table"/>. The examples
   assume an enum type created as:
-->
列挙型（<xref linkend="datatype-enum"/>で解説）に対し、特に列挙型の値をハードコーディングせず簡潔なプログラミングを可能にするいくつかの関数があります。
それらの関数は<xref linkend="functions-enum-table"/>で一覧されています。
例は以下のようにして列挙型が作成されていることを想定しています。

<programlisting>
CREATE TYPE rainbow AS ENUM ('red', 'orange', 'yellow', 'green', 'blue', 'purple');
</programlisting>

  </para>

  <table id="functions-enum-table">
<!--
    <title>Enum Support Functions</title>
-->
    <title>列挙型サポート関数</title>
    <tgroup cols="4">
     <thead>
      <row>
<!--
       <entry>Function</entry>
       <entry>Description</entry>
       <entry>Example</entry>
       <entry>Example Result</entry>
-->
       <entry>関数</entry>
       <entry>説明</entry>
       <entry>例</entry>
       <entry>例の結果</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>
         <indexterm>
          <primary>enum_first</primary>
         </indexterm>
         <literal>enum_first(anyenum)</literal>
       </entry>
<!--
       <entry>Returns the first value of the input enum type</entry>
-->
       <entry>入力列挙型の最初の値を返す</entry>
       <entry><literal>enum_first(null::rainbow)</literal></entry>
       <entry><literal>red</literal></entry>
      </row>
      <row>
       <entry>
         <indexterm>
          <primary>enum_last</primary>
         </indexterm>
         <literal>enum_last(anyenum)</literal>
       </entry>
<!--
       <entry>Returns the last value of the input enum type</entry>
-->
       <entry>入力列挙型の最後の値を返す</entry>
       <entry><literal>enum_last(null::rainbow)</literal></entry>
       <entry><literal>purple</literal></entry>
      </row>
      <row>
       <entry>
         <indexterm>
          <primary>enum_range</primary>
         </indexterm>
         <literal>enum_range(anyenum)</literal>
       </entry>
<!--
       <entry>Returns all values of the input enum type in an ordered array</entry>
-->
       <entry>入力列挙型の全ての値を順序配列として返す</entry>
       <entry><literal>enum_range(null::rainbow)</literal></entry>
       <entry><literal>{red,orange,yellow,green,blue,purple}</literal></entry>
      </row>
      <row>
       <entry morerows="2"><literal>enum_range(anyenum, anyenum)</literal></entry>
       <entry morerows="2">
<!--
        Returns the range between the two given enum values, as an ordered
        array. The values must be from the same enum type. If the first
        parameter is null, the result will start with the first value of
        the enum type.
        If the second parameter is null, the result will end with the last
        value of the enum type.
-->
与えられた２つの列挙型値の範囲を、順序配列として返す。
値は同一の列挙型に拠らなければならない。
１番目のパラメータがNULLの場合、結果は列挙型の最初の値から始まる。
２番目のパラメータがNULLの場合、結果は列挙型の最後の値で終わる。
       </entry>
       <entry><literal>enum_range('orange'::rainbow, 'green'::rainbow)</literal></entry>
       <entry><literal>{orange,yellow,green}</literal></entry>
      </row>
      <row>
       <entry><literal>enum_range(NULL, 'green'::rainbow)</literal></entry>
       <entry><literal>{red,orange,yellow,green}</literal></entry>
      </row>
      <row>
       <entry><literal>enum_range('orange'::rainbow, NULL)</literal></entry>
       <entry><literal>{orange,yellow,green,blue,purple}</literal></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
<!--
    Notice that except for the two-argument form of <function>enum_range</function>,
    these functions disregard the specific value passed to them; they care
    only about its declared data type.  Either null or a specific value of
    the type can be passed, with the same result.  It is more common to
    apply these functions to a table column or function argument than to
    a hardwired type name as suggested by the examples.
-->
<function>enum_range</function>の２引数の形式を除き、これらの関数は、渡された特定の値を無視することに注意してください。関数は宣言されたデータ型のみ配慮します。
その型のNULLまたは特定の値を渡すことができ、同一の結果が得られます。
例で示したような直書きした型名に対してではなく、テーブル列もしくは関数引数にこれらの関数を適用することがより一般的です。
   </para>
 </sect1>

 <sect1 id="functions-geometry">
<!--
  <title>Geometric Functions and Operators</title>
-->
  <title>幾何関数と演算子</title>

   <para>
<!--
    The geometric types <type>point</type>, <type>box</type>,
    <type>lseg</type>, <type>line</type>, <type>path</type>,
    <type>polygon</type>, and <type>circle</type> have a large set of
    native support functions and operators, shown in <xref
    linkend="functions-geometry-op-table"/>, <xref
    linkend="functions-geometry-func-table"/>, and <xref
    linkend="functions-geometry-conv-table"/>.
-->
<type>point</type>、<type>box</type>、<type>lseg</type>、<type>line</type>、<type>path</type>、<type>polygon</type>、および<type>circle</type>幾何データ型には、PostgreSQLが元々サポートしている関数と演算子が豊富に揃っています（<xref linkend="functions-geometry-op-table"/>、<xref linkend="functions-geometry-func-table"/>、および<xref linkend="functions-geometry-conv-table"/>を参照してください）。
   </para>

   <caution>
    <para>
<!--
     Note that the <quote>same as</quote> operator, <literal>~=</literal>, represents
     the usual notion of equality for the <type>point</type>,
     <type>box</type>, <type>polygon</type>, and <type>circle</type> types.
     Some of these types also have an <literal>=</literal> operator, but
     <literal>=</literal> compares
     for equal <emphasis>areas</emphasis> only.  The other scalar comparison operators
     (<literal>&lt;=</literal> and so on) likewise compare areas for these types.
-->
<quote>同じを示す</quote><literal>~=</literal>演算子は<type>point</type>、<type>box</type>、<type>polygon</type>、および<type>circle</type>型に対し通常の等価概念を示すことに注意してください。これらのいくつかの型は<literal>=</literal>演算子を持ちますが、<literal>=</literal>は<emphasis>面積</emphasis>の等しさのみを比較します。その他のスカラー比較演算子（<literal>&lt;=</literal>など）は同様にこれらの型の面積を比較します。
    </para>
   </caution>

   <table id="functions-geometry-op-table">
<!--
     <title>Geometric Operators</title>
-->
     <title>幾何データ演算子</title>
     <tgroup cols="3">
      <thead>
       <row>
<!--
        <entry>Operator</entry>
        <entry>Description</entry>
        <entry>Example</entry>
-->
        <entry>演算子</entry>
        <entry>説明</entry>
        <entry>例</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry> <literal>+</literal> </entry>
<!--
        <entry>Translation</entry>
-->
        <entry>平行移動</entry>
        <entry><literal>box '((0,0),(1,1))' + point '(2.0,0)'</literal></entry>
       </row>
       <row>
        <entry> <literal>-</literal> </entry>
<!--
        <entry>Translation</entry>
-->
        <entry>平行移動</entry>
        <entry><literal>box '((0,0),(1,1))' - point '(2.0,0)'</literal></entry>
       </row>
       <row>
        <entry> <literal>*</literal> </entry>
<!--
        <entry>Scaling/rotation</entry>
-->
        <entry>拡大縮小/回転</entry>
        <entry><literal>box '((0,0),(1,1))' * point '(2.0,0)'</literal></entry>
       </row>
       <row>
        <entry> <literal>/</literal> </entry>
<!--
        <entry>Scaling/rotation</entry>
-->
        <entry>拡大縮小/回転</entry>
        <entry><literal>box '((0,0),(2,2))' / point '(2.0,0)'</literal></entry>
       </row>
       <row>
        <entry> <literal>#</literal> </entry>
<!--
        <entry>Point or box of intersection</entry>
-->
        <entry>交差点、交差矩形</entry>
        <entry><literal>box '((1,-1),(-1,1))' # box '((1,1),(-2,-2))'</literal></entry>
       </row>
       <row>
        <entry> <literal>#</literal> </entry>
<!--
        <entry>Number of points in path or polygon</entry>
-->
        <entry>経路もしくは多角形の点の数</entry>
        <entry><literal># path '((1,0),(0,1),(-1,0))'</literal></entry>
       </row>
       <row>
        <entry> <literal>@-@</literal> </entry>
<!--
        <entry>Length or circumference</entry>
-->
        <entry>長さもしくは円周</entry>
        <entry><literal>@-@ path '((0,0),(1,0))'</literal></entry>
       </row>
       <row>
        <entry> <literal>@@</literal> </entry>
<!--
        <entry>Center</entry>
-->
        <entry>中心</entry>
        <entry><literal>@@ circle '((0,0),10)'</literal></entry>
       </row>
       <row>
        <entry> <literal>##</literal> </entry>
<!--
        <entry>Closest point to first operand on second operand</entry>
-->
        <entry>第2オペランド上の第1オペランドへの近接点</entry>
        <entry><literal>point '(0,0)' ## lseg '((2,0),(0,2))'</literal></entry>
       </row>
       <row>
        <entry> <literal>&lt;-&gt;</literal> </entry>
<!--
        <entry>Distance between</entry>
-->
        <entry>距離</entry>
        <entry><literal>circle '((0,0),1)' &lt;-&gt; circle '((5,0),1)'</literal></entry>
       </row>
       <row>
        <entry> <literal>&amp;&amp;</literal> </entry>
<!--
        <entry>Overlaps?  (One point in common makes this true.)</entry>
-->
        <entry>重なっているかどうか？(一つでも共通する点があれば真となります)</entry>
        <entry><literal>box '((0,0),(1,1))' &amp;&amp; box '((0,0),(2,2))'</literal></entry>
       </row>
       <row>
        <entry> <literal>&lt;&lt;</literal> </entry>
<!--
        <entry>Is strictly left of?</entry>
-->
        <entry>厳密に左側にあるか？</entry>
        <entry><literal>circle '((0,0),1)' &lt;&lt; circle '((5,0),1)'</literal></entry>
       </row>
       <row>
        <entry> <literal>&gt;&gt;</literal> </entry>
<!--
        <entry>Is strictly right of?</entry>
-->
        <entry>厳密に右側にあるか？</entry>
        <entry><literal>circle '((5,0),1)' &gt;&gt; circle '((0,0),1)'</literal></entry>
       </row>
       <row>
        <entry> <literal>&amp;&lt;</literal> </entry>
<!--
        <entry>Does not extend to the right of?</entry>
-->
        <entry>右側にはみ出さないか？</entry>
        <entry><literal>box '((0,0),(1,1))' &amp;&lt; box '((0,0),(2,2))'</literal></entry>
       </row>
       <row>
        <entry> <literal>&amp;&gt;</literal> </entry>
<!--
        <entry>Does not extend to the left of?</entry>
-->
        <entry>左側にはみ出さないか？</entry>
        <entry><literal>box '((0,0),(3,3))' &amp;&gt; box '((0,0),(2,2))'</literal></entry>
       </row>
       <row>
        <entry> <literal>&lt;&lt;|</literal> </entry>
<!--
        <entry>Is strictly below?</entry>
-->
        <entry>厳密に下側にあるか？</entry>
        <entry><literal>box '((0,0),(3,3))' &lt;&lt;| box '((3,4),(5,5))'</literal></entry>
       </row>
       <row>
        <entry> <literal>|&gt;&gt;</literal> </entry>
<!--
        <entry>Is strictly above?</entry>
-->
        <entry>厳密に上側にあるか？</entry>
        <entry><literal>box '((3,4),(5,5))' |&gt;&gt; box '((0,0),(3,3))'</literal></entry>
       </row>
       <row>
        <entry> <literal>&amp;&lt;|</literal> </entry>
<!--
        <entry>Does not extend above?</entry>
-->
        <entry>上側に出ていないか？</entry>
        <entry><literal>box '((0,0),(1,1))' &amp;&lt;| box '((0,0),(2,2))'</literal></entry>
       </row>
       <row>
        <entry> <literal>|&amp;&gt;</literal> </entry>
<!--
        <entry>Does not extend below?</entry>
-->
        <entry>下側に出ていないか？</entry>
        <entry><literal>box '((0,0),(3,3))' |&amp;&gt; box '((0,0),(2,2))'</literal></entry>
       </row>
       <row>
        <entry> <literal>&lt;^</literal> </entry>
<!--
        <entry>Is below (allows touching)?</entry>
-->
        <entry>（接触を許可し）下側にあるか？</entry>
        <entry><literal>circle '((0,0),1)' &lt;^ circle '((0,5),1)'</literal></entry>
       </row>
       <row>
        <entry> <literal>&gt;^</literal> </entry>
<!--
        <entry>Is above (allows touching)?</entry>
-->
        <entry>（接触を許可し）上側にあるか？</entry>
        <entry><literal>circle '((0,5),1)' &gt;^ circle '((0,0),1)'</literal></entry>
       </row>
       <row>
        <entry> <literal>?#</literal> </entry>
<!--
        <entry>Intersects?</entry>
-->
        <entry>交わるか？</entry>
        <entry><literal>lseg '((-1,0),(1,0))' ?# box '((-2,-2),(2,2))'</literal></entry>
       </row>
       <row>
        <entry> <literal>?-</literal> </entry>
<!--
        <entry>Is horizontal?</entry>
-->
        <entry>水平か？</entry>
        <entry><literal>?- lseg '((-1,0),(1,0))'</literal></entry>
       </row>
       <row>
        <entry> <literal>?-</literal> </entry>
<!--
        <entry>Are horizontally aligned?</entry>
-->
        <entry>水平方向に揃っているか？</entry>
        <entry><literal>point '(1,0)' ?- point '(0,0)'</literal></entry>
       </row>
       <row>
        <entry> <literal>?|</literal> </entry>
<!--
        <entry>Is vertical?</entry>
-->
        <entry>垂直か？</entry>
        <entry><literal>?| lseg '((-1,0),(1,0))'</literal></entry>
       </row>
       <row>
        <entry> <literal>?|</literal> </entry>
<!--
        <entry>Are vertically aligned?</entry>
-->
        <entry>垂直方向に揃っているか？</entry>
        <entry><literal>point '(0,1)' ?| point '(0,0)'</literal></entry>
       </row>
       <row>
        <entry> <literal>?-|</literal> </entry>
<!--
        <entry>Is perpendicular?</entry>
-->
        <entry>直角をなしているか？</entry>
        <entry><literal>lseg '((0,0),(0,1))' ?-| lseg '((0,0),(1,0))'</literal></entry>
       </row>
       <row>
        <entry> <literal>?||</literal> </entry>
<!--
        <entry>Are parallel?</entry>
-->
        <entry>平行か？</entry>
        <entry><literal>lseg '((-1,0),(1,0))' ?|| lseg '((-1,2),(1,2))'</literal></entry>
       </row>
       <row>
        <entry> <literal>@&gt;</literal> </entry>
<!--
        <entry>Contains?</entry>
-->
        <entry>包含しているか？</entry>
        <entry><literal>circle '((0,0),2)' @&gt; point '(1,1)'</literal></entry>
       </row>
       <row>
        <entry> <literal>&lt;@</literal> </entry>
<!--
        <entry>Contained in or on?</entry>
-->
        <entry>包含されているかもしくは境界上か？</entry>
        <entry><literal>point '(1,1)' &lt;@ circle '((0,0),2)'</literal></entry>
       </row>
       <row>
        <entry> <literal>~=</literal> </entry>
<!--
        <entry>Same as?</entry>
-->
        <entry>同等か？</entry>
        <entry><literal>polygon '((0,0),(1,1))' ~= polygon '((1,1),(0,0))'</literal></entry>
       </row>
      </tbody>
     </tgroup>
   </table>

   <note>
    <para>
<!--
     Before <productname>PostgreSQL</productname> 8.2, the containment
     operators <literal>@&gt;</literal> and <literal>&lt;@</literal> were respectively
     called <literal>~</literal> and <literal>@</literal>.  These names are still
     available, but are deprecated and will eventually be removed.
-->
<productname>PostgreSQL</productname>の8.2より前では、包含演算子<literal>@&gt;</literal>および<literal>&lt;@</literal>はそれぞれ<literal>~</literal>および<literal>@</literal>という名前でした。
これらの名前はまだ利用できますが、削除予定であり最終的にはなくなるでしょう。
    </para>
   </note>

   <indexterm>
    <primary>area</primary>
   </indexterm>
   <indexterm>
    <primary>center</primary>
   </indexterm>
   <indexterm>
    <primary>diameter</primary>
   </indexterm>
   <indexterm>
    <primary>height</primary>
   </indexterm>
   <indexterm>
    <primary>isclosed</primary>
   </indexterm>
   <indexterm>
    <primary>isopen</primary>
   </indexterm>
   <indexterm>
    <primary>length</primary>
   </indexterm>
   <indexterm>
    <primary>npoints</primary>
   </indexterm>
   <indexterm>
    <primary>pclose</primary>
   </indexterm>
   <indexterm>
    <primary>popen</primary>
   </indexterm>
   <indexterm>
    <primary>radius</primary>
   </indexterm>
   <indexterm>
    <primary>width</primary>
   </indexterm>

   <table id="functions-geometry-func-table">
<!--
     <title>Geometric Functions</title>
-->
     <title>幾何データ型関数</title>
     <tgroup cols="4">
      <thead>
       <row>
<!--
        <entry>Function</entry>
        <entry>Return Type</entry>
        <entry>Description</entry>
        <entry>Example</entry>
-->
        <entry>関数</entry>
        <entry>戻り値</entry>
        <entry>説明</entry>
        <entry>例</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><literal><function>area(<replaceable>object</replaceable>)</function></literal></entry>
        <entry><type>double precision</type></entry>
<!--
        <entry>area</entry>
-->
        <entry>面積</entry>
        <entry><literal>area(box '((0,0),(1,1))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>center(<replaceable>object</replaceable>)</function></literal></entry>
        <entry><type>point</type></entry>
<!--
        <entry>center</entry>
-->
        <entry>中心</entry>
        <entry><literal>center(box '((0,0),(1,2))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>diameter(<type>circle</type>)</function></literal></entry>
        <entry><type>double precision</type></entry>
<!--
        <entry>diameter of circle</entry>
-->
        <entry>円の直径</entry>
        <entry><literal>diameter(circle '((0,0),2.0)')</literal></entry>
       </row>
       <row>
        <entry><literal><function>height(<type>box</type>)</function></literal></entry>
        <entry><type>double precision</type></entry>
<!--
        <entry>vertical size of box</entry>
-->
        <entry>矩形の高さ</entry>
        <entry><literal>height(box '((0,0),(1,1))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>isclosed(<type>path</type>)</function></literal></entry>
        <entry><type>boolean</type></entry>
<!--
        <entry>a closed path?</entry>
-->
        <entry>閉経路か？</entry>
        <entry><literal>isclosed(path '((0,0),(1,1),(2,0))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>isopen(<type>path</type>)</function></literal></entry>
        <entry><type>boolean</type></entry>
<!--
        <entry>an open path?</entry>
-->
        <entry>開経路か？</entry>
        <entry><literal>isopen(path '[(0,0),(1,1),(2,0)]')</literal></entry>
       </row>
       <row>
        <entry><literal><function>length(<replaceable>object</replaceable>)</function></literal></entry>
        <entry><type>double precision</type></entry>
<!--
        <entry>length</entry>
-->
        <entry>長さ</entry>
        <entry><literal>length(path '((-1,0),(1,0))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>npoints(<type>path</type>)</function></literal></entry>
        <entry><type>int</type></entry>
<!--
        <entry>number of points</entry>
-->
        <entry>点の数</entry>
        <entry><literal>npoints(path '[(0,0),(1,1),(2,0)]')</literal></entry>
       </row>
       <row>
        <entry><literal><function>npoints(<type>polygon</type>)</function></literal></entry>
        <entry><type>int</type></entry>
<!--
        <entry>number of points</entry>
-->
        <entry>点の数</entry>
        <entry><literal>npoints(polygon '((1,1),(0,0))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>pclose(<type>path</type>)</function></literal></entry>
        <entry><type>path</type></entry>
<!--
        <entry>convert path to closed</entry>
-->
        <entry>閉経路に変換</entry>
        <entry><literal>pclose(path '[(0,0),(1,1),(2,0)]')</literal></entry>
       </row>
       <row>
        <entry><literal><function>popen(<type>path</type>)</function></literal></entry>
        <entry><type>path</type></entry>
<!--
        <entry>convert path to open</entry>
-->
        <entry>開経路に変換</entry>
        <entry><literal>popen(path '((0,0),(1,1),(2,0))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>radius(<type>circle</type>)</function></literal></entry>
        <entry><type>double precision</type></entry>
<!--
        <entry>radius of circle</entry>
-->
        <entry>円の半径</entry>
        <entry><literal>radius(circle '((0,0),2.0)')</literal></entry>
       </row>
       <row>
        <entry><literal><function>width(<type>box</type>)</function></literal></entry>
        <entry><type>double precision</type></entry>
<!--
        <entry>horizontal size of box</entry>
-->
        <entry>矩形の幅</entry>
        <entry><literal>width(box '((0,0),(1,1))')</literal></entry>
       </row>
      </tbody>
     </tgroup>
   </table>

   <table id="functions-geometry-conv-table">
<!--
     <title>Geometric Type Conversion Functions</title>
-->
     <title>幾何型変換関数</title>
     <tgroup cols="4">
      <thead>
       <row>
<!--
        <entry>Function</entry>
        <entry>Return Type</entry>
        <entry>Description</entry>
        <entry>Example</entry>
-->
        <entry>関数</entry>
        <entry>戻り値</entry>
        <entry>説明</entry>
        <entry>例</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>
         <indexterm>
          <primary>box</primary>
         </indexterm>
         <literal><function>box(<type>circle</type>)</function></literal>
        </entry>
        <entry><type>box</type></entry>
<!--
        <entry>circle to box</entry>
-->
        <entry>円を矩形に変換</entry>
        <entry><literal>box(circle '((0,0),2.0)')</literal></entry>
       </row>
       <row>
        <entry><literal><function>box(<type>point</type>)</function></literal></entry>
        <entry><type>box</type></entry>
<!--
        <entry>point to empty box</entry>
-->
        <entry>点を空の矩形に変換</entry>
        <entry><literal>box(point '(0,0)')</literal></entry>
       </row>
       <row>
        <entry><literal><function>box(<type>point</type>, <type>point</type>)</function></literal></entry>
        <entry><type>box</type></entry>
<!--
        <entry>points to box</entry>
-->
        <entry>座標点を矩形に変換</entry>
        <entry><literal>box(point '(0,0)', point '(1,1)')</literal></entry>
       </row>
       <row>
        <entry><literal><function>box(<type>polygon</type>)</function></literal></entry>
        <entry><type>box</type></entry>
<!--
        <entry>polygon to box</entry>
-->
        <entry>多角形を矩形に変換</entry>
        <entry><literal>box(polygon '((0,0),(1,1),(2,0))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>bound_box(<type>box</type>, <type>box</type>)</function></literal></entry>
        <entry><type>box</type></entry>
<!--
        <entry>boxes to bounding box</entry>
-->
        <entry>矩形を外接矩形に変換</entry>
        <entry><literal>bound_box(box '((0,0),(1,1))', box '((3,3),(4,4))')</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>circle</primary>
         </indexterm>
         <literal><function>circle(<type>box</type>)</function></literal>
        </entry>
        <entry><type>circle</type></entry>
<!--
        <entry>box to circle</entry>
-->
        <entry>矩形を円に変換</entry>
        <entry><literal>circle(box '((0,0),(1,1))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>circle(<type>point</type>, <type>double precision</type>)</function></literal></entry>
        <entry><type>circle</type></entry>
<!--
        <entry>center and radius to circle</entry>
-->
        <entry>中心と半径から円に変換</entry>
        <entry><literal>circle(point '(0,0)', 2.0)</literal></entry>
       </row>
       <row>
        <entry><literal><function>circle(<type>polygon</type>)</function></literal></entry>
        <entry><type>circle</type></entry>
<!--
        <entry>polygon to circle</entry>
-->
        <entry>多角形を円に変換</entry>
        <entry><literal>circle(polygon '((0,0),(1,1),(2,0))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>line(<type>point</type>, <type>point</type>)</function></literal></entry>
        <entry><type>line</type></entry>
<!--
        <entry>points to line</entry>
-->
        <entry>座標点を直線に変換</entry>
        <entry><literal>line(point '(-1,0)', point '(1,0)')</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>lseg</primary>
         </indexterm>
         <literal><function>lseg(<type>box</type>)</function></literal>
        </entry>
        <entry><type>lseg</type></entry>
<!--
        <entry>box diagonal to line segment</entry>
-->
        <entry>矩形の対角線を線分に変換</entry>
        <entry><literal>lseg(box '((-1,0),(1,0))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>lseg(<type>point</type>, <type>point</type>)</function></literal></entry>
        <entry><type>lseg</type></entry>
<!--
        <entry>points to line segment</entry>
-->
        <entry>座標点を線分に変換</entry>
        <entry><literal>lseg(point '(-1,0)', point '(1,0)')</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>path</primary>
         </indexterm>
         <literal><function>path(<type>polygon</type>)</function></literal>
        </entry>
        <entry><type>path</type></entry>
<!--
        <entry>polygon to path</entry>
-->
        <entry>多角形を経路に変換</entry>
        <entry><literal>path(polygon '((0,0),(1,1),(2,0))')</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>point</primary>
         </indexterm>
         <literal><function>point</function>(<type>double
         precision</type>, <type>double precision</type>)</literal>
        </entry>
        <entry><type>point</type></entry>
<!--
        <entry>construct point</entry>
-->
        <entry>座標点の構築</entry>
        <entry><literal>point(23.4, -44.5)</literal></entry>
       </row>
       <row>
        <entry><literal><function>point(<type>box</type>)</function></literal></entry>
        <entry><type>point</type></entry>
<!--
        <entry>center of box</entry>
-->
        <entry>矩形の中心</entry>
        <entry><literal>point(box '((-1,0),(1,0))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>point(<type>circle</type>)</function></literal></entry>
        <entry><type>point</type></entry>
<!--
        <entry>center of circle</entry>
-->
        <entry>円の中心</entry>
        <entry><literal>point(circle '((0,0),2.0)')</literal></entry>
       </row>
       <row>
        <entry><literal><function>point(<type>lseg</type>)</function></literal></entry>
        <entry><type>point</type></entry>
<!--
        <entry>center of line segment</entry>
-->
        <entry>線分の中心</entry>
        <entry><literal>point(lseg '((-1,0),(1,0))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>point(<type>polygon</type>)</function></literal></entry>
        <entry><type>point</type></entry>
<!--
        <entry>center of polygon</entry>
-->
        <entry>多角形の中心</entry>
        <entry><literal>point(polygon '((0,0),(1,1),(2,0))')</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>polygon</primary>
         </indexterm>
         <literal><function>polygon(<type>box</type>)</function></literal>
        </entry>
        <entry><type>polygon</type></entry>
<!--
        <entry>box to 4-point polygon</entry>
-->
        <entry>矩形を4頂点の多角形に変換</entry>
        <entry><literal>polygon(box '((0,0),(1,1))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>polygon(<type>circle</type>)</function></literal></entry>
        <entry><type>polygon</type></entry>
<!--
        <entry>circle to 12-point polygon</entry>
-->
        <entry>円を12角形に変換</entry>
        <entry><literal>polygon(circle '((0,0),2.0)')</literal></entry>
       </row>
       <row>
        <entry><literal><function>polygon(<replaceable class="parameter">npts</replaceable>, <type>circle</type>)</function></literal></entry>
        <entry><type>polygon</type></entry>
<!--
        <entry>circle to <replaceable class="parameter">npts</replaceable>-point polygon</entry>
-->
        <entry>円を<replaceable class="parameter">npts</replaceable>角形に変換</entry>
        <entry><literal>polygon(12, circle '((0,0),2.0)')</literal></entry>
       </row>
       <row>
        <entry><literal><function>polygon(<type>path</type>)</function></literal></entry>
        <entry><type>polygon</type></entry>
<!--
        <entry>path to polygon</entry>
-->
        <entry>経路を多角形に変換</entry>
        <entry><literal>polygon(path '((0,0),(1,1),(2,0))')</literal></entry>
       </row>
      </tbody>
     </tgroup>
   </table>

    <para>
<!--
     It is possible to access the two component numbers of a <type>point</type>
     as though the point were an array with indexes 0 and 1.  For example, if
     <literal>t.p</literal> is a <type>point</type> column then
     <literal>SELECT p[0] FROM t</literal> retrieves the X coordinate and
     <literal>UPDATE t SET p[1] = ...</literal> changes the Y coordinate.
     In the same way, a value of type <type>box</type> or <type>lseg</type> can be treated
     as an array of two <type>point</type> values.
-->
あたかもpointは添字0、1を有する配列であるかのように、<type>point</type>の２つの構成要素にアクセスすることができます。
例えば、<literal>t.p</literal>が<type>point</type>列の場合、<literal>SELECT p[0] FROM t</literal>という式でX座標を抽出できます。また、<literal>UPDATE t SET p[1] = ...</literal>でY座標を変更できます。
同様に、<type>box</type>型または<type>lseg</type>型の値も、2つの<type>point</type>型の値の配列のように扱えます。
    </para>

    <para>
<!--
     The <function>area</function> function works for the types
     <type>box</type>, <type>circle</type>, and <type>path</type>.
     The <function>area</function> function only works on the
     <type>path</type> data type if the points in the
     <type>path</type> are non-intersecting.  For example, the
     <type>path</type>
     <literal>'((0,0),(0,1),(2,1),(2,2),(1,2),(1,0),(0,0))'::PATH</literal>
     will not work;  however, the following visually identical
     <type>path</type>
     <literal>'((0,0),(0,1),(1,1),(1,2),(2,2),(2,1),(1,1),(1,0),(0,0))'::PATH</literal>
     will work.  If the concept of an intersecting versus
     non-intersecting <type>path</type> is confusing, draw both of the
     above <type>path</type>s side by side on a piece of graph paper.
-->
<function>area</function>関数は、<type>box</type>、<type>circle</type>、<type>path</type>型に対して動作します。
<type>path</type>データ型に対する<function>area</function>関数は、その<type>path</type>が交差しない場合にのみ動作します。
例えば、<literal>'((0,0),(0,1),(2,1),(2,2),(1,2),(1,0),(0,0))'::PATH</literal>という<type>path</type>は動作しません。しかし、見た目は同じですが、<literal>'((0,0),(0,1),(1,1),(1,2),(2,2),(2,1),(1,1),(1,0),(0,0))'::PATH</literal>という<type>path</type>では動作します。
<type>path</type>の交差する、しないという概念がよくわからなければ、上の2つの<type>path</type>を並べてグラフ用紙に書いてみてください。
    </para>

  </sect1>


 <sect1 id="functions-net">
<!--
  <title>Network Address Functions and Operators</title>
-->
  <title>ネットワークアドレス関数と演算子</title>

  <para>
<!--
   <xref linkend="cidr-inet-operators-table"/> shows the operators
   available for the <type>cidr</type> and <type>inet</type> types.
   The operators <literal>&lt;&lt;</literal>,
   <literal>&lt;&lt;=</literal>, <literal>&gt;&gt;</literal>,
   <literal>&gt;&gt;=</literal>, and <literal>&amp;&amp;</literal>
   test for subnet inclusion.  They
   consider only the network parts of the two addresses (ignoring any
   host part) and determine whether one network is identical to
   or a subnet of the other.
-->
<xref linkend="cidr-inet-operators-table"/>に、<type>inet</type>型および<type>cidr</type>型で使用可能な演算子を示します。
演算子 <literal>&lt;&lt;</literal>、<literal>&lt;&lt;=</literal>、<literal>&gt;&gt;</literal>、<literal>&gt;&gt;=</literal>および<literal>&amp;&amp;</literal>はサブネットの包含関係を調べるものです。
これらは2つのアドレスのネットワークの部分のみを考慮（ホスト部分を無視）して2つのネットワークアドレスが等しいか、もしくは一方のネットワークが他方のサブネットになっているかを特定します。
  </para>

    <table id="cidr-inet-operators-table">
<!--
     <title><type>cidr</type> and <type>inet</type> Operators</title>
-->
     <title><type>cidr</type>と<type>inet</type>演算子</title>
     <tgroup cols="3">
      <thead>
       <row>
<!--
        <entry>Operator</entry>
        <entry>Description</entry>
        <entry>Example</entry>
-->
        <entry>演算子</entry>
        <entry>説明</entry>
        <entry>例</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry> <literal>&lt;</literal> </entry>
<!--
        <entry>is less than</entry>
-->
        <entry>未満</entry>
        <entry><literal>inet '192.168.1.5' &lt; inet '192.168.1.6'</literal></entry>
       </row>
       <row>
        <entry> <literal>&lt;=</literal> </entry>
<!--
        <entry>is less than or equal</entry>
-->
        <entry>未満もしくは等しい（以下）</entry>
        <entry><literal>inet '192.168.1.5' &lt;= inet '192.168.1.5'</literal></entry>
       </row>
       <row>
        <entry> <literal>=</literal> </entry>
<!--
        <entry>equals</entry>
-->
        <entry>等しい</entry>
        <entry><literal>inet '192.168.1.5' = inet '192.168.1.5'</literal></entry>
       </row>
       <row>
        <entry> <literal>&gt;=</literal> </entry>
<!--
        <entry>is greater or equal</entry>
-->
        <entry>より大きいもしくは等しい（以上）</entry>
        <entry><literal>inet '192.168.1.5' &gt;= inet '192.168.1.5'</literal></entry>
       </row>
       <row>
        <entry> <literal>&gt;</literal> </entry>
<!--
        <entry>is greater than</entry>
-->
        <entry>より大きい</entry>
        <entry><literal>inet '192.168.1.5' &gt; inet '192.168.1.4'</literal></entry>
       </row>
       <row>
        <entry> <literal>&lt;&gt;</literal> </entry>
<!--
        <entry>is not equal</entry>
-->
        <entry>等しくない</entry>
        <entry><literal>inet '192.168.1.5' &lt;&gt; inet '192.168.1.4'</literal></entry>
       </row>
       <row>
        <entry> <literal>&lt;&lt;</literal> </entry>
<!--
        <entry>is contained by</entry>
-->
        <entry>内包される</entry>
        <entry><literal>inet '192.168.1.5' &lt;&lt; inet '192.168.1/24'</literal></entry>
       </row>
       <row>
        <entry> <literal>&lt;&lt;=</literal> </entry>
<!--
        <entry>is contained by or equals</entry>
-->
        <entry>内包されるか等しい</entry>
        <entry><literal>inet '192.168.1/24' &lt;&lt;= inet '192.168.1/24'</literal></entry>
       </row>
       <row>
        <entry> <literal>&gt;&gt;</literal> </entry>
<!--
        <entry>contains</entry>
-->
        <entry>内包する</entry>
        <entry><literal>inet '192.168.1/24' &gt;&gt; inet '192.168.1.5'</literal></entry>
       </row>
       <row>
        <entry> <literal>&gt;&gt;=</literal> </entry>
<!--
        <entry>contains or equals</entry>
-->
        <entry>内包するか等しい</entry>
        <entry><literal>inet '192.168.1/24' &gt;&gt;= inet '192.168.1/24'</literal></entry>
       </row>
       <row>
        <entry> <literal>&amp;&amp;</literal> </entry>
<!--
        <entry>contains or is contained by</entry>
-->
        <entry>内包するか内包されるか</entry>
        <entry><literal>inet '192.168.1/24' &amp;&amp; inet '192.168.1.80/28'</literal></entry>
       </row>
       <row>
        <entry> <literal>~</literal> </entry>
<!--
        <entry>bitwise NOT</entry>
-->
        <entry>ビット否定</entry>
        <entry><literal>~ inet '192.168.1.6'</literal></entry>
       </row>
       <row>
        <entry> <literal>&amp;</literal> </entry>
<!--
        <entry>bitwise AND</entry>
-->
        <entry>ビット積</entry>
        <entry><literal>inet '192.168.1.6' &amp; inet '0.0.0.255'</literal></entry>
       </row>
       <row>
        <entry> <literal>|</literal> </entry>
<!--
        <entry>bitwise OR</entry>
-->
        <entry>ビット和</entry>
        <entry><literal>inet '192.168.1.6' | inet '0.0.0.255'</literal></entry>
       </row>
       <row>
        <entry> <literal>+</literal> </entry>
<!--
        <entry>addition</entry>
-->
        <entry>加算</entry>
        <entry><literal>inet '192.168.1.6' + 25</literal></entry>
       </row>
       <row>
        <entry> <literal>-</literal> </entry>
<!--
        <entry>subtraction</entry>
-->
        <entry>減算</entry>
        <entry><literal>inet '192.168.1.43' - 36</literal></entry>
       </row>
       <row>
        <entry> <literal>-</literal> </entry>
<!--
        <entry>subtraction</entry>
-->
        <entry>減算</entry>
        <entry><literal>inet '192.168.1.43' - inet '192.168.1.19'</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

  <para>
<!--
   <xref linkend="cidr-inet-functions-table"/> shows the functions
   available for use with the <type>cidr</type> and <type>inet</type>
   types.  The <function>abbrev</function>, <function>host</function>,
   and <function>text</function>
   functions are primarily intended to offer alternative display
   formats.
-->
<xref linkend="cidr-inet-functions-table"/>に、<type>inet</type>型および<type>cidr</type>型で使用可能な関数を示します。
関数<function>abbrev</function>、<function>host</function>、および<function>text</function>、は主として、代替の整形表示を提供する目的のものです。
  </para>

    <table id="cidr-inet-functions-table">
<!--
     <title><type>cidr</type> and <type>inet</type> Functions</title>
-->
     <title><type>cidr</type>および<type>inet</type>型関数</title>
     <tgroup cols="5">
      <thead>
       <row>
<!--
        <entry>Function</entry>
        <entry>Return Type</entry>
        <entry>Description</entry>
        <entry>Example</entry>
        <entry>Result</entry>
-->
        <entry>関数</entry>
        <entry>戻り値</entry>
        <entry>説明</entry>
        <entry>例</entry>
        <entry>結果</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>
         <indexterm>
          <primary>abbrev</primary>
         </indexterm>
         <literal><function>abbrev(<type>inet</type>)</function></literal>
        </entry>
        <entry><type>text</type></entry>
<!--
        <entry>abbreviated display format as text</entry>
-->
        <entry>表示用テキスト省略形</entry>
        <entry><literal>abbrev(inet '10.1.0.0/16')</literal></entry>
        <entry><literal>10.1.0.0/16</literal></entry>
       </row>
       <row>
        <entry><literal><function>abbrev(<type>cidr</type>)</function></literal></entry>
        <entry><type>text</type></entry>
<!--
        <entry>abbreviated display format as text</entry>
-->
        <entry>表示用テキスト省略形</entry>
        <entry><literal>abbrev(cidr '10.1.0.0/16')</literal></entry>
        <entry><literal>10.1/16</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>broadcast</primary>
         </indexterm>
         <literal><function>broadcast(<type>inet</type>)</function></literal>
        </entry>
        <entry><type>inet</type></entry>
<!--
        <entry>broadcast address for network</entry>
-->
        <entry>ネットワークブロードキャストアドレス</entry>
        <entry><literal>broadcast('192.168.1.5/24')</literal></entry>
        <entry><literal>192.168.1.255/24</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>family</primary>
         </indexterm>
         <literal><function>family(<type>inet</type>)</function></literal>
        </entry>
        <entry><type>int</type></entry>
<!--
        <entry>extract family of address; <literal>4</literal> for IPv4,
         <literal>6</literal> for IPv6</entry>
-->
         <entry>アドレスファミリの取り出し。IPv4では<literal>4</literal>、IPv6では<literal>6</literal>。</entry>
        <entry><literal>family('::1')</literal></entry>
        <entry><literal>6</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>host</primary>
         </indexterm>
         <literal><function>host(<type>inet</type>)</function></literal>
        </entry>
        <entry><type>text</type></entry>
<!--
        <entry>extract IP address as text</entry>
-->
        <entry>IPアドレスをテキストで抽出</entry>
        <entry><literal>host('192.168.1.5/24')</literal></entry>
        <entry><literal>192.168.1.5</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>hostmask</primary>
         </indexterm>
         <literal><function>hostmask(<type>inet</type>)</function></literal>
        </entry>
        <entry><type>inet</type></entry>
<!--
        <entry>construct host mask for network</entry>
-->
        <entry>ネットワーク用のホストマスクの構築</entry>
        <entry><literal>hostmask('192.168.23.20/30')</literal></entry>
        <entry><literal>0.0.0.3</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>masklen</primary>
         </indexterm>
         <literal><function>masklen(<type>inet</type>)</function></literal>
        </entry>
        <entry><type>int</type></entry>
<!--
        <entry>extract netmask length</entry>
-->
        <entry>ネットマスク長の抽出</entry>
        <entry><literal>masklen('192.168.1.5/24')</literal></entry>
        <entry><literal>24</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>netmask</primary>
         </indexterm>
         <literal><function>netmask(<type>inet</type>)</function></literal>
        </entry>
        <entry><type>inet</type></entry>
<!--
        <entry>construct netmask for network</entry>
-->
        <entry>ネットワーク用ネットマスクの構築</entry>
        <entry><literal>netmask('192.168.1.5/24')</literal></entry>
        <entry><literal>255.255.255.0</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>network</primary>
         </indexterm>
         <literal><function>network(<type>inet</type>)</function></literal>
        </entry>
        <entry><type>cidr</type></entry>
<!--
        <entry>extract network part of address</entry>
-->
        <entry>ネットワークアドレスからネットワーク部を抽出</entry>
        <entry><literal>network('192.168.1.5/24')</literal></entry>
        <entry><literal>192.168.1.0/24</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>set_masklen</primary>
         </indexterm>
         <literal><function>set_masklen(<type>inet</type>, <type>int</type>)</function></literal>
        </entry>
        <entry><type>inet</type></entry>
<!--
        <entry>set netmask length for <type>inet</type> value</entry>
-->
        <entry><type>inet</type>値のネットマスク長を設定</entry>
        <entry><literal>set_masklen('192.168.1.5/24', 16)</literal></entry>
        <entry><literal>192.168.1.5/16</literal></entry>
       </row>
       <row>
        <entry><literal><function>set_masklen(<type>cidr</type>, <type>int</type>)</function></literal></entry>
        <entry><type>cidr</type></entry>
<!--
        <entry>set netmask length for <type>cidr</type> value</entry>
-->
        <entry><type>cidr</type>値のネットマスク長を設定</entry>
        <entry><literal>set_masklen('192.168.1.0/24'::cidr, 16)</literal></entry>
        <entry><literal>192.168.0.0/16</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>text</primary>
         </indexterm>
         <literal><function>text(<type>inet</type>)</function></literal>
        </entry>
        <entry><type>text</type></entry>
<!--
        <entry>extract IP address and netmask length as text</entry>
-->
        <entry>IPアドレスとネットマスク長をテキストで抽出</entry>
        <entry><literal>text(inet '192.168.1.5')</literal></entry>
        <entry><literal>192.168.1.5/32</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>inet_same_family</primary>
         </indexterm>
         <literal><function>inet_same_family(<type>inet</type>, <type>inet</type>)</function></literal>
        </entry>
        <entry><type>boolean</type></entry>
<!--
        <entry>are the addresses from the same family?</entry>
-->
        <entry>同じアドレスファミリかどうかを返す</entry>
        <entry><literal>inet_same_family('192.168.1.5/24', '::1')</literal></entry>
        <entry><literal>false</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>inet_merge</primary>
         </indexterm>
         <literal><function>inet_merge(<type>inet</type>, <type>inet</type>)</function></literal>
        </entry>
        <entry><type>cidr</type></entry>
<!--
        <entry>the smallest network which includes both of the given networks</entry>
-->
        <entry>両方のネットワークを含む最小のネットワークを返す</entry>
        <entry><literal>inet_merge('192.168.1.5/24', '192.168.2.5/24')</literal></entry>
        <entry><literal>192.168.0.0/22</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

  <para>
<!--
   Any <type>cidr</type> value can be cast to <type>inet</type> implicitly
   or explicitly; therefore, the functions shown above as operating on
   <type>inet</type> also work on <type>cidr</type> values.  (Where there are
   separate functions for <type>inet</type> and <type>cidr</type>, it is because
   the behavior should be different for the two cases.)
   Also, it is permitted to cast an <type>inet</type> value to <type>cidr</type>.
   When this is done, any bits to the right of the netmask are silently zeroed
   to create a valid <type>cidr</type> value.
   In addition,
   you can cast a text value to <type>inet</type> or <type>cidr</type>
   using normal casting syntax: for example,
   <literal>inet(<replaceable>expression</replaceable>)</literal> or
   <literal><replaceable>colname</replaceable>::cidr</literal>.
-->
<type>cidr</type>値はすべて、暗黙的または明示的に<type>inet</type>型にキャスト可能です。
したがって、上で示した<type>inet</type>に対する操作を行う関数は<type>cidr</type>値でも動作します。
（<type>inet</type>と<type>cidr</type>で別々に関数が存在するものがありますが、それは、この2つで動作に違いがあるためです。）
また、<type>inet</type>値から<type>cidr</type>へのキャストも許されます。これが行われると、ネットマスクの右側のビットは、<type>cidr</type>として有効な値とするために0となります。
さらに、通常のキャスト構文、例えば、<literal>inet(<replaceable>expression</replaceable>)</literal>や<literal><replaceable>colname</replaceable>::cidr</literal>を使用して、テキスト値を<type>inet</type>や<type>cidr</type>にキャストすることもできます。
  </para>

  <para>
<!--
   <xref linkend="macaddr-functions-table"/> shows the functions
   available for use with the <type>macaddr</type> type.  The function
   <literal><function>trunc(<type>macaddr</type>)</function></literal> returns a MAC
   address with the last 3 bytes set to zero.  This can be used to
   associate the remaining prefix with a manufacturer.
-->
<xref linkend="macaddr-functions-table"/>に、<type>macaddr</type>型で使用可能な関数を示します。
関数<literal><function>trunc(<type>macaddr</type>)</function></literal>は終わりの3バイトがゼロに設定されたMACアドレスを返します。
これは、残った接頭部を製造者に対応させることに使えます。
  </para>

    <table id="macaddr-functions-table">
<!--
     <title><type>macaddr</type> Functions</title>
-->
     <title><type>macaddr</type>型関数</title>
     <tgroup cols="5">
      <thead>
       <row>
<!--
        <entry>Function</entry>
        <entry>Return Type</entry>
        <entry>Description</entry>
        <entry>Example</entry>
        <entry>Result</entry>
-->
        <entry>関数</entry>
        <entry>戻り値</entry>
        <entry>説明</entry>
        <entry>例</entry>
        <entry>結果</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>
         <indexterm>
          <primary>trunc</primary>
         </indexterm>
         <literal><function>trunc(<type>macaddr</type>)</function></literal>
        </entry>
        <entry><type>macaddr</type></entry>
<!--
        <entry>set last 3 bytes to zero</entry>
-->
        <entry>終わりの３バイトをゼロに設定</entry>
        <entry><literal>trunc(macaddr '12:34:56:78:90:ab')</literal></entry>
        <entry><literal>12:34:56:00:00:00</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
<!--
    The <type>macaddr</type> type also supports the standard relational
    operators (<literal>&gt;</literal>, <literal>&lt;=</literal>, etc.) for
    lexicographical ordering, and the bitwise arithmetic operators
    (<literal>~</literal>, <literal>&amp;</literal> and <literal>|</literal>)
    for NOT, AND and OR.
-->
<type>macaddr</type>型は（<literal>&gt;</literal>、<literal>&lt;=</literal>等の）辞書編集順に並べる標準関係演算子とNOT、AND、ORのビット演算子(<literal>~</literal>、<literal>&amp;</literal>、<literal>|</literal>)もサポートしています。
   </para>

   <para>
<!--
   <xref linkend="macaddr8-functions-table"/> shows the functions
   available for use with the <type>macaddr8</type> type.  The function
   <literal><function>trunc(<type>macaddr8</type>)</function></literal> returns a MAC
   address with the last 5 bytes set to zero.  This can be used to
   associate the remaining prefix with a manufacturer.
-->
<type>macaddr8</type>型で利用できる関数を<xref linkend="macaddr8-functions-table"/>に示します。
関数<literal><function>trunc(<type>macaddr8</type>)</function></literal>は終わりの5バイトをゼロに設定したMACアドレスを返します。
これは、残りの先頭部分を製造者と紐付けるのに使用できます。
  </para>

    <table id="macaddr8-functions-table">
<!--
     <title><type>macaddr8</type> Functions</title>
-->
     <title><type>macaddr8</type>関数</title>
     <tgroup cols="5">
      <thead>
       <row>
<!--
        <entry>Function</entry>
        <entry>Return Type</entry>
        <entry>Description</entry>
        <entry>Example</entry>
        <entry>Result</entry>
-->
        <entry>関数</entry>
        <entry>戻り値</entry>
        <entry>説明</entry>
        <entry>例</entry>
        <entry>結果</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>
         <indexterm>
          <primary>trunc</primary>
         </indexterm>
         <literal><function>trunc(<type>macaddr8</type>)</function></literal>
        </entry>
        <entry><type>macaddr8</type></entry>
<!--
        <entry>set last 5 bytes to zero</entry>
-->
        <entry>終わりの5バイトをゼロにする</entry>
        <entry><literal>trunc(macaddr8 '12:34:56:78:90:ab:cd:ef')</literal></entry>
        <entry><literal>12:34:56:00:00:00:00:00</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>macaddr8_set7bit</primary>
         </indexterm>
         <literal><function>macaddr8_set7bit(<type>macaddr8</type>)</function></literal>
        </entry>
        <entry><type>macaddr8</type></entry>
<!--
        <entry>set 7th bit to one, also known as modified EUI-64, for inclusion in an IPv6 address</entry>
-->
        <entry>7番目のビットを1にし、修正EUI-64と呼ばれる形式にして、IPv6アドレスに含められるようにする</entry>
        <entry><literal>macaddr8_set7bit(macaddr8 '00:34:56:ab:cd:ef')</literal></entry>
        <entry><literal>02:34:56:ff:fe:ab:cd:ef</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
<!--
    The <type>macaddr8</type> type also supports the standard relational
    operators (<literal>&gt;</literal>, <literal>&lt;=</literal>, etc.) for
    ordering, and the bitwise arithmetic operators (<literal>~</literal>,
    <literal>&amp;</literal> and <literal>|</literal>) for NOT, AND and OR.
-->
<type>macaddr8</type>型は、順序付けのための標準的関係演算（<literal>&gt;</literal>、<literal>&lt;=</literal>など）およびNOT、AND、ORに関するビットごとの算術演算（<literal>~</literal>、<literal>&amp;</literal>、<literal>|</literal>）もサポートします。
   </para>

  </sect1>


 <sect1 id="functions-textsearch">
<!--
  <title>Text Search Functions and Operators</title>
-->
  <title>テキスト検索関数と演算子</title>

   <indexterm zone="datatype-textsearch">
<!--
    <primary>full text search</primary>
    <secondary>functions and operators</secondary>
-->
    <primary>全文テキスト検索</primary>
    <secondary>関数と演算子</secondary>
   </indexterm>

   <indexterm zone="datatype-textsearch">
<!--
    <primary>text search</primary>
    <secondary>functions and operators</secondary>
-->
    <primary>テキスト検索</primary>
    <secondary>関数と演算子</secondary>
   </indexterm>

  <para>
<!--
   <xref linkend="textsearch-operators-table"/>,
   <xref linkend="textsearch-functions-table"/> and
   <xref linkend="textsearch-functions-debug-table"/>
   summarize the functions and operators that are provided
   for full text searching.  See <xref linkend="textsearch"/> for a detailed
   explanation of <productname>PostgreSQL</productname>'s text search
   facility.
-->
<xref linkend="textsearch-operators-table"/>、<xref linkend="textsearch-functions-table"/>および<xref linkend="textsearch-functions-debug-table"/>は全文検索用に提供されている関数と演算子を要約しています。<productname>PostgreSQL</productname>のテキスト検索機能の詳細は<xref linkend="textsearch"/>を参照してください。
  </para>

    <table id="textsearch-operators-table">
<!--
     <title>Text Search Operators</title>
-->
     <title>テキスト検索演算子</title>
     <tgroup cols="5">
      <thead>
       <row>
<!--
        <entry>Operator</entry>
        <entry>Return Type</entry>
        <entry>Description</entry>
        <entry>Example</entry>
        <entry>Result</entry>
-->
        <entry>演算子</entry>
        <entry>戻り値型</entry>
        <entry>説明</entry>
        <entry>例</entry>
        <entry>結果</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry> <literal>@@</literal> </entry>
        <entry><type>boolean</type></entry>
<!--
        <entry><type>tsvector</type> matches <type>tsquery</type> ?</entry>
-->
        <entry><type>tsvector</type>が<type>tsquery</type>の条件に合うか？</entry>
        <entry><literal>to_tsvector('fat cats ate rats') @@ to_tsquery('cat &amp; rat')</literal></entry>
        <entry><literal>t</literal></entry>
       </row>
       <row>
        <entry> <literal>@@@</literal> </entry>
        <entry><type>boolean</type></entry>
<!--
        <entry>deprecated synonym for <literal>@@</literal></entry>
-->
        <entry><literal>@@</literal>に対する廃止予定の同義語</entry>
        <entry><literal>to_tsvector('fat cats ate rats') @@@ to_tsquery('cat &amp; rat')</literal></entry>
        <entry><literal>t</literal></entry>
       </row>
       <row>
        <entry> <literal>||</literal> </entry>
        <entry><type>tsvector</type></entry>
<!--
        <entry>concatenate <type>tsvector</type>s</entry>
-->
        <entry><type>tsvector</type>を連結</entry>
        <entry><literal>'a:1 b:2'::tsvector || 'c:1 d:2 b:3'::tsvector</literal></entry>
        <entry><literal>'a':1 'b':2,5 'c':3 'd':4</literal></entry>
       </row>
       <row>
        <entry> <literal>&amp;&amp;</literal> </entry>
        <entry><type>tsquery</type></entry>
<!--
        <entry>AND <type>tsquery</type>s together</entry>
-->
        <entry><type>tsquery</type>にAND演算を行う</entry>
        <entry><literal>'fat | rat'::tsquery &amp;&amp; 'cat'::tsquery</literal></entry>
        <entry><literal>( 'fat' | 'rat' ) &amp; 'cat'</literal></entry>
       </row>
       <row>
        <entry> <literal>||</literal> </entry>
        <entry><type>tsquery</type></entry>
<!--
        <entry>OR <type>tsquery</type>s together</entry>
-->
        <entry><type>tsquery</type>にOR演算を行う</entry>
        <entry><literal>'fat | rat'::tsquery || 'cat'::tsquery</literal></entry>
        <entry><literal>( 'fat' | 'rat' ) | 'cat'</literal></entry>
       </row>
       <row>
        <entry> <literal>!!</literal> </entry>
        <entry><type>tsquery</type></entry>
<!--
        <entry>negate a <type>tsquery</type></entry>
-->
        <entry><type>tsquery</type>を否定</entry>
        <entry><literal>!! 'cat'::tsquery</literal></entry>
        <entry><literal>!'cat'</literal></entry>
       </row>
       <row>
        <entry> <literal>&lt;-&gt;</literal> </entry>
        <entry><type>tsquery</type></entry>
<!--
        <entry><type>tsquery</type> followed by <type>tsquery</type></entry>
-->
        <entry><type>tsquery</type>に続く<type>tsquery</type></entry>
        <entry><literal>to_tsquery('fat') &lt;-&gt; to_tsquery('rat')</literal></entry>
        <entry><literal>'fat' &lt;-&gt; 'rat'</literal></entry>
       </row>
       <row>
        <entry> <literal>@&gt;</literal> </entry>
        <entry><type>boolean</type></entry>
<!--
        <entry><type>tsquery</type> contains another ?</entry>
-->
        <entry><type>tsquery</type>は他方を包含するか？</entry>
        <entry><literal>'cat'::tsquery @&gt; 'cat &amp; rat'::tsquery</literal></entry>
        <entry><literal>f</literal></entry>
       </row>
       <row>
        <entry> <literal>&lt;@</literal> </entry>
        <entry><type>boolean</type></entry>
<!--
        <entry><type>tsquery</type> is contained in ?</entry>
-->
        <entry><type>tsquery</type>は他方に包含されるか？</entry>
        <entry><literal>'cat'::tsquery &lt;@ 'cat &amp; rat'::tsquery</literal></entry>
        <entry><literal>t</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

    <note>
     <para>
<!--
      The <type>tsquery</type> containment operators consider only the lexemes
      listed in the two queries, ignoring the combining operators.
-->
<type>tsquery</type>の包含演算子は２つの問い合わせで列挙された語彙素のみを対象とし、結合演算子を無視します。
     </para>
    </note>

    <para>
<!--
     In addition to the operators shown in the table, the ordinary B-tree
     comparison operators (<literal>=</literal>, <literal>&lt;</literal>, etc) are defined
     for types <type>tsvector</type> and <type>tsquery</type>.  These are not very
     useful for text searching but allow, for example, unique indexes to be
     built on columns of these types.
-->
表に示された演算子に加え、通常のB-tree比較演算子（<literal>=</literal>、<literal>&lt;</literal>など）が、型<type>tsvector</type>および<type>tsquery</type>に対して定義されます。
これらはテキスト検索に対してそれほど有用ではありませんが、例えばこれらの型の列に一意インデックスを作成することを可能にします。
    </para>

    <table id="textsearch-functions-table">
<!--
     <title>Text Search Functions</title>
-->
     <title>テキスト検索関数</title>
     <tgroup cols="5">
      <thead>
       <row>
<!--
        <entry>Function</entry>
        <entry>Return Type</entry>
        <entry>Description</entry>
        <entry>Example</entry>
        <entry>Result</entry>
-->
        <entry>関数</entry>
        <entry>戻り値型</entry>
        <entry>説明</entry>
        <entry>例</entry>
        <entry>結果</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>
         <indexterm>
          <primary>array_to_tsvector</primary>
         </indexterm>
         <literal><function>array_to_tsvector(<type>text[]</type>)</function></literal>
        </entry>
        <entry><type>tsvector</type></entry>
<!--
        <entry>convert array of lexemes to <type>tsvector</type></entry>
-->
        <entry>語彙素の配列を<type>tsvector</type>に変換</entry>
        <entry><literal>array_to_tsvector('{fat,cat,rat}'::text[])</literal></entry>
        <entry><literal>'cat' 'fat' 'rat'</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>get_current_ts_config</primary>
         </indexterm>
         <literal><function>get_current_ts_config()</function></literal>
        </entry>
        <entry><type>regconfig</type></entry>
<!--
        <entry>get default text search configuration</entry>
-->
        <entry>
         デフォルトのテキスト検索設定の取得
        </entry>
        <entry><literal>get_current_ts_config()</literal></entry>
        <entry><literal>english</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>length</primary>
         </indexterm>
         <literal><function>length(<type>tsvector</type>)</function></literal>
        </entry>
        <entry><type>integer</type></entry>
<!--
        <entry>number of lexemes in <type>tsvector</type></entry>
-->
        <entry><type>tsvector</type>にある語彙素の数</entry>
        <entry><literal>length('fat:2,4 cat:3 rat:5A'::tsvector)</literal></entry>
        <entry><literal>3</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>numnode</primary>
         </indexterm>
         <literal><function>numnode(<type>tsquery</type>)</function></literal>
        </entry>
        <entry><type>integer</type></entry>
<!--
        <entry>number of lexemes plus operators in <type>tsquery</type></entry>
-->
        <entry>
         <type>tsquery</type>にある語彙素の数と演算子の数の和
        </entry>
        <entry><literal> numnode('(fat &amp; rat) | cat'::tsquery)</literal></entry>
        <entry><literal>5</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>plainto_tsquery</primary>
         </indexterm>
         <literal><function>plainto_tsquery(<optional> <replaceable class="parameter">config</replaceable> <type>regconfig</type> , </optional> <replaceable class="parameter">query</replaceable> <type>text</type>)</function></literal>
        </entry>
        <entry><type>tsquery</type></entry>
<!--
        <entry>produce <type>tsquery</type> ignoring punctuation</entry>
-->
        <entry>句読点を無視して、<type>tsquery</type>を作成</entry>
        <entry><literal>plainto_tsquery('english', 'The Fat Rats')</literal></entry>
        <entry><literal>'fat' &amp; 'rat'</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>phraseto_tsquery</primary>
         </indexterm>
         <literal><function>phraseto_tsquery(<optional> <replaceable class="parameter">config</replaceable> <type>regconfig</type> , </optional> <replaceable class="parameter">query</replaceable> <type>text</type>)</function></literal>
        </entry>
        <entry><type>tsquery</type></entry>
<!--
        <entry>produce <type>tsquery</type> that searches for a phrase,
         ignoring punctuation</entry>
-->
        <entry>句読点を無視して、語句を検索する<type>tsquery</type>を生成</entry>
        <entry><literal>phraseto_tsquery('english', 'The Fat Rats')</literal></entry>
        <entry><literal>'fat' &lt;-&gt; 'rat'</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>websearch_to_tsquery</primary>
         </indexterm>
          <literal><function>websearch_to_tsquery(<optional> <replaceable class="parameter">config</replaceable> <type>regconfig</type> , </optional> <replaceable class="parameter">query</replaceable> <type>text</type>)</function></literal>
         </entry>
        <entry><type>tsquery</type></entry>
<!--
        <entry>produce <type>tsquery</type> from a web search style query</entry>
-->
        <entry>web検索形式の問い合わせから<type>tsquery</type>を生成</entry>
        <entry><literal>websearch_to_tsquery('english', '"fat rat" or rat')</literal></entry>
        <entry><literal>'fat' &lt;-&gt; 'rat' | 'rat'</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>querytree</primary>
         </indexterm>
         <literal><function>querytree(<replaceable class="parameter">query</replaceable> <type>tsquery</type>)</function></literal>
        </entry>
        <entry><type>text</type></entry>
<!--
        <entry>get indexable part of a <type>tsquery</type></entry>
-->
        <entry><type>tsquery</type>のインデックス付け可能部分の取得</entry>
        <entry><literal>querytree('foo &amp; ! bar'::tsquery)</literal></entry>
        <entry><literal>'foo'</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>setweight</primary>
         </indexterm>
         <literal><function>setweight(<replaceable class="parameter">vector</replaceable> <type>tsvector</type>, <replaceable class="parameter">weight</replaceable> <type>"char"</type>)</function></literal>
        </entry>
        <entry><type>tsvector</type></entry>
<!--
        <entry>assign <replaceable class="parameter">weight</replaceable> to each element of <replaceable class="parameter">vector</replaceable></entry>
-->
        <entry><replaceable class="parameter">vector</replaceable>の各要素に<replaceable class="parameter">weight</replaceable>を割り当てる</entry>
        <entry><literal>setweight('fat:2,4 cat:3 rat:5B'::tsvector, 'A')</literal></entry>
        <entry><literal>'cat':3A 'fat':2A,4A 'rat':5A</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>setweight</primary>
<!--
          <secondary>setweight for specific lexeme(s)</secondary>
-->
          <secondary>特定の語彙素に対するsetweight</secondary>
         </indexterm>
         <literal><function>setweight(<replaceable class="parameter">vector</replaceable> <type>tsvector</type>, <replaceable class="parameter">weight</replaceable> <type>"char"</type>, <replaceable class="parameter">lexemes</replaceable> <type>text[]</type>)</function></literal>
        </entry>
        <entry><type>tsvector</type></entry>
<!--
        <entry>assign <replaceable class="parameter">weight</replaceable> to elements of <replaceable class="parameter">vector</replaceable> that are listed in <replaceable class="parameter">lexemes</replaceable></entry>
-->
        <entry><replaceable class="parameter">lexemes</replaceable>に列挙された<replaceable class="parameter">vector</replaceable>の要素に<replaceable class="parameter">weight</replaceable>を割り当てる</entry>
        <entry><literal>setweight('fat:2,4 cat:3 rat:5B'::tsvector, 'A', '{cat,rat}')</literal></entry>
        <entry><literal>'cat':3A 'fat':2,4 'rat':5A</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>strip</primary>
         </indexterm>
         <literal><function>strip(<type>tsvector</type>)</function></literal>
        </entry>
        <entry><type>tsvector</type></entry>
<!--
        <entry>remove positions and weights from <type>tsvector</type></entry>
-->
        <entry><type>tsvector</type>から位置と重みを削除</entry>
        <entry><literal>strip('fat:2,4 cat:3 rat:5A'::tsvector)</literal></entry>
        <entry><literal>'cat' 'fat' 'rat'</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>to_tsquery</primary>
         </indexterm>
         <literal><function>to_tsquery(<optional> <replaceable class="parameter">config</replaceable> <type>regconfig</type> , </optional> <replaceable class="parameter">query</replaceable> <type>text</type>)</function></literal>
        </entry>
        <entry><type>tsquery</type></entry>
<!--
        <entry>normalize words and convert to <type>tsquery</type></entry>
-->
        <entry>単語（複数）を正規化し<type>tsquery</type>に変換</entry>
        <entry><literal>to_tsquery('english', 'The &amp; Fat &amp; Rats')</literal></entry>
        <entry><literal>'fat' &amp; 'rat'</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>to_tsvector</primary>
         </indexterm>
         <literal><function>to_tsvector(<optional> <replaceable class="parameter">config</replaceable> <type>regconfig</type> , </optional> <replaceable class="parameter">document</replaceable> <type>text</type>)</function></literal>
        </entry>
        <entry><type>tsvector</type></entry>
<!--
        <entry>reduce document text to <type>tsvector</type></entry>
-->
        <entry>ドキュメントテキストを<type>tsvector</type>に縮小</entry>
        <entry><literal>to_tsvector('english', 'The Fat Rats')</literal></entry>
        <entry><literal>'fat':2 'rat':3</literal></entry>
       </row>
       <row>
        <entry>
         <literal><function>to_tsvector(<optional> <replaceable class="parameter">config</replaceable> <type>regconfig</type> , </optional> <replaceable class="parameter">document</replaceable> <type>json(b)</type>)</function></literal>
        </entry>
        <entry><type>tsvector</type></entry>
        <entry>
<!--
          reduce each string value in the document to a <type>tsvector</type>, and then
          concatenate those in document order to produce a single <type>tsvector</type>
-->
ドキュメント内の各文字列の値を<type>tsvector</type>に縮小し、それを繋げて一つの<type>tsvector</type>にする
        </entry>
        <entry><literal>to_tsvector('english', '{"a": "The Fat Rats"}'::json)</literal></entry>
        <entry><literal>'fat':2 'rat':3</literal></entry>
       </row>
       <row>
        <entry>
         <literal><function>json(b)_to_tsvector(<optional> <replaceable class="parameter">config</replaceable> <type>regconfig</type>,
         </optional> <replaceable class="parameter">document</replaceable> <type>json(b)</type>,
         <replaceable class="parameter">filter</replaceable> <type>json(b)</type>)</function></literal>
        </entry>
        <entry><type>tsvector</type></entry>
        <entry>
<!--
          reduce each value in the document, specified by <replaceable class="parameter">filter</replaceable> to a <type>tsvector</type>,
          and then concatenate those in document order to produce a single <type>tsvector</type>.
          <replaceable class="parameter">filter</replaceable> is a <type>jsonb</type> array, that enumerates what kind of elements need to be included
          into the resulting <type>tsvector</type>. Possible values for <replaceable class="parameter">filter</replaceable> are
          <literal>"string"</literal> (to include all string values), <literal>"numeric"</literal> (to include all numeric values in the string format),
          <literal>"boolean"</literal> (to include all Boolean values in the string format <literal>"true"</literal>/<literal>"false"</literal>),
          <literal>"key"</literal> (to include all keys) or <literal>"all"</literal> (to include all above). These values
          can be combined together to include, e.g. all string and numeric values.
-->
<replaceable class="parameter">filter</replaceable>によって指定された文書中の各々の値を<type>tsvector</type>にまとめ、次に文書にあらわれる順にそれらを結合して単一の<type>tsvector</type>を生成します。
<replaceable class="parameter">filter</replaceable>は<type>jsonb</type>の配列で、結果の<type>tsvector</type>にどの種類の要素を含める必要があるのかを列挙します。
<replaceable class="parameter">filter</replaceable>に指定可能な値は、<literal>"string"</literal> (すべての文字列値を含める)、<literal>"numeric"</literal> (すべての文字列形式の数値を含める)、<literal>"key"</literal> (すべてのキーを含める)、<literal>"all"</literal> (それらすべてを含める)です。
これらの値は、たとえばすべての文字列と数値、のように組み合わせることができます。
        </entry>
        <entry><literal>json_to_tsvector('english', '{"a": "The Fat Rats", "b": 123}'::json, '["string", "numeric"]')</literal></entry>
        <entry><literal>'123':5 'fat':2 'rat':3</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>ts_delete</primary>
         </indexterm>
         <literal><function>ts_delete(<replaceable class="parameter">vector</replaceable> <type>tsvector</type>, <replaceable class="parameter">lexeme</replaceable> <type>text</type>)</function></literal>
        </entry>
        <entry><type>tsvector</type></entry>
<!--
        <entry>remove given <replaceable class="parameter">lexeme</replaceable> from <replaceable class="parameter">vector</replaceable></entry>
-->
        <entry><replaceable class="parameter">vector</replaceable>から指定の<replaceable class="parameter">lexeme</replaceable>を削除する</entry>
        <entry><literal>ts_delete('fat:2,4 cat:3 rat:5A'::tsvector, 'fat')</literal></entry>
        <entry><literal>'cat':3 'rat':5A</literal></entry>
       </row>
       <row>
        <entry>
         <!-- previous indexterm entry covers this too -->
         <literal><function>ts_delete(<replaceable class="parameter">vector</replaceable> <type>tsvector</type>, <replaceable class="parameter">lexemes</replaceable> <type>text[]</type>)</function></literal>
        </entry>
        <entry><type>tsvector</type></entry>
<!--
        <entry>remove any occurrence of lexemes in <replaceable class="parameter">lexemes</replaceable> from <replaceable class="parameter">vector</replaceable></entry>
-->
        <entry><replaceable class="parameter">vector</replaceable>から<replaceable class="parameter">lexemes</replaceable>内にある語彙素の出現のすべてを削除する</entry>
        <entry><literal>ts_delete('fat:2,4 cat:3 rat:5A'::tsvector, ARRAY['fat','rat'])</literal></entry>
        <entry><literal>'cat':3</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>ts_filter</primary>
         </indexterm>
         <literal><function>ts_filter(<replaceable class="parameter">vector</replaceable> <type>tsvector</type>, <replaceable class="parameter">weights</replaceable> <type>"char"[]</type>)</function></literal>
        </entry>
        <entry><type>tsvector</type></entry>
<!--
        <entry>select only elements with given <replaceable class="parameter">weights</replaceable> from <replaceable class="parameter">vector</replaceable></entry>
-->
        <entry><replaceable class="parameter">vector</replaceable>から指定の<replaceable class="parameter">weights</replaceable>の要素のみを選択する</entry>
        <entry><literal>ts_filter('fat:2,4 cat:3b rat:5A'::tsvector, '{a,b}')</literal></entry>
        <entry><literal>'cat':3B 'rat':5A</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>ts_headline</primary>
         </indexterm>
         <literal><function>ts_headline(<optional> <replaceable class="parameter">config</replaceable> <type>regconfig</type>, </optional> <replaceable class="parameter">document</replaceable> <type>text</type>, <replaceable class="parameter">query</replaceable> <type>tsquery</type> <optional>, <replaceable class="parameter">options</replaceable> <type>text</type> </optional>)</function></literal>
        </entry>
        <entry><type>text</type></entry>
<!--
        <entry>display a query match</entry>
-->
        <entry>問い合わせによるマッチを表示</entry>
        <entry><literal>ts_headline('x y z', 'z'::tsquery)</literal></entry>
        <entry><literal>x y &lt;b&gt;z&lt;/b&gt;</literal></entry>
       </row>
       <row>
        <entry>
         <literal><function>ts_headline(<optional> <replaceable class="parameter">config</replaceable> <type>regconfig</type>, </optional> <replaceable class="parameter">document</replaceable> <type>json(b)</type>, <replaceable class="parameter">query</replaceable> <type>tsquery</type> <optional>, <replaceable class="parameter">options</replaceable> <type>text</type> </optional>)</function></literal>
        </entry>
        <entry><type>text</type></entry>
<!--
        <entry>display a query match</entry>
-->
        <entry>問い合わせによるマッチを表示</entry>
        <entry><literal>ts_headline('{"a":"x y z"}'::json, 'z'::tsquery)</literal></entry>
        <entry><literal>{"a":"x y &lt;b&gt;z&lt;/b&gt;"}</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>ts_rank</primary>
         </indexterm>
         <literal><function>ts_rank(<optional> <replaceable class="parameter">weights</replaceable> <type>float4[]</type>, </optional> <replaceable class="parameter">vector</replaceable> <type>tsvector</type>, <replaceable class="parameter">query</replaceable> <type>tsquery</type> <optional>, <replaceable class="parameter">normalization</replaceable> <type>integer</type> </optional>)</function></literal>
        </entry>
        <entry><type>float4</type></entry>
<!--
        <entry>rank document for query</entry>
-->
        <entry>問い合わせのためのドキュメント順位付け</entry>
        <entry><literal>ts_rank(textsearch, query)</literal></entry>
        <entry><literal>0.818</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>ts_rank_cd</primary>
         </indexterm>
         <literal><function>ts_rank_cd(<optional> <replaceable class="parameter">weights</replaceable> <type>float4[]</type>, </optional> <replaceable class="parameter">vector</replaceable> <type>tsvector</type>, <replaceable class="parameter">query</replaceable> <type>tsquery</type> <optional>, <replaceable class="parameter">normalization</replaceable> <type>integer</type> </optional>)</function></literal>
        </entry>
        <entry><type>float4</type></entry>
<!--
        <entry>rank document for query using cover density</entry>
-->
        <entry>被覆密度を用いた問い合わせのためのドキュメント順位付け</entry>
        <entry><literal>ts_rank_cd('{0.1, 0.2, 0.4, 1.0}', textsearch, query)</literal></entry>
        <entry><literal>2.01317</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>ts_rewrite</primary>
         </indexterm>
         <literal><function>ts_rewrite(<replaceable class="parameter">query</replaceable> <type>tsquery</type>, <replaceable class="parameter">target</replaceable> <type>tsquery</type>, <replaceable class="parameter">substitute</replaceable> <type>tsquery</type>)</function></literal>
        </entry>
        <entry><type>tsquery</type></entry>
<!--
        <entry>replace <replaceable>target</replaceable> with <replaceable>substitute</replaceable>
         within query</entry>
-->
        <entry>問い合わせ内の<replaceable>target</replaceable>を<replaceable>substitute</replaceable>で置換する</entry>
        <entry><literal>ts_rewrite('a &amp; b'::tsquery, 'a'::tsquery, 'foo|bar'::tsquery)</literal></entry>
        <entry><literal>'b' &amp; ( 'foo' | 'bar' )</literal></entry>
       </row>
       <row>
        <entry><literal><function>ts_rewrite(<replaceable class="parameter">query</replaceable> <type>tsquery</type>, <replaceable class="parameter">select</replaceable> <type>text</type>)</function></literal></entry>
        <entry><type>tsquery</type></entry>
<!--
        <entry>replace using targets and substitutes from a <command>SELECT</command> command</entry>
-->
        <entry><command>SELECT</command>から対象と代替を使用して置換</entry>
        <entry><literal>SELECT ts_rewrite('a &amp; b'::tsquery, 'SELECT t,s FROM aliases')</literal></entry>
        <entry><literal>'b' &amp; ( 'foo' | 'bar' )</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>tsquery_phrase</primary>
         </indexterm>
         <literal><function>tsquery_phrase(<replaceable class="parameter">query1</replaceable> <type>tsquery</type>, <replaceable class="parameter">query2</replaceable> <type>tsquery</type>)</function></literal>
        </entry>
        <entry><type>tsquery</type></entry>
<!--
        <entry>make query that searches for <replaceable>query1</replaceable> followed
         by <replaceable>query2</replaceable> (same as <literal>&lt;-&gt;</literal>
         operator)</entry>
-->
        <entry><replaceable>query1</replaceable>の後に<replaceable>query2</replaceable>が続くものを検索する問い合わせを作成する（<literal>&lt;-&gt;</literal>演算子と同じ）</entry>
        <entry><literal>tsquery_phrase(to_tsquery('fat'), to_tsquery('cat'))</literal></entry>
        <entry><literal>'fat' &lt;-&gt; 'cat'</literal></entry>
       </row>
       <row>
        <entry>
         <literal><function>tsquery_phrase(<replaceable class="parameter">query1</replaceable> <type>tsquery</type>, <replaceable class="parameter">query2</replaceable> <type>tsquery</type>, <replaceable class="parameter">distance</replaceable> <type>integer</type>)</function></literal>
        </entry>
        <entry><type>tsquery</type></entry>
<!--
        <entry>make query that searches for <replaceable>query1</replaceable> followed by
         <replaceable>query2</replaceable> at distance <replaceable>distance</replaceable></entry>
-->
        <entry><replaceable>query1</replaceable>の後に<replaceable>distance</replaceable>の距離で<replaceable>query2</replaceable>があるものを検索する問い合わせを作成する</entry>
        <entry><literal>tsquery_phrase(to_tsquery('fat'), to_tsquery('cat'), 10)</literal></entry>
        <entry><literal>'fat' &lt;10&gt; 'cat'</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>tsvector_to_array</primary>
         </indexterm>
         <literal><function>tsvector_to_array(<type>tsvector</type>)</function></literal>
        </entry>
        <entry><type>text[]</type></entry>
<!--
        <entry>convert <type>tsvector</type> to array of lexemes</entry>
-->
        <entry><type>tsvector</type>を語彙素の配列に変換する</entry>
        <entry><literal>tsvector_to_array('fat:2,4 cat:3 rat:5A'::tsvector)</literal></entry>
        <entry><literal>{cat,fat,rat}</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>tsvector_update_trigger</primary>
         </indexterm>
         <literal><function>tsvector_update_trigger()</function></literal>
        </entry>
        <entry><type>trigger</type></entry>
<!--
        <entry>trigger function for automatic <type>tsvector</type> column update</entry>
-->
        <entry><type>tsvector</type>列の自動更新のためのトリガ関数</entry>
        <entry><literal>CREATE TRIGGER ... tsvector_update_trigger(tsvcol, 'pg_catalog.swedish', title, body)</literal></entry>
        <entry><literal></literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>tsvector_update_trigger_column</primary>
         </indexterm>
         <literal><function>tsvector_update_trigger_column()</function></literal>
        </entry>
        <entry><type>trigger</type></entry>
<!--
        <entry>trigger function for automatic <type>tsvector</type> column update</entry>
-->
        <entry><type>tsvector</type>列の自動更新のためのトリガ関数</entry>
        <entry><literal>CREATE TRIGGER ... tsvector_update_trigger_column(tsvcol, configcol, title, body)</literal></entry>
        <entry><literal></literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>unnest</primary>
<!--
          <secondary>for tsvector</secondary>
-->
          <secondary>tsvector用の</secondary>
         </indexterm>
         <literal><function>unnest(<type>tsvector</type>, OUT <replaceable class="parameter">lexeme</replaceable> <type>text</type>, OUT <replaceable class="parameter">positions</replaceable> <type>smallint[]</type>, OUT <replaceable class="parameter">weights</replaceable> <type>text</type>)</function></literal>
        </entry>
        <entry><type>setof record</type></entry>
<!--
        <entry>expand a <type>tsvector</type> to a set of rows</entry>
-->
        <entry><type>tsvector</type>を行の集合に展開する</entry>
        <entry><literal>unnest('fat:2,4 cat:3 rat:5A'::tsvector)</literal></entry>
        <entry><literal>(cat,{3},{D}) ...</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

  <note>
   <para>
<!--
    All the text search functions that accept an optional <type>regconfig</type>
    argument will use the configuration specified by
    <xref linkend="guc-default-text-search-config"/>
    when that argument is omitted.
-->
オプションの<type>regconfig</type>引数を受け付ける全てのテキスト検索関数は、その引数が省略された場合<xref linkend="guc-default-text-search-config"/>で指定された構成を使用します。
   </para>
  </note>

  <para>
<!--
   The functions in
   <xref linkend="textsearch-functions-debug-table"/>
   are listed separately because they are not usually used in everyday text
   searching operations.  They are helpful for development and debugging
   of new text search configurations.
-->
<xref linkend="textsearch-functions-debug-table"/>の関数は、日常のテキスト検索操作では通常使用されないので、別の表にしました。
これらは新しいテキスト検索設定の開発およびデバッグに役立ちます。
  </para>

    <table id="textsearch-functions-debug-table">
<!--
     <title>Text Search Debugging Functions</title>
-->
     <title>テキスト検索デバッグ関数</title>
     <tgroup cols="5">
      <thead>
       <row>
<!--
        <entry>Function</entry>
        <entry>Return Type</entry>
        <entry>Description</entry>
        <entry>Example</entry>
        <entry>Result</entry>
-->
        <entry>関数</entry>
        <entry>戻り値型</entry>
        <entry>説明</entry>
        <entry>例</entry>
        <entry>結果</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>
         <indexterm>
          <primary>ts_debug</primary>
         </indexterm>
         <literal><function>ts_debug(<optional> <replaceable class="parameter">config</replaceable> <type>regconfig</type>, </optional> <replaceable class="parameter">document</replaceable> <type>text</type>, OUT <replaceable class="parameter">alias</replaceable> <type>text</type>, OUT <replaceable class="parameter">description</replaceable> <type>text</type>, OUT <replaceable class="parameter">token</replaceable> <type>text</type>, OUT <replaceable class="parameter">dictionaries</replaceable> <type>regdictionary[]</type>, OUT <replaceable class="parameter">dictionary</replaceable> <type>regdictionary</type>, OUT <replaceable class="parameter">lexemes</replaceable> <type>text[]</type>)</function></literal>
        </entry>
        <entry><type>setof record</type></entry>
<!--
        <entry>test a configuration</entry>
-->
        <entry>構成を検査</entry>
        <entry><literal>ts_debug('english', 'The Brightest supernovaes')</literal></entry>
        <entry><literal>(asciiword,"Word, all ASCII",The,{english_stem},english_stem,{}) ...</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>ts_lexize</primary>
         </indexterm>
         <literal><function>ts_lexize(<replaceable class="parameter">dict</replaceable> <type>regdictionary</type>, <replaceable class="parameter">token</replaceable> <type>text</type>)</function></literal>
        </entry>
        <entry><type>text[]</type></entry>
<!--
        <entry>test a dictionary</entry>
-->
        <entry>辞書を検査</entry>
        <entry><literal>ts_lexize('english_stem', 'stars')</literal></entry>
        <entry><literal>{star}</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>ts_parse</primary>
         </indexterm>
         <literal><function>ts_parse(<replaceable class="parameter">parser_name</replaceable> <type>text</type>, <replaceable class="parameter">document</replaceable> <type>text</type>, OUT <replaceable class="parameter">tokid</replaceable> <type>integer</type>, OUT <replaceable class="parameter">token</replaceable> <type>text</type>)</function></literal>
        </entry>
        <entry><type>setof record</type></entry>
<!--
        <entry>test a parser</entry>
-->
        <entry>パーサを検査</entry>
        <entry><literal>ts_parse('default', 'foo - bar')</literal></entry>
        <entry><literal>(1,foo) ...</literal></entry>
       </row>
       <row>
        <entry><literal><function>ts_parse(<replaceable class="parameter">parser_oid</replaceable> <type>oid</type>, <replaceable class="parameter">document</replaceable> <type>text</type>, OUT <replaceable class="parameter">tokid</replaceable> <type>integer</type>, OUT <replaceable class="parameter">token</replaceable> <type>text</type>)</function></literal></entry>
        <entry><type>setof record</type></entry>
<!--
        <entry>test a parser</entry>
-->
        <entry>パーサを検査</entry>
        <entry><literal>ts_parse(3722, 'foo - bar')</literal></entry>
        <entry><literal>(1,foo) ...</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>ts_token_type</primary>
         </indexterm>
         <literal><function>ts_token_type(<replaceable class="parameter">parser_name</replaceable> <type>text</type>, OUT <replaceable class="parameter">tokid</replaceable> <type>integer</type>, OUT <replaceable class="parameter">alias</replaceable> <type>text</type>, OUT <replaceable class="parameter">description</replaceable> <type>text</type>)</function></literal>
        </entry>
        <entry><type>setof record</type></entry>
<!--
        <entry>get token types defined by parser</entry>
-->
    <entry>パーサで定義されたトークンの型を入手</entry>
        <entry><literal>ts_token_type('default')</literal></entry>
        <entry><literal>(1,asciiword,"Word, all ASCII") ...</literal></entry>
       </row>
       <row>
        <entry><literal><function>ts_token_type(<replaceable class="parameter">parser_oid</replaceable> <type>oid</type>, OUT <replaceable class="parameter">tokid</replaceable> <type>integer</type>, OUT <replaceable class="parameter">alias</replaceable> <type>text</type>, OUT <replaceable class="parameter">description</replaceable> <type>text</type>)</function></literal></entry>
        <entry><type>setof record</type></entry>
<!--
        <entry>get token types defined by parser</entry>
-->
        <entry>パーサで定義されたトークンの型を入手</entry>
        <entry><literal>ts_token_type(3722)</literal></entry>
        <entry><literal>(1,asciiword,"Word, all ASCII") ...</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>ts_stat</primary>
         </indexterm>
         <literal><function>ts_stat(<replaceable class="parameter">sqlquery</replaceable> <type>text</type>, <optional> <replaceable class="parameter">weights</replaceable> <type>text</type>, </optional> OUT <replaceable class="parameter">word</replaceable> <type>text</type>, OUT <replaceable class="parameter">ndoc</replaceable> <type>integer</type>, OUT <replaceable class="parameter">nentry</replaceable> <type>integer</type>)</function></literal>
        </entry>
        <entry><type>setof record</type></entry>
<!--
        <entry>get statistics of a <type>tsvector</type> column</entry>
-->
        <entry><type>tsvector</type>列の統計情報を入手</entry>
        <entry><literal>ts_stat('SELECT vector from apod')</literal></entry>
        <entry><literal>(foo,10,15) ...</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

 </sect1>


 <sect1 id="functions-xml">

<!--
  <title>XML Functions</title>
-->
  <title>XML関数</title>

  <indexterm>
   <primary>XML Functions</primary>
  </indexterm>

  <para>
<!--
   The functions and function-like expressions described in this
   section operate on values of type <type>xml</type>.  See <xref
   linkend="datatype-xml"/> for information about the <type>xml</type>
   type.  The function-like expressions <function>xmlparse</function>
   and <function>xmlserialize</function> for converting to and from
   type <type>xml</type> are documented there, not in this section.
-->
この節で説明される関数および擬似関数式は、<type>xml</type>型の値に対して機能します。
<type>xml</type>型についての情報は<xref linkend="datatype-xml"/>を点検してください。
<type>xml</type>型のやりとりを変換する<function>xmlparse</function>および<function>xmlserialize</function>擬似関数式はここでは繰り返しません。
これらの多くの関数を使用するには、インストレーションの際<command>configure --with-libxml</command>付きでビルドされていることが必要です。
  </para>

  <para>
   Use of most of these functions
   requires <productname>PostgreSQL</productname> to have been built
   with <command>configure &#045;&#045;with-libxml</command>.
  </para>

  <sect2 id="functions-producing-xml">
<!--
   <title>Producing XML Content</title>
-->
   <title>XML内容の生成</title>

   <para>
<!--
    A set of functions and function-like expressions are available for
    producing XML content from SQL data.  As such, they are
    particularly suitable for formatting query results into XML
    documents for processing in client applications.
-->
SQLデータからXML内容を生成するために関数と擬似関数式の一式が提供されています。
そのようなものとして、クライアントアプリケーションが問い合わせ結果を処理のためXML文書に書式化するのにこれらは特に適しています。
   </para>

   <sect3>
    <title><literal>xmlcomment</literal></title>

    <indexterm>
     <primary>xmlcomment</primary>
    </indexterm>

<synopsis>
<function>xmlcomment</function>(<replaceable>text</replaceable>)
</synopsis>

    <para>
<!--
     The function <function>xmlcomment</function> creates an XML value
     containing an XML comment with the specified text as content.
     The text cannot contain <quote><literal>&#045;-</literal></quote> or end with a
     <quote><literal>-</literal></quote> so that the resulting construct is a valid
     XML comment.  If the argument is null, the result is null.
-->
関数<function>xmlcomment</function>は指定のテキストを内容とするXMLコメントを含んだXML値を作成します。
結果として構築されるXMLコメントが有効になるよう、テキストは<quote><literal>--</literal></quote>を含むこと、または<quote><literal>-</literal></quote>で終結することはできません。
引数がNULLならば結果もNULLになります。
    </para>

    <para>
<!--
     Example:
-->
例：
<screen><![CDATA[
SELECT xmlcomment('hello');

  xmlcomment
--------------
 <!--hello-->
]]></screen>
    </para>
   </sect3>

   <sect3>
    <title><literal>xmlconcat</literal></title>

    <indexterm>
     <primary>xmlconcat</primary>
    </indexterm>

<synopsis>
<function>xmlconcat</function>(<replaceable>xml</replaceable><optional>, ...</optional>)
</synopsis>

    <para>
<!--
     The function <function>xmlconcat</function> concatenates a list
     of individual XML values to create a single value containing an
     XML content fragment.  Null values are omitted; the result is
     only null if there are no nonnull arguments.
-->
関数<function>xmlconcat</function>は、個々のXML値のリストを結合し、XMLの内容断片を含む単一の値を作成します。
NULL値は削除され、NULL以外の引数が存在しないときのみ結果はNULLになります。
    </para>

    <para>
<!--
     Example:
-->
例：
<screen><![CDATA[
SELECT xmlconcat('<abc/>', '<bar>foo</bar>');

      xmlconcat
----------------------
 <abc/><bar>foo</bar>
]]></screen>
    </para>

    <para>
<!--
     XML declarations, if present, are combined as follows.  If all
     argument values have the same XML version declaration, that
     version is used in the result, else no version is used.  If all
     argument values have the standalone declaration value
     <quote>yes</quote>, then that value is used in the result.  If
     all argument values have a standalone declaration value and at
     least one is <quote>no</quote>, then that is used in the result.
     Else the result will have no standalone declaration.  If the
     result is determined to require a standalone declaration but no
     version declaration, a version declaration with version 1.0 will
     be used because XML requires an XML declaration to contain a
     version declaration.  Encoding declarations are ignored and
     removed in all cases.
-->
XML宣言が提示されている場合は次のように組み合わされます。
全ての引数の値が同一のXMLversion宣言を持っていれば、そのversionが結果に使用されます。さもなければversionは使用されません。
全ての引数の値でstandaloneの宣言値が<quote>yes</quote>であれば、その値が結果に使用されます。
全ての引数の値にstandalone宣言値があり、その中で１つでも<quote>no</quote>がある場合、それが結果に使用されます。
それ以外の場合は、結果はstandalone宣言を持ちません。
standalone宣言を必要とするが、standalone宣言がないという結果になった場合には、version 1.0のversion宣言が使用されます。
これはXMLがXML宣言においてversion宣言を含むことを要求するためです。
encoding宣言は無視され、全ての場合で削除されます。
    </para>

    <para>
<!--
     Example:
-->
例：
<screen><![CDATA[
SELECT xmlconcat('<?xml version="1.1"?><foo/>', '<?xml version="1.1" standalone="no"?><bar/>');

             xmlconcat
-----------------------------------
 <?xml version="1.1"?><foo/><bar/>
]]></screen>
    </para>
   </sect3>

   <sect3>
    <title><literal>xmlelement</literal></title>

   <indexterm>
    <primary>xmlelement</primary>
   </indexterm>

<synopsis>
<function>xmlelement</function>(name <replaceable>name</replaceable> <optional>, xmlattributes(<replaceable>value</replaceable> <optional>AS <replaceable>attname</replaceable></optional> <optional>, ... </optional>)</optional> <optional><replaceable>, content, ...</replaceable></optional>)
</synopsis>

    <para>
<!--
     The <function>xmlelement</function> expression produces an XML
     element with the given name, attributes, and content.
-->
<function>xmlelement</function>式は与えられた名前、属性、および内容を持つXML要素を生成します。
    </para>

    <para>
<!--
     Examples:
-->
例：
<screen><![CDATA[
SELECT xmlelement(name foo);

 xmlelement
------------
 <foo/>

SELECT xmlelement(name foo, xmlattributes('xyz' as bar));

    xmlelement
------------------
 <foo bar="xyz"/>

SELECT xmlelement(name foo, xmlattributes(current_date as bar), 'cont', 'ent');

             xmlelement
-------------------------------------
 <foo bar="2007-01-26">content</foo>
]]></screen>
    </para>

    <para>
<!--
     Element and attribute names that are not valid XML names are
     escaped by replacing the offending characters by the sequence
     <literal>_x<replaceable>HHHH</replaceable>_</literal>, where
     <replaceable>HHHH</replaceable> is the character's Unicode
     codepoint in hexadecimal notation.  For example:
-->
有効なXML名ではない要素名と属性名は、シーケンス<literal>_x<replaceable>HHHH</replaceable>_</literal>により障害となる文字を置換することでエスケープされます。ここで、<replaceable>HHHH</replaceable>は16進数によるその文字のUnicode文字コード番号です。
例をあげます。
<screen><![CDATA[
SELECT xmlelement(name "foo$bar", xmlattributes('xyz' as "a&b"));

            xmlelement
----------------------------------
 <foo_x0024_bar a_x0026_b="xyz"/>
]]></screen>
    </para>

    <para>
<!--
     An explicit attribute name need not be specified if the attribute
     value is a column reference, in which case the column's name will
     be used as the attribute name by default.  In other cases, the
     attribute must be given an explicit name.  So this example is
     valid:
-->
属性値が列参照の場合、明示的な属性名を指定する必要はありません。この場合、デフォルトで列名が属性名として使用されます。
その他の場合には、属性は明示的な名前で与えられなければなりません。
従って、以下の例は有効です。
<screen>
CREATE TABLE test (a xml, b xml);
SELECT xmlelement(name test, xmlattributes(a, b)) FROM test;
</screen>
<!--
     But these are not:
-->
しかし、以下の例は有効ではありません。
<screen>
SELECT xmlelement(name test, xmlattributes('constant'), a, b) FROM test;
SELECT xmlelement(name test, xmlattributes(func(a, b))) FROM test;
</screen>
    </para>

    <para>
<!--
     Element content, if specified, will be formatted according to
     its data type.  If the content is itself of type <type>xml</type>,
     complex XML documents can be constructed.  For example:
-->
もし要素内容が指定されればそのデータ型に従って書式化されます。
もし内容そのものが<type>xml</type>型であれば、複合XML文書が構築されます。
例をあげます。
<screen><![CDATA[
SELECT xmlelement(name foo, xmlattributes('xyz' as bar),
                            xmlelement(name abc),
                            xmlcomment('test'),
                            xmlelement(name xyz));

                  xmlelement
----------------------------------------------
 <foo bar="xyz"><abc/><!--test--><xyz/></foo>
]]></screen>

<!--
     Content of other types will be formatted into valid XML character
     data.  This means in particular that the characters &lt;, &gt;,
     and &amp; will be converted to entities.  Binary data (data type
     <type>bytea</type>) will be represented in base64 or hex
     encoding, depending on the setting of the configuration parameter
     <xref linkend="guc-xmlbinary"/>.  The particular behavior for
     individual data types is expected to evolve in order to align the
     PostgreSQL mappings with those specified in SQL:2006 and later,
     as discussed in <xref linkend="functions-xml-limits-casts"/>.
-->
そのほかの型の内容は有効なXML文字データにフォーマットされます。
これは特に文字&lt;、&gt;、および&amp;がエンティティに変換されることを意味します。
バイナリデータ（データ型は<type>bytea</type>）は、設定パラメータ<xref linkend="guc-xmlbinary"/>の設定にしたがって、base64もしくは16進符号化方式で表現されます。
個々のデータ型に対する特定の動作は、XMLスキーマ仕様でのSQLおよびPostgreSQLデータ型に調整するため発展すると期待されます。
その時点で記述がより詳細になるでしょう。
    </para>
   </sect3>

   <sect3>
    <title><literal>xmlforest</literal></title>

   <indexterm>
    <primary>xmlforest</primary>
   </indexterm>

<synopsis>
<function>xmlforest</function>(<replaceable>content</replaceable> <optional>AS <replaceable>name</replaceable></optional> <optional>, ...</optional>)
</synopsis>

    <para>
<!--
     The <function>xmlforest</function> expression produces an XML
     forest (sequence) of elements using the given names and content.
-->
<function>xmlforest</function>式は与えられた名前と内容を使用し、要素のXMLフォレスト（シーケンス）を生成します。
    </para>

    <para>
<!--
     Examples:
-->
例：
<screen><![CDATA[
SELECT xmlforest('abc' AS foo, 123 AS bar);

          xmlforest
------------------------------
 <foo>abc</foo><bar>123</bar>


SELECT xmlforest(table_name, column_name)
FROM information_schema.columns
WHERE table_schema = 'pg_catalog';

                                         xmlforest
-------------------------------------------------------------------------------------------
 <table_name>pg_authid</table_name><column_name>rolname</column_name>
 <table_name>pg_authid</table_name><column_name>rolsuper</column_name>
 ...
]]></screen>

<!--
     As seen in the second example, the element name can be omitted if
     the content value is a column reference, in which case the column
     name is used by default.  Otherwise, a name must be specified.
-->
第２の例に見られるように、内容の値が列参照の場合、要素名は省略可能です。この時は、列名がデフォルトで使用されます。
そうでない時は、名前が指定されなければなりません。
    </para>

    <para>
<!--
     Element names that are not valid XML names are escaped as shown
     for <function>xmlelement</function> above.  Similarly, content
     data is escaped to make valid XML content, unless it is already
     of type <type>xml</type>.
-->
有効なXML名ではない要素名は上の<function>xmlelement</function>で説明した通りエスケープされます。
同様にして、既に<type>xml</type>型であるものを除き、内容データは有効なXML内容になるようにエスケープされます。
    </para>

    <para>
<!--
     Note that XML forests are not valid XML documents if they consist
     of more than one element, so it might be useful to wrap
     <function>xmlforest</function> expressions in
     <function>xmlelement</function>.
-->
XMLフォレストは２つ以上の要素からなる場合、有効なXML文書ではないことに注意してください。
したがって、<function>xmlelement</function>内に<function>xmlforest</function>式をラップすることが有用なことがあります。
    </para>
   </sect3>

   <sect3>
    <title><literal>xmlpi</literal></title>

   <indexterm>
    <primary>xmlpi</primary>
   </indexterm>

<synopsis>
<function>xmlpi</function>(name <replaceable>target</replaceable> <optional>, <replaceable>content</replaceable></optional>)
</synopsis>

    <para>
<!--
     The <function>xmlpi</function> expression creates an XML
     processing instruction.  The content, if present, must not
     contain the character sequence <literal>?&gt;</literal>.
-->
<function>xmlpi</function>式はXML処理命令を作成します。
内容が存在すれば、その内容は<literal>?&gt;</literal>文字シーケンスを含んではなりません。
    </para>

    <para>
<!--
     Example:
-->
例：
<screen><![CDATA[
SELECT xmlpi(name php, 'echo "hello world";');

            xmlpi
-----------------------------
 <?php echo "hello world";?>
]]></screen>
    </para>
   </sect3>

   <sect3>
    <title><literal>xmlroot</literal></title>

   <indexterm>
    <primary>xmlroot</primary>
   </indexterm>

<synopsis>
<function>xmlroot</function>(<replaceable>xml</replaceable>, version <replaceable>text</replaceable> | no value <optional>, standalone yes|no|no value</optional>)
</synopsis>

    <para>
<!--
     The <function>xmlroot</function> expression alters the properties
     of the root node of an XML value.  If a version is specified,
     it replaces the value in the root node's version declaration; if a
     standalone setting is specified, it replaces the value in the
     root node's standalone declaration.
-->
<function>xmlroot</function>式はXML値のルートノードの属性を変更します。
versionが指定されていると、ルートノードのversion宣言での値を変更し、standalone設定が指定されていると、ルートノードのstandalone宣言での値を変更します。
    </para>

    <para>
<screen><![CDATA[
SELECT xmlroot(xmlparse(document '<?xml version="1.1"?><content>abc</content>'),
               version '1.0', standalone yes);

                xmlroot
----------------------------------------
 <?xml version="1.0" standalone="yes"?>
 <content>abc</content>
]]></screen>
    </para>
   </sect3>

   <sect3 id="functions-xml-xmlagg">
    <title><literal>xmlagg</literal></title>

    <indexterm>
     <primary>xmlagg</primary>
    </indexterm>

<synopsis>
<function>xmlagg</function>(<replaceable>xml</replaceable>)
</synopsis>

    <para>
<!--
     The function <function>xmlagg</function> is, unlike the other
     functions described here, an aggregate function.  It concatenates the
     input values to the aggregate function call,
     much like <function>xmlconcat</function> does, except that concatenation
     occurs across rows rather than across expressions in a single row.
     See <xref linkend="functions-aggregate"/> for additional information
     about aggregate functions.
-->
ここで説明している他の関数とは異なり、<function>xmlagg</function>関数は集約関数です。
これは<function>xmlconcat</function>が行うように、入力値を連結する集約関数ですが、単一行内の複数の式にまたがった連結ではなく、複数行にまたがった連結を行います。
集約関数についての追加情報は<xref linkend="functions-aggregate"/>を参照してください。
    </para>

    <para>
<!--
     Example:
-->
例：
<screen><![CDATA[
CREATE TABLE test (y int, x xml);
INSERT INTO test VALUES (1, '<foo>abc</foo>');
INSERT INTO test VALUES (2, '<bar/>');
SELECT xmlagg(x) FROM test;
        xmlagg
----------------------
 <foo>abc</foo><bar/>
]]></screen>
    </para>

    <para>
<!--
     To determine the order of the concatenation, an <literal>ORDER BY</literal>
     clause may be added to the aggregate call as described in
     <xref linkend="syntax-aggregates"/>. For example:
-->
連結の順序を決定するため、<xref linkend="syntax-aggregates"/>に記述されているように<literal>ORDER BY</literal>句を集計呼び出しに追加することができます。
以下は例です。

<screen><![CDATA[
SELECT xmlagg(x ORDER BY y DESC) FROM test;
        xmlagg
----------------------
 <bar/><foo>abc</foo>
]]></screen>
    </para>

    <para>
<!--
     The following non-standard approach used to be recommended
     in previous versions, and may still be useful in specific
     cases:
-->
下記は以前のバージョンで推奨されていた、非標準的な方法例です。特定のケースでは有用かもしれません。

<screen><![CDATA[
SELECT xmlagg(x) FROM (SELECT * FROM test ORDER BY y DESC) AS tab;
        xmlagg
----------------------
 <bar/><foo>abc</foo>
]]></screen>
    </para>
   </sect3>
   </sect2>

   <sect2 id="functions-xml-predicates">
<!--
    <title>XML Predicates</title>
-->
    <title>XML述語</title>

    <para>
<!--
     The expressions described in this section check properties
     of <type>xml</type> values.
-->
この節で記述されている式は、<type>xml</type>値の属性をチェックします。
    </para>

   <sect3>
    <title><literal>IS DOCUMENT</literal></title>

    <indexterm>
     <primary>IS DOCUMENT</primary>
    </indexterm>

<synopsis>
<replaceable>xml</replaceable> IS DOCUMENT
</synopsis>

    <para>
<!--
     The expression <literal>IS DOCUMENT</literal> returns true if the
     argument XML value is a proper XML document, false if it is not
     (that is, it is a content fragment), or null if the argument is
     null.  See <xref linkend="datatype-xml"/> about the difference
     between documents and content fragments.
-->
式<literal>IS DOCUMENT</literal>は引数XML値が適切なXML文書であれば真を返し、そうでなければ（つまり、内容の断片）偽を返すか、もしくは引数がNULLであればNULLを返します。
文書と内容の断片の差異については<xref linkend="datatype-xml"/>を参照してください。
    </para>
   </sect3>

   <sect3>
    <title><literal>IS NOT DOCUMENT</literal></title>

    <indexterm>
     <primary>IS NOT DOCUMENT</primary>
    </indexterm>

<synopsis>
<replaceable>xml</replaceable> IS NOT DOCUMENT
</synopsis>

    <para>
<!--
     The expression <literal>IS NOT DOCUMENT</literal> returns false if the
     argument XML value is a proper XML document, true if it is not (that is,
     it is a content fragment), or null if the argument is null.
-->
式<literal>IS NOT DOCUMENT</literal>は引数XML値が適切なXML文書であれば偽を返し、そうでなければ（つまり、内容の断片）真を返すか、もしくは引数がNULLであればNULLを返します。
    </para>
   </sect3>

   <sect3 id="xml-exists">
    <title><literal>XMLEXISTS</literal></title>

    <indexterm>
     <primary>XMLEXISTS</primary>
    </indexterm>

<synopsis>
<function>XMLEXISTS</function>(<replaceable>text</replaceable> PASSING <optional>BY { REF | VALUE }</optional> <replaceable>xml</replaceable> <optional>BY { REF | VALUE }</optional>)
</synopsis>

    <para>
<!--
     The function <function>xmlexists</function> evaluates an XPath 1.0
     expression (the first argument), with the passed XML value as its context
     item.  The function returns false if the result of that evaluation
     yields an empty node-set, true if it yields any other value.  The
     function returns null if any argument is null.  A nonnull value
     passed as the context item must be an XML document, not a content
     fragment or any non-XML value.
-->
関数<function>xmlexists</function>は第一引数のXPath式が何かしらのノードであれば真を返し、そうでなければ偽を返します。
(もしいずれの引数もNULLであった場合はNULLを返します。)
    </para>

    <para>
<!--
     Example:
-->
例:
     <screen><![CDATA[
SELECT xmlexists('//town[text() = ''Toronto'']' PASSING BY VALUE '<towns><town>Toronto</town><town>Ottawa</town></towns>');

 xmlexists
------------
 t
(1 row)
]]></screen>
    </para>

    <para>
<!--
     The <literal>BY REF</literal> and <literal>BY VALUE</literal> clauses
     are accepted in <productname>PostgreSQL</productname>, but are ignored,
     as discussed in <xref linkend="functions-xml-limits-postgresql"/>.
     In the SQL standard, the <function>xmlexists</function> function
     evaluates an expression in the XML Query language,
     but <productname>PostgreSQL</productname> allows only an XPath 1.0
     expression, as discussed in
     <xref linkend="functions-xml-limits-xpath1"/>.
-->
<literal>BY REF</literal>句は、PostgreSQLには何の影響も与えませんが、他の実装とのSQL互換性や順応性のため、付与することができます。
SQL標準では1つ目の<literal>BY REF</literal>を必要としており、2つ目はオプショナルです。
加えてSQL標準では<function>xmlexists</function>はXQuery式を第一引数として取る構成としていますが、PostgreSQLでは現在XQueryのサブセットにあたるXPathのみサポートしていることに注意してください。
    </para>
   </sect3>

   <sect3 id="xml-is-well-formed">
    <title><literal>xml_is_well_formed</literal></title>

    <indexterm>
     <primary>xml_is_well_formed</primary>
    </indexterm>

    <indexterm>
     <primary>xml_is_well_formed_document</primary>
    </indexterm>

    <indexterm>
     <primary>xml_is_well_formed_content</primary>
    </indexterm>

<synopsis>
<function>xml_is_well_formed</function>(<replaceable>text</replaceable>)
<function>xml_is_well_formed_document</function>(<replaceable>text</replaceable>)
<function>xml_is_well_formed_content</function>(<replaceable>text</replaceable>)
</synopsis>

    <para>
<!--
     These functions check whether a <type>text</type> string is well-formed XML,
     returning a Boolean result.
     <function>xml_is_well_formed_document</function> checks for a well-formed
     document, while <function>xml_is_well_formed_content</function> checks
     for well-formed content.  <function>xml_is_well_formed</function> does
     the former if the <xref linkend="guc-xmloption"/> configuration
     parameter is set to <literal>DOCUMENT</literal>, or the latter if it is set to
     <literal>CONTENT</literal>.  This means that
     <function>xml_is_well_formed</function> is useful for seeing whether
     a simple cast to type <type>xml</type> will succeed, whereas the other two
     functions are useful for seeing whether the corresponding variants of
     <function>XMLPARSE</function> will succeed.
-->
これらの関数は<type>text</type>文字列が整形式かどうかをチェックし、論理値で結果を返します。
<function>xml_is_well_formed_document</function>は文書が整形式かをチェックし、一方<function>xml_is_well_formed_content</function>は内容が整形式かをチェックします。
<function>xml_is_well_formed</function>は、<xref linkend="guc-xmloption"/>パラメータ値が<literal>DOCUMENT</literal>に設定されていれば前者を、<literal>CONTENT</literal>が設定されていれば後者のチェックを実施します。
これは、<function>xml_is_well_formed</function>は単純な<type>xml</type>型へのキャストが成功するかの判断に有用であり、その他の２つの関数は<function>XMLPARSE</function>の対応による変換が成功するかの判断に有用であることを意味します。
    </para>

    <para>
<!--
     Examples:
-->
例:

<screen><![CDATA[
SET xmloption TO DOCUMENT;
SELECT xml_is_well_formed('<>');
 xml_is_well_formed 
--------------------
 f
(1 row)

SELECT xml_is_well_formed('<abc/>');
 xml_is_well_formed 
--------------------
 t
(1 row)

SET xmloption TO CONTENT;
SELECT xml_is_well_formed('abc');
 xml_is_well_formed 
--------------------
 t
(1 row)

SELECT xml_is_well_formed_document('<pg:foo xmlns:pg="http://postgresql.org/stuff">bar</pg:foo>');
 xml_is_well_formed_document 
-----------------------------
 t
(1 row)

SELECT xml_is_well_formed_document('<pg:foo xmlns:pg="http://postgresql.org/stuff">bar</my:foo>');
 xml_is_well_formed_document 
-----------------------------
 f
(1 row)
]]></screen>

<!--
     The last example shows that the checks include whether
     namespaces are correctly matched.
-->
最後の例は、名前空間が正しく一致しているかのチェックも含むことを示しています。
    </para>
   </sect3>
  </sect2>

  <sect2 id="functions-xml-processing">
<!--
   <title>Processing XML</title>
-->
   <title>XMLの処理</title>

   <para>
<!--
    To process values of data type <type>xml</type>, PostgreSQL offers
    the functions <function>xpath</function> and
    <function>xpath_exists</function>, which evaluate XPath 1.0
    expressions, and the <function>XMLTABLE</function>
    table function.
-->
データ型<type>xml</type>の値を処理するため、PostgreSQLはXPath 1.0式を評価する関数<function>xpath</function>および<function>xpath_exists</function>と、テーブル関数<function>XMLTABLE</function>を提供しています。
   </para>

   <sect3 id="functions-xml-processing-xpath">
    <title><literal>xpath</literal></title>

    <indexterm>
     <primary>XPath</primary>
    </indexterm>

<synopsis>
<function>xpath</function>(<replaceable>xpath</replaceable>, <replaceable>xml</replaceable> <optional>, <replaceable>nsarray</replaceable></optional>)
</synopsis>

    <para>
<!--
     The function <function>xpath</function> evaluates the XPath 1.0
     expression <replaceable>xpath</replaceable> (a <type>text</type> value)
     against the XML value
     <replaceable>xml</replaceable>.  It returns an array of XML values
     corresponding to the node-set produced by the XPath expression.
     If the XPath expression returns a scalar value rather than a node-set,
     a single-element array is returned.
-->
関数<function>xpath</function>は、XML値<replaceable>xml</replaceable>に対し、XPath式<replaceable>xpath</replaceable>(ひとつの<type>text</type>値)を評価します。そして、XPath式で作成されたノードセットに対応するXML値の配列を返します。
もし、XPath式がノードセットではなくスカラー値を返す場合、単一要素の配列が返されます。
    </para>

    <para>
<!--
     The second argument must be a well formed XML document. In particular,
     it must have a single root node element.
-->
2番目の引数は整形済XML文書でなければなりません。特に、単一のルートノード要素を持たなければなりません。
    </para>

    <para>
<!--
     The optional third argument of the function is an array of namespace
     mappings.  This array should be a two-dimensional <type>text</type> array with
     the length of the second axis being equal to 2 (i.e., it should be an
     array of arrays, each of which consists of exactly 2 elements).
     The first element of each array entry is the namespace name (alias), the
     second the namespace URI. It is not required that aliases provided in
     this array be the same as those being used in the XML document itself (in
     other words, both in the XML document and in the <function>xpath</function>
     function context, aliases are <emphasis>local</emphasis>).
-->
オプショナルな関数の３番目の引数は名前空間マッピング配列です。
この配列は、第２軸が２に等しい長さをもつ２次元<type>text</type>配列です（つまり、それは配列の配列で、それぞれは正確に２つの要素からなります）。
それぞれの配列のエントリの最初の要素は名前空間の名前（別名）で、２番目は名前空間のURIです。
この配列内で提供される別名がXML文書自身で使用されるものと同じであることは必要ではありません（言い換えると、XML文書内および<function>xpath</function>関数の両方の文脈の中で、別名は<emphasis>ローカル</emphasis>です）。
    </para>

    <para>
<!--
     Example:
-->
例：
<screen><![CDATA[
SELECT xpath('/my:a/text()', '<my:a xmlns:my="http://example.com">test</my:a>',
             ARRAY[ARRAY['my', 'http://example.com']]);

 xpath  
--------
 {test}
(1 row)
]]></screen>
    </para>

    <para>
<!--
     To deal with default (anonymous) namespaces, do something like this:
-->
デフォルト(匿名)名前空間を取り扱うためには、以下のようなことを実施してください。
<screen><![CDATA[
SELECT xpath('//mydefns:b/text()', '<a xmlns="http://example.com"><b>test</b></a>',
             ARRAY[ARRAY['mydefns', 'http://example.com']]);

 xpath
--------
 {test}
(1 row)
]]></screen>
    </para>
   </sect3>

   <sect3 id="functions-xml-processing-xpath-exists">
    <title><literal>xpath_exists</literal></title>

    <indexterm>
     <primary>xpath_exists</primary>
    </indexterm>

<synopsis>
<function>xpath_exists</function>(<replaceable>xpath</replaceable>, <replaceable>xml</replaceable> <optional>, <replaceable>nsarray</replaceable></optional>)
</synopsis>

    <para>
<!--
     The function <function>xpath_exists</function> is a specialized form
     of the <function>xpath</function> function.  Instead of returning the
     individual XML values that satisfy the XPath 1.0 expression, this function
     returns a Boolean indicating whether the query was satisfied or not
     (specifically, whether it produced any value other than an empty node-set).
     This function is equivalent to the <literal>XMLEXISTS</literal> predicate,
     except that it also offers support for a namespace mapping argument.
-->
関数<function>xpath_exists</function>は、<function>xpath</function>関数の特別な形式です。この関数は、XPathを満足する個別のXML値を返す代わりに、問い合わせがそれを満足するかどうかを論理値で返します。
この関数は、名前空間にマッピングされた引数をもサポートする点を除き、標準の<literal>XMLEXISTS</literal>述語と同じです。
    </para>

    <para>
<!--
     Example:
-->
例:
<screen><![CDATA[
SELECT xpath_exists('/my:a/text()', '<my:a xmlns:my="http://example.com">test</my:a>',
                     ARRAY[ARRAY['my', 'http://example.com']]);

 xpath_exists  
--------------
 t
(1 row)
]]></screen>
    </para>
   </sect3>

   <sect3 id="functions-xml-processing-xmltable">
    <title><literal>xmltable</literal></title>

    <indexterm>
     <primary>xmltable</primary>
    </indexterm>

    <indexterm zone="functions-xml-processing-xmltable">
<!--
     <primary>table function</primary>
-->
     <primary>テーブル関数</primary>
     <secondary>XMLTABLE</secondary>
    </indexterm>

<synopsis>
<function>xmltable</function>( <optional>XMLNAMESPACES(<replaceable>namespace uri</replaceable> AS <replaceable>namespace name</replaceable><optional>, ...</optional>), </optional>
          <replaceable>row_expression</replaceable> PASSING <optional>BY { REF | VALUE }</optional> <replaceable>document_expression</replaceable> <optional>BY { REF | VALUE }</optional>
          COLUMNS <replaceable>name</replaceable> { <replaceable>type</replaceable> <optional>PATH <replaceable>column_expression</replaceable></optional> <optional>DEFAULT <replaceable>default_expression</replaceable></optional> <optional>NOT NULL | NULL</optional>
                        | FOR ORDINALITY }
                   <optional>, ...</optional>
)
</synopsis>

    <para>
<!--
     The <function>xmltable</function> function produces a table based
     on the given XML value, an XPath filter to extract rows, and a
     set of column definitions.
-->
<function>xmltable</function>関数は、与えられたXML値、行を抽出するXPathフィルタ、オプションの列定義の集合に基づいてテーブルを生成します。
    </para>

    <para>
<!--
     The optional <literal>XMLNAMESPACES</literal> clause is a comma-separated
     list of namespaces.  It specifies the XML namespaces used in
     the document and their aliases. A default namespace specification
     is not currently supported.
-->
オプションの<literal>XMLNAMESPACES</literal>句はカンマで区切られた名前空間のリストです。
これは文書とその別名で使用されるXML名前空間を指定します。
デフォルトの名前空間指定は現在のところサポートされていません。
    </para>

    <para>
<!--
     The required <replaceable>row_expression</replaceable> argument is
     an XPath 1.0 expression that is evaluated, passing the
     <replaceable>document_expression</replaceable> as its context item, to
     obtain a set of XML nodes. These nodes are what
     <function>xmltable</function> transforms into output rows. No rows
     will be produced if the <replaceable>document_expression</replaceable>
     is null, nor if the <replaceable>row_expression</replaceable> produces
     an empty node-set or any value other than a node-set.
-->
必須の<replaceable>row_expression</replaceable>引数はXPath式で、指定のXML文書に対して評価され、XMLノードの順序付きシーケンスが取得されます。
このシーケンスが<function>xmltable</function>により出力行に変換されます。
    </para>

    <para>
<!--
     <replaceable>document_expression</replaceable> provides the context
     item for the <replaceable>row_expression</replaceable>. It must be a
     well-formed XML document; fragments/forests are not accepted.
     The <literal>BY REF</literal> and <literal>BY VALUE</literal> clauses
     are accepted but ignored, as discussed in
     <xref linkend="functions-xml-limits-postgresql"/>.
     In the SQL standard, the <function>xmltable</function> function
     evaluates expressions in the XML Query language,
     but <productname>PostgreSQL</productname> allows only XPath 1.0
     expressions, as discussed in
     <xref linkend="functions-xml-limits-xpath1"/>.
-->
<replaceable>document_expression</replaceable>は演算の対象となるXML文書を提供します。
<literal>BY REF</literal>句はPostgreSQLでは何の効果もありませんが、SQL準拠および他の実装との互換性のために受け入れられます。
引数は整形されたXMLドキュメントでなければならず、フラグメントやフォレストは受け付けられません。
    </para>

    <para>
<!--
     The mandatory <literal>COLUMNS</literal> clause specifies the list
     of columns in the output table.
     Each entry describes a single column.
     See the syntax summary above for the format.
     The column name and type are required; the path, default and
     nullability clauses are optional.
-->
必須の<literal>COLUMNS</literal>句は、出力テーブルの列のリストを指定します。
<literal>COLUMNS</literal>句を省略した場合、結果集合の行には<literal>xml</literal>型の列が1つだけ含まれ、そこには<replaceable>row_expression</replaceable>にマッチしたデータが含まれます。
<literal>COLUMNS</literal>が指定された場合、各エントリは一つの列を表します。
形式については上記の構文サマリーを参照してください。
列名と型は必須ですが、パス、デフォルト値、NULLを許すかどうかの句は省略できます。
    </para>

    <para>
<!--
     A column marked <literal>FOR ORDINALITY</literal> will be populated
     with row numbers, starting with 1, in the order of nodes retrieved from
     the <replaceable>row_expression</replaceable>'s result node-set.
     At most one column may be marked <literal>FOR ORDINALITY</literal>.
-->
<literal>FOR ORDINALITY</literal>と印がつけられた列には、元の入力XMLドキュメントの中に現れた出力行の順序に対応する行番号が入ります。
<literal>FOR ORDINALITY</literal>の印が付けられるのは最大でも1列です。
    </para>

    <note>
     <para>
      XPath 1.0 does not specify an order for nodes in a node-set, so code
      that relies on a particular order of the results will be
      implementation-dependent.  Details can be found in
      <xref linkend="xml-xpath-1-specifics"/>.
     </para>
    </note>

    <para>
<!--
     The <replaceable>column_expression</replaceable> for a column is an
     XPath 1.0 expression that is evaluated for each row, with the current
     node from the <replaceable>row_expression</replaceable> result as its
     context item, to find the value of the column.  If
     no <replaceable>column_expression</replaceable> is given, then the
     column name is used as an implicit path.
-->
列の<literal>column_expression</literal>はXPath式で、<replaceable>row_expression</replaceable>の結果に対応する各行について評価されて、列の値を得ます。
<literal>column_expression</literal>が与えられなかった場合は、暗示的なパスとして列名が使用されます。
    </para>

    <para>
<!--
     If a column's XPath expression returns a non-XML value (limited to
     string, boolean, or double in XPath 1.0) and the column has a
     PostgreSQL type other than <type>xml</type>, the column will be set
     as if by assigning the value's string representation to the PostgreSQL
     type.  (If the value is a boolean, its string representation is taken
     to be <literal>1</literal> or <literal>0</literal> if the output
     column's type category is numeric, otherwise <literal>true</literal> or
     <literal>false</literal>.)
-->
列のXPath式が複数の要素を戻した場合、エラーが発生します。
式が空のタグとマッチした場合、結果は空文字列となります（<literal>NULL</literal>ではありません）。
<literal>xsi:nil</literal>の属性はすべて無視されます。
    </para>

    <para>
     If a column's XPath expression returns a non-empty set of XML nodes
     and the column's PostgreSQL type is <type>xml</type>, the column will
     be assigned the expression result exactly, if it is of document or
     content form.
     <footnote>
      <para>
       A result containing more than one element node at the top level, or
       non-whitespace text outside of an element, is an example of content form.
       An XPath result can be of neither form, for example if it returns an
       attribute node selected from the element that contains it. Such a result
       will be put into content form with each such disallowed node replaced by
       its string value, as defined for the XPath 1.0
       <function>string</function> function.
      </para>
     </footnote>
    </para>

    <para>
     A non-XML result assigned to an <type>xml</type> output column produces
     content, a single text node with the string value of the result.
     An XML result assigned to a column of any other type may not have more than
     one node, or an error is raised. If there is exactly one node, the column
     will be set as if by assigning the node's string
     value (as defined for the XPath 1.0 <function>string</function> function)
     to the PostgreSQL type.
    </para>

    <para>
<!--
     The string value of an XML element is the concatenation, in document order,
     of all text nodes contained in that element and its descendants. The string
     value of an element with no descendant text nodes is an
     empty string (not <literal>NULL</literal>).
     Any <literal>xsi:nil</literal> attributes are ignored.
     Note that the whitespace-only <literal>text()</literal> node between two non-text
     elements is preserved, and that leading whitespace on a <literal>text()</literal>
     node is not flattened.
     The XPath 1.0 <function>string</function> function may be consulted for the
     rules defining the string value of other XML node types and non-XML values.
-->
<replaceable>column_expression</replaceable>にマッチしたXMLのテキスト本体が列の値として使用されます。
要素内の複数の<literal>text()</literal>ノードは順番に結合されます。
子要素、処理命令、コメントはすべて無視されますが、子要素のテキストコンテンツは結果に結合されます。
2つの非テキスト要素間にある空白文字のみの<literal>text()</literal>ノードは保存されること、また<literal>text()</literal>ノードの先頭にある空白文字は削られないことに注意してください。
    </para>

    <para>
     The conversion rules presented here are not exactly those of the SQL
     standard, as discussed in <xref linkend="functions-xml-limits-casts"/>.
    </para>

    <para>
<!--
     If the path expression returns an empty node-set
     (typically, when it does not match)
     for a given row, the column will be set to <literal>NULL</literal>, unless
     a <replaceable>default_expression</replaceable> is specified; then the
     value resulting from evaluating that expression is used.
-->
パス式が行とマッチせず、<replaceable>default_expression</replaceable>が指定されている場合は、その式を評価した結果の値が使用されます。
その列に<literal>DEFAULT</literal>句が指定されていない場合は、そのフィールドは<literal>NULL</literal>に設定されます。
<replaceable>default_expression</replaceable>は列リスト内でそれより前に現れる出力列の値を参照して、ある列のデフォルト値を他の列の値に基づくものにすることができます。
    </para>

    <para>
<!--
     Columns may be marked <literal>NOT NULL</literal>. If the
     <replaceable>column_expression</replaceable> for a <literal>NOT NULL</literal> column
     does not match anything and there is no <literal>DEFAULT</literal> or the
     <replaceable>default_expression</replaceable> also evaluates to null, an error
     is reported.
-->
列には<literal>NOT NULL</literal>の印をつけることができます。
<literal>NOT NULL</literal>の列の<replaceable>column_expression</replaceable>が何にもマッチせず、<literal>DEFAULT</literal>がない、あるいは<replaceable>default_expression</replaceable>の評価結果もNULLになるという場合はエラーが報告されます。
    </para>

    <para>
<!--
     A <replaceable>default_expression</replaceable>, rather than being
     evaluated immediately when <function>xmltable</function> is called,
     is evaluated each time a default is needed for the column.
     If the expression qualifies as stable or immutable, the repeat
     evaluation may be skipped.
     This means that you can usefully use volatile functions like
     <function>nextval</function> in
     <replaceable>default_expression</replaceable>.
-->
PostgreSQLの通常の関数とは異なり、<replaceable>column_expression</replaceable>と<replaceable>default_expression</replaceable>は関数を呼び出す前には単純な値に評価されません。
<replaceable>column_expression</replaceable>は通常は一つの入力行に対してちょうど一度だけ評価され、<replaceable>default_expression</replaceable>はフィールドにデフォルト値が必要になる度に評価されます。
式が安定（stable）または不変（immutable）とみなされる場合、評価は繰り返し行われないかもしれません。
実際上、<function>xmltable</function>は関数呼び出しとしてよりも、副問合せのように動作します。
これは<replaceable>default_expression</replaceable>の中で<function>nextval</function>のような揮発性（volatile）の関数を有効に使用できること、また<replaceable>column_expression</replaceable>はXML文書の他の部分に依存するかもしれないということを意味します。
    </para>

    <para>
<!--
     Examples:
-->
例：
  <screen><![CDATA[
CREATE TABLE xmldata AS SELECT
xml $$
<ROWS>
  <ROW id="1">
    <COUNTRY_ID>AU</COUNTRY_ID>
    <COUNTRY_NAME>Australia</COUNTRY_NAME>
  </ROW>
  <ROW id="5">
    <COUNTRY_ID>JP</COUNTRY_ID>
    <COUNTRY_NAME>Japan</COUNTRY_NAME>
    <PREMIER_NAME>Shinzo Abe</PREMIER_NAME>
    <SIZE unit="sq_mi">145935</SIZE>
  </ROW>
  <ROW id="6">
    <COUNTRY_ID>SG</COUNTRY_ID>
    <COUNTRY_NAME>Singapore</COUNTRY_NAME>
    <SIZE unit="sq_km">697</SIZE>
  </ROW>
</ROWS>
$$ AS data;

SELECT xmltable.*
  FROM xmldata,
       XMLTABLE('//ROWS/ROW'
                PASSING data
                COLUMNS id int PATH '@id',
                        ordinality FOR ORDINALITY,
                        "COUNTRY_NAME" text,
                        country_id text PATH 'COUNTRY_ID',
                        size_sq_km float PATH 'SIZE[@unit = "sq_km"]',
                        size_other text PATH
                             'concat(SIZE[@unit!="sq_km"], " ", SIZE[@unit!="sq_km"]/@unit)',
                        premier_name text PATH 'PREMIER_NAME' DEFAULT 'not specified') ;

 id | ordinality | COUNTRY_NAME | country_id | size_sq_km |  size_other  | premier_name  
----+------------+--------------+------------+------------+--------------+---------------
  1 |          1 | Australia    | AU         |            |              | not specified
  5 |          2 | Japan        | JP         |            | 145935 sq_mi | Shinzo Abe
  6 |          3 | Singapore    | SG         |        697 |              | not specified
]]></screen>

<!--
     The following example shows concatenation of multiple text() nodes,
     usage of the column name as XPath filter, and the treatment of whitespace,
     XML comments and processing instructions:
-->
以下の例では、複数のtext()ノードの結合、列名のXPathフィルターとしての使用、空白文字、XMLコメント、処理命令の取扱いを示します。

  <screen><![CDATA[
CREATE TABLE xmlelements AS SELECT
xml $$
  <root>
   <element>  Hello<!-- xyxxz -->2a2<?aaaaa?> <!--x-->  bbb<x>xxx</x>CC  </element>
  </root>
$$ AS data;

SELECT xmltable.*
  FROM xmlelements, XMLTABLE('/root' PASSING data COLUMNS element text);
         element         
-------------------------
   Hello2a2   bbbxxxCC  
]]></screen>
    </para>

    <para>
<!--
     The following example illustrates how
     the <literal>XMLNAMESPACES</literal> clause can be used to specify
     a list of namespaces
     used in the XML document as well as in the XPath expressions:
-->
以下の例では、<literal>XMLNAMESPACES</literal>句を使ってXMLドキュメントやXPath式で使われる追加の名前空間のリストを指定する方法を示します。

  <screen><![CDATA[
WITH xmldata(data) AS (VALUES ('
<example xmlns="http://example.com/myns" xmlns:B="http://example.com/b">
 <item foo="1" B:bar="2"/>
 <item foo="3" B:bar="4"/>
 <item foo="4" B:bar="5"/>
</example>'::xml)
)
SELECT xmltable.*
  FROM XMLTABLE(XMLNAMESPACES('http://example.com/myns' AS x,
                              'http://example.com/b' AS "B"),
             '/x:example/x:item'
                PASSING (SELECT data FROM xmldata)
                COLUMNS foo int PATH '@foo',
                  bar int PATH '@B:bar');
 foo | bar
-----+-----
   1 |   2
   3 |   4
   4 |   5
(3 rows)
]]></screen>
    </para>
   </sect3>
  </sect2>

  <sect2 id="functions-xml-mapping">
<!--
   <title>Mapping Tables to XML</title>
-->
   <title>XMLにテーブルをマップ</title>

   <indexterm zone="functions-xml-mapping">
<!--
    <primary>XML export</primary>
-->
    <primary>XMLエクスポート</primary>
   </indexterm>

   <para>
<!--
    The following functions map the contents of relational tables to
    XML values.  They can be thought of as XML export functionality:
-->
以下の関数はリレーショナルテーブルの内容をXML値にマップします。
これらはXMLエクスポート機能と考えることができます。
<synopsis>
table_to_xml(tbl regclass, nulls boolean, tableforest boolean, targetns text)
query_to_xml(query text, nulls boolean, tableforest boolean, targetns text)
cursor_to_xml(cursor refcursor, count int, nulls boolean,
              tableforest boolean, targetns text)
</synopsis>
<!--
    The return type of each function is <type>xml</type>.
-->
それぞれの関数の戻り値型は<type>xml</type>です。
   </para>

   <para>
<!--
    <function>table_to_xml</function> maps the content of the named
    table, passed as parameter <parameter>tbl</parameter>.  The
    <type>regclass</type> type accepts strings identifying tables using the
    usual notation, including optional schema qualifications and
    double quotes.  <function>query_to_xml</function> executes the
    query whose text is passed as parameter
    <parameter>query</parameter> and maps the result set.
    <function>cursor_to_xml</function> fetches the indicated number of
    rows from the cursor specified by the parameter
    <parameter>cursor</parameter>.  This variant is recommended if
    large tables have to be mapped, because the result value is built
    up in memory by each function.
-->
<function>table_to_xml</function>は、パラメータ<parameter>tbl</parameter>として渡された名前付きのテーブルの内容をマップします。
<type>regclass</type>型はオプションのスキーマ修飾と二重引用符を含む、通常の表記法を使用しテーブルを特定する文字列を受け付けます。
<function>query_to_xml</function>は、パラメータ<parameter>query</parameter>としてテキストが渡された問い合わせを実行し、結果セットをマップします。
<function>cursor_to_xml</function>は、パラメータ<parameter>cursor</parameter>で指定されたカーソルから提示された行数を取得します。
それぞれの関数により結果値がメモリーに構築されるため、この異形は巨大なテーブルをマップする必要がある場合推奨されます。
   </para>

   <para>
<!--
    If <parameter>tableforest</parameter> is false, then the resulting
    XML document looks like this:
-->
<parameter>tableforest</parameter>が偽であれば、結果のXML文書は以下のようになります。
<screen><![CDATA[
<tablename>
  <row>
    <columnname1>data</columnname1>
    <columnname2>data</columnname2>
  </row>

  <row>
    ...
  </row>

  ...
</tablename>
]]></screen>

<!--
    If <parameter>tableforest</parameter> is true, the result is an
    XML content fragment that looks like this:
-->
<parameter>tableforest</parameter>が真であれば、結果は以下のようなXML文書の断片です。
<screen><![CDATA[
<tablename>
  <columnname1>data</columnname1>
  <columnname2>data</columnname2>
</tablename>

<tablename>
  ...
</tablename>

...
]]></screen>

<!--
    If no table name is available, that is, when mapping a query or a
    cursor, the string <literal>table</literal> is used in the first
    format, <literal>row</literal> in the second format.
-->
テーブル名が利用できないとき、つまり、問い合わせ、またはカーソルをマップする時は、最初の書式では文字列<literal>table</literal>が使用され、２番目の書式では<literal>row</literal>が使用されます。
   </para>

   <para>
<!--
    The choice between these formats is up to the user.  The first
    format is a proper XML document, which will be important in many
    applications.  The second format tends to be more useful in the
    <function>cursor_to_xml</function> function if the result values are to be
    reassembled into one document later on.  The functions for
    producing XML content discussed above, in particular
    <function>xmlelement</function>, can be used to alter the results
    to taste.
-->
これらどの書式を選択するのかはユーザ次第です。
最初の書式は適切なXML文書で、多くのアプリケーションにおいて重要です。
第２の書式は、後に結果値が１つの文書に再び組み立てられる場合、<function>cursor_to_xml</function>関数内でより有用になる傾向があります。
上記で説明したXML内容を作成する関数、特に<function>xmlelement</function>は結果を好みにかえるために使用することができます。
   </para>

   <para>
<!--
    The data values are mapped in the same way as described for the
    function <function>xmlelement</function> above.
-->
データの値は上記関数<function>xmlelement</function>で説明したのと同じ方法でマップされます。
   </para>

   <para>
<!--
    The parameter <parameter>nulls</parameter> determines whether null
    values should be included in the output.  If true, null values in
    columns are represented as:
-->
パラメータ<parameter>nulls</parameter>は出力にNULL値が含まれる必要があるかを決定します。
もし真であれば列内のNULL値は以下のように表現されます。
<screen><![CDATA[
<columnname xsi:nil="true"/>
]]></screen>
<!--
    where <literal>xsi</literal> is the XML namespace prefix for XML
    Schema Instance.  An appropriate namespace declaration will be
    added to the result value.  If false, columns containing null
    values are simply omitted from the output.
-->
ここで<literal>xsi</literal>はXMLスキーマインスタンスに対するXML名前空間接頭辞です。
適切な名前空間宣言が結果値に追加されます。
もし偽の場合、NULL値を含む列は単に出力から削除されます。
   </para>

   <para>
<!--
    The parameter <parameter>targetns</parameter> specifies the
    desired XML namespace of the result.  If no particular namespace
    is wanted, an empty string should be passed.
-->
パラメータ<parameter>targetns</parameter>は結果の希望するXML名前空間を指定します。
特定の名前空間が必要なければ、空文字列を渡す必要があります。
   </para>

   <para>
<!--
    The following functions return XML Schema documents describing the
    mappings performed by the corresponding functions above:
-->
以下の関数は、対応する上記関数により行われたマッピングを記述するXMLスキーマ文書を返します。
<synopsis>
table_to_xmlschema(tbl regclass, nulls boolean, tableforest boolean, targetns text)
query_to_xmlschema(query text, nulls boolean, tableforest boolean, targetns text)
cursor_to_xmlschema(cursor refcursor, nulls boolean, tableforest boolean, targetns text)
</synopsis>
<!--
    It is essential that the same parameters are passed in order to
    obtain matching XML data mappings and XML Schema documents.
-->
    一致するXMLデータマッピングとXMLスキーマ文書を取得するため、同じパラメータが渡されることが不可欠です。
   </para>

   <para>
<!--
    The following functions produce XML data mappings and the
    corresponding XML Schema in one document (or forest), linked
    together.  They can be useful where self-contained and
    self-describing results are wanted:
-->
以下の関数は、XMLデータマッピングとそれに対応するXMLスキーマがお互いにリンクされた、１つの文書（またはフォレスト）を作成します。
これらは自己完結した、自己記述的な結果を希望する場合に便利です。
<synopsis>
table_to_xml_and_xmlschema(tbl regclass, nulls boolean, tableforest boolean, targetns text)
query_to_xml_and_xmlschema(query text, nulls boolean, tableforest boolean, targetns text)
</synopsis>
   </para>

   <para>
<!--
    In addition, the following functions are available to produce
    analogous mappings of entire schemas or the entire current
    database:
-->
さらに、以下の関数がスキーマ全体、または現在のデータベース全体の類似マッピングを作成するため利用できます。
<synopsis>
schema_to_xml(schema name, nulls boolean, tableforest boolean, targetns text)
schema_to_xmlschema(schema name, nulls boolean, tableforest boolean, targetns text)
schema_to_xml_and_xmlschema(schema name, nulls boolean, tableforest boolean, targetns text)

database_to_xml(nulls boolean, tableforest boolean, targetns text)
database_to_xmlschema(nulls boolean, tableforest boolean, targetns text)
database_to_xml_and_xmlschema(nulls boolean, tableforest boolean, targetns text)
</synopsis>

<!--
    Note that these potentially produce a lot of data, which needs to
    be built up in memory.  When requesting content mappings of large
    schemas or databases, it might be worthwhile to consider mapping the
    tables separately instead, possibly even through a cursor.
-->
これらはメモリー内に作成される必要がある、多くのデータを生成する潜在的可能性があることに注意してください。
巨大なスキーマ、またはデータベースの内容マッピングを要求する際は、その代わりにテーブルを別々にマップすること、さらにはカーソル経由とすることさえ、検討することは無駄ではありません。
   </para>

   <para>
<!--
    The result of a schema content mapping looks like this:
-->
スキーマ内容マッピングの結果は以下のようになります。

<screen><![CDATA[
<schemaname>

table1-mapping

table2-mapping

...

</schemaname>]]></screen>

<!--
    where the format of a table mapping depends on the
    <parameter>tableforest</parameter> parameter as explained above.
-->
ここで、テーブルマッピング書式は上で説明したとおり<parameter>tableforest</parameter>パラメータに依存します。
   </para>

   <para>
<!--
    The result of a database content mapping looks like this:
-->
データベース内容マッピング書式は以下のようになります。

<screen><![CDATA[
<dbname>

<schema1name>
  ...
</schema1name>

<schema2name>
  ...
</schema2name>

...

</dbname>]]></screen>

<!--
    where the schema mapping is as above.
-->
ここで、スキーママッピングは上記のとおりです。
   </para>

   <para>
<!--
    As an example of using the output produced by these functions,
    <xref linkend="xslt-xml-html"/> shows an XSLT stylesheet that
    converts the output of
    <function>table_to_xml_and_xmlschema</function> to an HTML
    document containing a tabular rendition of the table data.  In a
    similar manner, the results from these functions can be
    converted into other XML-based formats.
-->
これらの関数で作成された出力を使用する１つの例として、<xref linkend="xslt-xml-html"/>は、テーブルデータの表形式への翻訳を含む<function>table_to_xml_and_xmlschema</function>からHTML文書への出力の変換をおこなうXSLTスタイルシートを示します。
同じようにして、これらの関数の結果は他のXML基準書式に変換されます。
   </para>

   <figure id="xslt-xml-html">
<!--
    <title>XSLT Stylesheet for Converting SQL/XML Output to HTML</title>
-->
    <title>SQL/XML出力をHTMLに変換するXSLTスタイルシート</title>
<programlisting><![CDATA[
<?xml version="1.0"?>
<xsl:stylesheet version="1.0"
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:xsd="http://www.w3.org/2001/XMLSchema"
    xmlns="http://www.w3.org/1999/xhtml"
>

  <xsl:output method="xml"
      doctype-system="http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"
      doctype-public="-//W3C/DTD XHTML 1.0 Strict//EN"
      indent="yes"/>

  <xsl:template match="/*">
    <xsl:variable name="schema" select="//xsd:schema"/>
    <xsl:variable name="tabletypename"
                  select="$schema/xsd:element[@name=name(current())]/@type"/>
    <xsl:variable name="rowtypename"
                  select="$schema/xsd:complexType[@name=$tabletypename]/xsd:sequence/xsd:element[@name='row']/@type"/>

    <html>
      <head>
        <title><xsl:value-of select="name(current())"/></title>
      </head>
      <body>
        <table>
          <tr>
            <xsl:for-each select="$schema/xsd:complexType[@name=$rowtypename]/xsd:sequence/xsd:element/@name">
              <th><xsl:value-of select="."/></th>
            </xsl:for-each>
          </tr>

          <xsl:for-each select="row">
            <tr>
              <xsl:for-each select="*">
                <td><xsl:value-of select="."/></td>
              </xsl:for-each>
            </tr>
          </xsl:for-each>
        </table>
      </body>
    </html>
  </xsl:template>

</xsl:stylesheet>
]]></programlisting>
   </figure>
  </sect2>
 </sect1>

<!-- split-func2-end -->
