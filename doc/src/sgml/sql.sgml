<!-- doc/src/sgml/sql.sgml -->

 <chapter id="sql-intro">
  <title>SQL</title>

  <abstract>
   <para>
<!--
    This chapter introduces the mathematical concepts behind
    relational databases. It is not required reading, so if you bog
    down or want to get straight to some simple examples feel free to
    jump ahead to the next chapter and come back when you have more
    time and patience. This stuff is supposed to be fun!
-->
本章ではリレーショナルデータベースにおける数学的概念を紹介します。
これは必読書ではないので、SQL文でわからないことがあって行き詰まっている場合や、SQLの簡単な例から取り掛かりたいのであれば、飛ばして次の章に進み、時間と忍耐力のある時に読んで見てください。
飽きさせない内容になっていますよ！
   </para>

   <para>
<!--
    This material originally appeared as a part of
    Stefan Simkovics' Master's Thesis
    (<xref linkend="SIM98" endterm="SIM98">).
-->
この内容の元になっているのはStefan Simkovicsの修士論文（<xref linkend="SIM98" endterm="SIM98">）の一部です。
   </para>
  </abstract>

  <para>
<!--
   <acronym>SQL</acronym> has become the most popular relational query
   language.
   The name <quote><acronym>SQL</acronym></quote> is an abbreviation for
   <firstterm>Structured Query Language</firstterm>.
   In 1974 Donald Chamberlin and others defined the
   language SEQUEL (<firstterm>Structured English Query
    Language</firstterm>) at IBM
   Research. This language was first implemented in an IBM
   prototype called SEQUEL-XRM in 1974-75. In 1976-77 a revised version
   of SEQUEL called SEQUEL/2 was defined and the name was changed to
   <acronym>SQL</acronym>
   subsequently.
-->
<acronym>SQL</acronym>は最も一般的なリレーショナル問い合わせ言語になりました。
<quote><acronym>SQL</acronym></quote>という名前は、<firstterm>Structured Query Language</firstterm>の省略形だと言われます。
1974年にDonald ChamberlinらがIBMの研究所においてSEQUEL（<firstterm>Structured English Query Language</firstterm>）という言語を定義しました。
この言語は1974年から1975年にかけてSEQUEL-XRMという名称でIBMが最初にプロトタイプを実装しました。
1976年から1977年にはSEQUEL/2と言われるSEQUELの改定版が定義され、その後名称が<acronym>SQL</acronym>へと変更されました。
  </para>

  <para>
<!--
   A new prototype called System R was developed by IBM in 1977. System R
   implemented a large subset of SEQUEL/2 (now <acronym>SQL</acronym>)
   and a number of
   changes were made to <acronym>SQL</acronym> during the project.
   System R was installed in
   a number of user sites, both internal IBM sites and also some selected
   customer sites. Thanks to the success and acceptance of System R at
   those user sites IBM started to develop commercial products that
   implemented the <acronym>SQL</acronym> language based on the System
   R technology.
-->
System Rと呼ばれた新しいプロトタイプが1977年にIBMによって開発されました。
System RはSEQUEL/2（現在の<acronym>SQL</acronym>）の大部分をサブセットとして実装し、そのプロジェクトの間にたくさんの変更が<acronym>SQL</acronym>に対して施されました。
System RはIBM内のサイトやいくつかの選ばれた顧客サイトなどの多数のユーザサイトにインストールされました。
これらのユーザサイトでSystem Rが受け入れられたことに気を良くし、IBMはSystem R技術をベースとした<acronym>SQL</acronym>言語を実装した商用製品の開発を開始しました。
  </para>

  <para>
<!--
   Over the next years IBM and also a number of other vendors announced
   <acronym>SQL</acronym> products such as
   <productname>SQL/DS</productname> (IBM),
   <productname>DB2</productname> (IBM),
   <productname>ORACLE</productname> (Oracle Corp.),
   <productname>DG/SQL</productname> (Data General Corp.),
   and <productname>SYBASE</productname> (Sybase Inc.).
-->
その翌年より、IBMと、さらに数多くのベンダが<productname>SQL/DS</productname>（IBM）、<productname>DB2</productname>（IBM）、<productname>ORACLE</productname>（Oracle社）、<productname>DG/SQL</productname>（Data General社）、<productname>SYBASE</productname>（Sybase社）といった<acronym>SQL</acronym>製品を発表しました。
  </para>

  <para>
<!--
   <acronym>SQL</acronym> is also an official standard now. In 1982
   the American National
   Standards Institute (<acronym>ANSI</acronym>) chartered its
   Database Committee X3H2 to
   develop a proposal for a standard relational language. This proposal
   was ratified in 1986 and consisted essentially of the IBM dialect of
   <acronym>SQL</acronym>. In 1987 this <acronym>ANSI</acronym>
   standard was also accepted as an international
   standard by the International Organization for Standardization
   (<acronym>ISO</acronym>).
   This original standard version of <acronym>SQL</acronym> is often
   referred to,
   informally, as <quote><abbrev>SQL/86</abbrev></quote>. In 1989 the original
   standard was extended
   and this new standard is often, again informally, referred to as
   <quote><abbrev>SQL/89</abbrev></quote>. Also in 1989, a related standard called
   <firstterm>Database Language Embedded <acronym>SQL</acronym></firstterm>
   (<acronym>ESQL</acronym>) was developed.
-->
<acronym>SQL</acronym>は現在では公的な規格にもなっています。
1982年に米国規格協会（<acronym>ANSI</acronym>）はX3H2というデータベース委員会に対し、標準リレーショナル言語のための提案の開発を依頼しました。
この提案は1986年に批准されましたが、基本的には<acronym>SQL</acronym>のIBM版の方言といったものでした。
1987年にこの<acronym>ANSI</acronym>規格が国際標準化機構（<acronym>ISO</acronym>）によって国際標準として受け入れられました。
この<acronym>SQL</acronym>規格の最初のバージョンは非公式に<quote><abbrev>SQL/86</abbrev></quote>と呼ばれます。
1989年に最初の規格が拡張されました。この新しい規格はしばしば、やはり非公式に<quote><abbrev>SQL/89</abbrev></quote>と呼ばれています。
また1989年には、<firstterm>Database Language Embedded <acronym>SQL</acronym></firstterm>（<acronym>ESQL</acronym>）と呼ばれる関連した規格が開発されました。
  </para>

  <para>
<!--
   The <acronym>ISO</acronym> and <acronym>ANSI</acronym> committees
   have been working for many years on the
   definition of a greatly expanded version of the original standard,
   referred to informally as <firstterm><acronym>SQL2</acronym></firstterm>
   or <firstterm><acronym>SQL/92</acronym></firstterm>. This version became a
   ratified standard - <quote>International Standard ISO/IEC 9075:1992,
   Database Language <acronym>SQL</acronym></quote> - in late 1992.
   <acronym>SQL/92</acronym> is the version
   normally meant when people refer to <quote>the <acronym>SQL</acronym>
   standard</quote>. A detailed
   description of <acronym>SQL/92</acronym> is given in
   <xref linkend="DATE97" endterm="DATE97">. At the time of
   writing this document a new standard informally referred to
   as <firstterm><acronym>SQL3</acronym></firstterm>
   is under development. It is planned to make <acronym>SQL</acronym>
   a Turing-complete
   language, i.e., all computable queries (e.g., recursive queries) will be
   possible. This has now been completed as SQL:2003.
-->
<acronym>ISO</acronym>と<acronym>ANSI</acronym>の両委員会は、当初の規格を大幅に拡張したバージョンの定義について、長年にわたって取り組んでいました。
これが非公式に<firstterm><acronym>SQL2</acronym></firstterm>または<firstterm><acronym>SQL/92</acronym></firstterm>と呼ばれるものです。
このバージョンは1992年の終わり頃、<quote>国際標準ISO/IEC 9075:1992データベース言語<acronym>SQL</acronym></quote>として批准された規格となりました。
<quote><acronym>SQL</acronym>規格</quote>という場合は、通常この<acronym>SQL/92</acronym>を指しています。
<acronym>SQL/92</acronym>は<xref linkend="DATE97" endterm="DATE97">で詳細に説明されています。
本書の執筆時点で、非公式に<firstterm><acronym>SQL3</acronym></firstterm>と呼ばれる新しい規格が開発中です。
<acronym>SQL</acronym>をチューリング完備言語にする計画があります。すなわち、計算可能なあらゆる問い合わせ（例えば再帰問い合わせ）ができるというものです。
これは非常に複雑な作業です。
SQL:2003として完成されました。
</para></footnote>
  </para>

  <sect1 id="rel-model">
<!--
   <title>The Relational Data Model</title>
-->
   <title>リレーショナルデータモデル</title>

  <para>
<!--
    As mentioned before, <acronym>SQL</acronym> is a relational
    language. That means it is
    based on the <firstterm>relational data model</firstterm>
    first published by E.F. Codd in
    1970. We will give a formal description of the relational model
    later (in
    <xref linkend="formal-notion" endterm="formal-notion">)
    but first we want to have a look at it from a more intuitive
    point of view.
-->
先に述べたように、<acronym>SQL</acronym>はリレーショナル言語です。
これは1970年にE.F. Coddが初めて出版した<firstterm>リレーショナルデータモデル</firstterm>に基づくことを意味しています。
リレーショナルモデルの形式定義については後述しますが（<xref linkend="formal-notion"endterm="formal-notion">を参照）、ここではまず、より直感的にリレーショナルモデルを見てみましょう。
  </para>

  <para>
<!--
    A <firstterm>relational database</firstterm> is a database that is
    perceived by its
    users as a <firstterm>collection of tables</firstterm> (and
    nothing else but tables).
    A table consists of rows and columns where each row represents a
    record and each column represents an attribute of the records
    contained in the table.
    <xref linkend="supplier-fig" endterm="supplier-fig">
    shows an example of a database consisting of three tables:
-->
<firstterm>リレーショナルデータベース</firstterm>はユーザからは、<firstterm>テーブルの（そしてテーブルだけからなる）集合</firstterm>に見えるようなデータベースです。
テーブルは行と列から構成されており、各行はレコードを、各列はテーブルに格納されているレコードの属性を表しています。
<xref linkend="supplier-fig" endterm="supplier-fig">は3つのテーブルからなるデータベースの例を示しています。

    <itemizedlist>
     <listitem>
      <para>
<!--
       SUPPLIER is a table storing the number
       (SNO), the name (SNAME) and the city (CITY) of a supplier.
-->
SUPPLIER（納入業者）は、納入業者の番号（SNO）、名前（SNAME）、市（CITY）を格納するテーブルです。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       PART is a table storing the number (PNO) the name (PNAME) and
       the price (PRICE) of a part.
-->
PART（部品）は、部品の番号（PNO）、名前（PNAME）、値段（PRICE）を格納するテーブルです。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       SELLS stores information about which part (PNO) is sold by which
       supplier (SNO).
       It serves in a sense to connect the other two tables together.
-->
SELLS（販売）は、どの部品(PNO)がどの納入業者（SNO）によって売られるかに関する情報を格納しています。
他の2つのテーブルを繋ぐ役目を果たしています。
      </para>
     </listitem>
    </itemizedlist>

    <example>
<!--
     <title id="supplier-fig">The Suppliers and Parts Database</title>
-->
     <title id="supplier-fig">納入業者と部品のデータベース</title>
<screen>
SUPPLIER:                   SELLS:
 SNO |  SNAME  |  CITY       SNO | PNO
----+---------+--------     -----+-----
 1  |  Smith  | London        1  |  1
 2  |  Jones  | Paris         1  |  2
 3  |  Adams  | Vienna        2  |  4
 4  |  Blake  | Rome          3  |  1
                              3  |  3
                              4  |  2
PART:                         4  |  3
 PNO |  PNAME  |  PRICE       4  |  4
----+---------+---------
 1  |  Screw  |   10
 2  |  Nut    |    8
 3  |  Bolt   |   15
 4  |  Cam    |   25
</screen>
    </example>
   </para>

   <para>
<!--
    The tables PART and SUPPLIER can be regarded as
    <firstterm>entities</firstterm> and
    SELLS can be regarded as a <firstterm>relationship</firstterm>
    between a particular
    part and a particular supplier.
-->
PARTテーブルやSUPPLIERテーブルは<firstterm>実体</firstterm>として考えられ、SELLSテーブルは特定のPART（部品）と特定のSUPPLIER（納入業者）間の<firstterm>関連</firstterm>（リレーション）を表すと考えられるでしょう。 
   </para>

   <para>
<!--
    As we will see later, <acronym>SQL</acronym> operates on tables
    like the ones just
    defined but before that we will study the theory of the relational
    model.
-->
後に示す通り、<acronym>SQL</acronym>はテーブルに対して定義された通りの操作を行います。
ただその前に、リレーショナルモデルの理論について学んでみたいと思います。
   </para>
  </sect1>

  <sect1 id="relmodel-formal">
<!--
   <title id="formal-notion">Relational Data Model Formalities</title>
-->
   <title id="formal-notion">リレーショナルデータモデルの形式</title>

   <para>
<!--
    The mathematical concept underlying the relational model is the
    set-theoretic <firstterm>relation</firstterm> which is a subset of
    the Cartesian
    product of a list of domains. This set-theoretic relation gives
    the model its name (do not confuse it with the relationship from the
    <firstterm>Entity-Relationship model</firstterm>).
    Formally a domain is simply a set of
    values. For example the set of integers is a domain. Also the set of
    character strings of length 20 and the real numbers are examples of
    domains.
-->
リレーショナルモデルの基礎をなしている数学的な概念は、ドメインのリストの直積の部分集合である、集合理論的な<firstterm>リレーション</firstterm>です。
リレーショナルモデル（<firstterm>エンティティリレーションモデル</firstterm>でのリレーションと混同しないでください）という名前は、この集合理論のリレーションという言葉からきています。
外見的には、ドメインは単に値の集合です。
例えば、整数の集合はドメインです。
長さ20の文字列と、実数の集合もまたドメインの例と言えます。
   </para>

   <para>
<!-- 原文コメント
\begin{definition}
The <firstterm>Cartesian product</firstterm> of domains $D_{1},
    D_{2},\ldots, D_{k}$ written
\mbox{$D_{1} \times D_{2} \times \ldots \times D_{k}$} is the set of
all $k$-tuples $(v_{1},v_{2},\ldots,v_{k})$ such that \mbox{$v_{1} \in
D_{1}, v_{2} \in D_{2}, \ldots, v_{k} \in D_{k}$}.
\end{definition}
-->
<!--
    The <firstterm>Cartesian product</firstterm> of domains
    <parameter>D<subscript>1</subscript></parameter>,
    <parameter>D<subscript>2</subscript></parameter>,
    ...
    <parameter>D<subscript>k</subscript></parameter>,
    written
    <parameter>D<subscript>1</subscript></parameter> &times;
    <parameter>D<subscript>2</subscript></parameter> &times;
    ... &times;
    <parameter>D<subscript>k</subscript></parameter>
    is the set of all k-tuples
    <parameter>v<subscript>1</subscript></parameter>,
    <parameter>v<subscript>2</subscript></parameter>,
    ...
    <parameter>v<subscript>k</subscript></parameter>,
    such that
    <parameter>v<subscript>1</subscript></parameter> &isin;
    <parameter>D<subscript>1</subscript></parameter>,
    <parameter>v<subscript>2</subscript></parameter> &isin;
    <parameter>D<subscript>2</subscript></parameter>,
    ...
    <parameter>v<subscript>k</subscript></parameter> &isin;
    <parameter>D<subscript>k</subscript></parameter>.
-->
<Parameter>D<subscript>1</subscript></parameter>, <Parameter>D<subscript>2</subscript></parameter>, ... <Parameter>D<subscript>k</subscript></parameter>というドメインの<firstterm>直積</firstterm>は<Parameter>D<subscript>1</subscript></parameter> &times; <Parameter>D<subscript>2</subscript></parameter> &times;... &times; <Parameter>D<subscript>k</subscript></parameter>というように記述されます。
これは<Parameter>v<subscript>1</subscript></parameter>, <Parameter>v<subscript>2</subscript></parameter>, ... <Parameter>v<subscript>k</subscript></parameter> が <Parameter>v<subscript>1</subscript></parameter> &isin; <Parameter>D<subscript>1</subscript></parameter>, <Parameter>v<subscript>2</subscript></parameter>  &isin; <Parameter>D<subscript>2</subscript></parameter>, ... <Parameter>v<subscript>k</subscript></parameter> &isin; <Parameter>D<subscript>k</subscript></parameter> であるようなk個のタプル全ての集合です。
   </para>

   <para>
<!--
    For example, when we have
-->
例えば
<!-- 原文コメント
 $k=2$, $D_{1}=\{0,1\}$ and
$D_{2}=\{a,b,c\}$, then $D_{1} \times D_{2}$ is
$\{(0,a),(0,b),(0,c),(1,a),(1,b),(1,c)\}$.
-->
<!--
    <parameter>k</parameter>=2,
    <parameter>D<subscript>1</subscript></parameter>=<literal>{0,1}</literal> and
    <parameter>D<subscript>2</subscript></parameter>=<literal>{a,b,c}</literal> then
    <parameter>D<subscript>1</subscript></parameter> &times;
    <parameter>D<subscript>2</subscript></parameter> is
    <literal>{(0,a),(0,b),(0,c),(1,a),(1,b),(1,c)}</literal>.
-->
<Parameter>k</parameter>=2で<Parameter>D<subscript>1</subscript></parameter>=<literal>{0,1}</literal>で<Parameter>D<subscript>2</subscript></parameter>=<literal>{a,b,c}</literal>ならば<Parameter>D<subscript>1</subscript></parameter> &times; <Parameter>D<subscript>2</subscript></parameter>は<literal>{(0,a),(0,b),(0,c),(1,a),(1,b),(1,c)}</literal>となります。
   </para>

   <para>
<!-- 原文コメント
\begin{definition}
A Relation is any subset of the Cartesian product of one or more
domains: $R \subseteq$ \mbox{$D_{1} \times D_{2} \times \ldots \times D_{k}$}
\end{definition}
-->
<!--
    A Relation is any subset of the Cartesian product of one or more
    domains: <parameter>R</parameter> &sube;
    <parameter>D<subscript>1</subscript></parameter> &times;
    <parameter>D<subscript>2</subscript></parameter> &times;
    ... &times;
    <parameter>D<subscript>k</subscript></parameter>.
-->
リレーションは、1つ以上のドメインの直積の任意の部分集合です。
つまり、<Parameter>R</parameter> &sube; <Parameter>D<subscript>1</subscript></parameter> &times; <Parameter>D<subscript>2</subscript></parameter> &times; ... &times; <Parameter>D<subscript>k</subscript></parameter>となります。
   </para>

   <para>
<!--
    For example <literal>{(0,a),(0,b),(1,a)}</literal> is a relation;
    it is in fact a subset of
    <parameter>D<subscript>1</subscript></parameter> &times;
    <parameter>D<subscript>2</subscript></parameter>
    mentioned above.
-->
例えば<literal>{(0,a),(0,b),(1,a)}</literal>はリレーションです。
これは実際に、上で挙げた<Parameter>D<subscript>1</subscript></parameter> &times; <Parameter>D<subscript>2</subscript></parameter>の部分集合になっています。
   </para>

   <para>
<!--
    The members of a relation are called tuples. Each relation of some
    Cartesian product
    <parameter>D<subscript>1</subscript></parameter> &times;
    <parameter>D<subscript>2</subscript></parameter> &times;
    ... &times;
    <parameter>D<subscript>k</subscript></parameter>
    is said to have arity <literal>k</literal> and is therefore a set
    of <literal>k</literal>-tuples.
-->
リレーションの要素はタプルと呼ばれます。
ある直積<Parameter>D<subscript>1</subscript></parameter> &times; <Parameter>D<subscript>2</subscript></parameter> &times; ... &times; <Parameter>D<subscript>k</subscript></parameter>のリレーションは要素数が<literal>k</literal>個であると言い、<literal>k</literal>タプルの集合になっています。
   </para>

   <para>
<!--
    A relation can be viewed as a table (as we already did, remember
    <xref linkend="supplier-fig" endterm="supplier-fig"> where
    every tuple is represented by a row and every column corresponds to
    one component of a tuple. Giving names (called attributes) to the
    columns leads to the definition of a
    <firstterm>relation scheme</firstterm>.
-->
リレーションは（これまでに見たように）テーブルとしてみなすことができます。
<xref linkend="supplier-fig" endterm="supplier-fig">を思い出してください。各タプルは行によって表現され、各列はタプルの中の1つの要素に対応していました。
列に名前（属性と呼ばれます）を付けることは<firstterm>リレーションスキーマ</firstterm>の定義に通じています。
   </para>

   <para>
<!-- 原文コメント
\begin{definition}
A {\it relation scheme} $R$ is a finite set of attributes
\mbox{$\{A_{1},A_{2},\ldots,A_{k}\}$}. There is a domain $D_{i}$ for
each attribute $A_{i}, 1 \le i \le k$ where the values of the
attributes are taken from. We often write a relation scheme as
\mbox{$R(A_{1},A_{2},\ldots,A_{k})$}.
\end{definition}
-->
<!--
    A <firstterm>relation scheme</firstterm> <literal>R</literal> is a
    finite set of attributes
    <parameter>A<subscript>1</subscript></parameter>,
    <parameter>A<subscript>2</subscript></parameter>,
    ...
    <parameter>A<subscript>k</subscript></parameter>.
    There is a domain
    <parameter>D<subscript>i</subscript></parameter>,
    for each attribute
    <parameter>A<subscript>i</subscript></parameter>,
    1 &lt;= <literal>i</literal> &lt;= <literal>k</literal>,
    where the values of the attributes are taken from. We often write
    a relation scheme as
    <literal>R(<parameter>A<subscript>1</subscript></parameter>,
    <parameter>A<subscript>2</subscript></parameter>,
    ...
    <parameter>A<subscript>k</subscript></parameter>)</literal>.
-->
<firstterm>リレーションスキーマ</firstterm> <literal>R</literal>は、<parameter>A<subscript>1</subscript></parameter>, <parameter>A<subscript>2</subscript></parameter>, ... <parameter>A<subscript>k</subscript></parameter>という属性の有限集合です。
各属性<Parameter>A<subscript>i</subscript></parameter>の 1 &lt;= <literal>i</literal> &lt;= <literal>k</literal>に対してドメイン<Parameter>D<subscript>i</subscript></parameter>が存在し、各属性の値は対応するドメインの要素になります。
リレーションスキーマは<literal>R(<Parameter>A<subscript>1</subscript></parameter>,<Parameter>A<subscript>2</subscript></parameter>, ... <Parameter>A<subscript>k</subscript></parameter>)</literal>のように記述されます。

    <note>
     <para>
<!--
      A <firstterm>relation scheme</firstterm> is just a kind of template
      whereas a <firstterm>relation</firstterm> is an instance of a
      <firstterm>relation
       scheme</firstterm>. The relation consists of tuples (and can
      therefore be
      viewed as a table); not so the relation scheme.
-->
<firstterm>リレーションスキーマ</firstterm>はテンプレートの一種に過ぎないのですが、<firstterm>リレーション</firstterm>は<firstterm>リレーションスキーム</firstterm>のインスタンスです。
リレーションはタプルの集まりからなります（そして、テーブルとしても見えます）。 リレーションスキーマとの違いを意識してください。
     </para>
    </note>
   </para>

   <sect2>
<!--
    <title id="domains">Domains vs. Data Types</title>
-->
    <title id="domains">ドメインとデータ型</title>

    <para>
<!--
     We often talked about <firstterm>domains</firstterm>
     in the last section. Recall that a
     domain is, formally, just a set of values (e.g., the set of integers or
     the real numbers). In terms of database systems we often talk of
     <firstterm>data types</firstterm> instead of domains.
     When we define a table we have to make
     a decision about which attributes to include. Additionally we
     have to decide which kind of data is going to be stored as
     attribute values. For example the values of
     <classname>SNAME</classname> from the table
     <classname>SUPPLIER</classname> will be character strings,
     whereas <classname>SNO</classname> will store
     integers. We define this by assigning a data type to each
     attribute. The type of <classname>SNAME</classname> will be
     <type>VARCHAR(20)</type> (this is the <acronym>SQL</acronym> type
     for character strings of length &lt;= 20),
     the type of <classname>SNO</classname> will be
     <type>INTEGER</type>. With the assignment of a data type we also
     have selected
     a domain for an attribute. The domain of
     <classname>SNAME</classname> is the set of all
     character strings of length &lt;= 20,
     the domain of <classname>SNO</classname> is the set of
     all integer numbers.
-->
前節で<firstterm>ドメイン</firstterm>についてしばしば言及しました。
正式にはドメインとは単なる値の集合（例えば、整数や実数の集合）であるということを思い出してください。
データベースシステムの世界では、ドメインの代わりに<firstterm>データ型</firstterm>という言葉もよく使われます。
テーブルを作成する時には、そこにどのような属性を含めるかを決定しなければいけません。
さらに、属性値をどのような種類のデータを格納するのかも決定しなければいけません。
例えば、<classname>SUPPLIER</classname>テーブルの<classname>SNAME</classname>の値は文字列ですし、<classname>SNO</classname>は整数を格納するでしょう。
データの型を各属性に割り当てることによってこれを定義します。
<classname>SNAME</classname>の型は<type>VARCHAR(20)</type>(これは20文字以下の文字列を扱うための<acronym>SQL</acronym>の型)であり、<classname>SNO</classname>の型は<type>INTEGER</type>となります。
データ型を指定することで、属性のドメインも選択したことになります。
<classname>SNAME</classname>のドメインは、20文字以下の文字列全ての集合で、<classname>SNO</classname>のドメインは整数値全ての集合となります。
    </para>
   </sect2>
  </sect1>

  <sect1 id="relmodel-oper">
<!--
   <title id="operations">Operations in the Relational Data Model</title>
-->
   <title id="operations">リレーショナルデータモデルの操作</title>

   <para>
<!--
    In the previous section
    (<xref linkend="formal-notion" endterm="formal-notion">)
    we defined the mathematical notion of
    the relational model. Now we know how the data can be stored using a
    relational data model but we do not know what to do with all these
    tables to retrieve something from the database yet. For example somebody
    could ask for the names of all suppliers that sell the part
    'Screw'. Therefore two rather different kinds of notations for
    expressing operations on relations have been defined:
-->
前節（<xref linkend="formal-notion" endterm="formal-notion">）ではリレーショナルモデルの数学的な概念を定義しました。
これまでのところでは、リレーショナルデータモデルを利用してどのようにしてデータを格納するかわかったが、データベースから何かを検索するためにこれらのテーブルをどのように処理するべきかはまだわからない、という状態です。
例えば、「Screw（ネジ）」を売っている全ての業者を求めたいとします。
そのため、リレーションに対しての操作を表現する2つの多少異なった表記法が定義されています。

    <itemizedlist>
     <listitem>
      <para>
<!--
       The <firstterm>Relational Algebra</firstterm> which is an
       algebraic notation,
       where queries are expressed by applying specialized operators to the
       relations.
-->
<firstterm>リレーショナル代数</firstterm>は代数的記法で、特別な演算子をリレーションに適用することで問い合わせを表現します。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       The <firstterm>Relational Calculus</firstterm> which is a
       logical notation,
       where queries are expressed by formulating some logical restrictions
       that the tuples in the answer must satisfy.
-->
<firstterm>リレーショナル論理</firstterm>は論理学的記法で、答えのタプルが満たすべき論理的な制約によって問い合わせを表現します。
      </para>
    </listitem>
    </itemizedlist>
   </para>

   <sect2>
<!--
    <title id="rel-alg">Relational Algebra</title>
-->
    <title id="rel-alg">リレーショナル代数</title>

    <para>
<!--
     The <firstterm>Relational Algebra</firstterm> was introduced by
     E. F. Codd in 1972. It consists of a set of operations on relations:
-->
<firstterm>リレーショナル代数</firstterm>は1972年にE.F.Coddによって提示されました。
これはリレーションにおける演算の集合からなります。

     <itemizedlist>
      <listitem>
       <para>
<!--
        SELECT (&sigma;): extracts <firstterm>tuples</firstterm> from
        a relation that
        satisfy a given restriction. Let <parameter>R</parameter> be a
        table that contains an attribute
        <parameter>A</parameter>.
&sigma;<subscript>A=a</subscript>(R) = {t &isin; R &mid; t(A) = a}
        where <literal>t</literal> denotes a
        tuple of <parameter>R</parameter> and <literal>t(A)</literal>
        denotes the value of attribute <parameter>A</parameter> of
        tuple <literal>t</literal>.
-->
選択（&sigma;）——リレーションから条件を満たす<firstterm>タプル</firstterm>を抜き出します。
<Parameter>R</parameter>は属性<Parameter>A</parameter>を含むテーブルとしましょう。
&sigma;<subscript>A=a</subscript>(R) = {t &isin; R &mid; t(A) = a}のように表すことができます。
ここで<literal>t</literal>は<Parameter>R</parameter>のタプルで、<literal>t(A)</literal>はタプル<literal>t</literal>の属性の<Parameter>A</parameter>の値を意味します。
       </para>
      </listitem>

      <listitem>
       <para>
<!--
        PROJECT (&pi;): extracts specified
        <firstterm>attributes</firstterm> (columns) from a
        relation. Let <classname>R</classname> be a relation
        that contains an attribute <classname>X</classname>.
        &pi;<subscript>X</subscript>(<classname>R</classname>) = {t(X) &mid; t &isin; <classname>R</classname>},
        where <literal>t</literal>(<classname>X</classname>) denotes the value of
        attribute <classname>X</classname> of tuple <literal>t</literal>.
-->
射影（&pi;）——リレーションから指定した<firstterm>属性</firstterm>（列）を抜き出します。
<classname>R</classname>は属性<classname>X</classname>を含むリレーションとしましょう。
&pi;<subscript>X</subscript>(<classname>R</classname>) = {t(X) &mid; t &isin; <classname>R</classname>}のように定義することができます。
ここで、<literal>t</literal>(<classname>X</classname>)はタプル<literal>t</literal>の属性<classname>X</classname>の値を意味します。
       </para>
      </listitem>

      <listitem>
       <para>
<!--
        PRODUCT (&times;): builds the Cartesian product of two
        relations. Let <classname>R</classname> be a table with arity
        <literal>k</literal><subscript>1</subscript> and let
        <classname>S</classname> be a table with
        arity <literal>k</literal><subscript>2</subscript>.
        <classname>R</classname> &times; <classname>S</classname>
        is the set of all
        <literal>k</literal><subscript>1</subscript>
        + <literal>k</literal><subscript>2</subscript>-tuples
        whose first <literal>k</literal><subscript>1</subscript>
        components form a tuple in <classname>R</classname> and whose last
        <literal>k</literal><subscript>2</subscript> components form a
        tuple in <classname>S</classname>.
-->
直積（&times;）——2つのリレーションの直積をとります。
<classname>R</classname>は要素数<literal>k</literal><subscript>1</subscript>のテーブル、<classname>S</classname>は要素数<literal>k</literal><subscript>2</subscript>のテーブルとします。
<classname>R</classname> &times; <classname>S</classname>は要素数<literal>k</literal><subscript>1</subscript> + <literal>k</literal><subscript>2</subscript> からなる集合で、そのタプルは、最初の<literal>k</literal><subscript>1</subscript>個の要素は<classname>R</classname>のタプルであり、かつ残りの<literal>k</literal><subscript>2</subscript>個の要素は <classname>S</classname> のタプルで構成されます。
       </para>
      </listitem>

      <listitem>
       <para>
<!--
        UNION (&cup;): builds the set-theoretic union of two
        tables. Given the tables <classname>R</classname> and
        <classname>S</classname> (both must have the same arity),
        the union <classname>R</classname> &cup; <classname>S</classname>
        is the set of tuples that are in <classname>R</classname>
        or <classname>S</classname> or both.
-->
和集合（&cup;）——2つのテーブルの集合論的な和を構成します。
<classname>R</classname>と<classname>S</classname>というテーブルがある時（両方とも同じ要素数）、和<classname>R</classname> &cup; <classname>S</classname>とは、<classname>R</classname>に現れるタプルと<classname>S</classname>、もしくはその両方に現れるタプルからなる集合です。
       </para>
      </listitem>

      <listitem>
       <para>
<!--
        INTERSECT (&cap;): builds the set-theoretic intersection of two
        tables. Given the tables <classname>R</classname> and
        <classname>S</classname>,
        <classname>R</classname> &cap; <classname>S</classname> is the
        set of tuples
        that are in <classname>R</classname> and in
        <classname>S</classname>.
        We again require that <classname>R</classname> and
        <classname>S</classname> have the
        same arity.
-->
共通集合（&cap;）——2つのテーブルの集合論的な共通集合を構成します。
<classname>R</classname>と<classname>S</classname>というテーブルがあるものとします。
<classname>R</classname> &cap; <classname>S</classname>は<classname>R</classname>と<classname>S</classname>の両方に含まれるタプルの集合です。
<classname>R</classname>と<classname>S</classname>は要素数が同じであることが必要です。
       </para>
      </listitem>

      <listitem>
       <para>
<!--
        DIFFERENCE (&minus; or &setmn;): builds the set difference of
        two tables. Let <classname>R</classname> and <classname>S</classname>
        again be two tables with the same
        arity. <classname>R</classname> - <classname>S</classname>
        is the set of tuples in <classname>R</classname> but not in
        <classname>S</classname>.
-->
差集合（&minus;または&setmn;）——2つのテーブルの差集合を構成されます。
<classname>R</classname>と<classname>S</classname>は同じ要素数をもつ2つのテーブルであるとします。
<classname>R</classname> - <classname>S</classname>は<classname>R</classname>に含まれるが<classname>S</classname>に含まれないタプルの集合です。
       </para>
      </listitem>

      <listitem>
       <para>
<!--
        JOIN (&prod;): connects two tables by their common
        attributes. Let <classname>R</classname> be a table with the
        attributes <classname>A</classname>,<classname>B</classname>
        and <classname>C</classname> and
        let <classname>S</classname> be a table with the attributes
        <classname>C</classname>,<classname>D</classname>
        and <classname>E</classname>. There is one
        attribute common to both relations,
        the attribute <classname>C</classname>.
-->
結合（&prod;）——共通の属性で2つのテーブルを結合することです。
テーブル<classname>R</classname>は属性<classname>A</classname>,<classname>B</classname>,<classname>C</classname>を持ち、テーブル<classname>S</classname>は属性<classname>C</classname>,<classname>D</classname>,<classname>E</classname>を持つものとします。
属性<classname>C</classname>は両方のリレーションに共通の属性です。 
<!-- 原文コメント
        <classname>R</classname> &prod; <classname>S</classname> =
        &pi;<subscript><classname>R</classname>.<classname>A</classname>,<classname>R</classname>.<classname>B</classname>,<classname>R</classname>.<classname>C</classname>,<classname>S</classname>.<classname>D</classname>,<classname>S</classname>.<classname>E</classname></subscript>(&sigma;<subscript><classname>R</classname>.<classname>C</classname>=<classname>S</classname>.<classname>C</classname></subscript>(<classname>R</classname> &times; <classname>S</classname>)).
-->
<!--
        R &prod; S = &pi;<subscript>R.A,R.B,R.C,S.D,S.E</subscript>(&sigma;<subscript>R.C=S.C</subscript>(R &times; S)).
        What are we doing here? We first calculate the Cartesian
        product
        <classname>R</classname> &times; <classname>S</classname>.
        Then we select those tuples whose values for the common
        attribute <classname>C</classname> are equal
        (&sigma;<subscript>R.C = S.C</subscript>).
        Now we have a table
        that contains the attribute <classname>C</classname>
        two times and we correct this by
        projecting out the duplicate column.
-->
R &prod; S = &pi;<subscript>R.A,R.B,R.C,S.D,S.E</subscript>(&sigma;<subscript>R.C=S.C</subscript>(R &times; S))
これで何が起こるでしょう?
まず最初に直積<classname>R</classname> &times; <classname>S</classname>を演算します。
それから、共通の属性<classname>C</classname>が同一であるようなタプルを選択します（&sigma;<subscript>R.C = S.C</subscript>）。
ここで同じ属性<classname>C</classname>を2つ持つ1つのテーブルができ上がります。
そして、これに重複した列を取り除くような射影を行います。
       </para>

       <example>
<!--
        <title id="join-example">An Inner Join</title>
-->
        <title id="join-example">内部結合</title>

        <para>
<!--
         Let's have a look at the tables that are produced by evaluating the steps
         necessary for a join.
         Let the following two tables be given:
-->
結合に必要な手順を追って行き、でき上がるテーブルを見てみましょう。
以下の2つのテーブルがあります。

<screen>
R:                 S:
 A | B | C          C | D | E
---+---+---        ---+---+---
 1 | 2 | 3          3 | a | b
 4 | 5 | 6          6 | c | d
 7 | 8 | 9
</screen>
        </para>
       </example>

       <para>
<!--
        First we calculate the Cartesian product
        <classname>R</classname> &times; <classname>S</classname> and
        get:
-->
まず、直積<classname>R</classname> &times; <classname>S</classname>の演算を行うと以下の結果が得られます。

<screen>
R x S:
 A | B | R.C | S.C | D | E
---+---+-----+-----+---+---
 1 | 2 |  3  |  3  | a | b
 1 | 2 |  3  |  6  | c | d
 4 | 5 |  6  |  3  | a | b
 4 | 5 |  6  |  6  | c | d
 7 | 8 |  9  |  3  | a | b
 7 | 8 |  9  |  6  | c | d
</screen>
       </para>

       <para>
<!--
        After the selection
        &sigma;<subscript>R.C=S.C</subscript>(R &times; S)
        we get:
-->
次に、選択&sigma;<subscript>R.C=S.C</subscript>(R &times; S)を行うと以下のような結果が得られます。

<screen>
 A | B | R.C | S.C | D | E
---+---+-----+-----+---+---
 1 | 2 |  3  |  3  | a | b
 4 | 5 |  6  |  6  | c | d
</screen>
       </para>

       <para>
<!--
        To remove the duplicate column
        <classname>S</classname>.<classname>C</classname>
        we project it out by the following operation:
        &pi;<subscript>R.A,R.B,R.C,S.D,S.E</subscript>(&sigma;<subscript>R.C=S.C</subscript>(R &times; S))
        and get:
-->
重複した列<classname>S</classname>.<classname>C</classname>を削除するには、以下の操作でそれを射影します。
&pi;<subscript>R.A,R.B,R.C,S.D,S.E</subscript>(&sigma;<subscript>R.C=S.C</subscript>(R &times; S))
これによって以下の結果が得られます。

<screen>
 A | B | C | D | E
---+---+---+---+---
 1 | 2 | 3 | a | b
 4 | 5 | 6 | c | d
</screen>
       </para>
      </listitem>

      <listitem>
       <para>
<!--
        DIVIDE (&divide;): Let <classname>R</classname> be a table
        with the attributes A, B, C, and D and let
        <classname>S</classname> be a table with the attributes
        C and D.
        Then we define the division as:
-->
商（&divide;）——テーブル<classname>R</classname>は属性A、B、C、Dを持つもの、テーブル<classname>S</classname>は属性CとDを持つものとします。 
商を定義すると以下のようになります。

<programlisting>
R &divide; S = {t &mid; &forall; t<subscript>s</subscript> &isin; S &exist; t<subscript>r</subscript> &isin; R
</programlisting>

<!--
        such that
t<subscript>r</subscript>(A,B)=t&and;t<subscript>r</subscript>(C,D)=t<subscript>s</subscript>}
        where
        t<subscript>r</subscript>(x,y)
        denotes a
        tuple of table <classname>R</classname> that consists only of
        the components <literal>x</literal> and <literal>y</literal>.
        Note that the tuple <literal>t</literal> only consists of the
        components <classname>A</classname> and
        <classname>B</classname> of relation <classname>R</classname>.
-->
ここでt<subscript>r</subscript>(x,y)は、テーブル<classname>R</classname>のタプルから要素<literal>x</literal>と<literal>y</literal>だけを取り出したものを表しています。
タプル<literal>t</literal>はリレーション<classname>R</classname>の要素<classname>A</classname>と<classname>B</classname>からのみで構成されることに注意してください。
       </para>

       <para id="divide-example">
<!--
        Given the following tables
-->
以下のようなテーブルがあるものとします。

<screen>
R:                    S:
 A | B | C | D         C | D
---+---+---+---       ---+---
 a | b | c | d         c | d
 a | b | e | f         e | f
 b | c | e | f
 e | d | c | d
 e | d | e | f
 a | b | d | e
</screen>

<!--
        R &divide; S
        is derived as
-->
R &divide; Sにより以下の結果が得られます。

<screen>
 A | B
---+---
 a | b
 e | d
</screen>
       </para>
      </listitem>
     </itemizedlist>
    </para>

    <para>
<!--
     For a more detailed description and definition of the relational
     algebra refer to [<xref linkend="ULL88" endterm="ULL88">] or
     [<xref linkend="DATE04" endterm="DATE04">].
-->
リレーショナル代数の定義と詳細な解説は<xref linkend="ULL88" endterm="ULL88">または<xref linkend="DATE04" endterm="DATE04">を参照してください。
    </para>

    <example>
<!--
     <title id="suppl-rel-alg">A Query Using Relational Algebra</title>
-->
     <title id="suppl-rel-alg">リレーショナル代数を使った問い合わせ</title>
     <para>
<!--
      Recall that we formulated all those relational operators to be able to
      retrieve data from the database. Let's return to our example from
      the previous
      section (<xref linkend="operations" endterm="operations">)
      where someone wanted to know the names of all
      suppliers that sell the part <literal>Screw</literal>.
      This question can be answered
      using relational algebra by the following operation:
-->
データベースから検索できるリレーショナル演算子を全て定式化したことを思い出してください。
ここで前節（<xref linkend="operations" endterm="operations">）の例に戻って、<literal>Screw</literal>を売っている業者全ての名前を調べたくなったとします。
この質問には、リレーショナル代数を使って以下のような演算を施せば答えることができます。

<programlisting>
&pi;<subscript>SUPPLIER.SNAME</subscript>(&sigma;<subscript>PART.PNAME='Screw'</subscript>(SUPPLIER &prod; SELLS &prod; PART))
</programlisting>
     </para>

     <para>
<!--
      We call such an operation a query. If we evaluate the above query
      against the our example tables
      (<xref linkend="supplier-fig" endterm="supplier-fig">)
      we will obtain the following result:
-->
上記のような演算を問い合わせと言います。
例で使用したテーブル（<xref linkend="supplier-fig" endterm="supplier-fig">）に対して上記の問い合わせをしたとすれば、以下のような結果が得られるでしょう。

<screen>
 SNAME
-------
 Smith
 Adams
</screen>
     </para>
    </example>
   </sect2>

   <sect2 id="rel-calc">
<!--
    <title>Relational Calculus</title>
-->
    <title>リレーショナル論理</title>

    <para>
<!--
     The relational calculus is based on the
     <firstterm>first order logic</firstterm>. There are
     two variants of the relational calculus:
-->
リレーショナル論理は<firstterm>一階述語論理</firstterm>に基づくものです。
リレーショナル論理には2つの種類があります。

     <itemizedlist>
      <listitem>
       <para>
<!--
        The <firstterm>Domain Relational Calculus</firstterm>
        (<acronym>DRC</acronym>), where variables
        stand for components (attributes) of the tuples.
-->
<firstterm>ドメインリレーショナル論理</firstterm>（<acronym>DRC</acronym>）——変数がタプルのコンポーネント（属性）を表します。
       </para>
      </listitem>

      <listitem>
       <para>
<!--
        The <firstterm>Tuple Relational Calculus</firstterm>
        (<acronym>TRC</acronym>), where variables stand for tuples.
-->
<firstterm>タプルリレーショナル論理</firstterm>（<acronym>TRC</acronym>）——変数がタプルを表します。
       </para>
      </listitem>
     </itemizedlist>
    </para>

    <para>
<!--
     We want to discuss the tuple relational calculus only because it is
     the one underlying the most relational languages. For a detailed
     discussion on <acronym>DRC</acronym> (and also
     <acronym>TRC</acronym>) see
     <xref linkend="DATE04" endterm="DATE04">
     or
     <xref linkend="ULL88" endterm="ULL88">.
-->
たいていのリレーショナル言語の基礎をなしているものでもあるので、ここではタプルリレーショナル論理についてのみ議論してみようと思います。
<acronym>DRC</acronym>（<acronym>TRC</acronym>についても）に関する詳細な議論は<xref linkend="DATE04" endterm="DATE04">または<xref linkend="ULL88" endterm="ULL88">を参照してください。
    </para>
   </sect2>

   <sect2>
<!--
    <title>Tuple Relational Calculus</title>
-->
    <title>タプルリレーショナル論理</title>

    <para>
<!--
     The queries used in <acronym>TRC</acronym> are of the following
     form:
-->
<acronym>TRC</acronym>で使われる問い合わせは、以下の形式です。

<programlisting>
x(A) &mid; F(x)
</programlisting>

<!--
     where <literal>x</literal> is a tuple variable
     <classname>A</classname> is a set of attributes and <literal>F</literal> is a
     formula. The resulting relation consists of all tuples
     <literal>t(A)</literal> that satisfy <literal>F(t)</literal>.
-->
<literal>x</literal>はタプル変数、<classname>A</classname>は属性の集合、<literal>F</literal>は論理式です。
結果リレーションは<literal>F(t)</literal>を満たす全てのタプル<literal>t(A)</literal>で構成されています。
    </para>

    <para>
<!--
     If we want to answer the question from example
     <xref linkend="suppl-rel-alg" endterm="suppl-rel-alg">
     using <acronym>TRC</acronym> we formulate the following query:
-->
<xref linkend="suppl-rel-alg" endterm="suppl-rel-alg">を<acronym>TRC</acronym>を使って答えを求めるには以下のような論理式で問い合わせを行います。

<programlisting>
{x(SNAME) &mid; x &isin; SUPPLIER &and;
    &exist; y &isin; SELLS &exist; z &isin; PART (y(SNO)=x(SNO) &and;
    z(PNO)=y(PNO) &and;
    z(PNAME)='Screw')}
</programlisting>
    </para>

    <para>
<!--
     Evaluating the query against the tables from
     <xref linkend="supplier-fig" endterm="supplier-fig">
     again leads to the same result
     as in
     <xref linkend="suppl-rel-alg" endterm="suppl-rel-alg">.
-->
この問い合わせを<xref linkend="supplier-fig" endterm="supplier-fig">のテーブルに対して再び評価すると、<xref linkend="suppl-rel-alg" endterm="suppl-rel-alg">と同じ結果が得られます。
    </para>
   </sect2>

   <sect2 id="alg-vs-calc">
<!--
    <title>Relational Algebra vs. Relational Calculus</title>
-->
    <title>リレーショナル代数とリレーショナル論理</title>

    <para>
<!--
     The relational algebra and the relational calculus have the same
     <firstterm>expressive power</firstterm>; i.e., all queries that
     can be formulated using relational algebra can also be formulated
     using the relational calculus and vice versa.
     This was first proved by E. F. Codd in
     1972. This proof is based on an algorithm (<quote>Codd's reduction
     algorithm</quote>) by which an arbitrary expression of the relational
     calculus can be reduced to a semantically equivalent expression of
     relational algebra. For a more detailed discussion on that refer to
     <xref linkend="DATE04" endterm="DATE04">
     and
     <xref linkend="ULL88" endterm="ULL88">.
-->
リレーショナル代数とリレーショナル論理は同じ<firstterm>表現力</firstterm>を持っています。
つまり、リレーショナル代数を使って表すことができる問い合わせは全てリレーショナル論理で表すことができ、またその逆も可能なのです。
これは、1972年にE. F. Coddによって最初に証明されました。
この証明は、リレーショナル論理の任意の式を、それと意味論的に等価なリレーショナル代数の式に変換するアルゴリズム（<quote>Codd's reduction algorithm</quote>）に基づいています。
これに関するより詳細な議論に関しては、<xref linkend="DATE04" endterm="DATE04">や<xref linkend="ULL88" endterm="ULL88">を参照してください。
    </para>

    <para>
<!--
     It is sometimes said that languages based on the relational
     calculus are <quote>higher level</quote> or <quote>more
     declarative</quote> than languages based on relational algebra
     because the algebra (partially) specifies the order of operations
     while the calculus leaves it to a compiler or interpreter to
     determine the most efficient order of evaluation.
-->
場合によっては、リレーショナル論理に基づく言語がリレーショナル代数に基づく言語よりも<quote>より高水準である</quote>とか<quote>より宣言的である</quote>と言われます。
これはリレーショナル代数では演算の順番を（部分的に）指定しますが、リレーショナル論理では効率的な評価順の決定をコンパイラやインタプリタに任せられるからです。
    </para>
   </sect2>
  </sect1>

  <sect1 id="sql-language">
<!--
   <title>The <acronym>SQL</acronym> Language</title>
-->
<title><acronym>SQL</acronym>言語</title>

   <para>
<!--
    As is the case with most modern relational languages,
    <acronym>SQL</acronym> is based on the tuple
    relational calculus. As a result every query that can be formulated
    using the tuple relational calculus (or equivalently, relational
    algebra) can also be formulated using
    <acronym>SQL</acronym>. There are, however,
    capabilities beyond the scope of relational algebra or calculus. Here
    is a list of some additional features provided by
    <acronym>SQL</acronym> that are not
    part of relational algebra or calculus:
-->
現代のほとんどのリレーショナル言語と同様に、<acronym>SQL</acronym>はタプルリレーショナル論理に基づいています。
その結果、タプルリレーショナル論理（もしくは同様にリレーショナル代数）を使用することによって表現できるあらゆる問い合わせは、同様に<acronym>SQL</acronym>を使用して表現することもできます。
しかし、リレーショナル代数やリレーショナル論理の範囲を超えた能力もあります。
以下に示すのは、リレーショナル代数やリレーショナル論理の一部でない、<acronym>SQL</acronym>によって提供されるいくつかの追加機能です。

    <itemizedlist>
     <listitem>
      <para>
<!--
       Commands for insertion, deletion or modification of data.
-->
データの挿入、削除、修正のためのコマンド。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       Arithmetic capability: In <acronym>SQL</acronym> it is possible
       to involve
       arithmetic operations as well as comparisons, e.g.:
-->
計算能力。
<acronym>SQL</acronym>では、比較と同様に算術演算を含むことが可能です。
例えば、以下のようなものです。

<programlisting>
A &lt; B + 3.
</programlisting>

<!--
       Note
       that + or other arithmetic operators appear neither in relational
       algebra nor in relational calculus.
-->
「+」やその他の算術演算子は、リレーショナル代数にも、リレーショナル論理にもないことに注意してください。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       Assignment and Print Commands: It is possible to print a
       relation constructed by a query and to assign a computed relation to a
       relation name.
-->
割り当てと表示コマンド。問い合わせによって作られるリレーションを表示したり、計算されたリレーションをリレーション名に割り当てることも可能です。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       Aggregate Functions: Operations such as
       <firstterm>average</firstterm>, <firstterm>sum</firstterm>,
       <firstterm>max</firstterm>, etc. can be applied to columns of a
       relation to
       obtain a single quantity.
-->
集約関数。
<firstterm>平均</firstterm>、<firstterm>総和</firstterm>、<firstterm>最大</firstterm>といった演算をリレーションの列に対して行い、1つの数値を得ることができます。
      </para>
     </listitem>
    </itemizedlist>
   </para>

   <sect2 id="select">
<!--
    <title id="select-title">Select</title>
-->
    <title id="select-title">Select（選択）</title>

    <para>
<!--
     The most often used command in <acronym>SQL</acronym> is the
     <command>SELECT</command> statement,
     used to retrieve data. The syntax is:
-->
<acronym>SQL</acronym>で最もよく使われるコマンドは<command>SELECT</command>文です。
これはデータを検索するために使われます。
構文は以下の通りです。

<synopsis>
SELECT [ ALL | DISTINCT [ ON ( <replaceable class="PARAMETER">expression</replaceable> [, ...] ) ] ]
    * | <replaceable class="PARAMETER">expression</replaceable> [ [ AS ] <replaceable class="PARAMETER">output_name</replaceable> ] [, ...]
    [ INTO [ TEMPORARY | TEMP ] [ TABLE ] <replaceable class="PARAMETER">new_table</replaceable> ]
    [ FROM <replaceable class="PARAMETER">from_item</replaceable> [, ...] ]
    [ WHERE <replaceable class="PARAMETER">condition</replaceable> ]
    [ GROUP BY <replaceable class="PARAMETER">expression</replaceable> [, ...] ]
    [ HAVING <replaceable class="PARAMETER">condition</replaceable> [, ...] ]
    [ { UNION | INTERSECT | EXCEPT } [ ALL ] <replaceable class="PARAMETER">select</replaceable> ]
    [ ORDER BY <replaceable class="parameter">expression</replaceable> [ ASC | DESC | USING <replaceable class="parameter">operator</replaceable> ] [ NULLS { FIRST | LAST } ] [, ...] ]
    [ LIMIT { <replaceable class="PARAMETER">count</replaceable> | ALL } ]
    [ OFFSET <replaceable class="PARAMETER">start</replaceable> ]
    [ FOR { UPDATE | SHARE } [ OF <replaceable class="parameter">table_name</replaceable> [, ...] ] [ NOWAIT ] [...] ]
</synopsis>
    </para>

    <para>
<!--
     Now we will illustrate the complex syntax of the
     <command>SELECT</command> statement with various examples. The
     tables used for the examples are defined in <xref
     linkend="supplier-fig" endterm="supplier-fig">.
-->
ここで様々な例で<command>SELECT</command>文の複雑な構文を説明します。
例で使われているテーブルは<xref linkend="supplier-fig" endterm="supplier-fig">で定義したものです。
    </para>

    <sect3>
<!--
     <title>Simple Selects</title>
-->
     <title>簡単な検索</title>

     <para>
<!--
      Here are some simple examples using a <command>SELECT</command> statement:
-->
<command>SELECT</command>文を使った簡単な例は以下の通りです。

      <example>
<!--
       <title id="simple-query">Simple Query with Qualification</title>
-->
<title id="simple-query">条件による簡単な問い合わせ</title>
       <para>
<!--
        To retrieve all tuples from table PART where the attribute PRICE is
        greater than 10 we formulate the following query:
-->
PARTテーブルから、PRICE属性が10を越える全てのタプルを検索するには、以下のような問い合わせを作ります。

<programlisting>
SELECT * FROM PART
    WHERE PRICE &gt; 10;
</programlisting>

<!--
        and get the table:
-->
結果が以下のように得られます。

<screen>
 PNO |  PNAME  |  PRICE
-----+---------+--------
  3  |  Bolt   |   15
  4  |  Cam    |   25
</screen>
       </para>

       <para>
<!--
        Using <quote>*</quote> in the <command>SELECT</command> statement
        will deliver all attributes from the table. If we want to retrieve
        only the attributes PNAME and PRICE from table PART we use the
        statement:
-->
<command>SELECT</command>文で<quote>*</quote>を使うと、テーブルの全て属性を取り出すことができます。
もしPARTテーブルからPNAME属性とPRICE属性だけを取り出したければ、以下の文を使用します。

<programlisting>
SELECT PNAME, PRICE
    FROM PART
    WHERE PRICE &gt; 10;
</programlisting>

<!--
        In this case the result is:
-->
この場合の結果は以下のようになります。

<screen>
                      PNAME  |  PRICE
                     --------+--------
                      Bolt   |   15
                      Cam    |   25
</screen>

<!--
        Note that the <acronym>SQL</acronym> <command>SELECT</command>
        corresponds to the <quote>projection</quote> in relational algebra
        not to the <quote>selection</quote> (see <xref linkend="rel-alg"
        endterm="rel-alg"> for more details).
-->
<acronym>SQL</acronym>の<command>SELECT</command>がリレーショナル代数における<quote>選択</quote>ではなく<quote>射影</quote>に当たることに注意してください（詳細は<xref linkend="rel-alg" endterm="rel-alg">を参照）。
       </para>

       <para>
<!--
        The qualifications in the WHERE clause can also be logically connected
        using the keywords OR, AND, and NOT:
-->
WHERE句における条件は、OR、AND、NOTといったキーワードを使用して論理的に繋げることができます。

<programlisting>
SELECT PNAME, PRICE
    FROM PART
    WHERE PNAME = 'Bolt' AND
         (PRICE = 0 OR PRICE &lt;= 15);
</programlisting>

<!--
        will lead to the result:
-->
以下のような結果が得られます。

<screen>
 PNAME  |  PRICE
--------+--------
 Bolt   |   15
</screen>
       </para>

       <para>
<!--
        Arithmetic operations can be used in the target list and in the WHERE
        clause. For example if we want to know how much it would cost if we
        take two pieces of a part we could use the following query:
-->
ターゲットリスト<footnote><para>訳注: SELECT文で指定する、取り出す属性のリストのことです。</para></footnote>やWHERE句では、算術演算も使用できます。
例えば、PARTテーブルの2倍の値段がどれくらいなのか知りたければ、以下のような問い合わせを発行することになります。

<programlisting>
SELECT PNAME, PRICE * 2 AS DOUBLE
    FROM PART
    WHERE PRICE * 2 &lt; 50;
</programlisting>

<!--
        and we get:
-->
結果は以下のように得られます。

<screen>
 PNAME  |  DOUBLE
--------+---------
 Screw  |    20
 Nut    |    16
 Bolt   |    30
</screen>

<!--
        Note that the word DOUBLE after the keyword AS is the new title of the
        second column. This technique can be used for every element of the
        target list to assign a new title to the resulting
        column. This new title
        is often referred to as alias. The alias cannot be used throughout the
        rest of the query.
-->
キーワードASの後にあるDOUBLEは2番目の列の新しい名称であるという点に注意してください。
このテクニックはターゲットリストの中の全ての要素に対して使用できるもので、結果の列に対して新しい名称を付けることができます。
この新しいタイトルは別名とも呼ばれます。
別名は問い合わせのターゲットリスト以外の場所では使用できません。
       </para>
      </example>
     </para>
    </sect3>

    <sect3>
<!--
     <title>Joins</title>
-->
     <title>結合</title>

     <para id="simple-join">
<!--
      The following example shows how <firstterm>joins</firstterm> are
      realized in <acronym>SQL</acronym>.
-->
以下の例は、<firstterm>結合</firstterm>が<acronym>SQL</acronym>でどのように表現されるかについて示しています。
     </para>

     <para>
<!--
      To join the three tables SUPPLIER, PART and SELLS over their common
      attributes we formulate the following statement:
-->
SUPPLIER、PART、SELLSという3つのテーブルを、共通の属性で結合するには、以下の文となります。

<programlisting>
SELECT S.SNAME, P.PNAME
    FROM SUPPLIER S, PART P, SELLS SE
    WHERE S.SNO = SE.SNO AND
          P.PNO = SE.PNO;
</programlisting>

<!--
      and get the following table as a result:
-->
結果として以下のようなテーブルが得られます。

<screen>
 SNAME | PNAME
-------+-------
 Smith | Screw
 Smith | Nut
 Jones | Cam
 Adams | Screw
 Adams | Bolt
 Blake | Nut
 Blake | Bolt
 Blake | Cam
</screen>
     </para>

     <para>
<!--
      In the FROM clause we introduced an alias name for every relation
      because there are common named attributes (SNO and PNO) among the
      relations. Now we can distinguish between the common named attributes
      by simply prefixing the attribute name with the alias name followed by
      a dot. The join is calculated in the same way as shown in
      <xref linkend="join-example" endterm="join-example">.
      First the Cartesian product

      SUPPLIER &times; PART &times; SELLS

      is derived. Now only those tuples satisfying the
      conditions given in the WHERE clause are selected (i.e., the common
      named attributes have to be equal). Finally we project out all
      columns but S.SNAME and P.PNAME.
-->
リレーションの中に同じ名前が付けられた属性（SNOとPNO）があるので、FROM句の中に各リレーションに対する別名が出てきています。
属性名の前に別名とドット（.）を付けることにより、同じ名前を持つ属性を区別することができます。
結合は<xref linkend="join-example" endterm="join-example">に出てくるのと同じ方法で計算されています。
まず、直積SUPPLIER &times; PART &times; SELLSを導き出します。
次にこれらのタプルからWHERE句で指定される条件を満たすものだけが選択されます（つまり、同じ名前が付けられた属性は等しくなければいけません）。
最後に、S.NAMEとP.PNAME以外の列だけを射影します。
     </para>

     <para>
<!--
     Another way to perform joins is to use the SQL JOIN syntax as follows:
-->
結合を行うもう1つの方法として、次のようにSQLのJOIN文を使うこともできます。
<programlisting>
SELECT sname, pname from supplier
    JOIN sells USING (sno)
    JOIN part USING (pno);
</programlisting>
<!--
    giving again:
-->
結果は前に示したものと同じです。
<screen>
 sname | pname
-------+-------
 Smith | Screw
 Adams | Screw
 Smith | Nut
 Blake | Nut
 Adams | Bolt
 Blake | Bolt
 Jones | Cam
 Blake | Cam
(8 rows)
</screen>
     </para>

     <para>
<!--
     A joined table, created using JOIN syntax, is a table reference list
     item that occurs in a FROM clause and before any WHERE, GROUP BY,
     or HAVING clause.  Other table references, including table names or
     other JOIN clauses, can be included in the FROM clause if separated
     by commas.  JOINed tables are logically like any other
     table listed in the FROM clause.
-->
JOIN構文で作成される結合テーブルは、FROM句内、かつ、WHERE句、GROUP BY句、HAVING句が始まる前にあるテーブル参照リストの項目です。
テーブル名やJOIN句以外を含む他のテーブル参照をカンマで区切ることで、FROM句内に含めることができます。
結合テーブルは、論理上FROM句で列挙される他のどのテーブルと同じです。
     </para>

     <para>
<!--
      SQL JOINs come in two main types, CROSS JOINs (unqualified joins)
      and <firstterm>qualified JOINs</>.  Qualified joins can be further
      subdivided based on the way in which the <firstterm>join condition</>
      is specified (ON, USING, or NATURAL) and the way in which it is
      applied (INNER or OUTER join).
-->
SQLのJOINには2つの主要な型があります。
交差結合（修飾なし結合）と<firstterm>修飾結合</>です。
修飾結合は、指定された<firstterm>結合条件</>(ON、USING、NATURAL)による方法と、それが適用される方法（内部結合または外部結合）によってさらに分類されます。
     </para>

    <variablelist>
<!--
        <title>Join Types</title>
-->
        <title>結合型</title>
        <varlistentry>
            <term>CROSS JOIN</term>
            <listitem>
            <cmdsynopsis>
                <arg choice="req"> <replaceable class="parameter">T1</replaceable> </arg>
                <command> CROSS JOIN </command>
                <arg choice="req"> <replaceable class="parameter">T2</replaceable> </arg>
            </cmdsynopsis>

            <para>
<!--
            A cross join takes two tables T1 and T2 having N and M rows
            respectively, and returns a joined table containing all
            N*M possible joined rows. For each row R1 of T1, each row
            R2 of T2 is joined with R1 to yield a joined table row JR
            consisting of all fields in R1 and R2. A CROSS JOIN is
            equivalent to an INNER JOIN ON TRUE.
-->
交差結合は、N行のテーブルT1とM行のテーブルT2について、互いの行のあらゆる組み合わせを行った結果のテーブル（N×M行）を返します。
T1の各行R1について、T2の各行R2をR1に結合した結果できる、結合テーブルの行をJRとします。
ここでJRにはR1、R2全ての属性が含まれています。
交差結合はINNER JOIN ON TRUEと同等です。
            </para>
            </listitem>
        </varlistentry>

        <varlistentry>
<!--
            <term>Qualified JOINs</term>
-->
            <term>修飾結合</term>
            <listitem>

            <cmdsynopsis>
            <arg choice="req"> <replaceable class="parameter">T1</replaceable> </arg>
            <arg choice="opt"> NATURAL </arg>
            <group choice="opt">
                <arg choice="opt"> INNER </arg>
                <arg choice="plain">
                <group choice="req">
                    <arg choice="plain"> LEFT </arg>
                    <arg choice="plain"> RIGHT </arg>
                    <arg choice="plain"> FULL </arg>
                </group>
                <arg choice="opt"> OUTER </arg>
                    </arg>
                </group>
            <command> JOIN </command>
            <arg choice="req"> <replaceable class="parameter">T2</replaceable> </arg>
            <group choice="req">
                <arg choice="plain"> ON <replaceable>search condition</replaceable></arg>
                <arg choice="plain"> USING ( <replaceable>join column list</replaceable> ) </arg>
            </group>
            </cmdsynopsis>

            <para>
<!--
            A qualified JOIN must specify its join condition
            by providing one (and only one) of NATURAL, ON, or
            USING.  The ON clause
            takes a <replaceable>search condition</replaceable>,
            which is the same as in a WHERE clause.  The USING
            clause takes a comma-separated list of column names,
            which the joined tables must have in common, and joins
            the tables on equality of those columns.  NATURAL is
            shorthand for a USING clause that lists all the common
            column names of the two tables.  A side-effect of both
            USING and NATURAL is that only one copy of each joined
            column is emitted into the result table (compare the
            relational-algebra definition of JOIN, shown earlier).
-->
修飾結合は、NATURAL、ON、USINGのうちの1つ（しかもたった1つだけ）を指定することによってその結合条件を指定しなければいけません。
ON句は、WHERE句と同じような<replaceable>search condition</replaceable>を取ります。
USING句は、カンマで区切られた列名のリストを取ります。
この列名を結合されるテーブルは共通に持っていなければならず、これらの列が等しいという条件で結合します。
NATURALは、2つのテーブルに共通の列名全てを並べたUSING句の短縮形です。
USINGとNATURALによる副作用は、結合された列のうちの1つのコピーだけが結果テーブルに現れることです（既に示したJOINのリレーショナル代数の定義と比較してください）。
            </para>

            <!-- 原文コメント begin join semantics -->
            <variablelist>
            <varlistentry>
                <term>
                    <cmdsynopsis>
                        <arg choice="opt"> INNER </arg>
                        <command> JOIN </command>
                    </cmdsynopsis>
                </term>
                <listitem>
                <para>
<!--
                For each row R1 of T1, the joined table has a row for each row
                in T2 that satisfies the join condition with R1.
-->
T1の各行R1について、T2の各行のうちR1との結合条件を満たしたものが結合後のテーブルの行に含まれます。 
                </para>
                <tip>
                <para>
<!--
                    The words INNER and OUTER are optional for all JOINs.
                    INNER is the default.  LEFT, RIGHT, and FULL imply an
                    OUTER JOIN.
-->
INNERとOUTERという単語は全ての結合で省略することができます。
INNERがデフォルトです。
LEFT、RIGHT、FULLを指定すると、自動的にOUTERも指定したことになります。
                    </para>
                </tip>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <cmdsynopsis>
                        <arg choice="plain"> LEFT </arg>
                        <arg choice="opt"> OUTER </arg>
                        <command> JOIN </command>
                    </cmdsynopsis>
                </term>
                <listitem>
                <para>
<!--
                First, an INNER JOIN is performed.
                Then, for each row in T1 that does not satisfy the join
                condition with any row in T2, an additional joined row is
                returned with null fields in the columns from T2.
-->
まず、INNER JOINが実行されます。
それから、T2のどの行をもってきても結合条件が満たされないようなT1の行について、T2の列に相当する部分にはNULLをセットして結合結果に追加します。
                </para>
                <tip>
                    <para>
<!--
                    The joined table unconditionally has a row for each row in T1.
-->
結合後のテーブルには、T1の全ての行に対応する行が無条件に含まれます。
                    </para>
                </tip>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <cmdsynopsis>
                        <arg choice="plain"> RIGHT </arg>
                        <arg choice="opt"> OUTER </arg>
                        <command> JOIN </command>
                    </cmdsynopsis>
                </term>
                <listitem>
                <para>
<!--
                First, an INNER JOIN is performed.
                Then, for each row in T2 that does not satisfy the join
                condition with any row in T1, an additional joined row is
                returned with null fields in the columns from T1.
-->
まず、INNER JOINが実行されます。
それから、T1のどの行を持ってきても結合条件が満たされないようなT2の行について、T1の列に相当する部分にはNULLをセットして結合結果に追加します。
                </para>
                <tip>
                    <para>
<!--
                    The joined table unconditionally has a row for each row in T2.
-->
結合後のテーブルには、T2の全ての行に対応する行が無条件に含まれます。
                    </para>
                </tip>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <cmdsynopsis>
                        <arg choice="plain"> FULL </arg>
                        <arg choice="opt"> OUTER </arg>
                        <command> JOIN </command>
                    </cmdsynopsis>
                </term>
                <listitem>
                <para>
<!--
                First, an INNER JOIN is performed.
                Then, for each row in T1 that does not satisfy the join
                condition with any row in T2, an additional joined row is
                returned with null fields in the columns from T2.
                Also, for each row in T2 that does not satisfy the join
                condition with any row in T1, an additional joined row is
                returned with null fields in the columns from T1.
-->
まず、INNER JOINが実行されます。
それから、T2のどの行をもってきても結合条件が満たされないようなT1の行について、T2の列に相当する部分にはNULLをセットして結合結果に追加します。
さらに同様に、T1のどの行をもってきても結合条件が満たされないようなT2の行について、T1の列に相当する部分にはNULLをセットして結合結果に追加します。
                </para>
                <tip>
                    <para>
<!--
                    The joined table unconditionally has a row for every row of T1
                    and a row for every row of T2.
-->
結合後のテーブルには、T1の全ての行に対応する行が無条件に含まれますし、T2の全ての行に対応する行も無条件に含まれます。
                    </para>
                </tip>
                </listitem>
            </varlistentry>
            </variablelist>
            <!-- 原文コメント end join semantics -->

            </listitem>
        </varlistentry>
     </variablelist>

     <para>
<!--
     JOINs of all types can be chained together or nested where either or both of
     <replaceable class="parameter">T1</replaceable> and
     <replaceable class="parameter">T2</replaceable> can be JOINed tables.
     Parenthesis can be used around JOIN clauses to control the order
     of JOINs which are otherwise processed left to right.
-->
結合はどんな型のものでも連結したりネストすることができます。
つまり<replaceable class="parameter">T1</replaceable>か<replaceable class="parameter">T2</replaceable>の一方もしくは両方を結合でできたテーブルとすることができます。
結合は通常左から右へ処理されますが、JOIN句を括弧で括って結合順を指定することもできます。
     </para>

    </sect3>

    <sect3>
<!--
     <title id="aggregates-tutorial">Aggregate Functions</title>
-->
     <title id="aggregates-tutorial">集約関数</title>

     <para>
<!--
      <acronym>SQL</acronym> provides aggregate functions such as AVG,
      COUNT, SUM, MIN, and MAX.  The argument(s) of an aggregate function
      are evaluated at each row that satisfies the WHERE
      clause, and the aggregate function is calculated over this set
      of input values.  Normally, an aggregate delivers a single
      result for a whole <command>SELECT</command> statement.  But if
      grouping is specified in the query, then a separate calculation
      is done over the rows of each group, and an aggregate result is
      delivered per group (see next section).
-->
<acronym>SQL</acronym>はAVG、COUNT、SUM、MIN、MAXなどの集約関数を提供しています。
集約関数の引数はWHERE句を満たすそれぞれの行に対して評価されます。
そして、この入力値の集合全体に対して、集約関数が計算されます。
通常集約は<command>SELECT</command>文に対して単一の結果を返します。
しかし、問い合わせにおいてグループ分けを行った場合には、それぞれのグループの行に対して別々に演算を行います。
そして、集約の結果はグループごとに返されます（次節を参照）。

      <example>
<!--
       <title id="aggregates-example">Aggregates</title>
-->
       <title id="aggregates-example">集約</title>

       <para>
<!--
        If we want to know the average cost of all parts in table PART we use
        the following query:
-->
PARTテーブルのすべての部品の平均値を知りたい場合には以下のような問い合わせを行います。

<programlisting>
SELECT AVG(PRICE) AS AVG_PRICE
    FROM PART;
</programlisting>
       </para>

       <para>
<!--
        The result is:
-->
結果は以下のようになります。

<screen>
 AVG_PRICE
-----------
   14.5
</screen>
       </para>

       <para>
<!--
        If we want to know how many parts are defined in table PART we use
        the statement:
-->
PARTテーブルで定義された部品数を知りたい場合には以下のようにします。

<programlisting>
SELECT COUNT(PNO)
    FROM PART;
</programlisting>

<!--
        and get:
-->
結果は以下の通りです。

<screen>
 COUNT
-------
   4
</screen>

       </para>
      </example>
     </para>
    </sect3>

    <sect3>
<!--
     <title>Aggregation by Groups</title>
-->
     <title>グループごとの集約</title>

     <para>
<!--
      <acronym>SQL</acronym> allows one to partition the tuples of a table
      into groups. Then the
      aggregate functions described above can be applied to the groups &mdash;
      i.e., the value of the aggregate function is no longer calculated over
      all the values of the specified column but over all values of a
      group. Thus the aggregate function is evaluated separately for every
      group.
-->
<acronym>SQL</acronym>ではテーブルのタプルをグループに分割させることができます。
それから、上で説明した集約関数は、各グループに適用させることができます。
つまり、指定した列の全ての値に対してではなく、各グループごとに集約関数が別々に適用されます。
したがって、集約関数は、各グループに対して別々に評価されます。
     </para>

     <para>
<!--
      The partitioning of the tuples into groups is done by using the
      keywords <command>GROUP BY</command> followed by a list of
      attributes that define the
      groups. If we have
      <command>GROUP BY A<subscript>1</subscript>, &tdot;, A<subscript>k</subscript></command>
      we partition
      the relation into groups, such that two tuples are in the same group
      if and only if they agree on all the attributes
      A<subscript>1</subscript>, &tdot;, A<subscript>k</subscript>.
-->
グループへのタプルの分割は<command>GROUP BY</command>というキーワードの後にグループを定義する属性のリストを続けることで行います。
<command>GROUP BY A<subscript>1</subscript>, &tdot;, A<subscript>k</subscript></command>とすれば、ある2つの行が同じグループに振り分けられるのは、属性A<subscript>1</subscript>, &tdot;, A<subscript>k</subscript>全てが等しくなっている場合だけに限ることになります。

      <example>
<!--
       <title id="aggregates-groupby">Aggregates</title>
-->
       <title id="aggregates-groupby">集約</title>
       <para>
<!--
        If we want to know how many parts are sold by every supplier we
        formulate the query:
-->
どのくらいの部品がそれぞれの納入業者で売られているか知りたい場合には、このような問い合わせが考えられます。

<programlisting>
SELECT S.SNO, S.SNAME, COUNT(SE.PNO)
    FROM SUPPLIER S, SELLS SE
    WHERE S.SNO = SE.SNO
    GROUP BY S.SNO, S.SNAME;
</programlisting>

<!--
        and get:
-->
結果は以下の通りです。

<screen>
 SNO | SNAME | COUNT
-----+-------+-------
  1  | Smith |   2
  2  | Jones |   1
  3  | Adams |   2
  4  | Blake |   3
</screen>
       </para>

       <para>
<!--
        Now let's have a look of what is happening here.
        First the join of the
        tables SUPPLIER and SELLS is derived:
-->
ここで何が起こったかを見てみましょう。
まず、SUPPLIERテーブルとSELLSテーブルの結合が行われます。

<screen>
 S.SNO | S.SNAME | SE.PNO
-------+---------+--------
   1   |  Smith  |   1
   1   |  Smith  |   2
   2   |  Jones  |   4
   3   |  Adams  |   1
   3   |  Adams  |   3
   4   |  Blake  |   2
   4   |  Blake  |   3
   4   |  Blake  |   4
</screen>
       </para>

       <para>
<!--
        Next we partition the tuples into groups by putting all tuples
        together that agree on both attributes S.SNO and S.SNAME:
-->
次に、S.NOとS.SNAMEの両方の属性が等しい全てのタプルを同じグループに分割します。

<screen>
 S.SNO | S.SNAME | SE.PNO
-------+---------+--------
   1   |  Smith  |   1
                 |   2
--------------------------
   2   |  Jones  |   4
--------------------------
   3   |  Adams  |   1
                 |   3
--------------------------
   4   |  Blake  |   2
                 |   3
                 |   4
</screen>
       </para>

       <para>
<!--
        In our example we got four groups and now we can apply the aggregate
        function COUNT to every group leading to the final result of the query
        given above.
-->
この例では、4つのグループを得ることができました。
そして、集約関数COUNTを各グループに適用し、上で示した問い合わせの最終結果を得ます。
       </para>
      </example>
     </para>

     <para>
<!--
      Note that for a query using GROUP BY and aggregate
      functions to make sense, the target list can only refer directly to
      the attributes being grouped by.  Other attributes can only be used
      inside the arguments of aggregate functions.  Otherwise there would
      not be a unique value to associate with the other attributes.
-->
GROUP BYと集約関数を使っている問い合わせが意味をなすためには、ターゲットリストの中に直接記述できる属性はGROUP BYで指定した属性のみであることに注意してください。
その他の属性は、集約関数の引数の内部からのみ使用することができます。
さもないと他の属性と関係付けられる一意の値が存在しないことになります。
     </para>

     <para>
<!--
      Also observe that it makes no sense to ask for an aggregate of
      an aggregate, e.g., AVG(MAX(sno)), because a
      <command>SELECT</command> only does one pass of grouping and
      aggregation.  You can get a result of this kind by using a
      temporary table or a sub-SELECT in the FROM clause to do the
      first level of aggregation.
-->
また、例えばAVG(MAX(sno))のように、集約の集約は意味がないことにも注意してください。
<command>SELECT</command>はグループ化と集約については1回の処理しかしないからです。
この種の結果を得るには、一時テーブル、もしくはFROM句で副問い合わせを使って、一番内側の集約の処理を行えばよいのです。
     </para>
    </sect3>

    <sect3>
     <title>Having</title>

     <para>
<!--
      The HAVING clause works much like the WHERE clause and is used to
      consider only those groups satisfying the qualification given in the
      HAVING clause.  Essentially, WHERE filters out unwanted input rows
      before grouping and aggregation are done, whereas HAVING filters out
      unwanted group rows post-GROUP.  Therefore, WHERE cannot refer to the
      results of aggregate functions.  On the other hand, there's no point
      in writing a HAVING condition that doesn't involve an aggregate
      function!  If your condition doesn't involve aggregates, you might
      as well write it in WHERE, and thereby avoid the computation of
      aggregates for groups that you're just going to throw away anyway.
-->
HAVING句はWHERE句のような働きをします。
つまりHAVING句で指定された条件を満たすグループのみが抽出されてSELECTの対象になります。
本質的に、WHERE句はグループ化と集約演算が行われる前に不必要な入力行を省くのに対して、HAVINGはGOURP化された後のグループのそれぞれの行に対して不必要なグループを省きます。
よって、WHEREは集約関数の結果を使うことができません。
一方で、HAVINGには集約関数を含むことができないなどの条件はありません!
条件に集約を含まないのであればWHEREを使って書いた方が良いでしょう。
その方が、結局は捨ててしまうグループに対する集約計算をしなくて済みます。

      <example>
       <title id="having-example">Having</title>

       <para>
<!--
        If we want only those suppliers selling more than one part we use the
        query:
-->
複数の部品を売っている納入業者のみを調べたい場合には、以下の問い合わせを行います。

<programlisting>
SELECT S.SNO, S.SNAME, COUNT(SE.PNO)
    FROM SUPPLIER S, SELLS SE
    WHERE S.SNO = SE.SNO
    GROUP BY S.SNO, S.SNAME
    HAVING COUNT(SE.PNO) &gt; 1;
</programlisting>

<!--
        and get:
-->
結果は以下の通りです。

<screen>
 SNO | SNAME | COUNT
-----+-------+-------
  1  | Smith |   2
  3  | Adams |   2
  4  | Blake |   3
</screen>
       </para>
      </example>
     </para>
    </sect3>

    <sect3>
<!--
     <title>Subqueries</title>
-->
     <title>副問い合わせ</title>

     <para>
<!--
      In the WHERE and HAVING clauses the use of subqueries (subselects) is
      allowed in every place where a value is expected. In this case the
      value must be derived by evaluating the subquery first. The usage of
      subqueries extends the expressive power of
      <acronym>SQL</acronym>.
-->
WHERE句とHAVING句で値が使えるような場所ならどこでも副問い合わせ（subqyery、subselect）が使用できます。
この場合、先に副問い合わせが評価され、得られた結果がその場所での値として使われます。
副問い合わせの使用は<acronym>SQL</acronym>の表現力を拡張するものです。

      <example>
<!--
       <title id="subselect-example">Subselect</title>
-->
       <title id="subselect-example">副問い合わせ</title>

       <para>
<!--
        If we want to know all parts having a greater price than the part
        named 'Screw' we use the query:
-->
「Screw」という名前の部品よりも値段が高い部品を全て検索したい場合には、以下のような問い合わせを行います。

<programlisting>
SELECT *
    FROM PART
    WHERE PRICE &gt; (SELECT PRICE FROM PART
                   WHERE PNAME='Screw');
</programlisting>
       </para>

       <para>
<!--
        The result is:
-->
結果は以下のようになります。

<screen>
 PNO |  PNAME  |  PRICE
-----+---------+--------
  3  |  Bolt   |   15
  4  |  Cam    |   25
</screen>
       </para>

       <para>
<!--
        When we look at the above query we can see the keyword
        <command>SELECT</command> two times. The first one at the
        beginning of the query - we will refer to it as outer
        <command>SELECT</command> - and the one in the WHERE clause which
        begins a nested query - we will refer to it as inner
        <command>SELECT</command>. For every tuple of the outer
        <command>SELECT</command> the inner <command>SELECT</command> has
        to be evaluated. After every evaluation we know the price of the
        tuple named 'Screw' and we can check if the price of the actual
        tuple is greater.  (Actually, in this example the inner query need
        only be evaluated once, since it does not depend on the state of
        the outer query.)
-->
上記の問い合わせでは、<command>SELECT</command>というキーワードが2回現れているのがわかります。
1つは問い合わせの最初にあるものですが、以下では「外側の<command>SELECT</command>」と呼ぶことにします。
もう1つはWHERE句の中にあって入れ子の問い合わせの始まりになっているもので、以下では「内側の<command>SELECT</command>」と呼ぶことにします。
外側の<command>SELECT</command>のあらゆるタプルに対して内側の<command>SELECT</command>が評価されていなければいけません。
内側の<command>SELECT</command>の評価をする度に、「Screw」という名前のタプルの値段がわかり、実際のタプルの価格がそれより高いかどうかが判断できます
（実際にはこの例では、内側の問い合わせは一度の評価のみしか必要とされません。
なぜならその結果は外側の問い合わせの状態に依存せずに決まるからです）。
       </para>

       <para>
<!--
        If we want to know all suppliers that do not sell any part
        (e.g., to be able to remove these suppliers from the database) we use:
-->
どの部品も売っていない納入業者を全て求める場合（例えば、データベースからこれらの納入業者を削除する場合）には以下を使用します。

<programlisting>
SELECT *
    FROM SUPPLIER S
    WHERE NOT EXISTS
        (SELECT * FROM SELLS SE
         WHERE SE.SNO = S.SNO);
</programlisting>
       </para>

       <para>
<!--
        In our example the result will be empty because every supplier
        sells at least one part. Note that we use S.SNO from the outer
        <command>SELECT</command> within the WHERE clause of the inner
        <command>SELECT</command>. Here the subquery must be evaluated
        afresh for each tuple from the outer query, i.e., the value for
        S.SNO is always taken from the current tuple of the outer
        <command>SELECT</command>.
-->
例ではどの納入業者も少なくとも1つの部品を売っているので、結果は空です。 
内側の<command>SELECT</command>のWHERE句中で外側の<command>SELECT</command>のS.SNOを使用していることに注意してください。
この場合は、外側の問い合わせの各タプルに対して、副問い合わせが新たに評価し直される必要があります。
すなわち、S.SNOの値は、外側の<command>SELECT</command>が現在処理しているタプルから常に取り出されます。
       </para>
      </example>
     </para>
    </sect3>

    <sect3>
<!--
     <title>Subqueries in FROM</title>
-->
     <title>FROM句中の副問い合わせ</title>

     <para>
<!--
      A somewhat different way of using subqueries is to put them in the
      FROM clause.  This is a useful feature because a subquery of this
      kind can output multiple columns and rows, whereas a subquery used
      in an expression must deliver just a single result.  It also lets
      us get more than one round of grouping/aggregation without resorting
      to a temporary table.
-->
副問い合わせの別の使い方は、FROM句に副問い合わせを使うことです。
このような使い方では副問い合わせが複数の列と行を出力することができるので非常に有効です。
一方、式の中の副問い合わせは単一の結果のみを返さなければいけません。
またこのような副問い合わせにより、一時テーブルを使うという手段を使うことなく、複数段のグループ化と集約計算を行うことができます。

      <example>
<!--
       <title id="subselect-in-from-example">Subselect in FROM</title>
-->
       <title id="subselect-in-from-example">FROM句中の副問い合わせ</title>

       <para>
<!--
        If we want to know the highest average part price among all our
        suppliers, we cannot write MAX(AVG(PRICE)), but we can write:
-->
全ての納入業者の中から部品の平均価格が最も高いところを知りたい場合でもMAX(AVG(PRICE))と書くことはできませんが、以下のように記述することができます。

<programlisting>
SELECT MAX(subtable.avgprice)
    FROM (SELECT AVG(P.PRICE) AS avgprice
          FROM SUPPLIER S, PART P, SELLS SE
          WHERE S.SNO = SE.SNO AND
                P.PNO = SE.PNO
          GROUP BY S.SNO) subtable;
</programlisting>

<!--
        The subquery returns one row per supplier (because of its GROUP BY)
        and then we aggregate over those rows in the outer query.
-->
この副問い合わせは納入業者1か所につき1つの行（GROUP BYを納入業者に適用したので）を返します。
そして、外側の問い合わせでこれらの行を集計します。
       </para>
      </example>
     </para>
    </sect3>

    <sect3>
<!--
     <title>Union, Intersect, Except</title>
-->
     <title>和、積、差</title>

     <para>
<!--
      These operations calculate the union, intersection and set theoretic
      difference of the tuples derived by two subqueries.
-->
これらの操作は、2つの副問い合わせによって得られたタプルに対する和、積、集合論的差を計算します。

      <example>
<!--
       <title id="union-example">Union, Intersect, Except</title>
-->
       <title id="union-example">和、積、差</title>

       <para>
<!--
        The following query is an example for UNION:
-->
以下の問い合わせはUNION（和）の例です。

<programlisting>
SELECT S.SNO, S.SNAME, S.CITY
    FROM SUPPLIER S
    WHERE S.SNAME = 'Jones'
UNION
    SELECT S.SNO, S.SNAME, S.CITY
    FROM SUPPLIER S
    WHERE S.SNAME = 'Adams';
</programlisting>

<!--
gives the result:
-->
結果は以下のように得られます。

<screen>
 SNO | SNAME |  CITY
-----+-------+--------
  2  | Jones | Paris
  3  | Adams | Vienna
</screen>
       </para>

       <para>
<!--
        Here is an example for INTERSECT:
-->
次はINTERSECT（積）の例です。

<programlisting>
SELECT S.SNO, S.SNAME, S.CITY
    FROM SUPPLIER S
    WHERE S.SNO &gt; 1
INTERSECT
    SELECT S.SNO, S.SNAME, S.CITY
    FROM SUPPLIER S
    WHERE S.SNO &lt; 3;
</programlisting>

<!--
        gives the result:
-->
結果は以下のように得られます。

<screen>
 SNO | SNAME |  CITY
-----+-------+--------
  2  | Jones | Paris
</screen>

<!--
        The only tuple returned by both parts of the query is the one having SNO=2.
-->
問い合わせの前後半どちらからの結果にも含まれる唯一のタプルはSNOが2のものものです。
       </para>

       <para>
<!--
        Finally an example for EXCEPT:
-->
最後はEXCEPT（差）の例です。

<programlisting>
SELECT S.SNO, S.SNAME, S.CITY
    FROM SUPPLIER S
    WHERE S.SNO &gt; 1
EXCEPT
    SELECT S.SNO, S.SNAME, S.CITY
    FROM SUPPLIER S
    WHERE S.SNO &gt; 3;
</programlisting>

<!--
        gives the result:
-->
結果は以下のように得られます。

<screen>
 SNO | SNAME |  CITY
-----+-------+--------
  2  | Jones | Paris
  3  | Adams | Vienna
</screen>
       </para>
      </example>
     </para>
    </sect3>
   </sect2>

   <sect2 id="datadef">
<!--
    <title>Data Definition</title>
-->
    <title>データ定義</title>

    <para>
<!--
     There is a set of commands used for data definition included in the
     <acronym>SQL</acronym> language.
-->
<acronym>SQL</acronym>言語には、データ定義に使われるコマンドがいくつか含まれます。 
    </para>

    <sect3 id="create">
     <title id="create-title">Create Table</title>

     <para>
<!--
      The most fundamental command for data definition is the
      one that creates a new relation (a new table). The syntax of the
      <command>CREATE TABLE</command> command is:
-->
データ定義における最も基本的なコマンドは新しいリレーション（テーブル）を作成するものです。
<command>CREATE TABLE</command>コマンドの構文は以下の通りです。

<synopsis>
CREATE TABLE <replaceable class="parameter">table_name</replaceable>
    (<replaceable class="parameter">name_of_attr_1</replaceable> <replaceable class="parameter">type_of_attr_1</replaceable>
     [, <replaceable class="parameter">name_of_attr_2</replaceable> <replaceable class="parameter">type_of_attr_2</replaceable>
     [, ...]]);
</synopsis>

      <example>
<!--
       <title id="table-create">Table Creation</title>
-->
       <title id="table-create">テーブルの作成</title>

       <para>
<!--
        To create the tables defined in
        <xref linkend="supplier-fig" endterm="supplier-fig"> the
        following <acronym>SQL</acronym> statements are used:
-->
以前に示した<xref linkend="supplier-fig" endterm="supplier-fig">のテーブル定義を<acronym>SQL</acronym>文で表すと以下のような記述になります。

<programlisting>
CREATE TABLE SUPPLIER
    (SNO   INTEGER,
     SNAME VARCHAR(20),
     CITY  VARCHAR(20));
</programlisting>

<programlisting>
CREATE TABLE PART
    (PNO   INTEGER,
     PNAME VARCHAR(20),
     PRICE DECIMAL(4 , 2));
</programlisting>

<programlisting>
CREATE TABLE SELLS
    (SNO INTEGER,
     PNO INTEGER);
</programlisting>
       </para>
      </example>
     </para>
    </sect3>

    <sect3>
<!--
     <title>Data Types in <acronym>SQL</acronym></title>
-->
     <title><acronym>SQL</acronym>のデータ型</title>

     <para>
<!--
      The following is a list of some data types that are supported by
      <acronym>SQL</acronym>:
-->
以下に、<acronym>SQL</acronym>でサポートされているいくつかのデータ型を示します。

      <itemizedlist>
       <listitem>
        <para>
<!--
         INTEGER: signed fullword binary integer (31 bits precision).
-->
INTEGER——符号付き整数（31ビットの精度）
        </para>
       </listitem>

       <listitem>
        <para>
<!--
         SMALLINT: signed halfword binary integer (15 bits precision).
-->
SMALLINT——符号付き整数（15ビット精度）
        </para>
       </listitem>

       <listitem>
        <para>
<!--
         DECIMAL (<replaceable class="parameter">p</replaceable>[,<replaceable class="parameter">q</replaceable>]):
         signed packed decimal number of up to
         <replaceable class="parameter">p</replaceable>
         digits, with
         <replaceable class="parameter">q</replaceable>
         digits to the right of the decimal point.
         If <replaceable class="parameter">q</replaceable>
         is omitted it is assumed to be 0.
-->
DECIMAL(<replaceable class="parameter">p</replaceable>[,<replaceable class="parameter">q</replaceable>])——小数点以上が<replaceable class="parameter">p</replaceable>桁までで、小数点以下が<replaceable class="parameter">q</replaceable>桁までの、符号付きのパック10進数。
<replaceable class="parameter">q</replaceable>が省略された場合には0とみなされます。
        </para>
       </listitem>

       <listitem>
        <para>
<!--
         FLOAT: signed doubleword floating point number.
-->
FLOAT——符号付き倍精度実数
        </para>
       </listitem>

       <listitem>
        <para>
<!--
         VARCHAR(<replaceable class="parameter">n</replaceable>):
         varying length character string of maximum length
         <replaceable class="parameter">n</replaceable>.
-->
VARCHAR(<replaceable class="parameter">n</replaceable>)——最大<replaceable class="parameter">n</replaceable>文字の可変長文字列
        </para>
       </listitem>

       <listitem>
        <para>
<!--
         CHAR(<replaceable class="parameter">n</replaceable>):
         fixed length character string of length
         <replaceable class="parameter">n</replaceable>.
-->
CHAR(<replaceable class="parameter">n</replaceable>)——長さ<replaceable class="parameter">n</replaceable>の固定長文字列
        </para>
       </listitem>

      </itemizedlist>
     </para>
    </sect3>

    <sect3>
<!--
     <title>Create Index</title>
-->
     <title>インデックスの作成</title>

     <para>
<!--
      Indexes are used to speed up access to a relation. If a relation <classname>R</classname>
      has an index on attribute <classname>A</classname> then we can
      retrieve all tuples <replaceable>t</replaceable>
      having
      <replaceable>t</replaceable>(<classname>A</classname>) = <replaceable>a</replaceable>
      in time roughly proportional to the number of such
      tuples <replaceable>t</replaceable>
      rather than in time proportional to the size of <classname>R</classname>.
-->
インデックスはリレーションにアクセスする速度を上げるために使用されます。
例えば、リレーション<classname>R</classname>の属性<classname>A</classname>にインデックスが付けられているものとします。
この時、<replaceable>t</replaceable>(<classname>A</classname>) = <replaceable>a</replaceable>であるようなタプル全部を取り出すのには、この条件を満たすタプルの数にほぼ比例する時間だけでできてしまい、<classname>R</classname>全体のタプル数に比例する時間はかかりません。
     </para>

     <para>
<!--
      To create an index in <acronym>SQL</acronym>
      the <command>CREATE INDEX</command> command is used. The syntax is:
-->
<acronym>SQL</acronym>におけるインデックスの作成には<command>CREATE INDEX</command>コマンドを使います。
構文は以下の通りです。

<programlisting>
CREATE INDEX <replaceable class="parameter">index_name</replaceable>
    ON <replaceable class="parameter">table_name</replaceable> ( <replaceable class="parameter">name_of_attribute</replaceable> );
</programlisting>
     </para>

     <para>
      <example>
<!--
       <title id="index-create">Create Index</title>
-->
       <title id="index-create">インデックスの作成</title>

       <para>
<!--
        To create an index named I on attribute SNAME of relation SUPPLIER
        we use the following statement:
-->
SUPPLIERリレーションのSNAME属性に「I」という名前のインデックスを作成する場合には、以下のような文となります。

<programlisting>
CREATE INDEX I ON SUPPLIER (SNAME);
</programlisting>
     </para>

       <para>
<!--
        The created index is maintained automatically, i.e., whenever a new
        tuple is inserted into the relation SUPPLIER the index I is
        adapted. Note that the only changes a user can perceive when an
        index is present are increased speed for <command>SELECT</command>
        and decreases in speed of updates.
-->
作成されたインデックスは自動的に更新されます。
つまりSUPPLIERリレーションに新しいタプルを挿入した時にはインデックスIも修正されます。
ユーザからみた場合にインデックスがあることによる違いは、<command>SELECT</command>の速度が上昇して、更新の速度が遅くなることだということに注意してください。
       </para>
      </example>
     </para>
    </sect3>

    <sect3>
<!--
     <title>Create View</title>
-->
     <title>ビューの作成</title>

     <para>
<!--
      A view can be regarded as a <firstterm>virtual table</firstterm>,
      i.e., a table that
      does not <emphasis>physically</emphasis> exist in the database
      but looks to the user
      as if it does. By contrast, when we talk of a
      <firstterm>base table</firstterm> there is
      really a physically stored counterpart of each row of the table
      somewhere in the physical storage.
-->
ビューは<firstterm>仮想的なテーブル</firstterm>と考えられます。
すなわちデータベース中に<emphasis>物理的に</emphasis>は存在しないがユーザにとってはそれが存在するように見えるということです。
一方、<firstterm>基本テーブル</firstterm>の場合には、テーブルのどの行に対しても物理的記憶領域が本当にどこかに存在します。
     </para>

     <para>
<!--
      Views do not have their own, physically separate, distinguishable
      stored data. Instead, the system stores the definition of the
      view (i.e., the rules about how to access physically stored base
      tables in order to materialize the view) somewhere in the system
      catalogs (see
      <xref linkend="tutorial-catalogs-title" endterm="tutorial-catalogs-title">). For a
      discussion on different techniques to implement views refer to
-->
ビューには、物理的に分離され区別できるような、独自のデータは格納されません。
その代わりに、システムがシステムカタログ（<xref linkend="tutorial-catalogs-title" endterm="tutorial-catalogs-title">を参照）でビューの定義を格納しています（つまり、ビューを実体化するために物理的に格納されている基本テーブルにアクセスする規則を格納しています）。
ビューの実装に関するその他の方法論については、<citetitle>SIM98</citetitle>を参照してください。
<!-- 原文コメント
      section
      <xref linkend="view-impl" endterm="view-impl">.
-->
<!--
      <citetitle>SIM98</citetitle>.
-->
     </para>

     <para>
<!--
      In <acronym>SQL</acronym> the <command>CREATE VIEW</command>
      command is used to define a view. The syntax
      is:
-->
<acronym>SQL</acronym>では、ビューの定義に<command>CREATE VIEW</command>コマンドを使用します。構文は以下の通りです。

<programlisting>
CREATE VIEW <replaceable class="parameter">view_name</replaceable>
    AS <replaceable class="parameter">select_stmt</replaceable>
</programlisting>

<!--
      where <replaceable class="parameter">select_stmt</replaceable>
      is a valid select statement as defined
      in <xref linkend="select-title" endterm="select-title">.
      Note that <replaceable class="parameter">select_stmt</replaceable> is
      not executed when the view is created. It is just stored in the
      <firstterm>system catalogs</firstterm>
      and is executed whenever a query against the view is made.
-->
<replaceable class="parameter">select_stmt</replaceable>には、<xref linkend="select-title" endterm="select-title">で定義されているSELECT文を記述します。
ビューを作成する際には、<replaceable class="parameter">select_stmt</replaceable>は実行されないという点に注意してください。
ビューは<firstterm>システムカタログ</firstterm>に格納されるだけで、ビューに対する問い合わせがある度にSELECT文が実行されるのです。
     </para>

     <para>
<!--
      Let the following view definition be given (we use
      the tables from
      <xref linkend="supplier-fig" endterm="supplier-fig"> again):
-->
以下のビュー定義を考えてみましょう（<xref linkend="supplier-fig" endterm="supplier-fig">で使われているテーブルを再び使用します）。

<programlisting>
CREATE VIEW London_Suppliers
    AS SELECT S.SNAME, P.PNAME
        FROM SUPPLIER S, PART P, SELLS SE
        WHERE S.SNO = SE.SNO AND
              P.PNO = SE.PNO AND
              S.CITY = 'London';
</programlisting>
     </para>

     <para>
<!--
      Now we can use this <firstterm>virtual relation</firstterm>
      <classname>London_Suppliers</classname> as
      if it were another base table:
-->
これで、<firstterm>仮想リレーション</firstterm>である<classname>London_Suppliers</classname>をあたかも基本テーブルの1つであるかのように使用することができます。

<programlisting>
SELECT * FROM London_Suppliers
    WHERE PNAME = 'Screw';
</programlisting>

<!--
      which will return the following table:
-->
以下のようなテーブルが返されます。

<screen>
 SNAME | PNAME
-------+-------
 Smith | Screw                 
</screen>
     </para>

     <para>
<!--
      To calculate this result the database system has to do a
      <emphasis>hidden</emphasis>
      access to the base tables SUPPLIER, SELLS and PART first. It
      does so by executing the query given in the view definition against
      those base tables. After that the additional qualifications
      (given in the
      query against the view) can be applied to obtain the resulting
      table.
-->
この結果を計算するために、データベースシステムは最初に基本テーブルSUPPLIER、SELL、PARTに<emphasis>隠れた</emphasis>アクセスをしなければいけません。
それはこれらの基本テーブルに対してビュー定義で与えられる問い合わせを実行することによって行われます。その後、さらなる選択（ビューに対する問い合わせで指定されている）が行われて、結果のテーブルが得られます。
     </para>
    </sect3>

    <sect3>
     <title>Drop Table, Drop Index, Drop View</title>

     <para>
<!--
      To destroy a table (including all tuples stored in that table) the
      <command>DROP TABLE</command> command is used:
-->
テーブルを削除する（テーブル中にある全てのタプルを含む）ためには、<command>DROP TABLE</command>コマンドを使用します。

<programlisting>
DROP TABLE <replaceable class="parameter">table_name</replaceable>;
</programlisting>
      </para>

     <para>
<!--
      To destroy the SUPPLIER table use the following statement:
-->
SUPPLIERテーブルを削除するには、以下のような文を使用します。

<programlisting>
DROP TABLE SUPPLIER;
</programlisting>
     </para>

     <para>
<!--
      The <command>DROP INDEX</command> command is used to destroy an index:
-->
<command>DROP INDEX</command>コマンドは、インデックスの削除に使用されます。

<programlisting>
DROP INDEX <replaceable class="parameter">index_name</replaceable>;
</programlisting>
     </para>

     <para>
<!--
      Finally to destroy a given view use the command <command>DROP
      VIEW</command>:
-->
最後に、ビューを削除するには<command>DROP VIEW</command>コマンドを使用します。

<programlisting>
DROP VIEW <replaceable class="parameter">view_name</replaceable>;
</programlisting>
     </para>
    </sect3>
   </sect2>

   <sect2>
<!--
    <title>Data Manipulation</title>
-->
<title>データ操作</title>

    <sect3>
     <title>Insert Into</title>

     <para>
<!--
      Once a table is created (see
      <xref linkend="create-title" endterm="create-title">), it can be filled
      with tuples using the command <command>INSERT INTO</command>.
      The syntax is:
-->
いったんテーブルが作成されると（<xref linkend="create-title" endterm="create-title">を参照）、<command>INSERT INTO</command>コマンドを使用してタプルを挿入することができます。
構文は以下の通りです。

<programlisting>
INSERT INTO <replaceable class="parameter">table_name</replaceable> (<replaceable class="parameter">name_of_attr_1</replaceable>
    [, <replaceable class="parameter">name_of_attr_2</replaceable> [, ...]])
    VALUES (<replaceable class="parameter">val_attr_1</replaceable> [, <replaceable class="parameter">val_attr_2</replaceable> [, ...]]);
</programlisting>
     </para>

     <para>
<!--
      To insert the first tuple into the relation SUPPLIER (from
      <xref linkend="supplier-fig" endterm="supplier-fig">) we use the
      following statement:
-->
SUPPLIERリレーション（<xref linkend="supplier-fig" endterm="supplier-fig">を参照）に最初のタプルを挿入するには以下の文を使用します。

<programlisting>
INSERT INTO SUPPLIER (SNO, SNAME, CITY)
    VALUES (1, 'Smith', 'London');
</programlisting>
     </para>

     <para>
<!--
      To insert the first tuple into the relation SELLS we use:
-->
SELLSリレーションに最初のタプルを挿入するには以下を使用します。

<programlisting>
INSERT INTO SELLS (SNO, PNO)
    VALUES (1, 1);
</programlisting>
     </para>
    </sect3>

    <sect3>
     <title>Update</title>

     <para>
<!--
      To change one or more attribute values of tuples in a relation the
      <command>UPDATE</command> command is used. The syntax is:
-->
あるリレーションで、いくつかのタプルの1つもしくは複数の属性値を変更する場合には、<command>UPDATE</command>コマンドを使用します。
構文は以下の通りです。

<programlisting>
UPDATE <replaceable class="parameter">table_name</replaceable>
    SET <replaceable class="parameter">name_of_attr_1</replaceable> = <replaceable class="parameter">value_1</replaceable>
        [, ... [, <replaceable class="parameter">name_of_attr_k</replaceable> = <replaceable class="parameter">value_k</replaceable>]]
    WHERE <replaceable class="parameter">condition</replaceable>;
</programlisting>
     </para>

     <para>
<!--
      To change the value of attribute PRICE of the part 'Screw' in the
      relation PART we use:
-->
PARTというリレーションで、「Screw」という部品の属性PRICEの値を変更するには以下のようにします。

<programlisting>
UPDATE PART
    SET PRICE = 15
    WHERE PNAME = 'Screw';
</programlisting>
     </para>

     <para>
<!--
      The new value of attribute PRICE of the tuple whose name is 'Screw' is
      now 15.
-->
名前が「Screw」のタプルのPRICE属性の新しい値は15になります。
     </para>
    </sect3>

    <sect3>
     <title>Delete</title>

     <para>
<!--
      To delete a tuple from a particular table use the command DELETE
      FROM. The syntax is:
-->
特定のテーブルのタプルを削除するには、DELETE FROMコマンドを使用します。
構文は以下の通りです。

<programlisting>
DELETE FROM <replaceable class="parameter">table_name</replaceable>
    WHERE <replaceable class="parameter">condition</replaceable>;
</programlisting>
     </para>

     <para>
<!--
      To delete the supplier called 'Smith' of the table SUPPLIER the
      following statement is used:
-->
SUPPLIERテーブルの納入業者「Smith」を削除するには以下の文を使用します。

<programlisting>
DELETE FROM SUPPLIER
    WHERE SNAME = 'Smith';
</programlisting>
     </para>
    </sect3>
   </sect2>

   <sect2 id="tutorial-catalogs">
<!--
    <title id="tutorial-catalogs-title">System Catalogs</title>
-->
<title id="tutorial-catalogs-title">システムカタログ</title>

    <para>
<!--
     In every <acronym>SQL</acronym> database system
     <firstterm>system catalogs</firstterm> are used to keep
     track of which tables, views indexes etc. are defined in the
     database. These system catalogs can be queried as if they were normal
     relations. For example there is one catalog used for the definition of
     views. This catalog stores the query from the view definition. Whenever
     a query against a view is made, the system first gets the
     <firstterm>view definition query</firstterm> out of the catalog
     and materializes the view
     before proceeding with the user query (see
-->
<!-- 原文コメント
      section
      <xref linkend="view-impl" endterm="view-impl">.
    <citetitle>SIM98</citetitle>
-->
<!--
     <xref linkend="SIM98" endterm="SIM98">
     for a more detailed
     description). For more information about system catalogs refer to
     <xref linkend="DATE04" endterm="DATE04">.
-->
全ての<acronym>SQL</acronym>データベースシステムで、データベースに定義されているテーブル、ビュー、インデックスなどの情報を保持するために<firstterm>システムカタログ</firstterm>が使われます。
システムカタログは、通常のリレーションのように問い合わせすることができます。
例えば、ビューの定義に使用されているカタログが1つあります。
このカタログはビューの定義となる問い合わせを格納しています。
ビューに対する問い合わせが行われる時はいつでも、システムはまず、<firstterm>ビュー定義の問い合わせ</firstterm> をカタログから取り出し、ユーザの問い合わせを実行する前にビューを実体化します（詳細は<xref linkend="SIM98" endterm="SIM98">を参照）。
システムカタログに関する詳細な情報は<xref linkend="DATE04" endterm="DATE04">を参照してください。
    </para>
   </sect2>

   <sect2>
<!--
    <title>Embedded <acronym>SQL</acronym></title>
-->
    <title>埋め込み<acronym>SQL</acronym></title>

    <para>
<!--
     In this section we will sketch how <acronym>SQL</acronym> can be
     embedded into a host language (e.g., <literal>C</literal>).
     There are two main reasons why we want to use <acronym>SQL</acronym>
     from a host language:
-->
本節では、ホスト言語（例えば <literal>C</literal>）に<acronym>SQL</acronym>を埋め込む方法の概略を解説します。
ホスト言語から<acronym>SQL</acronym>を使用したい理由としては主に2つのものがあります。

     <itemizedlist>
      <listitem>
       <para>
<!--
        There are queries that cannot be formulated using pure <acronym>SQL</acronym>
        (i.e., recursive queries). To be able to perform such queries we need a
        host language with a greater expressive power than
        <acronym>SQL</acronym>.
-->
純粋な<acronym>SQL</acronym>では表現できない問い合わせ（例えば再帰問い合わせ）があります。
このような問い合わせを実行するために<acronym>SQL</acronym>よりも表現力豊かなホスト言語が必要な場合。
       </para>
      </listitem>

      <listitem>
       <para>
<!--
        We simply want to access a database from some application that
        is written in the host language (e.g., a ticket reservation system
        with a graphical user interface is written in C and the information
        about which tickets are still left is stored in a database that can be
        accessed using embedded <acronym>SQL</acronym>).
-->
単純にそのホスト言語で作成されたアプリケーションからデータベースにアクセスしたい場合（例えば、グラフィカルユーザインタフェースを使ったチケット予約システムでは、全体はCで記述し、まだ売れ残っているチケットの情報は埋め込み<acronym>SQL</acronym>を通してデータベースにアクセスして蓄えておくなど）。
       </para>
      </listitem>
     </itemizedlist>
    </para>

    <para>
<!--
     A program using embedded <acronym>SQL</acronym>
     in a host language consists of statements
     of the host language and of
     <firstterm>embedded <acronym>SQL</acronym></firstterm>
     (<acronym>ESQL</acronym>) statements. Every <acronym>ESQL</acronym>
     statement begins with the keywords <command>EXEC SQL</command>.
     The <acronym>ESQL</acronym> statements are
     transformed to statements of the host language
     by a <firstterm>precompiler</firstterm>
     (which usually inserts
     calls to library routines that perform the various <acronym>SQL</acronym>
     commands).
-->
ホスト言語で埋め込み<acronym>SQL</acronym>を使用しているプログラムは、ホスト言語の文と<firstterm>埋め込み<acronym>SQL</acronym></firstterm>（<acronym>ESQL</acronym>）文で構成されます。
全ての<acronym>ESQL</acronym>文は<command>EXEC SQL</command>というキーワードで始まります。
<acronym>ESQL</acronym>文は、<firstterm>プリコンパイラ</firstterm>（通常は各種の<acronym>SQL</acronym>コマンドを実行するライブラリルーチンの呼び出しを挿入すること）によってホスト言語の文に置き換えられます。 
    </para>

    <para>
<!--
     When we look at the examples throughout
     <xref linkend="select-title" endterm="select-title"> we
     realize that the result of the queries is very often a set of
     tuples. Most host languages are not designed to operate on sets so we
     need a mechanism to access every single tuple of the set of tuples
     returned by a SELECT statement. This mechanism can be provided by
     declaring a <firstterm>cursor</firstterm>.
     After that we can use the <command>FETCH</command> command to
     retrieve a tuple and set the cursor to the next tuple.
-->
<xref linkend="select-title" endterm="select-title">で示した一連の例を見てみると、問い合わせの結果がたいていの場合タプルの集合であることがわかると思います。
大部分のホスト言語は集合を操作するように設計されておらず、SELECT文によって返されるタプルの集合から個々のタプルにアクセスするための何らかの仕組みが必要となります。
この仕組みは<firstterm>カーソル</firstterm>を宣言することによって得ることができます。
宣言した後は、<command>FETCH</command>コマンドを使えば、タプルを1つ取り出してカーソルを次のタプルに設定することができます。
    </para>

    <para>
<!--
     For a detailed discussion on embedded <acronym>SQL</acronym>
     refer to
     <xref linkend="DATE97" endterm="DATE97">,
     <xref linkend="DATE04" endterm="DATE04">,
     or
     <xref linkend="ULL88" endterm="ULL88">.
-->
埋め込み<acronym>SQL</acronym>に関する詳細な議論は、<xref linkend="DATE97" endterm="DATE97">、<xref linkend="DATE04" endterm="DATE04">、<xref linkend="ULL88" endterm="ULL88">などで述べられています。
    </para>
   </sect2>
  </sect1>
 </chapter>
