<!-- doc/src/sgml/protocol.sgml -->

<chapter id="protocol">
<!--
 <title>Frontend/Backend Protocol</title>
-->
<title>フロントエンド/バックエンドプロトコル</title>

 <indexterm zone="protocol">
<!--
  <primary>protocol</primary>
  <secondary>frontend-backend</secondary>
-->
<primary>プロトコル</primary>
<secondary>フロントエンド/バックエンド</secondary>
 </indexterm>

 <para>
<!--
  <productname>PostgreSQL</productname> uses a message-based protocol
  for communication between frontends and backends (clients and servers).
  The protocol is supported over <acronym>TCP/IP</acronym> and also over
  Unix-domain sockets.  Port number 5432 has been registered with IANA as
  the customary TCP port number for servers supporting this protocol, but
  in practice any non-privileged port number can be used.
-->
<productname>PostgreSQL</productname>はフロントエンドとバックエンド（クライアントとサーバ）の通信にメッセージベースのプロトコルを使用します。
このプロトコルは<acronym>TCP/IP</acronym>に加え、Unixドメインソケットをサポートします。
ポート番号5432は、このプロトコルをサポートするサーバ用のTCPポートとしてIANAに登録されています。
しかし、実際には任意の非特権ポート番号を使用することができます。
 </para>

 <para>
<!--
  This document describes version 3.0 of the protocol, implemented in
  <productname>PostgreSQL</productname> 7.4 and later.  For descriptions
  of the earlier protocol versions, see previous releases of the
  <productname>PostgreSQL</productname> documentation.  A single server
  can support multiple protocol versions.  The initial startup-request
  message tells the server which protocol version the client is attempting to
  use.  If the major version requested by the client is not supported by
  the server, the connection will be rejected (for example, this would occur
  if the client requested protocol version 4.0, which does not exist as of
  this writing).  If the minor version requested by the client is not
  supported by the server (e.g., the client requests version 3.1, but the
  server supports only 3.0), the server may either reject the connection or
  may respond with a NegotiateProtocolVersion message containing the highest
  minor protocol version which it supports.  The client may then choose either
  to continue with the connection using the specified protocol version or
  to abort the connection.
-->
この文書は<productname>PostgreSQL</productname> 7.4以降で実装されたプロトコル3.0バージョンについて記載します。
以前のプロトコルバージョンについての説明は、<productname>PostgreSQL</productname>の以前のリリースの文書を参照してください。
単一のサーバが複数のプロトコルバージョンをサポートできます。
初めの開始要求メッセージは、サーバに対し、クライアントが使用する予定のプロトコルバージョンを通知します。
クライアントが要求したメジャーバージョンをサーバがサポートしない場合は、接続は拒否されます。（これはたとえば、クライアントが本稿執筆時点で存在しないプロトコルバージョン4.0を要求した際に起るでしょう。）
クライアントが要求したマイナーバージョンをサーバがサポートしない場合は（たとえばクライアントがバージョン3.1を要求し、サーバが3.0しかサポートしていないようなときです）、サーバは接続を拒否しても良いですし、サポートする最も大きなマイナープロトコルバージョンを含むNegotiateProtocolVersionメッセージを返しても構いません。
クライアントは、指定されたプロトコルバージョンで接続を継続するか、あるいは接続を切断するかのどちらかを選択できます。
 </para>

  <para>
<!--
   In order to serve multiple clients efficiently, the server launches
   a new <quote>backend</quote> process for each client.
   In the current implementation, a new child
   process is created immediately after an incoming connection is detected.
   This is transparent to the protocol, however.  For purposes of the
   protocol, the terms <quote>backend</quote> and <quote>server</quote> are
   interchangeable; likewise <quote>frontend</quote> and <quote>client</quote>
   are interchangeable.
-->
複数のクライアントにサービスを効率的に提供するために、サーバは各クライアント毎に新規の<quote>バックエンド</quote>プロセスを起動します。
現在の実装では、サーバに接続が届いたことを検知すると即座に新しい子プロセスが生成されます。
しかし、これはプロトコルに対して透過的です。
プロトコルという意味では、<quote>バックエンド</quote>と<quote>サーバ</quote>という用語は相互交換可能です。
同様に<quote>フロントエンド</quote>と<quote>クライアント</quote>も相互交換可能です。
  </para>

 <sect1 id="protocol-overview">
<!--
  <title>Overview</title>
-->
<title>概要</title>

  <para>
<!--
   The protocol has separate phases for startup and normal operation.
   In the startup phase, the frontend opens a connection to the server
   and authenticates itself to the satisfaction of the server.  (This might
   involve a single message, or multiple messages depending on the
   authentication method being used.)  If all goes well, the server then sends
   status information to the frontend, and finally enters normal operation.
   Except for the initial startup-request message, this part of the
   protocol is driven by the server.
-->
このプロトコルでは、接続開始と通常操作で段階が分かれています。
接続開始段階で、フロントエンドはサーバへの接続を開き、サーバの義務を履行できるよう自身を証明します。
（これは使用する認証方法に応じて、単一のメッセージになったり、複数のメッセージになったりします。）
すべてうまく行けば、サーバはフロントエンドに状態情報を送信し、最終的に通常操作段階に入ります。
初期の開始要求メッセージを除いて、プロトコルのこの部分はサーバによって駆動されます。
  </para>

  <para>
<!--
   During normal operation, the frontend sends queries and
   other commands to the backend, and the backend sends back query results
   and other responses.  There are a few cases (such as <command>NOTIFY</command>)
   wherein the
   backend will send unsolicited messages, but for the most part this portion
   of a session is driven by frontend requests.
-->
通常操作の間、フロントエンドは問い合わせやその他のコマンドをバックエンドに送信し、バックエンドは問い合わせ結果やその他の応答を返送します。
（<command>NOTIFY</command>のように）バックエンドから依頼されずにメッセージが送信されるまれな場合がありますが、セッションのこの部分のほとんどはフロントエンドの要求によって駆動されます。
  </para>

  <para>
<!--
   Termination of the session is normally by frontend choice, but can be
   forced by the backend in certain cases.  In any case, when the backend
   closes the connection, it will roll back any open (incomplete) transaction
   before exiting.
-->
セッションの終了は通常フロントエンドが選択することですが、特定の場合はバックエンドによって強制される可能性があります。
どちらの場合でも、バックエンドが接続を閉ざす時、終了前に実行中の（未完の）トランザクションをすべてロールバックします。
  </para>

  <para>
<!--
   Within normal operation, SQL commands can be executed through either of
   two sub-protocols.  In the <quote>simple query</quote> protocol, the frontend
   just sends a textual query string, which is parsed and immediately
   executed by the backend.  In the <quote>extended query</quote> protocol,
   processing of queries is separated into multiple steps: parsing,
   binding of parameter values, and execution.  This offers flexibility
   and performance benefits, at the cost of extra complexity.
-->
通常操作中は、SQLコマンドを２つのサブプロトコルのうちのいずれかによって実行することができます。
<quote>簡易問い合わせ</quote>プロトコルでは、フロントエンドはテキストで問い合わせ文字列を単に送信し、バックエンドによって解析され、即実行されます。
<quote>拡張問い合わせ</quote>プロトコルでは、問い合わせの処理は、解析、パラメータ値の結び付け、そして実行という複数の段階に分離されます。
これは複雑性が加わりますが、柔軟性と性能という点で利点が生まれます。
  </para>

  <para>
<!--
   Normal operation has additional sub-protocols for special operations
   such as <command>COPY</command>.
-->
通常操作には、さらに、<command>COPY</command>のような特殊な操作向けのサブプロトコルがあります。
  </para>

 <sect2 id="protocol-message-concepts">
<!--
  <title>Messaging Overview</title>
-->
<title>メッセージ処理の概要</title>

  <para>
<!--
   All communication is through a stream of messages.  The first byte of a
   message identifies the message type, and the next four bytes specify the
   length of the rest of the message (this length count includes itself, but
   not the message-type byte).  The remaining contents of the message are
   determined by the message type.  For historical reasons, the very first
   message sent by the client (the startup message) has no initial
   message-type byte.
-->
すべての通信はメッセージストリームを介します。
メッセージの先頭バイトはメッセージ種類を識別するもの、次の４バイトはメッセージの残りの長さを指定するものです
（この長さにはメッセージ種類バイトは含まれませんが、自身を含んで数えられます）。
残りのメッセージの内容は、メッセージ種類で決まります。
歴史的な理由のため、一番初めにクライアントから送信されるメッセージ（開始メッセージ）にはメッセージ種類バイトはありません。
  </para>

  <para>
<!--
   To avoid losing synchronization with the message stream, both servers and
   clients typically read an entire message into a buffer (using the byte
   count) before attempting to process its contents.  This allows easy
   recovery if an error is detected while processing the contents.  In
   extreme situations (such as not having enough memory to buffer the
   message), the receiver can use the byte count to determine how much
   input to skip before it resumes reading messages.
-->
メッセージストリームの同期ずれを防ぐために、サーバとクライアントの両方は、通常、メッセージの内容を処理し始める前に、（バイト数を使用して）メッセージ全体をバッファ内に読み込みます。
これにより、その内容を処理する時にエラーが検出された場合に、簡単に復旧することができます。
（メッセージをバッファするために十分なメモリがない場合のような）極限状況では、受信側はメッセージの読み取りを再開する前にどれだけの量の入力を飛ばすかどうかを決定するために、バイト数を活用することができます。
  </para>

  <para>
<!--
   Conversely, both servers and clients must take care never to send an
   incomplete message.  This is commonly done by marshaling the entire message
   in a buffer before beginning to send it.  If a communications failure
   occurs partway through sending or receiving a message, the only sensible
   response is to abandon the connection, since there is little hope of
   recovering message-boundary synchronization.
-->
反対に、サーバとクライアントの両方は、不完全なメッセージを決して送信しないように注意しなければなりません。
これは通常、送信する前にバッファ内のメッセージ全体を整列させることで行われます。
メッセージの送受信の途中で通信エラーが発生した場合、メッセージ境界の同期を復旧できる望みはほとんどありませんので、実用的な唯一の応答は通信を中断することです。
  </para>
 </sect2>

  <sect2 id="protocol-query-concepts">
<!--
   <title>Extended Query Overview</title>
-->
<title>拡張問い合わせの概要</title>

   <para>
<!--
    In the extended-query protocol, execution of SQL commands is divided
    into multiple steps.  The state retained between steps is represented
    by two types of objects: <firstterm>prepared statements</firstterm> and
    <firstterm>portals</firstterm>.  A prepared statement represents the result of
    parsing and semantic analysis of a textual query string.
    A prepared statement is not in itself ready to execute, because it might
    lack specific values for <firstterm>parameters</firstterm>.  A portal represents
    a ready-to-execute or already-partially-executed statement, with any
    missing parameter values filled in.  (For <command>SELECT</command> statements,
    a portal is equivalent to an open cursor, but we choose to use a different
    term since cursors don't handle non-<command>SELECT</command> statements.)
-->
拡張問い合わせプロトコルでは、SQLコマンドの実行は複数の段階に分割されます。
段階間で保持される状態は、<firstterm>プリペアド文</firstterm>と<firstterm>ポータル</firstterm>の２種類のオブジェクトで表現されます。
プリペアド文は、テキスト問い合わせ文字列の解析、意味解析を表現します。
プリペアド文は実行準備が整ったことを示すものではありません。
<firstterm>パラメータ</firstterm>の特定の値が欠落しているかもしれないからです。
ポータルは、すべてのパラメータ値が設定され、実行準備が整った、あるいは、既に一部実行された文を表現します。
（<command>SELECT</command>文では、ポータルは開いているカーソルと等価です。
しかし、カーソルは<command>SELECT</command>以外の文を扱いませんので、ここでは異なる用語を使用するよう選択しました。）
   </para>

   <para>
<!--
    The overall execution cycle consists of a <firstterm>parse</firstterm> step,
    which creates a prepared statement from a textual query string; a
    <firstterm>bind</firstterm> step, which creates a portal given a prepared
    statement and values for any needed parameters; and an
    <firstterm>execute</firstterm> step that runs a portal's query.  In the case of
    a query that returns rows (<command>SELECT</command>, <command>SHOW</command>, etc),
    the execute step can be told to fetch only
    a limited number of rows, so that multiple execute steps might be needed
    to complete the operation.
-->
実行サイクル全体は、テキストの問い合わせ文字列からプリペアド文を生成する<firstterm>解析</firstterm>段階、プリペアド文と必要なパラメータ値によりポータルを作成する<firstterm>バインド</firstterm>段階、ポータルの問い合わせを実行する<firstterm>実行</firstterm>段階からなります。
行を返す問い合わせ（<command>SELECT</command>、<command>SHOW</command>など）の場合、操作を完了させるために複数の実行段階が必要とすることができるように、実行段階に限定された行数のみを取り出すよう指示することができます。
   </para>

   <para>
<!--
    The backend can keep track of multiple prepared statements and portals
    (but note that these exist only within a session, and are never shared
    across sessions).  Existing prepared statements and portals are
    referenced by names assigned when they were created.  In addition,
    an <quote>unnamed</quote> prepared statement and portal exist.  Although these
    behave largely the same as named objects, operations on them are optimized
    for the case of executing a query only once and then discarding it,
    whereas operations on named objects are optimized on the expectation
    of multiple uses.
-->
バックエンドは複数のプリペアド文とポータルの経過を追うことができます
（しかし、1つのセッション内でのみ存在可能です。複数のセッションで共有することはできません）。
存在するプリペアド文とポータルは、作成時に割り当てられた名前で参照されます。
さらに、<quote>無名の</quote>プリペアド文とポータルも存在します。
これらは名前付きのオブジェクトとほとんど同じ動きをしますが、問い合わせを一回だけ実行し、その後に破棄する場合に備えて、これらに対する操作は最適化されています。
一方、名前付きオブジェクトの操作は複数回の使用を想定して最適化されています。
   </para>
  </sect2>

  <sect2 id="protocol-format-codes">
<!--
   <title>Formats and Format Codes</title>
-->
<title>書式と書式コード</title>

   <para>
<!--
    Data of a particular data type might be transmitted in any of several
    different <firstterm>formats</firstterm>.  As of <productname>PostgreSQL</productname> 7.4
    the only supported formats are <quote>text</quote> and <quote>binary</quote>,
    but the protocol makes provision for future extensions.  The desired
    format for any value is specified by a <firstterm>format code</firstterm>.
    Clients can specify a format code for each transmitted parameter value
    and for each column of a query result.  Text has format code zero,
    binary has format code one, and all other format codes are reserved
    for future definition.
-->
特定のデータ型のデータはいくつかの異なる<firstterm>書式</firstterm>で転送することができます。
<productname>PostgreSQL</productname> 7.4の時点でサポートしている書式は<quote>テキスト</quote>と<quote>バイナリ</quote>のみですが、プロトコルは将来の拡張に備えて準備をしています。
任意の値の必要な書式は<firstterm>書式コード</firstterm>で指定されます。
クライアントは、転送されるパラメータ値それぞれに書式コードを指定することも、問い合わせ結果の列それぞれに書式コードを指定することもできます。
テキストは書式コード0、バイナリは書式コード1です。
他の書式コードは将来の定義用に予約されています。
   </para>

   <para>
<!--
    The text representation of values is whatever strings are produced
    and accepted by the input/output conversion functions for the
    particular data type.  In the transmitted representation, there is
    no trailing null character; the frontend must add one to received
    values if it wants to process them as C strings.
    (The text format does not allow embedded nulls, by the way.)
-->
値のテキスト表現は、特定のデータ型の入出力変換関数で生成され、受け付けられる何らかの文字列です。
転送時の表現では、ヌル終端文字はありません。
フロントエンドでC言語文字列として処理したい場合は、必ず受信した値にヌル終端文字を追加しなければなりません。
（ついでですが、テキスト書式ではヌルを埋め込むことはできません。）
   </para>

   <para>
<!--
    Binary representations for integers use network byte order (most
    significant byte first).  For other data types consult the documentation
    or source code to learn about the binary representation.  Keep in mind
    that binary representations for complex data types might change across
    server versions; the text format is usually the more portable choice.
-->
整数用のバイナリ表現はネットワークバイト順（先頭に最上位バイト）を使用します。
他のデータ型のバイナリ表現については、文書もしくはソースコードを参照してください。
複雑なデータ型のバイナリ表現はサーバのバージョンによって異なる可能性があることに注意してください。
通常、テキスト書式がより移植性が高い選択肢です。
   </para>
  </sect2>
 </sect1>

 <sect1 id="protocol-flow">
<!--
  <title>Message Flow</title>
-->
<title>メッセージの流れ</title>

  <para>
<!--
   This section describes the message flow and the semantics of each
   message type.  (Details of the exact representation of each message
   appear in <xref linkend="protocol-message-formats"/>.)  There are
   several different sub-protocols depending on the state of the
   connection: start-up, query, function call,
   <command>COPY</command>, and termination.  There are also special
   provisions for asynchronous operations (including notification
   responses and command cancellation), which can occur at any time
   after the start-up phase.
-->
本節では、メッセージの流れと各メッセージ種類のセマンティクスを説明します。
（各メッセージの正確な表現の詳細については<xref linkend="protocol-message-formats"/>で説明します。）
開始、問い合わせ、関数呼び出し、<command>COPY</command>、終了といった接続状態に応じて、複数の異なるサブプロトコルがあります。
また、開始段階の後の任意の時点で発生する可能性がある、非同期操作（通知応答やコマンドのキャンセルを含む）用の特別な準備もあります。
  </para>

  <sect2>
<!--
   <title>Start-up</title>
-->
<title>開始</title>

   <para>
<!--
    To begin a session, a frontend opens a connection to the server and sends
    a startup message.  This message includes the names of the user and of the
    database the user wants to connect to; it also identifies the particular
    protocol version to be used.  (Optionally, the startup message can include
    additional settings for run-time parameters.)
    The server then uses this information and
    the contents of its configuration files (such as
    <filename>pg_hba.conf</filename>) to determine
    whether the connection is provisionally acceptable, and what additional
    authentication is required (if any).
-->
セッションを開始するために、フロントエンドはサーバへの接続を開き、開始メッセージを送信します。
このメッセージには、ユーザ名と接続を希望するデータベース名が含まれます。
これはまた、使用する特定のプロトコルバージョンを識別します。
（オプションとして、開始メッセージに、実行時パラメータの追加設定を含めることもできます。）
サーバはその後、この情報と設定ファイル（<filename>pg_hba.conf</filename>など）の内容を使用して、接続が暫定的に受け付けられるかどうか、そして（もしあれば）どのような追加認証が必要かを決定します。
   </para>

   <para>
<!--
    The server then sends an appropriate authentication request message,
    to which the frontend must reply with an appropriate authentication
    response message (such as a password).
    For all authentication methods except GSSAPI, SSPI and SASL, there is at
    most one request and one response. In some methods, no response
    at all is needed from the frontend, and so no authentication request
    occurs. For GSSAPI, SSPI and SASL, multiple exchanges of packets may be
    needed to complete the authentication.
-->
サーバはその後、適切な認証要求メッセージを送信します。
フロントエンドはこれに適切な認証応答メッセージ（パスワードなど）で答えなければなりません。
GSSAPI、SSPI、SASLを除くすべての認証方式では、多くても１つの要求と１つの応答が存在します。
認証方式の中には、フロントエンドからの応答をまったく必要としないものもあり、その場合、認証要求も発生しません。
GSSAPI、SSPI、SASLでは認証を完了するために複数のパケットの交換が必要となるかもしれません。
   </para>

   <para>
<!--
    The authentication cycle ends with the server either rejecting the
    connection attempt (ErrorResponse), or sending AuthenticationOk.
-->
認証サイクルは、サーバによって接続要求を拒絶する（ErrorResponse）か、あるいはAuthenticationOkを送信することで終わります。
   </para>

   <para>
<!--
    The possible messages from the server in this phase are:
-->
この段階でサーバから送信される可能性があるメッセージを以下に示します。

    <variablelist>
     <varlistentry>
      <term>ErrorResponse</term>
      <listitem>
       <para>
<!--
        The connection attempt has been rejected.
        The server then immediately closes the connection.
-->
接続試行が拒絶されました。
サーバはその後即座に接続を閉ざします。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>AuthenticationOk</term>
      <listitem>
       <para>
<!--
        The authentication exchange is successfully completed.
-->
認証情報の交換が正常に完了しました。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>AuthenticationKerberosV5</term>
      <listitem>
       <para>
<!--
        The frontend must now take part in a Kerberos V5
        authentication dialog (not described here, part of the
        Kerberos specification) with the server.  If this is
        successful, the server responds with an AuthenticationOk,
        otherwise it responds with an ErrorResponse. This is no
        longer supported.
-->
フロントエンドはここでサーバとのKerberos V5認証ダイアログ（ここでは説明しません。Kerberos仕様の一部）に参加する必要があります。
これが成功すれば、サーバはAuthenticationOk応答を行います。
失敗すれば、ErrorResponse応答を行います。
これはもはやサポートされていません。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>AuthenticationCleartextPassword</term>
      <listitem>
       <para>
<!--
        The frontend must now send a PasswordMessage containing the
        password in clear-text form.  If
        this is the correct password, the server responds with an
        AuthenticationOk, otherwise it responds with an ErrorResponse.
-->
フロントエンドはここで平文形式のパスワードを含むPasswordMessageを送信する必要があります。
これが正しいパスワードであればサーバはAuthenticationOk応答を行います。
さもなくば、ErrorResponse応答を行います。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>AuthenticationMD5Password</term>
      <listitem>
       <para>
<!--
        The frontend must now send a PasswordMessage containing the
        password (with user name) encrypted via MD5, then encrypted
        again using the 4-byte random salt specified in the
        AuthenticationMD5Password message.  If this is the correct
        password, the server responds with an AuthenticationOk,
        otherwise it responds with an ErrorResponse.  The actual
        PasswordMessage can be computed in SQL as <literal>concat('md5',
        md5(concat(md5(concat(password, username)), random-salt)))</literal>.
        (Keep in mind the <function>md5()</function> function returns its
        result as a hex string.)
-->
フロントエンドはここでMD5で暗号化したパスワード（とユーザ名）を再度AuthenticationMD5Passwordメッセージで指定されたランダムな４バイトのソルトを使用して暗号化したものを含むPasswordMessageを送信する必要があります。
これが正しいパスワードであればサーバはAuthenticationOk応答を行います。
さもなくば、ErrorResponse応答を行います。
実際のPasswordMessageを<literal>concat('md5', md5(concat(md5(concat(password, username)), random-salt)))</literal>というSQLで計算することができます。
（<function>md5()</function>関数がその結果を１６進数表記で返すことに注意してください。）
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>AuthenticationSCMCredential</term>
      <listitem>
       <para>
<!--
        This response is only possible for local Unix-domain connections
        on platforms that support SCM credential messages.  The frontend
        must issue an SCM credential message and then send a single data
        byte.  (The contents of the data byte are uninteresting; it's
        only used to ensure that the server waits long enough to receive
        the credential message.)  If the credential is acceptable,
        the server responds with an
        AuthenticationOk, otherwise it responds with an ErrorResponse.
        (This message type is only issued by pre-9.1 servers.  It may
        eventually be removed from the protocol specification.)
-->
この応答はSCM資格証明メッセージをサポートするプラットフォーム上のローカルなUnixドメイン接続でのみあり得ます。
フロントエンドはSCM資格証明メッセージを発行し、その後単一のデータバイトを送信する必要があります。
（データバイトの内容には意味はありません。
これはサーバが資格証明メッセージの受信にどれだけ待機すればよいのかを確実にするためだけに使用されます。）
資格証明が受け付け可能であれば、サーバはAuthenticationOk応答を行います。
さもなくば、ErrorResponse応答を行います。
（この種類のメッセージは9.1より前のサーバでのみ発行されます。
最終的にはプロトコル仕様から削除されるかもしれません。）
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>AuthenticationGSS</term>
      <listitem>
       <para>
<!--
        The frontend must now initiate a GSSAPI negotiation. The frontend
        will send a GSSResponse message with the first part of the GSSAPI
        data stream in response to this. If further messages are needed,
        the server will respond with AuthenticationGSSContinue.
-->
ここでフロントエンドはGSSAPIの調停を開始しなければなりません。
これに対する応答におけるGSSAPIデータストリームの最初の部分で、フロントエンドはGSSResponseを送信します。
さらにメッセージが必要となる場合、サーバはAuthenticationGSSContinueで応答します。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>AuthenticationSSPI</term>
      <listitem>
       <para>
<!--
        The frontend must now initiate a SSPI negotiation. The frontend
        will send a GSSResponse with the first part of the SSPI
        data stream in response to this. If further messages are needed,
        the server will respond with AuthenticationGSSContinue.
-->
ここでフロントエンドはSSPI調停を開始しなければなりません。
これに対する応答におけるSSPIデータストリームの最初の部分で、フロントエンドはGSSResponseを送信します。
さらにメッセージが必要となる場合、サーバはAuthenticationGSSContinueで応答します。
       </para>
      </listitem>

     </varlistentry>
     <varlistentry>
      <term>AuthenticationGSSContinue</term>
      <listitem>
       <para>
<!--
        This message contains the response data from the previous step
        of GSSAPI or SSPI negotiation (AuthenticationGSS, AuthenticationSSPI
        or a previous AuthenticationGSSContinue). If the GSSAPI
        or SSPI data in this message
        indicates more data is needed to complete the authentication,
        the frontend must send that data as another GSSResponse message. If
        GSSAPI or SSPI authentication is completed by this message, the server
        will next send AuthenticationOk to indicate successful authentication
        or ErrorResponse to indicate failure.
-->
このメッセージには、GSSAPIまたはSSPI調停の直前の段階（AuthenticationGSS、AuthenticationSSPIまたは前回のAuthenticationGSSContinue）についての応答データが含まれます。
このメッセージ内のGSSAPIまたはSSPIデータが認証を完結させるため、更なる追加データが必要であることを指示している場合、フロントエンドは他のGSSResponseとしてデータを送信しなければなりません。
このメッセージでGSSAPIまたはSSPI認証が完了すれば、次にサーバはAuthenticationOkを送信して認証が成功したことを示すか、あるいはErrorResponseを送信して失敗したことを示します。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>AuthenticationSASL</term>
      <listitem>
       <para>
<!--
        The frontend must now initiate a SASL negotiation, using one of the
        SASL mechanisms listed in the message. The frontend will send a
        SASLInitialResponse with the name of the selected mechanism, and the
        first part of the SASL data stream in response to this. If further
        messages are needed, the server will respond with
        AuthenticationSASLContinue. See <xref linkend="sasl-authentication"/>
        for details.
-->
ここでフロントエンドはメッセージ内に列挙されているSASL機構の1つを使ってSASL調停を開始しなければなりません。
これに応答するSASLデータストリームの最初の部分で、フロントエンドはSASLInitialResponseと選択した機構の名前を送信します。
さらにメッセージが必要な場合、サーバはAuthenticationSASLContinueで応答します。
詳細については<xref linkend="sasl-authentication"/>を参照してください。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>AuthenticationSASLContinue</term>
      <listitem>
       <para>
<!--
        This message contains challenge data from the previous step of SASL
        negotiation (AuthenticationSASL, or a previous
        AuthenticationSASLContinue). The frontend must respond with a
        SASLResponse message.
-->
このメッセージには、SASL調停における直前の段階（AuthenticationSASLまたは以前のAuthenticationSASLContinue）のチャレンジデータが含まれます。
フロントエンドはSASLResponseメッセージで応答しなければなりません。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>AuthenticationSASLFinal</term>
      <listitem>
       <para>
<!--
        SASL authentication has completed with additional mechanism-specific
        data for the client. The server will next send AuthenticationOk to
        indicate successful authentication, or an ErrorResponse to indicate
        failure. This message is sent only if the SASL mechanism specifies
        additional data to be sent from server to client at completion.
-->
機構固有のクライアント用の追加データを伴ってSASL認証が完了します。
サーバは次に認証成功を示すAuthenticationOkを送信するか、あるいは失敗を示すErrorResponseを送信します。
このメッセージはSASLの機構が完了時にサーバからクライアントに送信する追加データを指定しているときにのみ送信されます。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>NegotiateProtocolVersion</term>
      <listitem>
       <para>
<!--
        The server does not support the minor protocol version requested
        by the client, but does support an earlier version of the protocol;
        this message indicates the highest supported minor version.  This
        message will also be sent if the client requested unsupported protocol
        options (i.e., beginning with <literal>_pq_.</literal>) in the
        startup packet.  This message will be followed by an ErrorResponse or
        a message indicating the success or failure of authentication.
-->
サーバはクライアントが要求したマイナープロトコルバージョンをサポートしませんが、それ以前のバージョンをサポートします。
このメッセージは、サポートしている最も高いマイナーバージョンを示します。
このメッセージは、クライアントがサポートされないプロトコルオプション（つまり<literal>_pq_.</literal>で始まる）をスタートアップパケットの中で指定した場合にも送られます。
このメッセージの後に、ErrorResponseか、認証が成功あるいは失敗したことを示すメッセージが続きます。
       </para>
      </listitem>
     </varlistentry>

    </variablelist>
   </para>

   <para>
<!--
    If the frontend does not support the authentication method
    requested by the server, then it should immediately close the
    connection.
-->
サーバが要求した認証方式をフロントエンドがサポートしていない場合、フロントエンドは即座に接続を閉ざします。
   </para>

   <para>
<!--
    After having received AuthenticationOk, the frontend must wait
    for further messages from the server.  In this phase a backend process
    is being started, and the frontend is just an interested bystander.
    It is still possible for the startup attempt
    to fail (ErrorResponse) or the server to decline support for the requested
    minor protocol version (NegotiateProtocolVersion), but in the normal case
    the backend will send some ParameterStatus messages, BackendKeyData, and
    finally ReadyForQuery.
-->
AuthenticationOkを受け取った後、フロントエンドはさらにサーバからのメッセージを待機する必要があります。
この段階で、バックエンドプロセスが起動し、このフロントエンドは単なる関心を有する第三者となります。
開始試行が失敗（ErrorResponse）するか、サーバが要求されたマイナープロトコルバージョンを拒否する（NegotiateProtocolVersion）可能性がまだありますが、通常、バックエンドは何らかのParameterStatusメッセージ、BackendKeyData、そして最後にReadyForQueryを送信します。
   </para>

   <para>
<!--
    During this phase the backend will attempt to apply any additional
    run-time parameter settings that were given in the startup message.
    If successful, these values become session defaults.  An error causes
    ErrorResponse and exit.
-->
この段階の期間中、バックエンドは開始メッセージで与えられた任意の実行時パラメータの追加設定を適用しようとします。
成功した場合は、これらの値はセッションのデフォルトになります。
エラーが発生した場合はErrorResponseを行い、終了します。
   </para>

   <para>
<!--
    The possible messages from the backend in this phase are:
-->
この段階でバックエンドから送信される可能性があるメッセージを以下に示します。

    <variablelist>
     <varlistentry>
      <term>BackendKeyData</term>
      <listitem>
       <para>
<!--
        This message provides secret-key data that the frontend must
        save if it wants to be able to issue cancel requests later.
        The frontend should not respond to this message, but should
        continue listening for a ReadyForQuery message.
-->
このメッセージは、フロントエンドがキャンセル要求を後で送信できるようにしたい場合に保存しなければならない、秘密キーデータを用意します。
フロントエンドはこのメッセージに応答してはいけませんが、ReadyForQueryメッセージの監視を続けなくてはなりません。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>ParameterStatus</term>
      <listitem>
       <para>
<!--
        This message informs the frontend about the current (initial)
         setting of backend parameters, such as <xref
         linkend="guc-client-encoding"/> or <xref linkend="guc-datestyle"/>.
         The frontend can ignore this message, or record the settings
         for its future use; see <xref linkend="protocol-async"/> for
         more details.  The frontend should not respond to this
         message, but should continue listening for a ReadyForQuery
         message.
-->
このメッセージは、フロントエンドに現在（初期）の<xref linkend="guc-client-encoding"/>や<xref linkend="guc-datestyle"/>などのバックエンドパラメータの設定情報を通知します。
フロントエンドはこのメッセージを無視しても、将来の使用に備えてその設定を記録しても構いません。
詳細は<xref linkend="protocol-async"/>を参照してください。
フロントエンドはこのメッセージに応答してはいけませんが、ReadyForQueryメッセージの監視を続けなくてはなりません。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>ReadyForQuery</term>
      <listitem>
       <para>
<!--
        Start-up is completed.  The frontend can now issue commands.
-->
開始処理が完了しました。
フロントエンドはここでコマンドを発行することができます。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>ErrorResponse</term>
      <listitem>
       <para>
<!--
        Start-up failed.  The connection is closed after sending this
        message.
-->
開始処理が失敗しました。
接続はこのメッセージの送信後に閉ざされます。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>NoticeResponse</term>
      <listitem>
       <para>
<!--
        A warning message has been issued.  The frontend should
        display the message but continue listening for ReadyForQuery
        or ErrorResponse.
-->
警告メッセージが発行されました。
フロントエンドはこのメッセージを表示し、ReadyForQueryもしくはErrorResponseメッセージの監視を続けなければなりません。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>

   <para>
<!--
    The ReadyForQuery message is the same one that the backend will
    issue after each command cycle.  Depending on the coding needs of
    the frontend, it is reasonable to consider ReadyForQuery as
    starting a command cycle, or to consider ReadyForQuery as ending the
    start-up phase and each subsequent command cycle.
-->
ReadyForQueryメッセージは各コマンドサイクルの後にバックエンドが発行するものと同じものです。
フロントエンドのコーディングにおいて必要であれば、ReadyForQueryをコマンドサイクルの開始とみなしても構いませんし、ReadyForQueryを開始段階とその後の各コマンドサイクルの終端とみなしても構いません。
   </para>
  </sect2>

  <sect2>
<!--
   <title>Simple Query</title>
-->
<title>簡易問い合わせ</title>

   <para>
<!--
    A simple query cycle is initiated by the frontend sending a Query message
    to the backend.  The message includes an SQL command (or commands)
    expressed as a text string.
    The backend then sends one or more response
    messages depending on the contents of the query command string,
    and finally a ReadyForQuery response message.  ReadyForQuery
    informs the frontend that it can safely send a new command.
    (It is not actually necessary for the frontend to wait for
    ReadyForQuery before issuing another command, but the frontend must
    then take responsibility for figuring out what happens if the earlier
    command fails and already-issued later commands succeed.)
-->
フロントエンドがQueryメッセージをバックエンドに送信することで、簡易問い合わせサイクルが開始されます。
このメッセージには、テキスト文字列で表現されたSQLコマンド（またはコマンド）が含まれます。
そうすると、バックエンドは、問い合わせコマンド文字列の内容に応じて1つ以上の応答を送信し、最終的にReadyForQueryを応答します。
ReadyForQueryは、新しいコマンドを安全に送信できることをフロントエンドに知らせます。
（実際には、フロントエンドが他のコマンドを発行する前にReadyForQueryを待機することは不要です。
しかし、フロントエンドは、前のコマンドが失敗し、発行済みの後のコマンドが成功した場合に何が起きるかを了解する責任を持たなければなりません。）
   </para>

   <para>
<!--
    The possible response messages from the backend are:
-->
バックエンドから送信される可能性がある応答メッセージを以下に示します。

    <variablelist>
     <varlistentry>
      <term>CommandComplete</term>
      <listitem>
       <para>
<!--
        An SQL command completed normally.
-->
SQLコマンドが正常に終了しました。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>CopyInResponse</term>
      <listitem>
       <para>
<!--
        The backend is ready to copy data from the frontend to a
        table; see <xref linkend="protocol-copy"/>.
-->
バックエンドがフロントエンドからのデータをテーブルにコピーする準備ができました。
<xref linkend="protocol-copy"/>を参照してください。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>CopyOutResponse</term>
      <listitem>
       <para>
<!--
        The backend is ready to copy data from a table to the
        frontend; see <xref linkend="protocol-copy"/>.
-->
バックエンドがデータをテーブルからフロントエンドにコピーする準備ができました。
<xref linkend="protocol-copy"/>を参照してください。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>RowDescription</term>
      <listitem>
       <para>
<!--
        Indicates that rows are about to be returned in response to
        a <command>SELECT</command>, <command>FETCH</command>, etc query.
        The contents of this message describe the column layout of the rows.
        This will be followed by a DataRow message for each row being returned
        to the frontend.
-->
<command>SELECT</command>や<command>FETCH</command>などの問い合わせの応答の行がまさに返されようとしていることを示します。
このメッセージには、行の列レイアウトに関する説明が含まれます。
このメッセージの後に、フロントエンドに返される各行に対するDataRowメッセージが続きます。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>DataRow</term>
      <listitem>
       <para>
<!--
        One of the set of rows returned by
        a <command>SELECT</command>, <command>FETCH</command>, etc query.
-->
<command>SELECT</command>や<command>FETCH</command>などの問い合わせで返される行の集合の1つです。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>EmptyQueryResponse</term>
      <listitem>
       <para>
<!--
        An empty query string was recognized.
-->
空の問い合わせ文字列が検知されました。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>ErrorResponse</term>
      <listitem>
       <para>
<!--
        An error has occurred.
-->
エラーが起こりました。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>ReadyForQuery</term>
      <listitem>
       <para>
<!--
        Processing of the query string is complete.  A separate
        message is sent to indicate this because the query string might
        contain multiple SQL commands.  (CommandComplete marks the
        end of processing one SQL command, not the whole string.)
        ReadyForQuery will always be sent, whether processing
        terminates successfully or with an error.
-->
問い合わせ文字列の処理が終了しました。
問い合わせ文字列は複数のSQLコマンドが含まれる場合があるため、このことを通知するために分離したメッセージが送出されます。
（CommandCompleteは文字列全体ではなく、1つのSQLコマンドの処理の終了を明らかにします。）
処理が成功またはエラーで終了したかどうかにかかわらずReadyForQueryは常に送出されます。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>NoticeResponse</term>
      <listitem>
       <para>
<!--
        A warning message has been issued in relation to the query.
        Notices are in addition to other responses, i.e., the backend
        will continue processing the command.
-->
問い合わせに関して警告メッセージが発行されました。
警告メッセージは他の応答に対する追加のメッセージです。
したがって、バックエンドはそのコマンドの処理を続行します。
       </para>
      </listitem>
     </varlistentry>

    </variablelist>
   </para>

   <para>
<!--
    The response to a <command>SELECT</command> query (or other queries that
    return row sets, such as <command>EXPLAIN</command> or <command>SHOW</command>)
    normally consists of RowDescription, zero or more
    DataRow messages, and then CommandComplete.
    <command>COPY</command> to or from the frontend invokes special protocol
    as described in <xref linkend="protocol-copy"/>.
    All other query types normally produce only
    a CommandComplete message.
-->
<command>SELECT</command>問い合わせ（あるいは、<command>EXPLAIN</command>や<command>SHOW</command>などの行集合を返す他の問い合わせ）に対する応答は、通常、RowDescription、0個以上のDataRowメッセージ、そしてその後のCommandCompleteから構成されます。
フロントエンドへの<command>COPY</command>もしくはフロントエンドからの<command>COPY</command>は<xref linkend="protocol-copy"/>で説明する特別なプロトコルを呼び出します。
他の種類の問い合わせは通常CommandCompleteメッセージのみを生成します。
   </para>

   <para>
<!--
    Since a query string could contain several queries (separated by
    semicolons), there might be several such response sequences before the
    backend finishes processing the query string.  ReadyForQuery is issued
    when the entire string has been processed and the backend is ready to
    accept a new query string.
-->
問い合わせ文字列には（セミコロンで区切られた）複数の問い合わせが含まれることがありますので、バックエンドが問い合わせ文字列の処理を完了する前に、こうした応答シーケンスが複数発生する可能性があります。
ReadyForQueryは、文字列全体が処理され、バックエンドが新しい問い合わせ文字列を受け付ける準備が整った時点で発行されます。
   </para>

   <para>
<!--
    If a completely empty (no contents other than whitespace) query string
    is received, the response is EmptyQueryResponse followed by ReadyForQuery.
-->
完全に空の（空白文字以外の文字がない）問い合わせ文字列を受け取った場合、その応答は、EmptyQueryResponse、続いて、ReadyForQueryとなります。
   </para>

   <para>
<!--
    In the event of an error, ErrorResponse is issued followed by
    ReadyForQuery.  All further processing of the query string is aborted by
    ErrorResponse (even if more queries remained in it).  Note that this
    might occur partway through the sequence of messages generated by an
    individual query.
-->
エラーが発生した場合、ErrorResponse、続いて、ReadyForQueryが発行されます。
その問い合わせ文字列に対する以降の処理は（複数の問い合わせが残っていたとしても）すべて、ErrorResponseによって中断されます。
これは、個々の問い合わせで生成されるメッセージの並びの途中で発生する可能性があることに注意してください。
   </para>

   <para>
<!--
    In simple Query mode, the format of retrieved values is always text,
    except when the given command is a <command>FETCH</command> from a cursor
    declared with the <literal>BINARY</literal> option.  In that case, the
    retrieved values are in binary format.  The format codes given in
    the RowDescription message tell which format is being used.
-->
簡易問い合わせモードでは、読み出される値の書式は常にテキストです。
ただし、与えられたコマンドが<literal>BINARY</literal>オプション付きで宣言されたカーソルからの<command>FETCH</command>であった場合は例外です。
この場合は、読み出される値はバイナリ書式になります。
RowDescriptionメッセージ内で与えられる書式コードは、どの書式が使用されているかを通知します。
   </para>

   <para>
<!--
    A frontend must be prepared to accept ErrorResponse and
    NoticeResponse messages whenever it is expecting any other type of
    message.  See also <xref linkend="protocol-async"/> concerning messages
    that the backend might generate due to outside events.
-->
他の種類のメッセージの受信を待機している時、フロントエンドは常にErrorResponseとNoticeResponseメッセージを受け取る準備ができていなければなりません。
また、外部イベントのためにバックエンドが生成する可能性があるメッセージの扱いについては<xref linkend="protocol-async"/>を参照してください。
   </para>

   <para>
<!--
    Recommended practice is to code frontends in a state-machine style
    that will accept any message type at any time that it could make sense,
    rather than wiring in assumptions about the exact sequence of messages.
-->
メッセージの正しい並びを前提としてコーディングするのではなく、任意のメッセージ種類を、そのメッセージが意味を持つ任意の時点で受け付ける状態マシン形式でフロントエンドのコーディングを行うことを推奨します。
   </para>

   <sect3 id="protocol-flow-multi-statement">
<!--
    <title>Multiple Statements in a Simple Query</title>
-->
    <title>簡易問い合わせでの複文</title>

    <para>
<!--
     When a simple Query message contains more than one SQL statement
     (separated by semicolons), those statements are executed as a single
     transaction, unless explicit transaction control commands are included
     to force a different behavior.  For example, if the message contains
-->
簡易Queryメッセージが二つ以上の（セミコロンで区切られた）SQL文を含むとき、振る舞いを変えるように明示的なトランザクション制御コマンドが含まれていない限り、これらの文は単一トランザクションで実行されます。
例えばメッセージが以下を含む場合、
<programlisting>
INSERT INTO mytable VALUES(1);
SELECT 1/0;
INSERT INTO mytable VALUES(2);
</programlisting>
<!--
     then the divide-by-zero failure in the <command>SELECT</command> will force
     rollback of the first <command>INSERT</command>.  Furthermore, because
     execution of the message is abandoned at the first error, the second
     <command>INSERT</command> is never attempted at all.
-->
<command>SELECT</command>でのゼロ除算エラーは最初の<command>INSERT</command>のロールバックを強制します。
さらに、メッセージの実行が最初のエラー時点で中止されるので、二番目の<command>INSERT</command>は全く試みられません。
    </para>

    <para>
<!--
     If instead the message contains
-->
代わりにメッセージが以下を含んでいる場合、
<programlisting>
BEGIN;
INSERT INTO mytable VALUES(1);
COMMIT;
INSERT INTO mytable VALUES(2);
SELECT 1/0;
</programlisting>
<!--
     then the first <command>INSERT</command> is committed by the
     explicit <command>COMMIT</command> command.  The second <command>INSERT</command>
     and the <command>SELECT</command> are still treated as a single transaction,
     so that the divide-by-zero failure will roll back the
     second <command>INSERT</command>, but not the first one.
-->
最初の<command>INSERT</command>は明示的な<command>COMMIT</command>コマンドによりコミットされます。
二番目の<command>INSERT</command>と<command>SELECT</command>は、やはり単一トランザクションとして処理されます。
そのためゼロ除算エラーが二番目の<command>INSERT</command>をロールバックしますが、最初の<command>INSERT</command>はロールバックされません。
    </para>

    <para>
<!--
     This behavior is implemented by running the statements in a
     multi-statement Query message in an <firstterm>implicit transaction
     block</firstterm> unless there is some explicit transaction block for them to
     run in.  The main difference between an implicit transaction block and
     a regular one is that an implicit block is closed automatically at the
     end of the Query message, either by an implicit commit if there was no
     error, or an implicit rollback if there was an error.  This is similar
     to the implicit commit or rollback that happens for a statement
     executed by itself (when not in a transaction block).
-->
この振る舞いは、<firstterm>暗黙トランザクションブロック</firstterm>で複文Queryメッセージ内の文を実行することで、その中に明示的なトランザクションブロックがある場合を除き、発現します。
暗黙トランザクションブロックと通常のトラザクションブロックとの主な違いは、暗黙ブロックは自動的にQueryメッセージの最後にて、エラーが無いなら暗黙のコミット、エラーがあるなら暗黙のロールバックで、自動的に閉じられることです。
これは（トランザクションブロック内に無いときの）文の単体実行に対して生じる暗黙のコミットあるいはロールバックに似ています。
    </para>

    <para>
<!--
     If the session is already in a transaction block, as a result of
     a <command>BEGIN</command> in some previous message, then the Query message
     simply continues that transaction block, whether the message contains
     one statement or several.  However, if the Query message contains
     a <command>COMMIT</command> or <command>ROLLBACK</command> closing the existing
     transaction block, then any following statements are executed in an
     implicit transaction block.
     Conversely, if a <command>BEGIN</command> appears in a multi-statement Query
     message, then it starts a regular transaction block that will only be
     terminated by an explicit <command>COMMIT</command> or <command>ROLLBACK</command>,
     whether that appears in this Query message or a later one.
     If the <command>BEGIN</command> follows some statements that were executed as
     an implicit transaction block, those statements are not immediately
     committed; in effect, they are retroactively included into the new
     regular transaction block.
-->
何らか手前のメッセージでの<command>BEGIN</command>の結果として、セッションが既にトランザクションブロック内である場合、Queryメッセージは、含まれるのが単一文でもいくつかの文でも、単にそのトランザクションを継続します。
しかしながら、Queryメッセージが既存トランザクションブロックを閉じる<command>COMMIT</command>や<command>ROLLBACK</command>を含む場合、続く全ての文は暗黙トランザクションブロックで実行されます。
逆に言えば、複文Queryメッセージで<command>BEGIN</command>が現れたなら、このQueryメッセージ内または後のメッセージのいずれかにあらわれる明示的な<command>COMMIT</command>や<command>ROLLBACK</command>でのみ終了する、通常のトランザクションブロックが開始されます。
<command>BEGIN</command>が暗黙トランザクションブロックとして実行されたいくつかの文に続く場合、これらの文が直ちにコミットされることはありません。
結果として、これらは遡って新たな通常のトランザクションブロックに含められます。
    </para>

    <para>
<!--
     A <command>COMMIT</command> or <command>ROLLBACK</command> appearing in an implicit
     transaction block is executed as normal, closing the implicit block;
     however, a warning will be issued since a <command>COMMIT</command>
     or <command>ROLLBACK</command> without a previous <command>BEGIN</command> might
     represent a mistake.  If more statements follow, a new implicit
     transaction block will be started for them.
-->
暗黙トランザクションブロック内に現れた<command>COMMIT</command>や<command>ROLLBACK</command>は通常通り実行され、暗黙ブロックを閉じますが、手前の<command>BEGIN</command>無しの<command>COMMIT</command>や<command>ROLLBACK</command>は誤りであるかもしれないので警告が発行されます。
さらに文が続く場合、それらに対して新たな暗黙トランザクションブロックが開始されます。
    </para>

    <para>
<!--
     Savepoints are not allowed in an implicit transaction block, since
     they would conflict with the behavior of automatically closing the
     block upon any error.
-->
エラー時の自動ブロッククローズの振る舞いと競合するので暗黙トランザクションブロックでセーブポイントは使えません。
    </para>

    <para>
<!--
     Remember that, regardless of any transaction control commands that may
     be present, execution of the Query message stops at the first error.
     Thus for example given
-->
現状のいかなるトランザクション制御コマンドでも、Queryメッセージの実行は最初のエラー時点で打ち切られることに留意してください。
例を示します。
<programlisting>
BEGIN;
SELECT 1/0;
ROLLBACK;
</programlisting>
<!--
     in a single Query message, the session will be left inside a failed
     regular transaction block, since the <command>ROLLBACK</command> is not
     reached after the divide-by-zero error.  Another <command>ROLLBACK</command>
     will be needed to restore the session to a usable state.
-->
上記が単一Queryメッセージにあるとして、ゼロ除算エラーの後に<command>ROLLBACK</command>に達することがないため、このセッションは失敗した通常のトランザクション内のままとなります。
このセッションを通常の状態に回復させるには別の<command>ROLLBACK</command>が必要となります。
    </para>

    <para>
<!--
     Another behavior of note is that initial lexical and syntactic
     analysis is done on the entire query string before any of it is
     executed.  Thus simple errors (such as a misspelled keyword) in later
     statements can prevent execution of any of the statements.  This
     is normally invisible to users since the statements would all roll
     back anyway when done as an implicit transaction block.  However,
     it can be visible when attempting to do multiple transactions within a
     multi-statement Query.  For instance, if a typo turned our previous
     example into
-->
その他の注意すべき振る舞いは、初期の字句および構文解析が少しも実行されない段階で問い合わせ文字列全体に対して行われることです。
従って、後ろの分にある（スペルミスしたキーワードなどの）単純なエラーは全ての文の実行を妨げることがあります。
暗黙トランザクションブロックとして起きたとき、いずれにせよ全ての文はロールバックされるので、これは通常はユーザに見えません。
しかしながら、複文問い合わせの中で複数のトランザクションを実行しようとするとき、この挙動が明らかになることがあります。
例えば、タイプミスで先の例を以下のようにします。
<programlisting>
BEGIN;
INSERT INTO mytable VALUES(1);
COMMIT;
INSERT INTO mytable VALUES(2);
SELCT 1/0;<!-- this typo is intentional -->
</programlisting>
<!--
     then none of the statements would get run, resulting in the visible
     difference that the first <command>INSERT</command> is not committed.
     Errors detected at semantic analysis or later, such as a misspelled
     table or column name, do not have this effect.
-->
そうすると、含まれる文は一つも実行されず、最初の<command>INSERT</command>がコミットされないという違いが明らかになります。
エラーは、ミススペルしたテーブルやカラム名など、語彙の解析かその後に検出され、コマンドの効力はありません。
    </para>
   </sect3>
  </sect2>

  <sect2 id="protocol-flow-ext-query">
<!--
   <title>Extended Query</title>
-->
<title>拡張問い合わせ</title>

   <para>
<!--
    The extended query protocol breaks down the above-described simple
    query protocol into multiple steps.  The results of preparatory
    steps can be re-used multiple times for improved efficiency.
    Furthermore, additional features are available, such as the possibility
    of supplying data values as separate parameters instead of having to
    insert them directly into a query string.
-->
拡張問い合わせプロトコルは、上述の簡易問い合わせプロトコルを複数段階に分解します。
予備段階の結果は複数回再利用できますので、効率が上がります。
さらに、問い合わせ文字列に直接埋め込むのではなく、データ値をパラメータとして分離して提供できる機能など、利用できる追加機能があります。
   </para>

   <para>
<!--
    In the extended protocol, the frontend first sends a Parse message,
    which contains a textual query string, optionally some information
    about data types of parameter placeholders, and the
    name of a destination prepared-statement object (an empty string
    selects the unnamed prepared statement).  The response is
    either ParseComplete or ErrorResponse.  Parameter data types can be
    specified by OID; if not given, the parser attempts to infer the
    data types in the same way as it would do for untyped literal string
    constants.
-->
拡張プロトコルでは、フロントエンドはまず、テキストの問い合わせ文字列とオプションとしてパラメータプレースホルダのデータ型情報やプリペアド文のオブジェクトの宛先名（空文字列は無名のプリペアド文を選択）を含む、Parseメッセージを送信します。
この応答はParseCompleteまたはErrorResponseです。
パラメータデータ型はそのOIDで指定することができます。
指定がなければ、パーサは型指定のないリテラル文字列定数に対する方法と同じ方法でデータ型を推定します。
   </para>

   <note>
    <para>
<!--
     A parameter data type can be left unspecified by setting it to zero,
     or by making the array of parameter type OIDs shorter than the
     number of parameter symbols (<literal>$</literal><replaceable>n</replaceable>)
     used in the query string.  Another special case is that a parameter's
     type can be specified as <type>void</type> (that is, the OID of the
     <type>void</type> pseudo-type).  This is meant to allow parameter symbols
     to be used for function parameters that are actually OUT parameters.
     Ordinarily there is no context in which a <type>void</type> parameter
     could be used, but if such a parameter symbol appears in a function's
     parameter list, it is effectively ignored.  For example, a function
     call such as <literal>foo($1,$2,$3,$4)</literal> could match a function with
     two IN and two OUT arguments, if <literal>$3</literal> and <literal>$4</literal>
     are specified as having type <type>void</type>.
-->
パラメータデータ型をゼロと設定する、または、問い合わせ文字列内で使用されているパラメータ記号（<literal>$</literal><replaceable>n</replaceable>）の数より短くパラメータ型のOIDの配列を作成することで、指定しないまま残すことができます。
他にも、パラメータの型を<type>void</type>（つまり<type>void</type>仮想型のOID）と指定するという特別な場合があります。
これは、パラメータ記号を、実際のOUTパラメータである関数パラメータとして使用することができることを意味します。
通常では、<type>void</type>パラメータが使用される文脈はありませんが、関数パラメータリストにこうしたパラメータ記号があると、実質的には無視されます。
例えば、<literal>$3</literal>と<literal>$4</literal>が<type>void</type>型を持つと指定された場合、<literal>foo($1,$2,$3,$4)</literal>といった関数呼び出しは、2つのINと2つのOUT引数を持つ関数に一致します。
    </para>
   </note>

   <note>
    <para>
<!--
     The query string contained in a Parse message cannot include more
     than one SQL statement; else a syntax error is reported.  This
     restriction does not exist in the simple-query protocol, but it
     does exist in the extended protocol, because allowing prepared
     statements or portals to contain multiple commands would complicate
     the protocol unduly.
-->
Parseメッセージ内の問い合わせ文字列には、複数のSQL文を含めることはできません。
さもないと、構文エラーが報告されます。
この制限は簡易問い合わせプロトコルにはありませんが、複数のコマンドを持つプリペアド文やポータルを許すと、プロトコルが複雑になり過ぎるため、拡張プロトコルではこの制限があります。
    </para>
   </note>

   <para>
<!--
    If successfully created, a named prepared-statement object lasts till
    the end of the current session, unless explicitly destroyed.  An unnamed
    prepared statement lasts only until the next Parse statement specifying
    the unnamed statement as destination is issued.  (Note that a simple
    Query message also destroys the unnamed statement.)  Named prepared
    statements must be explicitly closed before they can be redefined by
    another Parse message, but this is not required for the unnamed statement.
    Named prepared statements can also be created and accessed at the SQL
    command level, using <command>PREPARE</command> and <command>EXECUTE</command>.
-->
作成に成功すると、名前付きプリペアド文オブジェクトは明示的に破棄されない限り現在のセッションが終わるまで残ります。
無名のプリペアド文オブジェクトは、次に無名のプリペアド文を宛先に指定したParse文が発行されるまでの間のみに残ります。
（単なるQueryメッセージでも無名のプリペアド文オブジェクトは破壊されることに注意してください。）
名前付きプリペアド文は、他のParseメッセージで再定義する前に明示的に閉じなければなりません。
しかし、これは無名のプリペアド文では必要ありません。
名前付きプリペアド文はまた、SQLコマンドレベルで<command>PREPARE</command>と<command>EXECUTE</command>を使用して作成しアクセスすることができます。
   </para>

   <para>
<!--
    Once a prepared statement exists, it can be readied for execution using a
    Bind message.  The Bind message gives the name of the source prepared
    statement (empty string denotes the unnamed prepared statement), the name
    of the destination portal (empty string denotes the unnamed portal), and
    the values to use for any parameter placeholders present in the prepared
    statement.  The
    supplied parameter set must match those needed by the prepared statement.
    (If you declared any <type>void</type> parameters in the Parse message,
    pass NULL values for them in the Bind message.)
    Bind also specifies the format to use for any data returned
    by the query; the format can be specified overall, or per-column.
    The response is either BindComplete or ErrorResponse.
-->
プリペアド文が存在すると、Bindメッセージを使用してそれを実行可能状態にすることができます。
Bindメッセージは、元となるプリペアド文（空文字列は無名のプリペアド文を表します）の名前、宛先となるポータル（空文字列は無名ポータルを表します）の名前、およびプリペアド文内のパラメータプレースホルダに使用する値を与えます。
与えられたパラメータ集合はプリペアド文で必要とするものと一致しなければなりません。
（Parseメッセージ内で<type>void</type>パラメータを1つでも宣言した場合、BindメッセージではそれらにはNULLを渡します。）
また、Bindは問い合わせで返されるデータに使用する書式を指定します。
書式は全体に対して指定することも、列単位で指定することも可能です。
応答はBindCompleteもしくはErrorResponseです。
   </para>

   <note>
    <para>
<!--
     The choice between text and binary output is determined by the format
     codes given in Bind, regardless of the SQL command involved.  The
     <literal>BINARY</literal> attribute in cursor declarations is irrelevant when
     using extended query protocol.
-->
テキスト出力とバイナリ出力との選択は、含まれるSQLコマンドに関係なく、Bindで与えられた書式コードで決定されます。
拡張問い合わせプロトコルを使用する場合、カーソル宣言の<literal>BINARY</literal>属性は役に立ちません。
    </para>
   </note>

   <para>
<!--
    Query planning typically occurs when the Bind message is processed.
    If the prepared statement has no parameters, or is executed repeatedly,
    the server might save the created plan and re-use it during subsequent
    Bind messages for the same prepared statement.  However, it will do so
    only if it finds that a generic plan can be created that is not much
    less efficient than a plan that depends on the specific parameter values
    supplied.  This happens transparently so far as the protocol is concerned.
-->
典型的に問い合わせ計画はBindメッセージが処理される時に作成されます。
プリペアド文がパラメータを持たない場合、または繰り返し実行される場合、サーバは作成した計画を保管し、その後の同じプリペアド文に対するBindメッセージの際に再利用する可能性があります。
しかし、作成できる汎用的な計画が提供された特定のパラメータ値に依存する計画より効率が大して劣化しないことが分かった場合のみ、このように動作します。
プロトコルに注目している限り、これは透過的に行われます。
   </para>

   <para>
<!--
    If successfully created, a named portal object lasts till the end of the
    current transaction, unless explicitly destroyed.  An unnamed portal is
    destroyed at the end of the transaction, or as soon as the next Bind
    statement specifying the unnamed portal as destination is issued.  (Note
    that a simple Query message also destroys the unnamed portal.)  Named
    portals must be explicitly closed before they can be redefined by another
    Bind message, but this is not required for the unnamed portal.
    Named portals can also be created and accessed at the SQL
    command level, using <command>DECLARE CURSOR</command> and <command>FETCH</command>.
-->
作成に成功すると、名前付きポータルオブジェクトは明示的に破棄されない限り現在のセッションが終わるまで残ります。
無名ポータルは、トランザクションの終わり、もしくは、次に無名ポータルを宛先に指定したBind文が発行されるまでの間のみに残ります。
（単なるQueryメッセージでも無名ポータルは破壊されることに注意してください。）
名前付きポータルは、他のBindメッセージで再定義する前に明示的に閉じなければなりません。
しかし、これは無名ポータルでは必要ありません。
名前付きポータルはまた、SQLコマンドレベルで<command>DECLARE CURSOR</command>と<command>FETCH</command>を使用して作成しアクセスすることができます。
   </para>

   <para>
<!--
    Once a portal exists, it can be executed using an Execute message.
    The Execute message specifies the portal name (empty string denotes the
    unnamed portal) and
    a maximum result-row count (zero meaning <quote>fetch all rows</quote>).
    The result-row count is only meaningful for portals
    containing commands that return row sets; in other cases the command is
    always executed to completion, and the row count is ignored.
    The possible
    responses to Execute are the same as those described above for queries
    issued via simple query protocol, except that Execute doesn't cause
    ReadyForQuery or RowDescription to be issued.
-->
ポータルが存在すると、Executeメッセージを使用してそれを実行することができます。
Executeメッセージは、ポータル名（空文字列は無名ポータルを表します）と結果行数の最大値（ゼロは<quote>fetch all rows</quote>を意味します）を指定します。
結果行数は、ポータルが行集合を返すコマンドを含む場合のみ意味があります。
その他の場合では、コマンドは常に終わりまで実行され、行数は無視されます。
Executeで起こり得る応答は、ExecuteではReadyForQueryやRowDescriptionが発行されない点を除き、上述の簡易問い合わせプロトコル経由で発行された問い合わせの場合と同じです。
   </para>

   <para>
<!--
    If Execute terminates before completing the execution of a portal
    (due to reaching a nonzero result-row count), it will send a
    PortalSuspended message; the appearance of this message tells the frontend
    that another Execute should be issued against the same portal to
    complete the operation.  The CommandComplete message indicating
    completion of the source SQL command is not sent until
    the portal's execution is completed.  Therefore, an Execute phase is
    always terminated by the appearance of exactly one of these messages:
    CommandComplete, EmptyQueryResponse (if the portal was created from
    an empty query string), ErrorResponse, or PortalSuspended.
-->
Executeがポータルの実行を完了する前に（非ゼロの結果行数に達したために）終了した場合、PortalSuspendedを送信します。
このメッセージの出現は、フロントエンドに操作を完了させるためには同一のポータルに対して、別のExecuteを発行しなければならないことを通知します。
元となったSQLコマンドが完了したことを示すCommandCompleteメッセージはポータルが完了するまで送信されません。
したがって、Execute段階は常にCommandComplete、EmptyQueryResponse（空の問い合わせ文字列からポータルが作成された場合）、ErrorResponse、またはPortalSuspendedの中の、正確にどれかが出現することによって常に終了します。
   </para>

   <para>
<!--
    At completion of each series of extended-query messages, the frontend
    should issue a Sync message.  This parameterless message causes the
    backend to close the current transaction if it's not inside a
    <command>BEGIN</command>/<command>COMMIT</command> transaction block (<quote>close</quote>
    meaning to commit if no error, or roll back if error).  Then a
    ReadyForQuery response is issued.  The purpose of Sync is to provide
    a resynchronization point for error recovery.  When an error is detected
    while processing any extended-query message, the backend issues
    ErrorResponse, then reads and discards messages until a Sync is reached,
    then issues ReadyForQuery and returns to normal message processing.
    (But note that no skipping occurs if an error is detected
    <emphasis>while</emphasis> processing Sync &mdash; this ensures that there is one
    and only one ReadyForQuery sent for each Sync.)
-->
拡張問い合わせメッセージの一連の流れのそれぞれの終了時、フロントエンドはSyncメッセージを発行しなければなりません。
このパラメータのないメッセージにより、もし<command>BEGIN</command>/<command>COMMIT</command>トランザクションブロックの内部でなければ、バックエンドは現在のトランザクションを閉ざします
（<quote>閉ざす</quote>とは、エラーがなければコミット、エラーがあればロールバックすることを意味します）。
そして、ReadyForQuery応答が発行されます。
Syncの目的は、エラーからの復旧用の再同期を行う時点を提供することです。
拡張問い合わせメッセージの処理中にエラーが検出されると、バックエンドはErrorResponseを発行し、Syncが届くまでメッセージを読み、それを破棄します。
その後、ReadyForQueryを発行し、通常のメッセージ処理に戻ります。
（しかし、Sync処理<emphasis>中に</emphasis>エラーが検出された場合に処理が飛ばされないことに注意してください。
これにより、各Syncに対してReadyForQueryが1つのみであることを保証します。）
   </para>

   <note>
    <para>
<!--
     Sync does not cause a transaction block opened with <command>BEGIN</command>
     to be closed.  It is possible to detect this situation since the
     ReadyForQuery message includes transaction status information.
-->
Syncによって、<command>BEGIN</command>で開かれたトランザクションブロックが閉ざされることはありません。
ReadyForQueryメッセージにはトランザクションの状態情報が含まれていますので、この状況を検出することができます。
    </para>
   </note>

   <para>
<!--
    In addition to these fundamental, required operations, there are several
    optional operations that can be used with extended-query protocol.
-->
これらの基本的な必要操作に加え、拡張問い合わせプロトコルで使用することができる、複数の省略可能な操作があります。
   </para>

   <para>
<!--
    The Describe message (portal variant) specifies the name of an existing
    portal (or an empty string for the unnamed portal).  The response is a
    RowDescription message describing the rows that will be returned by
    executing the portal; or a NoData message if the portal does not contain a
    query that will return rows; or ErrorResponse if there is no such portal.
-->
Describeメッセージ（ポータルの亜種）は、既存のポータルの名前（もしくは、無名ポータル用の空文字）を指定します。
応答は、実行中のポータルで返される予定の行を記述するRowDescriptionメッセージです。
ポータルが行を返す問い合わせを含まない場合はNoDataメッセージです。
指定したポータルが存在しない場合はErrorResponseです。
   </para>

   <para>
<!--
    The Describe message (statement variant) specifies the name of an existing
    prepared statement (or an empty string for the unnamed prepared
    statement).  The response is a ParameterDescription message describing the
    parameters needed by the statement, followed by a RowDescription message
    describing the rows that will be returned when the statement is eventually
    executed (or a NoData message if the statement will not return rows).
    ErrorResponse is issued if there is no such prepared statement.  Note that
    since Bind has not yet been issued, the formats to be used for returned
    columns are not yet known to the backend; the format code fields in the
    RowDescription message will be zeroes in this case.
-->
Describeメッセージ（ステートメントの亜種）は、既存のプリペアド文の名前（もしくは無名のプリペアド文用の空文字）を指定します。
応答は、文で必要とされるパラメータを記述するParameterDescriptionメッセージ、続いて、文が実行された場合に返される予定の行を記述するRowDescriptionメッセージ（もしくは文が行を返さない場合のNoDataメッセージ）です。
指定したプリペアド文が存在しない場合はErrorResponseが発行されます。
Bindがまだ発行されていませんので、返される列の書式はまだバックエンドでは不明であることに注意してください。
RowDescriptionメッセージ内の書式コードフィールドはこの場合はゼロになります。
   </para>

   <tip>
    <para>
<!--
     In most scenarios the frontend should issue one or the other variant
     of Describe before issuing Execute, to ensure that it knows how to
     interpret the results it will get back.
-->
ほとんどの状況では、フロントエンドはExecuteを発行する前に、返ってくる結果を解釈する方法を確実に判断できるように、Describeもしくはその亜種を実行すべきです。
    </para>
   </tip>

   <para>
<!--
    The Close message closes an existing prepared statement or portal
    and releases resources.  It is not an error to issue Close against
    a nonexistent statement or portal name.  The response is normally
    CloseComplete, but could be ErrorResponse if some difficulty is
    encountered while releasing resources.  Note that closing a prepared
    statement implicitly closes any open portals that were constructed
    from that statement.
-->
Closeメッセージは、既存のプリペアド文、もしくはポータルを閉ざし、リソースを解放します。
存在しない文やポータルに対してCloseを発行してもエラーになりません。
応答は通常CloseCompleteですが、リソースの解放に何らかの問題が発生した場合はErrorResponseになります。
プリペアド文を閉じると、そこから構築され、開いたポータルが暗黙的に閉ざされることに注意してください。
   </para>

   <para>
<!--
    The Flush message does not cause any specific output to be generated,
    but forces the backend to deliver any data pending in its output
    buffers.  A Flush must be sent after any extended-query command except
    Sync, if the frontend wishes to examine the results of that command before
    issuing more commands.  Without Flush, messages returned by the backend
    will be combined into the minimum possible number of packets to minimize
    network overhead.
-->
Flushメッセージにより特定の出力が生成されることはありません。
しかし、バックエンドに対して、出力バッファ内で待機しているデータを強制的に配送させます。
フロントエンドが他のコマンドを発行する前にコマンドの結果を検証したい場合に、FlushはSync以外の拡張問い合わせコマンドの後に送信される必要があります。
Flushを行わないと、バックエンドで返されるメッセージは、ネットワークオーバーヘッドを最小化する、最小限のパケット数にまとめられます。
   </para>

   <note>
    <para>
<!--
     The simple Query message is approximately equivalent to the series Parse,
     Bind, portal Describe, Execute, Close, Sync, using the unnamed prepared
     statement and portal objects and no parameters.  One difference is that
     it will accept multiple SQL statements in the query string, automatically
     performing the bind/describe/execute sequence for each one in succession.
     Another difference is that it will not return ParseComplete, BindComplete,
     CloseComplete, or NoData messages.
-->
簡易問い合わせメッセージは、おおよそ、無名のプリペアド文とポータルオブジェクトを使用したパラメータなしのParse、Bind、ポータル用Describe、Execute、Close、Syncの流れと同一です。
違いは、問い合わせ文字列内に複数のSQL文を受け付けられ、bind/describe/executeという流れがそれぞれが成功すれば自動的に行われる点です。
他の違いとして、ParseCompleteやBindComplete、CloseComplete、NoDataメッセージが返されない点があります。
    </para>
   </note>
  </sect2>

  <sect2>
<!--
   <title>Function Call</title>
-->
<title>関数呼び出し</title>

   <para>
<!--
    The Function Call sub-protocol allows the client to request a direct
    call of any function that exists in the database's
    <structname>pg_proc</structname> system catalog.  The client must have
    execute permission for the function.
-->
関数呼び出しサブプロトコルにより、クライアントはデータベースの<structname>pg_proc</structname>システムカタログに存在する任意の関数を直接呼び出す要求を行うことができます。
クライアントはその関数を実行する権限を持たなければなりません。
   </para>

   <note>
    <para>
<!--
     The Function Call sub-protocol is a legacy feature that is probably best
     avoided in new code.  Similar results can be accomplished by setting up
     a prepared statement that does <literal>SELECT function($1, ...)</literal>.
     The Function Call cycle can then be replaced with Bind/Execute.
-->
関数呼び出しサブプロトコルは、おそらく新しく作成するコードでは使用すべきではない古い機能です。
同様の結果は、<literal>SELECT function($1, ...)</literal>を行うプリペアド文を設定することで得ることができます。
そして、この関数呼び出しサイクルをBind/Executeで置き換えることができます。
    </para>
   </note>

   <para>
<!--
    A Function Call cycle is initiated by the frontend sending a
    FunctionCall message to the backend.  The backend then sends one
    or more response messages depending on the results of the function
    call, and finally a ReadyForQuery response message.  ReadyForQuery
    informs the frontend that it can safely send a new query or
    function call.
-->
関数呼び出しサイクルはフロントエンドがFunctionCallメッセージをバックエンドに送ることで起動されます。
バックエンドは1つまたは複数の応答メッセージを関数呼び出しの結果に基づいて送り、最終的にReadyForQueryメッセージを送出します。
ReadyForQueryはフロントエンドに対し新規の問い合わせまたは関数呼び出しを行っても安全確実であることを通知します。
   </para>

   <para>
<!--
    The possible response messages from the backend are:
-->
バックエンドから送信される可能性がある応答メッセージを以下に示します。

    <variablelist>
     <varlistentry>
      <term>ErrorResponse</term>
      <listitem>
       <para>
<!--
        An error has occurred.
-->
エラーが起こりました。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>FunctionCallResponse</term>
      <listitem>
       <para>
<!--
        The function call was completed and returned the result given
        in the message.
        (Note that the Function Call protocol can only handle a single
        scalar result, not a row type or set of results.)
-->
関数呼び出しが完了し、メッセージで与えられた結果が返されました。
（関数呼び出しプロトコルは単一のスカラ結果のみを扱うことができます。行型や結果集合を扱うことはできません。）
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>ReadyForQuery</term>
      <listitem>
       <para>
<!--
        Processing of the function call is complete.  ReadyForQuery
        will always be sent, whether processing terminates
        successfully or with an error.
-->
関数呼び出しの処理が終了しました。
処理が成功またはエラーで終了したかどうかにかかわらずReadyForQueryは常に送出されます。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>NoticeResponse</term>
      <listitem>
       <para>
<!--
        A warning message has been issued in relation to the function
        call.  Notices are in addition to other responses, i.e., the
        backend will continue processing the command.
-->
関数呼び出しに関して警告メッセージが出されました。
警告メッセージは他の応答に対する追加のメッセージです。
したがって、バックエンドはそのコマンドの処理を続行します。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </sect2>

  <sect2 id="protocol-copy">
<!--
   <title>COPY Operations</title>
-->
<title>COPY操作</title>

   <para>
<!--
    The <command>COPY</command> command allows high-speed bulk data transfer
    to or from the server.  Copy-in and copy-out operations each switch
    the connection into a distinct sub-protocol, which lasts until the
    operation is completed.
-->
<command>COPY</command>コマンドにより、サーバとの間で高速な大量データ転送を行うことができます。
コピーインとコピーアウト操作はそれぞれ接続を別のサブプロトコルに切り替えます。
これは操作が完了するまで残ります。
   </para>

   <para>
<!--
    Copy-in mode (data transfer to the server) is initiated when the
    backend executes a <command>COPY FROM STDIN</command> SQL statement.  The backend
    sends a CopyInResponse message to the frontend.  The frontend should
    then send zero or more CopyData messages, forming a stream of input
    data.  (The message boundaries are not required to have anything to do
    with row boundaries, although that is often a reasonable choice.)
    The frontend can terminate the copy-in mode by sending either a CopyDone
    message (allowing successful termination) or a CopyFail message (which
    will cause the <command>COPY</command> SQL statement to fail with an
    error).  The backend then reverts to the command-processing mode it was
    in before the <command>COPY</command> started, which will be either simple or
    extended query protocol.  It will next send either CommandComplete
    (if successful) or ErrorResponse (if not).
-->
コピーインモード（サーバへのデータ転送）は、バックエンドが<command>COPY FROM STDIN</command> SQL文を実行した時に起動されます。
バックエンドはフロントエンドにCopyInResponseメッセージを送信します。
フロントエンドはその後、ゼロ個以上のCopyDataメッセージを送信し、入力データのストリームを形成します。
（このメッセージの境界は行の境界に何かしら合わせる必要ありませんが、往々にしてそれが合理的な選択となります。）
フロントエンドは、CopyDoneメッセージ（正常に終了させる）、もしくは、CopyFailメッセージ（<command>COPY</command> SQL文をエラーで失敗させる）を送信することで、コピーインモードを終了させることができます。
そして、バックエンドは、<command>COPY</command>が始まる前の、簡易もしくは拡張問い合わせプロトコルを使用するコマンド処理モードに戻ります。
そして次に、CommandComplete（成功時）またはErrorResponse（失敗時）のどちらかを送信します。
   </para>

   <para>
<!--
    In the event of a backend-detected error during copy-in mode (including
    receipt of a CopyFail message), the backend will issue an ErrorResponse
    message.  If the <command>COPY</command> command was issued via an extended-query
    message, the backend will now discard frontend messages until a Sync
    message is received, then it will issue ReadyForQuery and return to normal
    processing.  If the <command>COPY</command> command was issued in a simple
    Query message, the rest of that message is discarded and ReadyForQuery
    is issued.  In either case, any subsequent CopyData, CopyDone, or CopyFail
    messages issued by the frontend will simply be dropped.
-->
コピーインモードの期間中にバックエンドがエラー（CopyFailメッセージの受信を含む）を検知すると、バックエンドはErrorResponseメッセージを発行します。
拡張問い合わせメッセージ経由で<command>COPY</command>コマンドが発行された場合、バックエンドはSyncメッセージを受け取るまでフロントエンドのメッセージを破棄するようになります。
Syncメッセージを受け取ると、ReadyForQueryを発行し、通常処理に戻ります。
簡易問い合わせメッセージで<command>COPY</command>が発行された場合、メッセージの残りは破棄され、ReadyForQueryメッセージを発行します。
どちらの場合でも、その後にフロントエンドによって発行されたCopyData、CopyDone、CopyFailは単に削除されます。
   </para>

   <para>
<!--
    The backend will ignore Flush and Sync messages received during copy-in
    mode.  Receipt of any other non-copy message type constitutes an error
    that will abort the copy-in state as described above.  (The exception for
    Flush and Sync is for the convenience of client libraries that always
    send Flush or Sync after an Execute message, without checking whether
    the command to be executed is a <command>COPY FROM STDIN</command>.)
-->
バックエンドは、コピーインモード期間中、FlushとSyncメッセージを無視します。
その他の種類の非コピーメッセージを受け取ると、エラーになり、上述のようにコピーイン状態を中断します
（クライアントライブラリがExecuteメッセージの後に、実行したコマンドが<command>COPY FROM STDIN</command>かどうかを検査することなく、常にFlushまたはSyncを送信できる、という便利さのためにFlushとSyncは例外です）。
   </para>

   <para>
<!--
    Copy-out mode (data transfer from the server) is initiated when the
    backend executes a <command>COPY TO STDOUT</command> SQL statement.  The backend
    sends a CopyOutResponse message to the frontend, followed by
    zero or more CopyData messages (always one per row), followed by CopyDone.
    The backend then reverts to the command-processing mode it was
    in before the <command>COPY</command> started, and sends CommandComplete.
    The frontend cannot abort the transfer (except by closing the connection
    or issuing a Cancel request),
    but it can discard unwanted CopyData and CopyDone messages.
-->
コピーアウトモード（サーバからのデータ転送）は、バックエンドが<command>COPY TO STDOUT</command> SQL文を実行した時に起動します。
バックエンドはCopyOutResponseメッセージをフロントエンドに送信し、その後、ゼロ個以上のCopyDataメッセージ（常に行ごとに1つ）を、そして、CopyDoneを送信します。
その後、バックエンドは<command>COPY</command>が始まる前のコマンド処理モードに戻り、CommandCompleteを送信します。
フロントエンドは（接続の切断やCancel要求の発行は例外ですが）転送を中断することはできません。
しかし、不要なCopyDataとCopyDoneメッセージを破棄することは可能です。
   </para>

   <para>
<!--
    In the event of a backend-detected error during copy-out mode,
    the backend will issue an ErrorResponse message and revert to normal
    processing.  The frontend should treat receipt of ErrorResponse as
    terminating the copy-out mode.
-->
コピーアウトモード期間中バックエンドはエラーを検知すると、ErrorResponseメッセージを発行し、通常処理に戻ります。
フロントエンドはErrorResponseの受信をコピーアウトモードの終了として扱うべきです。
   </para>

   <para>
<!--
    It is possible for NoticeResponse and ParameterStatus messages to be
    interspersed between CopyData messages; frontends must handle these cases,
    and should be prepared for other asynchronous message types as well (see
    <xref linkend="protocol-async"/>).  Otherwise, any message type other than
    CopyData or CopyDone may be treated as terminating copy-out mode.
-->
NoticeResponseおよびParameterStatusメッセージがCopyDataメッセージ間に散在することがあります。
フロントエンドはこのような場合も扱わなければなりません。
また、他の種類の非同期メッセージ（<xref linkend="protocol-async"/>を参照）も同様に準備すべきです。
さもなくば、CopyDataまたはCopyDone以外の種類のメッセージがコピーアウトモードの終了として扱われてしまう可能性があります。
   </para>

   <para>
<!--
    There is another Copy-related mode called copy-both, which allows
    high-speed bulk data transfer to <emphasis>and</emphasis> from the server.
    Copy-both mode is initiated when a backend in walsender mode
    executes a <command>START_REPLICATION</command> statement.  The
    backend sends a CopyBothResponse message to the frontend.  Both
    the backend and the frontend may then send CopyData messages
    until either end sends a CopyDone message. After the client
    sends a CopyDone message, the connection goes from copy-both mode to
    copy-out mode, and the client may not send any more CopyData messages.
    Similarly, when the server sends a CopyDone message, the connection
    goes into copy-in mode, and the server may not send any more CopyData
    messages. After both sides have sent a CopyDone message, the copy mode
    is terminated, and the backend reverts to the command-processing mode.
    In the event of a backend-detected error during copy-both mode,
    the backend will issue an ErrorResponse message, discard frontend messages
    until a Sync message is received, and then issue ReadyForQuery and return
    to normal processing.  The frontend should treat receipt of ErrorResponse
    as terminating the copy in both directions; no CopyDone should be sent
    in this case.  See <xref linkend="protocol-replication"/> for more
    information on the subprotocol transmitted over copy-both mode.
-->
他にも、サーバへ、<emphasis>および</emphasis>サーバからの高速な一括データ転送を行うことができるコピーボースというコピーに関連したモードがあります。
コピーボースモードは、walsenderモードのバックエンドが<command>START_REPLICATION</command>文を実行した時に初期化されます。
バックエンドはCopyBothResponseメッセージをフロントエンドに送信します。
この後バックエンドとフロントエンドの両方が、接続が終了するまでの間にCopyDataメッセージを送信できるようになります。
同様に、サーバがCopyDoneメッセージを送信した場合、接続はコピーインモードとなり、サーバはそれ以上のCopyDataメッセージを送信できません。
両方の側がCopyDoneメッセージを送信した後、コピーモードは終了し、バックエンドはコマンド処理モードに戻ります。
コピーボースモード中にバックエンドが検出したエラーのイベントにおいては、バックエンドはErrorResponseメッセージを発行し、Syncメッセージの受信までフロントエンドのメッセージを破棄し、その後ReadyForQueryを発行して通常の処理に戻ります。
フロントエンドは両方向のコピーを終了するように、ErrorResponse受理の処理をするべきです。
この場合CopyDoneを送信するべきではありません。
コピーボースモードにおけるサブプロトコル転送の詳細は<xref linkend="protocol-replication"/>を参照してください。
   </para>

   <para>
<!--
    The CopyInResponse, CopyOutResponse and CopyBothResponse messages
    include fields that inform the frontend of the number of columns
    per row and the format codes being used for each column.  (As of
    the present implementation, all columns in a given <command>COPY</command>
    operation will use the same format, but the message design does not
    assume this.)
-->
CopyInResponse、CopyOutResponse、CopyBothResponseメッセージには、フロントエンドに1行当たりの列数と各列で使用する書式コードを通知するためのフィールドが含まれています。
（現在の実装では、<command>COPY</command>操作で与えられるすべての列は同一の書式を使用します。
しかし、メッセージ設計においては、これを前提としていません。）
   </para>

  </sect2>

  <sect2 id="protocol-async">
<!--
   <title>Asynchronous Operations</title>
-->
<title>非同期操作</title>

   <para>
<!--
    There are several cases in which the backend will send messages that
    are not specifically prompted by the frontend's command stream.
    Frontends must be prepared to deal with these messages at any time,
    even when not engaged in a query.
    At minimum, one should check for these cases before beginning to
    read a query response.
-->
バックエンドが、フロントエンドのコマンドストリームで特に依頼されていないメッセージを送信する場合が複数あります。
フロントエンドは、問い合わせ作業を行っていない時であっても常に、これらのメッセージを扱う準備をしなければなりません。
少なくとも、問い合わせの応答の読み込みを始める前にこれらを検査すべきです。
   </para>

   <para>
<!--
    It is possible for NoticeResponse messages to be generated due to
    outside activity; for example, if the database administrator commands
    a <quote>fast</quote> database shutdown, the backend will send a NoticeResponse
    indicating this fact before closing the connection.  Accordingly,
    frontends should always be prepared to accept and display NoticeResponse
    messages, even when the connection is nominally idle.
-->
外部の活動によって、NoticeResponseメッセージが生成されることがあり得ます。
例えば、データベース管理者が<quote>高速</quote>データベース停止コマンドを実行した場合、バックエンドは接続を閉ざす前にこれを通知するためにNoticeResponseを送信します。
したがって、たとえ接続が名目上待機状態であったとしても、フロントエンドは常にNoticeResponseメッセージを受け付け、表示する準備をすべきです。
   </para>

   <para>
<!--
    ParameterStatus messages will be generated whenever the active
    value changes for any of the parameters the backend believes the
    frontend should know about.  Most commonly this occurs in response
    to a <command>SET</command> SQL command executed by the frontend, and
    this case is effectively synchronous &mdash; but it is also possible
    for parameter status changes to occur because the administrator
    changed a configuration file and then sent the
    <systemitem>SIGHUP</systemitem> signal to the server.  Also,
    if a <command>SET</command> command is rolled back, an appropriate
    ParameterStatus message will be generated to report the current
    effective value.
-->
ParameterStatusメッセージは、任意のパラメータの実際の値が変更され、それをバックエンドがフロントエンドに通知するべきであるとみなした場合は常に生成されます。
ほとんどの場合、これはフロントエンドによる<command>SET</command> SQLコマンド実行に対する応答の中で起こります。
これは実質的には同期していますが、管理者が設定ファイルを変更し、<systemitem>SIGHUP</systemitem>シグナルをサーバに送った場合にも、パラメータ状態の変更が発生することがあります。
また、<command>SET</command>コマンドがロールバックされた場合、現在の有効値を報告するために適切なParameterStatusメッセージが生成されます。
   </para>

   <para>
<!--
    At present there is a hard-wired set of parameters for which
    ParameterStatus will be generated: they are
    <varname>server_version</varname>,
    <varname>server_encoding</varname>,
    <varname>client_encoding</varname>,
    <varname>application_name</varname>,
    <varname>is_superuser</varname>,
    <varname>session_authorization</varname>,
    <varname>DateStyle</varname>,
    <varname>IntervalStyle</varname>,
    <varname>TimeZone</varname>,
    <varname>integer_datetimes</varname>, and
    <varname>standard_conforming_strings</varname>.
    (<varname>server_encoding</varname>, <varname>TimeZone</varname>, and
    <varname>integer_datetimes</varname> were not reported by releases before 8.0;
    <varname>standard_conforming_strings</varname> was not reported by releases
    before 8.1;
    <varname>IntervalStyle</varname> was not reported by releases before 8.4;
    <varname>application_name</varname> was not reported by releases before 9.0.)
    Note that
    <varname>server_version</varname>,
    <varname>server_encoding</varname> and
    <varname>integer_datetimes</varname>
    are pseudo-parameters that cannot change after startup.
    This set might change in the future, or even become configurable.
    Accordingly, a frontend should simply ignore ParameterStatus for
    parameters that it does not understand or care about.
-->
現時点では、ParameterStatusを生成するパラメータ群は固定されています。
それらは<varname>server_version</varname>、<varname>server_encoding</varname>、<varname>client_encoding</varname>、<varname>application_name</varname>、<varname>is_superuser</varname>、<varname>session_authorization</varname>、<varname>DateStyle</varname>、<varname>IntervalStyle</varname>、<varname>TimeZone</varname>、<varname>integer_datetimes</varname>、および<varname>standard_conforming_strings</varname>です。
（8.0より前までのリリースでは、<varname>server_encoding</varname>、<varname>TimeZone</varname>および<varname>integer_datetimes</varname>は送信されませんでした。
8.1より前までのリリースでは、<varname>standard_conforming_strings</varname>は送信されませんでした。
8.4より前のリリースでは、<varname>IntervalStyle</varname>は送信されませんでした。
9.0より前のリリースでは、<varname>application_name</varname>は送信されませんでした。）
<varname>server_version</varname>、<varname>server_encoding</varname>および<varname>integer_datetimes</varname>は仮想的なパラメータであり、起動後に変更することができないことに注意してください。
これは今後変更される、あるいは設定変更可能になる可能性があります。
したがって、フロントエンドは未知または注目していないParameterStatusを単に無視すべきです。
   </para>

   <para>
<!--
    If a frontend issues a <command>LISTEN</command> command, then the
    backend will send a NotificationResponse message (not to be
    confused with NoticeResponse!)  whenever a
    <command>NOTIFY</command> command is executed for the same
    channel name.
-->
フロントエンドが<command>LISTEN</command>コマンドを発行した場合、同じチャネル名に対し<command>NOTIFY</command>コマンドが実行された時にバックエンドはNotificationResponseメッセージ（NoticeResponseと間違えないように！）を送出します。
   </para>

   <note>
    <para>
<!--
     At present, NotificationResponse can only be sent outside a
     transaction, and thus it will not occur in the middle of a
     command-response series, though it might occur just before ReadyForQuery.
     It is unwise to design frontend logic that assumes that, however.
     Good practice is to be able to accept NotificationResponse at any
     point in the protocol.
-->
現在、NotificationResponseをトランザクションの外部でのみ送信することができます。
このため、これはコマンド応答の流れの途中では起こりませんが、ReadyForQueryの直前に発生する可能性があります。
しかし、これを前提にフロントエンドのロジックを設計することは避けてください。
プロトコル内の任意の時点でNotificationResponseを受け付けられるようにすることを勧めます。
    </para>
   </note>
  </sect2>

  <sect2>
<!--
   <title>Canceling Requests in Progress</title>
-->
<title>処理中のリクエストの取り消し</title>

   <para>
<!--
    During the processing of a query, the frontend might request
    cancellation of the query.  The cancel request is not sent
    directly on the open connection to the backend for reasons of
    implementation efficiency: we don't want to have the backend
    constantly checking for new input from the frontend during query
    processing.  Cancel requests should be relatively infrequent, so
    we make them slightly cumbersome in order to avoid a penalty in
    the normal case.
-->
問い合わせの処理中に、フロントエンドが問い合わせを取り消す可能性があります。
取り消し要求は、効率を高めるために、接続を開いたバックエンドに対して直接送信されません。
その問い合わせを処理中のバックエンドが、フロントエンドからの新しい入力があるかどうかを定期的に確認することは好ましくありません。
取り消し要求はたいていの場合、頻繁には起こらないので、通常の状態においての負担を避けるため、多少扱いにくくなっています。
   </para>

   <para>
<!--
    To issue a cancel request, the frontend opens a new connection to
    the server and sends a CancelRequest message, rather than the
    StartupMessage message that would ordinarily be sent across a new
    connection.  The server will process this request and then close
    the connection.  For security reasons, no direct reply is made to
    the cancel request message.
-->
取り消し要求を出す場合、フロントエンドは通常の新規接続の時に送出されるStartupMessageメッセージではなくCancelRequestメッセージをサーバに送り、新規接続を開始します。
サーバはこの要求を処理し、接続を切断します。
セキュリティ上の理由から、取り消し要求メッセージに対し直接の回答はありません。
   </para>

   <para>
<!--
    A CancelRequest message will be ignored unless it contains the
    same key data (PID and secret key) passed to the frontend during
    connection start-up.  If the request matches the PID and secret
    key for a currently executing backend, the processing of the
    current query is aborted.  (In the existing implementation, this is
    done by sending a special signal to the backend process that is
    processing the query.)
-->
CancelRequestメッセージは、接続開始段階でフロントエンドに送られたものと同一の鍵データ（PIDと秘密鍵）を含んでいない場合は無視されます。
現在バックエンドが実行中の処理に対するPIDと秘密鍵が要求と一致した場合、その現在の問い合わせ処理は中断されます。
（現状では、これは、その問い合わせを処理しているバックエンドプロセスに対し特別なシグナルを送ることで実装されています。）
   </para>

   <para>
<!--
    The cancellation signal might or might not have any effect &mdash; for
    example, if it arrives after the backend has finished processing
    the query, then it will have no effect.  If the cancellation is
    effective, it results in the current command being terminated
    early with an error message.
-->
この取り消しシグナルは何の効果も生まないことがあります。
例えば、バックエンドが問い合わせの処理を完了した後に届いた場合、効果がありません。
もし取り消し処理が有効であれば、エラーメッセージとともに、現在のコマンドは終了されます。
   </para>

   <para>
<!--
    The upshot of all this is that for reasons of both security and
    efficiency, the frontend has no direct way to tell whether a
    cancel request has succeeded.  It must continue to wait for the
    backend to respond to the query.  Issuing a cancel simply improves
    the odds that the current query will finish soon, and improves the
    odds that it will fail with an error message instead of
    succeeding.
-->
セキュリティと効率上の理由による上述の実装の結果、フロントエンドは取り消し要求が成功したかどうかを直接判断することはできません。
フロントエンドはバックエンドからの問い合わせの回答を待ち続けなければいけません。
取り消しを要求することは単に現在の問い合わせを早めに終わらせ、成功ではなくエラーメッセージを出して不成功とする可能性を単に高める程度のものです。
   </para>

   <para>
<!--
    Since the cancel request is sent across a new connection to the
    server and not across the regular frontend/backend communication
    link, it is possible for the cancel request to be issued by any
    process, not just the frontend whose query is to be canceled.
    This might provide additional flexibility when building
    multiple-process applications.  It also introduces a security
    risk, in that unauthorized persons might try to cancel queries.
    The security risk is addressed by requiring a dynamically
    generated secret key to be supplied in cancel requests.
-->
取り消し要求は、通常のフロントエンドとバックエンドの通信接続を通してではなく新規のサーバとの接続に送られるため、取り消される問い合わせを実行したフロントエンドだけでなく、任意のプロセスによっても送信することができます。
このことはマルチプロセスアプリケーションを作るに当たって柔軟性を提供します。
同時に、権限のない者が問い合わせを取り消そうとするといったセキュリティ上のリスクも持ち込みます。
このセキュリティ上のリスクは、取り消し要求内に動的に生成される秘密キーを供給することを必須とすることで回避されます。
   </para>
  </sect2>

  <sect2>
<!--
   <title>Termination</title>
-->
<title>終了</title>

   <para>
<!--
    The normal, graceful termination procedure is that the frontend
    sends a Terminate message and immediately closes the connection.
    On receipt of this message, the backend closes the connection and
    terminates.
-->
通常の洗練された終了手順はフロントエンドがTerminateメッセージを出し、すぐに接続を閉じることです。
このメッセージを受け取るとすぐにバックエンドは接続を閉じ終了します。
   </para>

   <para>
<!--
    In rare cases (such as an administrator-commanded database shutdown)
    the backend might disconnect without any frontend request to do so.
    In such cases the backend will attempt to send an error or notice message
    giving the reason for the disconnection before it closes the connection.
-->
まれに（管理者によるデータベース停止コマンドなど）、バックエンドはフロントエンドからの要求なしに切断することがあります。
こうした場合、バックエンドは、接続を閉ざす前に切断理由を通知するエラーまたは警報メッセージの送信を試みます。
   </para>

   <para>
<!--
    Other termination scenarios arise from various failure cases, such as core
    dump at one end or the other, loss of the communications link, loss of
    message-boundary synchronization, etc.  If either frontend or backend sees
    an unexpected closure of the connection, it should clean
    up and terminate.  The frontend has the option of launching a new backend
    by recontacting the server if it doesn't want to terminate itself.
    Closing the connection is also advisable if an unrecognizable message type
    is received, since this probably indicates loss of message-boundary sync.
-->
他にも、どちらかの側のコアダンプ、通信リンクの消失、メッセージ境界の同期の消失など各種失敗によって終了する状況があります。
フロントエンドかバックエンドいずれかが予期しない接続の中断を検知した場合、後始末を行い終了しなければいけません。
フロントエンドはもし自身が終了を望まない場合、サーバに再交信し新規のバックエンドを立ち上げる選択権を持っています。
解釈できないメッセージ種類を受け取った時、おそらくメッセージ境界の同期が消失したことを示しますので、接続を閉ざすことを勧めます。
   </para>

   <para>
<!--
    For either normal or abnormal termination, any open transaction is
    rolled back, not committed.  One should note however that if a
    frontend disconnects while a non-<command>SELECT</command> query
    is being processed, the backend will probably finish the query
    before noticing the disconnection.  If the query is outside any
    transaction block (<command>BEGIN</command> ... <command>COMMIT</command>
    sequence) then its results might be committed before the
    disconnection is recognized.
-->
通常の終了、異常な終了のどちらの場合でも、開いているトランザクションはすべてコミットされずにロールバックされます。
しかし、フロントエンドが<command>SELECT</command>以外の問い合わせを処理中に切断した場合、バックエンドはおそらく切断に気付く前にその問い合わせを完了させてしまうでしょう。
その問い合わせがトランザクションブロック（<command>BEGIN</command> ... <command>COMMIT</command>の並び）外部であった場合、切断に気付く前にその結果はコミットされる可能性があります。
   </para>
  </sect2>

  <sect2>
<!--
   <title><acronym>SSL</acronym> Session Encryption</title>
-->
<title><acronym>SSL</acronym>セッション暗号化</title>

   <para>
<!--
    If <productname>PostgreSQL</productname> was built with
    <acronym>SSL</acronym> support, frontend/backend communications
    can be encrypted using <acronym>SSL</acronym>.  This provides
    communication security in environments where attackers might be
    able to capture the session traffic. For more information on
    encrypting <productname>PostgreSQL</productname> sessions with
    <acronym>SSL</acronym>, see <xref linkend="ssl-tcp"/>.
-->
<productname>PostgreSQL</productname>が<acronym>SSL</acronym>サポート付きで構築された場合、フロントエンドとバックエンド間の通信を<acronym>SSL</acronym>で暗号化することができます。
攻撃者がセッショントラフィックをキャプチャできるような環境における通信を安全にすることができます。
<acronym>SSL</acronym>を使用した<productname>PostgreSQL</productname>セッションの暗号化に関する詳細は<xref linkend="ssl-tcp"/>を参照してください。
   </para>

   <para>
<!--
    To initiate an <acronym>SSL</acronym>-encrypted connection, the
    frontend initially sends an SSLRequest message rather than a
    StartupMessage.  The server then responds with a single byte
    containing <literal>S</literal> or <literal>N</literal>, indicating that it is
    willing or unwilling to perform <acronym>SSL</acronym>,
    respectively.  The frontend might close the connection at this point
    if it is dissatisfied with the response.  To continue after
    <literal>S</literal>, perform an <acronym>SSL</acronym> startup handshake
    (not described here, part of the <acronym>SSL</acronym>
    specification) with the server.  If this is successful, continue
    with sending the usual StartupMessage.  In this case the
    StartupMessage and all subsequent data will be
    <acronym>SSL</acronym>-encrypted.  To continue after
    <literal>N</literal>, send the usual StartupMessage and proceed without
    encryption.
-->
<acronym>SSL</acronym>暗号化接続を開始するには、フロントエンドはまず、StartupMessageではなくSSLRequestを送信します。
その後サーバはそれぞれ<acronym>SSL</acronym>の実行を行うか行わないかを示す<literal>S</literal>か<literal>N</literal>かを持つ1バイトの応答を返します。
フロントエンドはその応答に満足できなければ、この時点で接続を切断することができます。
<literal>S</literal>の後に継続するのであれば、サーバと間で<acronym>SSL</acronym>起動ハンドシェーク（ここでは<acronym>SSL</acronym>の仕様に関しては説明しません）を行います。
これが成功した場合、続いて通常のStartupMessageの送信を行います。
この場合、StartupMessageおよびその後のデータは<acronym>SSL</acronym>により暗号化されます。
<literal>N</literal>の後に、通常のStartupMessageを送信することで暗号化なしで進みます。
   </para>

   <para>
<!--
    The frontend should also be prepared to handle an ErrorMessage
    response to SSLRequest from the server.  This would only occur if
    the server predates the addition of <acronym>SSL</acronym> support
    to <productname>PostgreSQL</productname>.  (Such servers are now very ancient,
    and likely do not exist in the wild anymore.)
    In this case the connection must
    be closed, but the frontend might choose to open a fresh connection
    and proceed without requesting <acronym>SSL</acronym>.
-->
また、フロントエンドはサーバからのSSLRequestに対するErrorMessage応答を取り扱うための用意もすべきです。
これは、<productname>PostgreSQL</productname>に<acronym>SSL</acronym>サポートが追加される前のサーバの場合のみで発生します。
（現在ではこうしたサーバは非常に古いものといえ、ほとんど存在しません。）
この場合接続を切断しなければなりませんが、フロントエンドは<acronym>SSL</acronym>要求なしで新しく接続を開き、処理を進めることもできます。
   </para>

   <para>
<!--
    An initial SSLRequest can also be used in a connection that is being
    opened to send a CancelRequest message.
-->
最初のSSLRequestはCancelRequestメッセージを送信するために開いた接続で使用することもできます。
   </para>

   <para>
<!--
    While the protocol itself does not provide a way for the server to
    force <acronym>SSL</acronym> encryption, the administrator can
    configure the server to reject unencrypted sessions as a byproduct
    of authentication checking.
-->
プロトコル自体には、サーバに<acronym>SSL</acronym>暗号化を強制する方法は用意されていませんが、管理者は認証検査の一方法として、暗号化されていないセッションを拒否するようにサーバを設定することができます。
   </para>
  </sect2>

  <sect2>
<!--
   <title><acronym>GSSAPI</acronym> Session Encryption</title>
-->
   <title><acronym>GSSAPI</acronym>セッション暗号化</title>

   <para>
<!--
    If <productname>PostgreSQL</productname> was built with
    <acronym>GSSAPI</acronym> support, frontend/backend communications
    can be encrypted using <acronym>GSSAPI</acronym>.  This provides
    communication security in environments where attackers might be
    able to capture the session traffic. For more information on
    encrypting <productname>PostgreSQL</productname> sessions with
    <acronym>GSSAPI</acronym>, see <xref linkend="gssapi-enc"/>.
-->
<productname>PostgreSQL</productname>が<acronym>GSSAPI</acronym>サポートを有効にして構築されていれば、<acronym>GSSAPI</acronym>を使ってフロントエンド/バックエンド通信を暗号化できます。
これにより、攻撃者がセッションのやり取りを読み取れるかもしれない環境における通信のセキュリティが提供されます。
<productname>PostgreSQL</productname>での通信を<acronym>GSSAPI</acronym>で暗号化するための情報に関しては、<xref linkend="gssapi-enc"/>をご覧ください。
   </para>

   <para>
<!--
    To initiate a <acronym>GSSAPI</acronym>-encrypted connection, the
    frontend initially sends a GSSENCRequest message rather than a
    StartupMessage.  The server then responds with a single byte
    containing <literal>G</literal> or <literal>N</literal>, indicating that it
    is willing or unwilling to perform <acronym>GSSAPI</acronym> encryption,
    respectively.  The frontend might close the connection at this point
    if it is dissatisfied with the response.  To continue after
    <literal>G</literal>, using the GSSAPI C bindings as discussed in RFC2744
    or equivalent, perform a <acronym>GSSAPI</acronym> initialization by
    calling <function>gss_init_sec_context()</function> in a loop and sending
    the result to the server, starting with an empty input and then with each
    result from the server, until it returns no output.  When sending the
    results of <function>gss_init_sec_context()</function> to the server,
    prepend the length of the message as a four byte integer in network byte
    order.  If this is successful, then use <function>gss_wrap()</function> to
    encrypt the usual StartupMessage and all subsequent data, prepending the
    length of the result from <function>gss_wrap()</function> as a four byte
    integer in network byte order to the actual encrypted payload.  Note that
    the server will only accept encrypted packets from the client which are less
    than 16kB; <function>gss_wrap_size_limit()</function> should be used by the
    client to determine the size of the unencrypted message which will fit
    within this limit and larger messages should be broken up into multiple
    <function>gss_wrap()</function> calls.  Typical segments are 8kB of
    unencrypted data, resulting in encrypted packets of slightly larger than 8kB
    but well within the 16kB maximum.  The server can be expected to not send
    encrypted packets of larger than 16kB to the client.  To continue after
    <literal>N</literal>, send the usual StartupMessage and proceed without
    encryption.
-->
<acronym>GSSAPI</acronym>暗号化接続を開始するには、フロントエンドは最初にStartupMessageではなく、GSSENCRequestメッセージを送ります。
次にサーバは、それぞれ<acronym>GSSAPI</acronym>暗号化を希望する、しないを意味する<literal>G</literal>または<literal>N</literal>を含む1バイトを送信します。
このレスポンスに満足できなければ、この時点でフロントエンドは接続を打ち切って構いません。
<literal>G</literal>の受信後継続するには、RFC2744あるいは同様の文書で議論されているGSSAPI Cバインディングを使い、ループの中で<function>gss_init_sec_context()</function>を呼び出して<acronym>GSSAPI</acronym>を初期化し、結果をサーバに送信し、空の入力を受け取ることから始めて、サーバが出力を返さなくなるまでサーバからの出力を受け取ります。
<function>gss_init_sec_context()</function>の結果をサーバに送る際には、ネットワークバイトオーダーで4バイトの整数にメッセージ長を先頭に付与します。
これに成功したら、<function>gss_wrap()</function>を使って通常のStartupMessageと後続のすべてのメッセージを暗号化します。
実際に暗号化した送信データの前に、<function>gss_wrap()</function>の結果をネットワークバイトオーダーで4バイトの整数にしたものを付与します。
サーバは16kB未満のクライアントからの暗号化パケットだけを受け付けることに注意してください。
クライアントは<function>gss_wrap_size_limit()</function>を使って暗号化前のメッセージの大きさがこの制限に収まるかどうかを確認し、それより大きなメッセージは複数の<function>gss_wrap()</function>呼び出しに分解すべきです。
典型的なセグメントは暗号化前で8kBのデータで、暗号化後のパケットは8kBより少し大きくなりますが、最大長の16kB以内には問題なく収まります。
サーバは16kBよりも大きな暗号化パケットをクライアントに送らないものと期待することができます。
<literal>N</literal>の後継続するには、通常のStartupMessageを送信し、暗号化せずに続けてください。
   </para>

   <para>
<!--
    The frontend should also be prepared to handle an ErrorMessage
    response to GSSENCRequest from the server.  This would only occur if
    the server predates the addition of <acronym>GSSAPI</acronym> encryption
    support to <productname>PostgreSQL</productname>.  In this case the
    connection must be closed, but the frontend might choose to open a fresh
    connection and proceed without requesting <acronym>GSSAPI</acronym>
    encryption.  Given the length limits specified above, the ErrorMessage can
    not be confused with a proper response from the server with an appropriate
    length.
-->
また、フロントエンドはサーバからのGSSENCRequestへのErrorMessage応答に備えるべきです。
これはサーバが<productname>PostgreSQL</productname>への<acronym>GSSAPI</acronym>暗号化サポートを追加する以前だったときにのみ発生します。
この場合は接続を切断しなければなりませんが、フロントエンドは新しい接続を開いて<acronym>GSSAPI</acronym>暗号化を要求せずに進めることを選択するかもしれません。
上述の長さ制限により、ErrorMessageがサーバからの適切な長さを持つ正しい応答と混同されることはありません。
   </para>

   <para>
<!--
    An initial GSSENCRequest can also be used in a connection that is being
    opened to send a CancelRequest message.
-->
最初のGSSENCRequestは、CancelRequestメッセージを送信するために開いている接続でも利用できます。
   </para>

   <para>
<!--
    While the protocol itself does not provide a way for the server to
    force <acronym>GSSAPI</acronym> encryption, the administrator can
    configure the server to reject unencrypted sessions as a byproduct
    of authentication checking.
-->
プロトコル自身はサーバに<acronym>GSSAPI</acronym>暗号化を強制する方法を提供していませんが、管理者は認証チェックの副次的効果として暗号化されていないセッションをサーバが拒否するように設定できます。
   </para>
  </sect2>
 </sect1>

<sect1 id="sasl-authentication">
<!--
<title>SASL Authentication</title>
-->
<title>SASL認証</title>

<para>
<!--
<firstterm>SASL</firstterm> is a framework for authentication in connection-oriented
protocols. At the moment, <productname>PostgreSQL</productname> implements two SASL
authentication mechanisms, SCRAM-SHA-256 and SCRAM-SHA-256-PLUS. More
might be added in the future. The below steps illustrate how SASL
authentication is performed in general, while the next subsection gives
more details on SCRAM-SHA-256 and SCRAM-SHA-256-PLUS.
-->
<firstterm>SASL</firstterm>は接続指向のプロトコルでの認証のためのフレームワークです。
現時点では<productname>PostgreSQL</productname>は2つのSASLの認証機構、SCRAM-SHA-256とSCRAM-SHA-256-PLUSを実装しています。
将来には他の機構が追加されるかもしれません。
以下の手順は、SASLの認証が一般的にどのように行われるかを示したものですが、次の副節ではSCRAM-SHA-256とSCRAM-SHA-256-PLUSにおけるより詳細について説明します。
</para>

<procedure>
<!--
<title>SASL Authentication Message Flow</title>
-->
<title>SASL認証のメッセージフロー</title>

<step id="sasl-auth-begin">
<para>
<!--
  To begin a SASL authentication exchange, the server sends an
  AuthenticationSASL message. It includes a list of SASL authentication
  mechanisms that the server can accept, in the server's preferred order.
-->
SASL認証の交換を開始するため、サーバはAuthenticationSASLメッセージを送信します。
これにはサーバが受け付けることができるSASLの認証機構を、サーバにとって望ましいものから順に並べたリストが含まれます。
</para>
</step>

<step id="sasl-auth-initial-response">
<para>
<!--
  The client selects one of the supported mechanisms from the list, and sends
  a SASLInitialResponse message to the server. The message includes the name
  of the selected mechanism, and an optional Initial Client Response, if the
  selected mechanism uses that.
-->
クライアントはリストからサポートされる機構を1つ選択し、サーバにSASLInitialResponseメッセージを送信します。
このメッセージには選択された機構の名前が含まれ、また選択した機構がInitial Client Response（最初のクライアントの応答）を使用するなら、オプションでそれも含まれます。
</para>
</step>

<step id="sasl-auth-continue">
<para>
<!--
  One or more server-challenge and client-response message will follow. Each
  server-challenge is sent in an AuthenticationSASLContinue message, followed
  by a response from client in an SASLResponse message. The particulars of
  the messages are mechanism specific.
-->
サーバのチャレンジメッセージおよびクライアントのレスポンスメッセージが1つ以上続きます。
サーバのチャレンジはそれぞれがAuthenticationSASLContinueメッセージで送信され、それにクライアントからのレスポンスがSASLResponseメッセージで続きます。
メッセージの詳細は機構に固有のものです。
</para>
</step>

<step id="sasl-auth-end">
<para>
<!--
  Finally, when the authentication exchange is completed successfully, the
  server sends an AuthenticationSASLFinal message, followed
  immediately by an AuthenticationOk message. The AuthenticationSASLFinal
  contains additional server-to-client data, whose content is particular to the
  selected authentication mechanism. If the authentication mechanism doesn't
  use additional data that's sent at completion, the AuthenticationSASLFinal
  message is not sent.
-->
最後に、認証の交換が成功裏に終了すると、サーバはAuthenticationSASLFinalメッセージを送信し、その直後にAuthenticationOkメッセージを送信します。
AuthenticationSASLFinalにはサーバからクライアントへの追加のデータが含まれ、その内容は選択した認証機構毎に異なります。
完了時に送信する追加データを認証機構が使用していない場合、AuthenticationSASLFinalメッセージは送信されません。
</para>
</step>
</procedure>

<para>
<!--
On error, the server can abort the authentication at any stage, and send an
ErrorMessage.
-->
エラーが発生したときは、サーバは認証を任意の段階で終了してErrorMessageを送信することができます。
</para>

 <sect2 id="sasl-scram-sha-256">
<!--
  <title>SCRAM-SHA-256 Authentication</title>
-->
  <title>SCRAM-SHA-256 認証</title>

  <para>
<!--
   The implemented SASL mechanisms at the moment
   are <literal>SCRAM-SHA-256</literal> and its variant with channel
   binding <literal>SCRAM-SHA-256-PLUS</literal>. They are described in
   detail in RFC 7677 and RFC 5802.
-->
今のところ実装されているSASL機構は<literal>SCRAM-SHA-256</literal>とチャンネルバインディングを伴う変種の<literal>SCRAM-SHA-256-PLUS</literal>です。
詳細はRFC 7677およびRFC 5802で説明されています。
  </para>

  <para>
<!--
When SCRAM-SHA-256 is used in PostgreSQL, the server will ignore the user name
that the client sends in the <structname>client-first-message</structname>. The user name
that was already sent in the startup message is used instead.
<productname>PostgreSQL</productname> supports multiple character encodings, while SCRAM
dictates UTF-8 to be used for the user name, so it might be impossible to
represent the PostgreSQL user name in UTF-8.
-->
PostgreSQLでSCRAM-SHA-256を使用する場合、クライアントが<structname>client-first-message</structname>で送信するユーザ名をサーバは無視します。
その代わりに、開始メッセージで送信済みのユーザ名が使用されます。
SCRAMはユーザ名としてUTF-8の使用を指示していますが、<productname>PostgreSQL</productname>は複数の文字符号化方式をサポートするため、PostgreSQLのユーザ名をUTF-8で表現できないかもしれません。
  </para>

  <para>
<!--
The SCRAM specification dictates that the password is also in UTF-8, and is
processed with the <firstterm>SASLprep</firstterm> algorithm.
<productname>PostgreSQL</productname>, however, does not require UTF-8 to be used for
the password. When a user's password is set, it is processed with SASLprep
as if it was in UTF-8, regardless of the actual encoding used. However, if
it is not a legal UTF-8 byte sequence, or it contains UTF-8 byte sequences
that are prohibited by the SASLprep algorithm, the raw password will be used
without SASLprep processing, instead of throwing an error. This allows the
password to be normalized when it is in UTF-8, but still allows a non-UTF-8
password to be used, and doesn't require the system to know which encoding
the password is in.
-->
SCRAMの仕様ではパスワードもUTF-8であり、<firstterm>SASLprep</firstterm>アルゴリズムで処理されることが規定されています。
しかし<productname>PostgreSQL</productname>ではパスワードにUTF-8が使用されることを必須としていません。
ユーザのパスワードが設定されたとき、実際に使用された符号化方式に関わらず、それがUTF-8であるかのようにSASLprepで処理されます。
しかし、それが正当なUTF-8バイト列でない場合、あるいはSASLprepが禁止するUTF-8バイト列を含む場合、エラーを発生させるのではなく、SASLprep処理のない生のパスワードが使用されます。
これにより、パスワードがUTF-8であればそれを正規化できる一方で、UTF-8以外のパスワードを使用することもでき、またシステムもパスワードがどの符号化であるかを知る必要もありません。
  </para>

  <para>
<!--
<firstterm>Channel binding</firstterm> is supported in PostgreSQL builds with
SSL support. The SASL mechanism name for SCRAM with channel binding is
<literal>SCRAM-SHA-256-PLUS</literal>.  The channel binding type used by
PostgreSQL is <literal>tls-server-end-point</literal>.
-->
SSLをサポートするPostgreSQLビルドで<firstterm>チャンネルバインディング</firstterm>がサポートされます。
チャンネルバインディングを伴うSCRAMに対するSASL機構名は<literal>SCRAM-SHA-256-PLUS</literal>です。
PostgreSQLで使われるチャンネルバインディングのタイプは<literal>tls-server-end-point</literal>です。
  </para>

  <para>
<!--
   In <acronym>SCRAM</acronym> without channel binding, the server chooses
   a random number that is transmitted to the client to be mixed with the
   user-supplied password in the transmitted password hash.  While this
   prevents the password hash from being successfully retransmitted in
   a later session, it does not prevent a fake server between the real
   server and client from passing through the server's random value
   and successfully authenticating.
-->
チャンネルバインディングを伴わない<acronym>SCRAM</acronym>ではサーバは、送信されるパスワードハッシュの中でユーザに応じたパスワードと混合してクライアントに送る乱数を選びます。
これはパスワードハッシュが後のセッションで再送信されて認証に成功してしまうことを防止しますが、真のサーバとクライアントの間の偽サーバがサーバのランダム値を中継して認証に成功してしまうことを防止しません。
  </para>

  <para>
<!--
   <acronym>SCRAM</acronym> with channel binding prevents such
   man-in-the-middle attacks by mixing the signature of the server's
   certificate into the transmitted password hash. While a fake server can
   retransmit the real server's certificate, it doesn't have access to the
   private key matching that certificate, and therefore cannot prove it is
   the owner, causing SSL connection failure.
-->
チャンネルバインディングを伴う<acronym>SCRAM</acronym>はこのような中間者攻撃をサーバ証明書のシグネチャを送信されるパスワードハッシュと混合することで防止します。
偽サーバは真のサーバの証明書を再送信できますが、その証明書に一致する秘密鍵にアクセスできず、それゆえ所有者であることを証明できず、結果としてSSL接続は失敗します。
  </para>

<procedure>
<!--
<title>Example</title>
-->
<title>例</title>
  <step id="scram-begin">
<para>
<!--
  The server sends an AuthenticationSASL message. It includes a list of
  SASL authentication mechanisms that the server can accept.
  This will be <literal>SCRAM-SHA-256-PLUS</literal>
  and <literal>SCRAM-SHA-256</literal> if the server is built with SSL
  support, or else just the latter.
-->
サーバはAuthenticationSASLメッセージを送信します。
それにはサーバが受け付けることができるSASL認証機構のリストが含まれます。
サーバがSSLサポート有でビルドされていれば、これは<literal>SCRAM-SHA-256-PLUS</literal>と<literal>SCRAM-SHA-256</literal>になり、そうでなければ後者のみとなります。
</para>
</step>
<step id="scram-client-first">
<para>
<!--
  The client responds by sending a SASLInitialResponse message, which
  indicates the chosen mechanism, <literal>SCRAM-SHA-256</literal> or
  <literal>SCRAM-SHA-256-PLUS</literal>. (A client is free to choose either
  mechanism, but for better security it should choose the channel-binding
  variant if it can support it.) In the Initial Client response field, the
  message contains the SCRAM <structname>client-first-message</structname>.
  The <structname>client-first-message</structname> also contains the channel
  binding type chosen by the client.
-->
クライアントはSASLInitialResponseメッセージを送信することで応答します。
これは選択した機構、すなわち<literal>SCRAM-SHA-256</literal>または<literal>SCRAM-SHA-256-PLUS</literal>を示します。
（クライアントは何れかの機構を自由に選びますが、より良いセキュリティのためサポートされているならチャンネルバインディングを伴うものを選ぶべきです。）
Initial Clientの応答フィールドでは、メッセージにSCRAMの<structname>client-first-message</structname>が含まれます。
<structname>client-first-message</structname>にはクライアントが選んだチャンネルバインディングのタイプも含まれます。
</para>
</step>
<step id="scram-server-first">
<para>
<!--
  Server sends an AuthenticationSASLContinue message, with a SCRAM
  <structname>server-first-message</structname> as the content.
-->
サーバがAuthenticationSASLContinueメッセージを送信します。
その内容はSCRAMの<structname>server-first-message</structname>です。
</para>
</step>
<step id="scram-client-final">
<para>
<!--
  Client sends a SASLResponse message, with SCRAM
  <structname>client-final-message</structname> as the content.
-->
クライアントがSASLResponseメッセージを送信します。
その内容はSCRAMの<structname>client-final-message</structname>です。
</para>
</step>
<step id="scram-server-final">
<para>
<!--
  Server sends an AuthenticationSASLFinal message, with the SCRAM
  <structname>server-final-message</structname>, followed immediately by
  an AuthenticationOk message.
-->
サーバがSCRAMの<structname>server-final-message</structname>を含むAuthenticationSASLFinalメッセージを送信し、その直後にAuthenticationOkメッセージを送信します。
</para>
</step>
</procedure>
</sect2>
</sect1>

<sect1 id="protocol-replication">
<!--
<title>Streaming Replication Protocol</title>
-->
<title>ストリーミングレプリケーションプロトコル</title>

<para>
<!--
To initiate streaming replication, the frontend sends the
<literal>replication</literal> parameter in the startup message. A Boolean
value of <literal>true</literal> (or <literal>on</literal>,
<literal>yes</literal>, <literal>1</literal>) tells the backend to go into
physical replication walsender mode, wherein a small set of replication
commands, shown below, can be issued instead of SQL statements.
-->
ストリーミングレプリケーションを初期化するために、フロントエンドは開始メッセージにて<literal>replication</literal>パラメータを送信します。
ブール値の<literal>true</literal>（または<literal>on</literal>、<literal>yes</literal>、<literal>1</literal>）がバックエンドに対して、SQL文ではなく小規模なレプリケーションコマンド群を発行できるようになる、物理レプリケーションのwalsenderモードに入るように伝えます。
</para>

<para>
<!--
Passing <literal>database</literal> as the value for the
<literal>replication</literal> parameter instructs the backend to go into
logical replication walsender mode, connecting to the database specified in
the <literal>dbname</literal> parameter.  In logical replication walsender
mode, the replication commands shown below as well as normal SQL commands can
be issued.
-->
<literal>replication</literal>パラメータに対する値として<literal>database</literal>を渡すことは、バックエンドにロジカルレプリケーションのwalsendeモードに入ることを指示します。
ロジカルレプリケーションwalsenderモードでは、以下に示すレプリケーションコマンドを通常のSQLコマンドと同様に実行できます。
</para>

<para>
<!--
In either physical replication or logical replication walsender mode, only the
simple query protocol can be used.
-->
物理レプリケーション、ロジカルレプリケーションいずれかのwalsenderモードでは、簡易問い合わせプロトコルのみ使用できます。
</para>

<para>
<!--
 For the purpose of testing replication commands, you can make a replication
 connection via <application>psql</application> or any other
 <application>libpq</application>-using tool with a connection string including
 the <literal>replication</literal> option,
 e.g.:
-->
レプリケーションコマンドをテストするために、<literal>replication</literal>オプションを含む接続文字列を使用して、<application>psql</application>または他の<literal>libpq</literal>によるレプリケーション接続を作成できます。
例を示します。
<programlisting>
psql "dbname=postgres replication=database" -c "IDENTIFY_SYSTEM;"
</programlisting>
<!--
 However, it is often more useful to use
 <xref linkend="app-pgreceivewal"/> (for physical replication) or
 <xref linkend="app-pgrecvlogical"/> (for logical replication).
-->
しかし、物理的レプリケーションのために<xref linkend="app-pgreceivewal"/>を使用し、論理的レプリケーションのため<xref linkend="app-pgrecvlogical"/>を使用すれば、もっと有用なことが多いです。
</para>

<para>
<!--
Replication commands are logged in the server log when
<xref linkend="guc-log-replication-commands"/> is enabled.
-->
<xref linkend="guc-log-replication-commands"/>が有効であるとき、サーバログにレプリケーションコマンドが記録されます。
</para>

<para>
<!--
The commands accepted in replication mode are:
-->
レプリケーションモードで受け付けられるコマンドは以下の通りです。
<variablelist>
  <varlistentry>
    <term><literal>IDENTIFY_SYSTEM</literal>
     <indexterm><primary>IDENTIFY_SYSTEM</primary></indexterm>
    </term>
    <listitem>
     <para>
<!--
      Requests the server to identify itself. Server replies with a result
      set of a single row, containing four fields:
-->
サーバに自身を識別することを要求します。
サーバは以下の４つのフィールドを持つ単一行の結果セットをもって応答します。
     </para>

     <para>
      <variablelist>
      <varlistentry>
      <term>
       <literal>systemid</literal> (<type>text</type>)
      </term>
      <listitem>
      <para>
<!--
       The unique system identifier identifying the cluster. This
       can be used to check that the base backup used to initialize the
       standby came from the same cluster.
-->
クラスタを識別する一意なシステム識別子です。
これを使用してスタンバイを初期化するために使用するベースバックアップが同じクラスタに由来していることを検査することができます。
      </para>
      </listitem>
      </varlistentry>

      <varlistentry>
      <term>
       <literal>timeline</literal> (<type>int4</type>)
      </term>
      <listitem>
      <para>
<!--
       Current timeline ID. Also useful to check that the standby is
       consistent with the master.
-->
現在のタイムラインIDです。
同様にスタンバイがマスタと一貫性を持つことを検査するために使用されます。
      </para>
      </listitem>
      </varlistentry>

      <varlistentry>
      <term>
       <literal>xlogpos</literal> (<type>text</type>)
      </term>
      <listitem>
      <para>
<!--
       Current WAL flush location. Useful to get a known location in the
       write-ahead log where streaming can start.
-->
現在のWALの吐き出し位置です。
ストリーミングを開始できる先行書き込みログの既知の位置を得る際に有用です。
      </para>
      </listitem>
      </varlistentry>

      <varlistentry>
      <term>
       <literal>dbname</literal> (<type>text</type>)
      </term>
      <listitem>
      <para>
<!--
       Database connected to or null.
-->
接続したデータベース名またはNULLです。
      </para>
      </listitem>
      </varlistentry>

      </variablelist>
     </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term><literal>SHOW</literal> <replaceable class="parameter">name</replaceable>
     <indexterm><primary>SHOW</primary></indexterm>
    </term>
    <listitem>
     <para>
<!--
      Requests the server to send the current setting of a run-time parameter.
      This is similar to the SQL command <xref linkend="sql-show"/>.
-->
実行時パラメータの現在の設定を送信するようサーバに要求します。
これはSQLコマンド<xref linkend="sql-show"/>と同等です。
     </para>

     <variablelist>
      <varlistentry>
       <term><replaceable class="parameter">name</replaceable></term>
       <listitem>
         <para>
<!--
          The name of a run-time parameter. Available parameters are documented
          in <xref linkend="runtime-config"/>.
-->
実行時パラメータの名前です。
利用できるパラメータは<xref linkend="runtime-config"/>に記述されています。
         </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term><literal>TIMELINE_HISTORY</literal> <replaceable class="parameter">tli</replaceable>
     <indexterm><primary>TIMELINE_HISTORY</primary></indexterm>
    </term>
    <listitem>
     <para>
<!--
      Requests the server to send over the timeline history file for timeline
      <replaceable class="parameter">tli</replaceable>.  Server replies with a
      result set of a single row, containing two fields:
-->
<replaceable class="parameter">tli</replaceable>のタイムラインのため、サーバにタイムライン履歴ファイルの送付を要求します。
サーバは2列単一行の結果セットを返します。
     </para>

     <para>
      <variablelist>
      <varlistentry>
      <term>
       <literal>filename</literal> (<type>text</type>)
      </term>
      <listitem>
      <para>
<!--
       File name of the timeline history file, e.g., <filename>00000002.history</filename>.
-->
タイムライン履歴ファイル名、例えば<filename>00000002.history</filename>
      </para>
      </listitem>
      </varlistentry>

      <varlistentry>
      <term>
       <literal>content</literal> (<type>bytea</type>)
      </term>
      <listitem>
      <para>
<!--
       Contents of the timeline history file.
-->
タイムライン履歴ファイルの内容
      </para>
      </listitem>
      </varlistentry>

      </variablelist>
     </para>
    </listitem>
  </varlistentry>

  <varlistentry id="protocol-replication-create-slot" xreflabel="CREATE_REPLICATION_SLOT">
   <term><literal>CREATE_REPLICATION_SLOT</literal> <replaceable class="parameter">slot_name</replaceable> [ <literal>TEMPORARY</literal> ] { <literal>PHYSICAL</literal> [ <literal>RESERVE_WAL</literal> ] | <literal>LOGICAL</literal> <replaceable class="parameter">output_plugin</replaceable> [ <literal>EXPORT_SNAPSHOT</literal> | <literal>NOEXPORT_SNAPSHOT</literal> | <literal>USE_SNAPSHOT</literal> ] }
     <indexterm><primary>CREATE_REPLICATION_SLOT</primary></indexterm>
    </term>
    <listitem>
     <para>
<!--
      Create a physical or logical replication
      slot. See <xref linkend="streaming-replication-slots"/> for more about
      replication slots.
-->
物理的または論理的レプリケーションスロットを作成します。
レプリケーションスロットの詳細は<xref linkend="streaming-replication-slots"/>を参照。
     </para>
     <variablelist>
      <varlistentry>
       <term><replaceable class="parameter">slot_name</replaceable></term>
       <listitem>
         <para>
<!--
          The name of the slot to create. Must be a valid replication slot
          name (see <xref linkend="streaming-replication-slots-manipulation"/>).
-->
作成するスロット名。
有効なレプリケーションスロット名でなければならない。
（<xref linkend="streaming-replication-slots-manipulation"/>を参照）。
         </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><replaceable class="parameter">output_plugin</replaceable></term>
       <listitem>
         <para>
<!--
          The name of the output plugin used for logical decoding
          (see <xref linkend="logicaldecoding-output-plugin"/>).
-->
ロジカルデコーディングに使用される出力プラグイン名。
（<xref linkend="logicaldecoding-output-plugin"/>を参照）。
         </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><literal>TEMPORARY</literal></term>
       <listitem>
        <para>
<!--
         Specify that this replication slot is a temporary one. Temporary
         slots are not saved to disk and are automatically dropped on error
         or when the session has finished.
-->
このレプリケーションスロットが一時スロットであることを指定します。
一時スロットはディスクに保存されず、エラー発生時またはセッション終了時に自動で機に削除されます。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><literal>RESERVE_WAL</literal></term>
       <listitem>
        <para>
<!--
         Specify that this physical replication slot reserves <acronym>WAL</acronym>
         immediately.  Otherwise, <acronym>WAL</acronym> is only reserved upon
         connection from a streaming replication client.
-->
この物理的レプリケーションスロットが直ちに<acronym>WAL</acronym>を予約することを指定します。
そうでなければ、<acronym>WAL</acronym>はストリーミングレプリケーションクライアントからの接続に応じてだけ予約されます。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><literal>EXPORT_SNAPSHOT</literal></term>
       <term><literal>NOEXPORT_SNAPSHOT</literal></term>
       <term><literal>USE_SNAPSHOT</literal></term>
       <listitem>
        <para>
<!--
         Decides what to do with the snapshot created during logical slot
         initialization. <literal>EXPORT_SNAPSHOT</literal>, which is the default,
         will export the snapshot for use in other sessions. This option can't
         be used inside a transaction.  <literal>USE_SNAPSHOT</literal> will use the
         snapshot for the current transaction executing the command. This
         option must be used in a transaction, and
         <literal>CREATE_REPLICATION_SLOT</literal> must be the first command
         run in that transaction.  Finally, <literal>NOEXPORT_SNAPSHOT</literal> will
         just use the snapshot for logical decoding as normal but won't do
         anything else with it.
-->
論理スロットの初期化時に作成されたスナップショットの処理について決定します。
デフォルトの<literal>EXPORT_SNAPSHOT</literal>はスナップショットが他のセッションで利用できるようエクスポートします。
このオプションはトランザクションの内側で使用することはできません。
<literal>USE_SNAPSHOT</literal>はこのコマンドを実行している現在のトランザクションでスナップショットを利用します。
このオプションはトランザクション内で使用しなければならず、<literal>CREATE_REPLICATION_SLOT</literal>がそのトランザクション内で実行される最初のコマンドでなければなりません。
最後に、<literal>NOEXPORT_SNAPSHOT</literal>は論理デコーディングで通常通りにスナップショットを使用するだけで、他には何もしません。
        </para>
       </listitem>
      </varlistentry>
     </variablelist>

     <para>
<!--
      In response to this command, the server will send a one-row result set
      containing the following fields:
-->
このコマンドへの応答として、サーバは以下のフィールドを含む1行の結果集合を送信します。

      <variablelist>
       <varlistentry>
        <term><literal>slot_name</literal> (<type>text</type>)</term>
        <listitem>
         <para>
<!--
          The name of the newly-created replication slot.
-->
新しく作成されたレプリケーションスロットの名前です。
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>consistent_point</literal> (<type>text</type>)</term>
        <listitem>
         <para>
<!--
          The WAL location at which the slot became consistent.  This is the
          earliest location from which streaming can start on this replication
          slot.
-->
スロットが一貫性のある状態になった時点のWAL位置です。
これが、このスロット上でストリーミングを開始できる最も早い場所となります。
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>snapshot_name</literal> (<type>text</type>)</term>
        <listitem>
         <para>
<!--
          The identifier of the snapshot exported by the command.  The
          snapshot is valid until a new command is executed on this connection
          or the replication connection is closed.  Null if the created slot
          is physical.
-->
このコマンドでエクスポートされるスナップショットの識別子です。
スナップショットは、この接続上で新しいコマンドが実行されるか、レプリケーション接続が閉じられるまで有効です。
作成されたのが物理スロットの場合はNULLになります。
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>output_plugin</literal> (<type>text</type>)</term>
        <listitem>
         <para>
<!--
          The name of the output plugin used by the newly-created replication
          slot.  Null if the created slot is physical.
-->
新しく作成されたレプリケーションスロットが使用する出力プラグインの名前です。
作成されたのが物理スロットの場合はNULLになります。
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term><literal>START_REPLICATION</literal> [ <literal>SLOT</literal> <replaceable class="parameter">slot_name</replaceable> ] [ <literal>PHYSICAL</literal> ] <replaceable class="parameter">XXX/XXX</replaceable> [ <literal>TIMELINE</literal> <replaceable class="parameter">tli</replaceable> ]
     <indexterm><primary>START_REPLICATION</primary></indexterm>
    </term>
    <listitem>
     <para>
<!--
      Instructs server to start streaming WAL, starting at
      WAL location <replaceable class="parameter">XXX/XXX</replaceable>.
      If <literal>TIMELINE</literal> option is specified,
      streaming starts on timeline <replaceable class="parameter">tli</replaceable>;
      otherwise, the server's current timeline is selected. The server can
      reply with an error, for example if the requested section of WAL has already
      been recycled. On success, server responds with a CopyBothResponse
      message, and then starts to stream WAL to the frontend.
-->
サーバに対して、WALのストリーミングを<replaceable class="parameter">XXX/XXX</replaceable> WAL時点から開始するよう指示します。
<literal>TIMELINE</literal>オプションが指定された場合、ストリーミングは<replaceable class="parameter">tli</replaceable>のタイムラインから開始されます。
そうでなければ、サーバの現在のタイムラインが選択されます。
サーバが、例えば、要求されたWALの断片がすでに回収されているなど、エラーを返すことがありえます。
成功時サーバはCopyBothResponseメッセージで応答し、フロントエンドに対するWALストリームを開始します。
     </para>

     <para>
<!--
      If a slot's name is provided
      via <replaceable class="parameter">slot_name</replaceable>, it will be updated
      as replication progresses so that the server knows which WAL segments,
      and if <varname>hot_standby_feedback</varname> is on which transactions,
      are still needed by the standby.
-->
<replaceable class="parameter">slot_name</replaceable>を経由してスロット名が提供された場合、それはレプリケーションの進行として更新されます。
それによってサーバは、どのWALセグメントがまだスタンバイに必要か、<varname>hot_standby_feedback</varname>のトランザクションはどれか、を感知します。
     </para>

     <para>
<!--
      If the client requests a timeline that's not the latest but is part of
      the history of the server, the server will stream all the WAL on that
      timeline starting from the requested start point up to the point where
      the server switched to another timeline. If the client requests
      streaming at exactly the end of an old timeline, the server responds
      immediately with CommandComplete without entering COPY mode.
-->
最新ではなくて、サーバの過去のタイムラインをクライアントが要求した場合、サーバは要求された開始時点から他のタイムラインに切り替えるまでの、全てのWALストリームを送付します。
クライアントが旧タイムラインの終点のストリームを要求した場合、サーバはCOPYモードに入らずにCommandCompleteをすぐに応答します。
     </para>

     <para>
<!--
      After streaming all the WAL on a timeline that is not the latest one,
      the server will end streaming by exiting the COPY mode. When the client
      acknowledges this by also exiting COPY mode, the server sends a result
      set with one row and two columns, indicating the next timeline in this
      server's history. The first column is the next timeline's ID (type <type>int8</type>), and the
      second column is the WAL location where the switch happened (type <type>text</type>). Usually,
      the switch position is the end of the WAL that was streamed, but there
      are corner cases where the server can send some WAL from the old
      timeline that it has not itself replayed before promoting. Finally, the
      server sends two CommandComplete messages (one that ends the CopyData
      and the other ends the <literal>START_REPLICATION</literal> itself), and
      is ready to accept a new command.
-->
最新でないタイムラインの全てのWALストリームを送付した後、サーバはCOPYモードを出ることによりストリームを終了します。
クライアントもCOPYモードを出ることにより承認した場合、サーバは2列単一行の結果セットを送付し、サーバにある次のタイムラインを示します。
最初の列は次のタイムラインID(<type>int8</type>型)であり、次の列は切り替えたWALの位置(<type>text</type>型)です。
通常切り替えた位置はWALストリームの終点ですが、昇格する前に再実行されなかった旧タイムラインからWALを送付するというまれな場合もあります。
最後に、サーバは２つのCommandCompleteメッセージ（一方はCopyDataを終了し、もう一方は<literal>START_REPLICATION</literal>自体を終了する）を送付し、新規のコマンドを受理できるようになります。
     </para>

     <para>
<!--
      WAL data is sent as a series of CopyData messages.  (This allows
      other information to be intermixed; in particular the server can send
      an ErrorResponse message if it encounters a failure after beginning
      to stream.)  The payload of each CopyData message from server to the
      client contains a message of one of the following formats:
-->
WALデータはCopyDataメッセージ群として送信されます。
（これにより他の情報を混在させることができます。
具体的にはサーバはストリーム開始後に失敗が起きた場合にErrorResponseメッセージを送信することができます。）
サーバからクライアントへの各CopyDataメッセージのペイロード、は以下の書式のどれかを含みます。
     </para>

     <para>
      <variablelist>
      <varlistentry>
      <term>
          XLogData (B)
      </term>
      <listitem>
      <para>
      <variablelist>
      <varlistentry>
      <term>
          Byte1('w')
      </term>
      <listitem>
      <para>
<!--
          Identifies the message as WAL data.
-->
メッセージをWALデータとして識別します。
      </para>
      </listitem>
      </varlistentry>
      <varlistentry>
      <term>
          Int64
      </term>
      <listitem>
      <para>
<!--
          The starting point of the WAL data in this message.
-->
このメッセージ内のWALの開始点。
      </para>
      </listitem>
      </varlistentry>
      <varlistentry>
      <term>
          Int64
      </term>
      <listitem>
      <para>
<!--
          The current end of WAL on the server.
-->
サーバ上の現在のWAL終了点。
      </para>
      </listitem>
      </varlistentry>
      <varlistentry>
      <term>
          Int64
      </term>
      <listitem>
      <para>
<!--
          The server's system clock at the time of transmission, as
          microseconds since midnight on 2000-01-01.
-->
転送時点でのサーバのシステム時刻。
2000年1月1日午前0時からのマイクロ秒。
      </para>
      </listitem>
      </varlistentry>
      <varlistentry>
      <term>
          Byte<replaceable>n</replaceable>
      </term>
      <listitem>
      <para>
<!--
          A section of the WAL data stream.
-->
WALデータストリームの断片。
      </para>
      <para>
<!--
          A single WAL record is never split across two XLogData messages.
          When a WAL record crosses a WAL page boundary, and is therefore
          already split using continuation records, it can be split at the page
          boundary. In other words, the first main WAL record and its
          continuation records can be sent in different XLogData messages.
-->
単一のWALレコードが2つのXLogDataメッセージに分かれることはありません。
しかしWALレコードがWALページ境界を跨る場合、継続レコードを用いてすでに分割されていますので、ページ境界で分割することができます。
言い換えると、先頭の主WALレコードとその継続レコードは、別のXLogDataメッセージとして分かれることがありえます。
      </para>
      </listitem>
      </varlistentry>
      </variablelist>
      </para>
      </listitem>
      </varlistentry>
      <varlistentry>
      <term>
<!--
          Primary keepalive message (B)
-->
プライマリキープアライブメッセージ(B)
      </term>
      <listitem>
      <para>
      <variablelist>
      <varlistentry>
      <term>
          Byte1('k')
      </term>
      <listitem>
      <para>
<!--
          Identifies the message as a sender keepalive.
-->
このメッセージを送信元キープアライブとして識別します。
      </para>
      </listitem>
      </varlistentry>
      <varlistentry>
      <term>
          Int64
      </term>
      <listitem>
      <para>
<!--
          The current end of WAL on the server.
-->
サーバ上の現在のWAL終端。
      </para>
      </listitem>
      </varlistentry>
      <varlistentry>
      <term>
          Int64
      </term>
      <listitem>
      <para>
<!--
          The server's system clock at the time of transmission, as
          microseconds since midnight on 2000-01-01.
-->
転送時点でのサーバのシステム時刻。
2000年1月1日午前0時からのマイクロ秒。
      </para>
      </listitem>
      </varlistentry>
      <varlistentry>
      <term>
          Byte1
      </term>
      <listitem>
      <para>
<!--
          1 means that the client should reply to this message as soon as
          possible, to avoid a timeout disconnect. 0 otherwise.
-->
タイムアウトによる切断を避けるため、クライアントがこのメッセージに即時に応答するべき方法の1つ。
0またはその他
      </para>
      </listitem>
      </varlistentry>
      </variablelist>
      </para>
      </listitem>
      </varlistentry>
      </variablelist>
     </para>

     <para>
<!--
       The receiving process can send replies back to the sender at any time,
       using one of the following message formats (also in the payload of a
       CopyData message):
-->
以下のメッセージ書式の1つ（およびCopyDataメッセージのペイロード中のもの）を使用して、受理プロセスは送信者にいつでも応答できます。
     </para>

     <para>
      <variablelist>
      <varlistentry>
      <term>
<!--
          Standby status update (F)
-->
スタンバイ状態の更新(F)
      </term>
      <listitem>
      <para>
      <variablelist>
      <varlistentry>
      <term>
          Byte1('r')
      </term>
      <listitem>
      <para>
<!--
          Identifies the message as a receiver status update.
-->
メッセージを受信側の状態更新として識別します。
      </para>
      </listitem>
      </varlistentry>
      <varlistentry>
      <term>
          Int64
      </term>
      <listitem>
      <para>
<!--
          The location of the last WAL byte + 1 received and written to disk
          in the standby.
-->
スタンバイにおいて受信しディスクに書き込まれた最終WALバイト+1の場所。
      </para>
      </listitem>
      </varlistentry>
      <varlistentry>
      <term>
          Int64
      </term>
      <listitem>
      <para>
<!--
          The location of the last WAL byte + 1 flushed to disk in
          the standby.
-->
スタンバイにおいてディスクに吐き出された最終WALバイト+1の場所。
      </para>
      </listitem>
      </varlistentry>
      <varlistentry>
      <term>
          Int64
      </term>
      <listitem>
      <para>
<!--
          The location of the last WAL byte + 1 applied in the standby.
-->
スタンバイにおいて適用された最終WALバイト+1の場所。
      </para>
      </listitem>
      </varlistentry>
      <varlistentry>
      <term>
          Int64
      </term>
      <listitem>
      <para>
<!--
          The client's system clock at the time of transmission, as
          microseconds since midnight on 2000-01-01.
-->
転送時点でのクライアントのシステム時刻。
2000年1月1日午前0時からのマイクロ秒。
      </para>
      </listitem>
      </varlistentry>
      <varlistentry>
      <term>
          Byte1
      </term>
      <listitem>
      <para>
<!--
          If 1, the client requests the server to reply to this message
          immediately. This can be used to ping the server, to test if
          the connection is still healthy.
-->
値が1の場合、このメッセージにすぐ応答するように、クライアントはサーバへ要求します。
この方法は、接続がまだ保持されているか検査するために、サーバへのピング送信として使用できます。
      </para>
      </listitem>
      </varlistentry>
      </variablelist>
      </para>
      </listitem>
      </varlistentry>
      </variablelist>
     </para>

     <para>
      <variablelist>
      <varlistentry>
      <term>
<!--
          Hot Standby feedback message (F)
-->
ホットスタンバイフィードバックメッセージ(F)
      </term>
      <listitem>
      <para>
      <variablelist>
      <varlistentry>
      <term>
          Byte1('h')
      </term>
      <listitem>
      <para>
<!--
          Identifies the message as a Hot Standby feedback message.
-->
メッセージをホットスタンバイのフィードバックメッセージとして識別します。
      </para>
      </listitem>
      </varlistentry>
      <varlistentry>
      <term>
          Int64
      </term>
      <listitem>
      <para>
<!--
          The client's system clock at the time of transmission, as
          microseconds since midnight on 2000-01-01.
-->
転送時点でのクライアントのシステム時刻。
2000年1月1日午前0時からのマイクロ秒
      </para>
      </listitem>
      </varlistentry>
      <varlistentry>
      <term>
          Int32
      </term>
      <listitem>
      <para>
<!--
          The standby's current global xmin, excluding the catalog_xmin from any
          replication slots. If both this value and the following
          catalog_xmin are 0 this is treated as a notification that Hot Standby
          feedback will no longer be sent on this connection. Later non-zero
          messages may reinitiate the feedback mechanism.
-->
スタンバイの現在のグローバルのxminですが、すべてのレプリケーションスロットのcatalog_xminは除きます。
この値と次のcatalog_xminがいずれも0なら、この接続ではホットスタンバイのフィードバックはもう送信されないという通知として扱われます。
後でゼロでないメッセージによりフィードバック機構を再開することができます。
      </para>
      </listitem>
      </varlistentry>
      <varlistentry>
      <term>
          Int32
      </term>
      <listitem>
      <para>
<!--
          The epoch of the global xmin xid on the standby.
-->
スタンバイのグローバルのxmin xidのエポックです。
      </para>
      </listitem>
      </varlistentry>
      <varlistentry>
      <term>
          Int32
      </term>
      <listitem>
      <para>
<!--
          The lowest catalog_xmin of any replication slots on the standby. Set to 0
          if no catalog_xmin exists on the standby or if hot standby feedback is being
          disabled.
-->
スタンバイのすべてのレプリケーションスロットのcatalog_xminの最小値です。
スタンバイ上にcatalog_xminが存在しない、あるいはホットスタンバイのフィードバックが無効化されている場合は0に設定します。
      </para>
      </listitem>
      </varlistentry>
      <varlistentry>
      <term>
          Int32
      </term>
      <listitem>
      <para>
<!--
          The epoch of the catalog_xmin xid on the standby.
-->
スタンバイのcatalog_xmin xidのエポックです。
      </para>
      </listitem>
      </varlistentry>
      </variablelist>
      </para>
      </listitem>
      </varlistentry>
      </variablelist>
     </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term><literal>START_REPLICATION</literal> <literal>SLOT</literal> <replaceable class="parameter">slot_name</replaceable> <literal>LOGICAL</literal> <replaceable class="parameter">XXX/XXX</replaceable> [ ( <replaceable>option_name</replaceable> [ <replaceable>option_value</replaceable> ] [, ...] ) ]</term>
    <listitem>
     <para>
<!--
      Instructs server to start streaming WAL for logical replication, starting
      at WAL location <replaceable class="parameter">XXX/XXX</replaceable>. The server can
      reply with an error, for example if the requested section of WAL has already
      been recycled. On success, server responds with a CopyBothResponse
      message, and then starts to stream WAL to the frontend.
-->
サーバに対して、<replaceable class="parameter">XXX/XXX</replaceable>WAL時点から、論理的レプリケーションのWALストリームを開始するよう指示します。
例えば、要求されたWALがすでに回収された場合、サーバはエラーを返します。
サーバが、例えば、要求されたWALセクションがすでに回収されている場合、エラーを返すことがありえます。
成功時サーバはCopyBothResponseメッセージで応答し、フロントエンドに対するWALストリームを開始します。
     </para>

     <para>
<!--
      The messages inside the CopyBothResponse messages are of the same format
      documented for <literal>START_REPLICATION ... PHYSICAL</literal>, including
      two CommandComplete messages.
-->
CopyBothResponse内部のメッセージは、2つのCommandCompleteメッセージを含めて<literal>START_REPLICATION ... PHYSICAL</literal>の記述と同じ書式です。
     </para>

     <para>
<!--
      The output plugin associated with the selected slot is used
      to process the output for streaming.
-->
選択されたスロットに関連した出力プラグインは、出力ストリームの処理に使用されます。
     </para>

     <variablelist>
      <varlistentry>
       <term><literal>SLOT</literal> <replaceable class="parameter">slot_name</replaceable></term>
       <listitem>
         <para>
<!--
          The name of the slot to stream changes from. This parameter is required,
          and must correspond to an existing logical replication slot created
          with <literal>CREATE_REPLICATION_SLOT</literal> in
          <literal>LOGICAL</literal> mode.
-->
ストリームを変更したスロット名。
このパラメータは必須であり、<literal>LOGICAL</literal>モードにおいて<literal>CREATE_REPLICATION_SLOT</literal>によって作成された、実在する論理的レプリケーションスロットに対応しなければなりません。
         </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><replaceable class="parameter">XXX/XXX</replaceable></term>
       <listitem>
        <para>
<!--
         The WAL location to begin streaming at.
-->
ストリームを開始するWAL時点。
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><replaceable class="parameter">option_name</replaceable></term>
       <listitem>
        <para>
<!--
         The name of an option passed to the slot's logical decoding plugin.
-->
レプリケーションスロットのロジカルデコーディング出力プラグインに渡すオプション名。
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><replaceable class="parameter">option_value</replaceable></term>
       <listitem>
        <para>
<!--
         Optional value, in the form of a string constant, associated with the
         specified option.
-->
オプションの値。
文字列定数の形式。
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>
     <literal>DROP_REPLICATION_SLOT</literal> <replaceable class="parameter">slot_name</replaceable> <optional> <literal>WAIT</literal> </optional>
     <indexterm><primary>DROP_REPLICATION_SLOT</primary></indexterm>
    </term>
    <listitem>
     <para>
<!--
      Drops a replication slot, freeing any reserved server-side resources.
      If the slot is a logical slot that was created in a database other than
      the database the walsender is connected to, this command fails.
-->
レプリケーションスロットを削除し、サーバ側で準備した資源を解放します。
このスロットが、walsenderが接続しているデータベース以外のデータベースで作成された論理スロットの場合、このコマンドは失敗します。
     </para>
     <variablelist>
      <varlistentry>
       <term><replaceable class="parameter">slot_name</replaceable></term>
       <listitem>
         <para>
<!--
          The name of the slot to drop.
-->
削除するスロット名。
         </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><literal>WAIT</literal></term>
       <listitem>
        <para>
<!--
         This option causes the command to wait if the slot is active until
         it becomes inactive, instead of the default behavior of raising an
         error.
-->
このオプションを使用すると、スロットが使用中の時に、スロットの使用が終わるまでコマンドを待機させます。
デフォルトの動作ではエラーを発生させます。
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </listitem>
  </varlistentry>

  <varlistentry id="protocol-replication-base-backup" xreflabel="BASE_BACKUP">
    <term><literal>BASE_BACKUP</literal> [ <literal>LABEL</literal> <replaceable>'label'</replaceable> ] [ <literal>PROGRESS</literal> ] [ <literal>FAST</literal> ] [ <literal>WAL</literal> ] [ <literal>NOWAIT</literal> ] [ <literal>MAX_RATE</literal> <replaceable>rate</replaceable> ] [ <literal>TABLESPACE_MAP</literal> ] [ <literal>NOVERIFY_CHECKSUMS</literal> ] [ <literal>MANIFEST</literal> <replaceable>manifest_option</replaceable> ] [ <literal>MANIFEST_CHECKSUMS</literal> <replaceable>checksum_algorithm</replaceable> ]
     <indexterm><primary>BASE_BACKUP</primary></indexterm>
    </term>
    <listitem>
     <para>
<!--
      Instructs the server to start streaming a base backup.
      The system will automatically be put in backup mode before the backup
      is started, and taken out of it when the backup is complete. The
      following options are accepted:
-->
サーバにベースバックアップのストリーミングを始めるよう指示します。
システムはバックアップが開始される前に自動的にバックアップモードになり、バックアップが完了した時に取り出されます。
以下のオプションを受け付けることができます。
      <variablelist>
       <varlistentry>
        <term><literal>LABEL</literal> <replaceable>'label'</replaceable></term>
        <listitem>
         <para>
<!--
          Sets the label of the backup. If none is specified, a backup label
          of <literal>base backup</literal> will be used. The quoting rules
          for the label are the same as a standard SQL string with
          <xref linkend="guc-standard-conforming-strings"/> turned on.
-->
バックアップのラベルを設定します。
指定がない場合、<literal>base backup</literal>というバックアップラベルが使用されます。
ラベルについての引用符付け規則は、<xref linkend="guc-standard-conforming-strings"/>を有効にした場合の標準SQLの文字列の規則と同じです。
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>PROGRESS</literal></term>
        <listitem>
         <para>
<!--
          Request information required to generate a progress report. This will
          send back an approximate size in the header of each tablespace, which
          can be used to calculate how far along the stream is done. This is
          calculated by enumerating all the file sizes once before the transfer
          is even started, and might as such have a negative impact on the
          performance.  In particular, it might take longer before the first data
          is streamed. Since the database files can change during the backup,
          the size is only approximate and might both grow and shrink between
          the time of approximation and the sending of the actual files.
-->
進行状況の報告を生成するために必要な情報を要求します。
これは、ストリームが完了するまでにどのくらいかかるかを計算するために使用することができる、各テーブル空間のヘッダ内の概算容量を返送します。
これは、転送を始める前のすべてのファイルサイズを１度数え上げることで計算されます。
これ自体が性能に与える悪影響があるかもしれません。
特に最初のデータがストリームされるまでにより多くの時間がかかる可能性があります。
データベースファイルはバックアップの間変更される可能性がありますので、容量は概算に過ぎず、概算時と実ファイルを送信するまでの間に増減される可能性があります。
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>FAST</literal></term>
        <listitem>
         <para>
<!--
          Request a fast checkpoint.
-->
高速チェックポイントを要求します。
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>WAL</literal></term>
        <listitem>
         <para>
<!--
          Include the necessary WAL segments in the backup. This will include
          all the files between start and stop backup in the
          <filename>pg_wal</filename> directory of the base directory tar
          file.
-->
バックアップ内に必要なWALセグメントを含めます。
ベースディレクトリtarファイルの<filename>pg_wal</filename>ディレクトリにある、バックアップの開始から終了までのすべてのファイルが含まれます。
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>NOWAIT</literal></term>
        <listitem>
         <para>
<!--
          By default, the backup will wait until the last required WAL
          segment has been archived, or emit a warning if log archiving is
          not enabled. Specifying <literal>NOWAIT</literal> disables both
          the waiting and the warning, leaving the client responsible for
          ensuring the required log is available.
-->
デフォルトでは、バックアップは必要な最終WALセグメントがアーカイブされるまで待機します。
ログアーカイブが有効でない場合は警告が発せられます。
<literal>NOWAIT</literal>により、必要なログが利用できるようになったことを確認することをクライアント側の責任として、この待機や警告が無効になります。
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>MAX_RATE</literal> <replaceable>rate</replaceable></term>
        <listitem>
         <para>
<!--
          Limit (throttle) the maximum amount of data transferred from server
          to client per unit of time.  The expected unit is kilobytes per second.
          If this option is specified, the value must either be equal to zero
          or it must fall within the range from 32 kB through 1 GB (inclusive).
          If zero is passed or the option is not specified, no restriction is
          imposed on the transfer.
-->
サーバからクライアントへ転送する単位時間当たりの最大データ容量を制限します（絞ります）。
予期される単位はkB/s（キロバイト/秒）です。
このオプションが指定された場合、値はゼロまたは32 kB以上1 GB以下でなければなりません。
ゼロが渡されるかオプションが指定されない場合、転送の制約は課されません。
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>TABLESPACE_MAP</literal></term>
        <listitem>
         <para>
<!--
          Include information about symbolic links present in the directory
          <filename>pg_tblspc</filename> in a file named
          <filename>tablespace_map</filename>. The tablespace map file includes
          each symbolic link name as it exists in the directory
          <filename>pg_tblspc/</filename> and the full path of that symbolic link.
-->
ディレクトリ<filename>pg_tblspc</filename>にあるシンボリックリンクに関する情報を<filename>tablespace_map</filename>という名前のファイルに含めます。
テーブル空間マップファイルには、ディレクトリ<filename>pg_tblspc/</filename>に存在する各シンボリックリンクの名前とそのシンボリックリンクのフルパスが含まれています。
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>NOVERIFY_CHECKSUMS</literal></term>
        <listitem>
         <para>
<!--
          By default, checksums are verified during a base backup if they are
          enabled. Specifying <literal>NOVERIFY_CHECKSUMS</literal> disables
          this verification.
-->
デフォルトでは、チェックサムが有効である場合、ベースバックアップ中にチェックサムが検証されます。
<literal>NOVERIFY_CHECKSUMS</literal>を指定すると、この検証を無効にします。
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>MANIFEST</literal> <replaceable>manifest_option</replaceable></term>
        <listitem>
         <para>
<!--
          When this option is specified with a value of <literal>yes</literal>
          or <literal>force-encode</literal>, a backup manifest is created
          and sent along with the backup.  The manifest is a list of every
          file present in the backup with the exception of any WAL files that
          may be included. It also stores the size, last modification time, and
          optionally a checksum for each file.
          A value of <literal>force-encode</literal> forces all filenames
          to be hex-encoded; otherwise, this type of encoding is performed only
          for files whose names are non-UTF8 octet sequences.
          <literal>force-encode</literal> is intended primarily for testing
          purposes, to be sure that clients which read the backup manifest
          can handle this case. For compatibility with previous releases,
          the default is <literal>MANIFEST 'no'</literal>.
-->
このオプションを<literal>yes</literal>または<literal>force-encode</literal>の値で設定すると、バックアップマニフェストが作成され、バックアップとともに送信されます。
マニフェストは、含まれる可能性のあるWALファイルを除きバックアップ内に存在するすべてのファイルのリストです。
また、サイズ、最終更新時刻、オプションでファイル毎のチェックサムも格納します。
<literal>force-encode</literal>の値は、全てのファイル名を強制的に16進数でエンコーディングします。
それ以外の場合、このタイプのエンコードは、名前が非UTF-8オクテットシーケンスであるファイルに対してのみ実行されます。
<literal>force-encode</literal>は、主にテスト目的で使用されており、バックアップマニュフェストを読み取るクライアントがこのケースを処理できることを確認するために使用されます。
以前のリリースとの互換性を保つため、デフォルトは、<literal>MANIFEST 'no'</literal>です。
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>MANIFEST_CHECKSUMS</literal> <replaceable>checksum_algorithm</replaceable></term>
        <listitem>
         <para>
<!--
          Specifies the checksum algorithm that should be applied to each file included
          in the backup manifest. Currently, the available
          algorithms are <literal>NONE</literal>, <literal>CRC32C</literal>,
          <literal>SHA224</literal>, <literal>SHA256</literal>,
          <literal>SHA384</literal>, and <literal>SHA512</literal>.
          The default is <literal>CRC32C</literal>.
-->
バックアップマニュフェストに含まれている各ファイルに適用するチェックサムアルゴリズムを指定します。
現在使用可能なアルゴリズムは、<literal>NONE</literal>、<literal>CRC32C</literal>、<literal>SHA224</literal>, <literal>SHA256</literal>、<literal>SHA384</literal>、<literal>SHA512</literal>です。
デフォルトは<literal>CRC32C</literal>です。
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </para>
     <para>
<!--
      When the backup is started, the server will first send two
      ordinary result sets, followed by one or more CopyResponse
      results.
-->
バックアップを開始する時、サーバはまず２つの通常の結果セットを送信し、続けて１つ以上のCopyResponse結果を送信します。
     </para>
     <para>
<!--
      The first ordinary result set contains the starting position of the
      backup, in a single row with two columns. The first column contains
      the start position given in XLogRecPtr format, and the second column
      contains the corresponding timeline ID.
-->
最初の通常の結果セットには、1行2列という形でバックアップの開始位置が含まれます。
最初の列にはXLogRecPtr書式の開始位置が、2番目の列には対応するタイムラインIDが含まれます。
     </para>
     <para>
<!--
      The second ordinary result set has one row for each tablespace.
      The fields in this row are:
-->
２番目の通常の結果セットには各テーブル空間に付き１行を持ちます。
この行のフィールドは以下の通りです。
      <variablelist>
       <varlistentry>
        <term><literal>spcoid</literal> (<type>oid</type>)</term>
        <listitem>
         <para>
<!--
          The OID of the tablespace, or null if it's the base
          directory.
-->
テーブル空間のOIDです。
ベースディレクトリの場合はNULLです。
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term><literal>spclocation</literal> (<type>text</type>)</term>
        <listitem>
         <para>
<!--
          The full path of the tablespace directory, or null
          if it's the base directory.
-->
テーブル空間ディレクトリのフルパスです。
ベースディレクトリの場合はNULLです。
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term><literal>size</literal> (<type>int8</type>)</term>
        <listitem>
         <para>
<!--
          The approximate size of the tablespace, in kilobytes (1024 bytes),
          if progress report has been requested; otherwise it's null.
-->
進行状況の報告が要求された場合は、テーブル空間の概算容量です(キロバイト(1024バイト)単位)。
要求されていない場合はNULLです。
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </para>
     <para>
<!--
      After the second regular result set, one or more CopyResponse results
      will be sent, one for the main data directory and one for each additional tablespace other
      than <literal>pg_default</literal> and <literal>pg_global</literal>. The data in
      the CopyResponse results will be a tar format (following the
      <quote>ustar interchange format</quote> specified in the POSIX 1003.1-2008
      standard) dump of the tablespace contents, except that the two trailing
      blocks of zeroes specified in the standard are omitted.
      After the tar data is complete, and if a backup manifest was requested,
      another CopyResponse result is sent, containing the manifest data for the
      current base backup. In any case, a final ordinary result set will be
      sent, containing the WAL end position of the backup, in the same format as
      the start position.
-->
２番目の通常の結果セットの後、１つ以上のCopyResponse結果が送信されます。
主データディレクトリ用に1つ、<literal>pg_default</literal>、<literal>pg_global</literal>以外の追加のテーブル空間ごとに1つ送信されます。
CopyResponse結果内のデータは、テーブル空間の内容のtar形式（POSIX 1003.1-2008標準で規定された<quote>ustar交換形式</quote>に従う）ダンプです。
ただし標準で規定された最後の２つのゼロブロックは省略されています。
このtarデータが終わった後、バックアップマニフェストが要求された場合、現在のベースバックアップのマニフェストデータを含む別のCopyResponse結果が送信されます。
いずれの場合も、バックアップのWAL終了位置を含む最終の通常の結果セットが、開始位置と同じ形式で送信されます。
     </para>

     <para>
<!--
      The tar archive for the data directory and each tablespace will contain
      all files in the directories, regardless of whether they are
      <productname>PostgreSQL</productname> files or other files added to the same
      directory. The only excluded files are:
-->
データディレクトリと各テーブル空間のtarアーカイブには、そのディレクトリ内のファイルが<productname>PostgreSQL</productname>ファイルかそのディレクトリに追加された他のファイルかに関係なく、すべて含まれます。
以下に除かれるファイルを示します。
      <itemizedlist spacing="compact" mark="bullet">
       <listitem>
        <para>
         <filename>postmaster.pid</filename>
        </para>
       </listitem>
       <listitem>
        <para>
         <filename>postmaster.opts</filename>
        </para>
       </listitem>
       <listitem>
        <para>
<!--
         <filename>pg_internal.init</filename> (found in multiple directories)
-->
         <filename>pg_internal.init</filename>（複数のディレクトリに在ります）
        </para>
       </listitem>
       <listitem>
        <para>
<!--
         Various temporary files and directories created during the operation
         of the PostgreSQL server, such as any file or directory beginning
         with <filename>pgsql_tmp</filename> and temporary relations.
-->
PostgreSQLサーバの操作中に作成される種々の一時ファイルおよびディレクトリで、<filename>pgsql_tmp</filename>で始まるすべてのファイルおよびディレクトリ、および一時リレーション。
        </para>
       </listitem>
       <listitem>
        <para>
<!--
         Unlogged relations, except for the init fork which is required to
         recreate the (empty) unlogged relation on recovery.
-->
ログを取らないリレーション。ただし、リカバリでログを取らないリレーションの再作成に必要なinitフォークは除かれない。
        </para>
       </listitem>
       <listitem>
        <para>
<!--
         <filename>pg_wal</filename>, including subdirectories. If the backup is run
         with WAL files included, a synthesized version of <filename>pg_wal</filename> will be
         included, but it will only contain the files necessary for the
         backup to work, not the rest of the contents.
-->
サブディレクトリを含む<filename>pg_wal</filename>。
バックアップがwalファイルを含めて実行される場合、合成された版の<filename>pg_wal</filename>が含まれます。
これにはバックアップが動作するために必要なファイルのみが含まれ、残りの内容は含まれません。
        </para>
       </listitem>
       <listitem>
        <para>
<!--
         <filename>pg_dynshmem</filename>, <filename>pg_notify</filename>,
         <filename>pg_replslot</filename>, <filename>pg_serial</filename>,
         <filename>pg_snapshots</filename>, <filename>pg_stat_tmp</filename>, and
         <filename>pg_subtrans</filename> are copied as empty directories (even if
         they are symbolic links).
-->
<filename>pg_dynshmem</filename>、<filename>pg_notify</filename>、<filename>pg_replslot</filename>、<filename>pg_serial</filename>、<filename>pg_snapshots</filename>、<filename>pg_stat_tmp</filename>、<filename>pg_subtrans</filename>は（それがシンボリックリンクであったとしても）空のディレクトリとしてコピーされます。
        </para>
       </listitem>
       <listitem>
        <para>
<!--
         Files other than regular files and directories, such as symbolic
         links (other than for the directories listed above) and special
         device files, are skipped.  (Symbolic links
         in <filename>pg_tblspc</filename> are maintained.)
-->
シンボリックリンク（上記で列挙したディレクトリは除きます）や特殊デバイスファイルなど、通常のファイルとディレクトリ以外のものは省略されます。
（<filename>pg_tblspc</filename>中のシンボリックリンクは保持されます。）
        </para>
       </listitem>
      </itemizedlist>
<!--
      Owner, group, and file mode are set if the underlying file system on
      the server supports it.
-->
サーバ上の基盤となるファイルシステムがサポートする場合、所有者、グループ、ファイルのモードが設定されます。
     </para>
    </listitem>
  </varlistentry>
</variablelist>

</para>

</sect1>

<sect1 id="protocol-logical-replication">
<!--
 <title>Logical Streaming Replication Protocol</title>
-->
 <title>論理ストリーミングレプリケーションのプロトコル</title>

 <para>
<!--
  This section describes the logical replication protocol, which is the message
  flow started by the <literal>START_REPLICATION</literal>
  <literal>SLOT</literal> <replaceable class="parameter">slot_name</replaceable>
  <literal>LOGICAL</literal> replication command.
-->
この節では論理レプリケーションのプロトコルについて説明します。
このプロトコルはレプリケーションコマンド<literal>START_REPLICATION</literal> <literal>SLOT</literal> <replaceable class="parameter">slot_name</replaceable> <literal>LOGICAL</literal>で始まるメッセージフローです。
 </para>

 <para>
<!--
  The logical streaming replication protocol builds on the primitives of
  the physical streaming replication protocol.
-->
論理ストリーミングレプリケーションのプロトコルは、物理レプリケーションプロトコルの基本要素の上に構築されています。
 </para>

 <sect2 id="protocol-logical-replication-params">
<!--
  <title>Logical Streaming Replication Parameters</title>
-->
  <title>論理ストリーミングレプリケーションのパラメータ</title>

  <para>
<!--
   The logical replication <literal>START_REPLICATION</literal> command
   accepts following parameters:
-->
論理レプリケーションの<literal>START_REPLICATION</literal>コマンドは以下のパラメータを受け付けます。

   <variablelist>
    <varlistentry>
     <term>
      proto_version
     </term>
     <listitem>
      <para>
<!--
       Protocol version. Currently only version <literal>1</literal> is
       supported.
-->
プロトコルのバージョンです。
現在はバージョン<literal>1</literal>のみが受け付けられます。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>
      publication_names
     </term>
     <listitem>
      <para>
<!--
       Comma separated list of publication names for which to subscribe
       (receive changes). The individual publication names are treated
       as standard objects names and can be quoted the same as needed.
-->
サブスクライブする（変更を受け取る）対象となるパブリケーション名をカンマで区切ったリストです。
個々のパブリケーション名は標準的なオブジェクト名と扱われ、必要に応じて引用符で括ることができます。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>

  </para>
 </sect2>

 <sect2 id="protocol-logical-messages">
<!--
  <title>Logical Replication Protocol Messages</title>
-->
  <title>論理レプリケーションのプロトコルのメッセージ</title>

  <para>
<!--
   The individual protocol messages are discussed in the following
   subsections. Individual messages are described in
   <xref linkend="protocol-logicalrep-message-formats"/>.
-->
個々のプロトコルのメッセージについては以降の副節で説明します。
個々のメッセージについては<xref linkend="protocol-logicalrep-message-formats"/>で説明されています。
  </para>

  <para>
<!--
   All top-level protocol messages begin with a message type byte.
   While represented in code as a character, this is a signed byte with no
   associated encoding.
-->
トップレベルのプロトコルのメッセージはすべてメッセージタイプのバイトで始まります。
コード内では文字として表現されますが、これは文字符号化のないバイト（符号付き）です。
  </para>

  <para>
<!--
   Since the streaming replication protocol supplies a message length there
   is no need for top-level protocol messages to embed a length in their
   header.
-->
ストリーミングレプリケーションのプロトコルはメッセージ長を含むため、トップレベルのプロトコルのメッセージはそのヘッダに長さを埋め込む必要がありません。
  </para>

 </sect2>

 <sect2 id="protocol-logical-messages-flow">
<!--
  <title>Logical Replication Protocol Message Flow</title>
-->
  <title>論理レプリケーションのプロトコルのメッセージフロー</title>

  <para>
<!--
   With the exception of the <literal>START_REPLICATION</literal> command and
   the replay progress messages, all information flows only from the backend
   to the frontend.
-->
<literal>START_REPLICATION</literal>コマンドと再生進捗のメッセージを除き、すべての情報はバックエンド側からフロントエンド側にのみ流れます。
  </para>

  <para>
<!--
   The logical replication protocol sends individual transactions one by one.
   This means that all messages between a pair of Begin and Commit messages
   belong to the same transaction.
-->
論理レプリケーションのプロトコルは、個々のトランザクションを一つずつ送信します。
これはつまり、BeginとCommitのメッセージの対の間にある全てのメッセージは同じトランザクションに属するということです。
  </para>

  <para>
<!--
   Every sent transaction contains zero or more DML messages (Insert,
   Update, Delete). In case of a cascaded setup it can also contain Origin
   messages. The origin message indicates that the transaction originated on
   different replication node. Since a replication node in the scope of logical
   replication protocol can be pretty much anything, the only identifier
   is the origin name. It's downstream's responsibility to handle this as
   needed (if needed). The Origin message is always sent before any DML
   messages in the transaction.
-->
送信されるすべてのトランザクションにはゼロ個以上のDMLメッセージ（Insert、Update、Delete）が含まれます。
カスケードの設定がされている場合は、Originメッセージを含めることができます。
Originメッセージはトランザクションの起点が別のレプリケーションノードであることを示します。
<!--
訳注：原文が文法的におかしく、構文解析不能でした。
   "indicated"は"indicates"、"originated"は"originates"であるとして、
   また、 different"の前に"a"があるものとして訳しました。
-->
論理レプリケーションのプロトコルという観点では、レプリケーションノードはほぼ何でも良いため、唯一の識別子はOriginの名前です。
（必要なら）必要に応じてこれを処理するのは下流側の責任です。
Originメッセージは必ずトランザクション内のどのDMLよりも前に送信されます。
  </para>

  <para>
<!--
   Every DML message contains an arbitrary relation ID, which can be mapped to
   an ID in the Relation messages. The Relation messages describe the schema of the
   given relation. The Relation message is sent for a given relation either
   because it is the first time we send a DML message for given relation in the
   current session or because the relation definition has changed since the
   last Relation message was sent for it. The protocol assumes that the client
   is capable of caching the metadata for as many relations as needed.
-->
すべてのDMLメッセージは任意のリレーションIDを含んでおり、これをRelationメッセージ内のIDと関連付けることができます。
Relationメッセージはあるリレーションのスキーマを記述します。
あるリレーションについてのRelationメッセージは、現在のセッションでそのリレーションについて初めてDMLメッセージを送信する場合、あるいはRelationメッセージが最後に送信された後でリレーションの定義が変更された場合に送信されます。
このプロトコルは、クライアントが必要なだけ多くのリレーションについて、メタデータをキャッシュできることを前提としています。
  </para>
 </sect2>
</sect1>

<sect1 id="protocol-message-types">
<!--
<title>Message Data Types</title>
-->
<title>メッセージのデータ型</title>

<para>
<!--
This section describes the base data types used in messages.
-->
本節ではメッセージの中で使われる基本的なデータ型を説明します。

<variablelist>

<varlistentry>
<term>
        Int<replaceable>n</replaceable>(<replaceable>i</replaceable>)
</term>
<listitem>
<para>
<!--
                An <replaceable>n</replaceable>-bit integer in network byte
                order (most significant byte first).
                If <replaceable>i</replaceable> is specified it
                is the exact value that will appear, otherwise the value
                is variable.  Eg. Int16, Int32(42).
-->
ネットワークバイト順（最上位バイトが先頭）における<replaceable>n</replaceable>ビットの整数。
もし<replaceable>i</replaceable>が指定されていれば、それがそのまま使われます。
さもなければ変数です。
例えばInt16、Int32(42)などです。
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
        Int<replaceable>n</replaceable>[<replaceable>k</replaceable>]
</term>
<listitem>
<para>
<!--
                An array of <replaceable>k</replaceable>
                <replaceable>n</replaceable>-bit integers, each in network
                byte order.  The array length <replaceable>k</replaceable>
                is always determined by an earlier field in the message.
                Eg. Int16[M].
-->
<replaceable>n</replaceable>ビット整数の要素数<replaceable>k</replaceable>の配列で、それぞれはネットワークバイト順です。
配列サイズ<replaceable>k</replaceable>は常にメッセージの前のフィールドで決定されます。
例えばInt16[M]です。
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
        String(<replaceable>s</replaceable>)
</term>
<listitem>
<para>
<!--
                A null-terminated string (C-style string).  There is no
                specific length limitation on strings.
                If <replaceable>s</replaceable> is specified it is the exact
                value that will appear, otherwise the value is variable.
                Eg. String, String("user").
-->
NULL終端文字列（C様式文字列）。文字列には長さ制限の指定はありません。
<replaceable>s</replaceable>が指定されていれば、それがそのまま使われます。
さもなければ値は変数です。
例えばString、String("user")などです。
</para>

<note>
<para>
<!--
<emphasis>There is no predefined limit</emphasis> on the length of a string
that can be returned by the backend.  Good coding strategy for a frontend
is to use an expandable buffer so that anything that fits in memory can be
accepted.  If that's not feasible, read the full string and discard trailing
characters that don't fit into your fixed-size buffer.
-->
バックエンドから返すことができる文字列の長さには<emphasis>事前に定義された制限はありません</emphasis>。
フロントエンドではメモリに収まるものはすべて受け入れられるように拡張可能なバッファを使用するコーディング戦略を勧めます。
これが実行できないのであれば、文字列全体を読み取り、固定長バッファに合わない後の方の文字を破棄してください。
</para>
</note>
</listitem>
</varlistentry>

<varlistentry>
<term>
        Byte<replaceable>n</replaceable>(<replaceable>c</replaceable>)
</term>
<listitem>
<para>
<!--
                Exactly <replaceable>n</replaceable> bytes.  If the field
                width <replaceable>n</replaceable> is not a constant, it is
                always determinable from an earlier field in the message.
                If <replaceable>c</replaceable> is specified it is the exact
                value.  Eg. Byte2, Byte1('\n').
-->
厳密に<replaceable>n</replaceable>バイト。
フィールド幅<replaceable>n</replaceable>が定数でない場合、メッセージの前のフィールドから決定されます。
<replaceable>c</replaceable>が指定されていれば、それがそのまま使われます。
例えば Byte2、Byte1('\n')などです。
</para>
</listitem>
</varlistentry>

</variablelist>
</para>
</sect1>

<sect1 id="protocol-message-formats">
<!--
<title>Message Formats</title>
-->
<title>メッセージの書式</title>

<para>
<!--
This section describes the detailed format of each message.  Each is marked to
indicate that it can be sent by a frontend (F), a backend (B), or both
(F &amp; B).
Notice that although each message includes a byte count at the beginning,
the message format is defined so that the message end can be found without
reference to the byte count.  This aids validity checking.  (The CopyData
message is an exception, because it forms part of a data stream; the contents
of any individual CopyData message cannot be interpretable on their own.)
-->
本節ではそれぞれのメッセージの詳細書式について説明します。
それぞれにはフロントエンド（F）、バックエンド（B）あるいは双方（F &amp; B）から送出されることを示す印が付いています。
各メッセージには先頭にバイト数を持っていますが、バイト数を参照しなくてもメッセージの終わりを検知できるようにメッセージ書式は定義されています。
これは有効性検査を補助します。
（CopyDataメッセージはデータストリームの一部を形成しますので例外です。
個々のCopyDataメッセージの内容は自身でも解釈することができません。）
</para>

<variablelist>


<varlistentry>
<term>
AuthenticationOk (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('R')
</term>
<listitem>
<para>
<!--
                Identifies the message as an authentication request.
-->
認証要求としてメッセージを識別します。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(8)
</term>
<listitem>
<para>
<!--
                Length of message contents in bytes, including self.
-->
自身を含む、メッセージ内容の長さ（バイト単位）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(0)
</term>
<listitem>
<para>
<!--
                Specifies that the authentication was successful.
-->
認証が成功したことを指定します。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
AuthenticationKerberosV5 (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('R')
</term>
<listitem>
<para>
<!--
                Identifies the message as an authentication request.
-->
メッセージを認証要求として識別します。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(8)
</term>
<listitem>
<para>
<!--
                Length of message contents in bytes, including self.
-->
自身を含む、メッセージ内容の長さ（バイト単位）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(2)
</term>
<listitem>
<para>
<!--
                Specifies that Kerberos V5 authentication is required.
-->
Kerberos V5認証が必要であることを指定します。
</para>
</listitem>
</varlistentry>
</variablelist>
</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
AuthenticationCleartextPassword (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('R')
</term>
<listitem>
<para>
<!--
                Identifies the message as an authentication request.
-->
メッセージを認証要求として識別します。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(8)
</term>
<listitem>
<para>
<!--
                Length of message contents in bytes, including self.
-->
自身を含む、メッセージ内容の長さ（バイト単位）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(3)
</term>
<listitem>
<para>
<!--
                Specifies that a clear-text password is required.
-->
平文パスワードが必要であることを指定します。
</para>
</listitem>
</varlistentry>
</variablelist>
</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
AuthenticationMD5Password (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('R')
</term>
<listitem>
<para>
<!--
                Identifies the message as an authentication request.
-->
メッセージが認証要求であることを識別します。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(12)
</term>
<listitem>
<para>
<!--
                Length of message contents in bytes, including self.
-->
自身を含む、メッセージ内容の長さ（バイト単位）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(5)
</term>
<listitem>
<para>
<!--
                Specifies that an MD5-encrypted password is required.
-->
MD5暗号化パスワードが必要であることを指定します。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Byte4
</term>
<listitem>
<para>
<!--
                The salt to use when encrypting the password.
-->
パスワード暗号化用ソルトです。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
AuthenticationSCMCredential (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('R')
</term>
<listitem>
<para>
<!--
                Identifies the message as an authentication request.
-->
メッセージが認証要求であることを識別します。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(8)
</term>
<listitem>
<para>
<!--
                Length of message contents in bytes, including self.
-->
自身を含む、メッセージ内容の長さ（バイト単位）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(6)
</term>
<listitem>
<para>
<!--
                Specifies that an SCM credentials message is required.
-->
SCM資格証明メッセージが必要であることを指定します。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
AuthenticationGSS (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('R')
</term>
<listitem>
<para>
<!--
                Identifies the message as an authentication request.
-->
メッセージが認証要求であることを識別します。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(8)
</term>
<listitem>
<para>
<!--
                Length of message contents in bytes, including self.
-->
自身を含む、メッセージ内容の長さ（バイト単位）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(7)
</term>
<listitem>
<para>
<!--
                Specifies that GSSAPI authentication is required.
-->
GSSAPI認証証明メッセージが必要であることを指定します。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
AuthenticationSSPI (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('R')
</term>
<listitem>
<para>
<!--
                Identifies the message as an authentication request.
-->
メッセージが認証要求であることを識別します。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(8)
</term>
<listitem>
<para>
<!--
                Length of message contents in bytes, including self.
-->
自身を含む、メッセージ内容の長さ（バイト単位）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(9)
</term>
<listitem>
<para>
<!--
                Specifies that SSPI authentication is required.
-->
SSPI認証証明メッセージが必要であることを指定します。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
AuthenticationGSSContinue (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('R')
</term>
<listitem>
<para>
<!--
                Identifies the message as an authentication request.
-->
メッセージが認証要求であることを識別します。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
<!--
                Length of message contents in bytes, including self.
-->
自身を含む、メッセージ内容の長さ（バイト単位）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(8)
</term>
<listitem>
<para>
<!--
                Specifies that this message contains GSSAPI or SSPI data.
-->
このメッセージがGSSAPIまたはSSPIデータを含むことを指定します。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Byte<replaceable>n</replaceable>
</term>
<listitem>
<para>
<!--
                GSSAPI or SSPI authentication data.
-->
GSSAPIまたはSSPI認証データです。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
AuthenticationSASL (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('R')
</term>
<listitem>
<para>
<!--
                Identifies the message as an authentication request.
-->
メッセージが認証要求であることを識別します。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
<!--
                Length of message contents in bytes, including self.
-->
自身を含む、メッセージ内容の長さ（バイト単位）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(10)
</term>
<listitem>
<para>
<!--
                Specifies that SASL authentication is required.
-->
SASL認証が必要であることを指定します。
</para>
</listitem>
</varlistentry>
</variablelist>
<!--
The message body is a list of SASL authentication mechanisms, in the
server's order of preference. A zero byte is required as terminator after
the last authentication mechanism name. For each mechanism, there is the
following:
-->
メッセージ本体はSASL認証機構をサーバにとって望ましい順に並べたリストです。
最後の認証機構名の後に終端子としてゼロのバイトを置く必要があります。
各機構は以下のようになります。
<variablelist>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
<!--
                Name of a SASL authentication mechanism.
-->
SASL認証機構の名前です。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
AuthenticationSASLContinue (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('R')
</term>
<listitem>
<para>
<!--
                Identifies the message as an authentication request.
-->
このメッセージが認証要求であることを識別します。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
<!--
                Length of message contents in bytes, including self.
-->
自身を含む、メッセージ内容の長さ（バイト単位）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(11)
</term>
<listitem>
<para>
<!--
                Specifies that this message contains a SASL challenge.
-->
このメッセージがSASLのチャレンジを含むことを指定します。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Byte<replaceable>n</replaceable>
</term>
<listitem>
<para>
<!--
                SASL data, specific to the SASL mechanism being used.
-->
使用するSASL機構に固有のSASLデータです。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
AuthenticationSASLFinal (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('R')
</term>
<listitem>
<para>
<!--
                Identifies the message as an authentication request.
-->
このメッセージが認証要求であることを識別します。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
<!--
                Length of message contents in bytes, including self.
-->
自身を含む、メッセージ内容の長さ（バイト単位）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(12)
</term>
<listitem>
<para>
<!--
                Specifies that SASL authentication has completed.
-->
SASL認証が完了したことを指定します。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Byte<replaceable>n</replaceable>
</term>
<listitem>
<para>
<!--
                SASL outcome "additional data", specific to the SASL mechanism
                being used.
-->
SASLの結果の「追加データ」で、使用するSASL機構に固有のものです。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
BackendKeyData (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('K')
</term>
<listitem>
<para>
<!--
                Identifies the message as cancellation key data.
                The frontend must save these values if it wishes to be
                able to issue CancelRequest messages later.
-->
メッセージが取り消しのキーデータであることを識別します。
フロントエンドが後でCancelRequestメッセージを発行できるようにするためには、これらの値を保存しておかなければなりません。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(12)
</term>
<listitem>
<para>
<!--
                Length of message contents in bytes, including self.
-->
自身を含む、メッセージ内容の長さ（バイト単位）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
<!--
                The process ID of this backend.
-->
このバックエンドのプロセスIDです。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
<!--
                The secret key of this backend.
-->
このバックエンドの秘密鍵です。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
Bind (F)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('B')
</term>
<listitem>
<para>
<!--
                Identifies the message as a Bind command.
-->
このメッセージがBindコマンドであることを識別します。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
<!--
                Length of message contents in bytes, including self.
-->
自身を含む、メッセージ内容の長さ（バイト単位）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
<!--
                The name of the destination portal
                (an empty string selects the unnamed portal).
-->
宛先ポータルの名前（空文字列にすると無名ポータルを選択します）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
<!--
                The name of the source prepared statement
                (an empty string selects the unnamed prepared statement).
-->
入力元のプリペアド文の名前（空文字列にすると無名のプリペアド文を選択します）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16
</term>
<listitem>
<para>
<!--
                The number of parameter format codes that follow
                (denoted <replaceable>C</replaceable> below).
                This can be zero to indicate that there are no parameters
                or that the parameters all use the default format (text);
                or one, in which case the specified format code is applied
                to all parameters; or it can equal the actual number of
                parameters.
-->
その後に続くパラメータ書式コードの数（以下では<replaceable>C</replaceable>で表します）。
これは、パラメータがない、またはパラメータはすべてデフォルトの書式（テキスト）を使うことを示す0、あるいは指定の書式コードがすべてのパラメータに適用されることを示す1にすることができます。
そうでなければ、実際のパラメータの数と同じになります。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16[<replaceable>C</replaceable>]
</term>
<listitem>
<para>
<!--
                The parameter format codes.  Each must presently be
                zero (text) or one (binary).
-->
パラメータ書式コードです。
現在はそれぞれが0（テキスト）あるいは1（バイナリ）でなければなりません。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16
</term>
<listitem>
<para>
<!--
                The number of parameter values that follow (possibly zero).
                This must match the number of parameters needed by the query.
-->
後続するパラメータ値の数
（ゼロの場合もあります）。
これは問い合わせが必要とするパラメータ数と一致する必要があります。
</para>
</listitem>
</varlistentry>
</variablelist>
<!--
        Next, the following pair of fields appear for each parameter:
-->
次に、各パラメータに対して、以下のフィールドのペアが現れます。
<variablelist>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
<!--
                The length of the parameter value, in bytes (this count
                does not include itself).  Can be zero.
                As a special case, -1 indicates a NULL parameter value.
                No value bytes follow in the NULL case.
-->
パラメータ値のバイト単位の長さ（これには自身は含まれません）。
ゼロにすることもできます。
特別な場合として、-1はNULLというパラメータ値を示します。
NULLの場合、後続の値用のバイトはありません。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Byte<replaceable>n</replaceable>
</term>
<listitem>
<para>
<!--
                The value of the parameter, in the format indicated by the
                associated format code.
                <replaceable>n</replaceable> is the above length.
-->
関連する書式コードで示される書式におけるパラメータの値。
<replaceable>n</replaceable>は上述の長さです。
</para>
</listitem>
</varlistentry>
</variablelist>
<!--
        After the last parameter, the following fields appear:
-->
最後のパラメータの後に、以下のフィールドが現れます。
<variablelist>
<varlistentry>
<term>
        Int16
</term>
<listitem>
<para>
<!--
                The number of result-column format codes that follow
                (denoted <replaceable>R</replaceable> below).
                This can be zero to indicate that there are no result columns
                or that the result columns should all use the default format
                (text);
                or one, in which case the specified format code is applied
                to all result columns (if any); or it can equal the actual
                number of result columns of the query.
-->
後続する結果列書式コードの数
（以下では<replaceable>R</replaceable>で表します）。
これは、結果列が存在しないことを示す0、あるいはすべての結果列が（もしあれば）デフォルトの書式コード（テキスト）を使用することを示す1にすることができます。
さもなくば、問い合わせの結果列の実際の数と同じになります。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16[<replaceable>R</replaceable>]
</term>
<listitem>
<para>
<!--
                The result-column format codes.  Each must presently be
                zero (text) or one (binary).
-->
結果列の書式コード。
現在それぞれは0（テキスト）もしくは1（バイナリ）のいずれかでなければなりません。
</para>
</listitem>
</varlistentry>
</variablelist>
</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
BindComplete (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('2')
</term>
<listitem>
<para>
<!--
                Identifies the message as a Bind-complete indicator.
-->
メッセージがBind完了指示子であることを識別します。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(4)
</term>
<listitem>
<para>
<!--
                Length of message contents in bytes, including self.
-->
自身を含む、メッセージ内容の長さ（バイト単位）。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
CancelRequest (F)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Int32(16)
</term>
<listitem>
<para>
<!--
                Length of message contents in bytes, including self.
-->
自身を含む、メッセージ内容の長さ（バイト単位）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(80877102)
</term>
<listitem>
<para>
<!--
                The cancel request code.  The value is chosen to contain
                <literal>1234</literal> in the most significant 16 bits, and <literal>5678</literal> in the
                least significant 16 bits.  (To avoid confusion, this code
                must not be the same as any protocol version number.)
-->
取消要求コードです。
この値は、最上位16ビットに<literal>1234</literal>が、下位16ビットに<literal>5678</literal>を持つように選択されます。
（混乱を防ぐため、このコードはプロトコルバージョン番号と同一になってはいけません。）
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
<!--
                The process ID of the target backend.
-->
対象バックエンドのプロセスIDです。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
<!--
                The secret key for the target backend.
-->
対象バックエンドの秘密鍵です。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
Close (F)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('C')
</term>
<listitem>
<para>
<!--
                Identifies the message as a Close command.
-->
メッセージがCloseコマンドであることを識別します。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
<!--
                Length of message contents in bytes, including self.
-->
自身を含む、メッセージ内容の長さ（バイト単位）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Byte1
</term>
<listitem>
<para>
<!--
                '<literal>S</literal>' to close a prepared statement; or
                '<literal>P</literal>' to close a portal.
-->
プリペアド文を閉ざす時は'<literal>S</literal>'。
ポータルを閉ざす時は'<literal>P</literal>'です。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
<!--
                The name of the prepared statement or portal to close
                (an empty string selects the unnamed prepared statement
                or portal).
-->
閉ざすプリペアド文またはポータルの名前です
（空文字列で無名のプリペアド文または無名ポータルを選択します）。
</para>
</listitem>
</varlistentry>
</variablelist>
</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
CloseComplete (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('3')
</term>
<listitem>
<para>
<!--
                Identifies the message as a Close-complete indicator.
-->
メッセージがClose完了指示子であることを識別します。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(4)
</term>
<listitem>
<para>
<!--
                Length of message contents in bytes, including self.
-->
自身を含む、メッセージ内容の長さ（バイト単位）。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
CommandComplete (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('C')
</term>
<listitem>
<para>
<!--
                Identifies the message as a command-completed response.
-->
メッセージがコマンド完了応答であることを識別します。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
<!--
                Length of message contents in bytes, including self.
-->
自身を含む、メッセージ内容の長さ（バイト単位）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
       <para>
<!--
        The command tag.  This is usually a single
        word that identifies which SQL command was completed.
-->
コマンドタグです。
これは通常どのSQLコマンドが完了したかを表す単一の単語です。
       </para>

       <para>
<!--
        For an <command>INSERT</command> command, the tag is
        <literal>INSERT <replaceable>oid</replaceable>
        <replaceable>rows</replaceable></literal>, where
        <replaceable>rows</replaceable> is the number of rows
        inserted. <replaceable>oid</replaceable> used to be the object ID
        of the inserted row if <replaceable>rows</replaceable> was 1
        and the target table had OIDs, but OIDs system columns are
        not supported anymore; therefore <replaceable>oid</replaceable>
        is always 0.
-->
<command>INSERT</command>コマンドの場合、タグは<literal>INSERT <replaceable>oid</replaceable> <replaceable>rows</replaceable></literal>です。
ここで<replaceable>rows</replaceable>は挿入された行数です。
かつて<replaceable>oid</replaceable>は、<replaceable>rows</replaceable>が1、かつ、対象テーブルがOIDを持つ場合、挿入された行のオブジェクトIDでしたが、もはやOID列はサポートされていません。
ですから<replaceable>oid</replaceable>は常に0です。
       </para>

       <para>
<!--
        For a <command>DELETE</command> command, the tag is
        <literal>DELETE <replaceable>rows</replaceable></literal> where
        <replaceable>rows</replaceable> is the number of rows deleted.
-->
<command>DELETE</command>コマンドの場合、タグは<literal>DELETE <replaceable>rows</replaceable></literal>です。
ここで<replaceable>rows</replaceable>は削除された行数です。
       </para>

       <para>
<!--
        For an <command>UPDATE</command> command, the tag is
        <literal>UPDATE <replaceable>rows</replaceable></literal> where
        <replaceable>rows</replaceable> is the number of rows updated.
-->
<command>UPDATE</command>コマンドの場合、タグは<literal>UPDATE <replaceable>rows</replaceable></literal>です。
ここで<replaceable>rows</replaceable>は更新された行数です。
       </para>

       <para>
<!--
        For a <command>SELECT</command> or <command>CREATE TABLE AS</command>
        command, the tag is <literal>SELECT <replaceable>rows</replaceable></literal>
        where <replaceable>rows</replaceable> is the number of rows retrieved.
-->
<command>SELECT</command>または<command>CREATE TABLE AS</command>の場合、タグは<literal>SELECT <replaceable>rows</replaceable></literal>となります。
ここで<replaceable>rows</replaceable>は取り込んだ行数です。
       </para>

       <para>
<!--
        For a <command>MOVE</command> command, the tag is
        <literal>MOVE <replaceable>rows</replaceable></literal> where
        <replaceable>rows</replaceable> is the number of rows the
        cursor's position has been changed by.
-->
<command>MOVE</command>コマンドの場合、タグは<literal>MOVE <replaceable>rows</replaceable></literal>です。
ここで<replaceable>rows</replaceable>は、カーソル位置が何行変更されたかを示す数です。
       </para>

       <para>
<!--
        For a <command>FETCH</command> command, the tag is
        <literal>FETCH <replaceable>rows</replaceable></literal> where
        <replaceable>rows</replaceable> is the number of rows that
        have been retrieved from the cursor.
-->
<command>FETCH</command>コマンドの場合、タグは<literal>FETCH <replaceable>rows</replaceable></literal>です。
ここで<replaceable>rows</replaceable>は、カーソルから何行取り出したかを示す行数です。
       </para>

       <para>
<!--
        For a <command>COPY</command> command, the tag is
        <literal>COPY <replaceable>rows</replaceable></literal> where
        <replaceable>rows</replaceable> is the number of rows copied.
        (Note: the row count appears only in
        <productname>PostgreSQL</productname> 8.2 and later.)
-->
<command>COPY</command>コマンドの場合、タグは<literal>COPY <replaceable>rows</replaceable></literal>です。
ここで<replaceable>rows</replaceable>は、コピーされた行数です（注意：この行数は<productname>PostgreSQL</productname> 8.2以降でのみ出力されます）。
       </para>

</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
CopyData (F &amp; B)
</term>
<listitem>
<para>
<variablelist>
<varlistentry>
<term>
        Byte1('d')
</term>
<listitem>
<para>
<!--
                Identifies the message as <command>COPY</command> data.
-->
メッセージがデータの<command>COPY</command>であることを識別します。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
<!--
                Length of message contents in bytes, including self.
-->
自身を含む、メッセージ内容の長さ（バイト単位）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Byte<replaceable>n</replaceable>
</term>
<listitem>
<para>
<!--
                Data that forms part of a <command>COPY</command> data stream.  Messages sent
                from the backend will always correspond to single data rows,
                but messages sent by frontends might divide the data stream
                arbitrarily.
-->
<command>COPY</command>データストリームの一部を形成するデータです。
バックエンドから送信されるメッセージは、常に1つのデータ行に対応します。
しかし、フロントエンドから送信されるメッセージは任意のデータストリームに分割される可能性があります。
</para>
</listitem>
</varlistentry>
</variablelist>
</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
CopyDone (F &amp; B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('c')
</term>
<listitem>
<para>
<!--
                Identifies the message as a <command>COPY</command>-complete indicator.
-->
メッセージが<command>COPY</command>完了指示子であることを識別します。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(4)
</term>
<listitem>
<para>
<!--
                Length of message contents in bytes, including self.
-->
自身を含む、メッセージ内容の長さ（バイト単位）。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
CopyFail (F)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('f')
</term>
<listitem>
<para>
<!--
                Identifies the message as a <command>COPY</command>-failure indicator.
-->
メッセージが<command>COPY</command>失敗指示子であることを識別します。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
<!--
                Length of message contents in bytes, including self.
-->
自身を含む、メッセージ内容の長さ（バイト単位）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
<!--
                An error message to report as the cause of failure.
-->
失敗の原因を報告するエラーメッセージです。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
CopyInResponse (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('G')
</term>
<listitem>
<para>
<!--
                Identifies the message as a Start Copy In response.
                The frontend must now send copy-in data (if not
                prepared to do so, send a CopyFail message).
-->
メッセージがStart Copy Inの応答であることを識別します。
フロントエンドはここで必ずコピーインデータを送信しなければなりません
（まだ準備ができていない場合はCopyFailメッセージを送信してください）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
<!--
                Length of message contents in bytes, including self.
-->
自身を含む、メッセージ内容の長さ（バイト単位）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int8
</term>
<listitem>
<para>
<!--
                0 indicates the overall <command>COPY</command> format is textual (rows
                separated by newlines, columns separated by separator
                characters, etc).
                1 indicates the overall copy format is binary (similar
                to DataRow format).
                See <xref linkend="sql-copy"/>
                for more information.
-->
0は<command>COPY</command>全体の書式がテキスト（行は改行で区切られ、列は区切り文字などで区切られます）であることを示します。
1は、コピー全体の書式がバイナリ（DataRowの書式と同様）であることを示します。
より詳細については<xref linkend="sql-copy"/>を参照してください。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16
</term>
<listitem>
<para>
<!--
                The number of columns in the data to be copied
                (denoted <replaceable>N</replaceable> below).
-->
コピーされるデータ内の列数です
（以下では<replaceable>N</replaceable>と表されます）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16[<replaceable>N</replaceable>]
</term>
<listitem>
<para>
<!--
                The format codes to be used for each column.
                Each must presently be zero (text) or one (binary).
                All must be zero if the overall copy format is textual.
-->
各列で使用される書式コードです。
現在それぞれは0（テキスト）または1（バイナリ）でなければなりません。
コピー全体の書式がテキストの場合、すべてが0でなければなりません。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
CopyOutResponse (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('H')
</term>
<listitem>
<para>
<!--
                Identifies the message as a Start Copy Out response.
                This message will be followed by copy-out data.
-->
メッセージがStart Copy Outの応答であることを識別します。
このメッセージの後にコピーアウトデータが続きます。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
<!--
                Length of message contents in bytes, including self.
-->
自身を含む、メッセージ内容の長さ（バイト単位）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int8
</term>
<listitem>
<para>
<!--
                0 indicates the overall <command>COPY</command> format
                is textual (rows separated by newlines, columns
                separated by separator characters, etc). 1 indicates
                the overall copy format is binary (similar to DataRow
                format). See <xref linkend="sql-copy"/> for more information.
-->
0は<command>COPY</command>全体の書式がテキスト（行は改行で区切られ、列は区切り文字などで区切られます）であることを示します。
1はコピー全体の書式がバイナリ（DataRowの書式同様）であることを示します。
詳細については<xref linkend="sql-copy"/>を参照してください。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16
</term>
<listitem>
<para>
<!--
                The number of columns in the data to be copied
                (denoted <replaceable>N</replaceable> below).
-->
コピーされるデータ内の列数です
（以下では<replaceable>N</replaceable>と表されます）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16[<replaceable>N</replaceable>]
</term>
<listitem>
<para>
<!--
                The format codes to be used for each column.
                Each must presently be zero (text) or one (binary).
                All must be zero if the overall copy format is textual.
-->
各列で使用される書式コードです。
現在それぞれは0（テキスト）または1（バイナリ）でなければなりません。
コピー全体の書式がテキストの場合、すべてが0でなければなりません。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
CopyBothResponse (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('W')
</term>
<listitem>
<para>
<!--
                Identifies the message as a Start Copy Both response.
                This message is used only for Streaming Replication.
-->
メッセージがStart Copy Bothの応答であることを識別します。
このメッセージはストリーミングレプリケーションのみで使用されます。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
<!--
                Length of message contents in bytes, including self.
-->
自身を含む、メッセージ内容の長さ（バイト単位）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int8
</term>
<listitem>
<para>
<!--
                0 indicates the overall <command>COPY</command> format
                is textual (rows separated by newlines, columns
                separated by separator characters, etc). 1 indicates
                the overall copy format is binary (similar to DataRow
                format). See <xref linkend="sql-copy"/> for more information.
-->
0は<command>COPY</command>全体の書式がテキスト（行は改行で区切られ、列は区切り文字などで区切られます）であることを示します。
1はコピー全体の書式がバイナリ（DataRowの書式同様）であることを示します。
詳細については<xref linkend="sql-copy"/>を参照してください。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16
</term>
<listitem>
<para>
<!--
                The number of columns in the data to be copied
                (denoted <replaceable>N</replaceable> below).
-->
コピーされるデータ内の列数です
（以下では<replaceable>N</replaceable>と表されます）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16[<replaceable>N</replaceable>]
</term>
<listitem>
<para>
<!--
                The format codes to be used for each column.
                Each must presently be zero (text) or one (binary).
                All must be zero if the overall copy format is textual.
-->
各列で使用される書式コードです。
現在それぞれは0（テキスト）または1（バイナリ）でなければなりません。
コピー全体の書式がテキストの場合、すべてが0でなければなりません。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
DataRow (B)
</term>
<listitem>
<para>
<variablelist>
<varlistentry>
<term>
        Byte1('D')
</term>
<listitem>
<para>
<!--
                Identifies the message as a data row.
-->
メッセージがデータ行であることを識別します。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
<!--
                Length of message contents in bytes, including self.
-->
自身を含む、メッセージ内容の長さ（バイト単位）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16
</term>
<listitem>
<para>
<!--
                The number of column values that follow (possibly zero).
-->
後に続く列値の数です
（ゼロの場合もあります）。
</para>
</listitem>
</varlistentry>
</variablelist>
<!--
        Next, the following pair of fields appear for each column:
-->
次に、各列について以下のフィールドのペアが現れます。
<variablelist>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
<!--
                The length of the column value, in bytes (this count
                does not include itself).  Can be zero.
                As a special case, -1 indicates a NULL column value.
                No value bytes follow in the NULL case.
-->
列値のバイト単位の長さです
（これには自身は含まれません）。
ゼロとすることもできます。
特別な場合として、-1はNULLという列値を示します。
NULLの場合、後続の値用のバイトはありません。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Byte<replaceable>n</replaceable>
</term>
<listitem>
<para>
<!--
                The value of the column, in the format indicated by the
                associated format code.
                <replaceable>n</replaceable> is the above length.
-->
関連する書式コードで示される書式における列の値。
<replaceable>n</replaceable>は上述の長さです。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
Describe (F)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('D')
</term>
<listitem>
<para>
<!--
                Identifies the message as a Describe command.
-->
メッセージがDescribeコマンドであることを識別します。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
<!--
                Length of message contents in bytes, including self.
-->
自身を含む、メッセージ内容の長さ（バイト単位）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Byte1
</term>
<listitem>
<para>
<!--
                '<literal>S</literal>' to describe a prepared statement; or
                '<literal>P</literal>' to describe a portal.
-->
プリペアド文の記述の場合は'<literal>S</literal>'。
ポータルの記述の場合は'<literal>P</literal>'です。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
<!--
                The name of the prepared statement or portal to describe
                (an empty string selects the unnamed prepared statement
                or portal).
-->
記述を求めるプリペアド文またはポータルの名前です
（空文字列で無名のプリペアド文または無名ポータルを選択します）。
</para>
</listitem>
</varlistentry>
</variablelist>
</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
EmptyQueryResponse (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('I')
</term>
<listitem>
<para>
<!--
                Identifies the message as a response to an empty query string.
                (This substitutes for CommandComplete.)
-->
メッセージが空の問い合わせ文字列に対する応答であることを識別します
（これはCommandCompleteを置き換えます）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(4)
</term>
<listitem>
<para>
<!--
                Length of message contents in bytes, including self.
-->
自身を含む、メッセージ内容の長さ（バイト単位）。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
ErrorResponse (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('E')
</term>
<listitem>
<para>
<!--
                Identifies the message as an error.
-->
メッセージがエラーであることを識別します。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
<!--
                Length of message contents in bytes, including self.
-->
自身を含む、メッセージ内容の長さ（バイト単位）。
</para>
</listitem>
</varlistentry>
</variablelist>
<!--
        The message body consists of one or more identified fields,
        followed by a zero byte as a terminator.  Fields can appear in
        any order.  For each field there is the following:
-->
このメッセージの本体には、ゼロバイトを終端として後続する、1つ以上の識別されるフィールドが含まれます。
フィールドは任意の順番で現れる可能性があります。
各フィールドには以下があります。
<variablelist>
<varlistentry>
<term>
        Byte1
</term>
<listitem>
<para>
<!--
                A code identifying the field type; if zero, this is
                the message terminator and no string follows.
                The presently defined field types are listed in
                <xref linkend="protocol-error-fields"/>.
                Since more field types might be added in future,
                frontends should silently ignore fields of unrecognized
                type.
-->
フィールド種類を識別するコードです。
ゼロならば、メッセージの終端であり、後続する文字列がないことを表します。
<xref linkend="protocol-error-fields"/>に、現時点でフィールド種類として定義されているものを列挙します。
将来もっと多くのフィールド種類が追加される可能性がありますので、フロントエンドは、認知できない種類のフィールドに対して何もせずに無視すべきです。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
<!--
                The field value.
-->
フィールド値です。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
Execute (F)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('E')
</term>
<listitem>
<para>
<!--
                Identifies the message as an Execute command.
-->
メッセージがExecuteコマンドであることを識別します。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
<!--
                Length of message contents in bytes, including self.
-->
自身を含む、メッセージ内容の長さ（バイト単位）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
<!--
                The name of the portal to execute
                (an empty string selects the unnamed portal).
-->
実行するポータルの名前です。
（空文字列で無名ポータルを選択します）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
<!--
                Maximum number of rows to return, if portal contains
                a query that returns rows (ignored otherwise).  Zero
                denotes <quote>no limit</quote>.
-->
ポータルが行を返す問い合わせの場合、返される行数の最大値です
（他の問い合わせでは無視されます）。
ゼロは<quote>無制限</quote>を表します。
</para>
</listitem>
</varlistentry>
</variablelist>
</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
Flush (F)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('H')
</term>
<listitem>
<para>
<!--
                Identifies the message as a Flush command.
-->
メッセージがFlushコマンドであることを識別します。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(4)
</term>
<listitem>
<para>
<!--
                Length of message contents in bytes, including self.
-->
自身を含む、メッセージ内容の長さ（バイト単位）。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
FunctionCall (F)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('F')
</term>
<listitem>
<para>
<!--
                Identifies the message as a function call.
-->
メッセージが関数呼び出しであることを識別します。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
<!--
                Length of message contents in bytes, including self.
-->
自身を含む、メッセージ内容の長さ（バイト単位）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
<!--
                Specifies the object ID of the function to call.
-->
呼び出す関数のオブジェクトIDを指定します。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16
</term>
<listitem>
<para>
<!--
                The number of argument format codes that follow
                (denoted <replaceable>C</replaceable> below).
                This can be zero to indicate that there are no arguments
                or that the arguments all use the default format (text);
                or one, in which case the specified format code is applied
                to all arguments; or it can equal the actual number of
                arguments.
-->
後述する引数書式コード数です
（以下では<replaceable>C</replaceable>と表します）。
これは、引数が存在しない、あるいは、すべての引数がデフォルトの書式（テキスト）を使用することを示す0に、指定する書式コードをすべての引数に適用することを示す1にすることができます。
さもなくば、これは実際の引数の数と同じになります。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16[<replaceable>C</replaceable>]
</term>
<listitem>
<para>
<!--
                The argument format codes.  Each must presently be
                zero (text) or one (binary).
-->
引数の書式コードです。
それぞれは、0（テキスト）もしくは1（バイナリ）でなければなりません。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16
</term>
<listitem>
<para>
<!--
                Specifies the number of arguments being supplied to the
                function.
-->
関数に提供する引数の数を指定します。
</para>
</listitem>
</varlistentry>
</variablelist>
<!--
        Next, the following pair of fields appear for each argument:
-->
次に、各引数に対して以下のフィールドのペアが現れます。
<variablelist>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
<!--
                The length of the argument value, in bytes (this count
                does not include itself).  Can be zero.
                As a special case, -1 indicates a NULL argument value.
                No value bytes follow in the NULL case.
-->
引数の値のバイト単位の長さです
（これには自身は含まれません）。
0とすることもできます。
特別な場合として、-1はNULLという引数の値を示します。
NULLの場合、後続の値用のバイトはありません。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Byte<replaceable>n</replaceable>
</term>
<listitem>
<para>
<!--
                The value of the argument, in the format indicated by the
                associated format code.
                <replaceable>n</replaceable> is the above length.
-->
関連する書式コードで示される書式における引数の値。
<replaceable>n</replaceable>は上述の長さです。
</para>
</listitem>
</varlistentry>
</variablelist>
 <!--
        After the last argument, the following field appears:
-->
最後の引数の後に、以下のフィールドが現れます。
<variablelist>
<varlistentry>
<term>
        Int16
</term>
<listitem>
<para>
<!--
                The format code for the function result. Must presently be
                zero (text) or one (binary).
-->
関数結果用の書式コードです。
現在、0（テキスト）または1（バイナリ）でなければなりません。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
FunctionCallResponse (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('V')
</term>
<listitem>
<para>
<!--
                Identifies the message as a function call result.
-->
メッセージが関数呼び出しの結果であることを識別します。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
<!--
                Length of message contents in bytes, including self.
-->
自身を含む、メッセージ内容の長さ（バイト単位）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
<!--
                The length of the function result value, in bytes (this count
                does not include itself).  Can be zero.
                As a special case, -1 indicates a NULL function result.
                No value bytes follow in the NULL case.
-->
関数の結果の値のバイト単位の長さです
（これには自身は含まれません）。
ゼロとすることもできます。
特別な場合として、-1はNULLという関数の結果の値を示します。
NULLの場合、後続の値用のバイトはありません。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Byte<replaceable>n</replaceable>
</term>
<listitem>
<para>
<!--
                The value of the function result, in the format indicated by
                the associated format code.
                <replaceable>n</replaceable> is the above length.
-->
関連する書式コードで示される書式における関数の結果の値。
<replaceable>n</replaceable>は上述の長さです。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
GSSResponse (F)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('p')
</term>
<listitem>
<para>
<!--
                Identifies the message as a GSSAPI or SSPI response. Note that
                this is also used for SASL and password response messages.
                The exact message type can be deduced from the context.
-->
このメッセージがGSSAPIまたはSSPI応答であることを識別します。
これはSASLおよびパスワードの応答メッセージにも使用されることに注意してください。
厳密なメッセージ種別は、その状況から推論できます。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
<!--
                Length of message contents in bytes, including self.
-->
自身を含む、メッセージ内容の長さ（バイト単位）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Byte<replaceable>n</replaceable>
</term>
<listitem>
<para>
<!--
                GSSAPI/SSPI specific message data.
-->
GSSAPI/SSPIに固有のメッセージデータ。
</para>
</listitem>
</varlistentry>
</variablelist>
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
NegotiateProtocolVersion (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('v')
</term>
<listitem>
<para>
<!--
                Identifies the message as a protocol version negotiation
                message.
-->
メッセージが、プロトコルバージョン交渉メッセージであることを識別します。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
<!--
                Length of message contents in bytes, including self.
-->
自身を含む、メッセージ内容の長さ（バイト単位）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
<!--
                Newest minor protocol version supported by the server
                for the major protocol version requested by the client.
-->
クライアントが要求したメジャープロトコルバージョンに対し、サーバがサポートする最新のマイナープロトコルバージョン。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
<!--
                Number of protocol options not recognized by the server.
-->
サーバが認識しなかったプロトコルオプションの数。
</para>
</listitem>
</varlistentry>
</variablelist>
<!--
        Then, for protocol option not recognized by the server, there
        is the following:
-->
続いて、サーバが認識しなかったプロトコルオプションに対して以下が続きます。
<variablelist>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
<!--
                The option name.
-->
オプション名。
</para>
</listitem>
</varlistentry>
</variablelist>
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
NoData (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('n')
</term>
<listitem>
<para>
<!--
                Identifies the message as a no-data indicator.
-->
メッセージがデータなしの指示子であることを識別します。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(4)
</term>
<listitem>
<para>
<!--
                Length of message contents in bytes, including self.
-->
自身を含む、メッセージ内容の長さ（バイト単位）。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
NoticeResponse (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('N')
</term>
<listitem>
<para>
<!--
                Identifies the message as a notice.
-->
メッセージが警報であることを識別します。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
<!--
                Length of message contents in bytes, including self.
-->
自身を含む、メッセージ内容の長さ（バイト単位）。
</para>
</listitem>
</varlistentry>
</variablelist>
<!--
        The message body consists of one or more identified fields,
        followed by a zero byte as a terminator.  Fields can appear in
        any order.  For each field there is the following:
-->
このメッセージの本体には、ゼロバイトを終端として後続する、1つ以上の識別されるフィールドが含まれます。
フィールドは任意の順番で現れる可能性があります。
各フィールドには以下があります。
<variablelist>
<varlistentry>
<term>
        Byte1
</term>
<listitem>
<para>
<!--
                A code identifying the field type; if zero, this is
                the message terminator and no string follows.
                The presently defined field types are listed in
                <xref linkend="protocol-error-fields"/>.
                Since more field types might be added in future,
                frontends should silently ignore fields of unrecognized
                type.
-->
フィールド種類を識別するコードです。
ゼロならば、メッセージの終端であり、後続する文字列がないことを表します。
<xref linkend="protocol-error-fields"/>に、現時点でフィールド種類として定義されているものを列挙します。
将来もっと多くのフィールド種類が追加される可能性がありますので、フロントエンドは、認知できない種類のフィールドに対して何もせずに無視すべきです。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
<!--
                The field value.
-->
フィールドの値です。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
NotificationResponse (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('A')
</term>
<listitem>
<para>
<!--
                Identifies the message as a notification response.
-->
メッセージが通知応答であることを識別します。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
<!--
                Length of message contents in bytes, including self.
-->
自身を含む、メッセージ内容の長さ（バイト単位）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
<!--
                The process ID of the notifying backend process.
-->
通知元バックエンドのプロセスIDです。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
<!--
                The name of the channel that the notify has been raised on.
-->
通知の発生元となったチャネル名です。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
<!--
                The <quote>payload</quote> string passed from the notifying process.
-->
通知プロセスから渡される<quote>ペイロード</quote>文字列です。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
ParameterDescription (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('t')
</term>
<listitem>
<para>
<!--
                Identifies the message as a parameter description.
-->
メッセージがパラメータ記述であることを識別します。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
<!--
                Length of message contents in bytes, including self.
-->
自身を含む、メッセージ内容の長さ（バイト単位）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16
</term>
<listitem>
<para>
<!--
                The number of parameters used by the statement
                (can be zero).
-->
文で使用されるパラメータ数です
（ゼロとすることができます）。
</para>
</listitem>
</varlistentry>
</variablelist>
<!--
        Then, for each parameter, there is the following:
-->
そして、各パラメータに対して、以下が続きます。
<variablelist>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
<!--
                Specifies the object ID of the parameter data type.
-->
パラメータのデータ型のオブジェクトIDを指定します。
</para>
</listitem>
</varlistentry>
</variablelist>
</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
ParameterStatus (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('S')
</term>
<listitem>
<para>
<!--
                Identifies the message as a run-time parameter status report.
-->
メッセージが実行時パラメータ状態報告であることを識別します。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
<!--
                Length of message contents in bytes, including self.
-->
自身を含む、メッセージ内容の長さ（バイト単位）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
<!--
                The name of the run-time parameter being reported.
-->
報告される実行時パラメータの名前です。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
<!--
                The current value of the parameter.
-->
そのパラメータの現在値です。
</para>
</listitem>
</varlistentry>
</variablelist>
</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
Parse (F)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('P')
</term>
<listitem>
<para>
<!--
                Identifies the message as a Parse command.
-->
メッセージがParseコマンドであることを識別します。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
<!--
                Length of message contents in bytes, including self.
-->
自身を含む、メッセージ内容の長さ（バイト単位）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
<!--
                The name of the destination prepared statement
                (an empty string selects the unnamed prepared statement).
-->
宛先のプリペアド文の名前です
（空文字列で無名のプリペアド文を選択します）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
<!--
                The query string to be parsed.
-->
解析される問い合わせ文字列です。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16
</term>
<listitem>
<para>
<!--
                The number of parameter data types specified
                (can be zero).  Note that this is not an indication of
                the number of parameters that might appear in the
                query string, only the number that the frontend wants to
                prespecify types for.
-->
指定されるパラメータデータ型の数です
（ゼロとすることができます）。
これは、問い合わせ文字列内にあるパラメータの数を示すものではないことに注意してください。
フロントエンドが型指定を希望するパラメータの数でしかありません。
</para>
</listitem>
</varlistentry>
</variablelist>
<!--
        Then, for each parameter, there is the following:
-->
その後、各パラメータに対し、以下が続きます。
<variablelist>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
<!--
                Specifies the object ID of the parameter data type.
                Placing a zero here is equivalent to leaving the type
                unspecified.
-->
パラメータのデータ型のオブジェクトIDを指定します。
ここにゼロを書くことは型指定を行わないことと同じです。
</para>
</listitem>
</varlistentry>
</variablelist>
</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
ParseComplete (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('1')
</term>
<listitem>
<para>
<!--
                Identifies the message as a Parse-complete indicator.
-->
メッセージがParse完了指示子であることを識別します。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(4)
</term>
<listitem>
<para>
<!--
                Length of message contents in bytes, including self.
-->
自身を含む、メッセージ内容の長さ（バイト単位）。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
PasswordMessage (F)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('p')
</term>
<listitem>
<para>
<!--
                Identifies the message as a password response. Note that
                this is also used for GSSAPI, SSPI and SASL response messages.
                The exact message type can be deduced from the context.
-->
メッセージがパスワード応答であることを識別します。
これがGSSAPI、SSPIまたはSASL応答メッセージでも使用されることに注意してください。
厳密なメッセージ種別は、その状況から推論できます。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
<!--
                Length of message contents in bytes, including self.
-->
自身を含む、メッセージ内容の長さ（バイト単位）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
<!--
                The password (encrypted, if requested).
-->
パスワードです
（必要ならば暗号化されています）。
</para>
</listitem>
</varlistentry>
</variablelist>
</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
PortalSuspended (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('s')
</term>
<listitem>
<para>
<!--
                Identifies the message as a portal-suspended indicator.
                Note this only appears if an Execute message's row-count limit
                was reached.
-->
メッセージがポータル中断指示子であることを識別します。
これは、Executeメッセージの行数制限に達した場合にのみ現れることに注意してください。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(4)
</term>
<listitem>
<para>
<!--
                Length of message contents in bytes, including self.
-->
自身を含む、メッセージ内容の長さ（バイト単位）。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
Query (F)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('Q')
</term>
<listitem>
<para>
<!--
                Identifies the message as a simple query.
-->
メッセージが簡易問い合わせであることを識別します。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
<!--
                Length of message contents in bytes, including self.
-->
自身を含む、メッセージ内容の長さ（バイト単位）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
<!--
                The query string itself.
-->
問い合わせ文字列自体です。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
ReadyForQuery (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('Z')
</term>
<listitem>
<para>
<!--
                Identifies the message type.  ReadyForQuery is sent
                whenever the backend is ready for a new query cycle.
-->
このメッセージ種類を識別します。
バックエンドで新しい問い合わせサイクルの準備が整った時には常にReadyForQueryが送信されます。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(5)
</term>
<listitem>
<para>
<!--
                Length of message contents in bytes, including self.
-->
自身を含む、メッセージ内容の長さ（バイト単位）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Byte1
</term>
<listitem>
<para>
<!--
                Current backend transaction status indicator.
                Possible values are '<literal>I</literal>' if idle (not in
                a transaction block); '<literal>T</literal>' if in a transaction
                block; or '<literal>E</literal>' if in a failed transaction
                block (queries will be rejected until block is ended).
-->
現在のバックエンドのトランザクション状態指示子です。
取り得る値は、待機状態（トランザクションブロックにない状態）に'<literal>I</literal>'、トランザクションブロック内の場合に'<literal>T</literal>'、失敗したトランザクションブロック（ブロックが終わるまで問い合わせは拒絶されます）内の場合に'<literal>E</literal>'です。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
RowDescription (B)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('T')
</term>
<listitem>
<para>
<!--
                Identifies the message as a row description.
-->
メッセージが行の記述であることを識別します。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
<!--
                Length of message contents in bytes, including self.
-->
自身を含む、メッセージ内容の長さ（バイト単位）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16
</term>
<listitem>
<para>
<!--
                Specifies the number of fields in a row (can be zero).
-->
行内のフィールド数を指定します
（ゼロとすることができます）。
</para>
</listitem>
</varlistentry>
</variablelist>
<!--
        Then, for each field, there is the following:
-->
その後、各フィールドに対して以下が続きます。
<variablelist>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
<!--
                The field name.
-->
フィールド名です。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
<!--
                If the field can be identified as a column of a specific
                table, the object ID of the table; otherwise zero.
-->
フィールドが特定のテーブルの列として識別できる場合、テーブルのオブジェクトIDです。
さもなくばゼロです。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16
</term>
<listitem>
<para>
<!--
                If the field can be identified as a column of a specific
                table, the attribute number of the column; otherwise zero.
-->
フィールドが特定のテーブルの列として識別できる場合、列の属性番号です。
さもなくばゼロです。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
<!--
                The object ID of the field's data type.
-->
フィールドのデータ型のオブジェクトIDです。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16
</term>
<listitem>
<para>
<!--
                The data type size (see <varname>pg_type.typlen</varname>).
                Note that negative values denote variable-width types.
-->
データ型の大きさ（<varname>pg_type.typlen</varname>を参照）です。
負の値が可変長の型を表すことに注意してください。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
<!--
                The type modifier (see <varname>pg_attribute.atttypmod</varname>).
                The meaning of the modifier is type-specific.
-->
型修飾子（<varname>pg_attribute.atttypmod</varname>を参照）です。
修飾子の意味は型に固有です。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16
</term>
<listitem>
<para>
<!--
                The format code being used for the field.  Currently will
                be zero (text) or one (binary).  In a RowDescription
                returned from the statement variant of Describe, the
                format code is not yet known and will always be zero.
-->
フィールドに使用される書式コードです。
現在、0（テキスト）または1（バイナリ）のいずれかになります。
RowDescriptionがステートメント用のDescribeから返された場合、書式コードはまだ不明ですので、常に0になります。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
SASLInitialResponse (F)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('p')
</term>
<listitem>
<para>
<!--
                Identifies the message as an initial SASL response. Note that
                this is also used for GSSAPI, SSPI and password response messages.
                The exact message type is deduced from the context.
-->
メッセージが最初のSASL応答であることを識別します。
これがGSSAPI、SSPIまたはパスワード応答メッセージでも使用されることに注意してください。
厳密なメッセージ種別は、その状況から推論できます。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
<!--
                Length of message contents in bytes, including self.
-->
自身を含む、メッセージ内容の長さ（バイト単位）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
<!--
                Name of the SASL authentication mechanism that the client
                selected.
-->
クライアントが選択したSASL認証機構の名前。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
<!--
                Length of SASL mechanism specific "Initial Client Response" that
                follows, or -1 if there is no Initial Response.
-->
それに続くSASLの機構固有の「Initial Client Response（最初のクライアントの応答）」の長さ、またはInitial Responseがなければ-1。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Byte<replaceable>n</replaceable>
</term>
<listitem>
<para>
<!--
                SASL mechanism specific "Initial Response".
-->
SASLの機構固有の「Initial Response（最初の応答）」。
</para>
</listitem>
</varlistentry>
</variablelist>
</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
SASLResponse (F)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('p')
</term>
<listitem>
<para>
<!--
                Identifies the message as a SASL response. Note that
                this is also used for GSSAPI, SSPI and password response messages.
                The exact message type can be deduced from the context.
-->
メッセージがSASL応答であることを識別します。
これがGSSAPI、SSPIまたはパスワード応答メッセージでも使用されることに注意してください。
厳密なメッセージ種別は、その状況から推論できます。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
<!--
                Length of message contents in bytes, including self.
-->
自身を含む、メッセージ内容の長さ（バイト単位）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Byte<replaceable>n</replaceable>
</term>
<listitem>
<para>
<!--
                SASL mechanism specific message data.
-->
SASLの機構固有のメッセージデータ
</para>
</listitem>
</varlistentry>
</variablelist>
</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
SSLRequest (F)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Int32(8)
</term>
<listitem>
<para>
<!--
                Length of message contents in bytes, including self.
-->
自身を含む、メッセージ内容の長さ（バイト単位）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(80877103)
</term>
<listitem>
<para>
<!--
                The <acronym>SSL</acronym> request code.  The value is chosen to contain
                <literal>1234</literal> in the most significant 16 bits, and <literal>5679</literal> in the
                least significant 16 bits.  (To avoid confusion, this code
                must not be the same as any protocol version number.)
-->
<acronym>SSL</acronym>要求コードです。
この値は最上位の16ビットに<literal>1234</literal>が、最下位の16ビットに<literal>5679</literal>が含まれるように選択されます。
（混乱を防ぐため、このコードはどのプロトコルのバージョン番号とも同じになってはいけません。）
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
GSSENCRequest (F)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Int32(8)
</term>
<listitem>
<para>
<!--
                Length of message contents in bytes, including self.
-->
自身を含む、メッセージ内容の長さ（バイト単位）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(80877104)
</term>
<listitem>
<para>
<!--
                The <acronym>GSSAPI</acronym> Encryption request code.  The value is chosen to contain
                <literal>1234</literal> in the most significant 16 bits, and <literal>5680</literal> in the
                least significant 16 bits.  (To avoid confusion, this code
                must not be the same as any protocol version number.)
-->
<acronym>GSSAPI</acronym>暗号化要求コードです。
この値は最上位の16ビットに<literal>1234</literal>が、最下位の16ビットに<literal>5680</literal>が含まれるように選択されます。
（混乱を防ぐため、このコードはどのプロトコルのバージョン番号とも同じになってはいけません。）
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
StartupMessage (F)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
<!--
                Length of message contents in bytes, including self.
-->
自身を含む、メッセージ内容の長さ（バイト単位）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(196608)
</term>
<listitem>
<para>
<!--
                The protocol version number.  The most significant 16 bits are
                the major version number (3 for the protocol described here).
                The least significant 16 bits are the minor version number
                (0 for the protocol described here).
-->
プロトコルのバージョン番号です。
最上位の16ビットはメジャーバージョン番号（ここで説明しているプロトコルでは3）です。
最下位の16ビットはマイナーバージョン番号（ここで説明しているプロトコルでは0）です。
</para>
</listitem>
</varlistentry>
</variablelist>
<!--
        The protocol version number is followed by one or more pairs of
        parameter name and value strings.  A zero byte is required as a
        terminator after the last name/value pair.
        Parameters can appear in any
        order.  <literal>user</literal> is required, others are optional.
        Each parameter is specified as:
-->
プロトコルのバージョン番号の後には、パラメータ名と値文字列の対が1つ以上続きます。
最後の名前／値の対の後に終端子としてゼロのバイトが必要です。
パラメータは任意の順番に並べることができます。
<literal>user</literal>が必須、他はオプションです。
各パラメータは以下のように指定します。
<variablelist>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
<!--
                The parameter name.  Currently recognized names are:
-->
パラメータ名です。
現在認識される名前を以下に示します。

<variablelist>
<varlistentry>
<term>
                <literal>user</literal>
</term>
<listitem>
<para>
<!--
                        The database user name to connect as.  Required;
                        there is no default.
-->
接続するデータベースユーザ名です。
必須。
デフォルトはありません。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
                <literal>database</literal>
</term>
<listitem>
<para>
<!--
                        The database to connect to.  Defaults to the user name.
-->
接続するデータベースです。
デフォルトはユーザ名です。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
                <literal>options</literal>
</term>
<listitem>
<para>
<!--
                        Command-line arguments for the backend.  (This is
                        deprecated in favor of setting individual run-time
                        parameters.)  Spaces within this string are
                        considered to separate arguments, unless escaped with
                        a backslash (<literal>\</literal>); write <literal>\\</literal> to
                        represent a literal backslash.
-->
バックエンド用のコマンドライン引数です。
（これは廃棄予定であり、個々の実行時パラメータを設定する方が好ましいです。）
この文字列の中の空白は、バックスラッシュ(<literal>\</literal>)でエスケープされていなければ、引数を分けるためのものとみなされます。
バックスラッシュそのものを表すためには<literal>\\</literal>と書いてください。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
                <literal>replication</literal>
</term>
<listitem>
<para>
<!--
                        Used to connect in streaming replication mode, where
                        a small set of replication commands can be issued
                        instead of SQL statements. Value can be
                        <literal>true</literal>, <literal>false</literal>, or
                        <literal>database</literal>, and the default is
                        <literal>false</literal>. See
                        <xref linkend="protocol-replication"/> for details.
-->
ストリーミングレプリケーションモードで接続するのに使用され、SQL文の代わりにレプリケーションコマンドの小さな集合を発行することができます。
値は<literal>true</literal>、<literal>false</literal>または<literal>database</literal>をとることができ、デフォルトは<literal>false</literal>です。
詳細は<xref linkend="protocol-replication"/>を参照してください。
</para>
</listitem>
</varlistentry>
</variablelist>

<!--
                In addition to the above, other parameters may be listed.
                Parameter names beginning with <literal>_pq_.</literal> are
                reserved for use as protocol extensions, while others are
                treated as run-time parameters to be set at backend start
                time.  Such settings will be applied during backend start
                (after parsing the command-line arguments if any) and will
                act as session defaults.
-->
上記に加え、他のパラメータが列挙される可能性があります
<literal>_pq_.</literal>で始まるパラメータ名は、プロトコルの拡張用途のために予約されています。
それ以外は、バックエンド開始時に設定される実行時パラメータとして扱われます。
こうした設定は、バックエンド起動時に（もしあればコマンドライン引数の解析の後に）適用されます。
この値はセッションのデフォルトとして動作します。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
<!--
                The parameter value.
-->
パラメータの値です。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
Sync (F)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('S')
</term>
<listitem>
<para>
<!--
                Identifies the message as a Sync command.
-->
メッセージがSyncコマンドであることを識別します。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(4)
</term>
<listitem>
<para>
<!--
                Length of message contents in bytes, including self.
-->
自身を含む、メッセージ内容の長さ（バイト単位）。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<term>
Terminate (F)
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('X')
</term>
<listitem>
<para>
<!--
                Identifies the message as a termination.
-->
メッセージが終了であることを識別します。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(4)
</term>
<listitem>
<para>
<!--
                Length of message contents in bytes, including self.
-->
自身を含む、メッセージ内容の長さ（バイト単位）。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


</variablelist>

</sect1>


<sect1 id="protocol-error-fields">
<!--
<title>Error and Notice Message Fields</title>
-->
<title>エラーおよび警報メッセージフィールド</title>

<para>
<!--
This section describes the fields that can appear in ErrorResponse and
NoticeResponse messages.  Each field type has a single-byte identification
token.  Note that any given field type should appear at most once per
message.
-->
本節では、ErrorResponseおよびNoticeResponseメッセージ内で現れる可能性があるフィールドについて説明します。
それぞれのフィールド種類は、単一バイトの識別子トークンを持ちます。
メッセージ内に与えられる任意のフィールド種類は、多くてもメッセージ当たり1つでなければならないことに注意してください。
</para>

<variablelist>

<varlistentry>
<term>
<literal>S</literal>
</term>
<listitem>
<para>
<!--
        Severity: the field contents are
        <literal>ERROR</literal>, <literal>FATAL</literal>, or
        <literal>PANIC</literal> (in an error message), or
        <literal>WARNING</literal>, <literal>NOTICE</literal>, <literal>DEBUG</literal>,
        <literal>INFO</literal>, or <literal>LOG</literal> (in a notice message),
        or a localized translation of one of these.  Always present.
-->
深刻度です。
フィールドの内容は<literal>ERROR</literal>、<literal>FATAL</literal>、<literal>PANIC</literal>（エラーメッセージ内）、<literal>WARNING</literal>、<literal>NOTICE</literal>、<literal>DEBUG</literal>、<literal>INFO</literal>、<literal>LOG</literal>（警報メッセージ内）、もしくはこれらの1つの地域化された翻訳です。
常に存在します。
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
<literal>V</literal>
</term>
<listitem>
<para>
<!--
        Severity: the field contents are
        <literal>ERROR</literal>, <literal>FATAL</literal>, or
        <literal>PANIC</literal> (in an error message), or
        <literal>WARNING</literal>, <literal>NOTICE</literal>, <literal>DEBUG</literal>,
        <literal>INFO</literal>, or <literal>LOG</literal> (in a notice message).
        This is identical to the <literal>S</literal> field except
        that the contents are never localized.  This is present only in
        messages generated by <productname>PostgreSQL</productname> versions 9.6
        and later.
-->
深刻度です。
フィールドの内容は<literal>ERROR</literal>、<literal>FATAL</literal>、<literal>PANIC</literal>（エラーメッセージ内）、<literal>WARNING</literal>、<literal>NOTICE</literal>、<literal>DEBUG</literal>、<literal>INFO</literal>、<literal>LOG</literal>（警報メッセージ内）です。
これは、その内容が決して地域化されないという点以外は<literal>S</literal>フィールドと同一です。
これは<productname>PostgreSQL</productname>バージョン9.6以降で生成されたメッセージにだけあります。
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
<literal>C</literal>
</term>
<listitem>
<para>
<!--
        Code: the SQLSTATE code for the error (see <xref
        linkend="errcodes-appendix"/>).  Not localizable.  Always present.
-->
コード、そのエラー用のSQLSTATEコードです（<xref linkend="errcodes-appendix"/>を参照）。
地域化されません。
常に存在します。
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
<literal>M</literal>
</term>
<listitem>
<para>
<!--
        Message: the primary human-readable error message.
        This should be accurate but terse (typically one line).
        Always present.
-->
メッセージ、主に人にわかりやすいエラーメッセージです。
これは正確、簡潔でなければなりません（通常は1行です）。
常に存在します。
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
<literal>D</literal>
</term>
<listitem>
<para>
<!--
        Detail: an optional secondary error message carrying more
        detail about the problem.  Might run to multiple lines.
-->
詳細です。
問題のより詳細を説明する省略可能な二次的なエラーメッセージです。
複数行にまたがる可能性があります。
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
<literal>H</literal>
</term>
<listitem>
<para>
<!--
        Hint: an optional suggestion what to do about the problem.
        This is intended to differ from Detail in that it offers advice
        (potentially inappropriate) rather than hard facts.
        Might run to multiple lines.
-->
ヒントです。
その問題にどう対応するかを表す省略可能な提言です。
これは、詳細と異なり、事実ではなく提案（不適切な場合もありますが）を提供することを目的としたものです。
複数行にまたがる可能性があります。
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
<literal>P</literal>
</term>
<listitem>
<para>
<!--
        Position: the field value is a decimal ASCII integer, indicating
        an error cursor position as an index into the original query string.
        The first character has index 1, and positions are measured in
        characters not bytes.
-->
位置です。
フィールド値は、エラーカーソルの位置を示すもので、元の問い合わせ文字列へのインデックスを10進ASCIIで表した整数です。
先頭の文字がインデックス1になり、位置はバイトではなく文字で数えられます。
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
<literal>p</literal>
</term>
<listitem>
<para>
<!--
        Internal position: this is defined the same as the <literal>P</literal>
        field, but it is used when the cursor position refers to an internally
        generated command rather than the one submitted by the client.
        The <literal>q</literal> field will always appear when this field appears.
-->
内部的位置です。
これは<literal>P</literal>と同じ定義ですが、カーソルの位置がクライアントによって発せられたコマンドではなく内部的に生成されたコマンドを参照する場合に使用されます。
このフィールドが現れる時には常に<literal>q</literal>も現れます。
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
<literal>q</literal>
</term>
<listitem>
<para>
<!--
        Internal query: the text of a failed internally-generated command.
        This could be, for example, a SQL query issued by a PL/pgSQL function.
-->
内部的問い合わせ。
失敗した、内部生成のコマンドテキストです。
これは例えば、PL/pgSQL関数によって発行されたSQL問い合わせなどです。
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
<literal>W</literal>
</term>
<listitem>
<para>
<!--
        Where: an indication of the context in which the error occurred.
        Presently this includes a call stack traceback of active
        procedural language functions and internally-generated queries.
        The trace is one entry per line, most recent first.
-->
場所です。
エラーが発生したコンテキストを示します。
現在ここには、実行中の手続き言語関数と内部生成問い合わせの呼び出しスタックトレースバックが含まれます。
この追跡情報は、1行当たり1項目として、最も最近のものが初めに現れます。
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
<literal>s</literal>
</term>
<listitem>
<para>
<!--
        Schema name: if the error was associated with a specific database
        object, the name of the schema containing that object, if any.
-->
スキーマ名。
エラーが特定のデータベースオブジェクトに関連する場合、そのオブジェクトを含むスキーマ名。
無名でなければ。
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
<literal>t</literal>
</term>
<listitem>
<para>
<!--
        Table name: if the error was associated with a specific table, the
        name of the table.  (Refer to the schema name field for the name of
        the table's schema.)
-->
テーブル名。
エラーが特定のテーブルに関連する場合、そのテーブル名。
（スキーマ名フィールドにおいて、そのテーブルのスキーマ名を参照します。）
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
<literal>c</literal>
</term>
<listitem>
<para>
<!--
        Column name: if the error was associated with a specific table column,
        the name of the column.  (Refer to the schema and table name fields to
        identify the table.)
-->
列名。
エラーが特定のテーブルの列に関連する場合、その列名。
（テーブルを識別するため、スキーマ名とテーブル名のフィールドを参照します。）
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
<literal>d</literal>
</term>
<listitem>
<para>
<!--
        Data type name: if the error was associated with a specific data type,
        the name of the data type.  (Refer to the schema name field for the
        name of the data type's schema.)
-->
データ型名。
エラーが特定のデータ型に関連する場合、そのデータ型名。
（スキーマ名フィールドにおいて、そのデータ型のスキーマ名を参照します。）
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
<literal>n</literal>
</term>
<listitem>
<para>
<!--
        Constraint name: if the error was associated with a specific
        constraint, the name of the constraint.  Refer to fields listed above
        for the associated table or domain.  (For this purpose, indexes are
        treated as constraints, even if they weren't created with constraint
        syntax.)
-->
制約名。
エラーが特定の制約に関連する場合、その制約名。
上に列挙したフィールドにおいて、関連するテーブルまたはドメインを参照します。
（この目的のために、制約の構文のもとに作成されていない場合でも、インデックスは制約として扱われます。）
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
<literal>F</literal>
</term>
<listitem>
<para>
<!--
        File: the file name of the source-code location where the error
        was reported.
-->
ファイルです。
エラーを報告した、ソースコードのファイル名です。
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
<literal>L</literal>
</term>
<listitem>
<para>
<!--
        Line: the line number of the source-code location where the error
        was reported.
-->
行です。
エラーを報告した、ソースコードの行番号です。
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
<literal>R</literal>
</term>
<listitem>
<para>
<!--
        Routine: the name of the source-code routine reporting the error.
-->
ルーチンです。
エラーを報告した、ソースコードのルーチン名です。
</para>
</listitem>
</varlistentry>

</variablelist>

<note>
 <para>
<!--
  The fields for schema name, table name, column name, data type name, and
  constraint name are supplied only for a limited number of error types;
  see <xref linkend="errcodes-appendix"/>.  Frontends should not assume that
  the presence of any of these fields guarantees the presence of another
  field.  Core error sources observe the interrelationships noted above, but
  user-defined functions may use these fields in other ways.  In the same
  vein, clients should not assume that these fields denote contemporary
  objects in the current database.
-->
スキーマ名、テーブル名、列名、データ型名および制約名のフィールドは、限られたエラー型のためにしか提供されません。
<xref linkend="errcodes-appendix"/>を参照してください。
フロントエンドは、これらのフィールドの一部の存在が、他のフィールドの存在も保障すると仮定してはいけません。
上記の相互関係により主なエラーの原因を探す方法がありますが、ユーザが定義した関数は他の方法でこれらのフィールドを利用できるかもしれません。
同様の理由により、クライアントはこれらのフィールドが、現在のデータベースにおける適切なオブジェクトを示すと仮定してはいけません。
 </para>
</note>

<para>
<!--
The client is responsible for formatting displayed information to meet its
needs; in particular it should break long lines as needed.  Newline characters
appearing in the error message fields should be treated as paragraph breaks,
not line breaks.
-->
クライアントには、必要な情報を表示する際、整形する責任があります。
具体的には、必要に応じて長い行を分割しなければなりません。
エラーメッセージフィールド内にある改行文字は、改行ではなく、段落の区切りとして扱わなければなりません。
</para>

</sect1>

<sect1 id="protocol-logicalrep-message-formats">
<!--
<title>Logical Replication Message Formats</title>
-->
<title>論理レプリケーションのメッセージ書式</title>

<para>
<!--
This section describes the detailed format of each logical replication message.
These messages are returned either by the replication slot SQL interface or are
sent by a walsender. In case of a walsender they are encapsulated inside the replication
protocol WAL messages as described in <xref linkend="protocol-replication"/>
and generally obey same message flow as physical replication.
-->
本節では論理レプリケーションの各メッセージの書式の詳細について説明します。
これらのメッセージはレプリケーションスロットのSQLインタフェースから返されるか、あるいはwalsenderから送信されるかのいずれかです。
walsenderの場合は、<xref linkend="protocol-replication"/>で説明されているようにレプリケーションプロトコルのWALメッセージ内でカプセル化され、通常は物理レプリケーションと同じメッセージフローに従います。
</para>

<variablelist>

<varlistentry>
<term>
Begin
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('B')
</term>
<listitem>
<para>
<!--
                Identifies the message as a begin message.
-->
メッセージが開始メッセージであることを識別します。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int64
</term>
<listitem>
<para>
<!--
                The final LSN of the transaction.
-->
トランザクションの最後のLSNです。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int64
</term>
<listitem>
<para>
<!--
                Commit timestamp of the transaction. The value is in number
                of microseconds since PostgreSQL epoch (2000-01-01).
-->
トランザクションのコミット時刻です。
その値はPostgreSQLのエポック（2000-01-01）からのマイクロ秒数です。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
<!--
                Xid of the transaction.
-->
トランザクションのXIDです。
</para>
</listitem>
</varlistentry>

</variablelist>
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
Commit
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('C')
</term>
<listitem>
<para>
<!--
                Identifies the message as a commit message.
-->
メッセージがCommitメッセージであることを識別します。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int8
</term>
<listitem>
<para>
<!--
                Flags; currently unused (must be 0).
-->
フラグですが現在は未使用です（0でなければなりません）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int64
</term>
<listitem>
<para>
<!--
                The LSN of the commit.
-->
コミットのLSNです。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int64
</term>
<listitem>
<para>
<!--
                The end LSN of the transaction.
-->
トランザクションの終了LSNです。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int64
</term>
<listitem>
<para>
<!--
                Commit timestamp of the transaction. The value is in number
                of microseconds since PostgreSQL epoch (2000-01-01).
-->
トランザクションのコミット時刻です。
その値はPostgreSQLのエポック（2000-01-01）からのマイクロ秒数です。
</para>
</listitem>
</varlistentry>

</variablelist>
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
Origin
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('O')
</term>
<listitem>
<para>
<!--
                Identifies the message as an origin message.
-->
メッセージがOriginメッセージであることを識別します。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int64
</term>
<listitem>
<para>
<!--
                The LSN of the commit on the origin server.
-->
Originサーバ上のコミットのLSNです。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
<!--
                Name of the origin.
-->
Originの名前です。
</para>
</listitem>
</varlistentry>

</variablelist>
</para>

<para>
<!--
  Note that there can be multiple Origin messages inside a single transaction.
-->
一つのトランザクション内で複数のOriginメッセージがあり得ることに注意してください。
</para>

</listitem>
</varlistentry>

<varlistentry>
<term>
Relation
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('R')
</term>
<listitem>
<para>
<!--
                Identifies the message as a relation message.
-->
メッセージがRelationメッセージであることを識別します。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
<!--
                ID of the relation.
-->
リレーションのIDです。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
<!--
                Namespace (empty string for <literal>pg_catalog</literal>).
-->
名前空間（<literal>pg_catalog</literal>の場合は空文字列）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
<!--
                Relation name.
-->
リレーション名。
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
        Int8
</term>
<listitem>
<para>
<!--
                Replica identity setting for the relation (same as
                <structfield>relreplident</structfield> in <structname>pg_class</structname>).
-->
リレーションのレプリカ識別子の設定（<structname>pg_class</structname>の<structfield>relreplident</structfield>と同じ）。
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
        Int16
</term>
<listitem>
<para>
<!--
                Number of columns.
-->
列数。
</para>
</listitem>
</varlistentry>
</variablelist>
<!--
        Next, the following message part appears for each column (except generated columns):
-->
次に、各列について以下のメッセージ部分があります。（生成列を除く）
<variablelist>
<varlistentry>
<term>
        Int8
</term>
<listitem>
<para>
<!--
                Flags for the column. Currently can be either 0 for no flags
                or 1 which marks the column as part of the key.
-->
列のフラグ。
現在は、フラグがないことを示す0か、列がキーの一部であることを示す1のいずれかにできます。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
<!--
                Name of the column.
-->
列名。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
<!--
                ID of the column's data type.
-->
列のデータ型のID。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
<!--
                Type modifier of the column (<structfield>atttypmod</structfield>).
-->
列の型修飾子（<structfield>atttypmod</structfield>）。
</para>
</listitem>
</varlistentry>

</variablelist>
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
Type
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('Y')
</term>
<listitem>
<para>
<!--
                Identifies the message as a type message.
-->
メッセージがTypeメッセージであることを識別します。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
<!--
                ID of the data type.
-->
データ型のID。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
<!--
                Namespace (empty string for <literal>pg_catalog</literal>).
-->
名前空間（<literal>pg_catalog</literal>の場合は空文字列）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
<!--
                Name of the data type.
-->
データ型の名前。
</para>
</listitem>
</varlistentry>

</variablelist>
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
Insert
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('I')
</term>
<listitem>
<para>
<!--
                Identifies the message as an insert message.
-->
メッセージがInsertメッセージであることを識別します。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
<!--
                ID of the relation corresponding to the ID in the relation
                message.
-->
Relationメッセージ中のIDに対応するリレーションのID。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Byte1('N')
</term>
<listitem>
<para>
<!--
                Identifies the following TupleData message as a new tuple.
-->
以下のTupleDataメッセージが新しいタプルであることを識別します。
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
        TupleData
</term>
<listitem>
<para>
<!--
                TupleData message part representing the contents of new tuple.
-->
新しいタプルの内容を表すTupleDataメッセージ部分です。
</para>
</listitem>
</varlistentry>

</variablelist>
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
Update
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('U')
</term>
<listitem>
<para>
<!--
                Identifies the message as an update message.
-->
メッセージがUpdateメッセージであることを識別します。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
<!--
                ID of the relation corresponding to the ID in the relation
                message.
-->
Relationメッセージ中のIDに対応するリレーションのID。
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
        Byte1('K')
</term>
<listitem>
<para>
<!--
                Identifies the following TupleData submessage as a key.
                This field is optional and is only present if
                the update changed data in any of the column(s) that are
                part of the REPLICA IDENTITY index.
-->
これに続くTupleData副メッセージがキーであることを識別します。
このフィールドはオプションで、UPDATEがREPLICA IDENTITYインデックスの一部となっている列のどれかを変更したときにのみ存在します。
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
        Byte1('O')
</term>
<listitem>
<para>
<!--
                Identifies the following TupleData submessage as an old tuple.
                This field is optional and is only present if table in which
                the update happened has REPLICA IDENTITY set to FULL.
-->
これに続くTupleData副メッセージが古いタプルであることを識別します。
このフィールドはオプションで、UPDATEが発生したテーブルでREPLICA IDENTITYがFULLに設定されている場合にのみ存在します。
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
        TupleData
</term>
<listitem>
<para>
<!--
                TupleData message part representing the contents of the old tuple
                or primary key. Only present if the previous 'O' or 'K' part
                is present.
-->
古いタプルまたは主キーの内容を表すTupleDataメッセージ部分です。
この前に'O'または'K'の部分が存在するときにのみ存在します。
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
        Byte1('N')
</term>
<listitem>
<para>
<!--
                Identifies the following TupleData message as a new tuple.
-->
これに続くTupleDataメッセージが新しいタプルであることを識別します。
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
        TupleData
</term>
<listitem>
<para>
<!--
                TupleData message part representing the contents of a new tuple.
-->
新しいタプルの内容を表すTupleDataメッセージ部分です。
</para>
</listitem>
</varlistentry>

</variablelist>
</para>

<para>
<!--
    The Update message may contain either a 'K' message part or an 'O' message part
    or neither of them, but never both of them.
-->
Updateメッセージは'K'メッセージ部分と'O'メッセージ部分のいずれかを含むか、どちらも含まないかであり、その両方を含むことはできません。
</para>

</listitem>
</varlistentry>

<varlistentry>
<term>
Delete
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('D')
</term>
<listitem>
<para>
<!--
                Identifies the message as a delete message.
-->
メッセージがDeleteメッセージであることを識別します。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
<!--
                ID of the relation corresponding to the ID in the relation
                message.
-->
Relationメッセージ中のIDに対応するリレーションのID。
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
        Byte1('K')
</term>
<listitem>
<para>
<!--
                Identifies the following TupleData submessage as a key.
                This field is present if the table in which the delete has
                happened uses an index as REPLICA IDENTITY.
-->
これに続くTupleData副メッセージがキーであることを識別します。
このフィールドはDELETEが発生したテーブルがインデックスをREPLICA IDENTITYとして使用している場合にのみ存在します。
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
        Byte1('O')
</term>
<listitem>
<para>
<!--
                Identifies the following TupleData message as a old tuple.
                This field is present if the table in which the delete has
                happened has REPLICA IDENTITY set to FULL.
-->
これに続くTupleDataメッセージが古いタプルであることを識別します。
このフィールドはDELETEが発生したテーブルでREPLICA IDENTITYがFULLに設定されている場合にのみ存在します。
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
        TupleData
</term>
<listitem>
<para>
<!--
                TupleData message part representing the contents of the old tuple
                or primary key, depending on the previous field.
-->
直前のフィールドに従って、古いタプルまたは主キーの内容を表すTupleDataメッセージ部分です。
</para>
</listitem>
</varlistentry>
</variablelist>
</para>

<para>
<!--
    The Delete message may contain either a 'K' message part or an 'O' message part,
    but never both of them.
-->
Deleteメッセージは'K'メッセージ部分と'O'メッセージ部分のいずれかを含みますが、両方を含むことはできません。
</para>

</listitem>
</varlistentry>

<varlistentry>
<term>
Truncate
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('T')
</term>
<listitem>
<para>
<!--
                Identifies the message as a truncate message.
-->
メッセージをTruncateメッセージと識別します。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
<!--
                Number of relations
-->
リレーション数
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int8
</term>
<listitem>
<para>
<!--
                Option bits for <command>TRUNCATE</command>:
                1 for <literal>CASCADE</literal>, 2 for <literal>RESTART IDENTITY</literal>
-->
<command>TRUNCATE</command>に対するオプションビット。1は<literal>CASCADE</literal>、2は<literal>RESTART IDENTITY</literal>
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
<!--
                ID of the relation corresponding to the ID in the relation
                message.  This field is repeated for each relation.
-->
リレーションメッセージのIDに一致するリレーションのID。
このフィールドは各リレーション毎に繰り返されます。
</para>
</listitem>
</varlistentry>

</variablelist>
</para>
</listitem>
</varlistentry>

</variablelist>

<para>

<!--
The following message parts are shared by the above messages.
-->
以下のメッセージ部分は上記のメッセージに共通です。

</para>

<variablelist>

<varlistentry>
<term>
TupleData
</term>
<listitem>
<para>

<variablelist>
<varlistentry>
<term>
        Int16
</term>
<listitem>
<para>
<!--
                Number of columns.
-->
列数。
</para>
</listitem>
</varlistentry>
</variablelist>
<!--
        Next, one of the following submessages appears for each column (except generated columns):
-->
次に各列を表す以下の副メッセージの一つがあります。（生成列を除く）
<variablelist>
<varlistentry>
<term>
        Byte1('n')
</term>
<listitem>
<para>
<!--
                Identifies the data as NULL value.
-->
データがNULL値であることを識別します。
</para>
</listitem>
</varlistentry>
</variablelist>
<!--
        Or
-->
または、
<variablelist>
<varlistentry>
<term>
        Byte1('u')
</term>
<listitem>
<para>
<!--
                Identifies unchanged TOASTed value (the actual value is not
                sent).
-->
TOAST値が変更されないことを識別します（実際の値は送信されません）。
</para>
</listitem>
</varlistentry>
</variablelist>
<!--
        Or
-->
または
<variablelist>
<varlistentry>
<term>
        Byte1('t')
</term>
<listitem>
<para>
<!--
                Identifies the data as text formatted value.
-->
データがテキスト形式の値であることを識別します。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
<!--
                Length of the column value.
-->
列値の長さ。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Byte<replaceable>n</replaceable>
</term>
<listitem>
<para>
<!--
                The value of the column, in text format.  (A future release
                might support additional formats.)
                <replaceable>n</replaceable> is the above length.
-->
テキスト形式での列の値。
（将来のリリースでは他の形式もサポートするかもしれません。）
<replaceable>n</replaceable>は上記の長さです。

</para>
</listitem>
</varlistentry>

</variablelist>
</para>
</listitem>
</varlistentry>

</variablelist>

</sect1>

<sect1 id="protocol-changes">
<!--
<title>Summary of Changes since Protocol 2.0</title>
-->
<title>プロトコル2.0からの変更点の要約</title>

<para>
<!--
This section provides a quick checklist of changes, for the benefit of
developers trying to update existing client libraries to protocol 3.0.
-->
本節では、既存のクライアントライブラリをプロトコル3.0に更新しようとする開発者向けに、変更点の簡易チェックリストを示します。
</para>

<para>
<!--
The initial startup packet uses a flexible list-of-strings format
instead of a fixed format.  Notice that session default values for run-time
parameters can now be specified directly in the startup packet.  (Actually,
you could do that before using the <literal>options</literal> field, but given the
limited width of <literal>options</literal> and the lack of any way to quote
whitespace in the values, it wasn't a very safe technique.)
-->
最初の開始パケットは、固定書式ではなく、柔軟な文字列のリスト書式を使用します。
実行時パラメータのセッションのデフォルト値が直接開始パケット内に指定できるようになった点に注意してください。
（実際、以前でも<literal>options</literal>フィールドを使用してこれを行うことができましたが、<literal>options</literal>には長さに制限があること、および値内の空白文字を引用符でくくる方法がないことから、あまり安全な技法ではありませんでした。）
</para>

<para>
<!--
All messages now have a length count immediately following the message type
byte (except for startup packets, which have no type byte).  Also note that
PasswordMessage now has a type byte.
-->
すべてのメッセージが、メッセージ種類バイトの直後にバイト数を持つようになりました
（種類バイトがない開始パケットは例外です）。
また、PasswordMessageが種類バイトを持つようになったことにも注意してください。
</para>

<para>
<!--
ErrorResponse and NoticeResponse ('<literal>E</literal>' and '<literal>N</literal>')
messages now contain multiple fields, from which the client code can
assemble an error message of the desired level of verbosity.  Note that
individual fields will typically not end with a newline, whereas the single
string sent in the older protocol always did.
-->
ErrorResponseおよびNoticeResponse（'<literal>E</literal>'および'<literal>N</literal>'）メッセージが複数のフィールドを持つようになりました。
これを使用して、クライアントコードは、必要な冗長度に合わせて、エラーメッセージを組み立てることができます。
個々のフィールドが通常改行で終わらないことに注意してください。
単一の文字列を送信する古いプロトコルでは、常に改行で終わっていました。
</para>

<para>
<!--
The ReadyForQuery ('<literal>Z</literal>') message includes a transaction status
indicator.
-->
ReadyForQuery（'<literal>Z</literal>'）メッセージに、トランザクション状態指示子が含まれます。
</para>

<para>
<!--
The distinction between BinaryRow and DataRow message types is gone; the
single DataRow message type serves for returning data in all formats.
Note that the layout of DataRow has changed to make it easier to parse.
Also, the representation of binary values has changed: it is no longer
directly tied to the server's internal representation.
-->
BinaryRowとDataRowメッセージ種類間の区別がなくなりました。
1つのDataRowメッセージ種類で、すべての書式で記述されたデータを返すことができます。
DataRowのレイアウトが解析しやすいように変更されたことに注意してください。
またバイナリ値の表現も変更されました。
もはやサーバの内部表現に直接束縛されません。
</para>

<para>
<!--
There is a new <quote>extended query</quote> sub-protocol, which adds the frontend
message types Parse, Bind, Execute, Describe, Close, Flush, and Sync, and the
backend message types ParseComplete, BindComplete, PortalSuspended,
ParameterDescription, NoData, and CloseComplete.  Existing clients do not
have to concern themselves with this sub-protocol, but making use of it
might allow improvements in performance or functionality.
-->
新しい<quote>拡張問い合わせ</quote>サブプロトコルがあります。
これにより、フロントエンドメッセージ種類にParse、Execute、Describe、Close、Flush、およびSyncが、バックエンドメッセージ種類にParseComplete、BindComplete、PortalSuspended、ParameterDescription、NoData、およびCloseCompleteが追加されました。
既存のクライアントは、このサブプロトコルを意識する必要はありませんが、これを使用することで、性能や機能を向上させることができます。
</para>

<para>
<!--
<command>COPY</command> data is now encapsulated into CopyData and CopyDone messages.  There
is a well-defined way to recover from errors during <command>COPY</command>.  The special
<quote><literal>\.</literal></quote> last line is not needed anymore, and is not sent
during <command>COPY OUT</command>.
(It is still recognized as a terminator during <command>COPY IN</command>, but its use is
deprecated and will eventually be removed.)  Binary <command>COPY</command> is supported.
The CopyInResponse and CopyOutResponse messages include fields indicating
the number of columns and the format of each column.
-->
<command>COPY</command>データがCopyDataとCopyDoneメッセージにカプセル化されるようになりました。
<command>COPY</command>中のエラーから復旧するための十分に定義された方法があります。
特別な<quote><literal>\.</literal></quote>という最後の行はもはや不要で、<command>COPY OUT</command>で送信されません。
（<command>COPY IN</command>ではまだ終端として認識されます。しかし、この使用は廃止予定で、最終的には削除されます。）
バイナリ<command>COPY</command>がサポートされます。
CopyInResponseとCopyOutResponseメッセージは、列数と各列の書式を示すフィールドが含まれます。
</para>

<para>
<!--
The layout of FunctionCall and FunctionCallResponse messages has changed.
FunctionCall can now support passing NULL arguments to functions.  It also
can handle passing parameters and retrieving results in either text or
binary format.  There is no longer any reason to consider FunctionCall a
potential security hole, since it does not offer direct access to internal
server data representations.
-->
FunctionCallとFunctionCallResponseメッセージのレイアウトが変更されました。
FunctionCallは関数へのNULL引数を渡すことができるようになりました。
また、テキストとバイナリ書式のどちらでもパラメータの引き渡しと結果の取り出しを扱うことができます。
サーバの内部データ表現への直接アクセスを提供しなくなりましたので、FunctionCallを潜在的なセキュリティホールとみなす理由はもはやありません。
</para>

<para>
<!--
The backend sends ParameterStatus ('<literal>S</literal>') messages during connection
startup for all parameters it considers interesting to the client library.
Subsequently, a ParameterStatus message is sent whenever the active value
changes for any of these parameters.
-->
バックエンドは、接続開始時にクライアントライブラリが興味を持つとみなされるすべてのパラメータのためにParameterStatus（'<literal>S</literal>'）メッセージを送信します。
その後、これらのパラメータのいずれかの実際の値が変更された時は常に、ParameterStatusメッセージが送信されます。
</para>

<para>
<!--
The RowDescription ('<literal>T</literal>') message carries new table OID and column
number fields for each column of the described row.  It also shows the format
code for each column.
-->
RowDescription（'<literal>T</literal>'）メッセージは、新規に、記述する各列に対してテーブルのOIDと列番号フィールドを伝えます。
また各列の書式コードも示します。
</para>

<para>
<!--
The CursorResponse ('<literal>P</literal>') message is no longer generated by
the backend.
-->
CursorResponse（'<literal>P</literal>'）メッセージはもはやバックエンドで生成されません。
</para>

<para>
<!--
The NotificationResponse ('<literal>A</literal>') message has an additional string
field, which can carry a <quote>payload</quote> string passed
from the <command>NOTIFY</command> event sender.
-->
NotificationResponse（'<literal>A</literal>'）メッセージは、<command>NOTIFY</command>イベントの送信者から渡される<quote>ペイロード</quote>文字列を伝えることができる追加文字列フィールドを持ちます。
</para>

<para>
<!--
The EmptyQueryResponse ('<literal>I</literal>') message used to include an empty
string parameter; this has been removed.
-->
EmptyQueryResponse（'<literal>I</literal>'）メッセージは、空の文字列パラメータを含めるために使用されていました。
これは削除されました。
</para>

</sect1>

</chapter>
