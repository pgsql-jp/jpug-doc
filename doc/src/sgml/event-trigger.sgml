<!-- doc/src/sgml/event-trigger.sgml -->

 <chapter id="event-triggers">
<!--
  <title>Event Triggers</title>
-->
  <title>イベントトリガ</title>

  <indexterm zone="event-triggers">
   <primary>event trigger</primary>
  </indexterm>
  <indexterm zone="event-triggers">
   <primary>イベントトリガ</primary>
  </indexterm>

  <para>
<!--
   To supplement the trigger mechanism discussed in <xref linkend="triggers"/>,
   <productname>PostgreSQL</productname> also provides event triggers.  Unlike regular
   triggers, which are attached to a single table and capture only DML events,
   event triggers are global to a particular database and are capable of
   capturing DDL events.
-->
<xref linkend="triggers"/>で説明されたトリガの機能を補完するために、<productname>PostgreSQL</productname>はイベントトリガを提供します。
一つのテーブルに付与され、DMLイベントのみ対象にしたこれまでのトリガと違い、イベントトリガは特定のデータベースに大域的であり、DDLイベントを対象に実行できます。
  </para>

  <para>
<!--
   Like regular triggers, event triggers can be written in any procedural
   language that includes event trigger support, or in C, but not in plain
   SQL.
-->
これまでのトリガと違い、イベントトリガは普通のSQLではなく、イベントトリガがサポートする手続き言語やC言語で記述することができます。
  </para>

  <sect1 id="event-trigger-definition">
<!--
   <title>Overview of Event Trigger Behavior</title>
-->
   <title>イベントトリガ動作の概要</title>

   <para>
<!--
     An event trigger fires whenever the event with which it is associated
     occurs in the database in which it is defined. Currently, the
     supported events are
     <literal>login</literal>,
     <literal>ddl_command_start</literal>,
     <literal>ddl_command_end</literal>,
     <literal>table_rewrite</literal>
     and <literal>sql_drop</literal>.
     Support for additional events may be added in future releases.
-->
イベントトリガは、定義されたデータベース内で関連づけられたイベントが起こるたびに起動します。
今のところサポートされているイベントは、<literal>login</literal>、<literal>ddl_command_start</literal>、<literal>ddl_command_end</literal>、<literal>table_rewrite</literal>、および<literal>sql_drop</literal>です。
今後のリリースで新たなイベントが追加されるかもしれません。
   </para>

   <sect2 id="event-trigger-login">
    <title>login</title>

   <para>
<!--
     The <literal>login</literal> event occurs when an authenticated user logs
     into the system. Any bug in a trigger procedure for this event may
     prevent successful login to the system. Such bugs may be worked around by
     setting <xref linkend="guc-event-triggers"/> to <literal>false</literal>
     either in a connection string or configuration file. Alternatively, you can
     restart the system in single-user mode (as event triggers are
     disabled in this mode). See the <xref linkend="app-postgres"/> reference
     page for details about using single-user mode.
     The <literal>login</literal> event will also fire on standby servers.
     To prevent servers from becoming inaccessible, such triggers must avoid
     writing anything to the database when running on a standby.
     Also, it's recommended to avoid long-running queries in
     <literal>login</literal> event triggers.  Note that, for instance,
     canceling a connection in <application>psql</application> will not cancel
     the in-progress <literal>login</literal> trigger.
-->
<literal>login</literal>イベントは、認証されたユーザがシステムにログインするときに発生します。
このイベントのトリガプロシージャにおけるバグは、システムへのログインの成功を妨げる可能性があります。
このようなバグは、接続文字列または設定ファイルで<xref linkend="guc-event-triggers"/>を<literal>false</literal>に設定することで回避できます。
あるいは、シングルユーザモードでシステムを再起動することでも回避できます（このモードではイベントトリガが無効になっているため）。
シングルユーザモードの使用方法の詳細については、<xref linkend="app-postgres"/>のリファレンスページを参照してください。
<literal>login</literal>イベントはスタンバイサーバでも実行されます。
サーバがアクセスできなくなるのを防ぐために、このようなトリガは、スタンバイで実行されているときにはデータベースに何も書き込まないようにする必要があります。
また、<literal>login</literal>イベントトリガでの長時間実行する問い合わせは避けることをお勧めします。
例えば、<application>psql</application>で接続を取り消しても進行中の<literal>login</literal>トリガを中断しないことに注意してください。
   </para>

   <para>
<!--
     For an example on how to use the <literal>login</literal> event trigger,
     see <xref linkend="event-trigger-database-login-example"/>.
-->
<literal>login</literal>イベントトリガの使用方法の例については、<xref linkend="event-trigger-database-login-example"/>を参照してください。
   </para>
   </sect2>

   <sect2 id="event-trigger-ddl_command_start">
    <title>ddl_command_start</title>

   <para>
<!--
     The <literal>ddl_command_start</literal> event occurs just before the
     execution of a DDL command.  DDL commands in this context are:
-->
<literal>ddl_command_start</literal>イベントは、DDLコマンドが実行される直前に発生します。
この文脈でのDDLコマンドは、次の通りです。
     <itemizedlist>
      <listitem><para><literal>CREATE</literal></para></listitem>
      <listitem><para><literal>ALTER</literal></para></listitem>
      <listitem><para><literal>DROP</literal></para></listitem>
      <listitem><para><literal>COMMENT</literal></para></listitem>
      <listitem><para><literal>GRANT</literal></para></listitem>
      <listitem><para><literal>IMPORT FOREIGN SCHEMA</literal></para></listitem>
      <listitem><para><literal>REINDEX</literal></para></listitem>
      <listitem><para><literal>REFRESH MATERIALIZED VIEW</literal></para></listitem>
      <listitem><para><literal>REVOKE</literal></para></listitem>
      <listitem><para><literal>SECURITY LABEL</literal></para></listitem>
     </itemizedlist>
<!--
     <literal>ddl_command_start</literal> also occurs just before the
     execution of a <literal>SELECT INTO</literal> command, since this is
     equivalent to <literal>CREATE TABLE AS</literal>.
-->
<literal>ddl_command_start</literal>は、<literal>SELECT INTO</literal>コマンドが実行される直前にも発生します。
このコマンドは<literal>CREATE TABLE AS</literal>と同等であるためです。
   </para>

   <para>
<!--
     As an exception, this event does not occur for DDL commands targeting
     shared objects:
-->
例外として、このイベントは共有オブジェクトを対象とするDDLコマンドでは発生しません。
     <itemizedlist>
<!--
      <listitem><para>databases</para></listitem>
-->
      <listitem><para>データベース</para></listitem>
<!--
      <listitem><para>roles (role definitions and role memberships)</para></listitem>
-->
      <listitem><para>ロール（ロール定義とロールメンバ資格）</para></listitem>
<!--
      <listitem><para>tablespaces</para></listitem>
-->
      <listitem><para>テーブル空間</para></listitem>
<!--
      <listitem><para>parameter privileges</para></listitem>
-->
      <listitem><para>パラメータ権限</para></listitem>
      <listitem><para><command>ALTER SYSTEM</command></para></listitem>
     </itemizedlist>
<!--
     This event also does not occur for commands targeting event triggers
     themselves.
-->
このイベントは、イベントトリガ自体を対象とするコマンドでも発生しません。
   </para>

   <para>
<!--
     No check whether the affected object exists or doesn't exist is performed
     before the event trigger fires.
-->
イベントトリガが起動する前に、影響を受けるオブジェクトが存在するかどうかは確認されません。
   </para>
   </sect2>

   <sect2 id="event-trigger-ddl_command_end">
    <title>ddl_command_end</title>

   <para>
<!--
    The <literal>ddl_command_end</literal> event occurs just after the execution of
    the same set of commands as <literal>ddl_command_start</literal>.  To
    obtain more details on the <acronym>DDL</acronym>
    operations that took place, use the set-returning function
    <literal>pg_event_trigger_ddl_commands()</literal> from the
    <literal>ddl_command_end</literal> event trigger code (see
    <xref linkend="functions-event-triggers"/>).  Note that the trigger fires
    after the actions have taken place (but before the transaction commits),
    and thus the system catalogs can be read as already changed.
-->
<literal>ddl_command_end</literal>イベントは、<literal>ddl_command_start</literal>イベントの対象と同じコマンド集合の実行直後に発生します。
発生した<acronym>DDL</acronym>操作のより詳細を取得するには、<literal>ddl_command_end</literal>イベントトリガコードで集合を返す関数<literal>pg_event_trigger_ddl_commands()</literal>を使用してください（<xref linkend="functions-event-triggers"/>を参照してください）。
トリガはアクションが起きた後（ただし、トランザクションのコミットの前）に起動するため、システムカタログは既に変更されたものとして読まれることに注意してください。
   </para>
   </sect2>

   <sect2 id="event-trigger-sql_drop">
    <title>sql_drop</title>

   <para>
<!--
    The <literal>sql_drop</literal> event occurs just before the
    <literal>ddl_command_end</literal> event trigger for any operation that drops
    database objects.  Note that besides the obvious <literal>DROP</literal>
    commands, some <literal>ALTER</literal> commands can also trigger an
    <literal>sql_drop</literal> event.
-->
<literal>sql_drop</literal>イベントは、データベースオブジェクトを削除する操作に対する<literal>ddl_command_end</literal>イベントトリガの直前に発生します。
明らかな<literal>DROP</literal>コマンドの他に、いくつかの<literal>ALTER</literal>コマンドでも<literal>sql_drop</literal>イベントが発生する可能性があります。
   </para>

   <para>
<!--
    To list the objects that have been dropped, use the
    set-returning function <literal>pg_event_trigger_dropped_objects()</literal> from the
    <literal>sql_drop</literal> event trigger code (see
    <xref linkend="functions-event-triggers"/>). Note that
    the trigger is executed after the objects have been deleted from the
    system catalogs, so it's not possible to look them up anymore.
-->
削除されたオブジェクトの一覧を確認するには、<literal>sql_drop</literal>イベントトリガコードで集合を返す関数<literal>pg_event_trigger_dropped_objects()</literal>を使用してください（<xref linkend="functions-event-triggers"/>を参照してください）。
トリガはシステムカタログからオブジェクトが削除された後に実行されるため、それ以降それらのオブジェクトは検索できないことに注意してください。
   </para>
   </sect2>

   <sect2 id="event-trigger-table_rewrite">
    <title>table_rewrite</title>

   <para>
<!--
    The <literal>table_rewrite</literal> event occurs just before a table is
    rewritten by some actions of the commands <literal>ALTER TABLE</literal> and
    <literal>ALTER TYPE</literal>.  While other
    control statements are available to rewrite a table,
    like <literal>CLUSTER</literal> and <literal>VACUUM</literal>,
    the <literal>table_rewrite</literal> event is not triggered by them.
    To find the OID of the table that was rewritten, use the function
    <literal>pg_event_trigger_table_rewrite_oid()</literal>, to discover the
    reason(s) for the rewrite, use the function
    <literal>pg_event_trigger_table_rewrite_reason()</literal> (see <xref
    linkend="functions-event-triggers"/>).
-->
<literal>table_rewrite</literal>イベントは、<literal>ALTER TABLE</literal>や<literal>ALTER TYPE</literal>コマンドのアクションによりテーブルが書き換えられる直前に発生します。
<literal>CLUSTER</literal>や<literal>VACUUM</literal>のような他の制御文でもテーブルは書き換えられますが、それらでは<literal>table_rewrite</literal>イベントは発生しません。
書き換えられたテーブルのOIDを見つけるには、関数<literal>pg_event_trigger_table_rewrite_oid()</literal>を使用し、書き換えられた理由を知るには、関数<literal>pg_event_trigger_table_rewrite_reason()</literal>を使用します（<xref linkend="functions-event-triggers"/>を参照してください）。
   </para>
   </sect2>

   <sect2 id="event-trigger-aborted-transactions">
<!--
    <title>Event Triggers in Aborted Transactions</title>
-->

    <title>中断したトランザクションでのイベントトリガ</title>
   <para>
<!--
     Event triggers (like other functions) cannot be executed in an aborted
     transaction.  Thus, if a DDL command fails with an error, any associated
     <literal>ddl_command_end</literal> triggers will not be executed.  Conversely,
     if a <literal>ddl_command_start</literal> trigger fails with an error, no
     further event triggers will fire, and no attempt will be made to execute
     the command itself.  Similarly, if a <literal>ddl_command_end</literal> trigger
     fails with an error, the effects of the DDL statement will be rolled
     back, just as they would be in any other case where the containing
     transaction aborts.
-->
イベントトリガは（他の関数のように）中断したトランザクションでは実行されません。
従って、DDLコマンドがエラーで失敗した場合、関連する<literal>ddl_command_end</literal>トリガは実行されません。
逆に、もし<literal>ddl_command_start</literal>トリガがエラーで失敗した場合、他のイベントトリガは起動されず、コマンド自体も実行されません。
同様に、もし<literal>ddl_command_end</literal>トリガがエラーで失敗した場合、それを含むトランザクションが失敗した場合のようにDDL文はロールバックされます。
   </para>
   </sect2>

   <sect2 id="event-trigger-creating">
<!--
    <title>Creating Event Triggers</title>
-->
    <title>イベントトリガの作成</title>

   <para>
<!--
     Event triggers are created using the command <xref linkend="sql-createeventtrigger"/>.
     In order to create an event trigger, you must first create a function with
     the special return type <literal>event_trigger</literal>.  This function
     need not (and may not) return a value; the return type serves merely as
     a signal that the function is to be invoked as an event trigger.
-->
イベントトリガは、コマンド<xref linkend="sql-createeventtrigger"/>を使用して作成されます。
イベントトリガを作成するために、まず特別な型<literal>event_trigger</literal>を返す関数を作る必要があります。
この関数は値を返す必要はありません。というのも、その戻り値型は単にシグナルとして、その関数がイベントトリガを呼び出していることを示しているだけだからです。
   </para>

   <para>
<!--
     If more than one event trigger is defined for a particular event, they will
     fire in alphabetical order by trigger name.
-->
特定のイベントに対して複数のイベントトリガが定義された場合、トリガ名のアルファベット順で起動されます。
   </para>

   <para>
<!--
     A trigger definition can also specify a <literal>WHEN</literal>
     condition so that, for example, a <literal>ddl_command_start</literal>
     trigger can be fired only for particular commands which the user wishes
     to intercept. A common use of such triggers is to restrict the range of
     DDL operations which users may perform.
-->
トリガ定義は<literal>WHEN</literal>条件で特定されます。そのため、例えば<literal>ddl_command_start</literal>トリガはユーザが望む特定のコマンドのみを契機に実行させることができます。
このようなトリガの一般的な使い方として、ユーザが実行するかもしれないDDL文の範囲を狭めることができます。
   </para>
   </sect2>
  </sect1>

  <sect1 id="event-trigger-interface">
<!--
   <title>Writing Event Trigger Functions in C</title>
-->
   <title>C言語によるイベントトリガ関数の書き方</title>

   <indexterm zone="event-trigger-interface">
    <primary>event trigger</primary>
    <secondary>in C</secondary>
   </indexterm>
   <indexterm zone="event-trigger-interface">
    <primary>イベントトリガ</primary>
    <secondary>C言語による</secondary>
   </indexterm>

   <para>
<!--
    This section describes the low-level details of the interface to an
    event trigger function. This information is only needed when writing
    event trigger functions in C. If you are using a higher-level language
    then these details are handled for you. In most cases you should
    consider using a procedural language before writing your event triggers
    in C. The documentation of each procedural language explains how to
    write an event trigger in that language.
-->
本節ではトリガ関数とのインタフェースについて低レベルな詳細を説明します。
この情報はC言語でトリガ関数を作成する時にのみ必要です。
高レベルな言語で作成すれば、こうした詳細は代わりに扱ってもらえます。
たいていの場合、Cでトリガを作成する前に手続き言語を使用することを検討すべきです。
各手続き言語の文書で、その言語を使用したイベントトリガの作成方法を説明します。
   </para>

   <para>
<!--
    Event trigger functions must use the <quote>version 1</quote> function
    manager interface.
-->
トリガ関数は<quote>version 1</quote>関数マネージャインタフェースを使わなくてはいけません。
   </para>

   <para>
<!--
    When a function is called by the event trigger manager, it is not passed
    any normal arguments, but it is passed a <quote>context</quote> pointer
    pointing to a <structname>EventTriggerData</structname> structure. C functions can
    check whether they were called from the event trigger manager or not by
    executing the macro:
-->
関数がイベントトリガマネージャから呼び出される時は、通常の引数が渡されるのではなく、<structname>EventTriggerData</structname>構造体を指す<quote>context</quote>ポインタが渡されます。
C関数は、イベントトリガマネージャから呼び出されたのかどうかを以下のマクロを実行することで検査することができます。
<programlisting>
CALLED_AS_EVENT_TRIGGER(fcinfo)
</programlisting>
<!--
    which expands to:
-->
これは以下に展開されます。
<programlisting>
((fcinfo)-&gt;context != NULL &amp;&amp; IsA((fcinfo)-&gt;context, EventTriggerData))
</programlisting>
<!--
    If this returns true, then it is safe to cast
    <literal>fcinfo-&gt;context</literal> to type <literal>EventTriggerData
    *</literal> and make use of the pointed-to
    <structname>EventTriggerData</structname> structure.  The function must
    <emphasis>not</emphasis> alter the <structname>EventTriggerData</structname>
    structure or any of the data it points to.
-->
もしこれが真を返す場合、<literal>fcinfo-&gt;context</literal>を<literal>EventTriggerData *</literal>型にキャストし、指された<structname>EventTriggerData</structname>構造体を使用することは安全です。
その関数は、<structname>TriggerData</structname>構造体やそれが指すどのようなデータも変更しては<emphasis>いけません</emphasis>。
   </para>

   <para>
<!--
    <structname>struct EventTriggerData</structname> is defined in
    <filename>commands/event_trigger.h</filename>:
-->
<structname>struct EventTriggerData</structname>は<filename>commands/event_trigger.h</filename>の中で定義されています。

<programlisting>
typedef struct EventTriggerData
{
    NodeTag     type;
<!--
    const char *event;      /* event name */
    Node       *parsetree;  /* parse tree */
    CommandTag  tag;        /* command tag */
-->
    const char *event;      /* イベント名 */
    Node       *parsetree;  /* 解析ツリー */
    CommandTag  tag;        /* コマンドタグ */
} EventTriggerData;
</programlisting>

<!--
    where the members are defined as follows:
-->
メンバは下記のように定義されています。

    <variablelist>
     <varlistentry>
      <term><structfield>type</structfield></term>
      <listitem>
       <para>
<!--
        Always <literal>T_EventTriggerData</literal>.
-->
常に<literal>T_EventTriggerData</literal>です。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><structfield>event</structfield></term>
      <listitem>
       <para>
<!--
        Describes the event for which the function is called, one of
        <literal>"login"</literal>, <literal>"ddl_command_start"</literal>,
        <literal>"ddl_command_end"</literal>, <literal>"sql_drop"</literal>,
        <literal>"table_rewrite"</literal>.
        See <xref linkend="event-trigger-definition"/> for the meaning of these
        events.
-->
その関数が呼び出されたイベント、<literal>"login"</literal>、<literal>"ddl_command_start"</literal>、<literal>"ddl_command_end"</literal>、<literal>"sql_drop"</literal>、<literal>"table_rewrite"</literal>のうちの１つを記述します。
これらのイベントの内容は、<xref linkend="event-trigger-definition"/>を参照してください。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><structfield>parsetree</structfield></term>
      <listitem>
       <para>
<!--
        A pointer to the parse tree of the command.  Check the PostgreSQL
        source code for details.  The parse tree structure is subject to change
        without notice.
-->
コマンドの解析ツリーへのポインタです。
詳細はPostgreSQLのソースコードを確認してください。
解析ツリーの構造は予告なく変更されることがあります。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><structfield>tag</structfield></term>
      <listitem>
       <para>
<!--
        The command tag associated with the event for which the event trigger
        is run, for example <literal>"CREATE FUNCTION"</literal>.
-->
イベントトリガの実行対象となるイベントに関連するコマンドタグです。たとえば、<literal>"CREATE FUNCTION"</literal>です。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>

   <para>
<!--
    An event trigger function must return a <symbol>NULL</symbol> pointer
    (<emphasis>not</emphasis> an SQL null value, that is, do not
    set <parameter>isNull</parameter> true).
-->
イベントトリガ関数は<symbol>NULL</symbol>ポインタ（SQLのNULLでは<emphasis>ありません</emphasis>。したがって、<parameter>isNull</parameter>は真にはなりません）を返さなければなりません。
   </para>
  </sect1>

  <sect1 id="event-trigger-example">
<!--
   <title>A Complete Event Trigger Example</title>
-->
   <title>完全なイベントトリガの例</title>

   <para>
<!--
    Here is a very simple example of an event trigger function written in C.
    (Examples of triggers written in procedural languages can be found in
    the documentation of the procedural languages.)
-->
C言語で作成したイベントトリガ関数に関するとても簡単な例をここに示します。
（手続き言語で作成したトリガの例は、その手続き言語の文書に記載されています。）
   </para>

   <para>
<!--
    The function <function>noddl</function> raises an exception each time it is called.
    The event trigger definition associated the function with
    the <literal>ddl_command_start</literal> event.  The effect is that all DDL
    commands (with the exceptions mentioned
    in <xref linkend="event-trigger-definition"/>) are prevented from running.
-->
<function>noddl</function>関数は、呼ばれるたびに例外を発生させます。
このイベントトリガは、この関数と<literal>ddl_command_start</literal>イベントを関連づけます。
そのため、(<xref linkend="event-trigger-definition"/>で言及した例外はありますが例外を含む)すべてのDDLコマンドは、実行できません。
   </para>

   <para>
<!--
    This is the source code of the trigger function:
-->
以下がトリガ関数のソースコードです。
<programlisting><![CDATA[
#include "postgres.h"

#include "commands/event_trigger.h"
#include "fmgr.h"

PG_MODULE_MAGIC;

PG_FUNCTION_INFO_V1(noddl);

Datum
noddl(PG_FUNCTION_ARGS)
{
    EventTriggerData *trigdata;

]]><!--
    if (!CALLED_AS_EVENT_TRIGGER(fcinfo))  /* internal error */
--><![CDATA[
    if (!CALLED_AS_EVENT_TRIGGER(fcinfo))  /* 内部エラー */
        elog(ERROR, "not fired by event trigger manager");

    trigdata = (EventTriggerData *) fcinfo->context;

    ereport(ERROR,
            (errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),
             errmsg("command \"%s\" denied",
                    GetCommandTagName(trigdata->tag))));

    PG_RETURN_NULL();
}
]]></programlisting>
   </para>

   <para>
<!--
    After you have compiled the source code (see <xref linkend="dfunc"/>),
    declare the function and the triggers:
-->
ソースコードをコンパイル（<xref linkend="dfunc"/>を参照してください）した後に、以下の様に関数とトリガを宣言します。
<programlisting>
CREATE FUNCTION noddl() RETURNS event_trigger
    AS 'noddl' LANGUAGE C;

CREATE EVENT TRIGGER noddl ON ddl_command_start
    EXECUTE FUNCTION noddl();
</programlisting>
   </para>

   <para>
<!--
    Now you can test the operation of the trigger:
-->
これで、トリガの操作を確認することができます。
<screen>
=# \dy
                     List of event triggers
 Name  |       Event       | Owner | Enabled | Function | Tags
-------+-------------------+-------+---------+----------+------
 noddl | ddl_command_start | dim   | enabled | noddl    |
(1 row)

=# CREATE TABLE foo(id serial);
ERROR:  command "CREATE TABLE" denied
</screen>
   </para>

   <para>
<!--
    In this situation, in order to be able to run some DDL commands when you
    need to do so, you have to either drop the event trigger or disable it.  It
    can be convenient to disable the trigger for only the duration of a
    transaction:
-->
この状況では、DDLコマンドを必要なときに実行できるようにするには、このイベントトリガを削除するか、無効化しなければなりません。
以下のように、トランザクションの期間中だけトリガを無効化するのが、便利かもしれません。
<programlisting>
BEGIN;
ALTER EVENT TRIGGER noddl DISABLE;
CREATE TABLE foo (id serial);
ALTER EVENT TRIGGER noddl ENABLE;
COMMIT;
</programlisting>
<!--
    (Recall that DDL commands on event triggers themselves are not affected by
    event triggers.)
-->
(イベントトリガ自体が関係するDDLコマンドは、イベントトリガの影響を受けないことを思い出してください。)
   </para>
  </sect1>

  <sect1 id="event-trigger-table-rewrite-example">
<!--
   <title>A Table Rewrite Event Trigger Example</title>
-->
   <title>テーブル書き換えイベントトリガの例</title>

   <para>
<!--
    Thanks to the <literal>table_rewrite</literal> event, it is possible to implement
    a table rewriting policy only allowing the rewrite in maintenance windows.
-->
<literal>table_rewrite</literal>イベントのおかげで、メンテナンスウィンドウでの書き換えを許可するだけでテーブル書き換えポリシーを実装できます。
   </para>

   <para>
<!--
    Here's an example implementing such a policy.
-->
これが、そのようなポリシーを実装した例です。
<programlisting>
CREATE OR REPLACE FUNCTION no_rewrite()
 RETURNS event_trigger
 LANGUAGE plpgsql AS
$$
---
<!--
&#45;&#45;- Implement local Table Rewriting policy:
&#45;&#45;-   public.foo is not allowed rewriting, ever
&#45;&#45;-   other tables are only allowed rewriting between 1am and 6am
&#45;&#45;-   unless they have more than 100 blocks
-->
--- ローカルテーブル書き換えポリシーの実装:
---   public.fooは書き換えが許可されていません
---   その他のテーブルは100ブロック以下であれば、
---   午前1時から午前6時までの間だけ書き換えが許可されます
---
DECLARE
  table_oid oid := pg_event_trigger_table_rewrite_oid();
  current_hour integer := extract('hour' from current_time);
  pages integer;
  max_pages integer := 100;
BEGIN
  IF pg_event_trigger_table_rewrite_oid() = 'public.foo'::regclass
  THEN
        RAISE EXCEPTION 'you''re not allowed to rewrite the table %',
                        table_oid::regclass;
  END IF;

  SELECT INTO pages relpages FROM pg_class WHERE oid = table_oid;
  IF pages > max_pages
  THEN
        RAISE EXCEPTION 'rewrites only allowed for table with less than % pages',
                        max_pages;
  END IF;

  IF current_hour NOT BETWEEN 1 AND 6
  THEN
        RAISE EXCEPTION 'rewrites only allowed between 1am and 6am';
  END IF;
END;
$$;

CREATE EVENT TRIGGER no_rewrite_allowed
                  ON table_rewrite
   EXECUTE FUNCTION no_rewrite();
</programlisting>
   </para>
 </sect1>

  <sect1 id="event-trigger-database-login-example">
<!--
    <title>A Database Login Event Trigger Example</title>
-->
    <title>データベースログインイベントトリガの例</title>

    <para>
<!--
      The event trigger on the <literal>login</literal> event can be
      useful for logging user logins, for verifying the connection and
      assigning roles according to current circumstances, or for session
      data initialization. It is very important that any event trigger using
      the <literal>login</literal> event checks whether or not the database is
      in recovery before performing any writes. Writing to a standby server
      will make it inaccessible.
-->
<literal>login</literal>イベントのイベントトリガは、ユーザログインの記録、接続の検証と現在の状況に応じたロールの割り当て、あるいは、セッションデータの初期設定に有用です。
<literal>login</literal>イベントを使用するイベントトリガは、書き込みを実行する前にデータベースがリカバリ中であるかどうかを確認することが非常に重要です。
スタンバイサーバに書き込むとアクセスできなくなります。
    </para>

    <para>
<!--
      The following example demonstrates these options.
-->
以下は、これらの機能付加を示す例です。
<programlisting>
-- create test tables and roles
-- テスト用のテーブルとロールを作成
CREATE TABLE user_login_log (
  "user" text,
  "session_start" timestamp with time zone
);
CREATE ROLE day_worker;
CREATE ROLE night_worker;

-- the example trigger function
-- トリガ関数の例
CREATE OR REPLACE FUNCTION init_session()
  RETURNS event_trigger SECURITY DEFINER
  LANGUAGE plpgsql AS
$$
DECLARE
  hour integer = EXTRACT('hour' FROM current_time at time zone 'utc');
  rec boolean;
BEGIN
-- 1. Forbid logging in between 2AM and 4AM.
-- 1. AM2時から4時までのログインを禁止する。
IF hour BETWEEN 2 AND 4 THEN
  RAISE EXCEPTION 'Login forbidden';
END IF;

-- The checks below cannot be performed on standby servers so
-- ensure the database is not in recovery before we perform any
-- operations.
-- これより先のチェックはスタンバイサーバでは実行できないので、
-- 操作を実行する前にデータベースがリカバリ中でないことを確認する。
SELECT pg_is_in_recovery() INTO rec;
IF rec THEN
  RETURN;
END IF;

-- 2. Assign some roles. At daytime, grant the day_worker role, else the
-- night_worker role.
-- 2. ロールを割り当てる。
-- 日中はday_workerロール、さもなくば night_workerロール。
IF hour BETWEEN 8 AND 20 THEN
  EXECUTE 'REVOKE night_worker FROM ' || quote_ident(session_user);
  EXECUTE 'GRANT day_worker TO ' || quote_ident(session_user);
ELSE
  EXECUTE 'REVOKE day_worker FROM ' || quote_ident(session_user);
  EXECUTE 'GRANT night_worker TO ' || quote_ident(session_user);
END IF;

-- 3. Initialize user session data
-- 3. ユーザのセッションデータを初期化する。
CREATE TEMP TABLE session_storage (x float, y integer);
ALTER TABLE session_storage OWNER TO session_user;

-- 4. Log the connection time
INSERT INTO public.user_login_log VALUES (session_user, current_timestamp);

END;
$$;

-- trigger definition
CREATE EVENT TRIGGER init_session
  ON login
  EXECUTE FUNCTION init_session();
ALTER EVENT TRIGGER init_session ENABLE ALWAYS;
</programlisting>
    </para>
  </sect1>
</chapter>
