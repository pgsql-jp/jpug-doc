<!-- doc/src/sgml/rules.sgml -->

<chapter id="rules">
<!--
<title>The Rule System</title>
-->
<title>ルールシステム</title>

 <indexterm zone="rules">
<!--
  <primary>rule</primary>
-->
  <primary>ルール</primary>
 </indexterm>

<para>
<!--
     This chapter discusses the rule system in
     <productname>PostgreSQL</productname>.  Production rule systems
     are conceptually simple, but there are many subtle points
     involved in actually using them.
-->
本章では<productname>PostgreSQL</productname>のルールシステムについて説明します。
本番で稼働するルールシステムは概念としては単純ですが、実際に使ってみると、わかりにくいところが少なからずあります。
</para>

<para>
<!--
     Some other database systems define active database rules, which
     are usually stored procedures and triggers.  In
     <productname>PostgreSQL</productname>, these can be implemented
     using functions and triggers as well.
-->
通常それらはストアドプロシージャとトリガですが、他のいくつかのデータベースシステムは能動的データベースルールを定義しています。
<ProductName>PostgreSQL</ProductName>では関数とトリガとして実装されています。
</para>

<para>
<!--
     The rule system (more precisely speaking, the query rewrite rule
     system) is totally different from stored procedures and triggers.
     It modifies queries to take rules into consideration, and then
     passes the modified query to the query planner for planning and
     execution.  It is very powerful, and can be used for many things
     such as query language procedures, views, and versions.  The
     theoretical foundations and the power of this rule system are
     also discussed in <xref linkend="STON90b"> and <xref
     linkend="ONG90">.
-->
ルールシステム（より正確に言うと問い合わせ書き換えルールシステム）はストアドプロシージャとトリガとはまったく異なります。
ルールシステムはルールを参照して問い合わせを修正し、修正した問い合わせを、計画作成と実行のために問い合わせプランナに渡します。
これは非常に強力なため、問い合わせ言語プロシージャ、ビューあるいはバージョンなど多くのパターンで使用することができます。
このルールシステムの基礎理論と能力は<xref linkend="STON90b">および<xref linkend="ONG90">で解説されています。
</para>

<sect1 id="querytree">
<!--
<title>The Query Tree</title>
-->
<title>問い合わせツリーとは</title>

<indexterm zone="querytree">
<!--
 <primary>query tree</primary>
-->
 <primary>問い合わせツリー</primary>
</indexterm>

<para>
<!--
    To understand how the rule system works it is necessary to know
    when it is invoked and what its input and results are.
-->
どのようにルールシステムが機能するかを理解するためには、ルールがどのように起動され、その入力と結果は何かを理解しなければなりません。
</para>

<para>
<!--
    The rule system is located between the parser and the planner.
    It takes the output of the parser, one query tree, and the user-defined
    rewrite rules, which are also
    query trees with some extra information, and creates zero or more
    query trees as result. So its input and output are always things
    the parser itself could have produced and thus, anything it sees
    is basically representable as an <acronym>SQL</acronym> statement.
-->
ルールシステムは問い合わせパーサとプランナの中間に位置します。
ルールシステムは、入力としてパーサの出力、単一の問い合わせツリー、および何らかの特別な情報を持つ問い合わせツリーでもあるユーザ定義の書き換えルールを取り、結果として0個以上の問い合わせツリーを生成します。
ルールシステムの入力と出力は常にパーサ自体でも生成することができるもので、参照する対象は基本的に<acronym>SQL</acronym>文として表現できるものです。
</para>

<para>
<!--
    Now what is a query tree? It is an internal representation of an
    <acronym>SQL</acronym> statement where the single parts that it is
    built from are stored separately. These query trees can be shown
    in the server log if you set the configuration parameters
    <varname>debug_print_parse</varname>,
    <varname>debug_print_rewritten</varname>, or
    <varname>debug_print_plan</varname>.  The rule actions are also
    stored as query trees, in the system catalog
    <structname>pg_rewrite</structname>.  They are not formatted like
    the log output, but they contain exactly the same information.
-->
では問い合わせツリーとは何でしょうか。
それは、<acronym>SQL</acronym>文を構成する個々の部品を別々に記憶した、<acronym>SQL</acronym>文の内部表現です。
<varname>debug_print_parse</varname>、<varname>debug_print_rewritten</varname>、もしくは<varname>debug_print_plan</varname>設定パラメータを設定していれば、サーバログ内で問い合わせツリーを見ることができます。
ルールアクションも<structname>pg_rewrite</structname>システムカタログ内に問い合わせツリーとして格納されています。
これはログ出力のように整形されていませんが、まったく同じ情報を持っています。
</para>

<para>
<!--
    Reading a raw query tree requires some experience.  But since
    <acronym>SQL</acronym> representations of query trees are
    sufficient to understand the rule system, this chapter will not
    teach how to read them.
-->
問い合わせツリーそのものを読むためにはある程度の経験が必要です。
ルールシステムを理解するためには問い合わせツリーの<acronym>SQL</acronym>表現で十分ですので、ここではその読み方までは教えません。
</para>

<para>
<!--
    When reading the <acronym>SQL</acronym> representations of the
    query trees in this chapter it is necessary to be able to identify
    the parts the statement is broken into when it is in the query tree
    structure. The parts of a query tree are
-->
本章の問い合わせツリーの<acronym>SQL</acronym>表現形式を読む時に必要なのは、問い合わせツリー構造の中に分解された、ある文の部品を識別できることです。
問い合わせツリーには以下の部品があります。

<variablelist>
    <varlistentry>
    <term>
<!--
        the command type
-->
コマンド種類
    </term>
    <listitem>
    <para>
<!--
        This is a simple value telling which command
        (<command>SELECT</command>, <command>INSERT</command>,
        <command>UPDATE</command>, <command>DELETE</command>) produced
        the query tree.
-->
これはどのコマンド（<command>SELECT</command>、<command>INSERT</command>、<command>UPDATE</command>、<command>DELETE</command>）が構文解析ツリーを作ったかを示す単純な値です。
    </para>
    </listitem>
    </varlistentry>

    <varlistentry>
    <term>
<!--
        the range table
      <indexterm><primary>range table</></>
-->
範囲テーブル
      <indexterm><primary>範囲テーブル</></>
    </term>
    <listitem>
    <para>
<!--
        The range table is a list of relations that are used in the query.
        In a <command>SELECT</command> statement these are the relations given after
        the <literal>FROM</literal> key word.
-->
範囲テーブルは問い合わせで使われるリレーションのリストです。
<command>SELECT</command>文ではこれは<literal>FROM</literal>キーワードの後で与えられるリレーションになります。
    </para>

    <para>
<!--
        Every range table entry identifies a table or view and tells
        by which name it is called in the other parts of the query.
        In the query tree, the range table entries are referenced by
        number rather than by name, so here it doesn't matter if there
        are duplicate names as it would in an <acronym>SQL</acronym>
        statement. This can happen after the range tables of rules
        have been merged in. The examples in this chapter will not have
        this situation.
-->
範囲テーブルのそれぞれの項目はテーブルもしくはビューを識別し、問い合わせの別の部品ではどんな名前で呼び出されるかを示します。
問い合わせツリーでは範囲テーブルの項目は名前よりも番号で参照されることが多いため、ここでは<acronym>SQL</acronym>文とは違い、重複する名前があるかということは問題になりません。
これはルールの範囲テーブルがマージされた後に起こる可能性があります。
本章の例ではその状況を含んでいません。
    </para>
    </listitem>
    </varlistentry>

    <varlistentry>
    <term>
<!--
        the result relation
-->
結果リレーション
    </term>
    <listitem>
    <para>
<!--
        This is an index into the range table that identifies the
        relation where the results of the query go.
-->
問い合わせの結果が格納されるリレーションを識別する範囲テーブルへのインデックスです。
    </para>

    <para>
<!--
        <command>SELECT</command> queries don't have a result
        relation. (The special case of <command>SELECT INTO</command> is
        mostly identical to <command>CREATE TABLE</command> followed by
        <literal>INSERT ... SELECT</literal>, and is not discussed
        separately here.)
-->
<command>SELECT</command>問い合わせは結果リレーションを持ちません。
（<command>SELECT INTO</command>の場合は特別ですが、<literal>INSERT ... SELECT</literal>が付いた<command>CREATE TABLE</command>とほぼ同じですので、ここでは個別には説明しません。）
    </para>

    <para>
<!--
        For <command>INSERT</command>, <command>UPDATE</command>, and
        <command>DELETE</command> commands, the result relation is the table
        (or view!) where the changes are to take effect.
-->
<command>INSERT</command>、<command>UPDATE</command>、<command>DELETE</command>コマンドでは、結果リレーションは変更が有効になるテーブル（もしくはビュー）です。
    </para>
    </listitem>
    </varlistentry>

    <varlistentry>
    <term>
<!--
        the target list
    <indexterm><primary>target list</></>
-->
目的リスト
    <indexterm><primary>目的リスト</></>
    </term>
    <listitem>
    <para>
<!--
        The target list is a list of expressions that define the
        result of the query.  In the case of a
        <command>SELECT</command>, these expressions are the ones that
        build the final output of the query.  They correspond to the
        expressions between the key words <command>SELECT</command>
        and <command>FROM</command>.  (<literal>*</literal> is just an
        abbreviation for all the column names of a relation.  It is
        expanded by the parser into the individual columns, so the
        rule system never sees it.)
-->
目的リストは問い合わせの結果を定義する式のリストです。
<command>SELECT</command>の場合、この式は問い合わせの最終結果を構築するものです。
これらは<command>SELECT</command>と<command>FROM</command>キーワードの間にある式に対応します
（<literal>*</literal>は単にリレーションの全ての列名の省略です。
これはパーサによって個別の列に展開されますので、ルールシステムが見ることはありません）。
    </para>

    <para>
<!--
        <command>DELETE</command> commands don't need a normal target list
        because they don't produce any result.  Instead, the rule system
        adds a special <acronym>CTID</> entry to the empty target list,
        to allow the executor to find the row to be deleted.
        (<acronym>CTID</> is added when the result relation is an ordinary
        table.  If it is a view, a whole-row variable is added instead,
        as described in <xref linkend="rules-views-update">.)
-->
<command>DELETE</command>コマンドは結果を返しませんので、通常の目的リストは必要ありません。
その代わり、ルールシステムは空の目的リストに特別な<acronym>CTID</>項目を追加し、エクゼキュータが削除すべき行を見つけられるようにします。
（<acronym>CTID</>は結果リレーションが通常のテーブルの場合に追加されます。
もしビューであれば<xref linkend="rules-views-update">で述べるように、代わりに行全体の変数が追加されます。）
    </para>

    <para>
<!--
        For <command>INSERT</command> commands, the target list describes
        the new rows that should go into the result relation. It consists of the
        expressions in the <literal>VALUES</> clause or the ones from the
        <command>SELECT</command> clause in <literal>INSERT
        ... SELECT</literal>.  The first step of the rewrite process adds
        target list entries for any columns that were not assigned to by
        the original command but have defaults.  Any remaining columns (with
        neither a given value nor a default) will be filled in by the
        planner with a constant null expression.
-->
<command>INSERT</command>問い合わせでは、目的リストは結果リレーションへ入る新規の行を示します。
これは<literal>VALUES</>句か<literal>INSERT ... SELECT</literal>の中の<command>SELECT</command>句の式です。
書き換え処理の最初のステップでは、元の問い合わせでは割り当てられず、デフォルト値となっている列の目的リストの項目を追加します。
残った列（値が与えられていない列、かつデフォルト値を持たない列）は全て、プランナによって定数NULL式で埋められます。
    </para>

    <para>
<!--
        For <command>UPDATE</command> commands, the target list
        describes the new rows that should replace the old ones. In the
        rule system, it contains just the expressions from the <literal>SET
        column = expression</literal> part of the command.  The planner will
        handle missing columns by inserting expressions that copy the values
        from the old row into the new one.  Just as for <command>DELETE</>,
        the rule system adds a <acronym>CTID</> or whole-row variable so that
        the executor can identify the old row to be updated.
-->
<command>UPDATE</command>コマンドでは、目的リストは古いものを置き換えるべき新しい行を示します。
ルールシステムではコマンド内の<literal>SET column = expression</literal>部分にある式だけを持っています。
プランナは、古い行から新しい行へ値をコピーする式を挿入することにより、抜けている列を処理します。
<command>DELETE</command>の場合と同様、エクゼキュータが更新すべき行を見つけられるように、ルールシステムは<acronym>CTID</>もしくは行全体の変数を追加します。
    </para>

    <para>
<!--
        Every entry in the target list contains an expression that can
        be a constant value, a variable pointing to a column of one
        of the relations in the range table, a parameter, or an expression
        tree made of function calls, constants, variables, operators, etc.
-->
目的リストの各項目は、定数値、範囲テーブル内のリレーション中の1つの列を指し示す変数、パラメータ等の式を保持するか、または、関数呼び出し、定数、変数、演算子などにより作られた式のツリーを保持します。
    </para>
    </listitem>
    </varlistentry>

    <varlistentry>
    <term>
<!--
        the qualification
-->
条件
    </term>
    <listitem>
    <para>
<!--
        The query's qualification is an expression much like one of
        those contained in the target list entries. The result value of
        this expression is a Boolean that tells whether the operation
        (<command>INSERT</command>, <command>UPDATE</command>,
        <command>DELETE</command>, or <command>SELECT</command>) for the
        final result row should be executed or not. It corresponds to the <literal>WHERE</> clause
        of an <acronym>SQL</acronym> statement.
-->
問い合わせの条件は目的リストの項目に含まれている式によく似た式です。
この式の結果は、最終的な結果の行を得るための（<command>INSERT</command>、<command>UPDATE</command>、<command>DELETE</command>または<command>SELECT</command>）演算を実行すべきかどうかを示すブール値です。
それは<acronym>SQL</acronym>文の中の<literal>WHERE</>句に対応します。
    </para>
    </listitem>
    </varlistentry>

    <varlistentry>
    <term>
<!--
        the join tree
-->
結合ツリー
    </term>
    <listitem>
    <para>
<!--
        The query's join tree shows the structure of the <literal>FROM</> clause.
        For a simple query like <literal>SELECT ... FROM a, b, c</literal>, the join tree is just
        a list of the <literal>FROM</> items, because we are allowed to join them in
        any order.  But when <literal>JOIN</> expressions, particularly outer joins,
        are used, we have to join in the order shown by the joins.
        In that case, the join tree shows the structure of the <literal>JOIN</> expressions.  The
        restrictions associated with particular <literal>JOIN</> clauses (from <literal>ON</> or
        <literal>USING</> expressions) are stored as qualification expressions attached
        to those join-tree nodes.  It turns out to be convenient to store
        the top-level <literal>WHERE</> expression as a qualification attached to the
        top-level join-tree item, too.  So really the join tree represents
        both the <literal>FROM</> and <literal>WHERE</> clauses of a <command>SELECT</command>.
-->
問い合わせの結合ツリーは<literal>FROM</>句の構造を表します。
<literal>SELECT ... FROM a, b, c</literal>のような単純な問い合わせでは、結合ツリーは単なる<literal>FROM</>項目のリストです。
なぜならこれらはどんな順番で結合しても構わないためです。
しかし<literal>JOIN</>式、特に外部結合が使われた場合は、その結合が示す順番通りに結合しなければいけません。
この場合結合ツリーは<literal>JOIN</>式の構造を表します。
特定の<literal>JOIN</>句と関連付けられた制約（<literal>ON</>もしくは<literal>USING</>式からのもの）はこれらの結合ツリーノードに付加された条件として格納されます。
頂点レベルの<literal>WHERE</>式を頂点レベルの結合ツリー項目に付加された条件として格納することも便利です。
ですから、結合ツリーは<command>SELECT</command>の<literal>FROM</>句と<literal>WHERE</>句の両方を表しているわけです。
    </para>
    </listitem>
    </varlistentry>

    <varlistentry>
    <term>
<!--
        the others
-->
その他
    </term>
    <listitem>
    <para>
<!--
        The other parts of the query tree like the <literal>ORDER BY</>
        clause aren't of interest here. The rule system
        substitutes some entries there while applying rules, but that
        doesn't have much to do with the fundamentals of the rule
        system.
-->
<literal>ORDER BY</>句のような、問い合わせツリーのその他の部品は、ここでは取り上げません。
ルールシステムはルールを適用している時にそこで項目を入れ替えることもありますが、これはルールシステムの基本とはあまり関係しません。
    </para>
    </listitem>
    </varlistentry>

</variablelist>
</para>
</sect1>

<sect1 id="rules-views">
<!--
<title>Views and the Rule System</title>
-->
<title>ビューとルールシステム</title>

<indexterm zone="rules-views">
<!--
 <primary>rule</primary>
 <secondary>and views</secondary>
-->
 <primary>ルール</primary>
 <secondary>とビュー</secondary>
</indexterm>

<indexterm zone="rules-views">
<!--
 <primary>view</>
 <secondary>implementation through rules</>
-->
 <primary>ビュー</>
 <secondary>ルールを使用した実装</>
</indexterm>

<para>
<!--
    Views in <productname>PostgreSQL</productname> are implemented
    using the rule system. In fact, there is essentially no difference
    between:
-->
<productname>PostgreSQL</productname>におけるビューはルールシステムを使って実装されています。 
実際、

<programlisting>
CREATE VIEW myview AS SELECT * FROM mytab;
</programlisting>

<!--
    compared against the two commands:
-->
と

<programlisting>
CREATE TABLE myview (<replaceable>same column list as mytab</replaceable>);
CREATE RULE "_RETURN" AS ON SELECT TO myview DO INSTEAD
    SELECT * FROM mytab;
</programlisting>
の2つのコマンドの間には基本的な違いはありません。

<!--
    because this is exactly what the <command>CREATE VIEW</command>
    command does internally.  This has some side effects. One of them
    is that the information about a view in the
    <productname>PostgreSQL</productname> system catalogs is exactly
    the same as it is for a table. So for the parser, there is
    absolutely no difference between a table and a view. They are the
    same thing: relations.
-->
と言うのは、<command>CREATE VIEW</command>コマンドによって内部的にまったく同じコマンドが行われるからです。
これには副作用もあります。
その1つは<productname>PostgreSQL</productname>システムカタログのビューについての情報はテーブルの情報とまったく同一であるということです。
そのため、パーサにとってはテーブルとビューの間に違いは一切ありません。
これらは同じもの、つまりリレーションです。
</para>

<sect2 id="rules-select">
<!--
<title>How <command>SELECT</command> Rules Work</title>
-->
<title><command>SELECT</command>ルールの動き</title>

<indexterm zone="rules-select">
<!--
 <primary>rule</primary>
 <secondary sortas="SELECT">for SELECT</secondary>
-->
 <primary>ルール</primary>
 <secondary sortas="SELECT">SELECT用</secondary>
</indexterm>

<para>
<!--
    Rules <literal>ON SELECT</> are applied to all queries as the last step, even
    if the command given is an <command>INSERT</command>,
    <command>UPDATE</command> or <command>DELETE</command>. And they
    have different semantics from rules on the other command types in that they modify the
    query tree in place instead of creating a new one.  So
    <command>SELECT</command> rules are described first.
-->
たとえコマンドが<command>INSERT</command>、<command>UPDATE</command>、<command>DELETE</command>などであっても、<literal>ON SELECT</>ルールは全ての問い合わせに対し最後に適用されます。
そして、このルールは他のコマンド種類のルールと異なるセマンティックを持っていて、問い合わせツリーを新規に生成せずに、そこにあるものを修正します。
したがって<command>SELECT</command>ルールを一番初めに記述します。
</para>

<para>
<!--
    Currently, there can be only one action in an <literal>ON SELECT</> rule, and it must
    be an unconditional <command>SELECT</> action that is <literal>INSTEAD</>. This restriction was
    required to make rules safe enough to open them for ordinary users, and
    it restricts <literal>ON SELECT</> rules to act like views.
-->
現在のところ、<literal>ON SELECT</>ルールでは1つのアクションしか許されず、それは<literal>INSTEAD</>である無条件の<command>SELECT</>アクションでなければいけません。
この制約は、一般のユーザが何をしても、ルールシステムが堅牢であるために必要であり、<literal>ON SELECT</>のルールはビュー同様の動作に限定されます。
</para>

<para>
<!--
    The examples for this chapter are two join views that do some
    calculations and some more views using them in turn.  One of the
    two first views is customized later by adding rules for
    <command>INSERT</command>, <command>UPDATE</command>, and
    <command>DELETE</command> operations so that the final result will
    be a view that behaves like a real table with some magic
    functionality.  This is not such a simple example to start from and
    this makes things harder to get into. But it's better to have one
    example that covers all the points discussed step by step rather
    than having many different ones that might mix up in mind.
-->
本章の例として挙げているのは、ちょっとした演算をする2つの結合のビューと、次にこれらの機能を利用するいくつかのビューです。
初めの2つのビューのうちの1つは、<command>INSERT</command>、<command>UPDATE</command>、<command>DELETE</command>操作に対するルールを後で追加することでカスタマイズされ、最終結果は何らかの魔法の機能によりあたかも実テーブルのように振舞うビューになります。
初めて学ぶための例としては決して簡単ではなく先に進むことを躊躇させるかもしれませんが、多くの別々の例を持ち出して頭の混乱を招くよりも、全ての論点をステップごとに追う1つの例を挙げる方が良いでしょう。
</para>

<para>
<!--
For the example, we need a little <literal>min</literal> function that
returns the lower of 2 integer values. We create that as:
-->
この例では、2つの整数から小さな値を返すちょっとした<literal>min</literal>関数を必要とします。
関数の生成は以下のようにします。

<programlisting>
CREATE FUNCTION min(integer, integer) RETURNS integer AS $$
    SELECT CASE WHEN $1 &lt; $2 THEN $1 ELSE $2 END
$$ LANGUAGE SQL STRICT;
</programlisting>
</para>

<para>
<!--
    The real tables we need in the first two rule system descriptions
    are these:
-->
最初の2つのルールシステムの説明で必要とする実テーブルを以下に示します。

<programlisting>
<!--
CREATE TABLE shoe_data (
    shoename   text,          &#045;- primary key
    sh_avail   integer,       &#045;- available number of pairs
    slcolor    text,          &#045;- preferred shoelace color
    slminlen   real,          &#045;- minimum shoelace length
    slmaxlen   real,          &#045;- maximum shoelace length
    slunit     text           &#045;- length unit
);

CREATE TABLE shoelace_data (
    sl_name    text,          &#045;- primary key
    sl_avail   integer,       &#045;- available number of pairs
    sl_color   text,          &#045;- shoelace color
    sl_len     real,          &#045;- shoelace length
    sl_unit    text           &#045;- length unit
);

CREATE TABLE unit (
    un_name    text,          &#045;- primary key
    un_fact    real           &#045;- factor to transform to cm
);
-->
CREATE TABLE shoe_data (
    shoename   text,          -- プライマリキー
    sh_avail   integer,       -- 在庫
    slcolor    text,          -- 望ましい靴紐の色
    slminlen   real,          -- 靴紐の最短サイズ
    slmaxlen   real,          -- 靴紐の最長サイズ
    slunit     text           -- 長さの単位
);

CREATE TABLE shoelace_data (
    sl_name    text,          -- プライマリキー
    sl_avail   integer,       -- 在庫
    sl_color   text,          -- 靴紐の色
    sl_len     real,          -- 靴紐の長さ
    sl_unit    text           -- 長さの単位
);

CREATE TABLE unit (
    un_name    text,          -- プライマリキー
    un_fact    real           -- cmに変換するファクタ
);
</programlisting>

<!--
    As you can see, they represent shoe-store data.
-->
これでわかるかもしれませんが、これらは靴屋のデータを表しています。
</para>

<para>
<!--
    The views are created as:
-->
ビューを以下のように作成します。

<programlisting>
CREATE VIEW shoe AS
    SELECT sh.shoename,
           sh.sh_avail,
           sh.slcolor,
           sh.slminlen,
           sh.slminlen * un.un_fact AS slminlen_cm,
           sh.slmaxlen,
           sh.slmaxlen * un.un_fact AS slmaxlen_cm,
           sh.slunit
      FROM shoe_data sh, unit un
     WHERE sh.slunit = un.un_name;

CREATE VIEW shoelace AS
    SELECT s.sl_name,
           s.sl_avail,
           s.sl_color,
           s.sl_len,
           s.sl_unit,
           s.sl_len * u.un_fact AS sl_len_cm
      FROM shoelace_data s, unit u
     WHERE s.sl_unit = u.un_name;

CREATE VIEW shoe_ready AS
    SELECT rsh.shoename,
           rsh.sh_avail,
           rsl.sl_name,
           rsl.sl_avail,
           min(rsh.sh_avail, rsl.sl_avail) AS total_avail
      FROM shoe rsh, shoelace rsl
     WHERE rsl.sl_color = rsh.slcolor
       AND rsl.sl_len_cm &gt;= rsh.slminlen_cm
       AND rsl.sl_len_cm &lt;= rsh.slmaxlen_cm;
</programlisting>

<!--
    The <command>CREATE VIEW</command> command for the
    <literal>shoelace</literal> view (which is the simplest one we
    have) will create a relation <literal>shoelace</> and an entry in
    <structname>pg_rewrite</structname> that tells that there is a
    rewrite rule that must be applied whenever the relation <literal>shoelace</>
    is referenced in a query's range table.  The rule has no rule
    qualification (discussed later, with the non-<command>SELECT</> rules, since
    <command>SELECT</> rules currently cannot have them) and it is <literal>INSTEAD</>. Note
    that rule qualifications are not the same as query qualifications.
    The action of our rule has a query qualification.
    The action of the rule is one query tree that is a copy of the
    <command>SELECT</command> statement in the view creation command.
-->
<literal>shoelace</literal>ビュー（今ある一番簡単なビュー）用の<command>CREATE VIEW</command>コマンドは、<literal>shoelace</>リレーションと、問い合わせ範囲テーブルの中で<literal>shoelace</>リレーションが参照される時はいつでも、適用されるべき書き換えルールの存在を示す項目を<structname>pg_rewrite</structname>に作ります。
ルールはルール条件（<command>SELECT</>ルールは現在持つことができませんので、非<command>SELECT</>ルールのところで取り上げます）を持たない<literal>INSTEAD</>です。
ルール条件は問い合わせ条件とは異なることに注意してください！
ルールアクションは問い合わせ条件を持っています。
このルールアクションは、ビュー作成コマンド内の<command>SELECT</command>のコピーである、1つの問い合わせツリーです。
</para>

    <note>
    <para>
<!--
    The two extra range
    table entries for <literal>NEW</> and <literal>OLD</> that you can see in
    the <structname>pg_rewrite</structname> entry aren't of interest
    for <command>SELECT</command> rules.
-->
<structname>pg_rewrite</structname>項目の<literal>NEW</>と<literal>OLD</>に対する2つの特別な範囲テーブル項目は<command>SELECT</command>ルールには関係ありません。
    </para>
    </note>

<para>
<!--
    Now we populate <literal>unit</literal>, <literal>shoe_data</literal>
    and <literal>shoelace_data</literal> and run a simple query on a view:
-->
ではここで<literal>unit</literal>、<literal>shoe_data</literal>、<literal>shoelace_data</literal>にデータを入れ、ビューに簡単な問い合わせを行います。

<programlisting>
INSERT INTO unit VALUES ('cm', 1.0);
INSERT INTO unit VALUES ('m', 100.0);
INSERT INTO unit VALUES ('inch', 2.54);

INSERT INTO shoe_data VALUES ('sh1', 2, 'black', 70.0, 90.0, 'cm');
INSERT INTO shoe_data VALUES ('sh2', 0, 'black', 30.0, 40.0, 'inch');
INSERT INTO shoe_data VALUES ('sh3', 4, 'brown', 50.0, 65.0, 'cm');
INSERT INTO shoe_data VALUES ('sh4', 3, 'brown', 40.0, 50.0, 'inch');

INSERT INTO shoelace_data VALUES ('sl1', 5, 'black', 80.0, 'cm');
INSERT INTO shoelace_data VALUES ('sl2', 6, 'black', 100.0, 'cm');
INSERT INTO shoelace_data VALUES ('sl3', 0, 'black', 35.0 , 'inch');
INSERT INTO shoelace_data VALUES ('sl4', 8, 'black', 40.0 , 'inch');
INSERT INTO shoelace_data VALUES ('sl5', 4, 'brown', 1.0 , 'm');
INSERT INTO shoelace_data VALUES ('sl6', 0, 'brown', 0.9 , 'm');
INSERT INTO shoelace_data VALUES ('sl7', 7, 'brown', 60 , 'cm');
INSERT INTO shoelace_data VALUES ('sl8', 1, 'brown', 40 , 'inch');

SELECT * FROM shoelace;

 sl_name   | sl_avail | sl_color | sl_len | sl_unit | sl_len_cm
-----------+----------+----------+--------+---------+-----------
 sl1       |        5 | black    |     80 | cm      |        80
 sl2       |        6 | black    |    100 | cm      |       100
 sl7       |        7 | brown    |     60 | cm      |        60
 sl3       |        0 | black    |     35 | inch    |      88.9
 sl4       |        8 | black    |     40 | inch    |     101.6
 sl8       |        1 | brown    |     40 | inch    |     101.6
 sl5       |        4 | brown    |      1 | m       |       100
 sl6       |        0 | brown    |    0.9 | m       |        90
(8 rows)
</programlisting>
   </para>

   <para>
<!--
    This is the simplest <command>SELECT</command> you can do on our
    views, so we take this opportunity to explain the basics of view
    rules.  The <literal>SELECT * FROM shoelace</literal> was
    interpreted by the parser and produced the query tree:
-->
これは、ビューに対する最も簡単な<command>SELECT</command>ですので、この機会にビュールールの基本を説明します。
<literal>SELECT * FROM shoelace</literal>はパーサによって処理され、次の問い合わせツリーが生成されます。

<programlisting>
SELECT shoelace.sl_name, shoelace.sl_avail,
       shoelace.sl_color, shoelace.sl_len,
       shoelace.sl_unit, shoelace.sl_len_cm
  FROM shoelace shoelace;
</programlisting>

<!--
    and this is given to the rule system. The rule system walks through the
    range table and checks if there are rules
    for any relation. When processing the range table entry for
    <literal>shoelace</literal> (the only one up to now) it finds the
    <literal>_RETURN</literal> rule with the query tree:
-->
このツリーがルールシステムに伝えられます。
ルールシステムは範囲テーブルを参照し、何らかのリレーションに対してルールが存在するか調べます。
<literal>shoelace</literal>（現時点では唯一のビュー）についての範囲テーブル項目を処理する際、問い合わせツリーで<literal>_RETURN</literal>ルールを検出します。

<programlisting>
SELECT s.sl_name, s.sl_avail,
       s.sl_color, s.sl_len, s.sl_unit,
       s.sl_len * u.un_fact AS sl_len_cm
  FROM shoelace old, shoelace new,
       shoelace_data s, unit u
 WHERE s.sl_unit = u.un_name;
</programlisting>
</para>

<para>
<!--
    To expand the view, the rewriter simply creates a subquery range-table
    entry containing the rule's action query tree, and substitutes this
    range table entry for the original one that referenced the view.  The
    resulting rewritten query tree is almost the same as if you had typed:
-->
ビューを展開するために、リライタは単純にルールのアクション問い合わせツリーを持つ副問い合わせ範囲テーブルの項目を作り、ビューを参照していた元の範囲テーブルを置き換えます。
書き換えられた結果の問い合わせツリーは、以下のように入力した場合とほぼ同じです。

<programlisting>
SELECT shoelace.sl_name, shoelace.sl_avail,
       shoelace.sl_color, shoelace.sl_len,
       shoelace.sl_unit, shoelace.sl_len_cm
  FROM (SELECT s.sl_name,
               s.sl_avail,
               s.sl_color,
               s.sl_len,
               s.sl_unit,
               s.sl_len * u.un_fact AS sl_len_cm
          FROM shoelace_data s, unit u
         WHERE s.sl_unit = u.un_name) shoelace;
</programlisting>

<!--
     There is one difference however: the subquery's range table has two
     extra entries <literal>shoelace old</> and <literal>shoelace new</>.  These entries don't
     participate directly in the query, since they aren't referenced by
     the subquery's join tree or target list.  The rewriter uses them
     to store the access privilege check information that was originally present
     in the range-table entry that referenced the view.  In this way, the
     executor will still check that the user has proper privileges to access
     the view, even though there's no direct use of the view in the rewritten
     query.
-->
しかし1つだけ違いがあります。
副問い合わせの範囲テーブルが2つの余分な項目<literal>shoelace old</>と<literal>shoelace new</>を持っていることです。
これらの項目は副問い合わせの結合ツリーや目的リストで参照されませんので、直接問い合わせでは使われません。
リライタはそれらを使用して、ビューを参照した範囲テーブルの項目に元々存在したアクセス権限確認情報を格納します。
この方法で、書き換えられた問い合わせで直接ビューを使用していなくても、エクゼキュータはユーザがそのビューにアクセスするための正しい権限を持っているか確認します。
</para>

<para>
<!--
    That was the first rule applied.  The rule system will continue checking
    the remaining range-table entries in the top query (in this example there
    are no more), and it will recursively check the range-table entries in
    the added subquery to see if any of them reference views.  (But it
    won't expand <literal>old</> or <literal>new</> &mdash; otherwise we'd have infinite recursion!)
    In this example, there are no rewrite rules for <literal>shoelace_data</> or <literal>unit</>,
    so rewriting is complete and the above is the final result given to
    the planner.
-->
これが最初に適用されるルールです。
ルールシステムは最上位の問い合わせの残り（この例ではこれ以上ありません）の範囲テーブルの項目をチェックし続けます。
そしてルールシステムは、追加された副問い合わせの範囲テーブルの項目がビューを参照するかを再帰的に確認します
（しかし<literal>old</>や<literal>new</>は展開しません。
そうでなければ無限再帰になってしまいます！）。
この例では<literal>shoelace_data</>や<literal>unit</>用の書き換えルールはありません。
ですから書き換えは完結し、上記がプランナに渡される最終的な結果となります。
</para>

<para>
<!--
    Now we want to write a query that finds out for which shoes currently in the store
    we have the matching shoelaces (color and length) and where the
    total number of exactly matching pairs is greater or equal to two.
-->
さて、店に置いてある靴紐（の色とサイズ）に一致する靴が店にあるか、完全に一致する靴紐の在庫数が2以上あるかどうかを把握する問い合わせを書いてみましょう。

<programlisting>
SELECT * FROM shoe_ready WHERE total_avail &gt;= 2;

 shoename | sh_avail | sl_name | sl_avail | total_avail
----------+----------+---------+----------+-------------
 sh1      |        2 | sl1     |        5 |           2
 sh3      |        4 | sl7     |        7 |           4
(2 rows)
</programlisting>
</para>

<para>
<!--
    The output of the parser this time is the query tree:
-->
今回のパーサの出力は以下の問い合わせツリーです。

<programlisting>
SELECT shoe_ready.shoename, shoe_ready.sh_avail,
       shoe_ready.sl_name, shoe_ready.sl_avail,
       shoe_ready.total_avail
  FROM shoe_ready shoe_ready
 WHERE shoe_ready.total_avail &gt;= 2;
</programlisting>

<!--
    The first rule applied will be the one for the
    <literal>shoe_ready</literal> view and it results in the
    query tree:
-->
最初に適用されるルールは<literal>shoe_ready</literal>ビュー用のもので、問い合わせツリーにおける結果は以下のようになります。

<programlisting>
SELECT shoe_ready.shoename, shoe_ready.sh_avail,
       shoe_ready.sl_name, shoe_ready.sl_avail,
       shoe_ready.total_avail
  FROM (SELECT rsh.shoename,
               rsh.sh_avail,
               rsl.sl_name,
               rsl.sl_avail,
               min(rsh.sh_avail, rsl.sl_avail) AS total_avail
          FROM shoe rsh, shoelace rsl
         WHERE rsl.sl_color = rsh.slcolor
           AND rsl.sl_len_cm &gt;= rsh.slminlen_cm
           AND rsl.sl_len_cm &lt;= rsh.slmaxlen_cm) shoe_ready
 WHERE shoe_ready.total_avail &gt;= 2;
</programlisting>

<!--
    Similarly, the rules for <literal>shoe</literal> and
    <literal>shoelace</literal> are substituted into the range table of
    the subquery, leading to a three-level final query tree:
-->
同じように、<literal>shoe</literal>と<literal>shoelace</literal>用のルールは副問い合わせの範囲テーブルとして代用され、3レベルの最終問い合わせツリーへと導きます。

<programlisting>
SELECT shoe_ready.shoename, shoe_ready.sh_avail,
       shoe_ready.sl_name, shoe_ready.sl_avail,
       shoe_ready.total_avail
  FROM (SELECT rsh.shoename,
               rsh.sh_avail,
               rsl.sl_name,
               rsl.sl_avail,
               min(rsh.sh_avail, rsl.sl_avail) AS total_avail
          FROM (SELECT sh.shoename,
                       sh.sh_avail,
                       sh.slcolor,
                       sh.slminlen,
                       sh.slminlen * un.un_fact AS slminlen_cm,
                       sh.slmaxlen,
                       sh.slmaxlen * un.un_fact AS slmaxlen_cm,
                       sh.slunit
                  FROM shoe_data sh, unit un
                 WHERE sh.slunit = un.un_name) rsh,
               (SELECT s.sl_name,
                       s.sl_avail,
                       s.sl_color,
                       s.sl_len,
                       s.sl_unit,
                       s.sl_len * u.un_fact AS sl_len_cm
                  FROM shoelace_data s, unit u
                 WHERE s.sl_unit = u.un_name) rsl
         WHERE rsl.sl_color = rsh.slcolor
           AND rsl.sl_len_cm &gt;= rsh.slminlen_cm
           AND rsl.sl_len_cm &lt;= rsh.slmaxlen_cm) shoe_ready
 WHERE shoe_ready.total_avail &gt; 2;
</programlisting>
   </para>

   <para>
<!--
    It turns out that the planner will collapse this tree into a
    two-level query tree: the bottommost <command>SELECT</command>
    commands will be <quote>pulled up</quote> into the middle
    <command>SELECT</command> since there's no need to process them
    separately.  But the middle <command>SELECT</command> will remain
    separate from the top, because it contains aggregate functions.
    If we pulled those up it would change the behavior of the topmost
    <command>SELECT</command>, which we don't want.  However,
    collapsing the query tree is an optimization that the rewrite
    system doesn't have to concern itself with.
-->
次にプランナはこのツリーを2レベルの問い合わせツリーに縮めます。
一番下の<command>SELECT</command>コマンドは別々に処理する必要がありませんので2つ目の<command>SELECT</command>に<quote>引っ張り上げ</quote>られます。
しかし2つ目の<command>SELECT</command>は集約関数を持つため、頂点からは区別されます。
もしそれらを引っ張り上げてしまうと一番上の<command>SELECT</command>の動作を変えてしまうことになり、それはしたくありません。
しかし、問い合わせツリーを縮めるという最適化を、書き換えシステム自身で意識する必要はありません。
   </para>
</sect2>

<sect2>
<!--
<title>View Rules in Non-<command>SELECT</command> Statements</title>
-->
<title>非<command>SELECT</command>文のビュールール</title>

<para>
<!--
    Two details of the query tree aren't touched in the description of
    view rules above. These are the command type and the result relation.
    In fact, the command type is not needed by view rules, but the result
    relation may affect the way in which the query rewriter works, because
    special care needs to be taken if the result relation is a view.
-->
これまでのビュールールの説明では問い合わせツリーの2つの詳細について触れませんでした。
それらは、コマンドタイプと結果リレーションです。
実際、コマンドタイプはビュールールでは必要とされませんが、結果リレーションがビューの場合には特別な考慮が必要ですので、結果リレーションは問い合わせリライタの動作に影響するかもしれません。
</para>

<para>
<!--
    There are only a few differences between a query tree for a
    <command>SELECT</command> and one for any other
    command. Obviously, they have a different command type and for a
    command other than a <command>SELECT</command>, the result
    relation points to the range-table entry where the result should
    go.  Everything else is absolutely the same.  So having two tables
    <literal>t1</> and <literal>t2</> with columns <literal>a</> and
    <literal>b</>, the query trees for the two statements:
-->
<command>SELECT</command>と他のコマンドに対する問い合わせツリーの間には大きな違いはありません。
明らかに、それらは違うコマンドタイプを持っていて、<command>SELECT</command>以外のコマンドでは、結果リレーションは結果の格納先となる範囲テーブルの項目を指し示します。
それ以外ではまったく同じです。
ですから、<literal>a</>と<literal>b</>の列を持つテーブル<literal>t1</>、<literal>t2</>に対する以下の2つの文の問い合わせツリーは、ほとんど同じです。

<programlisting>
SELECT t2.b FROM t1, t2 WHERE t1.a = t2.a;

UPDATE t1 SET b = t2.b FROM t2 WHERE t1.a = t2.a;
</programlisting>

<!--
    are nearly identical.  In particular:
-->
以下に、具体的に示します。

    <itemizedlist>
        <listitem>
        <para>
<!--
            The range tables contain entries for the tables <literal>t1</> and <literal>t2</>.
-->
範囲テーブルには、テーブル<literal>t1</>と<literal>t2</>に対する項目があります。
        </para>
        </listitem>

        <listitem>
        <para>
<!--
            The target lists contain one variable that points to column
            <literal>b</> of the range table entry for table <literal>t2</>.
-->
目的リストにはテーブル<literal>t2</>に対する範囲テーブル項目の<literal>b</>列を指し示す1つの変数があります。
        </para>
        </listitem>

        <listitem>
        <para>
<!--
            The qualification expressions compare the columns <literal>a</> of both
            range-table entries for equality.
-->
条件式は、範囲テーブルの両項目の<literal>a</>列の等価性を比較します。
        </para>
        </listitem>

        <listitem>
        <para>
<!--
            The join trees show a simple join between <literal>t1</> and <literal>t2</>.
-->
結合ツリーは<literal>t1</>と<literal>t2</>の単純な結合を表しています。
        </para>
        </listitem>
    </itemizedlist>
   </para>

   <para>
<!--
    The consequence is, that both query trees result in similar
    execution plans: They are both joins over the two tables. For the
    <command>UPDATE</command> the missing columns from <literal>t1</> are added to
    the target list by the planner and the final query tree will read
    as:
-->
結果として、両方の問い合わせツリーは似たような実行計画になります。
それらはともに2つのテーブルの結合です。
<command>UPDATE</command>では<literal>t1</>から抜けている列はプランナによって目的リストに追加され、最終の問い合わせツリーは、以下のようになります。

<programlisting>
UPDATE t1 SET a = t1.a, b = t2.b FROM t2 WHERE t1.a = t2.a;
</programlisting>

<!--
    and thus the executor run over the join will produce exactly the
    same result set as:
-->
そして、結合を実行したエクゼキュータは、

<programlisting>
SELECT t1.a, t2.b FROM t1, t2 WHERE t1.a = t2.a;
</programlisting>

<!--
    But there is a little problem in
    <command>UPDATE</command>: the part of the executor plan that does
    the join does not care what the results from the join are
    meant for. It just produces a result set of rows. The fact that
    one is a <command>SELECT</command> command and the other is an
    <command>UPDATE</command> is handled higher up in the executor, where
    it knows that this is an <command>UPDATE</command>, and it knows that
    this result should go into table <literal>t1</>. But which of the rows
    that are there has to be replaced by the new row?
-->
の結果集合とまったく同じ結果集合を作成します。
とは言っても<command>UPDATE</command>にはちょっとした問題があります。
結合を行うエクゼキュータの計画の部分は、結合の結果が何に向けられているかに関与しません。
エクゼキュータは単に結果となる行の集合を作成するだけです。
1つは<command>SELECT</command>コマンドでもう1つは<command>UPDATE</command>コマンドであるという事実は、エクゼキュータの中のより上位で扱われます。
そこでは、これが<command>UPDATE</command>であるとわかっていて、この結果がテーブル<literal>t1</>に入らなければいけないことを知っています。
しかし、そこにあるどの行が新しい行によって置換されなければならないのでしょうか。
</para>

<para>
<!--
    To resolve this problem, another entry is added to the target list
    in <command>UPDATE</command> (and also in
    <command>DELETE</command>) statements: the current tuple ID
    (<acronym>CTID</>).<indexterm><primary>CTID</></>
    This is a system column containing the
    file block number and position in the block for the row. Knowing
    the table, the <acronym>CTID</> can be used to retrieve the
    original row of <literal>t1</> to be updated.  After adding the
    <acronym>CTID</> to the target list, the query actually looks like:
-->
この問題を解決するため、<command>UPDATE</command>文（<command>DELETE</command>文の場合も同様）の目的リストに別の項目が付け加えられます。
それは、現在のタプルID（<acronym>CTID</>）です。
<indexterm><primary>CTID</></>
これはその行のファイルブロック番号とブロック中の位置を持つシステム列です。
テーブルがわかっている場合、<acronym>CTID</>を使用して、元の<literal>t1</>行を抽出して更新することができます。
<acronym>CTID</>を目的リストに追加すると、問い合わせは以下のようになります。

<programlisting>
SELECT t1.a, t2.b, t1.ctid FROM t1, t2 WHERE t1.a = t2.a;
</programlisting>

<!--
    Now another detail of <productname>PostgreSQL</productname> enters
    the stage. Old table rows aren't overwritten, and this
    is why <command>ROLLBACK</command> is fast. In an <command>UPDATE</command>,
    the new result row is inserted into the table (after stripping the
    <acronym>CTID</>) and in the row header of the old row, which the
    <acronym>CTID</> pointed to, the <literal>cmax</> and
    <literal>xmax</> entries are set to the current command counter
    and current transaction ID. Thus the old row is hidden, and after
    the transaction commits the vacuum cleaner can eventually remove
    the dead row.
-->
では、<productname>PostgreSQL</productname>の別の詳細説明に入りましょう。
テーブルの行は上書きされませんので、<command>ROLLBACK</command>処理は速いのです。
<command>UPDATE</command>では、（<acronym>CTID</>を取り除いた後）テーブルに新しい結果行が挿入され、<acronym>CTID</>が指し示す古い行の行ヘッダ内の<literal>cmax</>と<literal>xmax</>項目は現在のコマンドカウンタと現在のトランザクションIDに設定されます。 
このようにして、古い行は隠され、トランザクションがコミットされた後、vacuum掃除機が不必要になった行をそのうちに削除できます。
</para>

<para>
<!--
    Knowing all that, we can simply apply view rules in absolutely
    the same way to any command. There is no difference.
-->
これらの詳細が全部理解できれば、どんなコマンドに対してもまったく同じようにしてビューのルールを簡単に適用することができます。
そこには差異がありません。
</para>
</sect2>

<sect2>
<!--
<title>The Power of Views in <productname>PostgreSQL</productname></title>
-->
<title><productname>PostgreSQL</productname>におけるビューの能力</title>

<para>
<!--
    The above demonstrates how the rule system incorporates view
    definitions into the original query tree. In the second example, a
    simple <command>SELECT</command> from one view created a final
    query tree that is a join of 4 tables (<literal>unit</> was used twice with
    different names).
-->
ここまでで、ルールシステムがどのようにビューの諸定義を元の問い合わせツリーに組み入れるかを解説しました。
第2の例では、1つのビューからの単純な<command>SELECT</command>によって、最終的に4つのテーブルを結合する問い合わせツリーが生成されました（<literal>unit</>は違った名前で2回使われました）。
</para>

<para>
<!--
    The benefit of implementing views with the rule system is,
    that the planner has all
    the information about which tables have to be scanned plus the
    relationships between these tables plus the restrictive
    qualifications from the views plus the qualifications from
    the original query
    in one single query tree. And this is still the situation
    when the original query is already a join over views.
    The planner has to decide which is
    the best path to execute the query, and the more information
    the planner has, the better this decision can be. And
    the rule system as implemented in <productname>PostgreSQL</productname>
    ensures, that this is all information available about the query
    up to that point.
-->
ビューをルールシステムで実装する利点は、どのテーブルをスキャンすべきか、それらのテーブル間の関連性、ビューからの制約条件、元の問い合わせ条件に関する情報を全て、プランナが1つの問い合わせツリーの中に持っていることです。
元の問い合わせが既にビューに対する結合である時も同様です。
プランナはここでどれが問い合わせ処理の最適経路かを決定しなければなりません。
プランナは保持する情報が多ければ多いほど、より良い決定を下すことができます。
そして<productname>PostgreSQL</productname>に実装されているルールシステムはこれが現時点で、提供されている全ての情報であることを保証します。
</para>
</sect2>

<sect2 id="rules-views-update">
<!--
<title>Updating a View</title>
-->
<title>ビューの更新について</title>

<para>
<!--
    What happens if a view is named as the target relation for an
    <command>INSERT</command>, <command>UPDATE</command>, or
    <command>DELETE</command>?  Doing the substitutions
    described above would give a query tree in which the result
    relation points at a subquery range-table entry, which will not
    work.  There are several ways in which <productname>PostgreSQL</>
    can support the appearance of updating a view, however.
-->
ビューが<command>INSERT</command>、<command>UPDATE</command>、<command>DELETE</command>などの目的リレーションとして名付けられた場合はどうなるのでしょうか？
上で説明したような置換をすると、結果リレーションが副問い合わせの範囲テーブル項目を指す問い合わせツリーができてしまい、それは上手く機能しません。しかし、いくつかのケースでは<productname>PostgreSQL</>はビューの更新をサポートする事ができます。
</para>

<para>
<!--
    If the subquery selects from a single base relation and is simple
    enough, the rewriter can automatically replace the subquery with the
    underlying base relation so that the <command>INSERT</command>,
    <command>UPDATE</command>, or <command>DELETE</command> is applied to
    the base relation in the appropriate way.  Views that are
    <quote>simple enough</> for this are called <firstterm>automatically
    updatable</>.  For detailed information on the kinds of view that can
    be automatically updated, see <xref linkend="sql-createview">.
-->
副問い合わせが単一のテーブルを参照しかつ十分に単純である時、リライタは副問い合わせを被参照テーブルに自動的に置き換え、したがって、<command>INSERT</command>、<command>UPDATE</command>あるいは<command>DELETE</command>を適切な方法で被参照テーブルに適用する事ができます。
この場合の<quote>十分に単純</>であるとは<firstterm>自動的に更新可能</>ある事です。より詳細な自動的に更新可能なビューの情報については、<xref linkend="sql-createview">を参照してください。
</para>

<para>
<!--
    Alternatively, the operation may be handled by a user-provided
    <literal>INSTEAD OF</> trigger on the view.
    Rewriting works slightly differently
    in this case.  For <command>INSERT</command>, the rewriter does
    nothing at all with the view, leaving it as the result relation
    for the query.  For <command>UPDATE</command> and
    <command>DELETE</command>, it's still necessary to expand the
    view query to produce the <quote>old</> rows that the command will
    attempt to update or delete.  So the view is expanded as normal,
    but another unexpanded range-table entry is added to the query
    to represent the view in its capacity as the result relation.
-->
もう一つの方法として、ビューに対するユーザ定義の<literal>INSTEAD OF</>トリガによってこれらのコマンドを処理する事ができます。この場合、書き換えは少々違う形で行われます。
<command>INSERT</command>に対しては、リライタはビューに全く何もせず、問い合わせの結果リレーションをそのままにします。
<command>UPDATE</command>と<command>DELETE</command>に対しては、コマンドが更新もしくは削除しようとする<quote>古い</>行を生成するためにビュー問い合わせを展開する必要がまだあります。
そのため、ビューは通常通り展開されますが、もう一つの展開されない範囲テーブル項目が結果リレーションとしてビューを表す問い合わせに追加されます。
</para>

<para>
<!--
    The problem that now arises is how to identify the rows to be
    updated in the view. Recall that when the result relation
    is a table, a special <acronym>CTID</> entry is added to the target
    list to identify the physical locations of the rows to be updated.
    This does not work if the result relation is a view, because a view
    does not have any <acronym>CTID</>, since its rows do not have
    actual physical locations. Instead, for an <command>UPDATE</command>
    or <command>DELETE</command> operation, a special <literal>wholerow</>
    entry is added to the target list, which expands to include all
    columns from the view. The executor uses this value to supply the
    <quote>old</> row to the <literal>INSTEAD OF</> trigger.  It is
    up to the trigger to work out what to update based on the old and
    new row values.
-->
ここで起こる問題はビューで更新される行をどのように特定するかということです。
結果リレーションがテーブルの場合、更新する行の物理的な位置を特定するために特別な<acronym>CTID</>項目が目的リストに追加されることを思い出して下さい。
ビューの行には実際の物理的な位置がないため、ビューには<acronym>CTID</>がありませんので、これは結果リレーションがビューの場合には上手くいきません。
その代わり、<command>UPDATE</command>や<command>DELETE</command>操作では、特別な<literal>行全体</>の項目が目的リストに追加されていて、それはビューからすべての列を含むように展開されています。
エクゼキュータはこの値を使って<quote>古い</>行を<literal>INSTEAD OF</>トリガに提供します。
新旧の行の値に基づいて更新するものを計算するのはトリガの責任です。
</para>

<para>
<!--
    Another possibility is for the user to define <literal>INSTEAD</>
    rules that specify substitute actions for <command>INSERT</command>,
    <command>UPDATE</command>, and <command>DELETE</command> commands on
    a view. These rules will rewrite the command, typically into a command
    that updates one or more tables, rather than views. That is the topic
    of the next section.
-->
別の方法としては、ビューに対する<command>INSERT</command>、<command>UPDATE</command>、<command>DELETE</command>コマンドに代替の動作を指定する<literal>INSTEAD</>ルールを定義する事です。
これらのルールは、ビューではなくコマンドを、通常は1つもしくは複数のテーブルを更新するコマンドに書き換えます。
それが次節の論題になります。
</para>

<para>
<!--
    Note that rules are evaluated first, rewriting the original query
    before it is planned and executed. Therefore, if a view has
    <literal>INSTEAD OF</> triggers as well as rules on <command>INSERT</>,
    <command>UPDATE</>, or <command>DELETE</>, then the rules will be
    evaluated first, and depending on the result, the triggers may not be
    used at all.
-->
ルールが最初に評価され、元の問い合わせが計画され実行される前にそれを書き換えることに注意して下さい。
そのためビューに<literal>INSTEAD OF</>トリガと<command>INSERT</>や<command>UPDATE</>や<command>DELETE</>に関するルールがあった場合、ルールが最初に評価され、その結果よってはトリガが全く使われないかもしれません。
</para>

<para>
<!--
    Automatic rewriting of an <command>INSERT</command>,
    <command>UPDATE</command>, or <command>DELETE</command> query on a
    simple view is always tried last. Therefore, if a view has rules or
    triggers, they will override the default behavior of automatically
    updatable views.
-->
単純なビューに対する<command>INSERT</command>、<command>UPDATE</command>あるいは<command>DELETE</command>コマンドの自動書き換えは常に最後に試みられます。したがって、ビューがルールもしくはトリガを持っていた場合、これらは更新可能ビューのデフォルト動作を上書きします。
</para>

<para>
<!--
    If there are no <literal>INSTEAD</> rules or <literal>INSTEAD OF</>
    triggers for the view, and the rewriter cannot automatically rewrite
    the query as an update on the underlying base relation, an error will
    be thrown because the executor cannot update a view as such.
-->
ビューに<literal>INSTEAD</>ルールも<literal>INSTEAD OF</>トリガも定義されておらず、かつ、リライタがクエリを自動的に被参照テーブルへの更新に書き換える事ができなかった場合、エグゼキュータはビューを更新できませんのでエラーが発生します。
</para>

</sect2>

</sect1>

<sect1 id="rules-materializedviews">
<!--
<title>Materialized Views</title>
-->
<title>マテリアライズドビュー</title>

<indexterm zone="rules-materializedviews">
 <primary>rule</primary>
 <secondary>and materialized views</secondary>
</indexterm>

<indexterm zone="rules-materializedviews">
 <primary>materialized view</>
 <secondary>implementation through rules</>
</indexterm>

<indexterm zone="rules-materializedviews">
 <primary>view</>
 <secondary>materialized</>
</indexterm>

<para>
<!--
    Materialized views in <productname>PostgreSQL</productname> use the
    rule system like views do, but persist the results in a table-like form.
    The main differences between:
-->
<productname>PostgreSQL</productname>におけるマテリアライズドビューはビューのようにルールシステムを使用しますが、あたかもテーブルであるかのような形態で結果を保持します。

<programlisting>
CREATE MATERIALIZED VIEW mymatview AS SELECT * FROM mytab;
</programlisting>

<!--
    and:
-->
と

<programlisting>
CREATE TABLE mymatview AS SELECT * FROM mytab;
</programlisting>

<!--
    are that the materialized view cannot subsequently be directly updated
    and that the query used to create the materialized view is stored in
    exactly the same way that a view's query is stored, so that fresh data
    can be generated for the materialized view with:
-->
の間の主な違いは、その後にマテリアライズドビューを直接更新できない事と、マテリアライズドビューを作成するために使われたクエリがビューと全く同様の方法で保持され、以下のコマンドを用いて最新のデータでマテリアライズドビューを再構築できる事です。

<programlisting>
REFRESH MATERIALIZED VIEW mymatview;
</programlisting>

<!--
    The information about a materialized view in the
    <productname>PostgreSQL</productname> system catalogs is exactly
    the same as it is for a table or view. So for the parser, a
    materialized view is a relation, just like a table or a view.  When
    a materialized view is referenced in a query, the data is returned
    directly from the materialized view, like from a table; the rule is
    only used for populating the materialized view.
-->
マテリアライズドビューに関する情報は<productname>PostgreSQL</productname>システムカタログでビューやテーブルに対するものと全く同様に保持されています。
そのため、パーサにとってマテリアライズドビューはテーブルやビューと同じリレーションです。
問い合わせでマテリアライズドビューが参照された時、あたかもテーブルのように、データはマテリアライズドビューから直接返されます。ルールはマテリアライズドビューにデータを投入する時にだけ使用されます。
</para>

<para>
<!--
    While access to the data stored in a materialized view is often much
    faster than accessing the underlying tables directly or through a view,
    the data is not always current; yet sometimes current data is not needed.
    Consider a table which records sales:
-->
多くの場合、マテリアライズドビューに格納されているデータの参照は、ビューを通して、あるいはビューから参照されているテーブルを直接参照するよりも高速ですが、データが常に最新であるとは限りません。ですが、時には最新のデータは必要でない事もあります。
販売履歴を記録するテーブルの例を考えてみましょう。

<programlisting>
<!--
CREATE TABLE invoice (
    invoice_no    integer        PRIMARY KEY,
    seller_no     integer,       &#045;- ID of salesperson
    invoice_date  date,          &#045;- date of sale
    invoice_amt   numeric(13,2)  &#045;- amount of sale
);
-->
CREATE TABLE invoice (
    invoice_no    integer        PRIMARY KEY,
    seller_no     integer,       -- 販売員のID
    invoice_date  date,          -- 販売日
    invoice_amt   numeric(13,2)  -- 販売量
);
</programlisting>

<!--
    If people want to be able to quickly graph historical sales data, they
    might want to summarize, and they may not care about the incomplete data
    for the current date:
-->
もし利用者が過去の販売データを速やかにグラフ化可能であってほしいと考えるなら、彼らはデータの要約を望むのであって、最新のデータが不完全である事は気にしないでしょう。

<programlisting>
CREATE MATERIALIZED VIEW sales_summary AS
  SELECT
      seller_no,
      invoice_date,
      sum(invoice_amt)::numeric(13,2) as sales_amt
    FROM invoice
    WHERE invoice_date < CURRENT_DATE
    GROUP BY
      seller_no,
      invoice_date
    ORDER BY
      seller_no,
      invoice_date;

CREATE UNIQUE INDEX sales_summary_seller
  ON sales_summary (seller_no, invoice_date);
</programlisting>

<!--
    This materialized view might be useful for displaying a graph in the
    dashboard created for salespeople.  A job could be scheduled to update
    the statistics each night using this SQL statement:
-->
このマテリアライズドビューは営業担当用に作成されるダッシュボードのグラフを表示するのにぴったりでしょう。
以下のSQLを使った統計情報を更新するジョブを毎晩スケジュールしておくことができます。

<programlisting>
REFRESH MATERIALIZED VIEW sales_summary;
</programlisting>
</para>

<para>
<!--
    Another use for a materialized view is to allow faster access to data
    brought across from a remote system through a foreign data wrapper.
    A simple example using <literal>file_fdw</literal> is below, with timings,
    but since this is using cache on the local system the performance
    difference compared to access to a remote system would usually be greater
    than shown here.  Notice we are also exploiting the ability to put an
    index on the materialized view, whereas <literal>file_fdw</literal> does
    not support indexes; this advantage might not apply for other sorts of
    foreign data access.
-->
それ以外のマテリアライズドビューの用途として、外部データラッパを通じてリモートシステムから取得したデータの高速化が挙げられます。
以下の例は<literal>file_fdw</literal>を用いた単純な例で、実行時間を含みますが、これはローカルシステムのキャッシュ機構を用いているため、リモートシステムへのアクセスと比較した違いの方がここで示したものより劇的です。
マテリアライズドビューにはインデックスを設定することもできますが、<literal>file_fdw</literal>はインデックスをサポートしないことに注意してください。
この有利な点は、他の種類の外部データアクセスには当てはまらないでしょう。
</para>

<para>
<!--
    Setup:
-->
セットアップ:

<programlisting>
CREATE EXTENSION file_fdw;
CREATE SERVER local_file FOREIGN DATA WRAPPER file_fdw;
CREATE FOREIGN TABLE words (word text NOT NULL)
  SERVER local_file
  OPTIONS (filename '/usr/share/dict/words');
CREATE MATERIALIZED VIEW wrd AS SELECT * FROM words;
CREATE UNIQUE INDEX wrd_word ON wrd (word);
CREATE EXTENSION pg_trgm;
CREATE INDEX wrd_trgm ON wrd USING gist (word gist_trgm_ops);
VACUUM ANALYZE wrd;
</programlisting>

<!--
    Now let's spell-check a word.  Using <literal>file_fdw</literal> directly:
-->
<literal>file_fdw</literal>を直接用いて字句のスペルチェックをしてみましょう。

<programlisting>
SELECT count(*) FROM words WHERE word = 'caterpiler';

 count 
-------
     0
(1 row)
</programlisting>

<!--
    With <command>EXPLAIN ANALYZE</>, we see:
-->
<command>EXPLAIN ANALYZE</>によれば以下の通りです:

<programlisting>
 Aggregate  (cost=21763.99..21764.00 rows=1 width=0) (actual time=188.180..188.181 rows=1 loops=1)
   -&gt;  Foreign Scan on words  (cost=0.00..21761.41 rows=1032 width=0) (actual time=188.177..188.177 rows=0 loops=1)
         Filter: (word = 'caterpiler'::text)
         Rows Removed by Filter: 479829
         Foreign File: /usr/share/dict/words
         Foreign File Size: 4953699
 Planning time: 0.118 ms
 Execution time: 188.273 ms
</programlisting>

<!--
    If the materialized view is used instead, the query is much faster:
-->
代わりにマテリアライズドビューを使った場合、クエリは非常に速くなります。

<programlisting>
 Aggregate  (cost=4.44..4.45 rows=1 width=0) (actual time=0.042..0.042 rows=1 loops=1)
   -&gt;  Index Only Scan using wrd_word on wrd  (cost=0.42..4.44 rows=1 width=0) (actual time=0.039..0.039 rows=0 loops=1)
         Index Cond: (word = 'caterpiler'::text)
         Heap Fetches: 0
 Planning time: 0.164 ms
 Execution time: 0.117 ms
</programlisting>

<!--
    Either way, the word is spelled wrong, so let's look for what we might
    have wanted.  Again using <literal>file_fdw</literal>:
-->
どちらの場合でも、wordの綴りは間違っています。では、我々が望んでいたであろう結果を得るために、もう一度<literal>file_fdw</literal>を使ってみます。
（訳注：検索条件の正しい綴りは<quote>caterpillar</>）

<programlisting>
SELECT word FROM words ORDER BY word <-> 'caterpiler' LIMIT 10;

     word     
---------------
 cater
 caterpillar
 Caterpillar
 caterpillars
 caterpillar's
 Caterpillar's
 caterer
 caterer's
 caters
 catered
(10 rows)
</programlisting>

<programlisting>
 Limit  (cost=11583.61..11583.64 rows=10 width=32) (actual time=1431.591..1431.594 rows=10 loops=1)
   -&gt;  Sort  (cost=11583.61..11804.76 rows=88459 width=32) (actual time=1431.589..1431.591 rows=10 loops=1)
         Sort Key: ((word &lt;-&gt; 'caterpiler'::text))
         Sort Method: top-N heapsort  Memory: 25kB
         -&gt;  Foreign Scan on words  (cost=0.00..9672.05 rows=88459 width=32) (actual time=0.057..1286.455 rows=479829 loops=1)
               Foreign File: /usr/share/dict/words
               Foreign File Size: 4953699
 Planning time: 0.128 ms
 Execution time: 1431.679 ms
</programlisting>

<!--
    Using the materialized view:
-->
マテリアライズドビューを使用した場合:

<programlisting>
 Limit  (cost=0.29..1.06 rows=10 width=10) (actual time=187.222..188.257 rows=10 loops=1)
   -&gt;  Index Scan using wrd_trgm on wrd  (cost=0.29..37020.87 rows=479829 width=10) (actual time=187.219..188.252 rows=10 loops=1)
         Order By: (word &lt;-&gt; 'caterpiler'::text)
 Planning time: 0.196 ms
 Execution time: 198.640 ms
</programlisting>

<!--
    If you can tolerate periodic update of the remote data to the local
    database, the performance benefit can be substantial.
-->
定期的にリモートのデータをローカルに更新せねばならない事を許容できるのであれば、代わりに性能上の便益を得られることでしょう。
</para>

</sect1>

<sect1 id="rules-update">
<!--
<title>Rules on <command>INSERT</>, <command>UPDATE</>, and <command>DELETE</></title>
-->
<title><command>INSERT</>、<command>UPDATE</>、<command>DELETE</>についてのルール</title>

<indexterm zone="rules-update">
<!--
 <primary>rule</primary>
 <secondary sortas="INSERT">for INSERT</secondary>
-->
 <primary>ルール</primary>
 <secondary sortas="INSERT">INSERT用</secondary>
</indexterm>

<indexterm zone="rules-update">
<!--
 <primary>rule</primary>
 <secondary sortas="UPDATE">for UPDATE</secondary>
-->
 <primary>ルール</primary>
 <secondary sortas="UPDATE">UPDATE用</secondary>
</indexterm>

<indexterm zone="rules-update">
<!--
 <primary>rule</primary>
 <secondary sortas="DELETE">for DELETE</secondary>
-->
 <primary>ルール</primary>
 <secondary sortas="DELETE">DELETE用</secondary>
</indexterm>

<para>
<!--
    Rules that are defined on <command>INSERT</>, <command>UPDATE</>,
    and <command>DELETE</> are significantly different from the view rules
    described in the previous section. First, their <command>CREATE
    RULE</command> command allows more:
-->
<command>INSERT</>、<command>UPDATE</>、<command>DELETE</>に定義するルールは前節で解説したビューのルールとはまったく異なります。
第一点として、これらの<command>CREATE RULE</command>コマンドでは以下を行うことができます。

    <itemizedlist>
        <listitem>
        <para>
<!--
            They are allowed to have no action.
-->
アクションがないルールも可能です。
        </para>
        </listitem>

        <listitem>
        <para>
<!--
            They can have multiple actions.
-->
複数のアクションを持てます。
        </para>
        </listitem>

        <listitem>
        <para>
<!--
            They can be <literal>INSTEAD</> or <literal>ALSO</> (the default).
-->
<literal>INSTEAD</>もしくは<literal>ALSO</>（デフォルト）を取ることができます。
        </para>
        </listitem>

        <listitem>
        <para>
<!--
            The pseudorelations <literal>NEW</> and <literal>OLD</> become useful.
-->
疑似リレーション<literal>NEW</>と<literal>OLD</>が役立つようになります。
        </para>
        </listitem>

        <listitem>
        <para>
<!--
            They can have rule qualifications.
-->
ルール条件を持たせることができます。
        </para>
        </listitem>
    </itemizedlist>

<!--
    Second, they don't modify the query tree in place. Instead they
    create zero or more new query trees and can throw away the
    original one.
-->
第二点として、その場で問い合わせツリーを変更しません。
その代わりに新規の0個以上の問い合わせツリーを生成して、オリジナルを破棄することができます。
</para>

<sect2>
<!--
<title>How Update Rules Work</title>
-->
<title>更新ルールの動作</title>

<para>
<!--
    Keep the syntax:
-->

<programlisting>
CREATE [ OR REPLACE ] RULE <replaceable class="parameter">name</replaceable> AS ON <replaceable class="parameter">event</replaceable>
    TO <replaceable class="parameter">table</replaceable> [ WHERE <replaceable class="parameter">condition</replaceable> ]
    DO [ ALSO | INSTEAD ] { NOTHING | <replaceable class="parameter">command</replaceable> | ( <replaceable class="parameter">command</replaceable> ; <replaceable class="parameter">command</replaceable> ... ) }
</programlisting>

<!--
    in mind.
    In the following, <firstterm>update rules</> means rules that are defined
    on <command>INSERT</>, <command>UPDATE</>, or <command>DELETE</>.
-->
上記の構文を覚えておいてください。
以下では、<firstterm>更新ルール</>は<command>INSERT</>、<command>UPDATE</>、<command>DELETE</>に定義されたルールを意味します。
</para>

<para>
<!--
    Update rules get applied by the rule system when the result
    relation and the command type of a query tree are equal to the
    object and event given in the <command>CREATE RULE</command> command.
    For update rules, the rule system creates a list of query trees.
    Initially the query-tree list is empty.
    There can be zero (<literal>NOTHING</> key word), one, or multiple actions.
    To simplify, we will look at a rule with one action. This rule
    can have a qualification or not and it can be <literal>INSTEAD</> or
    <literal>ALSO</> (the default).
-->
更新ルールは、問い合わせツリーの結果リレーションとコマンド種類が<command>CREATE RULE</command>で与えられるオブジェクトとイベントと等しい場合にルールシステムによって適用されます。
更新ルールに対してルールシステムは問い合わせツリーのリストを生成します。
最初は問い合わせツリーリストは空です。
0（<literal>NOTHING</>キーワード）、1つまたは複数のアクションが有効です。
簡単にするため、ここでは1つのアクションのルールを取り上げます。
このルールは条件を持っていても持っていなくても構いませんし、また<literal>INSTEAD</>か<literal>ALSO</>（デフォルト）のいずれかを取ることができます。
</para>

<para>
<!--
    What is a rule qualification? It is a restriction that tells
    when the actions of the rule should be done and when not. This
    qualification can only reference the pseudorelations <literal>NEW</> and/or <literal>OLD</>,
    which basically represent the relation that was given as object (but with a
    special meaning).
-->
ルール条件とはどんなものでしょうか。
それはルールのアクションを行わなければならない時と、行ってはならない時を指定する条件です。
基本的に（特別な意味合いを持った）オブジェクトとして与えられるリレーションである<literal>NEW</>疑似リレーションか<literal>OLD</>疑似リレーション、または、その両者のみをこの条件は参照することができます。
</para>

   <para>
<!--
    So we have three cases that produce the following query trees for
    a one-action rule.
-->
1アクションのルールに対し、以下の問い合わせツリーを生成する3つの場合があります。

    <variablelist>
     <varlistentry>
<!--
      <term>No qualification, with either <literal>ALSO</> or
      <literal>INSTEAD</></term>
-->
      <term><literal>ALSO</>または<literal>INSTEAD</>で条件がない場合。</term>
      <listitem>
       <para>
<!--
        the query tree from the rule action with the original query
        tree's qualification added
-->
元の問い合わせツリーの条件が追加された、ルールアクションからの問い合わせツリー
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--
      <term>Qualification given and <literal>ALSO</></term>
-->
      <term>条件付き、かつ<literal>ALSO</></term>
      <listitem>
       <para>
<!--
        the query tree from the rule action with the rule
        qualification and the original query tree's qualification
        added
-->
ルール条件と元の問い合わせツリーの条件が追加された、ルールアクションからの問い合わせツリー
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--
      <term>Qualification given and <literal>INSTEAD</></term>
-->
      <term>条件付き、かつ<literal>INSTEAD</></term>
      <listitem>
       <para>
<!--
        the query tree from the rule action with the rule
        qualification and the original query tree's qualification; and
        the original query tree with the negated rule qualification
        added
-->
ルール条件と元の問い合わせツリーの条件が追加された、ルールアクションからの問い合わせツリーとルール条件の否定条件が追加された元の問い合わせツリー
       </para>
      </listitem>
     </varlistentry>
    </variablelist>

<!--
    Finally, if the rule is <literal>ALSO</>, the unchanged original query tree is
    added to the list. Since only qualified <literal>INSTEAD</> rules already add the
    original query tree, we end up with either one or two output query trees
    for a rule with one action.
-->
最後に、もしルールが<literal>ALSO</>の場合、変更されていない元の問い合わせツリーがリストに付け加えられます。
条件付きの<literal>INSTEAD</>ルールのみが既に元の構文解析ツリーに追加をしているので、最後は1つのアクションを持つルールに対して1つもしくは2つの問い合わせツリーにたどり着きます。
</para>

<para>
 <!--
    For <literal>ON INSERT</> rules, the original query (if not suppressed by <literal>INSTEAD</>)
    is done before any actions added by rules.  This allows the actions to
    see the inserted row(s).  But for <literal>ON UPDATE</> and <literal>ON
    DELETE</> rules, the original query is done after the actions added by rules.
    This ensures that the actions can see the to-be-updated or to-be-deleted
    rows; otherwise, the actions might do nothing because they find no rows
    matching their qualifications.
-->
<literal>ON INSERT</>ルールでは、元の問い合わせは、（<literal>INSTEAD</>により止められていない限り）ルールによって追加されたアクションの前に実行されます。
これにより、アクションは挿入された行（複数可）を参照することができます。
しかし、<literal>ON UPDATE</>と<literal>ON DELETE</>ルールでは、元の問い合わせはルールによって追加されたアクションの後に実行されます。
これは、アクションが更新される予定の、または削除される予定の行を参照できることを保証します。
さもないと、条件に一致する行を見つけることができないためにアクションが作動しなくなる可能性が起こります。
</para>

<para>
<!--
    The query trees generated from rule actions are thrown into the
    rewrite system again, and maybe more rules get applied resulting
    in more or less query trees.
    So a rule's actions must have either a different
    command type or a different result relation than the rule itself is
    on, otherwise this recursive process will end up in an infinite loop.
    (Recursive expansion of a rule will be detected and reported as an
    error.)
-->
ルールアクションで生成された問い合わせツリーは、再度書き換えシステムに渡され、より多くのルールの適用を受けてより多くのもしくは少ない問い合わせツリーになるかもしれません。
ですから、ルールのアクションはルール自身とは異なるコマンド種類か、異なる結果リレーションを持っていなければなりません。
さもないと、この再帰的処理により無限ループに陥ってしまいます。
(ルールの再帰展開は検知され、エラーとして報告されます。)
</para>

<para>
<!--
    The query trees found in the actions of the
    <structname>pg_rewrite</structname> system catalog are only
    templates. Since they can reference the range-table entries for
    <literal>NEW</> and <literal>OLD</>, some substitutions have to be made before they can be
    used. For any reference to <literal>NEW</>, the target list of the original
    query is searched for a corresponding entry. If found, that
    entry's expression replaces the reference. Otherwise, <literal>NEW</> means the
    same as <literal>OLD</> (for an <command>UPDATE</command>) or is replaced by
    a null value (for an <command>INSERT</command>). Any reference to <literal>OLD</> is
    replaced by a reference to the range-table entry that is the
    result relation.
-->
<structname>pg_rewrite</structname>システムカタログのアクションにある問い合わせツリーは単なるテンプレートです。
これらは<literal>NEW</>と<literal>OLD</>に対する範囲テーブルの項目を参照することができるため、使用される前に何らかの置換措置がとられていなければなりません。
<literal>NEW</>を参照する全てに対し、元の問い合わせの目的リストは対応する項目があるかどうか検索されます。
項目が見つかった場合には、その項目式が参照を置き換えます。
項目がなかった場合、<literal>NEW</>は<literal>OLD</>と同じ意味になる（<command>UPDATE</command>の場合）か、NULLによって置き換えられます（<command>INSERT</command>の場合）。
<literal>OLD</>に対する参照は全て結果リレーションである範囲テーブルの項目への参照に置き換えられます。
</para>

<para>
<!--
    After the system is done applying update rules, it applies view rules to the
    produced query tree(s).  Views cannot insert new update actions so
    there is no need to apply update rules to the output of view rewriting.
-->
更新ルールの適用が終わると、システムはそこで作られた構文解析ツリーにビュールールを適用します。
ビューは、新しい更新アクションを挿入できないため、ビュー書き換えの結果に更新ルールを適用する必要はありません。
</para>

<sect3>
<!--
<title>A First Rule Step by Step</title>
-->
<title>最初のルール、ステップバイステップ</title>

<para>
<!--
    Say we want to trace changes to the <literal>sl_avail</> column in the
    <literal>shoelace_data</literal> relation. So we set up a log table
    and a rule that conditionally writes a log entry when an
    <command>UPDATE</command> is performed on
    <literal>shoelace_data</literal>.
-->
<literal>shoelace_data</literal>リレーションの<literal>sl_avail</literal>列の変化を追跡してみたいと思います。
そこでログ用テーブルと、<literal>shoelace_data</literal>に対して行われる<command>UPDATE</command>をログに記録するルールを用意しました。

<programlisting>
<!--
CREATE TABLE shoelace_log (
    sl_name    text,          &#045;- shoelace changed
    sl_avail   integer,       &#045;- new available value
    log_who    text,          &#045;- who did it
    log_when   timestamp      &#045;- when
);
-->
CREATE TABLE shoelace_log (
    sl_name    text,          -- 変更された靴紐
    sl_avail   integer,       -- 新しい現在値
    log_who    text,          -- 誰が行ったか
    log_when   timestamp      -- いつ行ったか
);

CREATE RULE log_shoelace AS ON UPDATE TO shoelace_data
    WHERE NEW.sl_avail &lt;&gt; OLD.sl_avail
    DO INSERT INTO shoelace_log VALUES (
                                    NEW.sl_name,
                                    NEW.sl_avail,
                                    current_user,
                                    current_timestamp
                                );
</programlisting>
</para>

<para>
<!--
    Now someone does:
-->
ここで誰かが以下を実行します。

<programlisting>
UPDATE shoelace_data SET sl_avail = 6 WHERE sl_name = 'sl7';
</programlisting>

<!--
    and we look at the log table:
-->
ログテーブルを見てみましょう。

<programlisting>
SELECT * FROM shoelace_log;

 sl_name | sl_avail | log_who | log_when                        
---------+----------+---------+----------------------------------
 sl7     |        6 | Al      | Tue Oct 20 16:14:45 1998 MET DST
(1 row)
</programlisting>
   </para>

   <para>
<!--
    That's what we expected. What happened in the background is the following.
    The parser created the query tree:
-->
思った通りの結果が出ました。
以下に裏で何が起こったのかを説明します。
パーサがまず以下の構文解析ツリーを生成しました。

<programlisting>
UPDATE shoelace_data SET sl_avail = 6
  FROM shoelace_data shoelace_data
 WHERE shoelace_data.sl_name = 'sl7';
</programlisting>

<!--
    There is a rule <literal>log_shoelace</literal> that is <literal>ON UPDATE</> with the rule
    qualification expression:
-->
以下のルール条件式

<programlisting>
NEW.sl_avail &lt;&gt; OLD.sl_avail
</programlisting>

<!--
    and the action:
-->
および、以下のアクションを持つ<literal>ON UPDATE</>の<literal>log_shoelace</literal>ルールがあります。

<programlisting>
INSERT INTO shoelace_log VALUES (
       new.sl_name, new.sl_avail,
       current_user, current_timestamp )
  FROM shoelace_data new, shoelace_data old;
</programlisting>

<!--
    (This looks a little strange since you cannot normally write
    <literal>INSERT ... VALUES ... FROM</>.  The <literal>FROM</>
    clause here is just to indicate that there are range-table entries
    in the query tree for <literal>new</> and <literal>old</>.
    These are needed so that they can be referenced by variables in
    the <command>INSERT</command> command's query tree.)
-->
（通常、<literal>INSERT ... VALUES ... FROM</>を書くことはできないのでちょっと奇妙に見えるかもしれません。
ここの<literal>FROM</>句は単に<literal>new</>と<literal>old</>の問い合わせツリーの範囲テーブル項目があることを示しているだけです。
これらは、<command>INSERT</command>コマンドの問い合わせツリー中の変数から参照されるために必要なのです。）
</para>

<para>
<!--
    The rule is a qualified <literal>ALSO</> rule, so the rule system
    has to return two query trees: the modified rule action and the original
    query tree. In step 1, the range table of the original query is
    incorporated into the rule's action query tree. This results in:
-->
このルールは条件付きの<literal>ALSO</>ルールですので、ルールシステムは変更されたルールアクションと元の問い合わせツリーという2つの問い合わせツリーを返さなければなりません。
第1の段階で元の問い合わせの範囲テーブルはルールアクション問い合わせツリーに取り込まれます。
そして、次の結果を生みます。

<programlisting>
INSERT INTO shoelace_log VALUES (
       new.sl_name, new.sl_avail,
       current_user, current_timestamp )
  FROM shoelace_data new, shoelace_data old,
       <emphasis>shoelace_data shoelace_data</emphasis>;
</programlisting>

<!--
    In step 2, the rule qualification is added to it, so the result set
    is restricted to rows where <literal>sl_avail</> changes:
-->
第2段階で、以下のようにルール条件が付け加えられます。
これにより、この結果集合は<literal>sl_avail</>が変更した行に限定されます。

<programlisting>
INSERT INTO shoelace_log VALUES (
       new.sl_name, new.sl_avail,
       current_user, current_timestamp )
  FROM shoelace_data new, shoelace_data old,
       shoelace_data shoelace_data
 <emphasis>WHERE new.sl_avail &lt;&gt; old.sl_avail</emphasis>;
</programlisting>

<!--
    (This looks even stranger, since <literal>INSERT ... VALUES</> doesn't have
    a <literal>WHERE</> clause either, but the planner and executor will have no
    difficulty with it.  They need to support this same functionality
    anyway for <literal>INSERT ... SELECT</>.)
-->
（<literal>INSERT ... VALUES</>は<literal>WHERE</>句を持たないため、これはさらに奇妙です。
しかし、プランナとエクゼキュータには問題はありません。
これらはどのみち<literal>INSERT ... SELECT</>のために同じ機能をサポートしなければなりません。）
   </para>

   <para>
<!--
    In step 3, the original query tree's qualification is added,
    restricting the result set further to only the rows that would have been touched
    by the original query:
-->
第3段階で、以下のように元の問い合わせツリーの条件が付け加えられ、結果集合は元の問い合わせで変更された行のみにさらに限定されます。

<programlisting>
INSERT INTO shoelace_log VALUES (
       new.sl_name, new.sl_avail,
       current_user, current_timestamp )
  FROM shoelace_data new, shoelace_data old,
       shoelace_data shoelace_data
 WHERE new.sl_avail &lt;&gt; old.sl_avail
   <emphasis>AND shoelace_data.sl_name = 'sl7'</emphasis>;
</programlisting>
   </para>

   <para>
<!--
    Step 4 replaces references to <literal>NEW</> by the target list entries from the
    original query tree or by the matching variable references
    from the result relation:
-->
第4段階では、以下のように元の問い合わせツリーの目的リスト項目、または結果リレーションの該当する変数参照で、<literal>NEW</>の参照を置換します。

<programlisting>
INSERT INTO shoelace_log VALUES (
       <emphasis>shoelace_data.sl_name</emphasis>, <emphasis>6</emphasis>,
       current_user, current_timestamp )
  FROM shoelace_data new, shoelace_data old,
       shoelace_data shoelace_data
 WHERE <emphasis>6</emphasis> &lt;&gt; old.sl_avail
   AND shoelace_data.sl_name = 'sl7';
</programlisting>

   </para>

   <para>
<!--
    Step 5 changes <literal>OLD</> references into result relation references:
-->
第5段階は、以下のように<literal>OLD</>参照を結果リレーション参照に置き換えます。

<programlisting>
INSERT INTO shoelace_log VALUES (
       shoelace_data.sl_name, 6,
       current_user, current_timestamp )
  FROM shoelace_data new, shoelace_data old,
       shoelace_data shoelace_data
 WHERE 6 &lt;&gt; <emphasis>shoelace_data.sl_avail</emphasis>
   AND shoelace_data.sl_name = 'sl7';
</programlisting>
   </para>

   <para>
<!--
    That's it.  Since the rule is <literal>ALSO</>, we also output the
    original query tree.  In short, the output from the rule system
    is a list of two query trees that correspond to these statements:
-->
これで終わりです。このルールは<literal>ALSO</>のため、元の問い合わせツリーも出力します。
まとめると、ルールシステムからの出力は以下の文に対応する2つの問い合わせツリーのリストです。

<programlisting>
INSERT INTO shoelace_log VALUES (
       shoelace_data.sl_name, 6,
       current_user, current_timestamp )
  FROM shoelace_data
 WHERE 6 &lt;&gt; shoelace_data.sl_avail
   AND shoelace_data.sl_name = 'sl7';

UPDATE shoelace_data SET sl_avail = 6
 WHERE sl_name = 'sl7';
</programlisting>

<!--
    These are executed in this order, and that is exactly what
    the rule was meant to do.
-->
この2つは順番通りに処理され、正確にルールが定義した通りです。
   </para>

   <para>
<!--
    The substitutions and the added qualifications
    ensure that, if the original query would be, say:
-->
元の問い合わせが例えば下記のような場合に、置換と追加された条件は、ログには何も書かれないことを確実にします。

<programlisting>
UPDATE shoelace_data SET sl_color = 'green'
 WHERE sl_name = 'sl7';
</programlisting>

<!--
    no log entry would get written.  In that case, the original query
    tree does not contain a target list entry for
    <literal>sl_avail</>, so <literal>NEW.sl_avail</> will get
    replaced by <literal>shoelace_data.sl_avail</>.  Thus, the extra
    command generated by the rule is:
-->
この場合、元の問い合わせツリーの目的リストには<literal>sl_avail</>の項目がありませんので、<literal>NEW.sl_avail</>が<literal>shoelace_data.sl_avail</>に置き換えられます。
その結果、このルールによって以下のような特別の問い合わせが生成されます。

<programlisting>
INSERT INTO shoelace_log VALUES (
       shoelace_data.sl_name, <emphasis>shoelace_data.sl_avail</emphasis>,
       current_user, current_timestamp )
  FROM shoelace_data
 WHERE <emphasis>shoelace_data.sl_avail</emphasis> &lt;&gt; shoelace_data.sl_avail
   AND shoelace_data.sl_name = 'sl7';
</programlisting>

<!--
    and that qualification will never be true.
-->
そしてこの条件は決して真にはなりません。
   </para>

   <para>
<!--
    It will also work if the original query modifies multiple rows. So
    if someone issued the command:
-->
もし元の問い合わせが複数の行を変更してもうまくいきます。
ですから、誰かが下記のようなコマンドを実行したとします。

<programlisting>
UPDATE shoelace_data SET sl_avail = 0
 WHERE sl_color = 'black';
</programlisting>

<!--
    four rows in fact get updated (<literal>sl1</>, <literal>sl2</>, <literal>sl3</>, and <literal>sl4</>).
    But <literal>sl3</> already has <literal>sl_avail = 0</>.   In this case, the original
    query trees qualification is different and that results
    in the extra query tree:
-->
この場合、実際には4行が更新されます（<literal>sl1</>、<literal>sl2</>、<literal>sl3</>および<literal>sl4</>）。
しかし<literal>sl3</>は既に<literal>sl_avail = 0</>を持っています。
この場合、元の問い合わせツリーの条件を満たさず、その結果、以下のような特別の問い合わせツリーがルールによって生成されます。

<programlisting>
INSERT INTO shoelace_log
SELECT shoelace_data.sl_name, 0,
       current_user, current_timestamp
  FROM shoelace_data
 WHERE 0 &lt;&gt; shoelace_data.sl_avail
   AND <emphasis>shoelace_data.sl_color = 'black'</emphasis>;
</programlisting>

<!--
    being generated by the rule.  This query tree will surely insert
    three new log entries. And that's absolutely correct.
-->
この構文解析ツリーは確実に3つの新しいログ項目を挿入します。
これはまったく正しい動作です
[訳注：sl3行はWHERE 0 != shoelace_data.sl_avail条件を満たさない（0!=0）ので、実際に更新される4行-1の3行分のログ項目が挿入されます]。
</para>

<para>
<!--
    Here we can see why it is important that the original query tree
    is executed last.  If the <command>UPDATE</command> had been
    executed first, all the rows would have already been set to zero, so the
    logging <command>INSERT</command> would not find any row where
    <literal>0 &lt;&gt; shoelace_data.sl_avail</literal>.
-->
ここで元の構文解析ツリーが最後に実行されるということが重要な理由がわかります。
もし<command>UPDATE</command>が先に実行されたとしたら、全ての行は0にセットされ、<literal>0 &lt;&gt; shoelace_data.sl_avail</literal>である行をログ書き込み時の<command>INSERT</command>の段階で見つけられなくなります。
</para>
</sect3>

</sect2>

<sect2 id="rules-update-views">
<!--
<title>Cooperation with Views</title>
-->
<title>ビューとの協調</title>

<!--
<indexterm zone="rules-update-views"><primary>view</><secondary>updating</></>
-->
<indexterm zone="rules-update-views"><primary>ビュー</><secondary>更新</></>

<para>
<!--
    A simple way to protect view relations from the mentioned
    possibility that someone can try to run <command>INSERT</command>,
    <command>UPDATE</command>, or <command>DELETE</command> on them is
    to let those query trees get thrown away.  So we could create the rules:
-->
誰かがビューに対して<command>INSERT</command>、<command>UPDATE</command>、<command>DELETE</command>を発行するといった、前述の可能性からビューリレーションを保護する簡単な方法は、それらの構文解析ツリーを破棄してしまうことです。
このために以下のルールを作ることができます。

<programlisting>
CREATE RULE shoe_ins_protect AS ON INSERT TO shoe
    DO INSTEAD NOTHING;
CREATE RULE shoe_upd_protect AS ON UPDATE TO shoe
    DO INSTEAD NOTHING;
CREATE RULE shoe_del_protect AS ON DELETE TO shoe
    DO INSTEAD NOTHING;
</programlisting>

<!--
    If someone now tries to do any of these operations on the view
    relation <literal>shoe</literal>, the rule system will
    apply these rules. Since the rules have
    no actions and are <literal>INSTEAD</>, the resulting list of
    query trees will be empty and the whole query will become
    nothing because there is nothing left to be optimized or
    executed after the rule system is done with it.
-->
誰かが<literal>shoe</literal>ビューリレーションに上記の操作を行おうとすると、ルールシステムはルールを適用します。
ルールにはアクションがなく、かつ、<literal>INSTEAD</>ですから、結果の問い合わせツリーリストは空になります。
ルールシステムの処理が完了した後に最適化されるものや実行されるべきものが何も残っていませんので、問い合わせ全体が無効になります。
</para>

<para>
<!--
    A more sophisticated way to use the rule system is to
    create rules that rewrite the query tree into one that
    does the right operation on the real tables. To do that
    on the <literal>shoelace</literal> view, we create
    the following rules:
-->
より洗練されたルールシステムの使用法は、実テーブルに適当な操作を行う問い合わせツリーへの書き換えを行うルールを作ることです。
<literal>shoelace</literal>ビューにこれを適用するために以下のルールを作ります。

<programlisting>
CREATE RULE shoelace_ins AS ON INSERT TO shoelace
    DO INSTEAD
    INSERT INTO shoelace_data VALUES (
           NEW.sl_name,
           NEW.sl_avail,
           NEW.sl_color,
           NEW.sl_len,
           NEW.sl_unit
    );

CREATE RULE shoelace_upd AS ON UPDATE TO shoelace
    DO INSTEAD
    UPDATE shoelace_data
       SET sl_name = NEW.sl_name,
           sl_avail = NEW.sl_avail,
           sl_color = NEW.sl_color,
           sl_len = NEW.sl_len,
           sl_unit = NEW.sl_unit
     WHERE sl_name = OLD.sl_name;

CREATE RULE shoelace_del AS ON DELETE TO shoelace
    DO INSTEAD
    DELETE FROM shoelace_data
     WHERE sl_name = OLD.sl_name;
</programlisting>
   </para>

   <para>
<!--
    If you want to support <literal>RETURNING</> queries on the view,
    you need to make the rules include <literal>RETURNING</> clauses that
    compute the view rows.  This is usually pretty trivial for views on a
    single table, but it's a bit tedious for join views such as
    <literal>shoelace</literal>.  An example for the insert case is:
-->
このビュー上で<literal>RETURNING</>問い合わせをサポートしたい場合、ビューの行を計算する<literal>RETURNING</>句を含むルールを作成しなければなりません。
これは通常、単一テーブルに対するビューでは非常に簡単ですが、<literal>shoelace</literal>のような結合されたビューの場合は多少やっかいです。
挿入する場合を例として以下に示します。

<programlisting>
CREATE RULE shoelace_ins AS ON INSERT TO shoelace
    DO INSTEAD
    INSERT INTO shoelace_data VALUES (
           NEW.sl_name,
           NEW.sl_avail,
           NEW.sl_color,
           NEW.sl_len,
           NEW.sl_unit
    )
    RETURNING
           shoelace_data.*,
           (SELECT shoelace_data.sl_len * u.un_fact
            FROM unit u WHERE shoelace_data.sl_unit = u.un_name);
</programlisting>

<!--
    Note that this one rule supports both <command>INSERT</> and
    <command>INSERT RETURNING</> queries on the view &mdash; the
    <literal>RETURNING</> clause is simply ignored for <command>INSERT</>.
-->
この1つのルールが、ビューに対する<command>INSERT</>問い合わせと<command>INSERT RETURNING</>問い合わせルールをサポートすることに注意してください。
<command>INSERT</>では<literal>RETURNING</>句が無視されるだけです。
   </para>

   <para>
<!--
    Now assume that once in a while, a pack of shoelaces arrives at
    the shop and a big parts list along with it.  But you don't want
    to manually update the <literal>shoelace</literal> view every
    time.  Instead we setup two little tables: one where you can
    insert the items from the part list, and one with a special
    trick. The creation commands for these are:
-->
ここで店には不定期に靴紐のケースが分厚い送り状とともに届けられると仮定します。
しかし、毎回毎回手作業で<literal>shoelace</literal>ビューを更新したくはありません。
代わりに、送り状から品目を挿入するテーブルと特殊な仕掛けを持つテーブルの2つの小さなテーブルを用意します。
以下はそれらを作成するコマンドです。

<programlisting>
CREATE TABLE shoelace_arrive (
    arr_name    text,
    arr_quant   integer
);

CREATE TABLE shoelace_ok (
    ok_name     text,
    ok_quant    integer
);

CREATE RULE shoelace_ok_ins AS ON INSERT TO shoelace_ok
    DO INSTEAD
    UPDATE shoelace
       SET sl_avail = sl_avail + NEW.ok_quant
     WHERE sl_name = NEW.ok_name;
</programlisting>

<!--
    Now you can fill the table <literal>shoelace_arrive</literal> with
    the data from the parts list:
-->
これで、送り状のデータを<literal>shoelace_arrive</literal>テーブルに投入することができます。

<programlisting>
SELECT * FROM shoelace_arrive;

 arr_name | arr_quant
----------+-----------
 sl3      |        10
 sl6      |        20
 sl8      |        20
(3 rows)
</programlisting>

<!--
    Take a quick look at the current data:
-->
そして現在のデータをチェックします。

<programlisting>
SELECT * FROM shoelace;

 sl_name  | sl_avail | sl_color | sl_len | sl_unit | sl_len_cm
----------+----------+----------+--------+---------+-----------
 sl1      |        5 | black    |     80 | cm      |        80
 sl2      |        6 | black    |    100 | cm      |       100
 sl7      |        6 | brown    |     60 | cm      |        60
 sl3      |        0 | black    |     35 | inch    |      88.9
 sl4      |        8 | black    |     40 | inch    |     101.6
 sl8      |        1 | brown    |     40 | inch    |     101.6
 sl5      |        4 | brown    |      1 | m       |       100
 sl6      |        0 | brown    |    0.9 | m       |        90
(8 rows)
</programlisting>

<!--
    Now move the arrived shoelaces in:
-->
さて、届いた靴紐を移動します。

<programlisting>
INSERT INTO shoelace_ok SELECT * FROM shoelace_arrive;
</programlisting>

<!--
    and check the results:
-->
そして結果を確認します。

<programlisting>
SELECT * FROM shoelace ORDER BY sl_name;

 sl_name  | sl_avail | sl_color | sl_len | sl_unit | sl_len_cm
----------+----------+----------+--------+---------+-----------
 sl1      |        5 | black    |     80 | cm      |        80
 sl2      |        6 | black    |    100 | cm      |       100
 sl7      |        6 | brown    |     60 | cm      |        60
 sl4      |        8 | black    |     40 | inch    |     101.6
 sl3      |       10 | black    |     35 | inch    |      88.9
 sl8      |       21 | brown    |     40 | inch    |     101.6
 sl5      |        4 | brown    |      1 | m       |       100
 sl6      |       20 | brown    |    0.9 | m       |        90
(8 rows)

SELECT * FROM shoelace_log;

 sl_name | sl_avail | log_who| log_when                        
---------+----------+--------+----------------------------------
 sl7     |        6 | Al     | Tue Oct 20 19:14:45 1998 MET DST
 sl3     |       10 | Al     | Tue Oct 20 19:25:16 1998 MET DST
 sl6     |       20 | Al     | Tue Oct 20 19:25:16 1998 MET DST
 sl8     |       21 | Al     | Tue Oct 20 19:25:16 1998 MET DST
(4 rows)
</programlisting>
   </para>

   <para>
<!--
    It's a long way from the one <literal>INSERT ... SELECT</literal>
    to these results. And the description of the query-tree
    transformation will be the last in this chapter.  First, there is
    the parser's output:
-->
1つの<literal>INSERT ... SELECT</literal>からこの結果になるには、長い道のりがあります。
本章での問い合わせツリーの変形に関する説明はこれが最後です。
まず、以下のようなパーサの出力があります。

<programlisting>
INSERT INTO shoelace_ok
SELECT shoelace_arrive.arr_name, shoelace_arrive.arr_quant
  FROM shoelace_arrive shoelace_arrive, shoelace_ok shoelace_ok;
</programlisting>

<!--
    Now the first rule <literal>shoelace_ok_ins</literal> is applied and turns this
    into:
-->
最初の<literal>shoelace_ok_ins</literal>ルールが適用され、結果は以下のようになります。

<programlisting>
UPDATE shoelace
   SET sl_avail = shoelace.sl_avail + shoelace_arrive.arr_quant
  FROM shoelace_arrive shoelace_arrive, shoelace_ok shoelace_ok,
       shoelace_ok old, shoelace_ok new,
       shoelace shoelace
 WHERE shoelace.sl_name = shoelace_arrive.arr_name;
</programlisting>

<!--
    and throws away the original <command>INSERT</command> on
    <literal>shoelace_ok</literal>.  This rewritten query is passed to
    the rule system again, and the second applied rule
    <literal>shoelace_upd</literal> produces:
-->
そして、<literal>shoelace_ok</literal>に対する元の<command>INSERT</command>を破棄します。
この書き換えられた問い合わせは再びルールシステムに渡されて、2番目に適用される<literal>shoelace_upd</literal>ルールは以下を生成します。

<programlisting>
UPDATE shoelace_data
   SET sl_name = shoelace.sl_name,
       sl_avail = shoelace.sl_avail + shoelace_arrive.arr_quant,
       sl_color = shoelace.sl_color,
       sl_len = shoelace.sl_len,
       sl_unit = shoelace.sl_unit
  FROM shoelace_arrive shoelace_arrive, shoelace_ok shoelace_ok,
       shoelace_ok old, shoelace_ok new,
       shoelace shoelace, shoelace old,
       shoelace new, shoelace_data shoelace_data
 WHERE shoelace.sl_name = shoelace_arrive.arr_name
   AND shoelace_data.sl_name = shoelace.sl_name;
</programlisting>

<!--
    Again it's an <literal>INSTEAD</> rule and the previous query tree is trashed.
    Note that this query still uses the view <literal>shoelace</literal>.
    But the rule system isn't finished with this step, so it continues
    and applies the <literal>_RETURN</literal> rule on it, and we get:
-->
これは再び<literal>INSTEAD</>ルールですので、以前の問い合わせツリーは破棄されます。
この問い合わせは<literal>shoelace</literal>ビューを引き続き使用していることに注意してください。
しかし、この段階ではルールシステムは終了していないため、引き続き<literal>_RETURN</literal>ルールが適用され、下記のようになります。

<programlisting>
UPDATE shoelace_data
   SET sl_name = s.sl_name,
       sl_avail = s.sl_avail + shoelace_arrive.arr_quant,
       sl_color = s.sl_color,
       sl_len = s.sl_len,
       sl_unit = s.sl_unit
  FROM shoelace_arrive shoelace_arrive, shoelace_ok shoelace_ok,
       shoelace_ok old, shoelace_ok new,
       shoelace shoelace, shoelace old,
       shoelace new, shoelace_data shoelace_data,
       shoelace old, shoelace new,
       shoelace_data s, unit u
 WHERE s.sl_name = shoelace_arrive.arr_name
   AND shoelace_data.sl_name = s.sl_name;
</programlisting>

<!--
    Finally, the rule <literal>log_shoelace</literal> gets applied,
    producing the extra query tree:
-->
最後に、<literal>log_shoelace</literal>ルールが適用され、以下のような特別な問い合わせツリーが生成されます。

<programlisting>
INSERT INTO shoelace_log
SELECT s.sl_name,
       s.sl_avail + shoelace_arrive.arr_quant,
       current_user,
       current_timestamp
  FROM shoelace_arrive shoelace_arrive, shoelace_ok shoelace_ok,
       shoelace_ok old, shoelace_ok new,
       shoelace shoelace, shoelace old,
       shoelace new, shoelace_data shoelace_data,
       shoelace old, shoelace new,
       shoelace_data s, unit u,
       shoelace_data old, shoelace_data new
       shoelace_log shoelace_log
 WHERE s.sl_name = shoelace_arrive.arr_name
   AND shoelace_data.sl_name = s.sl_name
   AND (s.sl_avail + shoelace_arrive.arr_quant) &lt;&gt; s.sl_avail;
</programlisting>

<!--
    After that the rule system runs out of rules and returns the
    generated query trees.
-->
この後、ルールシステムはルールを使い切り、生成された問い合わせツリーを返します。
   </para>

   <para>
<!--
    So we end up with two final query trees that are equivalent to the
    <acronym>SQL</acronym> statements:
-->
そして、以下の<acronym>SQL</acronym>文と等価となる2つの最終問い合わせツリーで終結します。

<programlisting>
INSERT INTO shoelace_log
SELECT s.sl_name,
       s.sl_avail + shoelace_arrive.arr_quant,
       current_user,
       current_timestamp
  FROM shoelace_arrive shoelace_arrive, shoelace_data shoelace_data,
       shoelace_data s
 WHERE s.sl_name = shoelace_arrive.arr_name
   AND shoelace_data.sl_name = s.sl_name
   AND s.sl_avail + shoelace_arrive.arr_quant &lt;&gt; s.sl_avail;

UPDATE shoelace_data
   SET sl_avail = shoelace_data.sl_avail + shoelace_arrive.arr_quant
  FROM shoelace_arrive shoelace_arrive,
       shoelace_data shoelace_data,
       shoelace_data s
 WHERE s.sl_name = shoelace_arrive.sl_name
   AND shoelace_data.sl_name = s.sl_name;
</programlisting>

<!--
    The result is that data coming from one relation inserted into another,
    changed into updates on a third, changed into updating
    a fourth plus logging that final update in a fifth
    gets reduced into two queries.
-->
結果は、1つのリレーションから来たデータが別のリレーションに挿入され、3つ目のリレーションの更新に変更され、4つ目の更新と5つ目への最終更新のログ記録に変更され、最終的に2つの問い合わせに縮小されます。
</para>

<para>
<!--
    There is a little detail that's a bit ugly. Looking at the two
    queries, it turns out that the <literal>shoelace_data</literal>
    relation appears twice in the range table where it could
    definitely be reduced to one. The planner does not handle it and
    so the execution plan for the rule systems output of the
    <command>INSERT</command> will be
-->
ちょっと見苦しい小さな事項があります。
でき上がった2つの問い合わせを見ると、1つに縮小されたはずの<literal>shoelace_data</literal>リレーションが範囲テーブルに二度出てきます。
プランナは処理をしないので、<command>INSERT</command>のルールシステムの出力に対する実行計画は次のようになります。

<literallayout class="monospaced">
<!--
Nested Loop
  -&gt;  Merge Join
        -&gt;  Seq Scan
              -&gt;  Sort
                    -&gt;  Seq Scan on s
        -&gt;  Seq Scan
              -&gt;  Sort
                    -&gt;  Seq Scan on shoelace_arrive
  -&gt;  Seq Scan on shoelace_data
-->
入れ子状ループ
  -&gt;  マージ結合
        -&gt;  シーケンシャルスキャン
              -&gt;  ソート
                    -&gt;  sに対するシーケンシャルスキャン
        -&gt;  シーケンシャルスキャン
              -&gt;  ソート
                    -&gt;  shoelace_arriveに対するシーケンシャルスキャン
  -&gt;  shoelace_dataに対するシーケンシャルスキャン
</literallayout>

<!--
    while omitting the extra range table entry would result in a
-->
一方、余計な範囲テーブル項目を省略することで、以下のようにログテーブルにまったく同じ項目が作られます。

<literallayout class="monospaced">
<!--
Merge Join
  -&gt;  Seq Scan
        -&gt;  Sort
              -&gt;  Seq Scan on s
  -&gt;  Seq Scan
        -&gt;  Sort
              -&gt;  Seq Scan on shoelace_arrive
-->
マージ結合
  -&gt;  シーケンシャルスキャン
        -&gt;  ソート
              -&gt;  sに対するシーケンシャルスキャン
  -&gt;  シーケンシャルスキャン
        -&gt;  ソート
              -&gt;  shoelace_arriveに対するシーケンシャルスキャン
</literallayout>

<!--
    which produces exactly the same entries in the log table.  Thus,
    the rule system caused one extra scan on the table
    <literal>shoelace_data</literal> that is absolutely not
    necessary. And the same redundant scan is done once more in the
    <command>UPDATE</command>. But it was a really hard job to make
    that all possible at all.
-->
ですから、ルールシステムは、まったく必要のない<literal>shoelace_data</literal>リレーションに対する余計なスキャンを一度行うことになります。
そして<command>UPDATE</command>でも同様な不要なスキャンが再度実行されます。
しかしながら、これらを全て可能にするのは大変な仕事です。
</para>

<para>
<!--
    Now we make a final demonstration of the
    <productname>PostgreSQL</productname> rule system and its power.
    Say you add some shoelaces with extraordinary colors to your
    database:
-->
最後に<productname>PostgreSQL</productname>のルールシステムとその効力を示しましょう。
例えば、まったく売れそうもない靴紐をデータベースに追加してみます。

<programlisting>
INSERT INTO shoelace VALUES ('sl9', 0, 'pink', 35.0, 'inch', 0.0);
INSERT INTO shoelace VALUES ('sl10', 1000, 'magenta', 40.0, 'inch', 0.0);
</programlisting>

<!--
    We would like to make a view to check which
    <literal>shoelace</literal> entries do not fit any shoe in color.
    The view for this is:
-->
全ての靴に合わない色が<literal>shoelace</literal>項目にあるかどうかを検査するビューを作成したいと考えます。
ビューは以下のようになります。

<programlisting>
CREATE VIEW shoelace_mismatch AS
    SELECT * FROM shoelace WHERE NOT EXISTS
        (SELECT shoename FROM shoe WHERE slcolor = sl_color);
</programlisting>

<!--
    Its output is:
-->
この出力は以下のようになります。

<programlisting>
SELECT * FROM shoelace_mismatch;

 sl_name | sl_avail | sl_color | sl_len | sl_unit | sl_len_cm
---------+----------+----------+--------+---------+-----------
 sl9     |        0 | pink     |     35 | inch    |      88.9
 sl10    |     1000 | magenta  |     40 | inch    |     101.6
</programlisting>
   </para>

   <para>
<!--
    Now we want to set it up so that mismatching shoelaces that are
    not in stock are deleted from the database.
    To make it a little harder for <productname>PostgreSQL</productname>,
    we don't delete it directly. Instead we create one more view:
-->
ここで、合う靴がない靴紐のうち、在庫がないものをデータベースから削除するように設定してみます。
これは<productname>PostgreSQL</productname>では困難な作業ですので、直接削除しません。
代わりに、以下のようにもう1つビューを作成します。

<programlisting>
CREATE VIEW shoelace_can_delete AS
    SELECT * FROM shoelace_mismatch WHERE sl_avail = 0;
</programlisting>

<!--
    and do it this way:
-->
そして、以下を行います。

<programlisting>
DELETE FROM shoelace WHERE EXISTS
    (SELECT * FROM shoelace_can_delete
             WHERE sl_name = shoelace.sl_name);
</programlisting>

<!--
    <foreignphrase>Voil&agrave;</foreignphrase>:
-->
さあできました。

<programlisting>
SELECT * FROM shoelace;

 sl_name | sl_avail | sl_color | sl_len | sl_unit | sl_len_cm
---------+----------+----------+--------+---------+-----------
 sl1     |        5 | black    |     80 | cm      |        80
 sl2     |        6 | black    |    100 | cm      |       100
 sl7     |        6 | brown    |     60 | cm      |        60
 sl4     |        8 | black    |     40 | inch    |     101.6
 sl3     |       10 | black    |     35 | inch    |      88.9
 sl8     |       21 | brown    |     40 | inch    |     101.6
 sl10    |     1000 | magenta  |     40 | inch    |     101.6
 sl5     |        4 | brown    |      1 | m       |       100
 sl6     |       20 | brown    |    0.9 | m       |        90
(9 rows)
</programlisting>
   </para>

   <para>
<!--
    A <command>DELETE</command> on a view, with a subquery qualification that
    in total uses 4 nesting/joined views, where one of them
    itself has a subquery qualification containing a view
    and where calculated view columns are used,
    gets rewritten into
    one single query tree that deletes the requested data
    from a real table.
-->
合計4つのネスト/結合されたビューを副問い合わせの条件として持ち、その中の1つはビューを含む副問い合わせ条件を持ち、かつ演算を施されたビューの列が使われる場合の、ビューに対する<command>DELETE</command>が、実テーブルから要求されたデータを削除する単一の問い合わせツリーに書き換えられます。
</para>

<para>
<!--
    There are probably only a few situations out in the real world
    where such a construct is necessary. But it makes you feel
    comfortable that it works.
-->
このような構造が必要な状況は実社会ではほとんどないと思われます。
しかし、実際に動くことを確認できれば安心できます。
</para>
</sect2>

</sect1>

<sect1 id="rules-privileges">
<!--
<title>Rules and Privileges</title>
-->
<title>ルールと権限</title>

<indexterm zone="rules-privileges">
<!--
 <primary>privilege</primary>
 <secondary sortas="Regeln">with rules</secondary>
-->
 <primary>権限</primary>
 <secondary sortas="Regeln">ルールでの</secondary>
</indexterm>

<indexterm zone="rules-privileges">
<!--
 <primary>privilege</primary>
 <secondary sortas="Sichten">with views</secondary>
-->
 <primary>権限</primary>
 <secondary sortas="Sichten">ビューでの</secondary>
</indexterm>

<para>
<!--
    Due to rewriting of queries by the <productname>PostgreSQL</productname>
    rule system, other tables/views than those used in the original
    query get accessed. When update rules are used, this can include write access
    to tables.
-->
<productname>PostgreSQL</productname>のルールシステムによる問い合わせの書き換えによって、オリジナルの問い合わせで使われたものではない他のテーブル/ビューがアクセスされます。
更新ルールを使うことによってテーブルへの書き込みアクセスを包含することができます。
</para>

<para>
<!--
    Rewrite rules don't have a separate owner. The owner of
    a relation (table or view) is automatically the owner of the
    rewrite rules that are defined for it.
    The <productname>PostgreSQL</productname> rule system changes the
    behavior of the default access control system. Relations that
    are used due to rules get checked against the
    privileges of the rule owner, not the user invoking the rule.
    This means that a user only needs the required privileges
    for the tables/views that he names explicitly in his queries.
-->
書き換えルールに別々の所有者はいません。
リレーション（テーブルまたはビュー）の所有者は自動的にそれに定義された書き換えルールの所有者となります。
<productname>PostgreSQL</productname>のルールシステムはデフォルトのアクセス制御システムの振舞いを変更します。
ルールによって使用されるリレーションは、ルールを起動したユーザの権限ではなく、ルール所有者の権限でチェックされます。
このことは、ユーザは問い合わせで明記するテーブル/ビューに対しての権限だけあればよいことを示しています。
</para>

<para>
<!--
    For example: A user has a list of phone numbers where some of
    them are private, the others are of interest for the secretary of the office.
    He can construct the following:
-->
例えば、以下のようにします。
あるユーザが、いくつかは個人用の、その他は事務所で秘書が利用するための、電話番号のリストを持っていたとします。
ユーザは次のようにして構築することができます。

<programlisting>
CREATE TABLE phone_data (person text, phone text, private boolean);
CREATE VIEW phone_number AS
    SELECT person, CASE WHEN NOT private THEN phone END AS phone
    FROM phone_data;
GRANT SELECT ON phone_number TO secretary;
</programlisting>

<!--
    Nobody except him (and the database superusers) can access the
    <literal>phone_data</> table. But because of the <command>GRANT</>,
    the secretary can run a <command>SELECT</command> on the
    <literal>phone_number</> view. The rule system will rewrite the
    <command>SELECT</command> from <literal>phone_number</> into a
    <command>SELECT</command> from <literal>phone_data</>.
    Since the user is the owner of
    <literal>phone_number</> and therefore the owner of the rule, the
    read access to <literal>phone_data</> is now checked against his
    privileges and the query is permitted. The check for accessing
    <literal>phone_number</> is also performed, but this is done
    against the invoking user, so nobody but the user and the
    secretary can use it.
-->
そのユーザ（とデータベースのスーパーユーザ）以外は<literal>phone_data</>テーブルにアクセスできません。
しかし、<command>GRANT</>により秘書は<literal>phone_number</>ビューに対し<command>SELECT</command>できます。
ルールシステムは<literal>phone_number</>からの<command>SELECT</command>操作を<literal>phone_data</>からの<command>SELECT</command>操作に書き換えます。
そのユーザは<literal>phone_number</>の所有者、したがってルールの所有者ですから、<literal>phone_data</>の読み込みに対するアクセスはそのユーザの権限に従ってチェックされ、問い合わせを受け付けてもよいことになります。
<literal>phone_number</>へのアクセスもチェックされますが、これは呼び出したユーザに対して行われますので、秘書とユーザ以外は使うことができません。
</para>

<para>
<!--
    The privileges are checked rule by rule. So the secretary is for now the
    only one who can see the public phone numbers. But the secretary can setup
    another view and grant access to that to the public. Then, anyone
    can see the <literal>phone_number</> data through the secretary's view.
    What the secretary cannot do is to create a view that directly
    accesses <literal>phone_data</>.  (Actually he can, but it will not work since
    every access will be denied during the permission checks.)
    And as soon as the user will notice, that the secretary opened
    his <literal>phone_number</> view, he can revoke his access. Immediately, any
    access to the secretary's view would fail.
-->
権限はルールごとにチェックされます。
ですから秘書だけが今のところ公開の電話番号を参照することができます。
しかし、秘書は別のビューを作成し、それにPUBLICに対するアクセス許可を与えることができます。
こうすると秘書のビューを通して誰もが<literal>phone_number</>データを見ることができます。
秘書ができないことは<literal>phone_data</>に直接アクセスするビューを作ることです
（実際には作成はできますが、アクセスは全て、権限チェックで拒絶されます）。
そして、秘書が独自の<literal>phone_number</>ビューを開いたことにユーザが気付いた時点で、秘書の権限を取り上げることができます。
秘書のビューへのアクセスは即座に失敗に終わります。
</para>

<para>
<!--
    One might think that this rule-by-rule checking is a security
    hole, but in fact it isn't.   But if it did not work this way, the secretary
    could set up a table with the same columns as <literal>phone_number</> and
    copy the data to there once per day. Then it's his own data and
    he can grant access to everyone he wants. A
    <command>GRANT</command> command means, <quote>I trust you</quote>.
    If someone you trust does the thing above, it's time to
    think it over and then use <command>REVOKE</command>.
-->
このルールごとのチェックがセキュリティホールになると考える人がいるかもしれませんが、実際にはそうではありません。
もしこのように機能しないとなると、秘書は<literal>phone_number</>と同じ列を持ったテーブルを用意して、1日1回データをそこにコピーするかもしれません。
そうなると、データは彼のものですから、誰にアクセス権を与えようが彼の自由です。
<command>GRANT</command>は<quote>あなたを信用しています</quote>ということです。
信用している誰かがこのようなことを行った場合は、考えを変えて<command>REVOKE</command>してください。
</para>

<para>
<!--
    Note that while views can be used to hide the contents of certain
    columns using the technique shown above, they cannot be used to reliably
    conceal the data in unseen rows unless the
    <literal>security_barrier</literal> flag has been set.  For example,
    the following view is insecure:
-->
上に示したような手法を使ってある列の内容を隠すのにビューは使えますが、<literal>security_barrier</literal>フラグが設定されていない限り、見えない行にあるデータを隠す信頼できる方法ではない事に注意してください。
例えば、以下のビューは安全ではありません。
<programlisting>
CREATE VIEW phone_number AS
    SELECT person, phone FROM phone_data WHERE phone NOT LIKE '412%';
</programlisting>
<!--
    This view might seem secure, since the rule system will rewrite any
    <command>SELECT</command> from <literal>phone_number</> into a
    <command>SELECT</command> from <literal>phone_data</> and add the
    qualification that only entries where <literal>phone</> does not begin
    with 412 are wanted.  But if the user can create his or her own functions,
    it is not difficult to convince the planner to execute the user-defined
    function prior to the <function>NOT LIKE</function> expression.
    For example:
-->
ルールシステムが<literal>phone_number</>からの<command>SELECT</command>を<literal>phone_data</>からの<command>SELECT</command>に書き換え、<literal>phone</>が412で始まらない項目のみが必要だという条件を追加しますので、このビューは安全に見えます。
しかし、ユーザが自身の関数を作成できるのであれば、<function>NOT LIKE</function>式の前にユーザ定義の関数を実行するようプランナを説得することは難しくありません。
例えば以下の通りです。
<programlisting>
CREATE FUNCTION tricky(text, text) RETURNS bool AS $$
BEGIN
    RAISE NOTICE '% => %', $1, $2;
    RETURN true;
END
$$ LANGUAGE plpgsql COST 0.0000000000000000000001;

SELECT * FROM phone_number WHERE tricky(person, phone);
</programlisting>
<!--
    Every person and phone number in the <literal>phone_data</> table will be
    printed as a <literal>NOTICE</literal>, because the planner will choose to
    execute the inexpensive <function>tricky</function> function before the
    more expensive <function>NOT LIKE</function>.  Even if the user is
    prevented from defining new functions, built-in functions can be used in
    similar attacks.  (For example, most casting functions include their
    input values in the error messages they produce.)
-->
プランナはより高価な<function>NOT LIKE</function>の前に安価な<function>tricky</function>関数を実行することを選びますので、<literal>phone_data</>テーブルの人と電話番号はすべて<literal>NOTICE</literal>として表示されます。
たとえユーザが新しい関数を定義できない場合でも、同様の攻撃で組み込み関数が使えます。
（例えば、ほとんどの型変換関数は生成するエラーメッセージに入力値を含んでいます。）
</para>

<para>
<!--
    Similar considerations apply to update rules. In the examples of
    the previous section, the owner of the tables in the example
    database could grant the privileges <literal>SELECT</>,
    <literal>INSERT</>, <literal>UPDATE</>, and <literal>DELETE</> on
    the <literal>shoelace</> view to someone else, but only
    <literal>SELECT</> on <literal>shoelace_log</>. The rule action to
    write log entries will still be executed successfully, and that
    other user could see the log entries.  But he cannot create fake
    entries, nor could he manipulate or remove existing ones.  In this
    case, there is no possibility of subverting the rules by convincing
    the planner to alter the order of operations, because the only rule
    which references <literal>shoelace_log</> is an unqualified
    <literal>INSERT</>.  This might not be true in more complex scenarios.
-->
同様の考慮は更新ルールにも適用できます。
前節の例において、データベースのテーブルの所有者は<literal>shoelace</>ビューに対し、誰かに<literal>SELECT</>、<literal>INSERT</>、<literal>UPDATE</>、<literal>DELETE</>権限を与えることができます。
しかし、<literal>shoelace_log</>に対しては<literal>SELECT</>だけです。
ログ項目を書き込むルールアクションは支障なく実行され、また、他のユーザはログ項目を見ることができます。
しかし、他のユーザは項目を捏造したり、既に存在する項目を操作する、あるいは削除することはできません。
この場合、<literal>shoelace_log</>を参照しているルールは条件のない<literal>INSERT</>だけですので、操作の順序を変えるようにプランナを説得することでルールを破壊する可能性はありません。
これはより複雑な状況では正しくないかもしれません。
</para>

<para>
<!--
    When it is necessary for a view to provide row-level security, the
    <literal>security_barrier</literal> attribute should be applied to
    the view.  This prevents maliciously-chosen functions and operators from
    being invoked on rows until after the view has done its work.  For
    example, if the view shown above had been created like this, it would
    be secure:
-->
ビューが行レベルセキュリティを提供する場合には、そのビューには<literal>security_barrier</>属性を付与するべきです。
これは、悪意を持って選ばれた関数や演算子が、ビューが適用されるより前に取り出された行に対して実行されないようにします。
例えば、上記のビューが次のように定義された場合、これは安全です。
<programlisting>
CREATE VIEW phone_number WITH (security_barrier) AS
    SELECT person, phone FROM phone_data WHERE phone NOT LIKE '412%';
</programlisting>
<!--
    Views created with the <literal>security_barrier</literal> may perform
    far worse than views created without this option.  In general, there is
    no way to avoid this: the fastest possible plan must be rejected
    if it may compromise security.  For this reason, this option is not
    enabled by default.
-->
<literal>security_barrier</>を付けて定義されたビューは、このオプションなしのビューよりも性能の劣るクエリ実行プランを生成します。一般的に、最も高速だが、セキュリティ上の問題があるクエリ実行プランを破棄しなければならないという状況は不可避です。そのため、このオプションはデフォルトでは有効になっていません。
</para>

<para>
<!--
    The query planner has more flexibility when dealing with functions that
    have no side effects.  Such functions are referred to as <literal>LEAKPROOF</literal>, and
    include many simple, commonly used operators, such as many equality
    operators.  The query planner can safely allow such functions to be evaluated
    at any point in the query execution process, since invoking them on rows
    invisible to the user will not leak any information about the unseen rows.
    In contrast, a function that might throw an error depending on the values
    received as arguments (such as one that throws an error in the event of
    overflow or division by zero) are not leak-proof, and could provide
    significant information about the unseen rows if applied before the security
    view's row filters.
-->
   プランナは副作用のない関数をもう少し柔軟に扱います。これらの関数は<literal>LEAKPROOF</literal>属性を持っており、等価演算子など、単純で広く用いられる演算子も多く含まれます。利用者に対して不可視な行に対するこれら関数の呼び出しはいかなる情報も漏えいさせないため、プランナはこれらの関数をどのような場所でも安全に実行させる事ができます。
一方、例えばオーバーフローやゼロ除算のよう、受け取った引数の値に応じてエラーを発生させるような関数は leak-proof ではありません。これがもしセキュリティ・ビューの条件句でフィルタリングされるより前に適用されたなら、不可視行に関する何か重要な情報を与える事ができてしまいます。
</para>

<para>
<!--
    It is important to understand that even a view created with the
    <literal>security_barrier</literal> option is intended to be secure only
    in the limited sense that the contents of the invisible tuples will not be
    passed to possibly-insecure functions.  The user may well have other means
    of making inferences about the unseen data; for example, they can see the
    query plan using <command>EXPLAIN</command>, or measure the run time of
    queries against the view.  A malicious attacker might be able to infer
    something about the amount of unseen data, or even gain some information
    about the data distribution or most common values (since these things may
    affect the run time of the plan; or even, since they are also reflected in
    the optimizer statistics, the choice of plan).  If these types of "covert
    channel" attacks are of concern, it is probably unwise to grant any access
    to the data at all.
-->
   ビューが<literal>security_barrier</literal>属性付きで定義されたとしても、それは限定的な意味で安全である、つまり不可視な行の内容が潜在的に安全でない関数に渡される事がないという事を意図しているにすぎません。
利用者には不可視な行に対して何らかの推測を行う他の手段があるかもしれません。例えば、<command>EXPLAIN</command>を用いてクエリ実行プランを見たり、ビューに対するクエリ実行時間を計測したりすることです。
   悪意の攻撃者は不可視データの量を推測したり、分散や最頻値（なぜなら、これらは統計情報を通じて実行プランの選択、ひいては実行時間に影響するかもしれません）に関する何らかの情報を得る事ができるかもしれません。
   もし、この種の"隠れチャネル"に対する対策が必要であれば、とにかくデータに対するアクセスを許可するのは得策ではありません。
</para>
</sect1>

<sect1 id="rules-status">
<!--
<title>Rules and Command Status</title>
-->
<title>ルールおよびコマンドの状態</title>

<para>
<!--
    The <productname>PostgreSQL</productname> server returns a command
    status string, such as <literal>INSERT 149592 1</>, for each
    command it receives.  This is simple enough when there are no rules
    involved, but what happens when the query is rewritten by rules?
-->
<productname>PostgreSQL</productname>サーバでは、受け取った問い合わせのそれぞれに対して、<literal>INSERT 149592 1</>のようなコマンド状態文字列を返します。
これは簡単ですが、ルールが使用されていない場合には十分なものです。
しかし、問い合わせがルールにより書き換えられた場合、どのようになるでしょうか。
</para>

<para>
<!--
    Rules affect the command status as follows:
-->
ルールはコマンド状態に以下のように影響を与えます。

    <itemizedlist>
     <listitem>
      <para>
<!--
       If there is no unconditional <literal>INSTEAD</> rule for the query, then
       the originally given query will be executed, and its command
       status will be returned as usual.  (But note that if there were
       any conditional <literal>INSTEAD</> rules, the negation of their qualifications
       will have been added to the original query.  This might reduce the
       number of rows it processes, and if so the reported status will
       be affected.)
-->
問い合わせに無条件の<literal>INSTEAD</>ルールが使用されていない場合、元々与えられていた問い合わせが実行され、そのコマンド状態は通常通り返されます
（しかし、条件付き<literal>INSTEAD</>ルールが使用されている場合、その条件の否定が元の問い合わせに追加されることに注意してください。
これにより、処理する行の数が減り、その結果報告される状態が影響を受けるかもしれません）。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       If there is any unconditional <literal>INSTEAD</> rule for the query, then
       the original query will not be executed at all.  In this case,
       the server will return the command status for the last query
       that was inserted by an <literal>INSTEAD</> rule (conditional or
       unconditional) and is of the same command type
       (<command>INSERT</command>, <command>UPDATE</command>, or
       <command>DELETE</command>) as the original query.  If no query
       meeting those requirements is added by any rule, then the
       returned command status shows the original query type and
       zeroes for the row-count and OID fields.
-->
問い合わせに無条件の<literal>INSTEAD</>ルールが使用されている場合、元の問い合わせはまったく実行されません。
この場合、サーバでは、（条件付きもしくは無条件の）<literal>INSTEAD</>ルールによって挿入され、かつ、元の問い合わせと同じ種類（<command>INSERT</command>、<command>UPDATE</command>または<command>DELETE</command>）の最後の問い合わせについてコマンド状態を返します。
この条件に合致する問い合わせがルールによって追加されない場合、返されるコマンド状態は、元の問い合わせの種類と行数およびOIDフィールドに0が表示されます。
      </para>
     </listitem>
    </itemizedlist>
</para>

<para>
<!--
    The programmer can ensure that any desired <literal>INSTEAD</> rule is the one
    that sets the command status in the second case, by giving it the
    alphabetically last rule name among the active rules, so that it
    gets applied last.
-->
後者の場合、プログラマは、有効ルールの中でアルファベット順の最後のルール名を与えることによって、必要な<literal>INSTEAD</>ルールを最後に実行することができます。そして、そのことによって、コマンド状態が確実にそのルールで設定されるようにできます。
</para>
</sect1>

<sect1 id="rules-triggers">
<!--
<title>Rules Versus Triggers</title>
-->
<title>ルール対トリガ</title>

<indexterm zone="rules-triggers">
<!--
 <primary>rule</primary>
 <secondary sortas="Trigger">compared with triggers</secondary>
-->
 <primary>ルール</primary>
 <secondary sortas="Trigger">とトリガとの比較</secondary>
</indexterm>

<indexterm zone="rules-triggers">
<!--
 <primary>trigger</primary>
 <secondary sortas="Regeln">compared with rules</secondary>
-->
 <primary>トリガ</primary>
 <secondary sortas="Regeln">とルールとの比較</secondary>
</indexterm>

<para>
<!--
    Many things that can be done using triggers can also be
    implemented using the <productname>PostgreSQL</productname>
    rule system.  One of the things that cannot be implemented by
    rules are some kinds of constraints, especially foreign keys. It is possible
    to place a qualified rule that rewrites a command to <literal>NOTHING</>
    if the value of a column does not appear in another table.
    But then the data is silently thrown away and that's
    not a good idea. If checks for valid values are required,
    and in the case of an invalid value an error message should
    be generated, it must be done by a trigger.
-->
トリガによって行われる多くの操作は<productname>PostgreSQL</productname>のルールシステムで実装可能です。
ルールで実装できないものの1つはある種の制約、特に外部キーに関してです。
もし他のテーブルに列の値がなかった場合、条件ルールでコマンドを<literal>NOTHING</>に書き換えてしまうことも可能ですが、これではデータがだまって消去されてしまい、良いアイディアとは言えません。
有効な値かどうかのチェックが必要で、無効な値についてはエラーメッセージを表示する必要があるなら、このことは今のところトリガを使って行わなければなりません。
</para>

<para>
<!--
    In this chapter, we focused on using rules to update views. All of
    the update rule examples in this chapter can also be implemented
    using <literal>INSTEAD OF</> triggers on the views.  Writing such
    triggers is often easier than writing rules, particularly if complex
    logic is required to perform the update.
-->
この章ではビューを更新するのにルールを使うことに焦点を当ててきました。
この章の更新ルールの例はすべてビューの<literal>INSTEAD OF</>トリガを使っても実装できます。
特に更新を実行するのに複雑な論理が要求される場合には、そのようなトリガを書くことはしばしばルールを書くよりも簡単です。
</para>

<para>
<!--
    For the things that can be implemented by both, which is best
    depends on the usage of the database.
    A trigger is fired once for each affected row. A rule modifies
    the query or generates an additional query. So if many
    rows are affected in one statement, a rule issuing one extra
    command is likely to be faster than a trigger that is
    called for every single row and must re-determine what to do
    many times.  However, the trigger approach is conceptually far
    simpler than the rule approach, and is easier for novices to get right.
-->
どちらでも実装できる事項に関してどちらがベストかはデータベースの使用法によります。
トリガは各行に対して一度起動します。
ルールは問い合わせを修正するか追加の問い合わせを生成します。
ですから、1つの文が多くの行に影響を与える場合、1つの行を処理する度に呼び出され、何をするかを何度も再決定しなければならないトリガよりも、追加の問い合わせを1つ発行するルールの方がほとんどの場合高速になります。
しかし、トリガ方式は概念的にルールシステムよりかなり単純であり、初心者は簡単に正しく扱うことができます。
</para>

<para>
<!--
    Here we show an example of how the choice of rules versus triggers
    plays out in one situation.  There are two tables:
-->
ここで、ある状況下でルールとトリガのどちらを選択するかを示す例を挙げます。
例えば、2つのテーブルがあるとします。

<programlisting>
CREATE TABLE computer (
<!--
    hostname        text,    &#045;- indexed
    manufacturer    text     &#045;- indexed
-->
    hostname        text,    -- インデックスあり
    manufacturer    text     -- インデックスあり
);

CREATE TABLE software (
<!--
    software        text,    &#045;- indexed
    hostname        text     &#045;- indexed
-->
    software        text,    -- インデックスあり
    hostname        text     -- インデックスあり
);
</programlisting>

<!--
    Both tables have many thousands of rows and the indexes on
    <structfield>hostname</> are unique.  The rule or trigger should
    implement a constraint that deletes rows from <literal>software</>
    that reference a deleted computer.  The trigger would use this command:
-->
2つのテーブルにはともに数千の行があって、<structfield>hostname</>上のインデックスは一意です。
ルール/トリガは削除されたホストを参照する、<literal>software</>の行を削除する制限を実装しなければなりません。
トリガの場合は以下のコマンドを使用します。

<programlisting>
DELETE FROM software WHERE hostname = $1;
</programlisting>

<!--
    Since the trigger is called for each individual row deleted from
    <literal>computer</>, it can prepare and save the plan for this
    command and pass the <structfield>hostname</> value in the
    parameter.  The rule would be written as:
-->
<literal>computer</>から削除された行1つひとつに対してこのトリガが呼び出されますので、このコマンドの準備を行い、計画を保存し、パラメータとして<structfield>hostname</>を渡すことができます。
ルールの場合は以下のように作成されます。

<programlisting>
CREATE RULE computer_del AS ON DELETE TO computer
    DO DELETE FROM software WHERE hostname = OLD.hostname;
</programlisting>
   </para>

   <para>
<!--
    Now we look at different types of deletes. In the case of a:
-->
ここで別の類の削除を考えてみましょう。

<programlisting>
DELETE FROM computer WHERE hostname = 'mypc.local.net';
</programlisting>

<!--
    the table <literal>computer</> is scanned by index (fast), and the
    command issued by the trigger would also use an index scan (also fast).
    The extra command from the rule would be:
-->
上のような場合では、<literal>computer</>はインデックスにより（高速に）スキャンされます。
トリガによってこのコマンドが発行された場合もインデックススキャンが使用されます（高速です）。
ルールによる追加コマンドは以下のようになります。

<programlisting>
DELETE FROM software WHERE computer.hostname = 'mypc.local.net'
                       AND software.hostname = computer.hostname;
</programlisting>

<!--
    Since there are appropriate indexes setup, the planner
    will create a plan of
-->
適切なインデックスが設定されていますので、プランナは以下の計画を作成します。

<literallayout class="monospaced">
<!--
Nestloop
  -&gt;  Index Scan using comp_hostidx on computer
  -&gt;  Index Scan using soft_hostidx on software
-->
入れ子状ループ
  -&gt;  computerに対しcomp_hostidxを使用したインデックススキャン
  -&gt;  softwareに対しsoft_hostidxを使用したインデックススキャン
</literallayout>

<!--
    So there would be not that much difference in speed between
    the trigger and the rule implementation.
-->
ですので、トリガとルールの実装間での速度差はあまりありません。
   </para>

   <para>
<!--
    With the next delete we want to get rid of all the 2000 computers
    where the <structfield>hostname</> starts with
    <literal>old</>. There are two possible commands to do that. One
    is:
-->
次の削除処理では<structfield>hostname</>が<literal>old</>で始まる2,000台全てのcomputerを削除しようと思います。
方法として2つの有効な問い合わせがあって、1つは以下のようなものです。

<programlisting>
DELETE FROM computer WHERE hostname &gt;= 'old'
                       AND hostname &lt;  'ole'
</programlisting>

<!--
    The command added by the rule will be:
-->
ルールによって追加されるコマンドは以下のようになります。

<programlisting>
DELETE FROM software WHERE computer.hostname &gt;= 'old' AND computer.hostname &lt; 'ole'
                       AND software.hostname = computer.hostname;
</programlisting>

<!--
    with the plan
-->
これに対する計画は以下のようになります。

<literallayout class="monospaced">
<!--
Hash Join
  -&gt;  Seq Scan on software
  -&gt;  Hash
    -&gt;  Index Scan using comp_hostidx on computer
-->
ハッシュ結合
  -&gt;  softwareに対するシーケンシャルスキャン
  -&gt;  ハッシュ
    -&gt;  computerに対するcomp_hostidxを使用するインデックススキャン
</literallayout>

<!--
    The other possible command is:
-->
もう1つのコマンドは以下のようなものです。

<programlisting>
DELETE FROM computer WHERE hostname ~ '^old';
</programlisting>

<!--
    which results in the following executing plan for the command
    added by the rule:
-->
これにより、ルールによって追加されるコマンド用の実行計画は以下のようになります。

<literallayout class="monospaced">
<!--
Nestloop
  -&gt;  Index Scan using comp_hostidx on computer
  -&gt;  Index Scan using soft_hostidx on software
-->
入れ子状ループ
  -&gt;  computerに対するcomp_hostidxを使用するインデックススキャン
  -&gt;  softwareに対するsoft_hostidxを使用するインデックススキャン
</literallayout>

<!--
    This shows, that the planner does not realize that the
    qualification for <structfield>hostname</> in
    <literal>computer</> could also be used for an index scan on
    <literal>software</> when there are multiple qualification
    expressions combined with <literal>AND</>, which is what it does
    in the regular-expression version of the command. The trigger will
    get invoked once for each of the 2000 old computers that have to be
    deleted, and that will result in one index scan over
    <literal>computer</> and 2000 index scans over
    <literal>software</>. The rule implementation will do it with two
    commands that use indexes.  And it depends on the overall size of
    the table <literal>software</> whether the rule will still be faster in the
    sequential scan situation. 2000 command executions from the trigger over the SPI
    manager take some time, even if all the index blocks will soon be in the cache.
-->
これが示していることは、<literal>AND</>で結合された複数の検索条件が存在する場合、プランナは正規表現版のコマンドでは行っていることですが、<literal>computer</>上の<structfield>hostname</>に対する検索条件を<literal>software</>上のインデックススキャンにも同様に使用できることを理解しないということです。
トリガは削除されるべき2,000台の旧式コンピュータのそれぞれについて1回呼び出され、結果<literal>computer</>上で1回のインデックススキャンと<literal>software</>上で2,000回のインデックススキャンが行われます。
ルールによる実装ではインデックスを使用する2つの問い合わせによって実行されます。
シーケンシャルスキャンの場合でもルールがより速いかどうかは<literal>software</>テーブルの大きさに依存します。
参照する全てのインデックスブロックがすぐにキャッシュに現れるとしても、トリガによるSPIマネージャ経由の2,000回のコマンドの実行には時間を要します。
</para>

<para>
<!--
    The last command we look at is:
-->
最後のコマンドを見てみましょう。

<programlisting>
DELETE FROM computer WHERE manufacturer = 'bim';
</programlisting>

<!--
    Again this could result in many rows to be deleted from
    <literal>computer</>. So the trigger will again run many commands
    through the executor.  The command generated by the rule will be:
-->
この文でも<literal>computer</>から多くの行が削除される結果となります。
ですので、ここでもトリガはエクゼキュータを通して多くのコマンドを実行することになります。
ルールで作成されるコマンドは以下のようなものです。

<programlisting>
DELETE FROM software WHERE computer.manufacturer = 'bim'
                       AND software.hostname = computer.hostname;
</programlisting>

<!--
    The plan for that command will again be the nested loop over two
    index scans, only using a different index on <literal>computer</>:
-->
このコマンド用の計画もまた前回同様2つのインデックススキャンの入れ子状ループとなります。
<literal>computer</>の別のインデックスを使用する点のみが異なります。

<programlisting>
<!--
Nestloop
  -&gt;  Index Scan using comp_manufidx on computer
  -&gt;  Index Scan using soft_hostidx on software
-->
入れ子状ループ
  -&gt;  computerに対するcomp_manufidxを使用するインデックススキャン
  -&gt;  softwareに対するsoft_hostidxを使用するインデックススキャン
</programlisting>

<!--
    In any of these cases, the extra commands from the rule system
    will be more or less independent from the number of affected rows
    in a command.
-->
いずれの場合においても、ルールシステムが生成する追加コマンドは影響を受ける行数からは多かれ少なかれ独立しています。 
</para>

<![IGNORE[
<!-- 原文コメント What's happening with this?  If it doesn't come back, remove this section. -->
<para>
<!--
    Another situation is cases on <command>UPDATE</command> where it depends on the
    change of an attribute if an action should be performed or
    not. The only way to
    create a rule as in the shoelace_log example is to do it with
    a rule qualification. That results in an extra query that is
    performed always, even if the attribute of interest cannot
    change at all because it does not appear in the target list
    of the initial query. When this is enabled again, it will be
    one more advantage of rules over triggers. Optimization of
    a trigger must fail by definition in this case, because the
    fact that its actions will only be done when a specific attribute
    is updated is hidden in its functionality. The definition of
    a trigger only allows to specify it on row level, so whenever a
    row is touched, the trigger must be called to make its
    decision. The rule system will know it by looking up the
    target list and will suppress the additional query completely
    if the attribute isn't touched. So the rule, qualified or not,
    will only do its scans if there ever could be something to do.
-->
別の状況として、アクションを実行すべきか否かが変更された属性に依存する、<command>UPDATE</command>の場合があります。
現時点でshoelace_logの例のようなルールを作成する唯一の方法は、ルール条件を使用することです。
初めの問い合わせの目的リストに出てこないため、これは対象とする属性が変更されなくても常に実行される特別な問い合わせとなります。 
再度使えるようになった場合は、トリガに対するルールのもう1つの強みになります。
この場合、トリガの最適化はその定義により不可能です。 
特定の属性が変更された時にのみそのアクションを行うという処理自体はその（トリガ）関数内部に隠されているからです。
トリガの定義は行レベルのみに対して認められるので、行が触られるとトリガが決定が下せるようにトリガが呼び出されなければなりません。
ルールシステムの場合は対象リストを検索することで変更されたかどうかわかりますので、属性が触られていなければその後の問い合わせを全て中止することができます。
条件の有無にかかわらず、ルールは実行しなければならないことがあればスキャンを実行します。
</para>
]]>

<para>
<!--
    The summary is, rules will only be significantly slower than
    triggers if their actions result in large and badly qualified
    joins, a situation where the planner fails.
-->
まとめると、問い合わせ結果が大きく、プランナがうまく結合条件を設定できないような状況下でのみルールはトリガに比べて明らかに遅くなります。
</para>
</sect1>

</chapter>
