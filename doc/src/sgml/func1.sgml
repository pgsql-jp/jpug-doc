<!-- 警告：このファイルは直接編集しないでください！
1. func.sgmlを編集したら、split.shを起動します。
2. するとfunc[0-4].sgmlが生成されます。
3. func.sgmlとともにfunc[0-4].sgmlのうち変更されたファイルをcommit/pushしてpull requestを作成してください。
4. レビューはfunc[0-4].sgmlに対して行います。
5. 指摘された点があればfunc.sgmlに反映し、1に戻ります。
6. func.sgmlの変更がなければ、pull requestをマージして終了です。お疲れ様でした！
-->
<!-- split-func1-start -->

  <sect1 id="functions-logical">
<!--
   <title>Logical Operators</title>
-->
   <title>論理演算子</title>

   <indexterm zone="functions-logical">
    <primary>operator</primary>
    <secondary>logical</secondary>
   </indexterm>
   <indexterm zone="functions-logical">
    <primary>演算子</primary>
    <secondary>論理</secondary>
   </indexterm>

   <indexterm>
    <primary>Boolean</primary>
    <secondary>operators</secondary>
    <see>operators, logical</see>
   </indexterm>
   <indexterm>
    <primary>論理値</primary>
    <secondary>演算子</secondary>
    <see>演算子, 論理</see>
   </indexterm>

   <para>
<!--
    The usual logical operators are available:
-->
    通常の論理演算子が使用できます。

    <indexterm>
     <primary>AND (operator)</primary>
    </indexterm>
    <indexterm>
     <primary>AND（演算子）</primary>
    </indexterm>

    <indexterm>
     <primary>OR (operator)</primary>
    </indexterm>
    <indexterm>
     <primary>OR（演算子）</primary>
    </indexterm>

    <indexterm>
     <primary>NOT (operator)</primary>
    </indexterm>
    <indexterm>
     <primary>NOT（演算子）</primary>
    </indexterm>

    <indexterm>
     <primary>conjunction</primary>
    </indexterm>
    <indexterm>
     <primary>論理積</primary>
    </indexterm>

    <indexterm>
     <primary>disjunction</primary>
    </indexterm>
    <indexterm>
     <primary>論理和</primary>
    </indexterm>

    <indexterm>
     <primary>negation</primary>
    </indexterm>
    <indexterm>
     <primary>否定</primary>
    </indexterm>

<synopsis>
<type>boolean</type> <literal>AND</literal> <type>boolean</type> <returnvalue>boolean</returnvalue>
<type>boolean</type> <literal>OR</literal> <type>boolean</type> <returnvalue>boolean</returnvalue>
<literal>NOT</literal> <type>boolean</type> <returnvalue>boolean</returnvalue>
</synopsis>

<!--
    <acronym>SQL</acronym> uses a three-valued logic system with true,
    false, and <literal>null</literal>, which represents <quote>unknown</quote>.
    Observe the following truth tables:
-->
<acronym>SQL</acronym>はtrue、false、そして<quote>不明</quote>を意味する<literal>null</literal>の3値の論理システムを使用します。
以下の真理値表を参照してください。

    <informaltable>
     <tgroup cols="4">
      <thead>
       <row>
        <entry><replaceable>a</replaceable></entry>
        <entry><replaceable>b</replaceable></entry>
        <entry><replaceable>a</replaceable> AND <replaceable>b</replaceable></entry>
        <entry><replaceable>a</replaceable> OR <replaceable>b</replaceable></entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry>TRUE</entry>
        <entry>TRUE</entry>
        <entry>TRUE</entry>
        <entry>TRUE</entry>
       </row>

       <row>
        <entry>TRUE</entry>
        <entry>FALSE</entry>
        <entry>FALSE</entry>
        <entry>TRUE</entry>
       </row>

       <row>
        <entry>TRUE</entry>
        <entry>NULL</entry>
        <entry>NULL</entry>
        <entry>TRUE</entry>
       </row>

       <row>
        <entry>FALSE</entry>
        <entry>FALSE</entry>
        <entry>FALSE</entry>
        <entry>FALSE</entry>
       </row>

       <row>
        <entry>FALSE</entry>
        <entry>NULL</entry>
        <entry>FALSE</entry>
        <entry>NULL</entry>
       </row>

       <row>
        <entry>NULL</entry>
        <entry>NULL</entry>
        <entry>NULL</entry>
        <entry>NULL</entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>

    <informaltable>
     <tgroup cols="2">
      <thead>
       <row>
        <entry><replaceable>a</replaceable></entry>
        <entry>NOT <replaceable>a</replaceable></entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry>TRUE</entry>
        <entry>FALSE</entry>
       </row>

       <row>
        <entry>FALSE</entry>
        <entry>TRUE</entry>
       </row>

       <row>
        <entry>NULL</entry>
        <entry>NULL</entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>
   </para>

   <para>
<!--
    The operators <literal>AND</literal> and <literal>OR</literal> are
    commutative, that is, you can switch the left and right operands
    without affecting the result.  (However, it is not guaranteed that
    the left operand is evaluated before the right operand.  See <xref
    linkend="syntax-express-eval"/> for more information about the
    order of evaluation of subexpressions.)
-->
<literal>AND</literal>演算子と<literal>OR</literal>演算子は可換です。
つまり、結果に影響を与えることなく左右のオペランドを交換することができます。
（しかし、左オペランドが右オペランドよりも先に評価されるという保証はありません。副式の評価順についてのより詳細は<xref linkend="syntax-express-eval"/>を参照してください。）
   </para>
  </sect1>

  <sect1 id="functions-comparison">
<!--
   <title>Comparison Functions and Operators</title>
-->
   <title>比較関数および演算子</title>

   <indexterm zone="functions-comparison">
    <primary>comparison</primary>
    <secondary>operators</secondary>
   </indexterm>
   <indexterm zone="functions-comparison">
    <primary>比較</primary>
    <secondary>演算子</secondary>
   </indexterm>

   <para>
<!--
    The usual comparison operators are available, as shown in <xref
    linkend="functions-comparison-op-table"/>.
-->
<xref linkend="functions-comparison-op-table"/>に示すように、通常の比較演算子が使用可能です。
   </para>

   <table id="functions-comparison-op-table">
<!--
    <title>Comparison Operators</title>
-->
    <title>比較演算子</title>
    <tgroup cols="2">
     <thead>
      <row>
<!--
       <entry>Operator</entry>
-->
       <entry>演算子</entry>
<!--
       <entry>Description</entry>
-->
       <entry>説明</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry>
        <replaceable>datatype</replaceable> <literal>&lt;</literal> <replaceable>datatype</replaceable>
        <returnvalue>boolean</returnvalue>
       </entry>
<!--
       <entry>Less than</entry>
-->
       <entry>小なり</entry>
      </row>

      <row>
       <entry>
        <replaceable>datatype</replaceable> <literal>&gt;</literal> <replaceable>datatype</replaceable>
        <returnvalue>boolean</returnvalue>
       </entry>
<!--
       <entry>Greater than</entry>
-->
       <entry>大なり</entry>
      </row>

      <row>
       <entry>
        <replaceable>datatype</replaceable> <literal>&lt;=</literal> <replaceable>datatype</replaceable>
        <returnvalue>boolean</returnvalue>
       </entry>
<!--
       <entry>Less than or equal to</entry>
-->
       <entry>等しいかそれ以下</entry>
      </row>

      <row>
       <entry>
        <replaceable>datatype</replaceable> <literal>&gt;=</literal> <replaceable>datatype</replaceable>
        <returnvalue>boolean</returnvalue>
       </entry>
<!--
       <entry>Greater than or equal to</entry>
-->
       <entry>等しいかそれ以上</entry>
      </row>

      <row>
       <entry>
        <replaceable>datatype</replaceable> <literal>=</literal> <replaceable>datatype</replaceable>
        <returnvalue>boolean</returnvalue>
       </entry>
<!--
       <entry>Equal</entry>
-->
       <entry>等しい</entry>
      </row>

      <row>
       <entry>
        <replaceable>datatype</replaceable> <literal>&lt;&gt;</literal> <replaceable>datatype</replaceable>
        <returnvalue>boolean</returnvalue>
       </entry>
<!--
       <entry>Not equal</entry>
-->
       <entry>等しくない</entry>
      </row>

      <row>
       <entry>
        <replaceable>datatype</replaceable> <literal>!=</literal> <replaceable>datatype</replaceable>
        <returnvalue>boolean</returnvalue>
       </entry>
<!--
       <entry>Not equal</entry>
-->
       <entry>等しくない</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <note>
    <para>
<!--
     <literal>&lt;&gt;</literal> is the standard SQL notation for <quote>not
     equal</quote>.  <literal>!=</literal> is an alias, which is converted
     to <literal>&lt;&gt;</literal> at a very early stage of parsing.
     Hence, it is not possible to implement <literal>!=</literal>
     and <literal>&lt;&gt;</literal> operators that do different things.
-->
<literal>&lt;&gt;</literal>が標準SQLにおける<quote>等しくない</quote>の記法です。
<literal>!=</literal>はその別名で、構文解析のごく初期に<literal>&lt;&gt;</literal>に変換されます。
ですから<literal>!=</literal>演算子と<literal>&lt;&gt;</literal>演算子に異なる処理を行わせる実装はできません。
    </para>
   </note>

   <para>
<!--
    These comparison operators are available for all built-in data types
    that have a natural ordering, including numeric, string, and date/time
    types.  In addition, arrays, composite types, and ranges can be compared
    if their component data types are comparable.
-->
これらの比較演算子は、数値、文字列、日付、時刻データ型などの自然な順序付けを持つすべての組み込みデータ型に用意されています。
更に、要素となるデータ型が比較可能なら、配列、複合データ型、範囲は比較可能です。
   </para>

   <para>
<!--
    It is usually possible to compare values of related data
    types as well; for example <type>integer</type> <literal>&gt;</literal>
    <type>bigint</type> will work.  Some cases of this sort are implemented
    directly by <quote>cross-type</quote> comparison operators, but if no
    such operator is available, the parser will coerce the less-general type
    to the more-general type and apply the latter's comparison operator.
-->
通常関連性のあるデータ型も比較することができます。
たとえば<type>integer</type> <literal>&gt;</literal><type>bigint</type>も可能です。
ある場合にはこれらの比較は<quote>型をまたがる</quote>比較演算子で直接実装されています。そうした演算子がなければ、パーサはより一般的ではない型をより一般的な型に変換して後者の比較演算子に適用します。
   </para>

   <para>
<!--
    As shown above, all comparison operators are binary operators that
    return values of type <type>boolean</type>.  Thus, expressions like
    <literal>1 &lt; 2 &lt; 3</literal> are not valid (because there is
    no <literal>&lt;</literal> operator to compare a Boolean value with
    <literal>3</literal>).  Use the <literal>BETWEEN</literal> predicates
    shown below to perform range tests.
-->
上で示したように、全ての比較演算子は二項演算子で、<type>boolean</type>型の値を返します。
ですから<literal>1 &lt; 2 &lt; 3</literal>のような式は（ブール値と<literal>3</literal>を比較する<literal>&lt;</literal>演算子がないので）無効です。
下で示す<literal>BETWEEN</literal>述語を使って範囲検査を行ってください。
   </para>

   <para>
<!--
    There are also some comparison predicates, as shown in <xref
    linkend="functions-comparison-pred-table"/>.  These behave much like
    operators, but have special syntax mandated by the SQL standard.
-->
<xref linkend="functions-comparison-pred-table"/>に示すように、比較述語がいくつかあります。
これらは演算子と同様に振る舞いますが、標準SQLによって強制される特別の構文があります。
   </para>

   <table id="functions-comparison-pred-table">
<!--
    <title>Comparison Predicates</title>
-->
    <title>比較述語</title>
    <tgroup cols="1">
     <thead>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
<!--
        Predicate
-->
述語
       </para>
       <para>
<!--
        Description
-->
説明
       </para>
       <para>
<!--
        Example(s)
-->
例
       </para></entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>datatype</replaceable> <literal>BETWEEN</literal> <replaceable>datatype</replaceable> <literal>AND</literal> <replaceable>datatype</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Between (inclusive of the range endpoints).
-->
間にある（範囲の端点を含む）。
       </para>
       <para>
        <literal>2 BETWEEN 1 AND 3</literal>
        <returnvalue>t</returnvalue>
       </para>
       <para>
        <literal>2 BETWEEN 3 AND 1</literal>
        <returnvalue>f</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>datatype</replaceable> <literal>NOT BETWEEN</literal> <replaceable>datatype</replaceable> <literal>AND</literal> <replaceable>datatype</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Not between (the negation of <literal>BETWEEN</literal>).
-->
間にない（<literal>BETWEEN</literal>の否定）。
       </para>
       <para>
        <literal>2 NOT BETWEEN 1 AND 3</literal>
        <returnvalue>f</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>datatype</replaceable> <literal>BETWEEN SYMMETRIC</literal> <replaceable>datatype</replaceable> <literal>AND</literal> <replaceable>datatype</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Between, after sorting the two endpoint values.
-->
2つの端点値をソートした上で、間にある。
       </para>
       <para>
        <literal>2 BETWEEN SYMMETRIC 3 AND 1</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>datatype</replaceable> <literal>NOT BETWEEN SYMMETRIC</literal> <replaceable>datatype</replaceable> <literal>AND</literal> <replaceable>datatype</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Not between, after sorting the two endpoint values.
-->
2つの端点値をソートした上で、間にない。
       </para>
       <para>
        <literal>2 NOT BETWEEN SYMMETRIC 3 AND 1</literal>
        <returnvalue>f</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>datatype</replaceable> <literal>IS DISTINCT FROM</literal> <replaceable>datatype</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Not equal, treating null as a comparable value.
-->
NULLを比較可能な値とした上で、等しくない。
       </para>
       <para>
        <literal>1 IS DISTINCT FROM NULL</literal>
<!--
        <returnvalue>t</returnvalue> (rather than <literal>NULL</literal>)
-->
        <returnvalue>t</returnvalue> (<literal>NULL</literal>ではなく)
       </para>
       <para>
        <literal>NULL IS DISTINCT FROM NULL</literal>
<!--
        <returnvalue>f</returnvalue> (rather than <literal>NULL</literal>)
-->
        <returnvalue>f</returnvalue> (<literal>NULL</literal>ではなく)
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>datatype</replaceable> <literal>IS NOT DISTINCT FROM</literal> <replaceable>datatype</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Equal, treating null as a comparable value.
-->
NULLを比較可能な値とした上で、等しい。
       </para>
       <para>
        <literal>1 IS NOT DISTINCT FROM NULL</literal>
<!--
        <returnvalue>f</returnvalue> (rather than <literal>NULL</literal>)
-->
        <returnvalue>f</returnvalue> (<literal>NULL</literal>ではなく)
       </para>
       <para>
        <literal>NULL IS NOT DISTINCT FROM NULL</literal>
<!--
        <returnvalue>t</returnvalue> (rather than <literal>NULL</literal>)
-->
        <returnvalue>t</returnvalue> (<literal>NULL</literal>ではなく)
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>datatype</replaceable> <literal>IS NULL</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Test whether value is null.
-->
値がNULLかどうか検査する。
       </para>
       <para>
        <literal>1.5 IS NULL</literal>
        <returnvalue>f</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>datatype</replaceable> <literal>IS NOT NULL</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Test whether value is not null.
-->
値がNULLではないかどうか検査する。
       </para>
       <para>
        <literal>'null' IS NOT NULL</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>datatype</replaceable> <literal>ISNULL</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Test whether value is null (nonstandard syntax).
-->
値がNULLかどうか検査する。（非標準構文）
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>datatype</replaceable> <literal>NOTNULL</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Test whether value is not null (nonstandard syntax).
-->
値がNULLではないかどうか検査する。（非標準構文）
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>boolean</type> <literal>IS TRUE</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Test whether boolean expression yields true.
-->
論理式の結果が真となるかどうか検査する。
       </para>
       <para>
        <literal>true IS TRUE</literal>
        <returnvalue>t</returnvalue>
       </para>
       <para>
        <literal>NULL::boolean IS TRUE</literal>
<!--
        <returnvalue>f</returnvalue> (rather than <literal>NULL</literal>)
-->
        <returnvalue>f</returnvalue> (<literal>NULL</literal>ではなく)
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>boolean</type> <literal>IS NOT TRUE</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Test whether boolean expression yields false or unknown.
-->
論理式の結果が偽または不明となるかどうか検査する。
       </para>
       <para>
        <literal>true IS NOT TRUE</literal>
        <returnvalue>f</returnvalue>
       </para>
       <para>
        <literal>NULL::boolean IS NOT TRUE</literal>
<!--
        <returnvalue>t</returnvalue> (rather than <literal>NULL</literal>)
-->
        <returnvalue>t</returnvalue> (<literal>NULL</literal>ではなく)
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>boolean</type> <literal>IS FALSE</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Test whether boolean expression yields false.
-->
論理式の結果が偽となるかどうか検査する。
       </para>
       <para>
        <literal>true IS FALSE</literal>
        <returnvalue>f</returnvalue>
       </para>
       <para>
        <literal>NULL::boolean IS FALSE</literal>
<!--
        <returnvalue>f</returnvalue> (rather than <literal>NULL</literal>)
-->
        <returnvalue>f</returnvalue> (<literal>NULL</literal>ではなく)
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>boolean</type> <literal>IS NOT FALSE</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Test whether boolean expression yields true or unknown.
-->
論理式の結果が真または不明となるかどうか検査する。
       </para>
       <para>
        <literal>true IS NOT FALSE</literal>
        <returnvalue>t</returnvalue>
       </para>
       <para>
        <literal>NULL::boolean IS NOT FALSE</literal>
<!--
        <returnvalue>t</returnvalue> (rather than <literal>NULL</literal>)
-->
        <returnvalue>t</returnvalue> (<literal>NULL</literal>ではなく)
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>boolean</type> <literal>IS UNKNOWN</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Test whether boolean expression yields unknown.
-->
論理式の結果が不明となるかどうか検査する。
       </para>
       <para>
        <literal>true IS UNKNOWN</literal>
        <returnvalue>f</returnvalue>
       </para>
       <para>
        <literal>NULL::boolean IS UNKNOWN</literal>
<!--
        <returnvalue>t</returnvalue> (rather than <literal>NULL</literal>)
-->
        <returnvalue>t</returnvalue> (<literal>NULL</literal>ではなく)
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>boolean</type> <literal>IS NOT UNKNOWN</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Test whether boolean expression yields true or false.
-->
論理式の結果が真または偽となるかどうか検査する。
       </para>
       <para>
        <literal>true IS NOT UNKNOWN</literal>
        <returnvalue>t</returnvalue>
       </para>
       <para>
        <literal>NULL::boolean IS NOT UNKNOWN</literal>
<!--
        <returnvalue>f</returnvalue> (rather than <literal>NULL</literal>)
-->
        <returnvalue>f</returnvalue> (<literal>NULL</literal>ではなく)
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
    <indexterm>
     <primary>BETWEEN</primary>
    </indexterm>
    <indexterm>
     <primary>BETWEEN SYMMETRIC</primary>
    </indexterm>
<!--
    The <token>BETWEEN</token> predicate simplifies range tests:
-->
<token>BETWEEN</token>述語は範囲の検査を次のように単純にします。
<synopsis>
<replaceable>a</replaceable> BETWEEN <replaceable>x</replaceable> AND <replaceable>y</replaceable>
</synopsis>
<!--
    is equivalent to
-->
は
<synopsis>
<replaceable>a</replaceable> &gt;= <replaceable>x</replaceable> AND <replaceable>a</replaceable> &lt;= <replaceable>y</replaceable>
</synopsis>
と同じです。
<!--
    Notice that <token>BETWEEN</token> treats the endpoint values as included
    in the range.
    <literal>BETWEEN SYMMETRIC</literal> is like <literal>BETWEEN</literal>
    except there is no requirement that the argument to the left of
    <literal>AND</literal> be less than or equal to the argument on the right.
    If it is not, those two arguments are automatically swapped, so that
    a nonempty range is always implied.
-->
<token>BETWEEN</token>は範囲内に含まれるとして端点値を扱うことに注意してください。
<literal>BETWEEN SYMMETRIC</literal>は、<literal>AND</literal>の左側の引数が右側の引数より小さいか、もしくは等しいという必要性が無い点を除き<literal>BETWEEN</literal>と同様です。
この条件を満たしていない場合、2つの引数は自動的に交換されますので、常に空ではない範囲となります。
   </para>

   <para>
<!--
    The various variants of <literal>BETWEEN</literal> are implemented in
    terms of the ordinary comparison operators, and therefore will work for
    any data type(s) that can be compared.
-->
<literal>BETWEEN</literal>の変種は通常の比較演算子を使って実装されており、比較可能なすべてのデータ型に対して使用できます。
   </para>

   <note>
    <para>
<!--
     The use of <literal>AND</literal> in the <literal>BETWEEN</literal>
     syntax creates an ambiguity with the use of <literal>AND</literal> as a
     logical operator.  To resolve this, only a limited set of expression
     types are allowed as the second argument of a <literal>BETWEEN</literal>
     clause.  If you need to write a more complex sub-expression
     in <literal>BETWEEN</literal>, write parentheses around the
     sub-expression.
-->
<literal>BETWEEN</literal>構文中で<literal>AND</literal>を使用すると、<literal>AND</literal>を論理演算子として使うこととの曖昧さが生じます。
これを解決するために、<literal>BETWEEN</literal>句の第2引数としては限定された式の種類のみが利用できます。
<literal>BETWEEN</literal>中で複雑な副式を使用する必要がある場合は、副式を括弧で囲んでください。
    </para>
   </note>

   <para>
    <indexterm>
     <primary>IS DISTINCT FROM</primary>
    </indexterm>
    <indexterm>
     <primary>IS NOT DISTINCT FROM</primary>
    </indexterm>
<!--
    Ordinary comparison operators yield null (signifying <quote>unknown</quote>),
    not true or false, when either input is null.  For example,
    <literal>7 = NULL</literal> yields null, as does <literal>7 &lt;&gt; NULL</literal>.  When
    this behavior is not suitable, use the
    <literal>IS <optional> NOT </optional> DISTINCT FROM</literal> predicates:
-->
入力のどちらかがNULLの場合、通常の比較演算子は真や偽ではなく（<quote>不明</quote>を意味する）nullを生成します。
例えば<literal>7 = NULL</literal>はnullになります。<literal>7 &lt;&gt; NULL</literal>も同様です。
この動作が適切でない場合は、<literal>IS <optional> NOT </optional> DISTINCT FROM</literal>述語を使用してください。
<synopsis>
<replaceable>a</replaceable> IS DISTINCT FROM <replaceable>b</replaceable>
<replaceable>a</replaceable> IS NOT DISTINCT FROM <replaceable>b</replaceable>
</synopsis>
<!--
    For non-null inputs, <literal>IS DISTINCT FROM</literal> is
    the same as the <literal>&lt;&gt;</literal> operator.  However, if both
    inputs are null it returns false, and if only one input is
    null it returns true.  Similarly, <literal>IS NOT DISTINCT
    FROM</literal> is identical to <literal>=</literal> for non-null
    inputs, but it returns true when both inputs are null, and false when only
    one input is null. Thus, these predicates effectively act as though null
    were a normal data value, rather than <quote>unknown</quote>.
-->
非NULLの入力では、<literal>IS DISTINCT FROM</literal>は<literal>&lt;&gt;</literal>演算子と同じです。
しかし、入力がどちらもNULLの場合、これは偽を返し、片方の入力のみがNULLの場合は真を返します。
同様に、<literal>IS NOT DISTINCT FROM</literal>は非NULL入力では<literal>=</literal>と同じですが、両方の入力がNULLであれば真を、片方のみがNULLの場合は偽を返します。
このように、これらの述語はNULLを<quote>不明な値</quote>ではなく、通常の値かのように動作します。
   </para>

   <para>
    <indexterm>
     <primary>IS NULL</primary>
    </indexterm>
    <indexterm>
     <primary>IS NOT NULL</primary>
    </indexterm>
    <indexterm>
     <primary>ISNULL</primary>
    </indexterm>
    <indexterm>
     <primary>NOTNULL</primary>
    </indexterm>
<!--
    To check whether a value is or is not null, use the predicates:
-->
値がNULLかNULLでないかを検証するには次の述語を使います。
<synopsis>
<replaceable>expression</replaceable> IS NULL
<replaceable>expression</replaceable> IS NOT NULL
</synopsis>
<!--
    or the equivalent, but nonstandard, predicates:
-->
あるいは、これと同等の、非標準の述語も使えます。
<synopsis>
<replaceable>expression</replaceable> ISNULL
<replaceable>expression</replaceable> NOTNULL
</synopsis>
    <indexterm><primary>null value</primary><secondary>comparing</secondary></indexterm>
    <indexterm><primary>NULL値</primary><secondary>比較</secondary></indexterm>
   </para>

   <para>
<!--
    Do <emphasis>not</emphasis> write
    <literal><replaceable>expression</replaceable> = NULL</literal>
    because <literal>NULL</literal> is not <quote>equal to</quote>
    <literal>NULL</literal>.  (The null value represents an unknown value,
    and it is not known whether two unknown values are equal.)
-->
<literal>NULL</literal>と<literal>NULL</literal>とは<quote>等しい</quote>関係にはありませんので、<literal><replaceable>expression</replaceable> = NULL</literal>と記述しては<emphasis>いけません</emphasis>。
（NULL値は不明の値を表しているため、不明な値同士が同じかどうかは識別できません。）
   </para>

  <tip>
   <para>
<!--
    Some applications might expect that
    <literal><replaceable>expression</replaceable> = NULL</literal>
    returns true if <replaceable>expression</replaceable> evaluates to
    the null value.  It is highly recommended that these applications
    be modified to comply with the SQL standard. However, if that
    cannot be done the <xref linkend="guc-transform-null-equals"/>
    configuration variable is available. If it is enabled,
    <productname>PostgreSQL</productname> will convert <literal>x =
    NULL</literal> clauses to <literal>x IS NULL</literal>.
-->
アプリケーションによっては、<literal><replaceable>expression</replaceable> = NULL</literal>が、<replaceable>expression</replaceable>がNULL値と評価されるのであれば真を返すことを期待することがあります。
これらのアプリケーションを標準SQLに準拠するように変更することを強くお勧めします。
しかし、それができなければ<xref linkend="guc-transform-null-equals"/>を使用することで対応することができます。
これを有効にした場合、<productname>PostgreSQL</productname>は<literal>x = NULL</literal>句を<literal>x IS NULL</literal>に変換します。
   </para>
  </tip>

   <para>
<!--
    If the <replaceable>expression</replaceable> is row-valued, then
    <literal>IS NULL</literal> is true when the row expression itself is null
    or when all the row's fields are null, while
    <literal>IS NOT NULL</literal> is true when the row expression itself is non-null
    and all the row's fields are non-null.  Because of this behavior,
    <literal>IS NULL</literal> and <literal>IS NOT NULL</literal> do not always return
    inverse results for row-valued expressions; in particular, a row-valued
    expression that contains both null and non-null fields will return false
    for both tests.  In some cases, it may be preferable to
    write <replaceable>row</replaceable> <literal>IS DISTINCT FROM NULL</literal>
    or <replaceable>row</replaceable> <literal>IS NOT DISTINCT FROM NULL</literal>,
    which will simply check whether the overall row value is null without any
    additional tests on the row fields.
-->
<replaceable>expression</replaceable>が行値の場合、行式自体がNULLまたは、行のフィールドすべてがNULLの場合に<literal>IS NULL</literal>は真となります。
一方<literal>IS NOT NULL</literal>は、行式自体が非NULLかつ、行のフィールドすべてが非NULLの場合に真となります。
この動作により、<literal>IS NULL</literal>および<literal>IS NOT NULL</literal>は行値評価式に対し常に反対の結果を返すわけではありません。
特に、NULLと非NULLの値の両方を含む行値式はどちらの試験でも偽を返します。
場合によっては、<replaceable>row</replaceable> <literal>IS DISTINCT FROM NULL</literal>あるいは<replaceable>row</replaceable> <literal>IS NOT DISTINCT FROM NULL</literal>と記述する方が望ましいことがあるでしょう。
これらは単に行全体の値がNULLかどうかを検査し、行のフィールドについての追加的検査を全く行わないからです。
   </para>

   <para>
    <indexterm>
     <primary>IS TRUE</primary>
    </indexterm>
    <indexterm>
     <primary>IS NOT TRUE</primary>
    </indexterm>
    <indexterm>
     <primary>IS FALSE</primary>
    </indexterm>
    <indexterm>
     <primary>IS NOT FALSE</primary>
    </indexterm>
    <indexterm>
     <primary>IS UNKNOWN</primary>
    </indexterm>
    <indexterm>
     <primary>IS NOT UNKNOWN</primary>
    </indexterm>
<!--
    Boolean values can also be tested using the predicates
-->
論理値も次の述語で検証できます。
<synopsis>
<replaceable>boolean_expression</replaceable> IS TRUE
<replaceable>boolean_expression</replaceable> IS NOT TRUE
<replaceable>boolean_expression</replaceable> IS FALSE
<replaceable>boolean_expression</replaceable> IS NOT FALSE
<replaceable>boolean_expression</replaceable> IS UNKNOWN
<replaceable>boolean_expression</replaceable> IS NOT UNKNOWN
</synopsis>
<!--
    These will always return true or false, never a null value, even when the
    operand is null.
    A null input is treated as the logical value <quote>unknown</quote>.
    Notice that <literal>IS UNKNOWN</literal> and <literal>IS NOT UNKNOWN</literal> are
    effectively the same as <literal>IS NULL</literal> and
    <literal>IS NOT NULL</literal>, respectively, except that the input
    expression must be of Boolean type.
-->
これらは、常に真か偽を返し、演算項目がNULLであってもNULL値を返すことはありません。
NULL値が入力されると、<quote>不明</quote>という論理値として扱われます。
<literal>IS UNKNOWN</literal>と<literal>IS NOT UNKNOWN</literal>が、入力式が論理値型でなければならないという点を除き、それぞれ実質的に<literal>IS NULL</literal>と<literal>IS NOT NULL</literal>と同じであることに注意してください。
   </para>

   <para>
<!--
    Some comparison-related functions are also available, as shown in <xref
    linkend="functions-comparison-func-table"/>.
-->
<xref linkend="functions-comparison-func-table"/>に示すように、比較に関連した関数がいくつか使用可能です。
   </para>

  <table id="functions-comparison-func-table">
<!--
    <title>Comparison Functions</title>
-->
    <title>比較関数</title>
    <tgroup cols="1">
     <thead>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
<!--
        Function
-->
関数
       </para>
       <para>
<!--
        Description
-->
説明
       </para>
       <para>
<!--
        Example(s)
-->
例
       </para></entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>num_nonnulls</primary>
        </indexterm>
        <function>num_nonnulls</function> ( <literal>VARIADIC</literal> <type>"any"</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
<!--
        Returns the number of non-null arguments.
-->
非NULLの引数の数を返す。
       </para>
       <para>
        <literal>num_nonnulls(1, NULL, 2)</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>num_nulls</primary>
        </indexterm>
        <function>num_nulls</function> ( <literal>VARIADIC</literal> <type>"any"</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
<!--
        Returns the number of null arguments.
-->
NULL引数の数を返す。
       </para>
       <para>
        <literal>num_nulls(1, NULL, 2)</literal>
        <returnvalue>1</returnvalue>
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  </sect1>

  <sect1 id="functions-math">
<!--
   <title>Mathematical Functions and Operators</title>
-->
   <title>算術関数と演算子</title>

   <para>
<!--
    Mathematical operators are provided for many
    <productname>PostgreSQL</productname> types. For types without
    standard mathematical conventions
    (e.g., date/time types) we
    describe the actual behavior in subsequent sections.
-->
<productname>PostgreSQL</productname>の数多くの型に対する算術演算子が用意されています。
標準算術表現法が存在しない型（例えば、日付/時刻データ型）については、後続する節で実際の動作を説明します。
   </para>

   <para>
<!--
    <xref linkend="functions-math-op-table"/> shows the mathematical
    operators that are available for the standard numeric types.
    Unless otherwise noted, operators shown as
    accepting <replaceable>numeric_type</replaceable> are available for all
    the types <type>smallint</type>, <type>integer</type>,
    <type>bigint</type>, <type>numeric</type>, <type>real</type>,
    and <type>double precision</type>.
    Operators shown as accepting <replaceable>integral_type</replaceable>
    are available for the types <type>smallint</type>, <type>integer</type>,
    and <type>bigint</type>.
    Except where noted, each form of an operator returns the same data type
    as its argument(s).  Calls involving multiple argument data types, such
    as <type>integer</type> <literal>+</literal> <type>numeric</type>,
    are resolved by using the type appearing later in these lists.
-->
<xref linkend="functions-math-op-table"/>は標準の数値型で使用可能な算術演算子を示しています。
特に説明がない限り、<replaceable>numeric_type</replaceable>を受け付けると表示されている演算子はすべての<type>smallint</type>、<type>integer</type>、<type>bigint</type>、<type>numeric</type>、<type>real</type>、<type>double precision</type>データ型で利用可能です。
<replaceable>integral_type</replaceable>を受け付けると表示されている演算子はすべての<type>smallint</type>、<type>integer</type>、<type>bigint</type>データ型で利用可能です。
特に説明がない限り、それぞれの演算子は引数と同じデータ型を返します。
<type>integer</type> <literal>+</literal> <type>numeric</type>のように、複数の引数データ型が使われる呼び出しは、このリストの後で現れる型を使って解決されます。
   </para>

   <table id="functions-math-op-table">
<!--
    <title>Mathematical Operators</title>
-->
    <title>算術演算子</title>

    <tgroup cols="1">
     <thead>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
<!--
        Operator
-->
演算子
       </para>
       <para>
<!--
        Description
-->
説明
       </para>
       <para>
<!--
        Example(s)
-->
例
       </para></entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>numeric_type</replaceable> <literal>+</literal> <replaceable>numeric_type</replaceable>
        <returnvalue><replaceable>numeric_type</replaceable></returnvalue>
       </para>
       <para>
<!--
        Addition
-->
和
       </para>
       <para>
        <literal>2 + 3</literal>
        <returnvalue>5</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>+</literal> <replaceable>numeric_type</replaceable>
        <returnvalue><replaceable>numeric_type</replaceable></returnvalue>
       </para>
       <para>
<!--
        Unary plus (no operation)
-->
単項和（演算なし）
       </para>
       <para>
        <literal>+ 3.5</literal>
        <returnvalue>3.5</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>numeric_type</replaceable> <literal>-</literal> <replaceable>numeric_type</replaceable>
        <returnvalue><replaceable>numeric_type</replaceable></returnvalue>
       </para>
       <para>
<!--
        Subtraction
-->
差
       </para>
       <para>
        <literal>2 - 3</literal>
        <returnvalue>-1</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>-</literal> <replaceable>numeric_type</replaceable>
        <returnvalue><replaceable>numeric_type</replaceable></returnvalue>
       </para>
       <para>
<!--
        Negation
-->
否定
       </para>
       <para>
        <literal>- (-4)</literal>
        <returnvalue>4</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>numeric_type</replaceable> <literal>*</literal> <replaceable>numeric_type</replaceable>
        <returnvalue><replaceable>numeric_type</replaceable></returnvalue>
       </para>
       <para>
<!--
        Multiplication
-->
積
       </para>
       <para>
        <literal>2 * 3</literal>
        <returnvalue>6</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>numeric_type</replaceable> <literal>/</literal> <replaceable>numeric_type</replaceable>
        <returnvalue><replaceable>numeric_type</replaceable></returnvalue>
       </para>
       <para>
<!--
        Division (for integral types, division truncates the result towards
        zero)
-->
商（整数型では、除算によってゼロへ余りが切り捨てられます）
       </para>
       <para>
        <literal>5.0 / 2</literal>
        <returnvalue>2.5000000000000000</returnvalue>
       </para>
       <para>
        <literal>5 / 2</literal>
        <returnvalue>2</returnvalue>
       </para>
       <para>
        <literal>(-5) / 2</literal>
        <returnvalue>-2</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>numeric_type</replaceable> <literal>%</literal> <replaceable>numeric_type</replaceable>
        <returnvalue><replaceable>numeric_type</replaceable></returnvalue>
       </para>
       <para>
<!--
        Modulo (remainder); available for <type>smallint</type>,
        <type>integer</type>, <type>bigint</type>, and <type>numeric</type>
-->
剰余（余り）。<type>smallint</type>、<type>integer</type>、<type>bigint</type>、<type>numeric</type>で利用可能
       </para>
       <para>
        <literal>5 % 4</literal>
        <returnvalue>1</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>numeric</type> <literal>^</literal> <type>numeric</type>
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <type>double precision</type> <literal>^</literal> <type>double precision</type>
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
<!--
        Exponentiation
-->
累乗
       </para>
       <para>
        <literal>2 ^ 3</literal>
        <returnvalue>8</returnvalue>
       </para>
       <para>
<!--
        Unlike typical mathematical practice, multiple uses of
        <literal>^</literal> will associate left to right by default:
-->
典型的な数学的用法とは違って、デフォルトでは<literal>^</literal>は左から右に適用されます。
       </para>
       <para>
        <literal>2 ^ 3 ^ 3</literal>
        <returnvalue>512</returnvalue>
       </para>
       <para>
        <literal>2 ^ (3 ^ 3)</literal>
        <returnvalue>134217728</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>|/</literal> <type>double precision</type>
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
<!--
        Square root
-->
平方根
       </para>
       <para>
        <literal>|/ 25.0</literal>
        <returnvalue>5</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>||/</literal> <type>double precision</type>
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
<!--
        Cube root
-->
立方根
       </para>
       <para>
        <literal>||/ 64.0</literal>
        <returnvalue>4</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>@</literal> <replaceable>numeric_type</replaceable>
        <returnvalue><replaceable>numeric_type</replaceable></returnvalue>
       </para>
       <para>
<!--
        Absolute value
-->
絶対値
       </para>
       <para>
        <literal>@ -5.0</literal>
        <returnvalue>5.0</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>integral_type</replaceable> <literal>&amp;</literal> <replaceable>integral_type</replaceable>
        <returnvalue><replaceable>integral_type</replaceable></returnvalue>
       </para>
       <para>
<!--
        Bitwise AND
-->
ビットごとのAND
       </para>
       <para>
        <literal>91 &amp; 15</literal>
        <returnvalue>11</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>integral_type</replaceable> <literal>|</literal> <replaceable>integral_type</replaceable>
        <returnvalue><replaceable>integral_type</replaceable></returnvalue>
       </para>
       <para>
<!--
        Bitwise OR
-->
ビットごとのOR
       </para>
       <para>
        <literal>32 | 3</literal>
        <returnvalue>35</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>integral_type</replaceable> <literal>#</literal> <replaceable>integral_type</replaceable>
        <returnvalue><replaceable>integral_type</replaceable></returnvalue>
       </para>
       <para>
<!--
        Bitwise exclusive OR
-->
ビットごとの排他的論理和
       </para>
       <para>
        <literal>17 # 5</literal>
        <returnvalue>20</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>~</literal> <replaceable>integral_type</replaceable>
        <returnvalue><replaceable>integral_type</replaceable></returnvalue>
       </para>
       <para>
<!--
        Bitwise NOT
-->
ビットごとのNOT
       </para>
       <para>
        <literal>~1</literal>
        <returnvalue>-2</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>integral_type</replaceable> <literal>&lt;&lt;</literal> <type>integer</type>
        <returnvalue><replaceable>integral_type</replaceable></returnvalue>
       </para>
       <para>
<!--
        Bitwise shift left
-->
ビットごとの左シフト
       </para>
       <para>
        <literal>1 &lt;&lt; 4</literal>
        <returnvalue>16</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>integral_type</replaceable> <literal>&gt;&gt;</literal> <type>integer</type>
        <returnvalue><replaceable>integral_type</replaceable></returnvalue>
       </para>
       <para>
<!--
        Bitwise shift right
-->
ビットごとの右シフト
       </para>
       <para>
        <literal>8 &gt;&gt; 2</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>

     </tbody>
    </tgroup>
   </table>

  <para>
<!--
   <xref linkend="functions-math-func-table"/> shows the available
   mathematical functions.
   Many of these functions are provided in multiple forms with different
   argument types.
   Except where noted, any given form of a function returns the same
   data type as its argument(s); cross-type cases are resolved in the
   same way as explained above for operators.
   The functions working with <type>double precision</type> data are mostly
   implemented on top of the host system's C library; accuracy and behavior in
   boundary cases can therefore vary depending on the host system.
-->
<xref linkend="functions-math-func-table"/>に使用可能な算術関数を示します。
これら関数の多くは、異なる引数型を持つ複数の形で提供されています。
特に記述がある場合を除き、すべての形式の関数はその引数と同じデータ型を返します。
複数の型をまたがる場合は上記の演算子のところで説明したのと同じ方法で解決されます。
<type>double precision</type>データに対する関数のほとんどはホストシステムのCライブラリの上層に実装されています。このため、精度と境界近くの場合の振舞いはホストシステムに依存して変わります。
  </para>

   <table id="functions-math-func-table">
<!--
    <title>Mathematical Functions</title>
-->
    <title>算術関数</title>
    <tgroup cols="1">
     <thead>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
<!--
        Function
-->
関数
       </para>
       <para>
<!--
        Description
-->
説明
       </para>
       <para>
<!--
        Example(s)
-->
例
       </para></entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>abs</primary>
        </indexterm>
        <function>abs</function> ( <replaceable>numeric_type</replaceable> )
        <returnvalue><replaceable>numeric_type</replaceable></returnvalue>
       </para>
       <para>
<!--
        Absolute value
-->
絶対値
       </para>
       <para>
        <literal>abs(-17.4)</literal>
        <returnvalue>17.4</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>cbrt</primary>
        </indexterm>
        <function>cbrt</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
<!--
        Cube root
-->
立方根
       </para>
       <para>
        <literal>cbrt(64.0)</literal>
        <returnvalue>4</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ceil</primary>
        </indexterm>
        <function>ceil</function> ( <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>ceil</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
<!--
        Nearest integer greater than or equal to argument
-->
引数より大きいか等しく、引数に最も近い整数
       </para>
       <para>
        <literal>ceil(42.2)</literal>
        <returnvalue>43</returnvalue>
       </para>
       <para>
        <literal>ceil(-42.8)</literal>
        <returnvalue>-42</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ceiling</primary>
        </indexterm>
        <function>ceiling</function> ( <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>ceiling</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
<!--
        Nearest integer greater than or equal to argument (same
        as <function>ceil</function>)
-->
引数より大きいか等しく、引数に最も近い整数（<function>ceil</function>と同じ）
       </para>
       <para>
        <literal>ceiling(95.3)</literal>
        <returnvalue>96</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>degrees</primary>
        </indexterm>
        <function>degrees</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
<!--
        Converts radians to degrees
-->
ラディアンを度に変換
       </para>
       <para>
        <literal>degrees(0.5)</literal>
        <returnvalue>28.64788975654116</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>div</primary>
        </indexterm>
        <function>div</function> ( <parameter>y</parameter> <type>numeric</type>,
        <parameter>x</parameter> <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para>
<!--
        Integer quotient of <parameter>y</parameter>/<parameter>x</parameter>
        (truncates towards zero)
-->
<parameter>y</parameter>/<parameter>x</parameter>の整数商
（0に向かって切り捨て）
       </para>
       <para>
        <literal>div(9, 4)</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>erf</primary>
        </indexterm>
        <function>erf</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
<!--
        Error function
-->
誤差関数
       </para>
       <para>
        <literal>erf(1.0)</literal>
        <returnvalue>0.8427007929497149</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>erfc</primary>
        </indexterm>
        <function>erfc</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
<!--
        Complementary error function (<literal>1 - erf(x)</literal>, without
        loss of precision for large inputs)
-->
相補誤差関数（<literal>1-erf(x)</literal>、大きな入力における精度の損失なし）
       </para>
       <para>
        <literal>erfc(1.0)</literal>
        <returnvalue>0.15729920705028513</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>exp</primary>
        </indexterm>
        <function>exp</function> ( <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>exp</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
<!--
        Exponential (<literal>e</literal> raised to the given power)
-->
指数（<literal>e</literal>を底とする指定のべき乗）
       </para>
       <para>
        <literal>exp(1.0)</literal>
        <returnvalue>2.7182818284590452</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm id="function-factorial">
         <primary>factorial</primary>
        </indexterm>
        <function>factorial</function> ( <type>bigint</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para>
<!--
        Factorial
-->
階乗
       </para>
       <para>
        <literal>factorial(5)</literal>
        <returnvalue>120</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>floor</primary>
        </indexterm>
        <function>floor</function> ( <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>floor</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
<!--
        Nearest integer less than or equal to argument
-->
引数より小さいか等しく、引数に最も近い整数
       </para>
       <para>
        <literal>floor(42.8)</literal>
        <returnvalue>42</returnvalue>
       </para>
       <para>
        <literal>floor(-42.8)</literal>
        <returnvalue>-43</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>gcd</primary>
        </indexterm>
        <function>gcd</function> ( <replaceable>numeric_type</replaceable>, <replaceable>numeric_type</replaceable> )
        <returnvalue><replaceable>numeric_type</replaceable></returnvalue>
       </para>
       <para>
<!--
        Greatest common divisor (the largest positive number that divides both
        inputs with no remainder); returns <literal>0</literal> if both inputs
        are zero; available for <type>integer</type>, <type>bigint</type>,
        and <type>numeric</type>
-->
最大公約数（余りなく入力を割る最大の正の整数）。
両方の入力が0なら<literal>0</literal>を返す。
<type>integer</type>、<type>bigint</type>、<type>numeric</type>で利用可能
       </para>
       <para>
        <literal>gcd(1071, 462)</literal>
        <returnvalue>21</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>lcm</primary>
        </indexterm>
        <function>lcm</function> ( <replaceable>numeric_type</replaceable>, <replaceable>numeric_type</replaceable> )
        <returnvalue><replaceable>numeric_type</replaceable></returnvalue>
       </para>
       <para>
<!--
        Least common multiple (the smallest strictly positive number that is
        an integral multiple of both inputs); returns <literal>0</literal> if
        either input is zero; available for <type>integer</type>,
        <type>bigint</type>, and <type>numeric</type>
-->
最小公倍数（両方の入力の整数倍となる最小の厳密な正の数）。
両方の入力が0なら<literal>0</literal>を返す。
<type>integer</type>、<type>bigint</type>、<type>numeric</type>で利用可能
       </para>
       <para>
        <literal>lcm(1071, 462)</literal>
        <returnvalue>23562</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ln</primary>
        </indexterm>
        <function>ln</function> ( <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>ln</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
<!--
        Natural logarithm
-->
自然対数
       </para>
       <para>
        <literal>ln(2.0)</literal>
        <returnvalue>0.6931471805599453</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>log</primary>
        </indexterm>
        <function>log</function> ( <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>log</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
<!--
        Base 10 logarithm
-->
10を底とした対数
       </para>
       <para>
        <literal>log(100)</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>log10</primary>
        </indexterm>
        <function>log10</function> ( <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>log10</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
<!--
        Base 10 logarithm (same as <function>log</function>)
-->
10を底とした対数（<function>log</function>と同じ）
       </para>
       <para>
        <literal>log10(1000)</literal>
        <returnvalue>3</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>log</function> ( <parameter>b</parameter> <type>numeric</type>,
        <parameter>x</parameter> <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para>
<!--
        Logarithm of <parameter>x</parameter> to base <parameter>b</parameter>
-->
<parameter>b</parameter>を底とした<parameter>x</parameter>の対数
       </para>
       <para>
       <literal>log(2.0, 64.0)</literal>
       <returnvalue>6.0000000000000000</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>min_scale</primary>
        </indexterm>
        <function>min_scale</function> ( <type>numeric</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
<!--
        Minimum scale (number of fractional decimal digits) needed
        to represent the supplied value precisely
-->
与えられた値を正確に表現するのに必要な最小の桁数（小数点以下の10進の桁数）
       </para>
       <para>
        <literal>min_scale(8.4100)</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>mod</primary>
        </indexterm>
        <function>mod</function> ( <parameter>y</parameter> <replaceable>numeric_type</replaceable>,
        <parameter>x</parameter> <replaceable>numeric_type</replaceable> )
        <returnvalue><replaceable>numeric_type</replaceable></returnvalue>
       </para>
       <para>
<!--
        Remainder of <parameter>y</parameter>/<parameter>x</parameter>;
        available for <type>smallint</type>, <type>integer</type>,
        <type>bigint</type>, and <type>numeric</type>
-->
<parameter>y</parameter>/<parameter>x</parameter>の剰余。
<type>smallint</type>、<type>integer</type>、<type>bigint</type>、<type>numeric</type>で利用可能
       </para>
       <para>
        <literal>mod(9, 4)</literal>
        <returnvalue>1</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pi</primary>
        </indexterm>
        <function>pi</function> (  )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
<!--
        Approximate value of <phrase role="symbol_font">&pi;</phrase>
-->
<phrase role="symbol_font">&pi;</phrase>の近似値
       </para>
       <para>
        <literal>pi()</literal>
        <returnvalue>3.141592653589793</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>power</primary>
        </indexterm>
        <function>power</function> ( <parameter>a</parameter> <type>numeric</type>,
        <parameter>b</parameter> <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>power</function> ( <parameter>a</parameter> <type>double precision</type>,
        <parameter>b</parameter> <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
<!--
        <parameter>a</parameter> raised to the power of <parameter>b</parameter>
-->
       <parameter>a</parameter>の<parameter>b</parameter>乗
       </para>
       <para>
        <literal>power(9, 3)</literal>
        <returnvalue>729</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>radians</primary>
        </indexterm>
        <function>radians</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
<!--
        Converts degrees to radians
-->
度をラディアンに変換
       </para>
       <para>
        <literal>radians(45.0)</literal>
        <returnvalue>0.7853981633974483</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>round</primary>
        </indexterm>
        <function>round</function> ( <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>round</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
<!--
        Rounds to nearest integer.  For <type>numeric</type>, ties are
        broken by rounding away from zero.  For <type>double precision</type>,
        the tie-breaking behavior is platform dependent, but
        <quote>round to nearest even</quote> is the most common rule.
-->
最も近い整数へ丸めます。
<type>numeric</type>の場合、小数点以下を四捨五入します。
<type>double precision</type>では端数処理の振る舞いはプラットフォーム依存です。
しかし、最も普通の規則は<quote>最近接偶数への丸め(round to nearest even)</quote>です。
       </para>
       <para>
        <literal>round(42.4)</literal>
        <returnvalue>42</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>round</function> ( <parameter>v</parameter> <type>numeric</type>, <parameter>s</parameter> <type>integer</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para>
<!--
        Rounds <parameter>v</parameter> to <parameter>s</parameter> decimal
        places.  Ties are broken by rounding away from zero.
-->
<parameter>v</parameter>を小数点第<parameter>s</parameter>位まで丸めます。
小数点以下を切り上げて端数を処理します。
       </para>
       <para>
        <literal>round(42.4382, 2)</literal>
        <returnvalue>42.44</returnvalue>
       </para>
       <para>
        <literal>round(1234.56, -1)</literal>
        <returnvalue>1230</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>scale</primary>
        </indexterm>
        <function>scale</function> ( <type>numeric</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
<!--
        Scale of the argument (the number of decimal digits in the fractional part)
-->
引数の位取り（小数点以下の10進の桁数）
       </para>
       <para>
        <literal>scale(8.4100)</literal>
        <returnvalue>4</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>sign</primary>
        </indexterm>
        <function>sign</function> ( <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>sign</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
<!--
        Sign of the argument (-1, 0, or +1)
-->
引数の符号(-1, 0,あるいは +1)
       </para>
       <para>
        <literal>sign(-8.4)</literal>
        <returnvalue>-1</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>sqrt</primary>
        </indexterm>
         <function>sqrt</function> ( <type>numeric</type> )
         <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
         <function>sqrt</function> ( <type>double precision</type> )
         <returnvalue>double precision</returnvalue>
       </para>
       <para>
<!--
        Square root
-->
平方根
       </para>
       <para>
        <literal>sqrt(2)</literal>
        <returnvalue>1.4142135623730951</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>trim_scale</primary>
        </indexterm>
        <function>trim_scale</function> ( <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para>
<!--
        Reduces the value's scale (number of fractional decimal digits) by
        removing trailing zeroes
-->
後方のゼロを削除することにより値の桁数（小数点以下の10進桁数）を減じる
       </para>
       <para>
        <literal>trim_scale(8.4100)</literal>
        <returnvalue>8.41</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>trunc</primary>
        </indexterm>
        <function>trunc</function> ( <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>trunc</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
<!--
        Truncates to integer (towards zero)
-->
整数へ切り捨て（ゼロに向かって）
       </para>
       <para>
        <literal>trunc(42.8)</literal>
        <returnvalue>42</returnvalue>
       </para>
       <para>
        <literal>trunc(-42.8)</literal>
        <returnvalue>-42</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>trunc</function> ( <parameter>v</parameter> <type>numeric</type>, <parameter>s</parameter> <type>integer</type> )
       <returnvalue>numeric</returnvalue>
       </para>
       <para>
<!--
        Truncates <parameter>v</parameter> to <parameter>s</parameter>
        decimal places
-->
<parameter>v</parameter>を小数点以下<parameter>s</parameter>桁で切り捨て
       </para>
       <para>
        <literal>trunc(42.4382, 2)</literal>
        <returnvalue>42.43</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>width_bucket</primary>
        </indexterm>
        <function>width_bucket</function> ( <parameter>operand</parameter> <type>numeric</type>, <parameter>low</parameter> <type>numeric</type>, <parameter>high</parameter> <type>numeric</type>, <parameter>count</parameter> <type>integer</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para role="func_signature">
        <function>width_bucket</function> ( <parameter>operand</parameter> <type>double precision</type>, <parameter>low</parameter> <type>double precision</type>, <parameter>high</parameter> <type>double precision</type>, <parameter>count</parameter> <type>integer</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
<!--
        Returns the number of the bucket in
        which <parameter>operand</parameter> falls in a histogram
        having <parameter>count</parameter> equal-width buckets spanning the
        range <parameter>low</parameter> to <parameter>high</parameter>.
        Returns <literal>0</literal>
        or <literal><parameter>count</parameter>+1</literal> for an input
        outside that range.
-->
<parameter>low</parameter>から<parameter>high</parameter>までの範囲に広がる等幅でバケット数<parameter>count</parameter>のヒストグラムにおいて、<parameter>operand</parameter>が割り当てられるバケット番号を返す。
範囲外の入力値に対しては<literal>0</literal>または<literal><parameter>count</parameter>+1</literal>を返す。
       </para>
       <para>
        <literal>width_bucket(5.35, 0.024, 10.06, 5)</literal>
        <returnvalue>3</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>width_bucket</function> ( <parameter>operand</parameter> <type>anycompatible</type>, <parameter>thresholds</parameter> <type>anycompatiblearray</type> )
       <returnvalue>integer</returnvalue>
       </para>
       <para>
<!--
        Returns the number of the bucket in
        which <parameter>operand</parameter> falls given an array listing the
        lower bounds of the buckets.  Returns <literal>0</literal> for an
        input less than the first lower
        bound.  <parameter>operand</parameter> and the array elements can be
        of any type having standard comparison operators.
        The <parameter>thresholds</parameter> array <emphasis>must be
        sorted</emphasis>, smallest first, or unexpected results will be
        obtained.
-->
バケットの最小値を示す配列が与えられた時に、<parameter>operand</parameter>が割り当てられるバケット番号を返す。
最初の最小値よりも小さい入力値に対しては<literal>0</literal>を返す。
<parameter>operand</parameter>と配列要素は標準の比較演算子を持つ型であればどのような型でも構いません。
<parameter>thresholds</parameter>配列は<emphasis>ソートされていなければならず</emphasis>、小さいものが最初です。
さもなければ予想外の結果となるでしょう。
       </para>
       <para>
        <literal>width_bucket(now(), array['yesterday', 'today', 'tomorrow']::timestamptz[])</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <para>
<!--
    <xref linkend="functions-math-random-table"/> shows functions for
    generating random numbers.
-->
<xref linkend="functions-math-random-table"/>に乱数を生成する関数を示します。
  </para>

   <table id="functions-math-random-table">
<!--
    <title>Random Functions</title>
-->
    <title>乱数関数</title>

    <tgroup cols="1">
     <thead>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
<!--
        Function
-->
関数
       </para>
       <para>
<!--
        Description
-->
説明
       </para>
       <para>
<!--
        Example(s)
-->
例
       </para></entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>random</primary>
        </indexterm>
        <function>random</function> ( )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
<!--
        Returns a random value in the range 0.0 &lt;= x &lt; 1.0
-->
0.0 &lt;= x &lt; 1.0の範囲の乱数値を返す
       </para>
       <para>
        <literal>random()</literal>
        <returnvalue>0.897124072839091</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>random_normal</primary>
        </indexterm>

         <function>random_normal</function> (
         <optional> <parameter>mean</parameter> <type>double precision</type>
         <optional>, <parameter>stddev</parameter> <type>double precision</type> </optional></optional> )
         <returnvalue>double precision</returnvalue>
       </para>
       <para>
<!--
        Returns a random value from the normal distribution with the given
        parameters; <parameter>mean</parameter> defaults to 0.0
        and <parameter>stddev</parameter> defaults to 1.0
-->
指定されたパラメータを使用した標準偏差での乱数値を返します。
<parameter>mean</parameter>のデフォルト値は0.0、<parameter>stddev</parameter>のデフォルト値は1.0です。
       </para>
       <para>
        <literal>random_normal(0.0, 1.0)</literal>
        <returnvalue>0.051285419</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>setseed</primary>
        </indexterm>
        <function>setseed</function> ( <type>double precision</type> )
        <returnvalue>void</returnvalue>
       </para>
       <para>
<!--
        Sets the seed for subsequent <literal>random()</literal> and
        <literal>random_normal()</literal> calls;
        argument must be between -1.0 and 1.0, inclusive
-->
今後の<literal>random()</literal>と<literal>random_normal()</literal>呼び出しで使用されるシード(種)を設定します。引数は-1.0から1.0までの境界を含む値でなければなりません。
       </para>
       <para>
        <literal>setseed(0.12345)</literal>
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <para>
<!--
   The <function>random()</function> function uses a deterministic
   pseudo-random number generator.
   It is fast but not suitable for cryptographic
   applications; see the <xref linkend="pgcrypto"/> module for a more
   secure alternative.
   If <function>setseed()</function> is called, the series of results of
   subsequent <function>random()</function> calls in the current session
   can be repeated by re-issuing <function>setseed()</function> with the same
   argument.
   Without any prior <function>setseed()</function> call in the same
   session, the first <function>random()</function> call obtains a seed
   from a platform-dependent source of random bits.
   These remarks hold equally for <function>random_normal()</function>.
-->
<function>random()</function>関数は決定論的疑似乱数発生器を使用しています。
高速ですが、暗号用途には適していません。より安全な代替物として<xref linkend="pgcrypto"/>モジュールを参照してください。
<function>setseed()</function>が呼び出されると、現在のセッション内での以後の一連の<function>random()</function>の呼び出し結果は<function>setseed()</function>を同じ引数で再実行することによって再現可能となります。
同じセッション内で<function>setseed()</function>をそれ以前に呼び出していない場合は、最初の<function>random()</function>の呼び出しによってプラットフォーム依存の乱数ビットのソースからシードを入手します。
これらの注意点は<function>random_normal()</function>にも適用されます。
  </para>

  <para>
<!--
   <xref linkend="functions-math-trig-table"/> shows the
   available trigonometric functions.  Each of these functions comes in
   two variants, one that measures angles in radians and one that
   measures angles in degrees.
-->
使用可能な三角関数を<xref linkend="functions-math-trig-table"/>に示します。
それぞれの三角関数には、角度の単位をラディアンにするものと度にするものの2種類があります。
  </para>

   <table id="functions-math-trig-table">
<!--
    <title>Trigonometric Functions</title>
-->
    <title>三角関数</title>

    <tgroup cols="1">
     <thead>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
<!--
        Function
-->
関数
       </para>
       <para>
<!--
        Description
-->
説明
       </para>
       <para>
<!--
        Example(s)
-->
例
       </para></entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>acos</primary>
        </indexterm>
        <function>acos</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
<!--
        Inverse cosine, result in radians
-->
逆余弦関数、結果はラディアン
       </para>
       <para>
        <literal>acos(1)</literal>
        <returnvalue>0</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>acosd</primary>
        </indexterm>
        <function>acosd</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
<!--
        Inverse cosine, result in degrees
-->
逆余弦関数、結果は度
       </para>
       <para>
        <literal>acosd(0.5)</literal>
        <returnvalue>60</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>asin</primary>
        </indexterm>
        <function>asin</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
<!--
        Inverse sine, result in radians
-->
逆正弦関数、結果はラディアン
       </para>
       <para>
        <literal>asin(1)</literal>
        <returnvalue>1.5707963267948966</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>asind</primary>
        </indexterm>
        <function>asind</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
<!--
        Inverse sine, result in degrees
-->
逆正弦関数、結果は度
       </para>
       <para>
        <literal>asind(0.5)</literal>
        <returnvalue>30</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>atan</primary>
        </indexterm>
        <function>atan</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
<!--
        Inverse tangent, result in radians
-->
逆正接関数、結果はラディアン
       </para>
       <para>
        <literal>atan(1)</literal>
        <returnvalue>0.7853981633974483</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>atand</primary>
        </indexterm>
        <function>atand</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
<!--
        Inverse tangent, result in degrees
-->
逆正接関数、結果は度
       </para>
       <para>
        <literal>atand(1)</literal>
        <returnvalue>45</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>atan2</primary>
        </indexterm>
        <function>atan2</function> ( <parameter>y</parameter> <type>double precision</type>,
        <parameter>x</parameter> <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
<!--
        Inverse tangent of
        <parameter>y</parameter>/<parameter>x</parameter>,
        result in radians
-->
<parameter>y</parameter>/<parameter>x</parameter>の逆正接関数、結果はラディアン
       </para>
       <para>
        <literal>atan2(1, 0)</literal>
        <returnvalue>1.5707963267948966</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>atan2d</primary>
        </indexterm>
        <function>atan2d</function> ( <parameter>y</parameter> <type>double precision</type>,
        <parameter>x</parameter> <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
<!--
        Inverse tangent of
        <parameter>y</parameter>/<parameter>x</parameter>,
        result in degrees
-->
<parameter>y</parameter>/<parameter>x</parameter>の逆正接関数、結果は度
       </para>
       <para>
        <literal>atan2d(1, 0)</literal>
        <returnvalue>90</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>cos</primary>
        </indexterm>
        <function>cos</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
<!--
        Cosine, argument in radians
-->
余弦関数、引数はラディアン
       </para>
       <para>
        <literal>cos(0)</literal>
        <returnvalue>1</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>cosd</primary>
        </indexterm>
        <function>cosd</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
<!--
        Cosine, argument in degrees
-->
余弦関数、引数は度
       </para>
       <para>
        <literal>cosd(60)</literal>
        <returnvalue>0.5</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>cot</primary>
        </indexterm>
        <function>cot</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
<!--
        Cotangent, argument in radians
-->
余接関数、引数はラディアン
       </para>
       <para>
        <literal>cot(0.5)</literal>
        <returnvalue>1.830487721712452</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>cotd</primary>
        </indexterm>
        <function>cotd</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
<!--
        Cotangent, argument in degrees
-->
余接関数、引数は度
       </para>
       <para>
        <literal>cotd(45)</literal>
        <returnvalue>1</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>sin</primary>
        </indexterm>
        <function>sin</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
<!--
        Sine, argument in radians
-->
正弦関数、結果はラディアン
       </para>
       <para>
        <literal>sin(1)</literal>
        <returnvalue>0.8414709848078965</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>sind</primary>
        </indexterm>
        <function>sind</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
<!--
        Sine, argument in degrees
-->
正弦関数、結果は度
       </para>
       <para>
        <literal>sind(30)</literal>
        <returnvalue>0.5</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>tan</primary>
        </indexterm>
        <function>tan</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
<!--
        Tangent, argument in radians
-->
正接関数、引数はラディアン
       </para>
       <para>
        <literal>tan(1)</literal>
        <returnvalue>1.5574077246549023</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>tand</primary>
        </indexterm>
        <function>tand</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
<!--
        Tangent, argument in degrees
-->
正接関数、引数は度
       </para>
       <para>
        <literal>tand(45)</literal>
        <returnvalue>1</returnvalue>
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <note>
   <para>
<!--
    Another way to work with angles measured in degrees is to use the unit
    transformation functions <literal><function>radians()</function></literal>
    and <literal><function>degrees()</function></literal> shown earlier.
    However, using the degree-based trigonometric functions is preferred,
    as that way avoids round-off error for special cases such
    as <literal>sind(30)</literal>.
-->
度単位の角度を扱う別の方法は、前に示した単位変換関数<literal><function>radians()</function></literal>と<literal><function>degrees()</function></literal>を使うことです。
しかし、角度を使う方法の方が、<literal>sind(30)</literal>のような特別な場合の丸め誤差を避けられるため、推奨されます。
   </para>
  </note>

  <para>
<!--
   <xref linkend="functions-math-hyp-table"/> shows the
   available hyperbolic functions.
-->
<xref linkend="functions-math-hyp-table"/>に利用可能な双曲線関数を示します。
  </para>

  <table id="functions-math-hyp-table">
<!--
    <title>Hyperbolic Functions</title>
-->
    <title>双曲線関数</title>

    <tgroup cols="1">
     <thead>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
<!--
        Function
-->
関数
       </para>
       <para>
<!--
        Description
-->
説明
       </para>
       <para>
<!--
        Example(s)
-->
例
       </para></entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>sinh</primary>
        </indexterm>
        <function>sinh</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
<!--
        Hyperbolic sine
-->
双曲線正弦
       </para>
       <para>
        <literal>sinh(1)</literal>
        <returnvalue>1.1752011936438014</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>cosh</primary>
        </indexterm>
        <function>cosh</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
<!--
        Hyperbolic cosine
-->
双曲線余弦
       </para>
       <para>
        <literal>cosh(0)</literal>
        <returnvalue>1</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>tanh</primary>
        </indexterm>
        <function>tanh</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
<!--
        Hyperbolic tangent
-->
双曲線正接
       </para>
       <para>
        <literal>tanh(1)</literal>
        <returnvalue>0.7615941559557649</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>asinh</primary>
        </indexterm>
        <function>asinh</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
<!--
        Inverse hyperbolic sine
-->
逆双曲線正弦
       </para>
       <para>
        <literal>asinh(1)</literal>
        <returnvalue>0.881373587019543</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>acosh</primary>
        </indexterm>
        <function>acosh</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
<!--
        Inverse hyperbolic cosine
-->
逆双曲線余弦
       </para>
       <para>
        <literal>acosh(1)</literal>
        <returnvalue>0</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>atanh</primary>
        </indexterm>
        <function>atanh</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
<!--
        Inverse hyperbolic tangent
-->
逆双曲線正接
       </para>
       <para>
        <literal>atanh(0.5)</literal>
        <returnvalue>0.5493061443340548</returnvalue>
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  </sect1>


  <sect1 id="functions-string">
<!--
   <title>String Functions and Operators</title>
-->
   <title>文字列関数と演算子</title>

   <para>
<!--
    This section describes functions and operators for examining and
    manipulating string values.  Strings in this context include values
    of the types <type>character</type>, <type>character varying</type>,
    and <type>text</type>.  Except where noted, these functions and operators
    are declared to accept and return type <type>text</type>.  They will
    interchangeably accept <type>character varying</type> arguments.
    Values of type <type>character</type> will be converted
    to <type>text</type> before the function or operator is applied, resulting
    in stripping any trailing spaces in the <type>character</type> value.
-->
本節では文字列の値の調査や操作のための関数と演算子について説明します。
ここでの文字列とは<type>character</type>データ型、<type>character varying</type>データ型、および<type>text</type>データ型の値を含みます。
補足説明のない限り、下記に挙げている全ての関数は<type>text</type>型を受付、また戻り値型として返すように宣言されています。
それらは<type>character varying</type>データ型も同じように受け付けます。
<type>character</type>型の値は関数あるいは演算子に適用される前に<type>text</type>に変換され、<type>character</type>値の末尾の空白が削除されることになります。
   </para>

   <para>
<!--
    <acronym>SQL</acronym> defines some string functions that use
    key words, rather than commas, to separate
    arguments.  Details are in
    <xref linkend="functions-string-sql"/>.
    <productname>PostgreSQL</productname> also provides versions of these functions
    that use the regular function invocation syntax
    (see <xref linkend="functions-string-other"/>).
-->
<acronym>SQL</acronym>では引数の区切りにカンマではなくキーワードを使用する文字列関数をいくつか定義しています。
詳細については<xref linkend="functions-string-sql"/>を参照してください。
また<productname>PostgreSQL</productname>は、これらの関数に対して通常の関数呼び出し構文を使用するバージョンを提供します（<xref linkend="functions-string-other"/>を参照してください）。
   </para>

   <note>
    <para>
<!--
     The string concatenation operator (<literal>||</literal>) will accept
     non-string input, so long as at least one input is of string type, as shown
     in <xref linkend="functions-string-sql"/>.  For other cases, inserting an
     explicit coercion to <type>text</type> can be used to have non-string input
     accepted.
-->
文字列連結演算子（<literal>||</literal>）は<xref linkend="functions-string-sql"/>で示されるように、少なくともひとつの入力が文字列型であれば、依然として非文字列入力を受け付けます。
その他の場合には非文字列入力を受け付けるために、<type>text</type>への明示的な変換を行うことが可能です。
    </para>
   </note>

   <table id="functions-string-sql">
<!--
    <title><acronym>SQL</acronym> String Functions and Operators</title>
-->
    <title><acronym>SQL</acronym>文字列関数と演算子</title>
    <tgroup cols="1">
     <thead>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
<!--
        Function/Operator
-->
関数/演算子
       </para>
       <para>
<!--
        Description
-->
説明
       </para>
       <para>
<!--
        Example(s)
-->
例
       </para></entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>character string</primary>
         <secondary>concatenation</secondary>
        </indexterm>
        <indexterm>
         <primary>文字列</primary>
         <secondary>結合</secondary>
        </indexterm>
        <type>text</type> <literal>||</literal> <type>text</type>
        <returnvalue>text</returnvalue>
       </para>
       <para>
<!--
        Concatenates the two strings.
-->
2つの文字列を結合します。
       </para>
       <para>
        <literal>'Post' || 'greSQL'</literal>
        <returnvalue>PostgreSQL</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>text</type> <literal>||</literal> <type>anynonarray</type>
        <returnvalue>text</returnvalue>
       </para>
       <para role="func_signature">
        <type>anynonarray</type> <literal>||</literal> <type>text</type>
        <returnvalue>text</returnvalue>
       </para>
       <para>
<!--
        Converts the non-string input to text, then concatenates the two
        strings.  (The non-string input cannot be of an array type, because
        that would create ambiguity with the array <literal>||</literal>
        operators.  If you want to concatenate an array's text equivalent,
        cast it to <type>text</type> explicitly.)
-->
非文字列の入力をテキストに変換したのちに2つの文字列を結合します。
（非文字列の入力は配列型であってはいけません。配列の<literal>||</literal>演算子との間で曖昧性が生じるからです。
配列のテキストあるいは類似のものを結合する場合は明示的に<type>text</type>にキャストしてください。）
       </para>
       <para>
        <literal>'Value: ' || 42</literal>
        <returnvalue>Value: 42</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>btrim</primary>
        </indexterm>
        <function>btrim</function> ( <parameter>string</parameter> <type>text</type>
        <optional>, <parameter>characters</parameter> <type>text</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
<!--
        Removes the longest string containing only characters
        in <parameter>characters</parameter> (a space by default)
        from the start and end of <parameter>string</parameter>.
-->
<parameter>string</parameter>から<parameter>characters</parameter>（空白一文字がデフォルト）に現れる文字のみを含む最長の文字列を先頭と末尾から取り除きます。
       </para>
       <para>
        <literal>btrim('xyxtrimyyx', 'xyz')</literal>
        <returnvalue>trim</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>normalized</primary>
        </indexterm>
        <indexterm>
         <primary>Unicode normalization</primary>
        </indexterm>
         <type>text</type> <literal>IS</literal> <optional><literal>NOT</literal></optional> <optional><parameter>form</parameter></optional> <literal>NORMALIZED</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Checks whether the string is in the specified Unicode normalization
        form.  The optional <parameter>form</parameter> key word specifies the
        form: <literal>NFC</literal> (the default), <literal>NFD</literal>,
        <literal>NFKC</literal>, or <literal>NFKD</literal>.  This expression can
        only be used when the server encoding is <literal>UTF8</literal>.  Note
        that checking for normalization using this expression is often faster
        than normalizing possibly already normalized strings.
-->
文字列が指定したUnicode正規形の範囲かどうかをチェックします。
オプションの<parameter>form</parameter>キーワードは正規形を指定します。<literal>NFC</literal> (デフォルトです)、<literal>NFD</literal>、<literal>NFKC</literal>あるいは<literal>NFKD</literal>です。
この式はサーバエンコーディングが<literal>UTF8</literal>のときだけ使用できます。
この式を用いた正規形のチェックは、しばしばすでに正規化されている可能性のある文字列を正規化するよりも高速であることに注意してください。
       </para>
       <para>
        <literal>U&amp;'\0061\0308bc' IS NFD NORMALIZED</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>bit_length</primary>
        </indexterm>
        <function>bit_length</function> ( <type>text</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
<!--
        Returns number of bits in the string (8
        times the <function>octet_length</function>).
-->
文字列中のビット数を返します（<function>octet_length</function>の8倍です。）
       </para>
       <para>
        <literal>bit_length('jose')</literal>
        <returnvalue>32</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>char_length</primary>
        </indexterm>
        <indexterm>
         <primary>character string</primary>
         <secondary>length</secondary>
        </indexterm>
        <indexterm>
         <primary>文字列</primary>
         <secondary>長さ</secondary>
        </indexterm>
        <indexterm>
         <primary>length</primary>
         <secondary sortas="character string">of a character string</secondary>
         <see>character string, length</see>
        </indexterm>
        <indexterm>
         <primary>長さ</primary>
         <secondary sortas="character string">文字列の</secondary>
         <see>文字列, 長さ</see>
        </indexterm>
        <function>char_length</function> ( <type>text</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>character_length</primary>
        </indexterm>
        <function>character_length</function> ( <type>text</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
<!--
        Returns number of characters in the string.
-->
文字列中の文字数を返します。
       </para>
       <para>
        <literal>char_length('jos&eacute;')</literal>
        <returnvalue>4</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>lower</primary>
        </indexterm>
        <function>lower</function> ( <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
<!--
        Converts the string to all lower case, according to the rules of the
        database's locale.
-->
データベースの照合順のルールに従い、文字列をすべて小文字に変換します。
       </para>
       <para>
        <literal>lower('TOM')</literal>
        <returnvalue>tom</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>lpad</primary>
        </indexterm>
        <function>lpad</function> ( <parameter>string</parameter> <type>text</type>,
        <parameter>length</parameter> <type>integer</type>
        <optional>, <parameter>fill</parameter> <type>text</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
<!--
        Extends the <parameter>string</parameter> to length
        <parameter>length</parameter> by prepending the characters
        <parameter>fill</parameter> (a space by default).  If the
        <parameter>string</parameter> is already longer than
        <parameter>length</parameter> then it is truncated (on the right).
-->
文字<parameter>fill</parameter>（デフォルトは空白文字）を文字列の前に追加して、<parameter>string</parameter>を<parameter>length</parameter>の長さにします。
<parameter>string</parameter>が既に<parameter>length</parameter>の長さを超えている場合は（右側が）切り捨てられます。
       </para>
       <para>
        <literal>lpad('hi', 5, 'xy')</literal>
        <returnvalue>xyxhi</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ltrim</primary>
        </indexterm>
        <function>ltrim</function> ( <parameter>string</parameter> <type>text</type>
        <optional>, <parameter>characters</parameter> <type>text</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
<!--
        Removes the longest string containing only characters in
        <parameter>characters</parameter> (a space by default) from the start of
        <parameter>string</parameter>.
-->
<parameter>string</parameter>から<parameter>characters</parameter>（空白一文字がデフォルト）に現れる文字のみを含む最長の文字列を先頭から取り除きます。
       </para>
       <para>
        <literal>ltrim('zzzytest', 'xyz')</literal>
        <returnvalue>test</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>normalize</primary>
        </indexterm>
        <indexterm>
         <primary>Unicode normalization</primary>
        </indexterm>
        <function>normalize</function> ( <type>text</type>
        <optional>, <parameter>form</parameter> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
<!--
        Converts the string to the specified Unicode
        normalization form.  The optional <parameter>form</parameter> key word
        specifies the form: <literal>NFC</literal> (the default),
        <literal>NFD</literal>, <literal>NFKC</literal>, or
        <literal>NFKD</literal>.  This function can only be used when the
        server encoding is <literal>UTF8</literal>.
-->
文字列を指定したUnicode正規形に変換します。
オプションの<parameter>form</parameter>キーワードは正規形を指定します。<literal>NFC</literal> (デフォルトです)、<literal>NFD</literal>、<literal>NFKC</literal>あるいは<literal>NFKD</literal>です。
この式はサーバエンコーディングが<literal>UTF8</literal>のときだけ使用できます。
       </para>
       <para>
        <literal>normalize(U&amp;'\0061\0308bc', NFC)</literal>
        <returnvalue>U&amp;'\00E4bc'</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>octet_length</primary>
        </indexterm>
        <function>octet_length</function> ( <type>text</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
<!--
        Returns number of bytes in the string.
-->
文字列のバイト数を返します。
       </para>
       <para>
        <literal>octet_length('jos&eacute;')</literal>
<!--
        <returnvalue>5</returnvalue> (if server encoding is UTF8)
-->
<returnvalue>5</returnvalue>（サーバエンコーディングがUTF8の場合）
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>octet_length</primary>
        </indexterm>
        <function>octet_length</function> ( <type>character</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
<!--
        Returns number of bytes in the string.  Since this version of the
        function accepts type <type>character</type> directly, it will not
        strip trailing spaces.
-->
文字列のバイト数を返します。
このバージョンの関数は直接<type>character</type>型を受け付けるので、末尾の空白を削除しません。
       </para>
       <para>
        <literal>octet_length('abc '::character(4))</literal>
        <returnvalue>4</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>overlay</primary>
        </indexterm>
        <function>overlay</function> ( <parameter>string</parameter> <type>text</type> <literal>PLACING</literal> <parameter>newsubstring</parameter> <type>text</type> <literal>FROM</literal> <parameter>start</parameter> <type>integer</type> <optional> <literal>FOR</literal> <parameter>count</parameter> <type>integer</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
<!--
        Replaces the substring of <parameter>string</parameter> that starts at
        the <parameter>start</parameter>'th character and extends
        for <parameter>count</parameter> characters
        with <parameter>newsubstring</parameter>.
        If <parameter>count</parameter> is omitted, it defaults to the length
        of <parameter>newsubstring</parameter>.
-->
<parameter>string</parameter>の<parameter>start</parameter>文字目から<parameter>count</parameter>文字を<parameter>newsubstring</parameter>で置き換えます。
<parameter>count</parameter>を省略すると<parameter>newsubstring</parameter>の長さがデフォルトになります。
       </para>
       <para>
        <literal>overlay('Txxxxas' placing 'hom' from 2 for 4)</literal>
        <returnvalue>Thomas</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>position</primary>
        </indexterm>
        <function>position</function> ( <parameter>substring</parameter> <type>text</type> <literal>IN</literal> <parameter>string</parameter> <type>text</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
<!--
        Returns first starting index of the specified
        <parameter>substring</parameter> within
        <parameter>string</parameter>, or zero if it's not present.
-->
<parameter>string</parameter>中の<parameter>substring</parameter>で指定する文字列の最初の開始位置を返します。0ならその文字列は存在しません。
       </para>
       <para>
        <literal>position('om' in 'Thomas')</literal>
        <returnvalue>3</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>rpad</primary>
        </indexterm>
        <function>rpad</function> ( <parameter>string</parameter> <type>text</type>,
        <parameter>length</parameter> <type>integer</type>
        <optional>, <parameter>fill</parameter> <type>text</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
<!--
        Extends the <parameter>string</parameter> to length
        <parameter>length</parameter> by appending the characters
        <parameter>fill</parameter> (a space by default).  If the
        <parameter>string</parameter> is already longer than
        <parameter>length</parameter> then it is truncated.
-->
文字<parameter>fill</parameter>（デフォルトは空白文字）を文字列に追加して、<parameter>string</parameter>を<parameter>length</parameter>の長さにします。
<parameter>string</parameter>が既に<parameter>length</parameter>の長さを超えている場合は切り捨てられます。
       </para>
       <para>
        <literal>rpad('hi', 5, 'xy')</literal>
        <returnvalue>hixyx</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>rtrim</primary>
        </indexterm>
        <function>rtrim</function> ( <parameter>string</parameter> <type>text</type>
         <optional>, <parameter>characters</parameter> <type>text</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
<!--
        Removes the longest string containing only characters in
        <parameter>characters</parameter> (a space by default) from the end of
        <parameter>string</parameter>.
-->
<parameter>string</parameter>から<parameter>characters</parameter>（空白一文字がデフォルト）に現れる文字のみを含む最長の文字列を末尾から取り除きます。
       </para>
       <para>
        <literal>rtrim('testxxzx', 'xyz')</literal>
        <returnvalue>test</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>substring</primary>
        </indexterm>
        <function>substring</function> ( <parameter>string</parameter> <type>text</type> <optional> <literal>FROM</literal> <parameter>start</parameter> <type>integer</type> </optional> <optional> <literal>FOR</literal> <parameter>count</parameter> <type>integer</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
<!--
        Extracts the substring of <parameter>string</parameter> starting at
        the <parameter>start</parameter>'th character if that is specified,
        and stopping after <parameter>count</parameter> characters if that is
        specified.  Provide at least one of <parameter>start</parameter>
        and <parameter>count</parameter>.
-->
<parameter>start</parameter>が指定されていれば<parameter>start</parameter>番目の文字で始まる<parameter>string</parameter>の部分文字列を返します。
<parameter>count</parameter>が指定されていれば<parameter>count</parameter>数の文字を取り出します。
少なくとも<parameter>start</parameter>か<parameter>count</parameter>のどちらかを指定してください。
       </para>
       <para>
        <literal>substring('Thomas' from 2 for 3)</literal>
        <returnvalue>hom</returnvalue>
       </para>
       <para>
        <literal>substring('Thomas' from 3)</literal>
        <returnvalue>omas</returnvalue>
       </para>
       <para>
        <literal>substring('Thomas' for 2)</literal>
        <returnvalue>Th</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>substring</function> ( <parameter>string</parameter> <type>text</type> <literal>FROM</literal> <parameter>pattern</parameter> <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
<!--
        Extracts the first substring matching POSIX regular expression; see
        <xref linkend="functions-posix-regexp"/>.
-->
POSIX正規表現にマッチする最初の部分文字列を返します。<xref linkend="functions-posix-regexp"/>を参照してください。
       </para>
       <para>
        <literal>substring('Thomas' from '...$')</literal>
        <returnvalue>mas</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>substring</function> ( <parameter>string</parameter> <type>text</type> <literal>SIMILAR</literal> <parameter>pattern</parameter> <type>text</type> <literal>ESCAPE</literal> <parameter>escape</parameter> <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para role="func_signature">
        <function>substring</function> ( <parameter>string</parameter> <type>text</type> <literal>FROM</literal> <parameter>pattern</parameter> <type>text</type> <literal>FOR</literal> <parameter>escape</parameter> <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
<!--
        Extracts the first substring matching <acronym>SQL</acronym> regular expression;
        see <xref linkend="functions-similarto-regexp"/>.  The first form has
        been specified since SQL:2003; the second form was only in SQL:1999
        and should be considered obsolete.
-->
<acronym>SQL</acronym>正規表現にマッチする最初の部分文字列を返します。<xref linkend="functions-similarto-regexp"/>を参照してください。
最初の形式はSQL:2003以降で指定されています。2番目の形式はSQL:1999でのみ指定されており、廃れていると考えるべきでしょう。
       </para>
       <para>
        <literal>substring('Thomas' similar '%#"o_a#"_' escape '#')</literal>
        <returnvalue>oma</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>trim</primary>
        </indexterm>
        <function>trim</function> ( <optional> <literal>LEADING</literal> | <literal>TRAILING</literal> | <literal>BOTH</literal> </optional>
        <optional> <parameter>characters</parameter> <type>text</type> </optional> <literal>FROM</literal>
        <parameter>string</parameter> <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
<!--
        Removes the longest string containing only characters in
        <parameter>characters</parameter> (a space by default) from the
        start, end, or both ends (<literal>BOTH</literal> is the default)
        of <parameter>string</parameter>.
-->
<parameter>string</parameter>から<parameter>characters</parameter>（空白一文字がデフォルト）に現れる文字のみを含む最長の文字列を先頭、末尾、あるいはその両方（<literal>BOTH</literal>がデフォルト）から取り除きます。
       </para>
       <para>
        <literal>trim(both 'xyz' from 'yxTomxx')</literal>
        <returnvalue>Tom</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>trim</function> ( <optional> <literal>LEADING</literal> | <literal>TRAILING</literal> | <literal>BOTH</literal> </optional> <optional> <literal>FROM</literal> </optional>
        <parameter>string</parameter> <type>text</type> <optional>,
        <parameter>characters</parameter> <type>text</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
<!--
        This is a non-standard syntax for <function>trim()</function>.
-->
これは<function>trim()</function>の非標準構文です。
       </para>
       <para>
        <literal>trim(both from 'yxTomxx', 'xyz')</literal>
        <returnvalue>Tom</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>upper</primary>
        </indexterm>
        <function>upper</function> ( <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
<!--
        Converts the string to all upper case, according to the rules of the
        database's locale.
-->
データベースの照合順のルールに従い、文字列をすべて大文字に変換します。
       </para>
       <para>
        <literal>upper('tom')</literal>
        <returnvalue>TOM</returnvalue>
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
<!--
    Additional string manipulation functions and operators are available
    and are listed in <xref linkend="functions-string-other"/>.  (Some of
    these are used internally to implement
    the <acronym>SQL</acronym>-standard string functions listed in
    <xref linkend="functions-string-sql"/>.)
    There are also pattern-matching operators, which are described in
    <xref linkend="functions-matching"/>, and operators for full-text
    search, which are described in <xref linkend="textsearch"/>.
-->
この他、<xref linkend="functions-string-other"/>に列挙する文字列操作関数と演算子が使えます。
（そのいくつかは、<xref linkend="functions-string-sql"/>で列挙した標準<acronym>SQL</acronym>の文字列関数を実装するため、内部的に使用されます。）
また、<xref linkend="functions-matching"/>で説明するしたパターンマッチ演算子と、<xref linkend="textsearch"/>で説明する全文検索用の演算子もあります。
   </para>

   <table id="functions-string-other">
<!--
    <title>Other String Functions and Operators</title>
-->
    <title>その他の文字列操作関数と演算子</title>
    <tgroup cols="1">
     <thead>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
<!--
        Function/Operator
-->
関数/演算子
       </para>
       <para>
<!--
        Description
-->
説明
       </para>
       <para>
<!--
        Example(s)
-->
例
       </para></entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>character string</primary>
         <secondary>prefix test</secondary>
        </indexterm>
        <indexterm>
         <primary>文字列</primary>
         <secondary>接頭辞テスト</secondary>
        </indexterm>
        <type>text</type> <literal>^@</literal> <type>text</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Returns true if the first string starts with the second string
        (equivalent to the <function>starts_with()</function> function).
-->
最初の文字列が2番目の文字列で始まる場合に真を返します（<function>starts_with()</function>関数と同じです）。
       </para>
       <para>
        <literal>'alphabet' ^@ 'alph'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ascii</primary>
        </indexterm>
        <function>ascii</function> ( <type>text</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
<!--
        Returns the numeric code of the first character of the argument.
        In <acronym>UTF8</acronym> encoding, returns the Unicode code point
        of the character.  In other multibyte encodings, the argument must
        be an <acronym>ASCII</acronym> character.
-->
引数の最初の文字の数値コードを返します。
<acronym>UTF8</acronym>符号化方式ではその文字のUnicodeコードポイントを返します。
その他のマルチバイト符号化方式の場合、引数は<acronym>ASCII</acronym>文字でなくてはなりません。
       </para>
       <para>
        <literal>ascii('x')</literal>
        <returnvalue>120</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>chr</primary>
        </indexterm>
        <function>chr</function> ( <type>integer</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
<!--
        Returns the character with the given code. In <acronym>UTF8</acronym>
        encoding the argument is treated as a Unicode code point. In other
        multibyte encodings the argument must designate
        an <acronym>ASCII</acronym> character.  <literal>chr(0)</literal> is
        disallowed because text data types cannot store that character.
-->
与えられたコードの文字を返します。
<acronym>UTF8</acronym>符号化方式では、引数はUnicodeコードポイントと見なされます。
その他のマルチバイト符号化方式の場合、引数は指定の<acronym>ASCII</acronym>文字でなくてはなりません。
<literal>chr(0)</literal>は禁止されています。テキストデータ型はその文字を格納できないからです。
      </para>
      <para>
        <literal>chr(65)</literal>
        <returnvalue>A</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>concat</primary>
        </indexterm>
        <function>concat</function> ( <parameter>val1</parameter> <type>"any"</type>
         [, <parameter>val2</parameter> <type>"any"</type> [, ...] ] )
        <returnvalue>text</returnvalue>
       </para>
       <para>
<!--
        Concatenates the text representations of all the arguments.
        NULL arguments are ignored.
-->
引数をテキスト形式にしたものを結合します。
NULL引数は無視されます。
       </para>
       <para>
        <literal>concat('abcde', 2, NULL, 22)</literal>
        <returnvalue>abcde222</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>concat_ws</primary>
        </indexterm>
        <function>concat_ws</function> ( <parameter>sep</parameter> <type>text</type>,
        <parameter>val1</parameter> <type>"any"</type>
        [, <parameter>val2</parameter> <type>"any"</type> [, ...] ] )
        <returnvalue>text</returnvalue>
       </para>
       <para>
<!--
        Concatenates all but the first argument, with separators. The first
        argument is used as the separator string, and should not be NULL.
        Other NULL arguments are ignored.
-->
最初の引数以外をセパレータとともに結合します。
最初の引数はセパレータ文字列として使われ、NULLにすべきではありません。
それ以外のNULLの引数は無視されます。
       </para>
       <para>
        <literal>concat_ws(',', 'abcde', 2, NULL, 22)</literal>
        <returnvalue>abcde,2,22</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>format</primary>
        </indexterm>
        <function>format</function> ( <parameter>formatstr</parameter> <type>text</type>
        [, <parameter>formatarg</parameter> <type>"any"</type> [, ...] ] )
        <returnvalue>text</returnvalue>
       </para>
       <para>
<!--
         Formats arguments according to a format string;
         see <xref linkend="functions-string-format"/>.
         This function is similar to the C function <function>sprintf</function>.
-->
引数の書式をフォーマット文字列に従って整形します。
<xref linkend="functions-string-format"/>を参照してください。
この関数はC言語関数の<function>sprintf</function>と似ています。
       </para>
       <para>
        <literal>format('Hello %s, %1$s', 'World')</literal>
        <returnvalue>Hello World, World</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>initcap</primary>
        </indexterm>
        <function>initcap</function> ( <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
<!--
        Converts the first letter of each word to upper case and the
        rest to lower case. Words are sequences of alphanumeric
        characters separated by non-alphanumeric characters.
-->
それぞれの単語の第一文字を大文字に、残りは小文字に変換します。
ここで単語とは、英数字以外の文字で区切られた、英数字からなる文字の並びのことです。
       </para>
       <para>
        <literal>initcap('hi THOMAS')</literal>
        <returnvalue>Hi Thomas</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>left</primary>
        </indexterm>
        <function>left</function> ( <parameter>string</parameter> <type>text</type>,
        <parameter>n</parameter> <type>integer</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
<!--
        Returns first <parameter>n</parameter> characters in the
        string, or when <parameter>n</parameter> is negative, returns
        all but last |<parameter>n</parameter>| characters.
-->
文字列の先頭から<parameter>n</parameter>文字を返します。
<parameter>n</parameter>が負数の場合、文字列の末尾から|<parameter>n</parameter>|文字を切り取った文字列を返します。
       </para>
       <para>
        <literal>left('abcde', 2)</literal>
        <returnvalue>ab</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>length</primary>
        </indexterm>
        <function>length</function> ( <type>text</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
<!--
        Returns the number of characters in the string.
-->
文字列内の文字数を返します。
       </para>
       <para>
        <literal>length('jose')</literal>
        <returnvalue>4</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>md5</primary>
        </indexterm>
        <function>md5</function> ( <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
<!--
        Computes the MD5 <link linkend="functions-hash-note">hash</link> of
        the argument, with the result written in hexadecimal.
-->
引数のMD5<link linkend="functions-hash-note">ハッシュ</link>計算し、16進数で結果を返します。
       </para>
       <para>
        <literal>md5('abc')</literal>
        <returnvalue>900150983cd24fb0&zwsp;d6963f7d28e17f72</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>parse_ident</primary>
        </indexterm>
        <function>parse_ident</function> ( <parameter>qualified_identifier</parameter> <type>text</type>
        [, <parameter>strict_mode</parameter> <type>boolean</type> <literal>DEFAULT</literal> <literal>true</literal> ] )
        <returnvalue>text[]</returnvalue>
       </para>
       <para>
<!--
        Splits <parameter>qualified_identifier</parameter> into an array of
        identifiers, removing any quoting of individual identifiers.  By
        default, extra characters after the last identifier are considered an
        error; but if the second parameter is <literal>false</literal>, then such
        extra characters are ignored. (This behavior is useful for parsing
        names for objects like functions.) Note that this function does not
        truncate over-length identifiers. If you want truncation you can cast
        the result to <type>name[]</type>.
-->
<parameter>qualified_identifier</parameter>を識別子の配列に分割し、個々の識別子に引用符があればそれを削除します。
デフォルトでは、最後の識別子の後に続く余分な文字はエラーとされますが、2番目のパラメータが<literal>false</literal>の場合は、そのような余分な文字は無視されます。
（この動作は、関数のようなオブジェクトに対して名前を解析するときに便利でしょう。）
この関数は、長すぎる識別子を切り詰めないことに注意してください。
切り詰めが必要なときは、その結果を<type>name[]</type>にキャストすることができます。
       </para>
       <para>
        <literal>parse_ident('"SomeSchema".someTable')</literal>
        <returnvalue>{SomeSchema,sometable}</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_client_encoding</primary>
        </indexterm>
        <function>pg_client_encoding</function> ( )
        <returnvalue>name</returnvalue>
       </para>
       <para>
<!--
        Returns current client encoding name.
-->
現在のクライアントの符号化方式の名前を返します。
       </para>
       <para>
        <literal>pg_client_encoding()</literal>
        <returnvalue>UTF8</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>quote_ident</primary>
        </indexterm>
        <function>quote_ident</function> ( <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
<!--
        Returns the given string suitably quoted to be used as an identifier
        in an <acronym>SQL</acronym> statement string.
        Quotes are added only if necessary (i.e., if the string contains
        non-identifier characters or would be case-folded).
        Embedded quotes are properly doubled.
        See also <xref linkend="plpgsql-quote-literal-example"/>.
-->
与えられた文字列を、<acronym>SQL</acronym>問い合わせ文字列で識別子として使用できるように、適切な引用符を付けて返します。
引用符は、必要な場合（すなわち、文字列に識別子として使用できない文字が含まれる場合や、大文字変換される場合）にのみ追加されます。
埋め込まれた引用符は、適切に二重化されます。
<xref linkend="plpgsql-quote-literal-example"/>も参照してください。
       </para>
       <para>
        <literal>quote_ident('Foo bar')</literal>
        <returnvalue>"Foo bar"</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>quote_literal</primary>
        </indexterm>
        <function>quote_literal</function> ( <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
<!--
        Returns the given string suitably quoted to be used as a string literal
        in an <acronym>SQL</acronym> statement string.
        Embedded single-quotes and backslashes are properly doubled.
        Note that <function>quote_literal</function> returns null on null
        input; if the argument might be null,
        <function>quote_nullable</function> is often more suitable.
        See also <xref linkend="plpgsql-quote-literal-example"/>.
-->
与えられた文字列を、<acronym>SQL</acronym>問い合わせ文字列で文字リテラルとして使用できるように、適切な引用符を付けて返します。
埋め込まれた単一引用符およびバックスラッシュは、適切に二重化されます。
<function>quote_literal</function>はNULL入力に対してNULLを返すことに注意してください。引数がNULLとなる可能性がある場合、より<function>quote_nullable</function>の方がしばしば適しています。
<xref linkend="plpgsql-quote-literal-example"/>も参照してください。
       </para>
       <para>
        <literal>quote_literal(E'O\'Reilly')</literal>
        <returnvalue>'O''Reilly'</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>quote_literal</function> ( <type>anyelement</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
<!--
        Converts the given value to text and then quotes it as a literal.
        Embedded single-quotes and backslashes are properly doubled.
-->
与えられた値をテキストに変換し、そしてリテラルとして引用符付けします。
埋め込まれた単一引用符とバックスラッシュは適切に二重化されます。
       </para>
       <para>
        <literal>quote_literal(42.5)</literal>
        <returnvalue>'42.5'</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>quote_nullable</primary>
        </indexterm>
        <function>quote_nullable</function> ( <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
<!--
        Returns the given string suitably quoted to be used as a string literal
        in an <acronym>SQL</acronym> statement string; or, if the argument
        is null, returns <literal>NULL</literal>.
        Embedded single-quotes and backslashes are properly doubled.
        See also <xref linkend="plpgsql-quote-literal-example"/>.
-->
与えられた文字列を、<acronym>SQL</acronym>問い合わせ文字列で文字列リテラルとして使用できるように、適切な引用符を付けて返します。
また、引数がNULLの場合、<literal>NULL</literal>を返します。
埋め込まれた単一引用符およびバックスラッシュは適切に二重化されます。
<xref linkend="plpgsql-quote-literal-example"/>も参照してください。
       </para>
       <para>
        <literal>quote_nullable(NULL)</literal>
        <returnvalue>NULL</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>quote_nullable</function> ( <type>anyelement</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
<!--
        Converts the given value to text and then quotes it as a literal;
        or, if the argument is null, returns <literal>NULL</literal>.
        Embedded single-quotes and backslashes are properly doubled.
-->
与えられた値をテキストに変換し、そしてリテラルとして引用符付けします。引数がNULLの場合は<literal>NULL</literal>を返します。
埋め込まれた単一引用符とバックスラッシュは適切に二重化されます。
       </para>
       <para>
        <literal>quote_nullable(42.5)</literal>
        <returnvalue>'42.5'</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>regexp_count</primary>
        </indexterm>
        <function>regexp_count</function> ( <parameter>string</parameter> <type>text</type>, <parameter>pattern</parameter> <type>text</type>
         [, <parameter>start</parameter> <type>integer</type>
         [, <parameter>flags</parameter> <type>text</type> ] ] )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
<!--
        Returns the number of times the POSIX regular
        expression <parameter>pattern</parameter> matches in
        the <parameter>string</parameter>; see
        <xref linkend="functions-posix-regexp"/>.
-->
<parameter>string</parameter>に対してPOSIX正規表現<parameter>pattern</parameter>がマッチした回数を返します。<xref linkend="functions-posix-regexp"/>を参照してください。
       </para>
       <para>
        <literal>regexp_count('123456789012', '\d\d\d', 2)</literal>
        <returnvalue>3</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>regexp_instr</primary>
        </indexterm>
        <function>regexp_instr</function> ( <parameter>string</parameter> <type>text</type>, <parameter>pattern</parameter> <type>text</type>
         [, <parameter>start</parameter> <type>integer</type>
         [, <parameter>N</parameter> <type>integer</type>
         [, <parameter>endoption</parameter> <type>integer</type>
         [, <parameter>flags</parameter> <type>text</type>
         [, <parameter>subexpr</parameter> <type>integer</type> ] ] ] ] ] )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
<!--
        Returns the position within <parameter>string</parameter> where
        the <parameter>N</parameter>'th match of the POSIX regular
        expression <parameter>pattern</parameter> occurs, or zero if there is
        no such match; see <xref linkend="functions-posix-regexp"/>.
-->
POSIX正規表現<parameter>pattern</parameter>の<parameter>N</parameter>番目の一致が発生する<parameter>string</parameter>内の位置を返します。一致がない場合は0を返します。<xref linkend="functions-posix-regexp"/>を参照してください。
       </para>
       <para>
        <literal>regexp_instr('ABCDEF', 'c(.)(..)', 1, 1, 0, 'i')</literal>
        <returnvalue>3</returnvalue>
       </para>
       <para>
        <literal>regexp_instr('ABCDEF', 'c(.)(..)', 1, 1, 0, 'i', 2)</literal>
        <returnvalue>5</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>regexp_like</primary>
        </indexterm>
        <function>regexp_like</function> ( <parameter>string</parameter> <type>text</type>, <parameter>pattern</parameter> <type>text</type>
         [, <parameter>flags</parameter> <type>text</type> ] )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Checks whether a match of the POSIX regular
        expression <parameter>pattern</parameter> occurs
        within <parameter>string</parameter>; see
        <xref linkend="functions-posix-regexp"/>.
-->
POSIX正規表現<parameter>pattern</parameter>の一致が<parameter>string</parameter>内にあるかどうかをチェックします。<xref linkend="functions-posix-regexp"/>を参照してください。
       </para>
       <para>
        <literal>regexp_like('Hello World', 'world$', 'i')</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>regexp_match</primary>
        </indexterm>
        <function>regexp_match</function> ( <parameter>string</parameter> <type>text</type>, <parameter>pattern</parameter> <type>text</type> [, <parameter>flags</parameter> <type>text</type> ] )
        <returnvalue>text[]</returnvalue>
       </para>
       <para>
<!--
        Returns substrings within the first match of the POSIX regular
        expression <parameter>pattern</parameter> to
        the <parameter>string</parameter>; see
        <xref linkend="functions-posix-regexp"/>.
-->
<parameter>string</parameter>に対してPOSIX正規表現<parameter>pattern</parameter>で最初にマッチした部分文字列を返します。より詳細は<xref linkend="functions-posix-regexp"/>を参照してください。
       </para>
       <para>
        <literal>regexp_match('foobarbequebaz', '(bar)(beque)')</literal>
        <returnvalue>{bar,beque}</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>regexp_matches</primary>
        </indexterm>
        <function>regexp_matches</function> ( <parameter>string</parameter> <type>text</type>, <parameter>pattern</parameter> <type>text</type> [, <parameter>flags</parameter> <type>text</type> ] )
        <returnvalue>setof text[]</returnvalue>
       </para>
       <para>
<!--
        Returns substrings within the first match of the POSIX regular
        expression <parameter>pattern</parameter> to
        the <parameter>string</parameter>, or substrings within all
        such matches if the <literal>g</literal> flag is used;
        see <xref linkend="functions-posix-regexp"/>.
-->
<parameter>string</parameter>に対してPOSIX正規表現<parameter>pattern</parameter>で最初にマッチした部分文字列、あるいは<literal>g</literal>フラグが設定されている場合には、一致したすべての部分文字列を返します。より詳細は<xref linkend="functions-posix-regexp"/>を参照してください。
       </para>
       <para>
        <literal>regexp_matches('foobarbequebaz', 'ba.', 'g')</literal>
        <returnvalue></returnvalue>
<programlisting>
 {bar}
 {baz}
</programlisting>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>regexp_replace</primary>
        </indexterm>
        <function>regexp_replace</function> ( <parameter>string</parameter> <type>text</type>, <parameter>pattern</parameter> <type>text</type>, <parameter>replacement</parameter> <type>text</type>
         [, <parameter>start</parameter> <type>integer</type> ]
         [, <parameter>flags</parameter> <type>text</type> ] )
        <returnvalue>text</returnvalue>
       </para>
       <para>
<!--
        Replaces the substring that is the first match to the POSIX
        regular expression <parameter>pattern</parameter>, or all such
        matches if the <literal>g</literal> flag is used; see
        <xref linkend="functions-posix-regexp"/>.
-->
<parameter>string</parameter>に対してPOSIX正規表現<parameter>pattern</parameter>で最初の一致、あるいは<literal>g</literal>が指定された場合にはすべての一致の結果部分文字列を返します。<xref linkend="functions-posix-regexp"/>を参照してください。
       </para>
       <para>
        <literal>regexp_replace('Thomas', '.[mN]a.', 'M')</literal>
        <returnvalue>ThM</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>regexp_replace</function> ( <parameter>string</parameter> <type>text</type>, <parameter>pattern</parameter> <type>text</type>, <parameter>replacement</parameter> <type>text</type>,
         <parameter>start</parameter> <type>integer</type>,
         <parameter>N</parameter> <type>integer</type>
         [, <parameter>flags</parameter> <type>text</type> ] )
        <returnvalue>text</returnvalue>
       </para>
       <para>
<!--
        Replaces the substring that is the <parameter>N</parameter>'th
        match to the POSIX regular expression <parameter>pattern</parameter>,
        or all such matches if <parameter>N</parameter> is zero; see
        <xref linkend="functions-posix-regexp"/>.
-->
POSIX正規表現<parameter>pattern</parameter>に<parameter>N</parameter>番目に一致する部分文字列、または<parameter>N</parameter>が0の場合にすべて一致する部分文字列を置き換えます。<xref linkend="functions-posix-regexp"/>を参照してください。
       </para>
       <para>
        <literal>regexp_replace('Thomas', '.', 'X', 3, 2)</literal>
        <returnvalue>ThoXas</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>regexp_split_to_array</primary>
        </indexterm>
        <function>regexp_split_to_array</function> ( <parameter>string</parameter> <type>text</type>, <parameter>pattern</parameter> <type>text</type> [, <parameter>flags</parameter> <type>text</type> ] )
        <returnvalue>text[]</returnvalue>
       </para>
       <para>
<!--
        Splits <parameter>string</parameter> using a POSIX regular
        expression as the delimiter, producing an array of results; see
        <xref linkend="functions-posix-regexp"/>.
-->
POSIX正規表現を区切り文字に使って<parameter>string</parameter>を分割し、結果の配列を生成します。
<xref linkend="functions-posix-regexp"/>を参照してください。
       </para>
       <para>
        <literal>regexp_split_to_array('hello world', '\s+')</literal>
        <returnvalue>{hello,world}</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>regexp_split_to_table</primary>
        </indexterm>
        <function>regexp_split_to_table</function> ( <parameter>string</parameter> <type>text</type>, <parameter>pattern</parameter> <type>text</type> [, <parameter>flags</parameter> <type>text</type> ] )
        <returnvalue>setof text</returnvalue>
       </para>
       <para>
<!--
        Splits <parameter>string</parameter> using a POSIX regular
        expression as the delimiter, producing a set of results; see
        <xref linkend="functions-posix-regexp"/>.
-->
POSIX正規表現を区切り文字に使って<parameter>string</parameter>を分割します。
詳しくは<xref linkend="functions-posix-regexp"/>を参照してください。
       </para>
       <para>
        <literal>regexp_split_to_table('hello world', '\s+')</literal>
        <returnvalue></returnvalue>
<programlisting>
 hello
 world
</programlisting>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>regexp_substr</primary>
        </indexterm>
        <function>regexp_substr</function> ( <parameter>string</parameter> <type>text</type>, <parameter>pattern</parameter> <type>text</type>
         [, <parameter>start</parameter> <type>integer</type>
         [, <parameter>N</parameter> <type>integer</type>
         [, <parameter>flags</parameter> <type>text</type>
         [, <parameter>subexpr</parameter> <type>integer</type> ] ] ] ] )
        <returnvalue>text</returnvalue>
       </para>
       <para>
<!--
        Returns the substring within <parameter>string</parameter> that
        matches the <parameter>N</parameter>'th occurrence of the POSIX
        regular expression <parameter>pattern</parameter>,
        or <literal>NULL</literal> if there is no such match; see
        <xref linkend="functions-posix-regexp"/>.
-->
POSIX正規表現<parameter>pattern</parameter>の<parameter>N</parameter>番目に一致する<parameter>string</parameter>内の部分文字列を返します。一致しない場合は<literal>NULL</literal>を返します。
<xref linkend="functions-posix-regexp"/>を参照してください。
       </para>
       <para>
        <literal>regexp_substr('ABCDEF', 'c(.)(..)', 1, 1, 'i')</literal>
        <returnvalue>CDEF</returnvalue>
       </para>
       <para>
        <literal>regexp_substr('ABCDEF', 'c(.)(..)', 1, 1, 'i', 2)</literal>
        <returnvalue>EF</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>repeat</primary>
        </indexterm>
        <function>repeat</function> ( <parameter>string</parameter> <type>text</type>, <parameter>number</parameter> <type>integer</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
<!--
        Repeats <parameter>string</parameter> the specified
        <parameter>number</parameter> of times.
-->
指定された<parameter>number</parameter>の数だけ<parameter>string</parameter>を繰り返します。
       </para>
       <para>
        <literal>repeat('Pg', 4)</literal>
        <returnvalue>PgPgPgPg</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>replace</primary>
        </indexterm>
        <function>replace</function> ( <parameter>string</parameter> <type>text</type>,
        <parameter>from</parameter> <type>text</type>,
        <parameter>to</parameter> <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
<!--
        Replaces all occurrences in <parameter>string</parameter> of
        substring <parameter>from</parameter> with
        substring <parameter>to</parameter>.
-->
<parameter>string</parameter>に出現する全ての<parameter>from</parameter>部分文字列を<parameter>to</parameter>部分文字列に置換します。
       </para>
       <para>
        <literal>replace('abcdefabcdef', 'cd', 'XX')</literal>
        <returnvalue>abXXefabXXef</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>reverse</primary>
        </indexterm>
        <function>reverse</function> ( <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
<!--
        Reverses the order of the characters in the string.
-->
文字列中の文字を逆順にします。
       </para>
       <para>
        <literal>reverse('abcde')</literal>
        <returnvalue>edcba</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>right</primary>
        </indexterm>
        <function>right</function> ( <parameter>string</parameter> <type>text</type>,
         <parameter>n</parameter> <type>integer</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
<!--
        Returns last <parameter>n</parameter> characters in the string,
        or when <parameter>n</parameter> is negative, returns all but
        first |<parameter>n</parameter>| characters.
-->
文字列の末尾から<parameter>n</parameter>文字を返します。
<parameter>n</parameter>が負数の場合は、文字列の先頭から|<parameter>n</parameter>|文字だけ切り取った文字列を返します。
       </para>
       <para>
        <literal>right('abcde', 2)</literal>
        <returnvalue>de</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>split_part</primary>
        </indexterm>
        <function>split_part</function> ( <parameter>string</parameter> <type>text</type>,
        <parameter>delimiter</parameter> <type>text</type>,
        <parameter>n</parameter> <type>integer</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
<!--
        Splits <parameter>string</parameter> at occurrences
        of <parameter>delimiter</parameter> and returns
        the <parameter>n</parameter>'th field (counting from one),
        or when <parameter>n</parameter> is negative, returns
        the |<parameter>n</parameter>|'th-from-last field.
-->
<parameter>string</parameter>を<parameter>delimiter</parameter>で分割し、その結果から<parameter>n</parameter>番目のフィールド（1から始まるように数える）を返します。
<parameter>n</parameter>が負なら最後から|<parameter>n</parameter>|番目のフィールドを返します。
       </para>
       <para>
        <literal>split_part('abc~@~def~@~ghi', '~@~', 2)</literal>
        <returnvalue>def</returnvalue>
       </para>
       <para>
        <literal>split_part('abc,def,ghi,jkl', ',', -2)</literal>
        <returnvalue>ghi</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>starts_with</primary>
        </indexterm>
        <function>starts_with</function> ( <parameter>string</parameter> <type>text</type>, <parameter>prefix</parameter> <type>text</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        Returns true if <parameter>string</parameter> starts
        with <parameter>prefix</parameter>.
-->
<parameter>string</parameter>が<parameter>prefix</parameter>で始まっていれば真を返します。
       </para>
       <para>
        <literal>starts_with('alphabet', 'alph')</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm id="function-string-to-array">
         <primary>string_to_array</primary>
        </indexterm>
        <function>string_to_array</function> ( <parameter>string</parameter> <type>text</type>, <parameter>delimiter</parameter> <type>text</type> <optional>, <parameter>null_string</parameter> <type>text</type> </optional> )
        <returnvalue>text[]</returnvalue>
       </para>
       <para>
<!--
        Splits the <parameter>string</parameter> at occurrences
        of <parameter>delimiter</parameter> and forms the resulting fields
        into a <type>text</type> array.
        If <parameter>delimiter</parameter> is <literal>NULL</literal>,
        each character in the <parameter>string</parameter> will become a
        separate element in the array.
        If <parameter>delimiter</parameter> is an empty string, then
        the <parameter>string</parameter> is treated as a single field.
        If <parameter>null_string</parameter> is supplied and is
        not <literal>NULL</literal>, fields matching that string are
        replaced by <literal>NULL</literal>.
        See also <link linkend="function-array-to-string"><function>array_to_string</function></link>.
-->
<parameter>string</parameter>を<parameter>delimiter</parameter>で区切り、結果のフィールドを<type>text</type>配列に格納します。
<parameter>delimiter</parameter>が<literal>NULL</literal>なら、<parameter>string</parameter>の各文字が配列の別々の要素になります。
<parameter>delimiter</parameter>が空文字なら、<parameter>string</parameter>は単一のフィールドとして扱われます。
<parameter>null_string</parameter>が指定され、<literal>NULL</literal>でなければ、その文字列にマッチするフィールドは<literal>NULL</literal>で置き換えられます。
<link linkend="function-array-to-string"><function>array_to_string</function></link>も参照してください。
       </para>
       <para>
        <literal>string_to_array('xx~~yy~~zz', '~~', 'yy')</literal>
        <returnvalue>{xx,NULL,zz}</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>string_to_table</primary>
        </indexterm>
        <function>string_to_table</function> ( <parameter>string</parameter> <type>text</type>, <parameter>delimiter</parameter> <type>text</type> <optional>, <parameter>null_string</parameter> <type>text</type> </optional> )
        <returnvalue>setof text</returnvalue>
       </para>
       <para>
<!--
        Splits the <parameter>string</parameter> at occurrences
        of <parameter>delimiter</parameter> and returns the resulting fields
        as a set of <type>text</type> rows.
        If <parameter>delimiter</parameter> is <literal>NULL</literal>,
        each character in the <parameter>string</parameter> will become a
        separate row of the result.
        If <parameter>delimiter</parameter> is an empty string, then
        the <parameter>string</parameter> is treated as a single field.
        If <parameter>null_string</parameter> is supplied and is
        not <literal>NULL</literal>, fields matching that string are
        replaced by <literal>NULL</literal>.
-->
<parameter>string</parameter>を<parameter>delimiter</parameter>で区切り、結果のフィールドを<type>text</type>の行集合として返します。
<parameter>delimiter</parameter>が<literal>NULL</literal>なら、結果は<parameter>string</parameter>の各文字が別々の行になります。
<parameter>delimiter</parameter>が空文字なら、<parameter>string</parameter>は単一のフィールドとして扱われます。
<parameter>null_string</parameter>が指定され、<literal>NULL</literal>でなければ、その文字列にマッチするフィールドは<literal>NULL</literal>で置き換えられます。
       </para>
       <para>
        <literal>string_to_table('xx~^~yy~^~zz', '~^~', 'yy')</literal>
        <returnvalue></returnvalue>
<programlisting>
 xx
 NULL
 zz
</programlisting>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>strpos</primary>
        </indexterm>
        <function>strpos</function> ( <parameter>string</parameter> <type>text</type>, <parameter>substring</parameter> <type>text</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
<!--
        Returns first starting index of the specified <parameter>substring</parameter>
        within <parameter>string</parameter>, or zero if it's not present.
        (Same as <literal>position(<parameter>substring</parameter> in
        <parameter>string</parameter>)</literal>, but note the reversed
        argument order.)
-->
<parameter>string</parameter>中の指定した<parameter>substring</parameter>の最初の開始位置を返します。<parameter>substring</parameter>が存在しなければゼロを返します。
（<literal>position(<parameter>substring</parameter> in <parameter>string</parameter>)</literal>と同じですが、引数の順序が逆であることに注意してください。）
       </para>
       <para>
        <literal>strpos('high', 'ig')</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>substr</primary>
        </indexterm>
        <function>substr</function> ( <parameter>string</parameter> <type>text</type>, <parameter>start</parameter> <type>integer</type> <optional>, <parameter>count</parameter> <type>integer</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
<!--
        Extracts the substring of <parameter>string</parameter> starting at
        the <parameter>start</parameter>'th character,
        and extending for <parameter>count</parameter> characters if that is
        specified.  (Same
        as <literal>substring(<parameter>string</parameter>
        from <parameter>start</parameter>
        for <parameter>count</parameter>)</literal>.)
-->
<parameter>string</parameter>の<parameter>start</parameter>番目の文字から始まり、指定されている場合は<parameter>count</parameter>文字だけ連続したが部分文字列を取り出します。
（<literal>substring(<parameter>string</parameter> from <parameter>from</parameter> for <parameter>count</parameter>)</literal>と同じです。）
       </para>
       <para>
        <literal>substr('alphabet', 3)</literal>
        <returnvalue>phabet</returnvalue>
       </para>
       <para>
        <literal>substr('alphabet', 3, 2)</literal>
        <returnvalue>ph</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>to_ascii</primary>
        </indexterm>
        <function>to_ascii</function> ( <parameter>string</parameter> <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para role="func_signature">
        <function>to_ascii</function> ( <parameter>string</parameter> <type>text</type>,
        <parameter>encoding</parameter> <type>name</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para role="func_signature">
        <function>to_ascii</function> ( <parameter>string</parameter> <type>text</type>,
        <parameter>encoding</parameter> <type>integer</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
<!--
        Converts <parameter>string</parameter> to <acronym>ASCII</acronym>
        from another encoding, which may be identified by name or number.
        If <parameter>encoding</parameter> is omitted the database encoding
        is assumed (which in practice is the only useful case).
        The conversion consists primarily of dropping accents.
        Conversion is only supported
        from <literal>LATIN1</literal>, <literal>LATIN2</literal>,
        <literal>LATIN9</literal>, and <literal>WIN1250</literal> encodings.
        (See the <xref linkend="unaccent"/> module for another, more flexible
        solution.)
-->
<parameter>string</parameter>を他の名前あるいは数で指定される符号化方式から、<acronym>ASCII</acronym>に変換します。
<parameter>encoding</parameter>が省略されるとデータベースの符号化方式を指定したと見なします（これは実用的には唯一有用なケースです。）
この変換は主にアクセントを削除するのが目的です。
<literal>LATIN1</literal>、<literal>LATIN2</literal>、<literal>LATIN9</literal>、<literal>WIN1250</literal>符号化方式からの変換のみをサポートします。
（他のより柔軟な解決方法としては、<xref linkend="unaccent"/>モジュールを参照してください。）
       </para>
       <para>
        <literal>to_ascii('Kar&eacute;l')</literal>
        <returnvalue>Karel</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>to_hex</primary>
        </indexterm>
        <function>to_hex</function> ( <type>integer</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para role="func_signature">
        <function>to_hex</function> ( <type>bigint</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
<!--
        Converts the number to its equivalent hexadecimal representation.
-->
数を同等の16進数表現に変換します。
       </para>
       <para>
        <literal>to_hex(2147483647)</literal>
        <returnvalue>7fffffff</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>translate</primary>
        </indexterm>
        <function>translate</function> ( <parameter>string</parameter> <type>text</type>,
        <parameter>from</parameter> <type>text</type>,
        <parameter>to</parameter> <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
<!--
        Replaces each character in <parameter>string</parameter> that
        matches a character in the <parameter>from</parameter> set with the
        corresponding character in the <parameter>to</parameter>
        set. If <parameter>from</parameter> is longer than
        <parameter>to</parameter>, occurrences of the extra characters in
        <parameter>from</parameter> are deleted.
-->
<parameter>from</parameter>集合内の文字と一致する<parameter>string</parameter>にある全ての文字は、<parameter>to</parameter>集合内のそれに対応する文字に置き換えられます。
もし<parameter>from</parameter>が<parameter>to</parameter>より長い場合、<parameter>from</parameter>で指定される余分な文字に一致するものは削除されます。
       </para>
       <para>
        <literal>translate('12345', '143', 'ax')</literal>
        <returnvalue>a2x5</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>unistr</primary>
        </indexterm>
        <function>unistr</function> ( <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
<!--
        Evaluate escaped Unicode characters in the argument.  Unicode characters
        can be specified as
        <literal>\<replaceable>XXXX</replaceable></literal> (4 hexadecimal
        digits), <literal>\+<replaceable>XXXXXX</replaceable></literal> (6
        hexadecimal digits),
        <literal>\u<replaceable>XXXX</replaceable></literal> (4 hexadecimal
        digits), or <literal>\U<replaceable>XXXXXXXX</replaceable></literal>
        (8 hexadecimal digits).  To specify a backslash, write two
        backslashes.  All other characters are taken literally.
-->
引数のエスケープされたUnicode文字を評価します。
Unicode文字は、<literal>\<replaceable>XXXX</replaceable></literal> (16進4桁)、<literal>\+<replaceable>XXXXXX</replaceable></literal> (16進6桁)、<literal>\u<replaceable>XXXX</replaceable></literal> (16進4桁)、<literal>\U<replaceable>XXXXXXXX</replaceable></literal>(16進8桁)で指定できます。
バックスラッシュを指定するには、2つのバックスラッシュを書きます。
それ以外の文字はそのまま扱われます。
       </para>

       <para>
<!--
        If the server encoding is not UTF-8, the Unicode code point identified
        by one of these escape sequences is converted to the actual server
        encoding; an error is reported if that's not possible.
-->
サーバのエンコーディングがUTF-8でなければ、これらのエスケープシーケンスで指定されるUnicodeコードポイントがサーバの実際のエンコーディングに変換されます。
変換不可能ならばエラーが報告されます。
       </para>

       <para>
<!--
        This function provides a (non-standard) alternative to string
        constants with Unicode escapes (see <xref
        linkend="sql-syntax-strings-uescape"/>).
-->
この関数はUnicodeエスケープシーケンス（<xref linkend="sql-syntax-strings-uescape"/>参照）に対する（非標準の）代替を提供します。
       </para>

       <para>
        <literal>unistr('d\0061t\+000061')</literal>
        <returnvalue>data</returnvalue>
       </para>
       <para>
        <literal>unistr('d\u0061t\U00000061')</literal>
        <returnvalue>data</returnvalue>
       </para></entry>
      </row>

     </tbody>
    </tgroup>
   </table>

   <para>
<!--
    The <function>concat</function>, <function>concat_ws</function> and
    <function>format</function> functions are variadic, so it is possible to
    pass the values to be concatenated or formatted as an array marked with
    the <literal>VARIADIC</literal> keyword (see <xref
    linkend="xfunc-sql-variadic-functions"/>).  The array's elements are
    treated as if they were separate ordinary arguments to the function.
    If the variadic array argument is NULL, <function>concat</function>
    and <function>concat_ws</function> return NULL, but
    <function>format</function> treats a NULL as a zero-element array.
-->
<function>concat</function>、<function>concat_ws</function>および<function>format</function>関数はVariadicです。従って、キーワード<literal>VARIADIC</literal>で標しをつけられた配列のように、値を連結またはフォーマットした形で受け渡すことが可能です（<xref linkend="xfunc-sql-variadic-functions"/>を参照してください）。
配列の要素は関数に対して分割された通常の引数のように扱われます。
もしvariadic配列引数がNULLであれば、<function>concat</function>および<function>concat_ws</function>はNULLを返しますが、<function>format</function>はNULLを要素を持たない配列と扱います。
   </para>

   <para>
<!--
    See also the aggregate function <function>string_agg</function> in
    <xref linkend="functions-aggregate"/>, and the functions for
    converting between strings and the <type>bytea</type> type in
    <xref linkend="functions-binarystring-conversions"/>.
-->
<xref linkend="functions-aggregate"/>内の<function>string_agg</function>集約関数と、文字列と<type>bytea</type>型を変換するための<xref linkend="functions-binarystring-conversions"/>内の関数も参照してください。
   </para>

   <sect2 id="functions-string-format">
    <title><function>format</function></title>

    <indexterm>
     <primary>format</primary>
    </indexterm>

    <para>
<!--
     The function <function>format</function> produces output formatted according to
     a format string, in a style similar to the C function
     <function>sprintf</function>.
-->
関数<function>format</function>は、C関数の<function>sprintf</function>同様の形式で、フォーマット文字列に従ってフォーマットされた出力を生成します。
    </para>

    <para>
<synopsis>
<function>format</function>(<parameter>formatstr</parameter> <type>text</type> [, <parameter>formatarg</parameter> <type>"any"</type> [, ...] ])
</synopsis>
<!--
     <parameter>formatstr</parameter> is a format string that specifies how the
     result should be formatted.  Text in the format string is copied
     directly to the result, except where <firstterm>format specifiers</firstterm> are
     used.  Format specifiers act as placeholders in the string, defining how
     subsequent function arguments should be formatted and inserted into the
     result.  Each <parameter>formatarg</parameter> argument is converted to text
     according to the usual output rules for its data type, and then formatted
     and inserted into the result string according to the format specifier(s).
-->
<parameter>formatstr</parameter>は結果がどのようにフォーマットされるかを指定するフォーマット文字列です。
<firstterm>フォーマット指示子</firstterm>が使用されている箇所を除き、フォーマット文字列のテキストは結果に直接コピーされます。
フォーマット指示子は文字列中のプレースホルダとして振舞い、その後に引き続く関数引数がどのようにフォーマットされ、どのように結果に挿入されるかを定義します。
それぞれの<parameter>formatarg</parameter>引数はそのデータ型に対する通常の出力規定に従ってテキストに変換され、その後フォーマット指示子に従って、結果文字列に挿入されます。
    </para>

    <para>
<!--
     Format specifiers are introduced by a <literal>%</literal> character and have
     the form
-->
フォーマット指示子は<literal>%</literal>文字で始まり、以下の形式をとります。
<synopsis>
%[<parameter>position</parameter>][<parameter>flags</parameter>][<parameter>width</parameter>]<parameter>type</parameter>
</synopsis>
<!--
     where the component fields are:
-->
ここで要素フィールドとは以下になっています。

     <variablelist>
      <varlistentry>
<!--
       <term><parameter>position</parameter> (optional)</term>
-->
       <term><parameter>position</parameter> (省略可能)</term>
       <listitem>
        <para>
<!--
         A string of the form <literal><parameter>n</parameter>$</literal> where
         <parameter>n</parameter> is the index of the argument to print.
         Index 1 means the first argument after
         <parameter>formatstr</parameter>.  If the <parameter>position</parameter> is
         omitted, the default is to use the next argument in sequence.
-->
<literal><parameter>n</parameter>$</literal>の形式の文字列で、<parameter>n</parameter>は出力する引数のインデックスです。
インデックス１は<parameter>formatstr</parameter>の後の最初の引数です。
<parameter>position</parameter>が省略されると、一連の中の次の引数がデフォルトとして使用されます。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
<!--
       <term><parameter>flags</parameter> (optional)</term>
-->
       <term><parameter>flags</parameter> (省略可能)</term>
       <listitem>
        <para>
<!--
         Additional options controlling how the format specifier's output is
         formatted.  Currently the only supported flag is a minus sign
         (<literal>-</literal>) which will cause the format specifier's output to be
         left-justified.  This has no effect unless the <parameter>width</parameter>
         field is also specified.
-->
フォーマット指示子の出力がどのようにフォーマットされるかを制御する追加の任意の要素です。
現在、サポートされているflagはマイナス記号(<literal>-</literal>)のみで、フォーマット指示子の出力が左詰めになるようにします。
これは<parameter>width</parameter>フィールドが同時に指定されていない場合は効果がありません。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
<!--
       <term><parameter>width</parameter> (optional)</term>
-->
       <term><parameter>width</parameter> (省略可能)</term>
       <listitem>
        <para>
<!--
         Specifies the <emphasis>minimum</emphasis> number of characters to use to
         display the format specifier's output.  The output is padded on the
         left or right (depending on the <literal>-</literal> flag) with spaces as
         needed to fill the width.  A too-small width does not cause
         truncation of the output, but is simply ignored.  The width may be
         specified using any of the following: a positive integer; an
         asterisk (<literal>*</literal>) to use the next function argument as the
         width; or a string of the form <literal>*<parameter>n</parameter>$</literal> to
         use the <parameter>n</parameter>th function argument as the width.
-->
フォーマット指示子の出力を表示する<emphasis>最小</emphasis>文字数を指定します。
出力は、幅を満たすのに必要な空白が左または右（flagの<literal>-</literal>による）に埋め込まれます。
幅が小さすぎても出力が切り詰められることはなく、単に無視されます。
幅は次のいずれかでも指定できます。それらは、正の整数、幅としての次の関数引数として使用する星印 (<literal>*</literal>)、または<parameter>n</parameter>番目の関数引数を幅として使用する<literal>*<parameter>n</parameter>$</literal>という形式の文字列です。
        </para>

        <para>
<!--
         If the width comes from a function argument, that argument is
         consumed before the argument that is used for the format specifier's
         value.  If the width argument is negative, the result is left
         aligned (as if the <literal>-</literal> flag had been specified) within a
         field of length <function>abs</function>(<parameter>width</parameter>).
-->
幅を関数引数から取得する場合、その引数はフォーマット指示子の値に使用される引数より先に消費されます。
幅の引数が負の場合、フィールド長<function>abs</function>(<parameter>width</parameter>)の範囲内で結果は（あたかもflagで<literal>-</literal>が指定されたように）左詰めになります。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
<!--
       <term><parameter>type</parameter> (required)</term>
-->
       <term><parameter>type</parameter> (必須)</term>
       <listitem>
        <para>
<!--
         The type of format conversion to use to produce the format
         specifier's output.  The following types are supported:
-->
フォーマット指示子の出力を生成するのに使用されるフォーマット変換の型。
以下の型がサポートされています。
         <itemizedlist>
          <listitem>
           <para>
<!--
            <literal>s</literal> formats the argument value as a simple
            string.  A null value is treated as an empty string.
-->
<literal>s</literal>は引数の値を単純文字列にフォーマットします。
NULL値は空文字列として扱われます。
           </para>
          </listitem>
          <listitem>
           <para>
<!--
            <literal>I</literal> treats the argument value as an SQL
            identifier, double-quoting it if necessary.
            It is an error for the value to be null (equivalent to
            <function>quote_ident</function>).
-->
<literal>I</literal>は、引数をSQLの識別子として取り扱い、必要ならそれを二重引用符で括ります。
NULL値はエラーです（<function>quote_ident</function>と同等です）。
           </para>
          </listitem>
          <listitem>
           <para>
<!--
            <literal>L</literal> quotes the argument value as an SQL literal.
            A null value is displayed as the string <literal>NULL</literal>, without
            quotes (equivalent to <function>quote_nullable</function>).
-->
<literal>L</literal>は引数値をSQLリテラルとして引用符が付けられます。
NULL値は引用符無しの文字列<literal>NULL</literal>となります（<function>quote_nullable</function>と同等です）。
           </para>
          </listitem>
         </itemizedlist>
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>

    <para>
<!--
     In addition to the format specifiers described above, the special sequence
     <literal>%%</literal> may be used to output a literal <literal>%</literal> character.
-->
上記で説明したフォーマット指示子に加え、特別の並びの<literal>%%</literal>がリテラル<literal>%</literal>文字を出力するために使用することもできます。
    </para>

    <para>
<!--
     Here are some examples of the basic format conversions:
-->
基本的なフォーマット変換の例を幾つか下記に紹介します。

<screen>
SELECT format('Hello %s', 'World');
<lineannotation>Result: </lineannotation><computeroutput>Hello World</computeroutput>

SELECT format('Testing %s, %s, %s, %%', 'one', 'two', 'three');
<lineannotation>Result: </lineannotation><computeroutput>Testing one, two, three, %</computeroutput>

SELECT format('INSERT INTO %I VALUES(%L)', 'Foo bar', E'O\'Reilly');
<lineannotation>Result: </lineannotation><computeroutput>INSERT INTO "Foo bar" VALUES('O''Reilly')</computeroutput>

SELECT format('INSERT INTO %I VALUES(%L)', 'locations', 'C:\Program Files');
<lineannotation>Result: </lineannotation><computeroutput>INSERT INTO locations VALUES('C:\Program Files')</computeroutput>
</screen>
    </para>

    <para>
<!--
     Here are examples using <parameter>width</parameter> fields
     and the <literal>-</literal> flag:
-->
<parameter>width</parameter>フィールドとflagの<literal>-</literal>を使用した例を以下に示します。

<screen>
SELECT format('|%10s|', 'foo');
<lineannotation>Result: </lineannotation><computeroutput>|       foo|</computeroutput>

SELECT format('|%-10s|', 'foo');
<lineannotation>Result: </lineannotation><computeroutput>|foo       |</computeroutput>

SELECT format('|%*s|', 10, 'foo');
<lineannotation>Result: </lineannotation><computeroutput>|       foo|</computeroutput>

SELECT format('|%*s|', -10, 'foo');
<lineannotation>Result: </lineannotation><computeroutput>|foo       |</computeroutput>

SELECT format('|%-*s|', 10, 'foo');
<lineannotation>Result: </lineannotation><computeroutput>|foo       |</computeroutput>

SELECT format('|%-*s|', -10, 'foo');
<lineannotation>Result: </lineannotation><computeroutput>|foo       |</computeroutput>
</screen>
    </para>

    <para>
<!--
     These examples show use of <parameter>position</parameter> fields:
-->
以下の例は<parameter>position</parameter>フィールドの使い方を示しています。

<screen>
SELECT format('Testing %3$s, %2$s, %1$s', 'one', 'two', 'three');
<lineannotation>Result: </lineannotation><computeroutput>Testing three, two, one</computeroutput>

SELECT format('|%*2$s|', 'foo', 10, 'bar');
<lineannotation>Result: </lineannotation><computeroutput>|       bar|</computeroutput>

SELECT format('|%1$*2$s|', 'foo', 10, 'bar');
<lineannotation>Result: </lineannotation><computeroutput>|       foo|</computeroutput>
</screen>
    </para>

    <para>
<!--
     Unlike the standard C function <function>sprintf</function>,
     <productname>PostgreSQL</productname>'s <function>format</function> function allows format
     specifiers with and without <parameter>position</parameter> fields to be mixed
     in the same format string.  A format specifier without a
     <parameter>position</parameter> field always uses the next argument after the
     last argument consumed.
     In addition, the <function>format</function> function does not require all
     function arguments to be used in the format string.
     For example:
-->
標準C関数<function>sprintf</function>とは違って、<productname>PostgreSQL</productname>の<function>format</function>関数は、同一のフォーマット文字列の中で<parameter>position</parameter>フィールドがあるフォーマット指示子と、それがないフォーマット指示子の混在を許容します。
<parameter>position</parameter>フィールドが無いフォーマット指示子は常に最終の引数が消費された後に次の引数を使用します。
さらに、<function>format</function>関数はフォーマット文字列で使用されるべき全ての関数引数を要求しません。
例を示します。

<screen>
SELECT format('Testing %3$s, %2$s, %s', 'one', 'two', 'three');
<lineannotation>Result: </lineannotation><computeroutput>Testing three, two, three</computeroutput>
</screen>
    </para>

    <para>
<!--
     The <literal>%I</literal> and <literal>%L</literal> format specifiers are particularly
     useful for safely constructing dynamic SQL statements.  See
     <xref linkend="plpgsql-quote-literal-example"/>.
-->
<literal>%I</literal> および <literal>%L</literal>のフォーマット指示子は特に動的SQL命令を安全に構築する場合に便利です。
<xref linkend="plpgsql-quote-literal-example"/>を参照してください。
    </para>
   </sect2>

  </sect1>


  <sect1 id="functions-binarystring">
<!--
   <title>Binary String Functions and Operators</title>
-->
   <title>バイナリ文字列関数と演算子</title>

   <indexterm zone="functions-binarystring">
    <primary>binary data</primary>
    <secondary>functions</secondary>
   </indexterm>
   <indexterm zone="functions-binarystring">
    <primary>バイナリデータ</primary>
    <secondary>関数</secondary>
   </indexterm>

   <para>
<!--
    This section describes functions and operators for examining and
    manipulating binary strings, that is values of type <type>bytea</type>.
    Many of these are equivalent, in purpose and syntax, to the
    text-string functions described in the previous section.
-->
本節ではバイナリ文字列、すなわち<type>bytea</type>型の値を調べたり操作するための関数と演算子について説明します。
これらの多くは前節で説明されているテキスト文字列関数と、目的と構文という意味で同じです。
   </para>

   <para>
<!--
    <acronym>SQL</acronym> defines some string functions that use
    key words, rather than commas, to separate
    arguments.  Details are in
    <xref linkend="functions-binarystring-sql"/>.
    <productname>PostgreSQL</productname> also provides versions of these functions
    that use the regular function invocation syntax
    (see <xref linkend="functions-binarystring-other"/>).
-->
<acronym>SQL</acronym>では、引数の区切りにカンマではなくキーワードを使う文字列関数を、いくつか定義しています。
詳細は<xref linkend="functions-binarystring-sql"/>を参照してください。
また<productname>PostgreSQL</productname>は、これらの関数に対して通常の関数呼び出し構文を使用するバージョンを提供します（<xref linkend="functions-binarystring-other"/>を参照してください）。
   </para>

   <table id="functions-binarystring-sql">
<!--
    <title><acronym>SQL</acronym> Binary String Functions and Operators</title>
-->
    <title><acronym>SQL</acronym>バイナリ文字列関数と演算子</title>
    <tgroup cols="1">
     <thead>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
<!--
        Function/Operator
-->
関数/演算子
       </para>
       <para>
<!--
        Description
-->
説明
       </para>
       <para>
<!--
        Example(s)
-->
例
       </para></entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>binary string</primary>
         <secondary>concatenation</secondary>
        </indexterm>
        <indexterm>
         <primary>バイナリ文字列</primary>
         <secondary>結合</secondary>
        </indexterm>
        <type>bytea</type> <literal>||</literal> <type>bytea</type>
        <returnvalue>bytea</returnvalue>
       </para>
       <para>
<!--
        Concatenates the two binary strings.
-->
2つのバイナリ文字列を結合します。
       </para>
       <para>
        <literal>'\x123456'::bytea || '\x789a00bcde'::bytea</literal>
        <returnvalue>\x123456789a00bcde</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>bit_length</primary>
        </indexterm>
        <function>bit_length</function> ( <type>bytea</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
<!--
        Returns number of bits in the binary string (8
        times the <function>octet_length</function>).
-->
文字列中のビット数を返します（<function>octet_length</function>の8倍）。
       </para>
       <para>
        <literal>bit_length('\x123456'::bytea)</literal>
        <returnvalue>24</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>btrim</primary>
        </indexterm>
        <function>btrim</function> ( <parameter>bytes</parameter> <type>bytea</type>,
        <parameter>bytesremoved</parameter> <type>bytea</type> )
        <returnvalue>bytea</returnvalue>
       </para>
       <para>
<!--
        Removes the longest string containing only bytes appearing in
        <parameter>bytesremoved</parameter> from the start and end of
        <parameter>bytes</parameter>.
-->
<parameter>bytes</parameter>から<parameter>bytesremoved</parameter>に現れるバイトのみを含む最長の文字列を先頭と末尾から取り除きます。
       </para>
       <para>
        <literal>btrim('\x1234567890'::bytea, '\x9012'::bytea)</literal>
        <returnvalue>\x345678</returnvalue>
       </para></entry>
      </row>

       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>ltrim</primary>
         </indexterm>
         <function>ltrim</function> ( <parameter>bytes</parameter> <type>bytea</type>,
         <parameter>bytesremoved</parameter> <type>bytea</type> )
         <returnvalue>bytea</returnvalue>
        </para>
        <para>
<!--
         Removes the longest string containing only bytes appearing in
         <parameter>bytesremoved</parameter> from the start of
         <parameter>bytes</parameter>.
-->
<parameter>bytes</parameter>の先頭から<parameter>bytesremoved</parameter>に現れるバイトだけを含む最長の文字列を削除します。
        </para>
        <para>
         <literal>ltrim('\x1234567890'::bytea, '\x9012'::bytea)</literal>
         <returnvalue>\x34567890</returnvalue>
        </para></entry>
       </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>octet_length</primary>
        </indexterm>
        <function>octet_length</function> ( <type>bytea</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
<!--
        Returns number of bytes in the binary string.
-->
バイナリ文字列中のバイト数を返します。
       </para>
       <para>
        <literal>octet_length('\x123456'::bytea)</literal>
        <returnvalue>3</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>overlay</primary>
        </indexterm>
        <function>overlay</function> ( <parameter>bytes</parameter> <type>bytea</type> <literal>PLACING</literal> <parameter>newsubstring</parameter> <type>bytea</type> <literal>FROM</literal> <parameter>start</parameter> <type>integer</type> <optional> <literal>FOR</literal> <parameter>count</parameter> <type>integer</type> </optional> )
        <returnvalue>bytea</returnvalue>
       </para>
       <para>
<!--
        Replaces the substring of <parameter>bytes</parameter> that starts at
        the <parameter>start</parameter>'th byte and extends
        for <parameter>count</parameter> bytes
        with <parameter>newsubstring</parameter>.
        If <parameter>count</parameter> is omitted, it defaults to the length
        of <parameter>newsubstring</parameter>.
-->
<parameter>bytes</parameter>の<parameter>start</parameter>番目のバイトから<parameter>count</parameter>バイトを<parameter>newsubstring</parameter>で置き換えます。
<parameter>count</parameter>を省略すると<parameter>newsubstring</parameter>の長さがデフォルトになります。
       </para>
       <para>
        <literal>overlay('\x1234567890'::bytea placing '\002\003'::bytea from 2 for 3)</literal>
        <returnvalue>\x12020390</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>position</primary>
        </indexterm>
        <function>position</function> ( <parameter>substring</parameter> <type>bytea</type> <literal>IN</literal> <parameter>bytes</parameter> <type>bytea</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
<!--
        Returns first starting index of the specified
        <parameter>substring</parameter> within
        <parameter>bytes</parameter>, or zero if it's not present.
-->
<parameter>bytes</parameter>中の<parameter>substring</parameter>で指定する最初の文字列開始位置を返します。その文字列が存在しなければ0を返します。
       </para>
       <para>
        <literal>position('\x5678'::bytea in '\x1234567890'::bytea)</literal>
        <returnvalue>3</returnvalue>
       </para></entry>
      </row>

       <row>
        <entry role="func_table_entry"><para role="func_signature">
         <indexterm>
          <primary>rtrim</primary>
         </indexterm>
         <function>rtrim</function> ( <parameter>bytes</parameter> <type>bytea</type>,
         <parameter>bytesremoved</parameter> <type>bytea</type> )
         <returnvalue>bytea</returnvalue>
        </para>
        <para>
<!--
         Removes the longest string containing only bytes appearing in
         <parameter>bytesremoved</parameter> from the end of
         <parameter>bytes</parameter>.
-->
<parameter>bytes</parameter>から<parameter>bytesremoved</parameter>に現れるバイトのみを含む最長の文字列を末尾から取り除きます。
        </para>
        <para>
         <literal>rtrim('\x1234567890'::bytea, '\x9012'::bytea)</literal>
         <returnvalue>\x12345678</returnvalue>
        </para></entry>
       </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>substring</primary>
        </indexterm>
        <function>substring</function> ( <parameter>bytes</parameter> <type>bytea</type> <optional> <literal>FROM</literal> <parameter>start</parameter> <type>integer</type> </optional> <optional> <literal>FOR</literal> <parameter>count</parameter> <type>integer</type> </optional> )
        <returnvalue>bytea</returnvalue>
       </para>
       <para>
<!--
        Extracts the substring of <parameter>bytes</parameter> starting at
        the <parameter>start</parameter>'th byte if that is specified,
        and stopping after <parameter>count</parameter> bytes if that is
        specified.  Provide at least one of <parameter>start</parameter>
        and <parameter>count</parameter>.
-->
<parameter>start</parameter>が指定されていれば<parameter>start</parameter>番目の文字で始まる<parameter>bytes</parameter>の部分文字列を返します。
<parameter>count</parameter>が指定されていれば<parameter>count</parameter>数の文字で停止します。
少なくとも<parameter>start</parameter>か<parameter>count</parameter>のどちらかを指定してください。
       </para>
       <para>
        <literal>substring('\x1234567890'::bytea from 3 for 2)</literal>
        <returnvalue>\x5678</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>trim</primary>
        </indexterm>
        <function>trim</function> ( <optional> <literal>LEADING</literal> | <literal>TRAILING</literal> | <literal>BOTH</literal> </optional>
        <parameter>bytesremoved</parameter> <type>bytea</type> <literal>FROM</literal>
        <parameter>bytes</parameter> <type>bytea</type> )
        <returnvalue>bytea</returnvalue>
       </para>
       <para>
<!--
        Removes the longest string containing only bytes appearing in
        <parameter>bytesremoved</parameter> from the start,
        end, or both ends (<literal>BOTH</literal> is the default)
        of <parameter>bytes</parameter>.
-->
<parameter>bytes</parameter>から<parameter>bytesremoved</parameter>に現れるバイトのみを含む最長の文字列を先頭、末尾、あるいはその両方（<literal>BOTH</literal>がデフォルト）から取り除きます。
       </para>
       <para>
        <literal>trim('\x9012'::bytea from '\x1234567890'::bytea)</literal>
        <returnvalue>\x345678</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>trim</function> ( <optional> <literal>LEADING</literal> | <literal>TRAILING</literal> | <literal>BOTH</literal> </optional> <optional> <literal>FROM</literal> </optional>
        <parameter>bytes</parameter> <type>bytea</type>,
        <parameter>bytesremoved</parameter> <type>bytea</type> )
        <returnvalue>bytea</returnvalue>
       </para>
       <para>
<!--
        This is a non-standard syntax for <function>trim()</function>.
-->
これは<function>trim()</function>の非標準構文です。
       </para>
       <para>
        <literal>trim(both from '\x1234567890'::bytea, '\x9012'::bytea)</literal>
        <returnvalue>\x345678</returnvalue>
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
<!--
    Additional binary string manipulation functions are available and
    are listed in <xref linkend="functions-binarystring-other"/>.  Some
    of them are used internally to implement the
    <acronym>SQL</acronym>-standard string functions listed in <xref
    linkend="functions-binarystring-sql"/>.
-->
この他、<xref linkend="functions-binarystring-other"/>に列挙するバイナリ文字列操作関数が使えます。
そのいくつかは、<xref linkend="functions-binarystring-sql"/>で列挙した標準<acronym>SQL</acronym>の文字列関数を実装するため、内部的に使用されます。
   </para>

   <table id="functions-binarystring-other">
<!--
    <title>Other Binary String Functions</title>
-->
    <title>その他のバイナリ文字列関数</title>
    <tgroup cols="1">
     <thead>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
<!--
        Function
-->
関数
       </para>
       <para>
<!--
        Description
-->
説明
       </para>
       <para>
<!--
        Example(s)
-->
例
       </para></entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>bit_count</primary>
        </indexterm>
        <indexterm>
         <primary>popcount</primary>
         <see>bit_count</see>
        </indexterm>
        <function>bit_count</function> ( <parameter>bytes</parameter> <type>bytea</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
<!--
        Returns the number of bits set in the binary string (also known as
        <quote>popcount</quote>).
-->
バイナリ文字列中のセットされているビットの数を返します（<quote>popcount</quote>としても知られています）。
       </para>
       <para>
        <literal>bit_count('\x1234567890'::bytea)</literal>
        <returnvalue>15</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>get_bit</primary>
        </indexterm>
        <function>get_bit</function> ( <parameter>bytes</parameter> <type>bytea</type>,
        <parameter>n</parameter> <type>bigint</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
<!--
        Extracts <link linkend="functions-zerobased-note">n'th</link> bit
        from binary string.
-->
バイナリ文字列の<link linkend="functions-zerobased-note">n番目</link>のビットを取り出します。
       </para>
       <para>
        <literal>get_bit('\x1234567890'::bytea, 30)</literal>
        <returnvalue>1</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>get_byte</primary>
        </indexterm>
        <function>get_byte</function> ( <parameter>bytes</parameter> <type>bytea</type>,
        <parameter>n</parameter> <type>integer</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
<!--
        Extracts <link linkend="functions-zerobased-note">n'th</link> byte
        from binary string.
-->
バイナリ文字列の<link linkend="functions-zerobased-note">n番目</link>のバイトを取り出します。
       </para>
       <para>
        <literal>get_byte('\x1234567890'::bytea, 4)</literal>
        <returnvalue>144</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>length</primary>
        </indexterm>
        <indexterm>
         <primary>binary string</primary>
         <secondary>length</secondary>
        </indexterm>
        <indexterm>
         <primary>length</primary>
         <secondary sortas="binary string">of a binary string</secondary>
         <see>binary strings, length</see>
        </indexterm>
        <indexterm>
        <primary>長さ</primary>
        <secondary sortas="binary string">バイナリ文字列の</secondary>
        <see>バイナリ文字列, 長さ</see>
        </indexterm>
        <function>length</function> ( <type>bytea</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
<!--
        Returns the number of bytes in the binary string.
-->
バイナリ文字列のバイト数を返します。
       </para>
       <para>
        <literal>length('\x1234567890'::bytea)</literal>
        <returnvalue>5</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>length</function> ( <parameter>bytes</parameter> <type>bytea</type>,
        <parameter>encoding</parameter> <type>name</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
<!--
        Returns the number of characters in the binary string, assuming
        that it is text in the given <parameter>encoding</parameter>.
-->
与えられた<parameter>encoding</parameter>のテキストであると見なしてバイナリ文字列中の文字数を返します。
       </para>
       <para>
        <literal>length('jose'::bytea, 'UTF8')</literal>
        <returnvalue>4</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>md5</primary>
        </indexterm>
        <function>md5</function> ( <type>bytea</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
<!--
        Computes the MD5 <link linkend="functions-hash-note">hash</link> of
        the binary string, with the result written in hexadecimal.
-->
バイナリ文字列のMD5<link linkend="functions-hash-note">ハッシュ</link>計算し、16進数で結果を返します。
       </para>
       <para>
        <literal>md5('Th\000omas'::bytea)</literal>
        <returnvalue>8ab2d3c9689aaf18&zwsp;b4958c334c82d8b1</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>set_bit</primary>
        </indexterm>
        <function>set_bit</function> ( <parameter>bytes</parameter> <type>bytea</type>,
        <parameter>n</parameter> <type>bigint</type>,
        <parameter>newvalue</parameter> <type>integer</type> )
        <returnvalue>bytea</returnvalue>
       </para>
       <para>
<!--
        Sets <link linkend="functions-zerobased-note">n'th</link> bit in
        binary string to <parameter>newvalue</parameter>.
-->
バイナリ文字列の<link linkend="functions-zerobased-note">n番目</link>のビットを<parameter>newvalue</parameter>にします。
       </para>
       <para>
        <literal>set_bit('\x1234567890'::bytea, 30, 0)</literal>
        <returnvalue>\x1234563890</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>set_byte</primary>
        </indexterm>
        <function>set_byte</function> ( <parameter>bytes</parameter> <type>bytea</type>,
        <parameter>n</parameter> <type>integer</type>,
        <parameter>newvalue</parameter> <type>integer</type> )
        <returnvalue>bytea</returnvalue>
       </para>
       <para>
<!--
        Sets <link linkend="functions-zerobased-note">n'th</link> byte in
        binary string to <parameter>newvalue</parameter>.
-->
バイナリ文字列の<link linkend="functions-zerobased-note">n番目</link>のバイトを<parameter>newvalue</parameter>にします。
       </para>
       <para>
        <literal>set_byte('\x1234567890'::bytea, 4, 64)</literal>
        <returnvalue>\x1234567840</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>sha224</primary>
        </indexterm>
        <function>sha224</function> ( <type>bytea</type> )
        <returnvalue>bytea</returnvalue>
       </para>
       <para>
<!--
        Computes the SHA-224 <link linkend="functions-hash-note">hash</link>
        of the binary string.
-->
バイナリ文字列のSHA-224 <link linkend="functions-hash-note">ハッシュ</link>を計算します。
       </para>
       <para>
        <literal>sha224('abc'::bytea)</literal>
        <returnvalue>\x23097d223405d8228642a477bda2&zwsp;55b32aadbce4bda0b3f7e36c9da7</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>sha256</primary>
        </indexterm>
        <function>sha256</function> ( <type>bytea</type> )
        <returnvalue>bytea</returnvalue>
       </para>
       <para>
<!--
        Computes the SHA-256 <link linkend="functions-hash-note">hash</link>
        of the binary string.
-->
バイナリ文字列のSHA-256 <link linkend="functions-hash-note">ハッシュ</link>を計算します。
       </para>
       <para>
        <literal>sha256('abc'::bytea)</literal>
        <returnvalue>\xba7816bf8f01cfea414140de5dae2223&zwsp;b00361a396177a9cb410ff61f20015ad</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>sha384</primary>
        </indexterm>
        <function>sha384</function> ( <type>bytea</type> )
        <returnvalue>bytea</returnvalue>
       </para>
       <para>
<!--
        Computes the SHA-384 <link linkend="functions-hash-note">hash</link>
        of the binary string.
-->
バイナリ文字列のSHA-384 <link linkend="functions-hash-note">ハッシュ</link>を計算します。
       </para>
       <para>
        <literal>sha384('abc'::bytea)</literal>
        <returnvalue>\xcb00753f45a35e8bb5a03d699ac65007&zwsp;272c32ab0eded1631a8b605a43ff5bed&zwsp;8086072ba1e7cc2358baeca134c825a7</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>sha512</primary>
        </indexterm>
        <function>sha512</function> ( <type>bytea</type> )
        <returnvalue>bytea</returnvalue>
       </para>
       <para>
<!--
        Computes the SHA-512 <link linkend="functions-hash-note">hash</link>
        of the binary string.
-->
バイナリ文字列のSHA-512 <link linkend="functions-hash-note">ハッシュ</link>を計算します。
       </para>
       <para>
        <literal>sha512('abc'::bytea)</literal>
        <returnvalue>\xddaf35a193617abacc417349ae204131&zwsp;12e6fa4e89a97ea20a9eeee64b55d39a&zwsp;2192992a274fc1a836ba3c23a3feebbd&zwsp;454d4423643ce80e2a9ac94fa54ca49f</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>substr</primary>
        </indexterm>
        <function>substr</function> ( <parameter>bytes</parameter> <type>bytea</type>, <parameter>start</parameter> <type>integer</type> <optional>, <parameter>count</parameter> <type>integer</type> </optional> )
        <returnvalue>bytea</returnvalue>
       </para>
       <para>
<!--
        Extracts the substring of <parameter>bytes</parameter> starting at
        the <parameter>start</parameter>'th byte,
        and extending for <parameter>count</parameter> bytes if that is
        specified.  (Same
        as <literal>substring(<parameter>bytes</parameter>
        from <parameter>start</parameter>
        for <parameter>count</parameter>)</literal>.)
-->
<parameter>start</parameter>番目の文字で始まる<parameter>bytes</parameter>の部分文字列を取り出します。
<parameter>count</parameter>が指定されていれば<parameter>count</parameter>数バイトを取り出します。
（<literal>substring(<parameter>bytes</parameter> from <parameter>start</parameter> for <parameter>count</parameter>)</literal>と同じです。）
       </para>
       <para>
        <literal>substr('\x1234567890'::bytea, 3, 2)</literal>
        <returnvalue>\x5678</returnvalue>
       </para></entry>
      </row>
    </tbody>
   </tgroup>
  </table>

  <para id="functions-zerobased-note">
<!--
   Functions <function>get_byte</function> and <function>set_byte</function>
   number the first byte of a binary string as byte 0.
   Functions <function>get_bit</function> and <function>set_bit</function>
   number bits from the right within each byte; for example bit 0 is the least
   significant bit of the first byte, and bit 15 is the most significant bit
   of the second byte.
-->
<function>get_byte</function>と<function>set_byte</function>はバイナリ文字列の先頭バイトを0バイトとして数えます。
<function>get_bit</function>と<function>set_bit</function>は各バイト内で右からビットを数えます。例えばビット0は先頭バイトの最下位ビットとなり、ビット15は第二バイトの最上位ビットとなります。
  </para>

  <para id="functions-hash-note">
<!--
   For historical reasons, the function <function>md5</function>
   returns a hex-encoded value of type <type>text</type> whereas the SHA-2
   functions return type <type>bytea</type>.  Use the functions
   <link linkend="function-encode"><function>encode</function></link>
   and <link linkend="function-decode"><function>decode</function></link> to
   convert between the two.  For example write <literal>encode(sha256('abc'),
   'hex')</literal> to get a hex-encoded text representation,
   or <literal>decode(md5('abc'), 'hex')</literal> to get
   a <type>bytea</type> value.
-->
歴史的な理由により、<function>md5</function>は16進のエンコード値を<type>text</type>型で返すのに対し、SHA-2関数は<type>bytea</type>を返します。
両者の間の変換を行うには、関数<link linkend="function-encode"><function>encode</function></link>と<link linkend="function-decode"><function>decode</function></link>を使ってください。
たとえば、16進のエンコードのテキスト表現を得るには、<literal>encode(sha256('abc'),'hex')</literal>、<type>bytea</type>を得るには<literal>decode(md5('abc'), 'hex')</literal>としてください。
  </para>

  <para>
   <indexterm>
    <primary>character string</primary>
    <secondary>converting to binary string</secondary>
   </indexterm>
   <indexterm>
    <primary>文字列</primary>
    <secondary>バイナリ文字列への変換</secondary>
   </indexterm>
   <indexterm>
    <primary>binary string</primary>
    <secondary>converting to character string</secondary>
   </indexterm>
   <indexterm>
    <primary>バイナリ文字列</primary>
    <secondary>文字列への変換</secondary>
   </indexterm>
<!--
   Functions for converting strings between different character sets
   (encodings), and for representing arbitrary binary data in textual
   form, are shown in
   <xref linkend="functions-binarystring-conversions"/>.  For these
   functions, an argument or result of type <type>text</type> is expressed
   in the database's default encoding, while arguments or results of
   type <type>bytea</type> are in an encoding named by another argument.
-->
異なる文字集合（文字符号化方式）間で文字列を変換する関数と、テキスト形式の任意のバイナリデータを表現する関数を<xref linkend="functions-binarystring-conversions"/>で示します。
引数あるいは結果の<type>text</type>型はデータベースのデフォルト文字符号化方式で表現され、<type>bytea</type>型の引数あるいは結果は別の引数で指定する文字符号化方式名で表現されます。
  </para>

  <table id="functions-binarystring-conversions">
<!--
   <title>Text/Binary String Conversion Functions</title>
-->
   <title>テキスト/バイナリ文字列変換関数</title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="func_table_entry"><para role="func_signature">
<!--
       Function
-->
関数
      </para>
      <para>
<!--
       Description
-->
説明
      </para>
      <para>
<!--
       Example(s)
-->
例
      </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>convert</primary>
       </indexterm>
       <function>convert</function> ( <parameter>bytes</parameter> <type>bytea</type>,
       <parameter>src_encoding</parameter> <type>name</type>,
       <parameter>dest_encoding</parameter> <type>name</type> )
       <returnvalue>bytea</returnvalue>
      </para>
      <para>
<!--
       Converts a binary string representing text in
       encoding <parameter>src_encoding</parameter>
       to a binary string in encoding <parameter>dest_encoding</parameter>
       (see <xref linkend="multibyte-conversions-supported"/> for
       available conversions).
-->
文字符号化方式<parameter>src_encoding</parameter>のバイナリ文字列で表現したテキストを文字符号化方式<parameter>dest_encoding</parameter>のバイナリ文字列に変換します。（利用可能な変換は<xref linkend="multibyte-conversions-supported"/>を参照してください。）
      </para>
      <para>
       <literal>convert('text_in_utf8', 'UTF8', 'LATIN1')</literal>
       <returnvalue>\x746578745f696e5f75746638</returnvalue>
      </para></entry>
     </row>

     <row>
      <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>convert_from</primary>
       </indexterm>
       <function>convert_from</function> ( <parameter>bytes</parameter> <type>bytea</type>,
       <parameter>src_encoding</parameter> <type>name</type> )
       <returnvalue>text</returnvalue>
      </para>
      <para>
<!--
       Converts a binary string representing text in
       encoding <parameter>src_encoding</parameter>
       to <type>text</type> in the database encoding
       (see <xref linkend="multibyte-conversions-supported"/> for
       available conversions).
-->
文字符号化方式<parameter>src_encoding</parameter>のバイナリ文字列で表現したテキストをデータベース文字符号化方式の<type>テキスト</type>に変換します。（利用可能な変換は<xref linkend="multibyte-conversions-supported"/>を参照してください。）
      </para>
      <para>
       <literal>convert_from('text_in_utf8', 'UTF8')</literal>
       <returnvalue>text_in_utf8</returnvalue>
      </para></entry>
     </row>

     <row>
      <entry role="func_table_entry"><para role="func_signature">
       <indexterm>
        <primary>convert_to</primary>
       </indexterm>
       <function>convert_to</function> ( <parameter>string</parameter> <type>text</type>,
       <parameter>dest_encoding</parameter> <type>name</type> )
       <returnvalue>bytea</returnvalue>
      </para>
      <para>
<!--
       Converts a <type>text</type> string (in the database encoding) to a
       binary string encoded in encoding <parameter>dest_encoding</parameter>
       (see <xref linkend="multibyte-conversions-supported"/> for
       available conversions).
-->
<type>text</type>文字列（データベース文字符号化方式で表現）を文字符号化方式<parameter>dest_encoding</parameter>のバイナリ文字列に変換します。（利用可能な変換は<xref linkend="multibyte-conversions-supported"/>を参照してください。）
      </para>
      <para>
       <literal>convert_to('some_text', 'UTF8')</literal>
       <returnvalue>\x736f6d655f74657874</returnvalue>
      </para></entry>
     </row>

     <row>
      <entry role="func_table_entry"><para role="func_signature">
       <indexterm id="function-encode">
        <primary>encode</primary>
       </indexterm>
       <function>encode</function> ( <parameter>bytes</parameter> <type>bytea</type>,
       <parameter>format</parameter> <type>text</type> )
       <returnvalue>text</returnvalue>
      </para>
      <para>
<!--
       Encodes binary data into a textual representation; supported
       <parameter>format</parameter> values are:
       <link linkend="encode-format-base64"><literal>base64</literal></link>,
       <link linkend="encode-format-escape"><literal>escape</literal></link>,
       <link linkend="encode-format-hex"><literal>hex</literal></link>.
-->
バイナリデータをテキスト表現形式に符号化します。サポートされている<parameter>format</parameter>値は、<link linkend="encode-format-base64"><literal>base64</literal></link>、<link linkend="encode-format-escape"><literal>escape</literal></link>、<link linkend="encode-format-hex"><literal>hex</literal></link>です。
      </para>
      <para>
       <literal>encode('123\000\001', 'base64')</literal>
       <returnvalue>MTIzAAE=</returnvalue>
      </para></entry>
     </row>

     <row>
      <entry role="func_table_entry"><para role="func_signature">
       <indexterm id="function-decode">
        <primary>decode</primary>
       </indexterm>
       <function>decode</function> ( <parameter>string</parameter> <type>text</type>,
       <parameter>format</parameter> <type>text</type> )
       <returnvalue>bytea</returnvalue>
      </para>
      <para>
<!--
       Decodes binary data from a textual representation; supported
       <parameter>format</parameter> values are the same as
       for <function>encode</function>.
-->
テキスト表現からバイナリデータに復号します。
<parameter>format</parameter>値は<function>encode</function>と同じです。
      </para>
      <para>
       <literal>decode('MTIzAAE=', 'base64')</literal>
       <returnvalue>\x3132330001</returnvalue>
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
<!--
   The <function>encode</function> and <function>decode</function>
   functions support the following textual formats:
-->
<function>encode</function>と<function>decode</function>関数は以下のテキスト形式をサポートしています。

   <variablelist>
    <varlistentry id="encode-format-base64">
     <term>base64
     <indexterm>
      <primary>base64 format</primary>
     </indexterm></term>
     <listitem>
      <para>
<!--
       The <literal>base64</literal> format is that
       of <ulink url="https://datatracker.ietf.org/doc/html/rfc2045#section-6.8">RFC
       2045 Section 6.8</ulink>.  As per the <acronym>RFC</acronym>, encoded lines are
       broken at 76 characters.  However instead of the MIME CRLF
       end-of-line marker, only a newline is used for end-of-line.
       The <function>decode</function> function ignores carriage-return,
       newline, space, and tab characters.  Otherwise, an error is
       raised when <function>decode</function> is supplied invalid
       base64 data &mdash; including when trailing padding is incorrect.
-->
<literal>base64</literal>形式は<ulink url="https://datatracker.ietf.org/doc/html/rfc2045#section-6.8">RFC 2045 6.8節</ulink>のものです。
<acronym>RFC</acronym>に従い、符号化された行は76文字に分割されます。
しかし、MIME CRLF行端指示子ではなくて単に改行が行端として使われます。
<function>decode</function>関数はキャリッジ・リターン、改行、空白、タブ文字を無視します。
行端パディング文字が不正な場合を含み、<function>decode</function>に不正なbase64のデータが与えられるとエラーが生じます。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="encode-format-escape">
     <term>escape
     <indexterm>
      <primary>escape format</primary>
     </indexterm></term>
     <listitem>
      <para>
<!--
       The <literal>escape</literal> format converts zero bytes and
       bytes with the high bit set into octal escape sequences
       (<literal>\</literal><replaceable>nnn</replaceable>), and it doubles
       backslashes.  Other byte values are represented literally.
       The <function>decode</function> function will raise an error if a
       backslash is not followed by either a second backslash or three
       octal digits; it accepts other byte values unchanged.
-->
<literal>escape</literal>形式はゼロバイトとハイビットがセットされたバイトを8進エスケープシーケンス(<literal>\</literal><replaceable>nnn</replaceable>)に変換し、バックスラッシュを二重化します。
他のバイト値は文字通りに表現されます。
バックスラッシュの後が二番目のバックスラッシュあるいは3つの8進数のどちらでもなければ、<function>decode</function>関数はエラーを生じます。他のバイト値はそのまま受け付けます。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry id="encode-format-hex">
     <term>hex
     <indexterm>
      <primary>hex format</primary>
     </indexterm></term>
     <listitem>
      <para>
<!--
       The <literal>hex</literal> format represents each 4 bits of
       data as one hexadecimal digit, <literal>0</literal>
       through <literal>f</literal>, writing the higher-order digit of
       each byte first.  The <function>encode</function> function outputs
       the <literal>a</literal>-<literal>f</literal> hex digits in lower
       case.  Because the smallest unit of data is 8 bits, there are
       always an even number of characters returned
       by <function>encode</function>.
       The <function>decode</function> function
       accepts the <literal>a</literal>-<literal>f</literal> characters in
       either upper or lower case.  An error is raised
       when <function>decode</function> is given invalid hex data
       &mdash; including when given an odd number of characters.
-->
<literal>hex</literal>形式はデータの各々の4ビットを、それぞれのバイトの上位桁を最初にして、<literal>0</literal>から<literal>f</literal>の16進数で表現します。
<function>encode</function>関数は<literal>a</literal>-<literal>f</literal>の16進数を小文字で出力します。
最小のデータ単位は8ビットなので、<function>encode</function>が返す文字数は常に偶数です。
<function>decode</function>関数は<literal>a</literal>-<literal>f</literal>の文字が大文字でも小文字でも受け付けます。
<function>decode</function>関数は、奇数の文字数を含み、不正な16進データを与えられるとエラーが生じます。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

  <para>
<!--
   See also the aggregate function <function>string_agg</function> in
   <xref linkend="functions-aggregate"/> and the large object functions
   in <xref linkend="lo-funcs"/>.
-->
<xref linkend="functions-aggregate"/>内の集約関数<function>string_agg</function>と<xref linkend="lo-funcs"/>内のラージオブジェクト関数も参照してください。
  </para>
 </sect1>


  <sect1 id="functions-bitstring">
<!--
   <title>Bit String Functions and Operators</title>
-->
   <title>ビット文字列関数と演算子</title>

   <indexterm zone="functions-bitstring">
    <primary>bit strings</primary>
    <secondary>functions</secondary>
   </indexterm>
   <indexterm zone="functions-bitstring">
    <primary>ビット文字列</primary>
    <secondary>関数</secondary>
   </indexterm>

   <para>
<!--
    This section describes functions and operators for examining and
    manipulating bit strings, that is values of the types
    <type>bit</type> and <type>bit varying</type>.  (While only
    type <type>bit</type> is mentioned in these tables, values of
    type <type>bit varying</type> can be used interchangeably.)
    Bit strings support the usual comparison operators shown in
    <xref linkend="functions-comparison-op-table"/>, as well as the
    operators shown in <xref linkend="functions-bit-string-op-table"/>.
-->
本節では<type>bit</type>型と<type>bit varying</type>型の値であるビット文字列を調べたり操作するための関数と演算子について説明します。
（この表では<type>bit</type>型だけが言及されていますが、<type>bit varying</type>型も同じように使用できます。）
ビット文字列は<xref linkend="functions-comparison-op-table"/>で示す通常の比較演算子および<xref linkend="functions-bit-string-op-table"/>で言及している演算子もサポートします。
   </para>

   <table id="functions-bit-string-op-table">
<!--
    <title>Bit String Operators</title>
-->
    <title>ビット文字列演算子</title>
    <tgroup cols="1">
     <thead>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
<!--
        Operator
-->
演算子
       </para>
       <para>
<!--
        Description
-->
説明
       </para>
       <para>
<!--
        Example(s)
-->
例
       </para></entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>bit</type> <literal>||</literal> <type>bit</type>
        <returnvalue>bit</returnvalue>
       </para>
       <para>
<!--
        Concatenation
-->
結合
       </para>
       <para>
        <literal>B'10001' || B'011'</literal>
        <returnvalue>10001011</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>bit</type> <literal>&amp;</literal> <type>bit</type>
        <returnvalue>bit</returnvalue>
       </para>
       <para>
<!--
        Bitwise AND (inputs must be of equal length)
-->
ビット単位のAND（入力は同じ長さでなければなりません）
       </para>
       <para>
        <literal>B'10001' &amp; B'01101'</literal>
        <returnvalue>00001</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>bit</type> <literal>|</literal> <type>bit</type>
        <returnvalue>bit</returnvalue>
       </para>
       <para>
<!--
        Bitwise OR (inputs must be of equal length)
-->
ビット単位のOR（入力は同じ長さでなければなりません）
       </para>
       <para>
        <literal>B'10001' | B'01101'</literal>
        <returnvalue>11101</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>bit</type> <literal>#</literal> <type>bit</type>
        <returnvalue>bit</returnvalue>
       </para>
       <para>
<!--
        Bitwise exclusive OR (inputs must be of equal length)
-->
ビット単位の排他的論理和（入力は同じ長さでなければなりません）
       </para>
       <para>
        <literal>B'10001' # B'01101'</literal>
        <returnvalue>11100</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>~</literal> <type>bit</type>
        <returnvalue>bit</returnvalue>
       </para>
       <para>
<!--
        Bitwise NOT
-->
ビット単位の否定
       </para>
       <para>
        <literal>~ B'10001'</literal>
        <returnvalue>01110</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>bit</type> <literal>&lt;&lt;</literal> <type>integer</type>
        <returnvalue>bit</returnvalue>
       </para>
       <para>
<!--
        Bitwise shift left
        (string length is preserved)
-->
ビット単位の左シフト（文字列長は保存されます）
       </para>
       <para>
        <literal>B'10001' &lt;&lt; 3</literal>
        <returnvalue>01000</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>bit</type> <literal>&gt;&gt;</literal> <type>integer</type>
        <returnvalue>bit</returnvalue>
       </para>
       <para>
<!--
        Bitwise shift right
        (string length is preserved)
-->
ビット単位の右シフト（文字列長は保存されます）
       </para>
       <para>
        <literal>B'10001' &gt;&gt; 2</literal>
        <returnvalue>00100</returnvalue>
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
<!--
    Some of the functions available for binary strings are also available
    for bit strings, as shown in <xref linkend="functions-bit-string-table"/>.
-->
バイナリ文字列で利用可能な関数のいくつかは、<xref linkend="functions-bit-string-table"/>で示すようにビット文字列でも利用可能です。
   </para>

   <table id="functions-bit-string-table">
<!--
    <title>Bit String Functions</title>
-->
    <title>ビット文字列関数</title>
    <tgroup cols="1">
     <thead>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
<!--
        Function
-->
関数
       </para>
       <para>
<!--
        Description
-->
説明
       </para>
       <para>
<!--
        Example(s)
-->
例
       </para></entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>bit_count</primary>
        </indexterm>
        <function>bit_count</function> ( <type>bit</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
<!--
        Returns the number of bits set in the bit string (also known as
        <quote>popcount</quote>).
-->
ビット文字列中のセットされているビットの数を返します（<quote>popcount</quote>としても知られています）。
       </para>
       <para>
        <literal>bit_count(B'10111')</literal>
        <returnvalue>4</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>bit_length</primary>
        </indexterm>
        <function>bit_length</function> ( <type>bit</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
<!--
        Returns number of bits in the bit string.
-->
ビット文字列中のビット数を返します。
       </para>
       <para>
        <literal>bit_length(B'10111')</literal>
        <returnvalue>5</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>length</primary>
        </indexterm>
        <indexterm>
         <primary>bit string</primary>
         <secondary>length</secondary>
        </indexterm>
        <function>length</function> ( <type>bit</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
<!--
        Returns number of bits in the bit string.
-->
ビット文字列中のビット数を返します。
       </para>
       <para>
        <literal>length(B'10111')</literal>
        <returnvalue>5</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>octet_length</primary>
        </indexterm>
        <function>octet_length</function> ( <type>bit</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
<!--
        Returns number of bytes in the bit string.
-->
ビット文字列中のバイト数を返します。
       </para>
       <para>
        <literal>octet_length(B'1011111011')</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>overlay</primary>
        </indexterm>
        <function>overlay</function> ( <parameter>bits</parameter> <type>bit</type> <literal>PLACING</literal> <parameter>newsubstring</parameter> <type>bit</type> <literal>FROM</literal> <parameter>start</parameter> <type>integer</type> <optional> <literal>FOR</literal> <parameter>count</parameter> <type>integer</type> </optional> )
        <returnvalue>bit</returnvalue>
       </para>
       <para>
<!--
        Replaces the substring of <parameter>bits</parameter> that starts at
        the <parameter>start</parameter>'th bit and extends
        for <parameter>count</parameter> bits
        with <parameter>newsubstring</parameter>.
        If <parameter>count</parameter> is omitted, it defaults to the length
        of <parameter>newsubstring</parameter>.
-->
<parameter>bits</parameter>の<parameter>start</parameter>番目のビットから<parameter>count</parameter>ビットを<parameter>newsubstring</parameter>で置き換えます。
<parameter>count</parameter>を省略すると<parameter>newsubstring</parameter>の長さがデフォルトになります。
       </para>
       <para>
        <literal>overlay(B'01010101010101010' placing B'11111' from 2 for 3)</literal>
        <returnvalue>0111110101010101010</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>position</primary>
        </indexterm>
        <function>position</function> ( <parameter>substring</parameter> <type>bit</type> <literal>IN</literal> <parameter>bits</parameter> <type>bit</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
<!--
        Returns first starting index of the specified <parameter>substring</parameter>
        within <parameter>bits</parameter>, or zero if it's not present.
-->
<parameter>bits</parameter>中の<parameter>substring</parameter>で指定する最初の文字列開始位置を返します。その文字列が存在しなければ0を返します。
       </para>
       <para>
        <literal>position(B'010' in B'000001101011')</literal>
        <returnvalue>8</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>substring</primary>
        </indexterm>
        <function>substring</function> ( <parameter>bits</parameter> <type>bit</type> <optional> <literal>FROM</literal> <parameter>start</parameter> <type>integer</type> </optional> <optional> <literal>FOR</literal> <parameter>count</parameter> <type>integer</type> </optional> )
        <returnvalue>bit</returnvalue>
       </para>
       <para>
<!--
        Extracts the substring of <parameter>bits</parameter> starting at
        the <parameter>start</parameter>'th bit if that is specified,
        and stopping after <parameter>count</parameter> bits if that is
        specified.  Provide at least one of <parameter>start</parameter>
        and <parameter>count</parameter>.
-->
<parameter>start</parameter>番目の文字で始まる<parameter>bits</parameter>の部分文字列を取り出します。
<parameter>count</parameter>が指定されていれば<parameter>count</parameter>数ビットを取り出します。
少なくとも<parameter>start</parameter>か<parameter>count</parameter>のどちらかを指定してください。
       </para>
       <para>
        <literal>substring(B'110010111111' from 3 for 2)</literal>
        <returnvalue>00</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>get_bit</primary>
        </indexterm>
        <function>get_bit</function> ( <parameter>bits</parameter> <type>bit</type>,
        <parameter>n</parameter> <type>integer</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
<!--
        Extracts <parameter>n</parameter>'th bit
        from bit string; the first (leftmost) bit is bit 0.
-->
ビット文字列の<parameter>n</parameter>番目のビットを取り出します。文字列の最初(一番左)のビットを0として数えます。
       </para>
       <para>
        <literal>get_bit(B'101010101010101010', 6)</literal>
        <returnvalue>1</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>set_bit</primary>
        </indexterm>
        <function>set_bit</function> ( <parameter>bits</parameter> <type>bit</type>,
        <parameter>n</parameter> <type>integer</type>,
        <parameter>newvalue</parameter> <type>integer</type> )
        <returnvalue>bit</returnvalue>
       </para>
       <para>
<!--
        Sets <parameter>n</parameter>'th bit in
        bit string to <parameter>newvalue</parameter>;
        the first (leftmost) bit is bit 0.
-->
ビット文字列の<parameter>n</parameter>番目のビットを<parameter>newvalue</parameter>にします。文字列の最初(一番左)のビットを0として数えます。
       </para>
       <para>
        <literal>set_bit(B'101010101010101010', 6, 0)</literal>
        <returnvalue>101010001010101010</returnvalue>
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
<!--
    In addition, it is possible to cast integral values to and from type
    <type>bit</type>.
    Casting an integer to <type>bit(n)</type> copies the rightmost
    <literal>n</literal> bits.  Casting an integer to a bit string width wider
    than the integer itself will sign-extend on the left.
    Some examples:
-->
さらに、<type>bit</type>型から整数値にキャストすることも整数から<type>bit</type>型にキャストすることも可能です。
整数から<type>bit(n)</type>にキャストすると最右端の<literal>n</literal>ビットがコピーされます。
その整数より文字列幅が広いビットにキャストすると左のビットが符号拡張されます。
以下に例を示します。
<programlisting>
44::bit(10)                    <lineannotation>0000101100</lineannotation>
44::bit(3)                     <lineannotation>100</lineannotation>
cast(-44 as bit(12))           <lineannotation>111111010100</lineannotation>
'1110'::bit(4)::integer        <lineannotation>14</lineannotation>
</programlisting>
<!--
    Note that casting to just <quote>bit</quote> means casting to
    <literal>bit(1)</literal>, and so will deliver only the least significant
    bit of the integer.
-->
単に<quote>bit</quote>にキャストすることは<literal>bit(1)</literal>にキャストすることを意味することに注意してください。つまり、単に整数の最下位ビットのみが渡されることになります。
   </para>
  </sect1>


 <sect1 id="functions-matching">
<!--
  <title>Pattern Matching</title>
-->
  <title>パターンマッチ</title>

  <indexterm zone="functions-matching">
   <primary>pattern matching</primary>
  </indexterm>
  <indexterm zone="functions-matching">
   <primary>パターンマッチ</primary>
  </indexterm>

   <para>
<!--
    There are three separate approaches to pattern matching provided
    by <productname>PostgreSQL</productname>: the traditional
    <acronym>SQL</acronym> <function>LIKE</function> operator, the
    more recent <function>SIMILAR TO</function> operator (added in
    SQL:1999), and <acronym>POSIX</acronym>-style regular
    expressions.  Aside from the basic <quote>does this string match
    this pattern?</quote> operators, functions are available to extract
    or replace matching substrings and to split a string at matching
    locations.
-->
<productname>PostgreSQL</productname>には、パターンマッチを行うに際して3つの異なった手法があります。伝統的な<acronym>SQL</acronym>の<function>LIKE</function>演算子、これより新しい<function>SIMILAR TO</function>演算子（SQL:1999で追加されました）、および<acronym>POSIX</acronym>様式の正規表現です。
基本の<quote>この文字列はこのパターンに一致するか？</quote>を別としても、一致した部分文字列を取り出したり置換したり、そして一致部分で文字列を分割する関数が用意されています。
   </para>

   <tip>
    <para>
<!--
     If you have pattern matching needs that go beyond this,
     consider writing a user-defined function in Perl or Tcl.
-->
上記の手法では検索できないようなパターンマッチが必要な場合は、PerlもしくはTclでユーザ定義関数を作成することを検討してください。
    </para>
   </tip>

   <caution>
    <para>
<!--
     While most regular-expression searches can be executed very quickly,
     regular expressions can be contrived that take arbitrary amounts of
     time and memory to process.  Be wary of accepting regular-expression
     search patterns from hostile sources.  If you must do so, it is
     advisable to impose a statement timeout.
-->
ほとんどの正規表現検索はとても速く実行されますが、正規表現は処理するのに任意の時間とメモリを使う可能性があります。
悪意のあるソースから正規表現検索パターンを受け取ることに用心してください。
そうしなければならないのであれば、文のタイムアウトを強制するのが賢明です。
    </para>

    <para>
<!--
     Searches using <function>SIMILAR TO</function> patterns have the same
     security hazards, since <function>SIMILAR TO</function> provides many
     of the same capabilities as <acronym>POSIX</acronym>-style regular
     expressions.
-->
<function>SIMILAR TO</function>が<acronym>POSIX</acronym>書式の正規表現と同じ多くの機能を提供するので、<function>SIMILAR TO</function>パターンを使う検索は同様のセキュリティ問題を抱えています。
    </para>

    <para>
<!--
     <function>LIKE</function> searches, being much simpler than the other
     two options, are safer to use with possibly-hostile pattern sources.
-->
<function>LIKE</function>検索は、他の2つの方法よりずっと単純ですので、悪意があるかもしれないパターンのソースで使うのにはより安全です。
    </para>
   </caution>

   <para>
<!--
    The pattern matching operators of all three kinds do not support
    nondeterministic collations.  If required, apply a different collation to
    the expression to work around this limitation.
-->
この3種類のパターンマッチング演算子はどれも非決定的照合順序をサポートしていません。
必要なら、この制限事項に対応するために別の照合順序を式に適用してください。
   </para>

  <sect2 id="functions-like">
   <title><function>LIKE</function></title>

   <indexterm>
    <primary>LIKE</primary>
   </indexterm>

<synopsis>
<replaceable>string</replaceable> LIKE <replaceable>pattern</replaceable> <optional>ESCAPE <replaceable>escape-character</replaceable></optional>
<replaceable>string</replaceable> NOT LIKE <replaceable>pattern</replaceable> <optional>ESCAPE <replaceable>escape-character</replaceable></optional>
</synopsis>

    <para>
<!--
     The <function>LIKE</function> expression returns true if the
     <replaceable>string</replaceable> matches the supplied
     <replaceable>pattern</replaceable>.  (As
     expected, the <function>NOT LIKE</function> expression returns
     false if <function>LIKE</function> returns true, and vice versa.
     An equivalent expression is
     <literal>NOT (<replaceable>string</replaceable> LIKE
      <replaceable>pattern</replaceable>)</literal>.)
-->
<function>LIKE</function>式は供給された<replaceable>pattern</replaceable>に<replaceable>string</replaceable>が一致すれば真を返します。
（想像される通り、<function>NOT LIKE</function>式は<function>LIKE</function>式が真を返す場合には偽を返し、その逆もまた同じです。
同等の式として<literal>NOT (<replaceable>string</replaceable> LIKE <replaceable>pattern</replaceable>)</literal>とも表現できます。）
    </para>

    <para>
<!--
     If <replaceable>pattern</replaceable> does not contain percent
     signs or underscores, then the pattern only represents the string
     itself; in that case <function>LIKE</function> acts like the
     equals operator.  An underscore (<literal>_</literal>) in
     <replaceable>pattern</replaceable> stands for (matches) any single
     character; a percent sign (<literal>%</literal>) matches any sequence
     of zero or more characters.
-->
<replaceable>pattern</replaceable>がパーセント記号もしくはアンダースコアを含んでいない場合patternは自身の文字列そのものです。この場合<function>LIKE</function>式は等号演算子のように振舞います。
<replaceable>pattern</replaceable>の中にあるアンダースコア（<literal>_</literal>）は任意の一文字との一致を意味し、パーセント記号（<literal>%</literal>）は0文字以上の並びとの一致を意味します。
    </para>

   <para>
<!--
    Some examples:
-->
例：
<programlisting>
'abc' LIKE 'abc'    <lineannotation>true</lineannotation>
'abc' LIKE 'a%'     <lineannotation>true</lineannotation>
'abc' LIKE '_b_'    <lineannotation>true</lineannotation>
'abc' LIKE 'c'      <lineannotation>false</lineannotation>
</programlisting>
   </para>

   <para>
<!--
    <function>LIKE</function> pattern matching always covers the entire
    string.  Therefore, if it's desired to match a sequence anywhere within
    a string, the pattern must start and end with a percent sign.
-->
<function>LIKE</function>によるパターン一致は常に文字列全体に対して行われます。
従って、文字列内の任意位置における並びと一致させたい場合には、パーセント記号を先頭と末尾に付ける必要があります。
   </para>

   <para>
<!--
    To match a literal underscore or percent sign without matching
    other characters, the respective character in
    <replaceable>pattern</replaceable> must be
    preceded by the escape character.  The default escape
    character is the backslash but a different one can be selected by
    using the <literal>ESCAPE</literal> clause.  To match the escape
    character itself, write two escape characters.
-->
他の文字の一致に使用するのではなく、アンダースコアやパーセント記号そのものを一致させたい場合には、<replaceable>pattern</replaceable>の中のそれぞれのアンダースコアとパーセント記号の前にエスケープ文字を付けなければなりません。
デフォルトのエスケープ文字はバックスラッシュですが、<literal>ESCAPE</literal>句で他の文字を指定することができます。エスケープ文字そのものを一致させるにはエスケープ文字を2つ書きます。
   </para>

   <note>
    <para>
<!--
     If you have <xref linkend="guc-standard-conforming-strings"/> turned off,
     any backslashes you write in literal string constants will need to be
     doubled.  See <xref linkend="sql-syntax-strings"/> for more information.
-->
<xref linkend="guc-standard-conforming-strings"/>パラメータをoffにしている場合、リテラル文字列定数に記述するバックスラッシュを二重にする必要があります。
詳細は<xref linkend="sql-syntax-strings"/>を参照してください。
    </para>
   </note>

   <para>
<!--
    It's also possible to select no escape character by writing
    <literal>ESCAPE ''</literal>.  This effectively disables the
    escape mechanism, which makes it impossible to turn off the
    special meaning of underscore and percent signs in the pattern.
-->
同時に<literal>ESCAPE ''</literal>と記述することでエスケープ文字を選択しないことも可能です。
これにより、事実上エスケープ機構が働かなくなります。つまり、パターン内のアンダースコアおよびパーセント記号の特別な意味を解除することはできなくなります。
   </para>

   <para>
<!--
    According to the SQL standard, omitting <literal>ESCAPE</literal>
    means there is no escape character (rather than defaulting to a
    backslash), and a zero-length <literal>ESCAPE</literal> value is
    disallowed.  <productname>PostgreSQL</productname>'s behavior in
    this regard is therefore slightly nonstandard.
-->
標準SQLによれば、<literal>ESCAPE</literal>は（デフォルトがバックスラッシュとなるのではなく）エスケープ文字が存在しないことを意味します。長さゼロの<literal>ESCAPE</literal>は使用できません。
ですからこの点で<productname>PostgreSQL</productname>は少し非標準な振る舞いをします。
   </para>

   <para>
<!--
    The key word <token>ILIKE</token> can be used instead of
    <token>LIKE</token> to make the match case-insensitive according
    to the active locale.  This is not in the <acronym>SQL</acronym> standard but is a
    <productname>PostgreSQL</productname> extension.
-->
現在のロケールに従って大文字小文字を区別しない一致を行うのであれば、<token>LIKE</token>の代わりに<token>ILIKE</token>キーワードを使うことができます。
これは標準<acronym>SQL</acronym>ではなく、<productname>PostgreSQL</productname>の拡張です。
   </para>

   <para>
<!--
    The operator <literal>~~</literal> is equivalent to
    <function>LIKE</function>, and <literal>~~*</literal> corresponds to
    <function>ILIKE</function>.  There are also
    <literal>!~~</literal> and <literal>!~~*</literal> operators that
    represent <function>NOT LIKE</function> and <function>NOT
    ILIKE</function>, respectively.  All of these operators are
    <productname>PostgreSQL</productname>-specific.  You may see these
    operator names in <command>EXPLAIN</command> output and similar
    places, since the parser actually translates <function>LIKE</function>
    et al. to these operators.
-->
<literal>~~</literal>演算子は<function>LIKE</function>式と等価で、<literal>~~*</literal>は<function>ILIKE</function>に対応します。
また<function>NOT LIKE</function>および<function>NOT ILIKE</function>を表す<literal>!~~</literal>および<literal>!~~*</literal>演算子があります。
これら全ての演算子は<productname>PostgreSQL</productname>固有のものです。
パーサは実際には<function>LIKE</function>などをこれらの演算子に変換するため、こうした演算子名は<command>EXPLAIN</command>の出力などで見ることができます。
   </para>

   <para>
<!--
    The phrases <function>LIKE</function>, <function>ILIKE</function>,
    <function>NOT LIKE</function>, and <function>NOT ILIKE</function> are
    generally treated as operators
    in <productname>PostgreSQL</productname> syntax; for example they can
    be used in <replaceable>expression</replaceable>
    <replaceable>operator</replaceable> ANY
    (<replaceable>subquery</replaceable>) constructs, although
    an <literal>ESCAPE</literal> clause cannot be included there.  In some
    obscure cases it may be necessary to use the underlying operator names
    instead.
-->
<function>LIKE</function>、<function>ILIKE</function>、<function>NOT LIKE</function>、<function>NOT ILIKE</function>句は一般に<productname>PostgreSQL</productname>の構文上は演算子として扱われます。
たとえば、<replaceable>式</replaceable> <replaceable>演算子</replaceable> ANY(<replaceable>副問い合わせ</replaceable>)構文で使用できます。しかし、<literal>ESCAPE</literal>句はこれには含むことはできません。
状況によっては背後の演算子名を代わりに使わなければならない場合もあります。
   </para>

   <para>
<!--
    Also see the starts-with operator <literal>^@</literal> and the
    corresponding <function>starts_with()</function> function, which are
    useful in cases where simply matching the beginning of a string is
    needed.
-->
単に文字列の先頭からの開始が必要なだけのケースであれば、そこから開始演算子<literal>^@</literal>とそれに対応する<function>starts_with</function>関数もあります。
   </para>
  </sect2>


  <sect2 id="functions-similarto-regexp">
<!--
   <title><function>SIMILAR TO</function> Regular Expressions</title>
-->
   <title><function>SIMILAR TO</function>正規表現</title>

   <indexterm>
    <primary>regular expression</primary>
    <!-- <seealso>pattern matching</seealso> breaks index build -->
   </indexterm>
   <indexterm>
    <primary>正規表現</primary>
   </indexterm>

   <indexterm>
    <primary>SIMILAR TO</primary>
   </indexterm>
   <indexterm>
    <primary>substring</primary>
   </indexterm>

<synopsis>
<replaceable>string</replaceable> SIMILAR TO <replaceable>pattern</replaceable> <optional>ESCAPE <replaceable>escape-character</replaceable></optional>
<replaceable>string</replaceable> NOT SIMILAR TO <replaceable>pattern</replaceable> <optional>ESCAPE <replaceable>escape-character</replaceable></optional>
</synopsis>

   <para>
<!--
    The <function>SIMILAR TO</function> operator returns true or
    false depending on whether its pattern matches the given string.
    It is similar to <function>LIKE</function>, except that it
    interprets the pattern using the SQL standard's definition of a
    regular expression.  SQL regular expressions are a curious cross
    between <function>LIKE</function> notation and common (POSIX) regular
    expression notation.
-->
<function>SIMILAR TO</function>演算子は、そのパターンが与えられた文字列に一致するかどうかにより、真もしくは偽を返します。
これは、標準SQLの正規表現定義を使用してパターンを解釈するという点以外は、<function>LIKE</function>に類似しています。
SQLの正規表現は、<function>LIKE</function>表記と一般的な(POSIX)正規表現の表記とを混ぜ合わせたようなものになっています。
   </para>

   <para>
<!--
    Like <function>LIKE</function>, the <function>SIMILAR TO</function>
    operator succeeds only if its pattern matches the entire string;
    this is unlike common regular expression behavior where the pattern
    can match any part of the string.
    Also like
    <function>LIKE</function>, <function>SIMILAR TO</function> uses
    <literal>_</literal> and <literal>%</literal> as wildcard characters denoting
    any single character and any string, respectively (these are
    comparable to <literal>.</literal> and <literal>.*</literal> in POSIX regular
    expressions).
-->
<function>LIKE</function>と同様、<function>SIMILAR TO</function>演算子は、そのパターンが文字列全体に一致した場合のみ真を返します。これは、パターンが文字列の一部分であっても一致する、一般的な正規表現の動作とは異なっています。
また、<function>LIKE</function>と同様、<function>SIMILAR TO</function>では、<literal>%</literal>および<literal>_</literal>を、それぞれ任意の文字列および任意の単一文字を意味するワイルドカード文字として使用します（これらは、POSIX正規表現での<literal>.*</literal>および<literal>.</literal>に相当します）。
   </para>

   <para>
<!--
    In addition to these facilities borrowed from <function>LIKE</function>,
    <function>SIMILAR TO</function> supports these pattern-matching
    metacharacters borrowed from POSIX regular expressions:
-->
<function>LIKE</function>から取り入れた上記の機能に加え、<function>SIMILAR TO</function>では、以下のようにPOSIX正規表現から取り入れたパターンマッチメタ文字もサポートしています。

   <itemizedlist>
    <listitem>
     <para>
<!--
      <literal>|</literal> denotes alternation (either of two alternatives).
-->
<literal>|</literal>は、二者択一（2つの選択肢のうちいずれか）を意味します。
     </para>
    </listitem>
    <listitem>
     <para>
<!--
      <literal>*</literal> denotes repetition of the previous item zero
      or more times.
-->
<literal>*</literal>は、直前の項目の0回以上の繰り返しを意味します。
     </para>
    </listitem>
    <listitem>
     <para>
<!--
      <literal>+</literal> denotes repetition of the previous item one
      or more times.
-->
<literal>+</literal>は、直前の項目の1回以上の繰り返しを意味します。
     </para>
    </listitem>
    <listitem>
     <para>
<!--
      <literal>?</literal> denotes repetition of the previous item zero
      or one time.
-->
<literal>?</literal>は、直前の項目の0回もしくは1回の繰り返しを意味します。
     </para>
    </listitem>
    <listitem>
     <para>
<!--
      <literal>{</literal><replaceable>m</replaceable><literal>}</literal> denotes repetition
      of the previous item exactly <replaceable>m</replaceable> times.
-->
<literal>{</literal><replaceable>m</replaceable><literal>}</literal>は、直前の項目の正確な<replaceable>m</replaceable>回の繰り返しを意味します。
     </para>
    </listitem>
    <listitem>
     <para>
<!--
      <literal>{</literal><replaceable>m</replaceable><literal>,}</literal> denotes repetition
      of the previous item <replaceable>m</replaceable> or more times.
-->
      <literal>{</literal><replaceable>m</replaceable><literal>,}</literal>は、直前の項目の<replaceable>m</replaceable>回以上の繰り返しを意味します。
     </para>
    </listitem>
    <listitem>
     <para>
<!--
      <literal>{</literal><replaceable>m</replaceable><literal>,</literal><replaceable>n</replaceable><literal>}</literal>
      denotes repetition of the previous item at least <replaceable>m</replaceable> and
      not more than <replaceable>n</replaceable> times.
-->
<literal>{</literal><replaceable>m</replaceable><literal>,</literal><replaceable>n</replaceable><literal>}</literal>は、直前の項目の<replaceable>m</replaceable>回以上かつ<replaceable>n</replaceable>回以下の繰り返しを意味します。
     </para>
    </listitem>
    <listitem>
     <para>
<!--
      Parentheses <literal>()</literal> can be used to group items into
      a single logical item.
-->
丸括弧<literal>()</literal>は、項目を1つの論理項目にグループ化することができます。
     </para>
    </listitem>
    <listitem>
     <para>
<!--
      A bracket expression <literal>[...]</literal> specifies a character
      class, just as in POSIX regular expressions.
-->
大括弧式<literal>[...]</literal>は、POSIX正規表現と同様に文字クラスを指定します。
     </para>
    </listitem>
   </itemizedlist>

<!--
    Notice that the period (<literal>.</literal>) is not a metacharacter
    for <function>SIMILAR TO</function>.
-->
<function>SIMILAR TO</function>ではピリオド（<literal>.</literal>）はメタ文字ではないことに注意してください。
   </para>

   <para>
<!--
    As with <function>LIKE</function>, a backslash disables the special
    meaning of any of these metacharacters.  A different escape character
    can be specified with <literal>ESCAPE</literal>, or the escape
    capability can be disabled by writing <literal>ESCAPE ''</literal>.
-->
<function>LIKE</function>と同様、バックスラッシュは全てのメタ文字の特殊な意味を無効にします。
異なるエスケープ文字を<literal>ESCAPE</literal>で指定することもできますし、<literal>ESCAPE ''</literal>と書くことにより、エスケープ機能を無効にすることもできます。
   </para>

   <para>
<!--
    According to the SQL standard, omitting <literal>ESCAPE</literal>
    means there is no escape character (rather than defaulting to a
    backslash), and a zero-length <literal>ESCAPE</literal> value is
    disallowed.  <productname>PostgreSQL</productname>'s behavior in
    this regard is therefore slightly nonstandard.
-->
標準SQLによれば、<literal>ESCAPE</literal>は（デフォルトがバックスラッシュとなるのではなく）エスケープ文字が存在しないことを意味します。長さゼロの<literal>ESCAPE</literal>は使用できません。
ですからこの点で<productname>PostgreSQL</productname>は少し非標準な振る舞いをします。
   </para>

   <para>
<!--
    Another nonstandard extension is that following the escape character
    with a letter or digit provides access to the escape sequences
    defined for POSIX regular expressions; see
    <xref linkend="posix-character-entry-escapes-table"/>,
    <xref linkend="posix-class-shorthand-escapes-table"/>, and
    <xref linkend="posix-constraint-escapes-table"/> below.
-->
他の非標準の拡張としては、エスケープ文字に続く文字あるいは数字を用いてPOSIX正規表現で定義されたエスケープシーケンスへのアクセスを提供するというのがあります。
以下の<xref linkend="posix-character-entry-escapes-table"/>、<xref linkend="posix-class-shorthand-escapes-table"/>、<xref linkend="posix-constraint-escapes-table"/>を参照してください。
   </para>

   <para>
<!--
    Some examples:
-->
例を示します。
<programlisting>
'abc' SIMILAR TO 'abc'          <lineannotation>true</lineannotation>
'abc' SIMILAR TO 'a'            <lineannotation>false</lineannotation>
'abc' SIMILAR TO '%(b|d)%'      <lineannotation>true</lineannotation>
'abc' SIMILAR TO '(b|c)%'       <lineannotation>false</lineannotation>
'-abc-' SIMILAR TO '%\mabc\M%'  <lineannotation>true</lineannotation>
'xabcy' SIMILAR TO '%\mabc\M%'  <lineannotation>false</lineannotation>
</programlisting>
   </para>

   <para>
<!--
    The <function>substring</function> function with three parameters
    provides extraction of a substring that matches an SQL
    regular expression pattern.  The function can be written according
    to standard SQL syntax:
-->
3つのパラメータを持つ<function>substring</function>関数を使用して、SQL正規表現パターンに一致する部分文字列を取り出すことができます。
標準SQLの構文にしたがって、この関数は次のように書くことができます。
<synopsis>
substring(<replaceable>string</replaceable> similar <replaceable>pattern</replaceable> escape <replaceable>escape-character</replaceable>)
</synopsis>
<!--
    or using the now obsolete SQL:1999 syntax:
-->
あるいは今では廃れたSQL:1999の構文を使って次のように書くことができます。
<synopsis>
substring(<replaceable>string</replaceable> from <replaceable>pattern</replaceable> for <replaceable>escape-character</replaceable>)
</synopsis>
<!--
    or as a plain three-argument function:
-->
あるいは単なる3引数関数として次のように書くこともできます。
<synopsis>
substring(<replaceable>string</replaceable>, <replaceable>pattern</replaceable>, <replaceable>escape-character</replaceable>)
</synopsis>
<!--
    As with <literal>SIMILAR TO</literal>, the
    specified pattern must match the entire data string, or else the
    function fails and returns null.  To indicate the part of the
    pattern for which the matching data sub-string is of interest,
    the pattern should contain
    two occurrences of the escape character followed by a double quote
    (<literal>"</literal>). <!&#45;- " font-lock sanity &#45;->
    The text matching the portion of the pattern
    between these separators is returned when the match is successful.
-->
<literal>SIMILAR TO</literal>と同様、指定したパターンがデータ文字列全体に一致する必要があります。一致しない場合、関数は失敗し、NULLを返します。
マッチするデータのうちの対象とする部分文字列に対応するパターンの部分を示すために、エスケープ文字の後に二重引用符（<literal>"</literal>）を繋げたものを2つパターンに含める必要があります。<!-- " font-lock sanity -->
マッチが成功すると、これらの区切り文字で囲まれたパターンの部分に一致するテキストが返されます。
   </para>

   <para>
<!--
    The escape-double-quote separators actually
    divide <function>substring</function>'s pattern into three independent
    regular expressions; for example, a vertical bar (<literal>|</literal>)
    in any of the three sections affects only that section.  Also, the first
    and third of these regular expressions are defined to match the smallest
    possible amount of text, not the largest, when there is any ambiguity
    about how much of the data string matches which pattern.  (In POSIX
    parlance, the first and third regular expressions are forced to be
    non-greedy.)
-->
エスケープ文字と二重引用符による区切りは実際には<function>substring</function>のパターン引数を3つの独立した正規表現に分割します。
たとえば3つのセクションのどこかに置いた垂直線（<literal>|</literal>）はそのセクションにしか影響を及ぼしません。
また、どのパターンにデータ文字列がマッチするかについて曖昧さがある場合は、最初と3番目の正規表現は、可能な最大のテキストではなく、最小のテキストにマッチするものとして定義されます。
（POSIX用語では、最初と3番目の正規表現は非貪欲（non-greedy）に強制されます。）
   </para>

   <para>
<!--
    As an extension to the SQL standard, <productname>PostgreSQL</productname>
    allows there to be just one escape-double-quote separator, in which case
    the third regular expression is taken as empty; or no separators, in which
    case the first and third regular expressions are taken as empty.
-->
標準SQLへの拡張として、<productname>PostgreSQL</productname>は、二重引用符による区切りが一個だけ存在することを許容し、その場合は3番目の正規表現が空として扱われます。
あるいは、二重引用符による区切りがないことも許容し、その場合は最初と3番目の正規表現は空として扱われます。
   </para>

   <para>
<!--
    Some examples, with <literal>#&quot;</literal> delimiting the return string:
-->
例：<literal>#&quot;</literal>を使用して返される文字列を区切ります。
<programlisting>
substring('foobar' similar '%#"o_b#"%' escape '#')   <lineannotation>oob</lineannotation>
substring('foobar' similar '#"o_b#"%' escape '#')    <lineannotation>NULL</lineannotation>
</programlisting>
   </para>
  </sect2>

  <sect2 id="functions-posix-regexp">
<!--
   <title><acronym>POSIX</acronym> Regular Expressions</title>
-->
   <title><acronym>POSIX</acronym>正規表現</title>

   <indexterm zone="functions-posix-regexp">
    <primary>regular expression</primary>
    <seealso>pattern matching</seealso>
   </indexterm>
   <indexterm zone="functions-posix-regexp">
    <primary>正規表現</primary>
    <seealso>パターンマッチ</seealso>
   </indexterm>
   <indexterm>
    <primary>substring</primary>
   </indexterm>
   <indexterm>
    <primary>regexp_count</primary>
   </indexterm>
   <indexterm>
    <primary>regexp_instr</primary>
   </indexterm>
   <indexterm>
    <primary>regexp_like</primary>
   </indexterm>
   <indexterm>
    <primary>regexp_match</primary>
   </indexterm>
   <indexterm>
    <primary>regexp_matches</primary>
   </indexterm>
   <indexterm>
    <primary>regexp_replace</primary>
   </indexterm>
   <indexterm>
    <primary>regexp_split_to_table</primary>
   </indexterm>
   <indexterm>
    <primary>regexp_split_to_array</primary>
   </indexterm>
   <indexterm>
    <primary>regexp_substr</primary>
   </indexterm>

   <para>
<!--
    <xref linkend="functions-posix-table"/> lists the available
    operators for pattern matching using POSIX regular expressions.
-->
<xref linkend="functions-posix-table"/>に、POSIX正規表現を使ったパターンマッチに使用可能な演算子を列挙します。
   </para>

   <table id="functions-posix-table">
<!--
    <title>Regular Expression Match Operators</title>
-->
    <title>正規表現マッチ演算子</title>

    <tgroup cols="1">
     <thead>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
<!--
        Operator
-->
演算子
       </para>
       <para>
<!--
        Description
-->
説明
       </para>
       <para>
<!--
        Example(s)
-->
例
       </para></entry>
      </row>
     </thead>

      <tbody>
       <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>text</type> <literal>~</literal> <type>text</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        String matches regular expression, case sensitively
-->
文字列が正規表現にマッチ、大文字小文字の区別あり
       </para>
       <para>
        <literal>'thomas' ~ 't.*ma'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
       </row>

       <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>text</type> <literal>~*</literal> <type>text</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        String matches regular expression, case-insensitively
-->
文字列が正規表現にマッチ、大文字小文字の区別なし
       </para>
       <para>
        <literal>'thomas' ~* 'T.*ma'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
       </row>

       <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>text</type> <literal>!~</literal> <type>text</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        String does not match regular expression, case sensitively
-->
文字列が正規表現にマッチしない、大文字小文字の区別あり
       </para>
       <para>
        <literal>'thomas' !~ 't.*max'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
       </row>

       <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>text</type> <literal>!~*</literal> <type>text</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
<!--
        String does not match regular expression, case-insensitively
-->
文字列が正規表現にマッチしない、大文字小文字の区別なし
       </para>
       <para>
        <literal>'thomas' !~* 'T.*ma'</literal>
        <returnvalue>f</returnvalue>
       </para></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

    <para>
<!--
     <acronym>POSIX</acronym> regular expressions provide a more
     powerful means for pattern matching than the <function>LIKE</function> and
     <function>SIMILAR TO</function> operators.
     Many Unix tools such as <command>egrep</command>,
     <command>sed</command>, or <command>awk</command> use a pattern
     matching language that is similar to the one described here.
-->
<acronym>POSIX</acronym>正規表現は、パターンマッチという意味合いでは、<function>LIKE</function>および<function>SIMILAR TO</function>演算子よりもさらに強力です。
<command>egrep</command>、<command>sed</command>、あるいは<command>awk</command>のような多くのUnixツールはここで解説しているのと類似したパターンマッチ言語を使用しています。
    </para>

    <para>
<!--
     A regular expression is a character sequence that is an
     abbreviated definition of a set of strings (a <firstterm>regular
     set</firstterm>).  A string is said to match a regular expression
     if it is a member of the regular set described by the regular
     expression.  As with <function>LIKE</function>, pattern characters
     match string characters exactly unless they are special characters
     in the regular expression language &mdash; but regular expressions use
     different special characters than <function>LIKE</function> does.
     Unlike <function>LIKE</function> patterns, a
     regular expression is allowed to match anywhere within a string, unless
     the regular expression is explicitly anchored to the beginning or
     end of the string.
-->
正規表現とは文字列の集合（<firstterm>正規集合</firstterm>）の簡略された定義である文字が連なっているものです。
ある文字列が正規表現で記述された正規集合の要素になっていれば、その文字列は正規表現にマッチしていると呼ばれます。
<function>LIKE</function>と同様、正規表現言語で特殊文字とされているもの以外、パターン文字は文字列と完全にマッチされます。とは言っても、正規表現は<function>LIKE</function>関数が使用するのとは異なる特殊文字を使用します。
<function>LIKE</function>関数のパターンと違って正規表現は、明示的に正規表現が文字列の最初または最後からと位置指定されていない限り文字列内のどの位置でもマッチを行えます。
    </para>

    <para>
<!--
     Some examples:
-->
例：
<programlisting>
'abcd' ~ 'bc'     <lineannotation>true</lineannotation>
'abcd' ~ 'a.c'    <lineannotation>true &mdash; dot matches any character</lineannotation>
'abcd' ~ 'a.*d'   <lineannotation>true &mdash; <literal>*</literal> repeats the preceding pattern item</lineannotation>
'abcd' ~ '(b|x)'  <lineannotation>true &mdash; <literal>|</literal> means OR, parentheses group</lineannotation>
'abcd' ~ '^a'     <lineannotation>true &mdash; <literal>^</literal> anchors to start of string</lineannotation>
'abcd' ~ '^(b|c)' <lineannotation>false &mdash; would match except for anchoring</lineannotation>
</programlisting>
    </para>

    <para>
<!--
     The <acronym>POSIX</acronym> pattern language is described in much
     greater detail below.
-->
<acronym>POSIX</acronym>パターン言語について以下により詳しく説明します。
    </para>

    <para>
<!--
     The <function>substring</function> function with two parameters,
     <function>substring(<replaceable>string</replaceable> from
     <replaceable>pattern</replaceable>)</function>, provides extraction of a
     substring
     that matches a POSIX regular expression pattern.  It returns null if
     there is no match, otherwise the first portion of the text that matched the
     pattern.  But if the pattern contains any parentheses, the portion
     of the text that matched the first parenthesized subexpression (the
     one whose left parenthesis comes first) is
     returned.  You can put parentheses around the whole expression
     if you want to use parentheses within it without triggering this
     exception.  If you need parentheses in the pattern before the
     subexpression you want to extract, see the non-capturing parentheses
     described below.
-->
2つのパラメータを持つ<function>substring</function>関数、<function>substring(<replaceable>string</replaceable> from <replaceable>pattern</replaceable>)</function>を使用して、POSIX正規表現パターンにマッチする部分文字列を取り出すことができます。
この関数は、マッチするものがない場合にはNULLを返し、ある場合はパターンに最初にマッチしたテキストの一部を返します。
しかし、丸括弧を持つパターンの場合、最初の丸括弧内部分正規表現（左丸括弧が最初に来るもの）にマッチするテキストの一部が返されます。
この例外を起こさずにパターン中に丸括弧を使用したいのであれば、常に正規表現全体を丸括弧で囲むことができます。
パターン内の抽出対象の部分文字列より前に丸括弧が必要な場合、後述の捕捉されない丸括弧を参照してください。
    </para>

   <para>
<!--
    Some examples:
-->
例：
<programlisting>
substring('foobar' from 'o.b')     <lineannotation>oob</lineannotation>
substring('foobar' from 'o(.)b')   <lineannotation>o</lineannotation>
</programlisting>
   </para>

    <para>
<!--
     The <function>regexp_count</function> function counts the number of
     places where a POSIX regular expression pattern matches a string.
     It has the syntax
     <function>regexp_count</function>(<replaceable>string</replaceable>,
     <replaceable>pattern</replaceable>
     <optional>, <replaceable>start</replaceable>
     <optional>, <replaceable>flags</replaceable>
     </optional></optional>).
     <replaceable>pattern</replaceable> is searched for
     in <replaceable>string</replaceable>, normally from the beginning of
     the string, but if the <replaceable>start</replaceable> parameter is
     provided then beginning from that character index.
     The <replaceable>flags</replaceable> parameter is an optional text
     string containing zero or more single-letter flags that change the
     function's behavior.  For example, including <literal>i</literal> in
     <replaceable>flags</replaceable> specifies case-insensitive matching.
     Supported flags are described in
     <xref linkend="posix-embedded-options-table"/>.
-->
<function>regexp_count</function>関数は、POSIX正規表現パターンが文字列とマッチした箇所の数をカウントします。
この関数は<function>regexp_count</function>(<replaceable>string</replaceable>,<replaceable>pattern</replaceable><optional>,<replaceable>start</replaceable><optional>,<replaceable>flags</replaceable></optional></optional>)という構文を持ちます。
<replaceable>pattern</replaceable>は<replaceable>string</replaceable>で検索されます。
通常は文字列の先頭から検索されますが、<replaceable>start</replaceable>パラメータが指定されている場合は、その文字インデックスから検索が開始されます。
<replaceable>flags</replaceable>パラメータは、オプションのテキスト文字列であり、関数の動作を変更する0個以上の単一文字フラグを含みます。
 たとえば、<replaceable>flags</replaceable>に<literal>i</literal>を含めると、大文字と小文字を区別しないマッチングを指定します。
サポートされているフラグは<xref linkend="posix-embedded-options-table"/>で説明されています。
    </para>

    <para>
<!--
     Some examples:
-->
例を示します。
<programlisting>
regexp_count('ABCABCAXYaxy', 'A.')          <lineannotation>3</lineannotation>
regexp_count('ABCABCAXYaxy', 'A.', 1, 'i')  <lineannotation>4</lineannotation>
</programlisting>
    </para>

    <para>
<!--
     The <function>regexp_instr</function> function returns the starting or
     ending position of the <replaceable>N</replaceable>'th match of a
     POSIX regular expression pattern to a string, or zero if there is no
     such match.  It has the syntax
     <function>regexp_instr</function>(<replaceable>string</replaceable>,
     <replaceable>pattern</replaceable>
     <optional>, <replaceable>start</replaceable>
     <optional>, <replaceable>N</replaceable>
     <optional>, <replaceable>endoption</replaceable>
     <optional>, <replaceable>flags</replaceable>
     <optional>, <replaceable>subexpr</replaceable>
     </optional></optional></optional></optional></optional>).
     <replaceable>pattern</replaceable> is searched for
     in <replaceable>string</replaceable>, normally from the beginning of
     the string, but if the <replaceable>start</replaceable> parameter is
     provided then beginning from that character index.
     If <replaceable>N</replaceable> is specified
     then the <replaceable>N</replaceable>'th match of the pattern
     is located, otherwise the first match is located.
     If the <replaceable>endoption</replaceable> parameter is omitted or
     specified as zero, the function returns the position of the first
     character of the match.  Otherwise, <replaceable>endoption</replaceable>
     must be one, and the function returns the position of the character
     following the match.
     The <replaceable>flags</replaceable> parameter is an optional text
     string containing zero or more single-letter flags that change the
     function's behavior.  Supported flags are described
     in <xref linkend="posix-embedded-options-table"/>.
     For a pattern containing parenthesized
     subexpressions, <replaceable>subexpr</replaceable> is an integer
     indicating which subexpression is of interest: the result identifies
     the position of the substring matching that subexpression.
     Subexpressions are numbered in the order of their leading parentheses.
     When <replaceable>subexpr</replaceable> is omitted or zero, the result
     identifies the position of the whole match regardless of
     parenthesized subexpressions.
-->
<function>regexp_instr</function>関数は、文字列に対するPOSIX正規表現パターンの<replaceable>N</replaceable>番目のマッチの開始位置または終了位置を返します。
マッチがない場合は0を返します。
構文は、<function>regexp_instr</function>(<replaceable>string</replaceable>, <replaceable>pattern</replaceable> <optional>, <replaceable>start</replaceable> <optional>, <replaceable>N</replaceable> <optional>, <replaceable>endoption</replaceable> <optional>, <replaceable>flags</replaceable> <optional>, <replaceable>subexpr</replaceable>
 </optional></optional></optional></optional></optional>)を持ちます。
<replaceable>pattern</replaceable>は<replaceable>string</replaceable>内で検索されます。通常は文字列の先頭から検索されますが、<replaceable>start</replaceable>パラメータが指定されている場合は、その文字インデックスから検索が開始されます。
<replaceable>N</replaceable>が指定されている場合は、パターンの<replaceable>N</replaceable>番目の一致が検索されます。
それ以外の場合は、最初の一致が検索されます。
<replaceable>endoption</replaceable>パラメータが省略されているか0が指定されている場合、関数は一致の最初の文字の位置を返します。
それ以外の場合は、<replaceable>endoption</replaceable>は1である必要があり、関数は一致の次の文字の位置を返します。
<replaceable>flags</replaceable>パラメータは、関数の動作を変更する0個以上の単一文字フラグを含むオプションのテキスト文字列です。
サポートされているフラグは<xref linkend="posix-embedded-options-table"/>で説明されています。
カッコで囲まれた部分式を含むパターンでは、<replaceable>subexpr</replaceable>は対象の部分式を示す整数です。
結果は、その部分式に一致する部分文字列の位置を示します。
部分式は先頭のカッコの順に番号が付けられます。
<replaceable>subexpr</replaceable>が省略されているか0の場合、結果はカッコで囲まれた部分式に関係なく、一致全体の位置を示します。
    </para>

    <para>
<!--
     Some examples:
-->
例を示します。
<programlisting>
regexp_instr('number of your street, town zip, FR', '[^,]+', 1, 2)
                                   <lineannotation>23</lineannotation>
regexp_instr('ABCDEFGHI', '(c..)(...)', 1, 1, 0, 'i', 2)
                                   <lineannotation>6</lineannotation>
</programlisting>
    </para>

    <para>
<!--
     The <function>regexp_like</function> function checks whether a match
     of a POSIX regular expression pattern occurs within a string,
     returning boolean true or false.  It has the syntax
     <function>regexp_like</function>(<replaceable>string</replaceable>,
     <replaceable>pattern</replaceable>
     <optional>, <replaceable>flags</replaceable> </optional>).
     The <replaceable>flags</replaceable> parameter is an optional text
     string containing zero or more single-letter flags that change the
     function's behavior.  Supported flags are described
     in <xref linkend="posix-embedded-options-table"/>.
     This function has the same results as the <literal>~</literal>
     operator if no flags are specified.  If only the <literal>i</literal>
     flag is specified, it has the same results as
     the <literal>~*</literal> operator.
-->
<function>regexp_like</function>関数は、POSIX正規表現パターンの一致が文字列内にあるかどうかをチェックし、ブール値trueまたはfalseを返します。
構文は<function>regexp_like</function>（<replaceable>string</replaceable>,<replaceable>pattern</replaceable><optional>,<replaceable>flags</replaceable></optional>）です。
<replaceable>flags</replaceable>パラメータは、関数の動作を変更する0個以上の単一文字フラグを含むオプションのテキスト文字列です。
サポートされているフラグは<xref linkend="posix-embedded-options-table"/>で説明されています。
フラグが指定されていない場合、この関数は<literal>~</literal>演算子と同じ結果になります。
<literal>i</literal>フラグのみが指定されている場合、<literal>~*</literal>演算子と同じ結果になります。
    </para>

    <para>
<!--
     Some examples:
-->
例を示します。
<programlisting>
regexp_like('Hello World', 'world')       <lineannotation>false</lineannotation>
regexp_like('Hello World', 'world', 'i')  <lineannotation>true</lineannotation>
</programlisting>
    </para>

    <para>
<!--
     The <function>regexp_match</function> function returns a text array of
     matching substring(s) within the first match of a POSIX
     regular expression pattern to a string.  It has the syntax
     <function>regexp_match</function>(<replaceable>string</replaceable>,
     <replaceable>pattern</replaceable> <optional>, <replaceable>flags</replaceable> </optional>).
     If there is no match, the result is <literal>NULL</literal>.
     If a match is found, and the <replaceable>pattern</replaceable> contains no
     parenthesized subexpressions, then the result is a single-element text
     array containing the substring matching the whole pattern.
     If a match is found, and the <replaceable>pattern</replaceable> contains
     parenthesized subexpressions, then the result is a text array
     whose <replaceable>n</replaceable>'th element is the substring matching
     the <replaceable>n</replaceable>'th parenthesized subexpression of
     the <replaceable>pattern</replaceable> (not counting <quote>non-capturing</quote>
     parentheses; see below for details).
     The <replaceable>flags</replaceable> parameter is an optional text string
     containing zero or more single-letter flags that change the function's
     behavior.  Supported flags are described
     in <xref linkend="posix-embedded-options-table"/>.
-->
<function>regexp_match</function>関数はPOSIX正規表現パターンを文字列にマッチさせた結果、一致した最初の部分文字列のテキスト配列を返します。
<function>regexp_match</function>(<replaceable>string</replaceable>, <replaceable>pattern</replaceable> <optional>, <replaceable>flags</replaceable> </optional>)の構文になります。
マッチするものがなければ、結果は<literal>NULL</literal>となります。
マッチする部分があり、かつ<replaceable>pattern</replaceable>が丸括弧で括られた部分文字列を含まない場合、結果はパターン全体にマッチする部分文字列を含む単一要素のテキスト配列となります。
マッチする部分があり、かつ<replaceable>pattern</replaceable>が丸括弧で括られた部分文字列を含む場合、結果はテキスト配列で、その<replaceable>n</replaceable>番目の要素は<replaceable>pattern</replaceable>の<replaceable>n</replaceable>番目に丸括弧で括られた部分文字列にマッチする部分文字列となります（<quote>捕捉されない</quote>丸括弧は数えません。詳細は以下を参照してください）。
<replaceable>flags</replaceable>パラメータは、関数の動作を変更するゼロもしくは複数の単一文字フラグを含むオプションのテキスト文字列です。
有効なフラグは<xref linkend="posix-embedded-options-table"/>に記載されています。
    </para>

   <para>
<!--
    Some examples:
-->
例：
<programlisting>
SELECT regexp_match('foobarbequebaz', 'bar.*que');
 regexp_match
--------------
 {barbeque}
(1 row)

SELECT regexp_match('foobarbequebaz', '(bar)(beque)');
 regexp_match
--------------
 {bar,beque}
(1 row)
</programlisting>
   </para>

    <tip>
     <para>
<!--
      In the common case where you just want the whole matching substring
      or <literal>NULL</literal> for no match, the best solution is to
      use <function>regexp_substr()</function>.
      However, <function>regexp_substr()</function> only exists
      in <productname>PostgreSQL</productname> version 15 and up.  When
      working in older versions, you can extract the first element
      of <function>regexp_match()</function>'s result, for example:
-->
部分文字列全体を一致させたい、または<literal>NULL</literal>を一致させたくないという一般的なケースでは、最善の解決策は<function>regexp_substr()</function>を使用することです。
しかし、<function>regexp_substr()</function>は<productname>PostgreSQL</productname>バージョン15以降にしか存在しません。
古いバージョンで作業する場合、以下のように<function>regexp_match()</function>の結果の最初の要素を抽出することができます。
<programlisting>
SELECT (regexp_match('foobarbequebaz', 'bar.*que'))[1];
 regexp_match
--------------
 barbeque
(1 row)
</programlisting>
     </para>
    </tip>

    <para>
<!--
     The <function>regexp_matches</function> function returns a set of text arrays
     of matching substring(s) within matches of a POSIX regular
     expression pattern to a string.  It has the same syntax as
     <function>regexp_match</function>.
     This function returns no rows if there is no match, one row if there is
     a match and the <literal>g</literal> flag is not given, or <replaceable>N</replaceable>
     rows if there are <replaceable>N</replaceable> matches and the <literal>g</literal> flag
     is given.  Each returned row is a text array containing the whole
     matched substring or the substrings matching parenthesized
     subexpressions of the <replaceable>pattern</replaceable>, just as described above
     for <function>regexp_match</function>.
     <function>regexp_matches</function> accepts all the flags shown
     in <xref linkend="posix-embedded-options-table"/>, plus
     the <literal>g</literal> flag which commands it to return all matches, not
     just the first one.
-->
<function>regexp_matches</function>関数はPOSIX正規表現パターンを文字列にマッチさせた結果、一致した部分文字列のテキスト配列の集合を返します。
構文は<function>regexp_match</function>と同じです。
この関数は、マッチするものがないときは行を返しませんが、マッチするものがあり、<literal>g</literal>フラグが指定されていないときは1行だけ、マッチするものが<replaceable>N</replaceable>個あり、<literal>g</literal>フラグが指定されているときは<replaceable>N</replaceable>行を返します。
返される各行は上で<function>regexp_match</function>について説明したのと全く同じで、マッチする部分文字列全体、または<replaceable>pattern</replaceable>の丸括弧で括られた部分文字列にマッチする部分文字列を含むテキスト配列です。
<function>regexp_matches</function>は<xref linkend="posix-embedded-options-table"/>に示すすべてのフラグに加え、最初のマッチだけでなくすべてのマッチを返す<literal>g</literal>を受け付けます。
    </para>

   <para>
<!--
    Some examples:
-->
例：
<programlisting>
SELECT regexp_matches('foo', 'not there');
 regexp_matches
----------------
(0 rows)

SELECT regexp_matches('foobarbequebazilbarfbonk', '(b[^b]+)(b[^b]+)', 'g');
 regexp_matches
----------------
 {bar,beque}
 {bazil,barf}
(2 rows)
</programlisting>
   </para>

   <tip>
    <para>
<!--
     In most cases <function>regexp_matches()</function> should be used with
     the <literal>g</literal> flag, since if you only want the first match, it's
     easier and more efficient to use <function>regexp_match()</function>.
     However, <function>regexp_match()</function> only exists
     in <productname>PostgreSQL</productname> version 10 and up.  When working in older
     versions, a common trick is to place a <function>regexp_matches()</function>
     call in a sub-select, for example:
-->
最初にマッチするものだけが必要なときは<function>regexp_match()</function>を使う方がより簡単で効率的ですから、<function>regexp_matches()</function>はほとんどの場合<literal>g</literal>フラグを指定して使われるでしょう。
しかし、<function>regexp_match()</function>は<productname>PostgreSQL</productname>のバージョン10以上でのみ利用できます。
古いバージョンを使う時によくある手法は、以下の例のように、副SELECTの中に<function>regexp_matches()</function>の呼び出しを入れることです。
<programlisting>
SELECT col1, (SELECT regexp_matches(col2, '(bar)(beque)')) FROM tab;
</programlisting>
<!--
     This produces a text array if there's a match, or <literal>NULL</literal> if
     not, the same as <function>regexp_match()</function> would do.  Without the
     sub-select, this query would produce no output at all for table rows
     without a match, which is typically not the desired behavior.
-->
これは<function>regexp_match()</function>と同じく、マッチするものがあればテキスト配列を生成し、マッチしなければ<literal>NULL</literal>となります。
副SELECTを使わなければ、マッチするものがないテーブル行については問い合わせの出力が生成されず、多くの場合に期待される動作と異なります。
    </para>
   </tip>

    <para>
<!--
     The <function>regexp_replace</function> function provides substitution of
     new text for substrings that match POSIX regular expression patterns.
     It has the syntax
     <function>regexp_replace</function>(<replaceable>source</replaceable>,
     <replaceable>pattern</replaceable>, <replaceable>replacement</replaceable>
     <optional>, <replaceable>start</replaceable>
     <optional>, <replaceable>N</replaceable>
     </optional></optional>
     <optional>, <replaceable>flags</replaceable> </optional>).
     (Notice that <replaceable>N</replaceable> cannot be specified
     unless <replaceable>start</replaceable> is,
     but <replaceable>flags</replaceable> can be given in any case.)
     The <replaceable>source</replaceable> string is returned unchanged if
     there is no match to the <replaceable>pattern</replaceable>.  If there is a
     match, the <replaceable>source</replaceable> string is returned with the
     <replaceable>replacement</replaceable> string substituted for the matching
     substring.  The <replaceable>replacement</replaceable> string can contain
     <literal>\</literal><replaceable>n</replaceable>, where <replaceable>n</replaceable> is 1
     through 9, to indicate that the source substring matching the
     <replaceable>n</replaceable>'th parenthesized subexpression of the pattern should be
     inserted, and it can contain <literal>\&amp;</literal> to indicate that the
     substring matching the entire pattern should be inserted.  Write
     <literal>\\</literal> if you need to put a literal backslash in the replacement
     text.
     <replaceable>pattern</replaceable> is searched for
     in <replaceable>string</replaceable>, normally from the beginning of
     the string, but if the <replaceable>start</replaceable> parameter is
     provided then beginning from that character index.
     By default, only the first match of the pattern is replaced.
     If <replaceable>N</replaceable> is specified and is greater than zero,
     then the <replaceable>N</replaceable>'th match of the pattern
     is replaced.
     If the <literal>g</literal> flag is given, or
     if <replaceable>N</replaceable> is specified and is zero, then all
     matches at or after the <replaceable>start</replaceable> position are
     replaced.  (The <literal>g</literal> flag is ignored
     when <replaceable>N</replaceable> is specified.)
     The <replaceable>flags</replaceable> parameter is an optional text
     string containing zero or more single-letter flags that change the
     function's behavior.  Supported flags (though
     not <literal>g</literal>) are
     described in <xref linkend="posix-embedded-options-table"/>.
-->
<function>regexp_replace</function>関数は、POSIX正規表現パターンにマッチする部分文字列を新規テキストと置換します。
構文は、<function>regexp_replace</function>(<replaceable>source</replaceable>, <replaceable>pattern</replaceable>, <replaceable>replacement</replaceable><optional>, <replaceable>start</replaceable><optional>, <replaceable>N</replaceable></optional></optional><optional>, <replaceable>flags</replaceable> </optional>)です。
（<replaceable>start</replaceable>が指定されない限り、<replaceable>N</replaceable>を指定できないこと、<replaceable>flags</replaceable>はいつでも指定できることに注意してください。）
<replaceable>pattern</replaceable>にマッチしない場合は、<replaceable>source</replaceable>文字列がそのまま返されます。
マッチすると、マッチ部分文字列を<replaceable>replacement</replaceable>文字列で置換した<replaceable>source</replaceable>文字列が返されます。
<replaceable>replacement</replaceable>文字列に<literal>\</literal><replaceable>n</replaceable>（<replaceable>n</replaceable>は1から9までの数字）を入れて、パターン内の<replaceable>n</replaceable>番目の丸括弧つき部分表現にマッチする元の部分文字列を挿入することができます。
また、<literal>\&amp;</literal>を入れて、パターン全体とマッチする部分文字列を挿入することもできます。
置換テキスト内にバックスラッシュそのものを挿入する必要がある時は<literal>\\</literal>と記述します。
通常<replaceable>string</replaceable>の先頭から<replaceable>pattern</replaceable>が文字列内で検索されますが、<replaceable>start</replaceable>引数が与えられるとその文字インデックスから検索されます。
デフォルトではパターンに一致した最初のマッチのみが置き換えられます。
<replaceable>N</replaceable>が指定され、それがゼロよりも大きい時は、パターンと<replaceable>N</replaceable>番目に一致したマッチが置き換えられます。
<literal>g</literal>フラグが指定されるか、<replaceable>N</replaceable>が指定されてそれがゼロなら、<replaceable>start</replaceable>位置あるいはそれ以降のすべてのマッチが置き換えられます。
（<literal>g</literal>フラグは<replaceable>N</replaceable>が指定されている時は無視されます。）
<replaceable>flags</replaceable>パラメータは、関数の動作を変更するゼロもしくはそれ以上の1文字フラグを含むオプションのテキスト文字列です。
有効なフラグは(<literal>g</literal>を除く)<xref linkend="posix-embedded-options-table"/>に記述されています。
    </para>

   <para>
<!--
    Some examples:
-->
例：
<programlisting>
regexp_replace('foobarbaz', 'b..', 'X')
                                   <lineannotation>fooXbaz</lineannotation>
regexp_replace('foobarbaz', 'b..', 'X', 'g')
                                   <lineannotation>fooXX</lineannotation>
regexp_replace('foobarbaz', 'b(..)', 'X\1Y', 'g')
                                   <lineannotation>fooXarYXazY</lineannotation>
regexp_replace('A PostgreSQL function', 'a|e|i|o|u', 'X', 1, 0, 'i')
                                   <lineannotation>X PXstgrXSQL fXnctXXn</lineannotation>
regexp_replace('A PostgreSQL function', 'a|e|i|o|u', 'X', 1, 3, 'i')
                                   <lineannotation>A PostgrXSQL function</lineannotation>
</programlisting>
   </para>

    <para>
<!--
     The <function>regexp_split_to_table</function> function splits a string using a POSIX
     regular expression pattern as a delimiter.  It has the syntax
     <function>regexp_split_to_table</function>(<replaceable>string</replaceable>, <replaceable>pattern</replaceable>
     <optional>, <replaceable>flags</replaceable> </optional>).
     If there is no match to the <replaceable>pattern</replaceable>, the function returns the
     <replaceable>string</replaceable>.  If there is at least one match, for each match it returns
     the text from the end of the last match (or the beginning of the string)
     to the beginning of the match.  When there are no more matches, it
     returns the text from the end of the last match to the end of the string.
     The <replaceable>flags</replaceable> parameter is an optional text string containing
     zero or more single-letter flags that change the function's behavior.
     <function>regexp_split_to_table</function> supports the flags described in
     <xref linkend="posix-embedded-options-table"/>.
-->
<function>regexp_split_to_table</function>関数はPOSIX正規表現パターンを区切り文字として使用し、文字列を分割します。<function>regexp_split_to_table</function>(<replaceable>string</replaceable>, <replaceable>pattern</replaceable> <optional>, <replaceable>flags</replaceable> </optional>)の構文になります。
<replaceable>pattern</replaceable>にマッチしない場合、関数は<replaceable>string</replaceable>を返します。
少なくともひとつのマッチがあれば、それぞれのマッチに対して関数は最後のマッチの終わり（あるいは文字列の始め）から最初のマッチまでのテキストを返します。
もはやマッチしなくなると最後のマッチの終わりから文字列の最後までテキストを返します。
<replaceable>flags</replaceable>パラメータは、関数の動作を変更するゼロもしくは複数の単一文字フラグを含むオプションのテキスト文字列です。
<function>regexp_split_to_table</function>は<xref linkend="posix-embedded-options-table"/>で記載されているフラグをサポートします。
    </para>

    <para>
<!--
     The <function>regexp_split_to_array</function> function behaves the same as
     <function>regexp_split_to_table</function>, except that <function>regexp_split_to_array</function>
     returns its result as an array of <type>text</type>.  It has the syntax
     <function>regexp_split_to_array</function>(<replaceable>string</replaceable>, <replaceable>pattern</replaceable>
     <optional>, <replaceable>flags</replaceable> </optional>).
     The parameters are the same as for <function>regexp_split_to_table</function>.
-->
<function>regexp_split_to_array</function>関数は、<function>regexp_split_to_array</function>がその結果を<type>text</type>配列で返すことを除いて、<function>regexp_split_to_table</function>と同じ動作をします。
<function>regexp_split_to_array</function>(<replaceable>string</replaceable>, <replaceable>pattern</replaceable> <optional>, <replaceable>flags</replaceable> </optional>)の構文になります。
パラメータは<function>regexp_split_to_table</function>のものと同じです。
    </para>

   <para>
<!--
    Some examples:
-->
例を示します。
<programlisting>
SELECT foo FROM regexp_split_to_table('the quick brown fox jumps over the lazy dog', '\s+') AS foo;
  foo
-------
 the
 quick
 brown
 fox
 jumps
 over
 the
 lazy
 dog
(9 rows)

SELECT regexp_split_to_array('the quick brown fox jumps over the lazy dog', '\s+');
              regexp_split_to_array
-----------------------------------------------
 {the,quick,brown,fox,jumps,over,the,lazy,dog}
(1 row)

SELECT foo FROM regexp_split_to_table('the quick brown fox', '\s*') AS foo;
 foo
-----
 t
 h
 e
 q
 u
 i
 c
 k
 b
 r
 o
 w
 n
 f
 o
 x
(16 rows)
</programlisting>
   </para>

   <para>
<!--
    As the last example demonstrates, the regexp split functions ignore
    zero-length matches that occur at the start or end of the string
    or immediately after a previous match.  This is contrary to the strict
    definition of regexp matching that is implemented by
    the other regexp functions, but is usually the most convenient behavior
    in practice.  Other software systems such as Perl use similar definitions.
-->
最後の例が明らかにしているように、regexp分割関数は文字列の最初あるいは終わり、もしくは前のマッチの直後に発生する長さを持たないマッチを無視します。
他の正規表現関数で実装されたregexpマッチの厳格な定義にこれは相容れませんが、実務上は最も使い勝手の良い動作です。
Perlのような他のソフトウェアシステムも似たような定義を使用します。
   </para>

    <para>
<!--
     The <function>regexp_substr</function> function returns the substring
     that matches a POSIX regular expression pattern,
     or <literal>NULL</literal> if there is no match.  It has the syntax
     <function>regexp_substr</function>(<replaceable>string</replaceable>,
     <replaceable>pattern</replaceable>
     <optional>, <replaceable>start</replaceable>
     <optional>, <replaceable>N</replaceable>
     <optional>, <replaceable>flags</replaceable>
     <optional>, <replaceable>subexpr</replaceable>
     </optional></optional></optional></optional>).
     <replaceable>pattern</replaceable> is searched for
     in <replaceable>string</replaceable>, normally from the beginning of
     the string, but if the <replaceable>start</replaceable> parameter is
     provided then beginning from that character index.
     If <replaceable>N</replaceable> is specified
     then the <replaceable>N</replaceable>'th match of the pattern
     is returned, otherwise the first match is returned.
     The <replaceable>flags</replaceable> parameter is an optional text
     string containing zero or more single-letter flags that change the
     function's behavior.  Supported flags are described
     in <xref linkend="posix-embedded-options-table"/>.
     For a pattern containing parenthesized
     subexpressions, <replaceable>subexpr</replaceable> is an integer
     indicating which subexpression is of interest: the result is the
     substring matching that subexpression.
     Subexpressions are numbered in the order of their leading parentheses.
     When <replaceable>subexpr</replaceable> is omitted or zero, the result
     is the whole match regardless of parenthesized subexpressions.
-->
<function>regexp_substr</function>関数は、POSIX正規表現パターンと一致する部分文字列を返します。
一致しない場合は<literal>NULL</literal>を返します。
<function>regexp_substr</function><replaceable>string</replaceable>,<replaceable>pattern</replaceable><optional>,<replaceable>start</replaceable><optional>,<replaceable>N</replaceable><optional>,<replaceable>flags</replaceable><optional>,<replaceable>subexpr</replaceable></optional></optional></optional></optional>)の構文となっています。
<replaceable>pattern</replaceable>は<replaceable>string</replaceable>内で検索されます。通常は文字列の先頭から検索されますが、<replaceable>start</replaceable>パラメータが指定されている場合は、その文字インデックスから検索が開始されます。
<replaceable>N</replaceable>が指定されている場合は、パターンの<replaceable>N</replaceable>番目に一致するものが返されます。
指定されていない場合は、最初に一致するものが返されます。
<replaceable>flags</replaceable>パラメータは、関数の動作を変更する0個以上の単一文字フラグを含むオプションのテキスト文字列です。
サポートされているフラグは<xref linkend="posix-embedded-options-table"/>で説明されています。
カッコで囲まれた部分式を含むパターンの場合、<replaceable>subexpr</replaceable>は対象となる部分式を示す整数です。
結果はその部分式に一致する部分文字列になります。
部分式には、先頭のカッコの順に番号が付けられます。
<replaceable>subexpr</replaceable>が省略されているか0の場合、結果はカッコで囲まれた部分式に関係なく全体に一致します。
    </para>

    <para>
<!--
     Some examples:
-->
例：
<programlisting>
regexp_substr('number of your street, town zip, FR', '[^,]+', 1, 2)
                                   <lineannotation> town zip</lineannotation>
regexp_substr('ABCDEFGHI', '(c..)(...)', 1, 1, 'i', 2)
                                   <lineannotation>FGH</lineannotation>
</programlisting>
    </para>

<!-- derived from the re_syntax.n man page -->

   <sect3 id="posix-syntax-details">
<!--
    <title>Regular Expression Details</title>
-->
    <title>正規表現の詳細</title>

   <para>
<!--
    <productname>PostgreSQL</productname>'s regular expressions are implemented
    using a software package written by Henry Spencer.  Much of
    the description of regular expressions below is copied verbatim from his
    manual.
-->
<productname>PostgreSQL</productname>の正規表現はHenry Spencerにより書かれたソフトウェアパッケージを使用して実装されています。
以下に説明する正規表現の多くの部分は同氏のマニュアルから一字一句複製したものです。
   </para>

   <para>
<!--
    Regular expressions (<acronym>RE</acronym>s), as defined in
    <acronym>POSIX</acronym> 1003.2, come in two forms:
    <firstterm>extended</firstterm> <acronym>RE</acronym>s or <acronym>ERE</acronym>s
    (roughly those of <command>egrep</command>), and
    <firstterm>basic</firstterm> <acronym>RE</acronym>s or <acronym>BRE</acronym>s
    (roughly those of <command>ed</command>).
    <productname>PostgreSQL</productname> supports both forms, and
    also implements some extensions
    that are not in the POSIX standard, but have become widely used
    due to their availability in programming languages such as Perl and Tcl.
    <acronym>RE</acronym>s using these non-POSIX extensions are called
    <firstterm>advanced</firstterm> <acronym>RE</acronym>s or <acronym>ARE</acronym>s
    in this documentation.  AREs are almost an exact superset of EREs,
    but BREs have several notational incompatibilities (as well as being
    much more limited).
    We first describe the ARE and ERE forms, noting features that apply
    only to AREs, and then describe how BREs differ.
-->
<acronym>POSIX</acronym> 1003.2の定義によると、正規表現（<acronym>RE</acronym>）には2つの形式があるとされます。<firstterm>拡張</firstterm><acronym>RE</acronym>もしくは<acronym>ERE</acronym>（大まかにいって<command>egrep</command>に代表されるもの）、および<firstterm>基本</firstterm><acronym>RE</acronym>もしくは<acronym>BRE</acronym>（大まかにいって<command>ed</command>に代表されるもの）です。
<productname>PostgreSQL</productname>は両方の形式をサポートし、さらに、POSIX標準にはないけれどもPerlやTclなどのプログラミング言語で利用できることから広く使用されるようになった、いくつかの拡張もサポートしています。
本書では、非POSIX拡張を使用した<acronym>RE</acronym>を<firstterm>高度な</firstterm><acronym>RE</acronym>もしくは<acronym>ARE</acronym>と呼びます。AREはEREの正確な上位セットですが、BREとは複数の記法上の非互換な点があります（さらに非常に多くの制限が課されています）。
まず、AREとERE形式について説明し、そして、AREにのみ適用される機能の注意を、さらにBREとの違いについて説明します。
   </para>

   <note>
    <para>
<!--
     <productname>PostgreSQL</productname> always initially presumes that a regular
     expression follows the ARE rules.  However, the more limited ERE or
     BRE rules can be chosen by prepending an <firstterm>embedded option</firstterm>
     to the RE pattern, as described in <xref linkend="posix-metasyntax"/>.
     This can be useful for compatibility with applications that expect
     exactly the <acronym>POSIX</acronym> 1003.2 rules.
-->
<productname>PostgreSQL</productname>は常に、まず正規表現はARE規則に従うと推測します。
しかし、REパターンの前に、<xref linkend="posix-metasyntax"/>に記載されているような<firstterm>埋め込みオプション</firstterm>を追加することにより、より限られたERE、あるいはBRE規則を選択することができます。
これは、<acronym>POSIX</acronym>1003.2の規則を正確に期待しているアプリケーションとの互換性に関して有用です。
    </para>
   </note>

   <para>
<!--
    A regular expression is defined as one or more
    <firstterm>branches</firstterm>, separated by
    <literal>|</literal>.  It matches anything that matches one of the
    branches.
-->
正規表現は<literal>|</literal>で区切られた、1つまたは複数の<firstterm>ブランチ</firstterm>として定義されます。
ブランチのいずれか1つにマッチすればマッチしたことになります。
   </para>

   <para>
<!--
    A branch is zero or more <firstterm>quantified atoms</firstterm> or
    <firstterm>constraints</firstterm>, concatenated.
    It matches a match for the first, followed by a match for the second, etc.;
    an empty branch matches the empty string.
-->
ブランチはゼロ個以上の<firstterm>量化アトム</firstterm>もしくは<firstterm>制約</firstterm>の連結です。
最初のものにマッチに、次に第２番目のものにマッチを、というふうにマッチします。なお、空のブランチは空文字列にマッチします。
   </para>

   <para>
<!--
    A quantified atom is an <firstterm>atom</firstterm> possibly followed
    by a single <firstterm>quantifier</firstterm>.
    Without a quantifier, it matches a match for the atom.
    With a quantifier, it can match some number of matches of the atom.
    An <firstterm>atom</firstterm> can be any of the possibilities
    shown in <xref linkend="posix-atoms-table"/>.
    The possible quantifiers and their meanings are shown in
    <xref linkend="posix-quantifiers-table"/>.
-->
量化アトムとは、単一の<firstterm>量指定子</firstterm>が後ろに付く<firstterm>アトム</firstterm>のことです。
量指定子がないと、アトムにマッチするものがマッチしたことになります。
量指定子がある場合、アトムとのマッチが何回あるかでマッチしたことになります。
<firstterm>アトム</firstterm>は、<xref linkend="posix-atoms-table"/>に示したもののいずれかを取ることができます。
  <xref linkend="posix-quantifiers-table"/>に設定可能な量指定子とその意味を示します。
   </para>

   <para>
<!--
    A <firstterm>constraint</firstterm> matches an empty string, but matches only when
    specific conditions are met.  A constraint can be used where an atom
    could be used, except it cannot be followed by a quantifier.
    The simple constraints are shown in
    <xref linkend="posix-constraints-table"/>;
    some more constraints are described later.
-->
<firstterm>制約</firstterm>は空文字に、特定の条件に合う場合のみにマッチします。
アトムを使用できるところには制約を使用することができます。ただしその後に量指定子を付けることはできません。
単純な制約を<xref linkend="posix-constraints-table"/>に示します。後で他のいくつかの制約を説明します。
   </para>


   <table id="posix-atoms-table">
<!--
    <title>Regular Expression Atoms</title>
-->
    <title>正規表現のアトム</title>

    <tgroup cols="2">
     <thead>
      <row>
<!--
       <entry>Atom</entry>
-->
       <entry>アトム</entry>
<!--
       <entry>Description</entry>
-->
       <entry>説明</entry>
      </row>
     </thead>

      <tbody>
       <row>
       <entry> <literal>(</literal><replaceable>re</replaceable><literal>)</literal> </entry>
<!--
       <entry> (where <replaceable>re</replaceable> is any regular expression)
       matches a match for
       <replaceable>re</replaceable>, with the match noted for possible reporting </entry>
-->
       <entry>（ここで<replaceable>re</replaceable> は任意の正規表現で、）<replaceable>re</replaceable>とのマッチに適合するもです。 マッチは可能である報告用と意味づけられます。</entry>
       </row>

       <row>
       <entry> <literal>(?:</literal><replaceable>re</replaceable><literal>)</literal> </entry>
<!--
       <entry> as above, but the match is not noted for reporting
       (a <quote>non-capturing</quote> set of parentheses)
       (AREs only) </entry>
-->
       <entry>上と同じ。ただし、マッチは報告用と意味づけられません。（<quote>捕捉されない</quote>括弧の集合）（AREのみ）</entry>
       </row>

       <row>
       <entry> <literal>.</literal> </entry>
<!--
       <entry> matches any single character </entry>
-->
       <entry>任意の1文字にマッチします。</entry>
       </row>

       <row>
       <entry> <literal>[</literal><replaceable>chars</replaceable><literal>]</literal> </entry>
<!--
       <entry> a <firstterm>bracket expression</firstterm>,
       matching any one of the <replaceable>chars</replaceable> (see
       <xref linkend="posix-bracket-expressions"/> for more detail) </entry>
-->
       <entry>
        <firstterm>ブラケット式</firstterm>。
        <replaceable>chars</replaceable>のいずれか1つにマッチします
       （詳細は<xref linkend="posix-bracket-expressions"/>を参照してください）。
       </entry>
       </row>

       <row>
       <entry> <literal>\</literal><replaceable>k</replaceable> </entry>
<!--
       <entry> (where <replaceable>k</replaceable> is a non-alphanumeric character)
       matches that character taken as an ordinary character,
       e.g., <literal>\\</literal> matches a backslash character </entry>
-->
       <entry>（ここで<replaceable>k</replaceable>は英数字以外です。）普通の文字として指定した文字にマッチします。例えば、<literal>\\</literal>はバックスラッシュ文字です。</entry>
       </row>

       <row>
       <entry> <literal>\</literal><replaceable>c</replaceable> </entry>
<!--
       <entry> where <replaceable>c</replaceable> is alphanumeric
       (possibly followed by other characters)
       is an <firstterm>escape</firstterm>, see <xref linkend="posix-escape-sequences"/>
       (AREs only; in EREs and BREs, this matches <replaceable>c</replaceable>) </entry>
-->
       <entry>ここで<replaceable>c</replaceable>は英数字です
       （おそらく他の文字が後に続きます）。
       <firstterm>エスケープ</firstterm>です。
       <xref linkend="posix-escape-sequences"/>を参照してください
       （AREのみ、EREとBREではこれは<replaceable>c</replaceable>にマッチします）。
       </entry>
       </row>

       <row>
       <entry> <literal>{</literal> </entry>
<!--
       <entry> when followed by a character other than a digit,
       matches the left-brace character <literal>{</literal>;
       when followed by a digit, it is the beginning of a
       <replaceable>bound</replaceable> (see below) </entry>
-->
       <entry>直後に数字以外がある場合、左中括弧<literal>{</literal>にマッチします。
直後に数字が続く場合、<replaceable>バウンド</replaceable>（後述）の始まりです。</entry>
       </row>

       <row>
       <entry> <replaceable>x</replaceable> </entry>
<!--
       <entry> where <replaceable>x</replaceable> is a single character with no other
       significance, matches that character </entry>
-->
       <entry>ここで<replaceable>x</replaceable>は他に意味を持たない1文字です。
<replaceable>x</replaceable>にマッチします。</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
<!--
    An RE cannot end with a backslash (<literal>\</literal>).
-->
REはバックスラッシュ<literal>\</literal>を終端とすることはできません。
   </para>

   <note>
    <para>
<!--
     If you have <xref linkend="guc-standard-conforming-strings"/> turned off,
     any backslashes you write in literal string constants will need to be
     doubled.  See <xref linkend="sql-syntax-strings"/> for more information.
-->
もし<xref linkend="guc-standard-conforming-strings"/>パラメータをoffにしていた場合、リテラル文字列定数に記述するバックスラッシュは2倍必要となります。
  詳細は<xref linkend="sql-syntax-strings"/>を参照してください。
    </para>
   </note>

   <table id="posix-quantifiers-table">
<!--
    <title>Regular Expression Quantifiers</title>
-->
    <title>正規表現量指定子</title>

    <tgroup cols="2">
     <thead>
      <row>
<!--
       <entry>Quantifier</entry>
-->
       <entry>量指定子</entry>
<!--
       <entry>Matches</entry>
-->
       <entry>マッチ</entry>
      </row>
     </thead>

      <tbody>
       <row>
       <entry> <literal>*</literal> </entry>
<!--
       <entry> a sequence of 0 or more matches of the atom </entry>
-->
       <entry>アトムの0個以上複数の並びにマッチ</entry>
       </row>

       <row>
       <entry> <literal>+</literal> </entry>
<!--
       <entry> a sequence of 1 or more matches of the atom </entry>
-->
       <entry>アトムの1個以上複数の並びにマッチ</entry>
       </row>

       <row>
       <entry> <literal>?</literal> </entry>
<!--
       <entry> a sequence of 0 or 1 matches of the atom </entry>
-->
       <entry>アトムの0個または1個の並びにマッチ</entry>
       </row>

       <row>
       <entry> <literal>{</literal><replaceable>m</replaceable><literal>}</literal> </entry>
<!--
       <entry> a sequence of exactly <replaceable>m</replaceable> matches of the atom </entry>
-->
       <entry>アトムの正確に<replaceable>m</replaceable>個の並びにマッチ</entry>
       </row>

       <row>
       <entry> <literal>{</literal><replaceable>m</replaceable><literal>,}</literal> </entry>
<!--
       <entry> a sequence of <replaceable>m</replaceable> or more matches of the atom </entry>
-->
       <entry>アトムの<replaceable>m</replaceable>個以上の並びにマッチ</entry>
       </row>

       <row>
       <entry>
       <literal>{</literal><replaceable>m</replaceable><literal>,</literal><replaceable>n</replaceable><literal>}</literal> </entry>
<!--
       <entry> a sequence of <replaceable>m</replaceable> through <replaceable>n</replaceable>
       (inclusive) matches of the atom; <replaceable>m</replaceable> cannot exceed
       <replaceable>n</replaceable> </entry>
-->
       <entry> アトムの<replaceable>m</replaceable>個以上<replaceable>n</replaceable>以下の並びにマッチ。
<replaceable>m</replaceable>は<replaceable>n</replaceable>を超えることはできません。</entry>
       </row>

       <row>
       <entry> <literal>*?</literal> </entry>
<!--
       <entry> non-greedy version of <literal>*</literal> </entry>
-->
       <entry><literal>*</literal>の最短マッチを行うバージョン</entry>
       </row>

       <row>
       <entry> <literal>+?</literal> </entry>
<!--
       <entry> non-greedy version of <literal>+</literal> </entry>
-->
       <entry><literal>+</literal>の最短マッチを行うバージョン</entry>
       </row>

       <row>
       <entry> <literal>??</literal> </entry>
<!--
       <entry> non-greedy version of <literal>?</literal> </entry>
-->
       <entry><literal>?</literal>の最短マッチを行うバージョン</entry>
       </row>

       <row>
       <entry> <literal>{</literal><replaceable>m</replaceable><literal>}?</literal> </entry>
<!--
       <entry> non-greedy version of <literal>{</literal><replaceable>m</replaceable><literal>}</literal> </entry>
-->
       <entry><literal>{</literal><replaceable>m</replaceable><literal>}</literal>の最短マッチを行うバージョン</entry>
       </row>

       <row>
       <entry> <literal>{</literal><replaceable>m</replaceable><literal>,}?</literal> </entry>
<!--
       <entry> non-greedy version of <literal>{</literal><replaceable>m</replaceable><literal>,}</literal> </entry>
-->
       <entry><literal>{</literal><replaceable>m</replaceable><literal>,}</literal>の最短マッチを行うバージョン</entry>
       </row>

       <row>
       <entry>
       <literal>{</literal><replaceable>m</replaceable><literal>,</literal><replaceable>n</replaceable><literal>}?</literal> </entry>
<!--
       <entry> non-greedy version of <literal>{</literal><replaceable>m</replaceable><literal>,</literal><replaceable>n</replaceable><literal>}</literal> </entry>
-->
       <entry><literal>{</literal><replaceable>m</replaceable><literal>,</literal><replaceable>n</replaceable><literal>}</literal>の最短マッチを行うバージョン</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
<!--
    The forms using <literal>{</literal><replaceable>...</replaceable><literal>}</literal>
    are known as <firstterm>bounds</firstterm>.
    The numbers <replaceable>m</replaceable> and <replaceable>n</replaceable> within a bound are
    unsigned decimal integers with permissible values from 0 to 255 inclusive.
-->
<literal>{</literal><replaceable>...</replaceable><literal>}</literal>を使用する形式は<firstterm>バウンド</firstterm>として知られています。
バウンド内の<replaceable>m</replaceable>と<replaceable>n</replaceable>という数は符号なし10進整数であり、0以上255以下の値を取ることができます。
   </para>

    <para>
<!--
     <firstterm>Non-greedy</firstterm> quantifiers (available in AREs only) match the
     same possibilities as their corresponding normal (<firstterm>greedy</firstterm>)
     counterparts, but prefer the smallest number rather than the largest
     number of matches.
     See <xref linkend="posix-matching-rules"/> for more detail.
-->
<firstterm>最短マッチを行う</firstterm>量指定子（AREのみで使用可能）は、対応する通常の（<firstterm>欲張りの</firstterm>）ものと同じものにマッチしますが、最大のマッチではなく最小のマッチを取ります。
詳細は<xref linkend="posix-matching-rules"/>を参照してください。
   </para>

   <note>
    <para>
<!--
     A quantifier cannot immediately follow another quantifier, e.g.,
     <literal>**</literal> is invalid.
     A quantifier cannot
     begin an expression or subexpression or follow
     <literal>^</literal> or <literal>|</literal>.
-->
量指定子の直後に量指定子を続けることはできません。例えば<literal>**</literal>は無効です。
量指定子から式や副式を始めることはできず、また、<literal>^</literal>や<literal>|</literal>の直後に付けることもできません。
    </para>
   </note>

   <table id="posix-constraints-table">
<!--
    <title>Regular Expression Constraints</title>
-->
    <title>正規表現制約</title>

    <tgroup cols="2">
     <thead>
      <row>
<!--
       <entry>Constraint</entry>
-->
       <entry>制約</entry>
<!--
       <entry>Description</entry>
-->
       <entry>説明</entry>
      </row>
     </thead>

      <tbody>
       <row>
       <entry> <literal>^</literal> </entry>
<!--
       <entry> matches at the beginning of the string </entry>
-->
       <entry>文字列の先頭にマッチ</entry>
       </row>

       <row>
       <entry> <literal>$</literal> </entry>
<!--
       <entry> matches at the end of the string </entry>
-->
       <entry>文字列の末尾にマッチ</entry>
       </row>

       <row>
       <entry> <literal>(?=</literal><replaceable>re</replaceable><literal>)</literal> </entry>
<!--
       <entry> <firstterm>positive lookahead</firstterm> matches at any point
       where a substring matching <replaceable>re</replaceable> begins
       (AREs only) </entry>
-->
       <entry><firstterm>先行肯定検索</firstterm>は、<replaceable>re</replaceable>にマッチする部分文字列が始まる任意の場所にマッチします（AREのみ）。</entry>
       </row>

       <row>
       <entry> <literal>(?!</literal><replaceable>re</replaceable><literal>)</literal> </entry>
<!--
       <entry> <firstterm>negative lookahead</firstterm> matches at any point
       where no substring matching <replaceable>re</replaceable> begins
       (AREs only) </entry>
-->
       <entry><firstterm>先行否定検索</firstterm>は、<replaceable>re</replaceable>にマッチしない部分文字列が始まる任意の場所にマッチします（AREのみ）。</entry>
       </row>

       <row>
       <entry> <literal>(?&lt;=</literal><replaceable>re</replaceable><literal>)</literal> </entry>
<!--
       <entry> <firstterm>positive lookbehind</firstterm> matches at any point
       where a substring matching <replaceable>re</replaceable> ends
       (AREs only) </entry>
-->
       <entry> <firstterm>後方肯定検索</firstterm>は<replaceable>re</replaceable>にマッチする部分文字列が終わる任意の場所にマッチします（AREのみ）。</entry>
       </row>

       <row>
       <entry> <literal>(?&lt;!</literal><replaceable>re</replaceable><literal>)</literal> </entry>
<!--
       <entry> <firstterm>negative lookbehind</firstterm> matches at any point
       where no substring matching <replaceable>re</replaceable> ends
       (AREs only) </entry>
-->
       <entry> <firstterm>後方否定検索</firstterm><replaceable>re</replaceable>にマッチしない部分文字列が終わる任意の場所にマッチします（AREのみ）。</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
<!--
    Lookahead and lookbehind constraints cannot contain <firstterm>back
    references</firstterm> (see <xref linkend="posix-escape-sequences"/>),
    and all parentheses within them are considered non-capturing.
-->
先行検索制約および後方検索制約には<firstterm>後方参照</firstterm>（<xref linkend="posix-escape-sequences"/>を参照）を含めることはできません。また、その中の括弧は全て取り込むものではないとみなされます。
   </para>
   </sect3>

   <sect3 id="posix-bracket-expressions">
<!--
    <title>Bracket Expressions</title>
-->
    <title>ブラケット式</title>

   <para>
<!--
    A <firstterm>bracket expression</firstterm> is a list of
    characters enclosed in <literal>[]</literal>.  It normally matches
    any single character from the list (but see below).  If the list
    begins with <literal>^</literal>, it matches any single character
    <emphasis>not</emphasis> from the rest of the list.
    If two characters
    in the list are separated by <literal>-</literal>, this is
    shorthand for the full range of characters between those two
    (inclusive) in the collating sequence,
    e.g., <literal>[0-9]</literal> in <acronym>ASCII</acronym> matches
    any decimal digit.  It is illegal for two ranges to share an
    endpoint, e.g.,  <literal>a-c-e</literal>.  Ranges are very
    collating-sequence-dependent, so portable programs should avoid
    relying on them.
-->
<firstterm>ブラケット式</firstterm>とは、<literal>[]</literal>内の文字のリストです。
通常これはそのリスト内の任意の1文字にマッチします（しかし、以降を参照してください）。
リストが<literal>^</literal>から始まる場合、そのリストの残りには<emphasis>ない</emphasis>任意の1文字にマッチします。
リスト内の2文字が<literal>-</literal>で区切られていた場合、これは2つ（を含む）の間にある文字範囲全体を表す省略形となります。例えば、<acronym>ASCII</acronym>における<literal>[0-9]</literal>は全ての数字にマッチします。
例えば<literal>a-c-e</literal>といった、終端を共有する2つの範囲は不正です。
範囲は並びの照合順に非常に依存しています。ですので、移植予定のプログラムではこれに依存してはなりません。
   </para>

   <para>
<!--
    To include a literal <literal>]</literal> in the list, make it the
    first character (after <literal>^</literal>, if that is used).  To
    include a literal <literal>-</literal>, make it the first or last
    character, or the second endpoint of a range.  To use a literal
    <literal>-</literal> as the first endpoint of a range, enclose it
    in <literal>[.</literal> and <literal>.]</literal> to make it a
    collating element (see below).  With the exception of these characters,
    some combinations using <literal>[</literal>
    (see next paragraphs), and escapes (AREs only), all other special
    characters lose their special significance within a bracket expression.
    In particular, <literal>\</literal> is not special when following
    ERE or BRE rules, though it is special (as introducing an escape)
    in AREs.
-->
このリストに<literal>]</literal>そのものを含めるには、それを先頭文字（もしそれが使用されれば<literal>^</literal>の後）にしてください。
<literal>-</literal>そのものを含めるには、それを先頭もしくは末尾の文字とするか、範囲の2番目の終端としてください。
<literal>-</literal>を範囲の最初の終端で使用するには、<literal>[.</literal>と<literal>.]</literal>でそれを囲み、照合要素（後述）にしてください。
これら文字と、<literal>[</literal>（次段落を参照）のなんらかの組み合わせ、およびエスケープ（AREのみ）を例外として、他の全ての特殊文字はブラケット式内では特殊な意味を持ちません。
特に、<literal>\</literal>はEREとBRE規則に従う場合は特別でなくなります。しかし、AREでは（エスケープの始まりとして）特別な意味を持ちます。
   </para>

   <para>
<!--
    Within a bracket expression, a collating element (a character, a
    multiple-character sequence that collates as if it were a single
    character, or a collating-sequence name for either) enclosed in
    <literal>[.</literal> and <literal>.]</literal> stands for the
    sequence of characters of that collating element.  The sequence is
    treated as a single element of the bracket expression's list.  This
    allows a bracket
    expression containing a multiple-character collating element to
    match more than one character, e.g., if the collating sequence
    includes a <literal>ch</literal> collating element, then the RE
    <literal>[[.ch.]]*c</literal> matches the first five characters of
    <literal>chchcc</literal>.
-->
ブラケット式内に、照合要素（文字、単一文字であるかのように照合する複数文字の並び、もしくはそれぞれの照合並びの名前）が<literal>[.</literal>と<literal>.]</literal>の間にあると、その照合要素の文字の並びを意味します。
この並びはブラケット式のリストの一要素として取り扱われます。
このことにより、ブラケット式は要素を照合する複数文字を含むブラケット式を1文字以上にマッチさせることができます。例えば、照合並びが<literal>ch</literal>照合要素を含む場合、正規表現<literal>[[.ch.]]*c</literal>は<literal>chchcc</literal>という文字の最初の5文字にマッチします。
   </para>

   <note>
    <para>
<!--
     <productname>PostgreSQL</productname> currently does not support multi-character collating
     elements. This information describes possible future behavior.
-->
今のところ、<productname>PostgreSQL</productname>は複数文字照合要素をサポートしません。
この情報は将来の振舞いの可能性を説明したものです。
    </para>
   </note>

   <para>
<!--
    Within a bracket expression, a collating element enclosed in
    <literal>[=</literal> and <literal>=]</literal> is an <firstterm>equivalence
    class</firstterm>, standing for the sequences of characters of all collating
    elements equivalent to that one, including itself.  (If there are
    no other equivalent collating elements, the treatment is as if the
    enclosing delimiters were <literal>[.</literal> and
    <literal>.]</literal>.)  For example, if <literal>o</literal> and
    <literal>^</literal> are the members of an equivalence class, then
    <literal>[[=o=]]</literal>, <literal>[[=^=]]</literal>, and
    <literal>[o^]</literal> are all synonymous.  An equivalence class
    cannot be an endpoint of a range.
-->
ブラケット式内の<literal>[=</literal>と<literal>=]</literal>の間に照合要素は<firstterm>同値クラス</firstterm>です。全ての照合要素の文字の並びが自身を含むものと等価であることを示します。
（他に等価な照合要素がある場合、<literal>[.</literal>と<literal>.]</literal>で囲まれたかのように扱われます。）
例えば、<literal>[[=o=]]</literal>、<literal>[[=^=]]</literal>および<literal>[o^]</literal>が全て同意語であれば、<literal>o</literal>と<literal>^</literal>は同値クラスのメンバです。
同値クラスは範囲の終端にはなりません。
   </para>

   <para>
<!--
    Within a bracket expression, the name of a character class
    enclosed in <literal>[:</literal> and <literal>:]</literal> stands
    for the list of all characters belonging to that class.  A character
    class cannot be used as an endpoint of a range.
    The <acronym>POSIX</acronym> standard defines these character class
    names:
    <literal>alnum</literal> (letters and numeric digits),
    <literal>alpha</literal> (letters),
    <literal>blank</literal> (space and tab),
    <literal>cntrl</literal> (control characters),
    <literal>digit</literal> (numeric digits),
    <literal>graph</literal> (printable characters except space),
    <literal>lower</literal> (lower-case letters),
    <literal>print</literal> (printable characters including space),
    <literal>punct</literal> (punctuation),
    <literal>space</literal> (any white space),
    <literal>upper</literal> (upper-case letters),
    and <literal>xdigit</literal> (hexadecimal digits).
    The behavior of these standard character classes is generally
    consistent across platforms for characters in the 7-bit ASCII set.
    Whether a given non-ASCII character is considered to belong to one
    of these classes depends on the <firstterm>collation</firstterm>
    that is used for the regular-expression function or operator
    (see <xref linkend="collation"/>), or by default on the
    database's <envar>LC_CTYPE</envar> locale setting (see
    <xref linkend="locale"/>).  The classification of non-ASCII
    characters can vary across platforms even in similarly-named
    locales.  (But the <literal>C</literal> locale never considers any
    non-ASCII characters to belong to any of these classes.)
    In addition to these standard character
    classes, <productname>PostgreSQL</productname> defines
    the <literal>word</literal> character class, which is the same as
    <literal>alnum</literal> plus the underscore (<literal>_</literal>)
    character, and
    the <literal>ascii</literal> character class, which contains exactly
    the 7-bit ASCII set.
-->
ブラケット式内では、<literal>[:</literal>と<literal>:]</literal>の間にある文字クラスの名称は、そのクラスに属する全ての文字のリストを意味します。
文字クラスは範囲の終端位置としては使用できません。
<acronym>POSIX</acronym>標準は以下の文字クラス名を定義しています。
<literal>alnum</literal>（文字と数字）、<literal>alpha</literal>（文字）、<literal>blank</literal>（空白とタブ）、<literal>cntrl</literal>（制御文字）、<literal>digit</literal>（数字）、<literal>graph</literal>（空白以外の印字可能文字）、<literal>lower</literal>（小文字）、<literal>print</literal>（空白を含む印字可能文字）、<literal>punct</literal>（句読点）、<literal>space</literal>（空白）、<literal>upper</literal>（大文字）、<literal>xdigit</literal>（16進数）です。
これらの標準文字クラスの振る舞いは7-bit ASCII集合の範囲であれば一般にどのプラットフォームでも同じです。
与えられた非ASCII文字がこれらの文字クラスに属すると考えられるかどうかは、正規表現関数または演算子（<xref linkend="collation"/>参照）で使用される<firstterm>照合順</firstterm>、あるいはデフォルトとしてはデータベースの<envar>LC_CTYPE</envar>ロケール（<xref linkend="locale"/>）の設定によります。
非ASCII文字の分類は、たとえ似たような名前のロケールであってもプラットフォームによって異なることがありえます。
（ただし<literal>C</literal>ロケールでは、すべての非ASCII文字はこれらのクラスのどれにも所属しないものとされます。）
これらの標準クラスに加え、<productname>PostgreSQL</productname>では<literal>alnum</literal>と同様だがアンダースコア(<literal>_</literal>)文字を加えた<literal>word</literal>文字クラス、そして7-bit ASCII集合を正確に含む<literal>ascii</literal>文字クラスが定義されています。
   </para>

   <para>
<!--
    There are two special cases of bracket expressions:  the bracket
    expressions <literal>[[:&lt;:]]</literal> and
    <literal>[[:&gt;:]]</literal> are constraints,
    matching empty strings at the beginning
    and end of a word respectively.  A word is defined as a sequence
    of word characters that is neither preceded nor followed by word
    characters.  A word character is any character belonging to the
    <literal>word</literal> character class, that is, any letter, digit,
    or underscore.  This is an extension, compatible with but not
    specified by <acronym>POSIX</acronym> 1003.2, and should be used with
    caution in software intended to be portable to other systems.
    The constraint escapes described below are usually preferable; they
    are no more standard, but are easier to type.
-->
ブラケット式には2つの特殊な場合があります。<literal>[[:&lt;:]]</literal>と<literal>[[:&gt;:]]</literal>というブラケット式は、先頭と終端の単語がそれぞれ空文字であることにマッチする制約です。
単語は、単語文字が前後に付かない単語文字の並びとして定義されます。
単語文字とは<literal>word</literal>文字クラスに所属するすべての文字、すなわちすべての文字、数字、アンダースコアです。
これは、<acronym>POSIX</acronym> 1003.2との互換性はありますが、そこでは定義されていない式です。ですので、他システムへ移植予定のソフトウェアでの使用には注意が必要です。
通常後述の制約エスケープの方がよく使われます。これはもはや標準ではありませんが、入力しやすいものです。
   </para>
   </sect3>

   <sect3 id="posix-escape-sequences">
<!--
    <title>Regular Expression Escapes</title>
-->
    <title>正規表現エスケープ</title>

   <para>
<!--
    <firstterm>Escapes</firstterm> are special sequences beginning with <literal>\</literal>
    followed by an alphanumeric character. Escapes come in several varieties:
    character entry, class shorthands, constraint escapes, and back references.
    A <literal>\</literal> followed by an alphanumeric character but not constituting
    a valid escape is illegal in AREs.
    In EREs, there are no escapes: outside a bracket expression,
    a <literal>\</literal> followed by an alphanumeric character merely stands for
    that character as an ordinary character, and inside a bracket expression,
    <literal>\</literal> is an ordinary character.
    (The latter is the one actual incompatibility between EREs and AREs.)
-->
<firstterm>エスケープ</firstterm>とは、<literal>\</literal>から始まり英数字がその後に続く特殊な並びです。
エスケープには、文字エントリ、クラス省略、制約エスケープ、後方参照といった様々な変種があります。
<literal>\</literal>の後に英数字が続くけれども、有効なエスケープを構成しない並びはAREでは不正です。
EREにはエスケープはありません。ブラケット式の外側では、<literal>\</literal>の後に英数字が続く並びは単に普通の文字としてその文字を意味します。ブラケット式の内側では、<literal>\</literal>は普通の文字です。
（後者はEREとARE間の非互換性の1つです。）
   </para>

   <para>
<!--
    <firstterm>Character-entry escapes</firstterm> exist to make it easier to specify
    non-printing and other inconvenient characters in REs.  They are
    shown in <xref linkend="posix-character-entry-escapes-table"/>.
-->
<firstterm>文字エントリエスケープ</firstterm>は非印字文字やRE内でその他の不便な文字の指定を簡略化するために存在します。
これらを<xref linkend="posix-character-entry-escapes-table"/>に示します。
   </para>

   <para>
<!--
    <firstterm>Class-shorthand escapes</firstterm> provide shorthands for certain
    commonly-used character classes.  They are
    shown in <xref linkend="posix-class-shorthand-escapes-table"/>.
-->
<firstterm>クラス省略エスケープ</firstterm>は、あるよく使用される文字クラスの省略形を提供します。
これらを<xref linkend="posix-class-shorthand-escapes-table"/>に示します。
   </para>

   <para>
<!--
    A <firstterm>constraint escape</firstterm> is a constraint,
    matching the empty string if specific conditions are met,
    written as an escape.  They are
    shown in <xref linkend="posix-constraint-escapes-table"/>.
-->
<firstterm>制約エスケープ</firstterm>は、指定した条件に合う場合に空文字にマッチする制約をエスケープとして表したものです。
これらを<xref linkend="posix-constraint-escapes-table"/>に示します。
   </para>

   <para>
<!--
    A <firstterm>back reference</firstterm> (<literal>\</literal><replaceable>n</replaceable>) matches the
    same string matched by the previous parenthesized subexpression specified
    by the number <replaceable>n</replaceable>
    (see <xref linkend="posix-constraint-backref-table"/>).  For example,
    <literal>([bc])\1</literal> matches <literal>bb</literal> or <literal>cc</literal>
    but not <literal>bc</literal> or <literal>cb</literal>.
    The subexpression must entirely precede the back reference in the RE.
    Subexpressions are numbered in the order of their leading parentheses.
    Non-capturing parentheses do not define subexpressions.
    The back reference considers only the string characters matched by the
    referenced subexpression, not any constraints contained in it.  For
    example, <literal>(^\d)\1</literal> will match <literal>22</literal>.
-->
<firstterm>後方参照</firstterm>（<literal>\</literal><replaceable>n</replaceable>）は、直前に括弧で囲まれた副式によってマッチされた、<replaceable>n</replaceable>番目の同一文字列にマッチします（<xref linkend="posix-constraint-backref-table"/>を参照してください）。
  例えば、<literal>([bc])\1</literal>は<literal>bb</literal>もしくは<literal>cc</literal>にマッチしますが、<literal>bc</literal>や<literal>cb</literal>にはマッチしません。REでは副式全体は後方参照の前になければなりません。
副式は開括弧の順番で番号付けされます。
取り込まない括弧は副式を定義しません。
後方参照は参照される副式にマッチした文字列のみを考慮し、そこに含まれる制約は考慮しません。
たとえば、<literal>(^\d)\1</literal>は<literal>22</literal>にマッチします。
   </para>

   <table id="posix-character-entry-escapes-table">
<!--
    <title>Regular Expression Character-Entry Escapes</title>
-->
    <title>正規表現文字エントリエスケープ</title>

    <tgroup cols="2">
     <thead>
      <row>
<!--
       <entry>Escape</entry>
-->
       <entry>エスケープ</entry>
<!--
       <entry>Description</entry>
-->
       <entry>説明</entry>
      </row>
     </thead>

      <tbody>
       <row>
       <entry> <literal>\a</literal> </entry>
<!--
       <entry> alert (bell) character, as in C </entry>
-->
       <entry>C言語と同じ警報（ベル）文字</entry>
       </row>

       <row>
       <entry> <literal>\b</literal> </entry>
<!--
       <entry> backspace, as in C </entry>
-->
       <entry>C言語と同じバックスペース</entry>
       </row>

       <row>
       <entry> <literal>\B</literal> </entry>
<!--
       <entry> synonym for backslash (<literal>\</literal>) to help reduce the need for backslash
       doubling </entry>
-->
       <entry> バックスラッシュの必要な二重化回数を減らすためのバックスラッシュ（<literal>\</literal>）の同義語</entry>
       </row>

       <row>
       <entry> <literal>\c</literal><replaceable>X</replaceable> </entry>
<!--
       <entry> (where <replaceable>X</replaceable> is any character) the character whose
       low-order 5 bits are the same as those of
       <replaceable>X</replaceable>, and whose other bits are all zero </entry>
-->
       <entry>（ここで<replaceable>X</replaceable>は任意の文字で）その下位5ビットが<replaceable>X</replaceable>と同一、その他のビットが0となる文字 </entry>
       </row>

       <row>
       <entry> <literal>\e</literal> </entry>
<!--
       <entry> the character whose collating-sequence name
       is <literal>ESC</literal>,
       or failing that, the character with octal value <literal>033</literal> </entry>
-->
       <entry>照合順名が<literal>ESC</literal>となる文字、それに失敗したら、<literal>033</literal>という8進数値を持つ文字。</entry>
       </row>

       <row>
       <entry> <literal>\f</literal> </entry>
<!--
       <entry> form feed, as in C </entry>
-->
       <entry>C言語と同じ改ページ</entry>
       </row>

       <row>
       <entry> <literal>\n</literal> </entry>
<!--
       <entry> newline, as in C </entry>
-->
       <entry>C言語と同じ改行</entry>
       </row>

       <row>
       <entry> <literal>\r</literal> </entry>
<!--
       <entry> carriage return, as in C </entry>
-->
       <entry>C言語と同じ復帰</entry>
       </row>

       <row>
       <entry> <literal>\t</literal> </entry>
<!--
       <entry> horizontal tab, as in C </entry>
-->
       <entry>C言語と同じ水平タブ</entry>
       </row>

       <row>
       <entry> <literal>\u</literal><replaceable>wxyz</replaceable> </entry>
<!--
       <entry> (where <replaceable>wxyz</replaceable> is exactly four hexadecimal digits)
       the character whose hexadecimal value is
       <literal>0x</literal><replaceable>wxyz</replaceable>
-->
       <entry>（ここで<replaceable>wxyz</replaceable>は正確に4桁の16進数で）その16進数での値が<literal>0x</literal><replaceable>wxyz</replaceable>という文字
       </entry>
       </row>

       <row>
       <entry> <literal>\U</literal><replaceable>stuvwxyz</replaceable> </entry>
<!--
       <entry> (where <replaceable>stuvwxyz</replaceable> is exactly eight hexadecimal
       digits)
       the character whose hexadecimal value is
       <literal>0x</literal><replaceable>stuvwxyz</replaceable>
-->
       <entry>（ここで<replaceable>stuvwxyz</replaceable>は正確に8桁の16進数で）その16進数での値が<literal>0x</literal><replaceable>stuvwxyz</replaceable>という文字
       </entry>
       </row>

       <row>
       <entry> <literal>\v</literal> </entry>
<!--
       <entry> vertical tab, as in C </entry>
-->
       <entry>C言語と同じ垂直タブ</entry>
       </row>

       <row>
       <entry> <literal>\x</literal><replaceable>hhh</replaceable> </entry>
<!--
       <entry> (where <replaceable>hhh</replaceable> is any sequence of hexadecimal
       digits)
       the character whose hexadecimal value is
       <literal>0x</literal><replaceable>hhh</replaceable>
       (a single character no matter how many hexadecimal digits are used)
-->
       <entry>（ここで<replaceable>hhh</replaceable>は任意の16進数の並びで）その文字の16進数値が<literal>0x</literal><replaceable>hhh</replaceable>となる文字（使用される16進数の桁数にかかわらず単一の文字）
       </entry>
       </row>

       <row>
       <entry> <literal>\0</literal> </entry>
<!--
       <entry> the character whose value is <literal>0</literal> (the null byte)</entry>
-->
       <entry>その値が<literal>0</literal>（NULLバイト）となる文字</entry>
       </row>

       <row>
       <entry> <literal>\</literal><replaceable>xy</replaceable> </entry>
<!--
       <entry> (where <replaceable>xy</replaceable> is exactly two octal digits,
       and is not a <firstterm>back reference</firstterm>)
       the character whose octal value is
       <literal>0</literal><replaceable>xy</replaceable> </entry>
-->
       <entry>（ここで<replaceable>xy</replaceable>は正確に2桁の8進数で、<firstterm>後方参照</firstterm>ではない）その値が<literal>0</literal><replaceable>xy</replaceable>となる文字</entry>
       </row>

       <row>
       <entry> <literal>\</literal><replaceable>xyz</replaceable> </entry>
<!--
       <entry> (where <replaceable>xyz</replaceable> is exactly three octal digits,
       and is not a <firstterm>back reference</firstterm>)
       the character whose octal value is
       <literal>0</literal><replaceable>xyz</replaceable> </entry>
-->
       <entry>（ここで<replaceable>xyz</replaceable>は正確に3桁の8進数で、<firstterm>後方参照</firstterm>ではない）その値が<literal>0</literal><replaceable>xyz</replaceable>となる文字</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
<!--
    Hexadecimal digits are <literal>0</literal>-<literal>9</literal>,
    <literal>a</literal>-<literal>f</literal>, and <literal>A</literal>-<literal>F</literal>.
    Octal digits are <literal>0</literal>-<literal>7</literal>.
-->
16進数の桁とは<literal>0</literal>-<literal>9</literal>、<literal>a</literal>-<literal>f</literal>、<literal>A</literal>-<literal>F</literal>です。
8進数の桁とは<literal>0</literal>-<literal>7</literal>です。
   </para>

   <para>
<!--
    Numeric character-entry escapes specifying values outside the ASCII range
    (0&ndash;127) have meanings dependent on the database encoding.  When the
    encoding is UTF-8, escape values are equivalent to Unicode code points,
    for example <literal>\u1234</literal> means the character <literal>U+1234</literal>.
    For other multibyte encodings, character-entry escapes usually just
    specify the concatenation of the byte values for the character.  If the
    escape value does not correspond to any legal character in the database
    encoding, no error will be raised, but it will never match any data.
-->
ASCIIの範囲(0-127)外の値を指定した数字のエントリエスケープは、その意味がデータベースエンコーディングに依存します。
エンコーディングがUTF-8の場合、エスケープ値はユニコード符号位置に相当します。例えば、<literal>\u1234</literal>は文字<literal>U+1234</literal>を意味します。
その他のマルチバイトエンコーディングでは、文字エントリエスケープはたいてい文字のバイト値の連結を指定します。
エスケープ値がデータベースエンコーディングでのいかなる正当な文字にも対応しない場合、エラーは起こりませんが、いかなるデータにもマッチしません。
   </para>

   <para>
<!--
    The character-entry escapes are always taken as ordinary characters.
    For example, <literal>\135</literal> is <literal>]</literal> in ASCII, but
    <literal>\135</literal> does not terminate a bracket expression.
-->
この文字エントリエスケープは常に普通の文字と解釈されます。
例えば、<literal>\135</literal>はASCIIの<literal>]</literal>となり、<literal>\135</literal>はブラケット式の終端にはなりません。
   </para>

   <table id="posix-class-shorthand-escapes-table">
<!--
    <title>Regular Expression Class-Shorthand Escapes</title>
-->
    <title>正規表現クラス省略エスケープ</title>

    <tgroup cols="2">
     <thead>
      <row>
<!--
       <entry>Escape</entry>
-->
       <entry>エスケープ</entry>
<!--
       <entry>Description</entry>
-->
       <entry>説明</entry>
      </row>
     </thead>

      <tbody>
       <row>
       <entry> <literal>\d</literal> </entry>
<!--
       <entry> matches any digit, like
        <literal>[[:digit:]]</literal> </entry>
-->
       <entry><literal>[[:digit:]]</literal>のようなすべての数字にマッチします。</entry>
       </row>

       <row>
       <entry> <literal>\s</literal> </entry>
<!--
       <entry> matches any whitespace character, like
        <literal>[[:space:]]</literal> </entry>
-->
       <entry><literal>[[:space:]]</literal>のようなすべての空白文字にマッチします。</entry>
       </row>

       <row>
       <entry> <literal>\w</literal> </entry>
<!--
       <entry> matches any word character, like
        <literal>[[:word:]]</literal> </entry>
-->
       <entry><literal>[[:word:]]</literal>のようなすべての単語文字にマッチします。</entry>
       </row>

       <row>
       <entry> <literal>\D</literal> </entry>
<!--
       <entry> matches any non-digit, like
        <literal>[^[:digit:]]</literal> </entry>
-->
       <entry><literal>[^[:digit:]]</literal>のようなすべての非数字にマッチします。</entry>
       </row>

       <row>
       <entry> <literal>\S</literal> </entry>
<!--
       <entry> matches any non-whitespace character, like
        <literal>[^[:space:]]</literal> </entry>
-->
       <entry><literal>[^[:space:]]</literal>のようなすべての非空白文字にマッチします。</entry>
       </row>

       <row>
       <entry> <literal>\W</literal> </entry>
<!--
       <entry> matches any non-word character, like
        <literal>[^[:word:]]</literal> </entry>
-->
       <entry><literal>[^[:word:]]</literal>のようなすべての非単語文字にマッチします。</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
<!--
    The class-shorthand escapes also work within bracket expressions,
    although the definitions shown above are not quite syntactically
    valid in that context.
    For example, <literal>[a-c\d]</literal> is equivalent to
    <literal>[a-c[:digit:]]</literal>.
-->
クラス省略エスケープはブラケット式の中でも使えますが、上に示した定義はそのコンテキストでは構文的に正しいとは言えません。
たとえば<literal>[a-c\d]</literal>は<literal>[a-c[:digit:]]</literal>と同様です。
   </para>

   <table id="posix-constraint-escapes-table">
<!--
    <title>Regular Expression Constraint Escapes</title>
-->
    <title>正規表現制約エスケープ</title>

    <tgroup cols="2">
     <thead>
      <row>
<!--
       <entry>Escape</entry>
-->
       <entry>エスケープ</entry>
<!--
       <entry>Description</entry>
-->
       <entry>説明</entry>
      </row>
     </thead>

      <tbody>
       <row>
       <entry> <literal>\A</literal> </entry>
<!--
       <entry> matches only at the beginning of the string
       (see <xref linkend="posix-matching-rules"/> for how this differs from
       <literal>^</literal>) </entry>
-->
       <entry>文字列の先頭にのみマッチします（<literal>^</literal>との違いについては<xref linkend="posix-matching-rules"/>を参照してください）。</entry>
       </row>

       <row>
       <entry> <literal>\m</literal> </entry>
<!--
       <entry> matches only at the beginning of a word </entry>
-->
       <entry> 単語の先頭にのみマッチします。 </entry>
       </row>

       <row>
       <entry> <literal>\M</literal> </entry>
<!--
       <entry> matches only at the end of a word </entry>
-->
       <entry> 単語の末尾にのみマッチします。 </entry>
       </row>

       <row>
       <entry> <literal>\y</literal> </entry>
<!--
       <entry> matches only at the beginning or end of a word </entry>
-->
       <entry> 単語の先頭もしくは末尾にのみマッチします。</entry>
       </row>

       <row>
       <entry> <literal>\Y</literal> </entry>
<!--
       <entry> matches only at a point that is not the beginning or end of a
       word </entry>
-->
       <entry>単語の先頭もしくは末尾以外の場所にのみマッチします。</entry>
       </row>

       <row>
       <entry> <literal>\Z</literal> </entry>
<!--
       <entry> matches only at the end of the string
       (see <xref linkend="posix-matching-rules"/> for how this differs from
       <literal>$</literal>) </entry>
-->
       <entry>文字列の末尾にのみマッチします（<literal>$</literal>との違いについては<xref linkend="posix-matching-rules"/>を参照してください）。</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
<!--
    A word is defined as in the specification of
    <literal>[[:&lt;:]]</literal> and <literal>[[:&gt;:]]</literal> above.
    Constraint escapes are illegal within bracket expressions.
-->
    単語は前述の<literal>[[:&lt;:]]</literal>と<literal>[[:&gt;:]]</literal>の規定通りに定義されます。ブラケット式内では制約エスケープは不正です。
   </para>

   <table id="posix-constraint-backref-table">
<!--
    <title>Regular Expression Back References</title>
-->
    <title>正規表現後方参照</title>

    <tgroup cols="2">
     <thead>
      <row>
<!--
       <entry>Escape</entry>
-->
       <entry>エスケープ</entry>
<!--
       <entry>Description</entry>
-->
       <entry>説明</entry>
      </row>
     </thead>

      <tbody>
       <row>
       <entry> <literal>\</literal><replaceable>m</replaceable> </entry>
<!--
       <entry> (where <replaceable>m</replaceable> is a nonzero digit)
       a back reference to the <replaceable>m</replaceable>'th subexpression </entry>
-->
       <entry>（ここで<replaceable>m</replaceable>は非ゼロの数です。）副式の<replaceable>m</replaceable>番目への後方参照</entry>
       </row>

       <row>
       <entry> <literal>\</literal><replaceable>mnn</replaceable> </entry>
<!--
       <entry> (where <replaceable>m</replaceable> is a nonzero digit, and
       <replaceable>nn</replaceable> is some more digits, and the decimal value
       <replaceable>mnn</replaceable> is not greater than the number of closing capturing
       parentheses seen so far)
       a back reference to the <replaceable>mnn</replaceable>'th subexpression </entry>
-->
       <entry>（ここで<replaceable>m</replaceable>は非ゼロの数です。<replaceable>nn</replaceable>でさらに桁を指定します。<replaceable>mnn</replaceable>10進数値は取り込み括弧の数よりも多くてはなりません。）副式の<replaceable>mnn</replaceable>番目への後方参照</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <note>
    <para>
<!--
     There is an inherent ambiguity between octal character-entry
     escapes and back references, which is resolved by the following heuristics,
     as hinted at above.
     A leading zero always indicates an octal escape.
     A single non-zero digit, not followed by another digit,
     is always taken as a back reference.
     A multi-digit sequence not starting with a zero is taken as a back
     reference if it comes after a suitable subexpression
     (i.e., the number is in the legal range for a back reference),
     and otherwise is taken as octal.
-->
8進数の文字エントリエスケープと後方参照の間には曖昧性があります。上でヒントとして示したようにこれは以下の発見的手法で解決されます。
先頭の0は常に8進数エスケープを示します。
その後に数字が続かない単一の非ゼロ数字は常に後方参照として解釈されます。
ゼロから始まらない複数数字の並びは、適切な副式の後にあれば（つまり、その番号が後方参照用の範囲内にあれば）後方参照として解釈されます。さもなくば、8進数として解釈されます。
    </para>
   </note>
   </sect3>

   <sect3 id="posix-metasyntax">
<!--
    <title>Regular Expression Metasyntax</title>
-->
    <title>正規表現メタ構文</title>

   <para>
<!--
    In addition to the main syntax described above, there are some special
    forms and miscellaneous syntactic facilities available.
-->
上述の主構文の他に、特殊な形式や雑多な構文的な機能が使用可能です。
   </para>

   <para>
<!--
    An RE can begin with one of two special <firstterm>director</firstterm> prefixes.
    If an RE begins with <literal>***:</literal>,
    the rest of the RE is taken as an ARE.  (This normally has no effect in
    <productname>PostgreSQL</productname>, since REs are assumed to be AREs;
    but it does have an effect if ERE or BRE mode had been specified by
    the <replaceable>flags</replaceable> parameter to a regex function.)
    If an RE begins with <literal>***=</literal>,
    the rest of the RE is taken to be a literal string,
    with all characters considered ordinary characters.
-->
REは、2つの特殊な<firstterm>決定子</firstterm>前置詞のどちらかから始まります。
REが<literal>***:</literal>から始まるものであれば、REの残りはAREと解釈されます。
(<productname>PostgreSQL</productname>はREをAREとして推測するため、通常は影響を受けません。ただし、正規表現関数に対して<replaceable>flags</replaceable>パラメータを指定されたEREやBREモードでは影響を受けます。)
REが<literal>***=</literal>から始まるものであれば、REの残りは、全ての文字を普通の文字とみなしたリテラル文字列と解釈されます。
   </para>

   <para>
<!--
    An ARE can begin with <firstterm>embedded options</firstterm>:
    a sequence <literal>(?</literal><replaceable>xyz</replaceable><literal>)</literal>
    (where <replaceable>xyz</replaceable> is one or more alphabetic characters)
    specifies options affecting the rest of the RE.
    These options override any previously determined options &mdash;
    in particular, they can override the case-sensitivity behavior implied by
    a regex operator, or the <replaceable>flags</replaceable> parameter to a regex
    function.
    The available option letters are
    shown in <xref linkend="posix-embedded-options-table"/>.
    Note that these same option letters are used in the <replaceable>flags</replaceable>
    parameters of regex functions.
-->
AREは<firstterm>埋め込みオプション</firstterm>から始められます。<literal>(?</literal><replaceable>xyz</replaceable><literal>)</literal>という並びで残りのREに影響するオプションを指定します（ここで<replaceable>xyz</replaceable>は1つ以上の英字です）。
このオプションは、事前に決定されたオプションを上書きします。&mdash; 特に、正規表現演算子、もしくは正規表現関数に与えられた<replaceable>flags</replaceable>パラメータにより示される大文字小文字の区別を上書きします。
使用可能なオプション文字を<xref linkend="posix-embedded-options-table"/>に示します。
これらの同じオプション文字が、正規表現関数の<replaceable>flags</replaceable>パラメータで使用されることに注意して下さい。
   </para>

   <table id="posix-embedded-options-table">
<!--
    <title>ARE Embedded-Option Letters</title>
-->
    <title>ARE埋め込みオプション文字</title>

    <tgroup cols="2">
     <thead>
      <row>
<!--
       <entry>Option</entry>
-->
       <entry>オプション</entry>
<!--
       <entry>Description</entry>
-->
       <entry>説明</entry>
      </row>
     </thead>

      <tbody>
       <row>
       <entry> <literal>b</literal> </entry>
<!--
       <entry> rest of RE is a BRE </entry>
-->
       <entry> 残りのREはBRE </entry>
       </row>

       <row>
       <entry> <literal>c</literal> </entry>
<!--
       <entry> case-sensitive matching (overrides operator type) </entry>
-->
       <entry> 大文字小文字を区別するマッチ（演算子で規定される大文字小文字の区別よりこの指定が優先されます）。 </entry>
       </row>

       <row>
       <entry> <literal>e</literal> </entry>
<!--
       <entry> rest of RE is an ERE </entry>
-->
       <entry> 残りのREはERE </entry>
       </row>

       <row>
       <entry> <literal>i</literal> </entry>
<!--
       <entry> case-insensitive matching (see
       <xref linkend="posix-matching-rules"/>) (overrides operator type) </entry>
-->
       <entry> 大文字小文字を区別しないマッチ（<xref linkend="posix-matching-rules"/>を参照）（演算子で規定される大文字小文字の区別よりこの指定が優先されます）。 </entry>
       </row>

       <row>
       <entry> <literal>m</literal> </entry>
<!--
       <entry> historical synonym for <literal>n</literal> </entry>
-->
       <entry> <literal>n</literal>の歴史的な同義語 </entry>
       </row>

       <row>
       <entry> <literal>n</literal> </entry>
<!--
       <entry> newline-sensitive matching (see
       <xref linkend="posix-matching-rules"/>) </entry>
-->
       <entry> 改行を区別するマッチ（<xref linkend="posix-matching-rules"/>を参照）</entry>
       </row>

       <row>
       <entry> <literal>p</literal> </entry>
<!--
       <entry> partial newline-sensitive matching (see
       <xref linkend="posix-matching-rules"/>) </entry>
-->
       <entry> 部分的な改行を区別するマッチ（<xref linkend="posix-matching-rules"/>を参照）</entry>
       </row>

       <row>
       <entry> <literal>q</literal> </entry>
<!--
       <entry> rest of RE is a literal (<quote>quoted</quote>) string, all ordinary
       characters </entry>
-->
       <entry> 残りのREはリテラル（<quote>引用符付けされた</quote>）文字列、全て普通の文字</entry>
       </row>

       <row>
       <entry> <literal>s</literal> </entry>
<!--
       <entry> non-newline-sensitive matching (default) </entry>
-->
       <entry> 改行を区別しないマッチ（デフォルト）</entry>
       </row>

       <row>
       <entry> <literal>t</literal> </entry>
<!--
       <entry> tight syntax (default; see below) </entry>
-->
       <entry> 厳しめの構文（デフォルト、後述） </entry>
       </row>

       <row>
       <entry> <literal>w</literal> </entry>
<!--
       <entry> inverse partial newline-sensitive (<quote>weird</quote>) matching
       (see <xref linkend="posix-matching-rules"/>) </entry>
-->
       <entry> 部分的な改行区別の逆（<quote>ワイアード</quote>）マッチ（<xref linkend="posix-matching-rules"/>を参照）</entry>
       </row>

       <row>
       <entry> <literal>x</literal> </entry>
<!--
       <entry> expanded syntax (see below) </entry>
-->
       <entry> 拡張構文（後述） </entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
<!--
    Embedded options take effect at the <literal>)</literal> terminating the sequence.
    They can appear only at the start of an ARE (after the
    <literal>***:</literal> director if any).
-->
埋め込みオプションはその並びの終端<literal>)</literal>で有効になります。
AREの先頭（もし<literal>***:</literal>決定子があればその後）でのみ利用可能です。
   </para>

   <para>
<!--
    In addition to the usual (<firstterm>tight</firstterm>) RE syntax, in which all
    characters are significant, there is an <firstterm>expanded</firstterm> syntax,
    available by specifying the embedded <literal>x</literal> option.
    In the expanded syntax,
    white-space characters in the RE are ignored, as are
    all characters between a <literal>#</literal>
    and the following newline (or the end of the RE).  This
    permits paragraphing and commenting a complex RE.
    There are three exceptions to that basic rule:
-->
全ての文字が意味を持つ、通常の（<firstterm>厳しめの</firstterm>）RE構文に加え、<literal>x</literal>埋め込みオプションを指定することで利用できる<firstterm>拡張</firstterm>構文があります。
拡張構文では、RE内の空白文字は無視され、<literal>#</literal>とその後の改行（もしくはREの終端）の間の全ての文字も同様です。
これにより、段落付けや複雑なREのコメント付けが可能になります。
基本規則に対して3つの例外があります。

    <itemizedlist>
     <listitem>
      <para>
<!--
       a white-space character or <literal>#</literal> preceded by <literal>\</literal> is
       retained
-->
直前に<literal>\</literal>が付いた空白文字もしくは<literal>#</literal>は保持されます。
      </para>
     </listitem>
     <listitem>
      <para>
<!--
       white space or <literal>#</literal> within a bracket expression is retained
-->
ブラケット式内の空白文字もしくは<literal>#</literal>は保持されます。
      </para>
     </listitem>
     <listitem>
      <para>
<!--
       white space and comments cannot appear within multi-character symbols,
       such as <literal>(?:</literal>
-->
<literal>(?:</literal>などの複数文字シンボルでは、空白文字とコメントは不正です。
      </para>
     </listitem>
    </itemizedlist>

<!--
    For this purpose, white-space characters are blank, tab, newline, and
    any character that belongs to the <replaceable>space</replaceable> character class.
-->
ここでの空白文字とは、空白、タブ、改行、<replaceable>スペース</replaceable>文字クラスに属する文字です。
   </para>

   <para>
<!--
    Finally, in an ARE, outside bracket expressions, the sequence
    <literal>(?#</literal><replaceable>ttt</replaceable><literal>)</literal>
    (where <replaceable>ttt</replaceable> is any text not containing a <literal>)</literal>)
    is a comment, completely ignored.
    Again, this is not allowed between the characters of
    multi-character symbols, like <literal>(?:</literal>.
    Such comments are more a historical artifact than a useful facility,
    and their use is deprecated; use the expanded syntax instead.
-->
最後に、AREのブラケット式の外側では、<literal>(?#</literal><replaceable>ttt</replaceable><literal>)</literal>という並びは完全に無視されるコメントになります（ここで<replaceable>ttt</replaceable>は<literal>）</literal>を含まない任意のテキストです）。
繰り返しになりますが、これは<literal>(?:</literal>などの複数文字シンボルの文字間では使用できません。
こうしたコメントは実用性というより歴史的所産です。そのため、この使用は勧めません。代わりに拡張構文を使用してください。
   </para>

   <para>
<!--
    <emphasis>None</emphasis> of these metasyntax extensions is available if
    an initial <literal>***=</literal> director
    has specified that the user's input be treated as a literal string
    rather than as an RE.
-->
初めに<literal>***=</literal>決定子が指定され、ユーザの入力がREではなくリテラルとして扱われる場合、これらのメタ構文拡張は使用<emphasis>できません</emphasis>。
   </para>
   </sect3>

   <sect3 id="posix-matching-rules">
<!--
    <title>Regular Expression Matching Rules</title>
-->
    <title>正規表現マッチ規則</title>

   <para>
<!--
    In the event that an RE could match more than one substring of a given
    string, the RE matches the one starting earliest in the string.
    If the RE could match more than one substring starting at that point,
    either the longest possible match or the shortest possible match will
    be taken, depending on whether the RE is <firstterm>greedy</firstterm> or
    <firstterm>non-greedy</firstterm>.
-->
REが文字列の中の1つ以上の部分文字列とマッチする場合において、REは最初にマッチが始まった部分文字列とマッチします。
その位置からまた1つ以上の部分文字列とマッチした際は、正規表現は<firstterm>最短マッチを行わない（欲張り型）</firstterm>か<firstterm>最短マッチを行う（非欲張り型）</firstterm>かによって、最長マッチもしくは最短マッチの文字列のどちらかにマッチします
   </para>

   <para>
<!--
    Whether an RE is greedy or not is determined by the following rules:
-->
REが最長マッチかどうかは以下の規則によって決まります。
    <itemizedlist>
     <listitem>
      <para>
<!--
       Most atoms, and all constraints, have no greediness attribute (because
       they cannot match variable amounts of text anyway).
-->
ほとんどのアトムおよび全ての式は欲張り属性を持ちません（これらは変動する量のテキストにまったくマッチしないからです）。
      </para>
     </listitem>
     <listitem>
      <para>
<!--
       Adding parentheses around an RE does not change its greediness.
-->
REを括弧で括ることは欲張りかどうかを変更しません。
      </para>
     </listitem>
     <listitem>
      <para>
<!--
       A quantified atom with a fixed-repetition quantifier
       (<literal>{</literal><replaceable>m</replaceable><literal>}</literal>
       or
       <literal>{</literal><replaceable>m</replaceable><literal>}?</literal>)
       has the same greediness (possibly none) as the atom itself.
-->
<literal>{</literal><replaceable>m</replaceable><literal>}</literal>もしくは<literal>{</literal><replaceable>m</replaceable><literal>}?</literal>といった固定繰り返し数の量指定子を持つ量指定付きアトムは、アトム自身と同一の欲張りさを持ちます（まったく持たない可能性もあります）。
      </para>
     </listitem>
     <listitem>
      <para>
<!--
       A quantified atom with other normal quantifiers (including
       <literal>{</literal><replaceable>m</replaceable><literal>,</literal><replaceable>n</replaceable><literal>}</literal>
       with <replaceable>m</replaceable> equal to <replaceable>n</replaceable>)
       is greedy (prefers longest match).
-->
他の通常の量指定子（<literal>{</literal><replaceable>m</replaceable><literal>,</literal><replaceable>n</replaceable><literal>}</literal>、<replaceable>m</replaceable>と<replaceable>n</replaceable>が等しい場合も含みます）を持つ量指定付きアトムは欲張り型です（最長マッチを使用します）。
      </para>
     </listitem>
     <listitem>
      <para>
<!--
       A quantified atom with a non-greedy quantifier (including
       <literal>{</literal><replaceable>m</replaceable><literal>,</literal><replaceable>n</replaceable><literal>}?</literal>
       with <replaceable>m</replaceable> equal to <replaceable>n</replaceable>)
       is non-greedy (prefers shortest match).
-->
他の非欲張り型量指定子（<literal>{</literal><replaceable>m</replaceable><literal>,</literal><replaceable>n</replaceable><literal>}?</literal>、<replaceable>m</replaceable>と<replaceable>n</replaceable>が等しい場合も含みます）を持つ量指定付きアトムは非欲張り型です（最短マッチを使用します）。
      </para>
     </listitem>
     <listitem>
      <para>
<!--
       A branch &mdash; that is, an RE that has no top-level
       <literal>|</literal> operator &mdash; has the same greediness as the first
       quantified atom in it that has a greediness attribute.
-->
最上位レベルの<literal>|</literal>演算子を持たないREであるブランチは、最初の欲張り属性を持つ量指定付きアトムと同一の欲張り属性を持ちます。
      </para>
     </listitem>
     <listitem>
      <para>
<!--
       An RE consisting of two or more branches connected by the
       <literal>|</literal> operator is always greedy.
-->
<literal>|</literal>演算子で接続された2つ以上のブランチからなるREは常に欲張り型です。
      </para>
     </listitem>
    </itemizedlist>
   </para>

   <para>
<!--
    The above rules associate greediness attributes not only with individual
    quantified atoms, but with branches and entire REs that contain quantified
    atoms.  What that means is that the matching is done in such a way that
    the branch, or whole RE, matches the longest or shortest possible
    substring <emphasis>as a whole</emphasis>.  Once the length of the entire match
    is determined, the part of it that matches any particular subexpression
    is determined on the basis of the greediness attribute of that
    subexpression, with subexpressions starting earlier in the RE taking
    priority over ones starting later.
-->
上の規則は、個々の量指定付きアトムだけではなく、量指定付きアトムを複数含むブランチやRE全体の欲張り属性に関連します。
つまり、ブランチやRE全体が<emphasis>全体として</emphasis>最長または最短の部分文字列にマッチするという方法でマッチ処理が行われます。
全体のマッチの長さが決まると、特定の部分式にマッチする部分がその部分式の欲張り属性によって決まります。この時、RE内でより前にある部分式が後にある部分式よりも高い優先度を持ちます。
   </para>

   <para>
<!--
    An example of what this means:
-->
この意味の例を示します。
<screen>
SELECT SUBSTRING('XY1234Z', 'Y*([0-9]{1,3})');
<lineannotation>Result: </lineannotation><computeroutput>123</computeroutput>
SELECT SUBSTRING('XY1234Z', 'Y*?([0-9]{1,3})');
<lineannotation>Result: </lineannotation><computeroutput>1</computeroutput>
</screen>
<!--
    In the first case, the RE as a whole is greedy because <literal>Y*</literal>
    is greedy.  It can match beginning at the <literal>Y</literal>, and it matches
    the longest possible string starting there, i.e., <literal>Y123</literal>.
    The output is the parenthesized part of that, or <literal>123</literal>.
    In the second case, the RE as a whole is non-greedy because <literal>Y*?</literal>
    is non-greedy.  It can match beginning at the <literal>Y</literal>, and it matches
    the shortest possible string starting there, i.e., <literal>Y1</literal>.
    The subexpression <literal>[0-9]{1,3}</literal> is greedy but it cannot change
    the decision as to the overall match length; so it is forced to match
    just <literal>1</literal>.
-->
最初の例では、<literal>Y*</literal>が欲張り型であるため、REは全体として欲張り型です。
マッチは<literal>Y</literal>の位置から始まり、そこから可能な限り最長の文字列にマッチします。つまり<literal>Y123</literal>となります。
出力は括弧で括られた部分、つまり<literal>123</literal>となります。
2番目の例では、<literal>Y*?</literal>が非欲張り型のため、REは全体として非欲張り型です。
マッチは<literal>Y</literal>の位置から始まり、そこから可能な限り最短の文字列にマッチします。つまり<literal>Y1</literal>となります。
部分式<literal>[0-9]{1,3}</literal>は欲張り型ですが、決定されたマッチする全体の長さを変更することはできません。したがって、強制的に<literal>1</literal>にマッチすることになります。
   </para>

   <para>
<!--
    In short, when an RE contains both greedy and non-greedy subexpressions,
    the total match length is either as long as possible or as short as
    possible, according to the attribute assigned to the whole RE.  The
    attributes assigned to the subexpressions only affect how much of that
    match they are allowed to <quote>eat</quote> relative to each other.
-->
まとめると、REが欲張り型部分式と非欲張り型部分式の両方を持つ場合、全体のマッチ長はRE全体に割り当てられる属性に応じて、最長マッチ長か最短マッチ長のどちらかになります。
部分式に割り当てられた属性は、部分式の中でどれだけの量をその部分式の中で<quote>消費</quote>できるかのみに影響します。
   </para>

   <para>
<!--
    The quantifiers <literal>{1,1}</literal> and <literal>{1,1}?</literal>
    can be used to force greediness or non-greediness, respectively,
    on a subexpression or a whole RE.
    This is useful when you need the whole RE to have a greediness attribute
    different from what's deduced from its elements.  As an example,
    suppose that we are trying to separate a string containing some digits
    into the digits and the parts before and after them.  We might try to
    do that like this:
-->
<literal>{1,1}</literal>および<literal>{1,1}?</literal>量指定子を副式もしくはRE全体に使用して、それぞれ、欲張りか欲張りでないかを強制することが可能です。
RE全体に対してはその要素から推論されるものと異なる欲張りさの属性が必要な場合に、これは便利です。
例として、数字をいくつか含む文字列を数字とその前後の部分に分けようとしているとします。
次のようにしてみるかもしれません。
<screen>
SELECT regexp_match('abc01234xyz', '(.*)(\d+)(.*)');
<lineannotation>Result: </lineannotation><computeroutput>{abc0123,4,xyz}</computeroutput>
</screen>
<!--
    That didn't work: the first <literal>.*</literal> is greedy so
    it <quote>eats</quote> as much as it can, leaving the <literal>\d+</literal> to
    match at the last possible place, the last digit.  We might try to fix
    that by making it non-greedy:
-->
上手くいきませんでした。最初の<literal>.*</literal>が欲張りで、可能なだけ<quote>消費</quote>してしまい、<literal>\d+</literal>は最後の可能な場所で最後の数字にマッチします。
欲張りでなくすることで直そうとするかもしれません。
<screen>
SELECT regexp_match('abc01234xyz', '(.*?)(\d+)(.*)');
<lineannotation>Result: </lineannotation><computeroutput>{abc,0,""}</computeroutput>
</screen>
<!--
    That didn't work either, because now the RE as a whole is non-greedy
    and so it ends the overall match as soon as possible.  We can get what
    we want by forcing the RE as a whole to be greedy:
-->
またもや上手くいきませんでした。今度は、REが全体として欲張りでなくなってしまい、できる限り早く全体に渡るマッチを終わらせてしまうからです。
RE全体として欲張りにすることで欲しいものが得られます。
<screen>
SELECT regexp_match('abc01234xyz', '(?:(.*?)(\d+)(.*)){1,1}');
<lineannotation>Result: </lineannotation><computeroutput>{abc,01234,xyz}</computeroutput>
</screen>
<!--
    Controlling the RE's overall greediness separately from its components'
    greediness allows great flexibility in handling variable-length patterns.
-->
REの全体に渡る欲張りさをその要素の欲張りさと別に制御すれば、可変長のパターンを非常に柔軟に扱えます。
   </para>

   <para>
<!--
    When deciding what is a longer or shorter match,
    match lengths are measured in characters, not collating elements.
    An empty string is considered longer than no match at all.
    For example:
    <literal>bb*</literal>
    matches the three middle characters of <literal>abbbc</literal>;
    <literal>(week|wee)(night|knights)</literal>
    matches all ten characters of <literal>weeknights</literal>;
    when <literal>(.*).*</literal>
    is matched against <literal>abc</literal> the parenthesized subexpression
    matches all three characters; and when
    <literal>(a*)*</literal> is matched against <literal>bc</literal>
    both the whole RE and the parenthesized
    subexpression match an empty string.
-->
マッチが長いか短いかを判断する時には、マッチの長さは照合要素ではなく文字列で測られます。
空文字列はまったくマッチする要素がない文字列よりも長いと考えられます。
例えば、<literal>bb*</literal>は<literal>abbbc</literal>の真中の3文字とマッチし、<literal>(week|wee)(night|knights)</literal>は<literal>weeknights</literal>の全ての10文字とマッチし、<literal>abc</literal>に対して<literal>(.*).*</literal>がマッチされると、括弧内の部分正規表現は3つの文字全てにマッチし、<literal>bc</literal>に対して<literal>(a*)*</literal>がマッチされると、全体のREと括弧内の正規表現は空文字列にマッチします。
   </para>

   <para>
<!--
    If case-independent matching is specified,
    the effect is much as if all case distinctions had vanished from the
    alphabet.
    When an alphabetic that exists in multiple cases appears as an
    ordinary character outside a bracket expression, it is effectively
    transformed into a bracket expression containing both cases,
    e.g., <literal>x</literal> becomes <literal>[xX]</literal>.
    When it appears inside a bracket expression, all case counterparts
    of it are added to the bracket expression, e.g.,
    <literal>[x]</literal> becomes <literal>[xX]</literal>
    and <literal>[^x]</literal> becomes <literal>[^xX]</literal>.
-->
もし大文字小文字を区別しないマッチが指定されると、アルファベット文字の大文字小文字の区別がまったくなくなったのと同じ効果を与えます。
ブラケット式の外側にアルファベットの大文字小文字が混ざった通常の文字が出てきた場合、例えば、<literal>x</literal>が<literal>[xX]</literal>となるように大文字小文字ともにブラケット式に実質的に転換されます。
ブラケット式の中に現れた時は、（例えば）<literal>[x]</literal>が<literal>[xX]</literal>となり、また<literal>[^x]</literal>が<literal>[^xX]</literal>となるように、全ての大文字小文字それぞれの対がブラケット式に追加されます。
   </para>

   <para>
<!--
    If newline-sensitive matching is specified, <literal>.</literal>
    and bracket expressions using <literal>^</literal>
    will never match the newline character
    (so that matches will not cross lines unless the RE
    explicitly includes a newline)
    and <literal>^</literal> and <literal>$</literal>
    will match the empty string after and before a newline
    respectively, in addition to matching at beginning and end of string
    respectively.
    But the ARE escapes <literal>\A</literal> and <literal>\Z</literal>
    continue to match beginning or end of string <emphasis>only</emphasis>.
    Also, the character class shorthands <literal>\D</literal>
    and <literal>\W</literal> will match a newline regardless of this mode.
    (Before <productname>PostgreSQL</productname> 14, they did not match
    newlines when in newline-sensitive mode.
    Write <literal>[^[:digit:]]</literal>
    or <literal>[^[:word:]]</literal> to get the old behavior.)
-->
改行を区別するマッチが指定されると、<literal>.</literal>と<literal>^</literal>を使用するブラケット式は（REが明示的に改行を含まない限りマッチが行をまたがらないようにするために）改行文字にマッチしなくなります。また、<literal>^</literal>と<literal>$</literal>はそれぞれ改行直後と直前の空文字列にマッチし、さらに、それぞれ文字列の先頭と末尾にマッチします。
しかし、AREエスケープの<literal>\A</literal>と<literal>\Z</literal>は、継続して、文字列の先頭と末尾<emphasis>のみ</emphasis>にマッチします。
また、文字クラス短縮形<literal>\D</literal>と<literal>\W</literal>このモードが何であれ改行にマッチします。
（<productname>PostgreSQL</productname> 14より前では、改行敏感モードのときはこれらは改行にマッチしませんでした。
古い挙動で動かすには<literal>[^[:digit:]]</literal>あるいは<literal>[^[:word:]]</literal>と書いてください。）
   </para>

   <para>
<!--
    If partial newline-sensitive matching is specified,
    this affects <literal>.</literal> and bracket expressions
    as with newline-sensitive matching, but not <literal>^</literal>
    and <literal>$</literal>.
-->
部分的に改行を区別するマッチが指定されると、<literal>.</literal>とブラケット式は改行を区別するマッチを行うようになりますが、<literal>^</literal>と<literal>$</literal>は変更されません。
   </para>

   <para>
<!--
    If inverse partial newline-sensitive matching is specified,
    this affects <literal>^</literal> and <literal>$</literal>
    as with newline-sensitive matching, but not <literal>.</literal>
    and bracket expressions.
    This isn't very useful but is provided for symmetry.
-->
部分的に改行を区別する逆マッチが指定されると、<literal>^</literal>と<literal>$</literal>は改行を区別するマッチを行うようになりますが、<literal>.</literal>とブラケット式は変更されません。
これはあまり有用ではありません。対称性のために提供されています。
   </para>
   </sect3>

   <sect3 id="posix-limits-compatibility">
<!--
    <title>Limits and Compatibility</title>
-->
    <title>制限と互換性</title>

   <para>
<!--
    No particular limit is imposed on the length of REs in this
    implementation.  However,
    programs intended to be highly portable should not employ REs longer
    than 256 bytes,
    as a POSIX-compliant implementation can refuse to accept such REs.
-->
本実装ではREの長さに関する制限はありません。
しかし、移植性を高めたいプログラムでは、256バイトを超えるREを使用すべきではありません。POSIX互換の実装ではそうしたREでは混乱する可能性があります。
   </para>

   <para>
<!--
    The only feature of AREs that is actually incompatible with
    POSIX EREs is that <literal>\</literal> does not lose its special
    significance inside bracket expressions.
    All other ARE features use syntax which is illegal or has
    undefined or unspecified effects in POSIX EREs;
    the <literal>***</literal> syntax of directors likewise is outside the POSIX
    syntax for both BREs and EREs.
-->
AREの機能のうち、POSIX EREと実質的な非互換性があるのは、<literal>\</literal>がブラケット式の内側で特殊な意味を失わないという点のみです。
他の全てのARE機能は、POSIX EREでは不正、未定義、未指定な効果となる構文を使用しています。決定子の<literal>***</literal>構文などはBREおよびEREのPOSIX構文にはありません。
   </para>

   <para>
<!--
    Many of the ARE extensions are borrowed from Perl, but some have
    been changed to clean them up, and a few Perl extensions are not present.
    Incompatibilities of note include <literal>\b</literal>, <literal>\B</literal>,
    the lack of special treatment for a trailing newline,
    the addition of complemented bracket expressions to the things
    affected by newline-sensitive matching,
    the restrictions on parentheses and back references in lookahead/lookbehind
    constraints, and the longest/shortest-match (rather than first-match)
    matching semantics.
-->
多くのARE拡張はPerlから拝借したものです。
しかし、いくつかは整理され、Perlの拡張のいくつかは存在しません。
注意すべき非互換性には、<literal>\b</literal>、<literal>\B</literal>、改行の取り扱いに関する特殊な措置の欠落、改行を区別するマッチに影響する点について補足したブラケット式の追加、括弧と先行・後方検索制約内の後方参照についての制限、最長/最短（最初にマッチするではなく）マッチのセマンティクスがあります。
   </para>
   </sect3>

   <sect3 id="posix-basic-regexes">
<!--
    <title>Basic Regular Expressions</title>
-->
    <title>基本正規表現</title>

   <para>
<!--
    BREs differ from EREs in several respects.
    In BREs, <literal>|</literal>, <literal>+</literal>, and <literal>?</literal>
    are ordinary characters and there is no equivalent
    for their functionality.
    The delimiters for bounds are
    <literal>\{</literal> and <literal>\}</literal>,
    with <literal>{</literal> and <literal>}</literal>
    by themselves ordinary characters.
    The parentheses for nested subexpressions are
    <literal>\(</literal> and <literal>\)</literal>,
    with <literal>(</literal> and <literal>)</literal> by themselves ordinary characters.
    <literal>^</literal> is an ordinary character except at the beginning of the
    RE or the beginning of a parenthesized subexpression,
    <literal>$</literal> is an ordinary character except at the end of the
    RE or the end of a parenthesized subexpression,
    and <literal>*</literal> is an ordinary character if it appears at the beginning
    of the RE or the beginning of a parenthesized subexpression
    (after a possible leading <literal>^</literal>).
    Finally, single-digit back references are available, and
    <literal>\&lt;</literal> and <literal>\&gt;</literal>
    are synonyms for
    <literal>[[:&lt;:]]</literal> and <literal>[[:&gt;:]]</literal>
    respectively; no other escapes are available in BREs.
-->
BREはEREといくつかの面において異なります。
BREにおいては、<literal>|</literal>、<literal>+</literal>、<literal>?</literal>は普通の文字であり、それらの機能と等価なものはありません。
バウンドの区切りは<literal>\{</literal>と<literal>\}</literal>であり、<literal>{</literal>と<literal>}</literal>自身は普通の文字です。
副式を入れ子にするための括弧は<literal>\(</literal>と<literal>\)</literal>であり、<literal>(</literal>と<literal>)</literal>自身は普通の文字です。
<literal>^</literal>は、REの先頭にある場合や括弧内の副式の先頭の場合を除き、普通の文字です。
<literal>$</literal>は、REの末尾にある場合や括弧内の副式の末尾の場合を除き、普通の文字です。
また、<literal>*</literal>はREの先頭にある場合や括弧内の副式の先頭にある場合には普通の文字になります（その前に<literal>^</literal>が付いている可能性もあります）。
最後に、1桁の後方参照を使用することができ、また、BREにおいては、<literal>\&lt;</literal>と<literal>\&gt;</literal>はそれぞれ<literal>[[:&lt;:]]</literal>と<literal>[[:&gt;:]]</literal>と同義です。
その他のエスケープはBREでは使用できません。
   </para>
   </sect3>

<!-- end re_syntax.n man page -->

   <sect3 id="posix-vs-xquery">
<!--
   <title>Differences from SQL Standard and XQuery</title>
-->
   <title>標準SQLおよびXQueryとの違い</title>

   <indexterm zone="posix-vs-xquery">
    <primary>LIKE_REGEX</primary>
   </indexterm>

   <indexterm zone="posix-vs-xquery">
    <primary>OCCURRENCES_REGEX</primary>
   </indexterm>

   <indexterm zone="posix-vs-xquery">
    <primary>POSITION_REGEX</primary>
   </indexterm>

   <indexterm zone="posix-vs-xquery">
    <primary>SUBSTRING_REGEX</primary>
   </indexterm>

   <indexterm zone="posix-vs-xquery">
    <primary>TRANSLATE_REGEX</primary>
   </indexterm>

   <indexterm zone="posix-vs-xquery">
    <primary>XQuery regular expressions</primary>
   </indexterm>
   <indexterm zone="posix-vs-xquery">
    <primary>XQuery正規表現</primary>
   </indexterm>

    <para>
<!--
     Since SQL:2008, the SQL standard includes regular expression operators
     and functions that performs pattern
     matching according to the XQuery regular expression
     standard:
-->
SQL:2008以降、標準SQLには正規表現演算子と、XQuery正規表現標準に従ってパターンマッチングを実行する関数が含まれています。
     <itemizedlist>
      <listitem><para><literal>LIKE_REGEX</literal></para></listitem>
      <listitem><para><literal>OCCURRENCES_REGEX</literal></para></listitem>
      <listitem><para><literal>POSITION_REGEX</literal></para></listitem>
      <listitem><para><literal>SUBSTRING_REGEX</literal></para></listitem>
      <listitem><para><literal>TRANSLATE_REGEX</literal></para></listitem>
     </itemizedlist>
<!--
     <productname>PostgreSQL</productname> does not currently implement these
     operators and functions.  You can get approximately equivalent
     functionality in each case as shown in <xref
     linkend="functions-regexp-sql-table"/>.  (Various optional clauses on
     both sides have been omitted in this table.)
-->
<productname>PostgreSQL</productname>は現在これらの演算子や関数を実装していません。
<xref linkend="functions-regexp-sql-table"/>に示すように、それぞれの場合でほぼ同等の機能を得ることができます。
（この表では両側のさまざまなオプション句を省略しています。）
    </para>

    <table id="functions-regexp-sql-table">
<!--
     <title>Regular Expression Functions Equivalencies</title>
-->
     <title>同等の正規表現関数</title>

     <tgroup cols="2">
      <thead>
       <row>
<!--
        <entry>SQL standard</entry>
-->
        <entry>標準SQL</entry>
        <entry><productname>PostgreSQL</productname></entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry><literal><replaceable>string</replaceable> LIKE_REGEX <replaceable>pattern</replaceable></literal></entry>
        <entry><literal>regexp_like(<replaceable>string</replaceable>, <replaceable>pattern</replaceable>)</literal> or <literal><replaceable>string</replaceable> ~ <replaceable>pattern</replaceable></literal></entry>
       </row>

       <row>
        <entry><literal>OCCURRENCES_REGEX(<replaceable>pattern</replaceable> IN <replaceable>string</replaceable>)</literal></entry>
        <entry><literal>regexp_count(<replaceable>string</replaceable>, <replaceable>pattern</replaceable>)</literal></entry>
       </row>

       <row>
        <entry><literal>POSITION_REGEX(<replaceable>pattern</replaceable> IN <replaceable>string</replaceable>)</literal></entry>
        <entry><literal>regexp_instr(<replaceable>string</replaceable>, <replaceable>pattern</replaceable>)</literal></entry>
       </row>

       <row>
        <entry><literal>SUBSTRING_REGEX(<replaceable>pattern</replaceable> IN <replaceable>string</replaceable>)</literal></entry>
        <entry><literal>regexp_substr(<replaceable>string</replaceable>, <replaceable>pattern</replaceable>)</literal></entry>
       </row>

       <row>
        <entry><literal>TRANSLATE_REGEX(<replaceable>pattern</replaceable> IN <replaceable>string</replaceable> WITH <replaceable>replacement</replaceable>)</literal></entry>
        <entry><literal>regexp_replace(<replaceable>string</replaceable>, <replaceable>pattern</replaceable>, <replaceable>replacement</replaceable>)</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

    <para>
<!--
     Regular expression functions similar to those provided by PostgreSQL are
     also available in a number of other SQL implementations, whereas the
     SQL-standard functions are not as widely implemented.  Some of the
     details of the regular expression syntax will likely differ in each
     implementation.
-->
PostgreSQLで提供されているものと同様の正規表現関数は、他の多くのSQL実装でも利用できますが、標準SQL関数はそれほど広く実装されていません。
正規表現構文の詳細のいくつかは、実装によって異なる可能性があります。
    </para>

    <para>
<!--
     The SQL-standard operators and functions use XQuery regular expressions,
     which are quite close to the ARE syntax described above.
     Notable differences between the existing POSIX-based
     regular-expression feature and XQuery regular expressions include:
-->
標準SQLの演算子と関数は、上で述べたARE構文に極めて近いXQuery正規表現を使用しています。
既存のPOSIXベースの正規表現機能とXQueryの正規表現の主な違いには以下のものが含まれます。

     <itemizedlist>
      <listitem>
       <para>
<!--
        XQuery character class subtraction is not supported.  An example of
        this feature is using the following to match only English
        consonants: <literal>[a-z-[aeiou]]</literal>.
-->
XQueryの文字クラス減算はサポートされていません。
この機能の例としては、<literal>[a-z-[aeiou]]</literal>のようにして英語の子音のみにマッチさせるというのがあります。
       </para>
      </listitem>
      <listitem>
       <para>
<!--
        XQuery character class shorthands <literal>\c</literal>,
        <literal>\C</literal>, <literal>\i</literal>,
        and <literal>\I</literal> are not supported.
-->
XQueryの文字クラス短縮形<literal>\c</literal>、<literal>\C</literal>、<literal>\i</literal>、<literal>\I</literal>はサポートされていません。
       </para>
      </listitem>
      <listitem>
       <para>
<!--
        XQuery character class elements
        using <literal>\p{UnicodeProperty}</literal> or the
        inverse <literal>\P{UnicodeProperty}</literal> are not supported.
-->
<literal>\p{UnicodeProperty}</literal>あるいはその逆である<literal>\P{UnicodeProperty}</literal>を使ったXQueryの文字クラス要素はサポートされていません。
       </para>
      </listitem>
      <listitem>
       <para>
<!--
        POSIX interprets character classes such as <literal>\w</literal>
        (see <xref linkend="posix-class-shorthand-escapes-table"/>)
        according to the prevailing locale (which you can control by
        attaching a <literal>COLLATE</literal> clause to the operator or
        function).  XQuery specifies these classes by reference to Unicode
        character properties, so equivalent behavior is obtained only with
        a locale that follows the Unicode rules.
-->
POSIXは有効なロケール（演算子あるいは関数の<literal>COLLATE</literal>句で制御できます）にしたがい、<literal>\w</literal>（<xref linkend="posix-class-shorthand-escapes-table"/>参照）のような文字クラスを解釈します。
XQueryはこれらのクラスをUnicodeの文字属性を参照してこれらのクラスを決定します。
ですからUnicodeルールに従うロケールを使用してのみ同等の振る舞いを得ることができます。
       </para>
      </listitem>
      <listitem>
       <para>
<!--
        The SQL standard (not XQuery itself) attempts to cater for more
        variants of <quote>newline</quote> than POSIX does.  The
        newline-sensitive matching options described above consider only
        ASCII NL (<literal>\n</literal>) to be a newline, but SQL would have
        us treat CR (<literal>\r</literal>), CRLF (<literal>\r\n</literal>)
        (a Windows-style newline), and some Unicode-only characters like
        LINE SEPARATOR (U+2028) as newlines as well.
        Notably, <literal>.</literal> and <literal>\s</literal> should
        count <literal>\r\n</literal> as one character not two according to
        SQL.
-->
標準SQL（XQuery自身ではなく）はPOSIXが提供するより多様な<quote>newline</quote>の亜種を提供しようとしています。
上で述べた改行に敏感なマッチオプションはASCII NL（<literal>\n</literal>）だけを改行として考慮します。
しかしSQLはCR （<literal>\r</literal>）、CRLF （<literal>\r\n</literal>）（Windowsスタイルの改行）、LINE SEPARATOR (U+2028)のようなUnicodeのみの文字も改行として扱うことを求めています。
とりわけ、SQLにおいては、<literal>.</literal>と<literal>\s</literal>は<literal>\r\n</literal>を2文字ではなく、1文字として数える必要があります。
       </para>
      </listitem>
      <listitem>
       <para>
<!--
        Of the character-entry escapes described in
        <xref linkend="posix-character-entry-escapes-table"/>,
        XQuery supports only <literal>\n</literal>, <literal>\r</literal>,
        and <literal>\t</literal>.
-->
<xref linkend="posix-character-entry-escapes-table"/>で示す文字エントリエスケープのうち、XQueryは<literal>\n</literal>、<literal>\r</literal>、<literal>\t</literal>だけをサポートしています。
       </para>
      </listitem>
      <listitem>
       <para>
<!--
        XQuery does not support
        the <literal>[:<replaceable>name</replaceable>:]</literal> syntax
        for character classes within bracket expressions.
-->
XQueryはブラケット式内の文字クラスとして<literal>[:<replaceable>name</replaceable>:]</literal>構文をサポートしていません。
       </para>
      </listitem>
      <listitem>
       <para>
<!--
        XQuery does not have lookahead or lookbehind constraints,
        nor any of the constraint escapes described in
        <xref linkend="posix-constraint-escapes-table"/>.
-->
XQueryには先行検索制約および後方検索制約がありませんし、<xref linkend="posix-constraint-escapes-table"/>に記述された制約エスケープもありません。
       </para>
      </listitem>
      <listitem>
       <para>
<!--
        The metasyntax forms described in <xref linkend="posix-metasyntax"/>
        do not exist in XQuery.
-->
<xref linkend="posix-metasyntax"/>に記述されたメタ構文形式はXQueryには存在しません。
       </para>
      </listitem>
      <listitem>
       <para>
<!--
        The regular expression flag letters defined by XQuery are
        related to but not the same as the option letters for POSIX
        (<xref linkend="posix-embedded-options-table"/>).  While the
        <literal>i</literal> and <literal>q</literal> options behave the
        same, others do not:
-->
XQueryで定義された正規表現フラグ文字はPOSIX（<xref linkend="posix-embedded-options-table"/>）のオプション文字に関連していますが、同じではありません。
<literal>i</literal>と<literal>q</literal>オプションは同じように振る舞いますが、その他は違います。
        <itemizedlist>
         <listitem>
          <para>
<!--
           XQuery's <literal>s</literal> (allow dot to match newline)
           and <literal>m</literal> (allow <literal>^</literal>
           and <literal>$</literal> to match at newlines) flags provide
           access to the same behaviors as
           POSIX's <literal>n</literal>, <literal>p</literal>
           and <literal>w</literal> flags, but they
           do <emphasis>not</emphasis> match the behavior of
           POSIX's <literal>s</literal> and <literal>m</literal> flags.
           Note in particular that dot-matches-newline is the default
           behavior in POSIX but not XQuery.
-->
XQueryの<literal>s</literal>（ピリオドが改行にマッチすることを許容する）と<literal>m</literal>（<literal>^</literal>と<literal>$</literal>が改行位置でマッチすることを許容する）フラグは、POSIXの<literal>n</literal>、<literal>p</literal>、<literal>w</literal>フラグと同じ挙動を提供しますが、POSIXの<literal>s</literal>と<literal>m</literal>フラグの挙動とは一致<emphasis>しません</emphasis>。
ピリオドが改行にマッチするのはPOSIXではデフォルトの挙動ですが、XQueryではそうでないことに留意してください。
          </para>
         </listitem>
         <listitem>
          <para>
<!--
           XQuery's <literal>x</literal> (ignore whitespace in pattern) flag
           is noticeably different from POSIX's expanded-mode flag.
           POSIX's <literal>x</literal> flag also
           allows <literal>#</literal> to begin a comment in the pattern,
           and POSIX will not ignore a whitespace character after a
           backslash.
-->
XQueryの<literal>x</literal>（パターン中の空白を無視する）フラグはPOSIXの拡張モードフラグとは著しく異なります。
POSIXの<literal>x</literal>フラグは<literal>#</literal>でパターン中のコメントを始めることもできます。
POSIXはバックスラッシュ以降の空白文字を無視しません。
          </para>
         </listitem>
        </itemizedlist>
       </para>
      </listitem>
     </itemizedlist>
    </para>

   </sect3>
  </sect2>
 </sect1>

<!-- split-func1-end -->
