<!-- doc/src/sgml/logical-replication.sgml -->

<chapter id="logical-replication">
<!--
 <title>Logical Replication</title>
-->
 <title>論理レプリケーション</title>

 <para>
<!--
  Logical replication is a method of replicating data objects and their
  changes, based upon their replication identity (usually a primary key).  We
  use the term logical in contrast to physical replication, which uses exact
  block addresses and byte-by-byte replication.  PostgreSQL supports both
  mechanisms concurrently, see <xref linkend="high-availability"/>.  Logical
  replication allows fine-grained control over both data replication and
  security.
-->
論理レプリケーションとは、レプリケーションアイデンティティ(replication identity)（通常は主キーです）に基づき、データオブジェクトと、それに対する変更を複製する手法です。
この論理という用語は、正確なブロックアドレスを使い、バイト同士の複製を行う物理レプリケーションと対比的に使用しています。
PostgreSQLは両方の仕組みを同時にサポートします。
<xref linkend="high-availability"/>をご覧ください。
論理レプリケーションにより、データの複製とセキュリティに対するきめの細かい制御が可能になります。
 </para>

 <para>
<!--
  Logical replication uses a <firstterm>publish</firstterm>
  and <firstterm>subscribe</firstterm> model with one or
  more <firstterm>subscribers</firstterm> subscribing to one or more
  <firstterm>publications</firstterm> on a <firstterm>publisher</firstterm>
  node.  Subscribers pull data from the publications they subscribe to and may
  subsequently re-publish data to allow cascading replication or more complex
  configurations.
-->
論理レプリケーションは、ひとつの<firstterm>パブリッシャー(publisher)</firstterm>ノード上の一つ以上の<firstterm>パブリケーション(publications)</firstterm>を購読する一つ以上の<firstterm>サブスクライバー(subscribers)</firstterm>を伴う、<firstterm>パブリッシュ(publish)</firstterm>と<firstterm>サブスクライブ(subscribe)</firstterm>モデルを使用します。
サブスクライバーは、サブスクライブするパブリケーションからデータを取得し、再パブリッシュしてカスケードレプリケーションや、更に複雑な構成を構築することができます。
 </para>

 <para>
<!--
  When logical replication of a table typically starts, PostgreSQL takes
  a snapshot of the table's data on the publisher database and copies it
  to the subscriber.  Once complete, changes on the publisher since the
  initial copy are sent continually to the subscriber.  The subscriber
  applies the data in the same
  order as the publisher so that transactional consistency is guaranteed for
  publications within a single subscription.  This method of data replication
  is sometimes referred to as transactional replication.
-->
通常、テーブルの論理レプリケーションが開始されると、PostgreSQLはパブリッシャーデータベースのテーブルデータのスナップショットを取得し、それをサブスクライバーにコピーします。
完了すると、最初のコピー以降のパブリッシャーの変更がサブスクライバーに継続的に送られます。
そのため、一つのサブスクリプション内のパブリケーションに対するトランザクションの一貫性が保証されます。
この方式によるデータレプリケーションは、トランザクショナルレプリケーション(transactional replication)と呼ばれることがあります。
 </para>

 <para>
<!--
  The typical use-cases for logical replication are:
-->
典型的な論理レプリケーションの利用例には、以下のようなものがあります。

  <itemizedlist>
   <listitem>
    <para>
<!--
     Sending incremental changes in a single database or a subset of a
     database to subscribers as they occur.
-->
一つのデータベース、あるいはデータベースの一部に起こった更新の差分を、発生都度サブスクライバーに送る。
    </para>
   </listitem>

   <listitem>
    <para>
<!--
     Firing triggers for individual changes as they arrive on the
     subscriber.
-->
サブスクライバーに更新が到着した時に、それぞれの更新に対してトリガを起動する。
    </para>
   </listitem>

   <listitem>
    <para>
<!--
     Consolidating multiple databases into a single one (for example for
     analytical purposes).
-->
複数のデータベースを一つのデータベースに統合する。（たとえば分析目的で。）
    </para>
   </listitem>

   <listitem>
    <para>
<!--
     Replicating between different major versions of PostgreSQL.
-->
異なるメジャーバージョンのPostgreSQL間でレプリケーションする。
    </para>
   </listitem>

   <listitem>
    <para>
<!--
     Replicating between PostgreSQL instances on different platforms (for
     example Linux to Windows)
-->
異なるプラットフォーム上のPostgreSQLインスタンス間（たとえばLinuxからWindows）でレプリケーションする。
    </para>
   </listitem>

   <listitem>
    <para>
<!--
     Giving access to replicated data to different groups of users.
-->
異なるユーザのグループに対して、複製されたデータにアクセスさせる。
    </para>
   </listitem>

   <listitem>
    <para>
<!--
     Sharing a subset of the database between multiple databases.
-->
複数のデータベース間でデータベースの一部を共有する。
    </para>
   </listitem>
  </itemizedlist>
 </para>

 <para>
<!--
  The subscriber database behaves in the same way as any other PostgreSQL
  instance and can be used as a publisher for other databases by defining its
  own publications.  When the subscriber is treated as read-only by
  application, there will be no conflicts from a single subscription.  On the
  other hand, if there are other writes done either by an application or by other
  subscribers to the same set of tables, conflicts can arise.
-->
サブスクライバーのデータベースは、他のPostgreSQLインスタンスと同様に振る舞い、自分用のパブリケーションを定義することにより、他のデータベースに対するパブリッシャーとして利用できます。
アプリケーションがそのサブスクライバーを読み取り専用として取り扱うときには、単独のサブスクリプションからはコンフリクトは発生しません。
一方、アプリケーションあるいは他のサブスクライバーから同じテーブルに書き込みが起こるとすると、コンフリクトが発生する可能性があります。
 </para>

 <sect1 id="logical-replication-publication">
<!--
  <title>Publication</title>
-->
  <title>パブリケーション</title>

  <para>
<!--
   A <firstterm>publication</firstterm> can be defined on any physical
   replication primary.  The node where a publication is defined is referred to
   as <firstterm>publisher</firstterm>.  A publication is a set of changes
   generated from a table or a group of tables, and might also be described as
   a change set or replication set.  Each publication exists in only one database.
-->
<firstterm>パブリケーション</firstterm>は、どのような物理レプリケーションのプライマリにも定義できます。
パブリケーションが定義されたノードは、<firstterm>パブリッシャー</firstterm>と呼ばれます。
パブリケーションは、テーブルか、テーブルのグループから生成された更新の集合であると同時に、更新セットあるいはレプリケーションセットであるとも言えます。
一つのパブリケーションは一つのデータベースにのみ存在します。
  </para>

  <para>
<!--
   Publications are different from schemas and do not affect how the table is
   accessed.  Each table can be added to multiple publications if needed.
   Publications may currently only contain tables and all tables in schema.
   Objects must be added explicitly, except when a publication is created for
   <literal>ALL TABLES</literal>.
-->
パブリケーションはスキーマとは異なり、テーブルがどのようにアクセスされるかには影響しません。
必要ならば、テーブルを複数のパブリケーションに追加できます。
今のところパブリケーションはテーブルとスキーマのすべてのテーブルのみを含むことができます。
パブリケーションが<literal>ALL TABLES</literal>で作られた場合を除き、オブジェクトは明示的に追加されなければなりません。
  </para>

  <para>
<!--
   Publications can choose to limit the changes they produce to
   any combination of <command>INSERT</command>, <command>UPDATE</command>,
   <command>DELETE</command>, and <command>TRUNCATE</command>, similar to how triggers are fired by
   particular event types. By default, all operation types are replicated.
   These publication specifications apply only for DML operations; they do not affect the initial
   data synchronization copy. (Row filters have no effect for
   <command>TRUNCATE</command>. See <xref linkend="logical-replication-row-filter"/>).
-->
パブリケーションは、生成される更新を、<command>INSERT</command>、<command>UPDATE</command>、<command>DELETE</command>、<command>TRUNCATE</command>のうちのどのような組み合わせにも制限することができます。
これはトリガが特定のイベント型によって起動されることに似ています。
デフォルトでは、すべての操作タイプがレプリケーションされます。
これらのパブリケーション指定はDML操作にのみ適用され、初期データ同期コピーには影響しません（行フィルタは<command>TRUNCATE</command>には影響しません。<xref linkend="logical-replication-row-filter"/>を参照してください）
  </para>

  <para>
<!--
   Every publication can have multiple subscribers.
-->
すべてのパブリケーションは、複数のサブスクライバーを持つことができます。
  </para>

  <para>
<!--
   A publication is created using the <link linkend="sql-createpublication"><command>CREATE PUBLICATION</command></link>
   command and may later be altered or dropped using corresponding commands.
-->
パブリケーションは、<link linkend="sql-createpublication"><command>CREATE PUBLICATION</command></link>コマンドで作成し、対応するコマンドで変更や削除ができます。
  </para>

  <para>
<!--
   The individual tables can be added and removed dynamically using
   <link linkend="sql-alterpublication"><command>ALTER PUBLICATION</command></link>.  Both the <literal>ADD
   TABLE</literal> and <literal>DROP TABLE</literal> operations are
   transactional, so the table will start or stop replicating at the correct
   snapshot once the transaction has committed.
-->
個々のテーブルは<link linkend="sql-alterpublication"><command>ALTER PUBLICATION</command></link>で動的に追加削除できます。
<literal>ADD TABLE</literal>および<literal>DROP TABLE</literal>操作はトランザクションの対象です。
ひとたびトランザクションがコミットされれば、正しいスナップショットでテーブルのレプリケーションが開始あるいは終了されます。
  </para>

  <sect2 id="logical-replication-publication-replica-identity">
<!--
   <title>Replica Identity</title>
-->
   <title>レプリカアイデンティティ</title>

   <para>
<!--
    A published table must have a <firstterm>replica identity</firstterm>
    configured in order to be able to replicate <command>UPDATE</command>
    and <command>DELETE</command> operations, so that appropriate rows to
    update or delete can be identified on the subscriber side.
-->
パブリッシュされたテーブルは、<command>UPDATE</command>と<command>DELETE</command>をレプリケーションできるようにするために、<firstterm>レプリカアイデンティティ</firstterm>の設定を含んでいなければなりません。
そうすることにより、サブスクライバー側で更新または削除する対象の正しい行が特定できるようになります。
   </para>

   <para>
<!--
    By default, this is the primary key, if there is one. Another unique index
    (with certain additional requirements) can also be set to be the replica
    identity.  If the table does not have any suitable key, then it can be set
    to replica identity <literal>FULL</literal>, which means the entire row
    becomes the key.  When replica identity <literal>FULL</literal> is
    specified, indexes can be used on the subscriber side for searching the
    rows.  Candidate indexes must be btree or hash, non-partial, and the
    leftmost index field must be a column (not an expression) that references
    the published table column.  These restrictions on the non-unique index
    properties adhere to some of the restrictions that are enforced for
    primary keys.  If there are no such suitable indexes, the search on the
    subscriber side can be very inefficient, therefore replica identity
    <literal>FULL</literal> should only be used as a fallback if no other
    solution is possible.
-->
デフォルトでは主キーがあれば、それがレプリカアイデンティティになります。
他に、一意インデックス（追加の要件を伴います）もレプリカアイデンティティにできます。
テーブルに適切なキーがなければ、レプリカアイデンティティを<literal>FULL</literal>にできます。これは、行全体がキーになることを意味します。
レプリカアイデンティティ<literal>FULL</literal>を指定すると、行の検索にサブスクライバー側でインデックスが使えます。
候補となるインデックスはBツリーまたはハッシュでなければならず、部分的であってはなりません。そして、左端のインデックスのフィールドはパブリッシュされたテーブル列を参照する（式でない）列でなければなりません。
一意でないインデックスの属性に関するこれらの制限は、主キーに強制される制限の一部に準拠しています。
そのような適切なインデックスがない場合には、サブスクライバー側での検索は非常に非効率なる可能性があるので、レプリカアイデンティティ<literal>FULL</literal>は他の解決方法がない場合のみの代替手段にすべきです。
   </para>

   <para>
<!--
    If a replica identity other than <literal>FULL</literal> is set on the
    publisher side, a replica identity comprising the same or fewer columns
    must also be set on the subscriber side.
-->
<literal>FULL</literal>以外のレプリカアイデンティティがパブリッシャー側に設定されている場合、同じか、より少ない列を含むレプリカアイデンティティがサブスクライバー側に設定されていなければなりません。
   </para>

   <para>
<!--
    Tables with a replica identity defined as <literal>NOTHING</literal>,
    <literal>DEFAULT</literal> without a primary key, or <literal>USING
    INDEX</literal> with a dropped index, cannot support
    <command>UPDATE</command> or <command>DELETE</command> operations when
    included in a publication replicating these actions. Attempting such
    operations will result in an error on the publisher.
-->
レプリカアイデンティティが<literal>NOTHING</literal>、主キーのない<literal>DEFAULT</literal>、または<literal>USING INDEX</literal>として削除されたインデックスが登録されたテーブルは、<command>UPDATE</command>または<command>DELETE</command>操作をサポートできません。
これらの操作を試みると、パブリッシャーでエラーが報告されます。
   </para>

   <para>
<!--
    <command>INSERT</command> operations can proceed regardless of any replica identity.
-->
<command>INSERT</command>操作は、レプリカアイデンティティの設定に関わらず実行されます。
   </para>

   <para>
<!--
    See <link linkend="sql-altertable-replica-identity"><literal>ALTER TABLE...REPLICA IDENTITY</literal></link>
    for details on how to set the replica identity.
-->
レプリカアイデンティティを設定する詳細な方法については、<link linkend="sql-altertable-replica-identity"><literal>ALTER TABLE...REPLICA IDENTITY</literal></link>をご覧ください。
   </para>
  </sect2>

 </sect1>

 <sect1 id="logical-replication-subscription">
<!--
  <title>Subscription</title>
-->
  <title>サブスクリプション</title>

  <para>
<!--
   A <firstterm>subscription</firstterm> is the downstream side of logical
   replication.  The node where a subscription is defined is referred to as
   the <firstterm>subscriber</firstterm>.  A subscription defines the connection
   to another database and set of publications (one or more) to which it wants
   to subscribe.
-->
<firstterm>サブスクリプション</firstterm>は論理レプリケーションの下流側です。
サブスクリプションが定義されたノードは<firstterm>サブスクライバー</firstterm>として参照されます。
サブスクリプションは他のデータベースへの接続と、サブスクリプション対象の一つ以上のパブリケーションの集合を定義します。
  </para>

  <para>
<!--
   The subscriber database behaves in the same way as any other PostgreSQL
   instance and can be used as a publisher for other databases by defining its
   own publications.
-->
サブスクライバーのデータベースは、他のPostgreSQLインスタンスと同様に振る舞い、自分用のパブリケーションを定義することにより、他のデータベースに対するパブリッシャーとして利用できます。
  </para>

  <para>
<!--
   A subscriber node may have multiple subscriptions if desired.  It is
   possible to define multiple subscriptions between a single
   publisher-subscriber pair, in which case care must be taken to ensure
   that the subscribed publication objects don't overlap.
-->
サブスクライバーノードは、必要ならば複数のサブスクリプションを持つことができます。
一組のパブリッシャーとサブスクライバーの間で複数のサブスクリプションを定義することもできますが、サブスクライブしたパブリケーションオブジェクトが重複しないように注意が必要です。
  </para>

  <para>
<!--
   Each subscription will receive changes via one replication slot (see
   <xref linkend="streaming-replication-slots"/>).  Additional replication
   slots may be required for the initial data synchronization of
   pre-existing table data and those will be dropped at the end of data
   synchronization.
-->
各々のサブスクリプションは、一つのレプリケーションスロット（<xref linkend="streaming-replication-slots"/>を参照）を通じて更新が通知されます。
既存のテーブルデータを初期同期するために、追加でレプリケーションスロットが必要になることもあります。それらはデータ同期の終了時に削除されます。
  </para>

  <para>
<!--
   A logical replication subscription can be a standby for synchronous
   replication (see <xref linkend="synchronous-replication"/>).  The standby
   name is by default the subscription name.  An alternative name can be
   specified as <literal>application_name</literal> in the connection
   information of the subscription.
-->
論理レプリケーションのサブスクリプションは、同期レプリケーション（<xref linkend="synchronous-replication"/>参照）のスタンバイであっても構いません。
スタンバイ名称はデフォルトではサブスクリプション名となります。
サブスクリプションのコネクション情報の中の<literal>application_name</literal>を別の名前として指定することもできます。
  </para>

  <para>
<!--
   Subscriptions are dumped by <command>pg_dump</command> if the current user
   is a superuser.  Otherwise a warning is written and subscriptions are
   skipped, because non-superusers cannot read all subscription information
   from the <structname>pg_subscription</structname> catalog.
-->
現在のユーザがスーパーユーザならば、サブスクリプションは<command>pg_dump</command>でダンプできます。
そうでない場合には、警告が出力され、サブスクリプションはスキップされます。
非スーパーユーザはすべてのサブスクリプション情報を、<structname>pg_subscription</structname>カタログから読み出せないからです。
  </para>

  <para>
<!--
   The subscription is added using <link linkend="sql-createsubscription"><command>CREATE SUBSCRIPTION</command></link> and
   can be stopped/resumed at any time using the
   <link linkend="sql-altersubscription"><command>ALTER SUBSCRIPTION</command></link> command and removed using
   <link linkend="sql-dropsubscription"><command>DROP SUBSCRIPTION</command></link>.
-->
サブスクリプションは<link linkend="sql-createsubscription"><command>CREATE SUBSCRIPTION</command></link>で追加し、<link linkend="sql-altersubscription"><command>ALTER SUBSCRIPTION</command></link>を使って、いつでも停止、再開でき、そして<link linkend="sql-dropsubscription"><command>DROP SUBSCRIPTION</command></link>で削除できます。
  </para>

  <para>
<!--
   When a subscription is dropped and recreated, the synchronization
   information is lost.  This means that the data has to be resynchronized
   afterwards.
-->
サブスクリプションが削除され、そして再作成されると、同期情報は失われます。
このことは、後でデータを再同期しなければならないことを意味します。
  </para>

  <para>
<!--
   The schema definitions are not replicated, and the published tables must
   exist on the subscriber.  Only regular tables may be
   the target of replication.  For example, you can't replicate to a view.
-->
スキーマ定義情報はレプリケーションされないので、パブリッシュするテーブルはサブスクライバーに存在しなければなりません。
通常のテーブルだけがレプリケーションの対象です。
たとえば、ビューはレプリケーションできません。
  </para>

  <para>
<!--
   The tables are matched between the publisher and the subscriber using the
   fully qualified table name.  Replication to differently-named tables on the
   subscriber is not supported.
-->
パブリッシャーとサブスクライバーの間でのテーブルの照合は、完全修飾されたテーブル名に基づいて行われます。
サブスクライバーで異なる名前になっているテーブルに対するレプリケーションは、サポートされていません。
  </para>

  <para>
<!--
   Columns of a table are also matched by name.  The order of columns in the
   subscriber table does not need to match that of the publisher.  The data
   types of the columns do not need to match, as long as the text
   representation of the data can be converted to the target type.  For
   example, you can replicate from a column of type <type>integer</type> to a
   column of type <type>bigint</type>.  The target table can also have
   additional columns not provided by the published table.  Any such columns
   will be filled with the default value as specified in the definition of the
   target table. However, logical replication in binary format is more
   restrictive. See the
   <link linkend="sql-createsubscription-params-with-binary"><literal>binary</literal></link>
   option of <command>CREATE SUBSCRIPTION</command> for details.
-->
テーブルの列も名前で照合されます。
サブスクライバーのテーブルでの列の順序はパブリッシャーと一致している必要はありません。
データのテキスト表現列が対象の型に変換可能である限り、列のデータ型も一致している必要がありません。
例えば、<type>integer</type>型の列から<type>bigint</type>型の列にレプリケーションすることができます。
対象テーブルはパブリッシュされたテーブルにない追加の列を持つこともできます。
そうした列には対象テーブルの定義の指定に従ってデフォルト値が挿入されます。
しかしながら、バイナリ形式の論理レプリケーションはより制限的です。
詳細は、<command>CREATE SUBSCRIPTION</command>の<link linkend="sql-createsubscription-params-with-binary"><literal>binary</literal></link>オプションを参照してください。
  </para>

  <sect2 id="logical-replication-subscription-slot">
<!--
   <title>Replication Slot Management</title>
-->
   <title>レプリケーションスロットの管理</title>

   <para>
<!--
    As mentioned earlier, each (active) subscription receives changes from a
    replication slot on the remote (publishing) side.
-->
前述のように、各々の（有効な）サブスクリプションは、リモート（パブリッシュしている）側のレプリケーションスロットに対する変更を受信します。
   </para>
   <para>
<!--
    Additional table synchronization slots are normally transient, created
    internally to perform initial table synchronization and dropped
    automatically when they are no longer needed. These table synchronization
    slots have generated names: <quote><literal>pg_%u_sync_%u_%llu</literal></quote>
    (parameters: Subscription <parameter>oid</parameter>,
    Table <parameter>relid</parameter>, system identifier <parameter>sysid</parameter>)
-->
追加的なテーブル同期スロットは通常一時的なもので、初期テーブル同期を実行するために内部的に作成され、不要になった時に自動的に削除されます。
これらのテーブル同期スロットには<quote><literal>pg_%u_sync_%u_%llu</literal></quote>（パラメータは、サブスクリプション<parameter>oid</parameter>、テーブル<parameter>relid</parameter>、システム識別子<parameter>sysid</parameter>）という名前が生成されます。
   </para>
   <para>
<!--
    Normally, the remote replication slot is created automatically when the
    subscription is created using <link linkend="sql-createsubscription">
    <command>CREATE SUBSCRIPTION</command></link> and it
    is dropped automatically when the subscription is dropped using
    <link linkend="sql-dropsubscription"><command>DROP SUBSCRIPTION</command></link>.
    In some situations, however, it can
    be useful or necessary to manipulate the subscription and the underlying
    replication slot separately.  Here are some scenarios:
-->
通常、リモートのレプリケーションスロットは<link linkend="sql-createsubscription"><command>CREATE SUBSCRIPTION</command></link>でサブスクリプションが作成されるときに自動的に作成され、サブスクリプションが<link linkend="sql-dropsubscription"><command>DROP SUBSCRIPTION</command></link>で削除されるときに自動的に削除されます。
しかしながら、状況によっては、サブスクリプションとその下にあるレプリケーションスロットを別々に操作することが有用であったり必要であったりします。
以下にいくつかシナリオを示します。

    <itemizedlist>
     <listitem>
      <para>
<!--
       When creating a subscription, the replication slot already exists.  In
       that case, the subscription can be created using
       the <literal>create_slot = false</literal> option to associate with the
       existing slot.
-->
サブスクリプションを作る際、レプリケーションスロットがすでに存在しています。
この場合、<literal>create_slot = false</literal>オプションを使ってサブスクリプションを作成し、既存のスロットと関連付けることができます。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       When creating a subscription, the remote host is not reachable or in an
       unclear state.  In that case, the subscription can be created using
       the <literal>connect = false</literal> option.  The remote host will then not
       be contacted at all.  This is what <application>pg_dump</application>
       uses.  The remote replication slot will then have to be created
       manually before the subscription can be activated.
-->
サブスクリプションを作成する際に、リモートホストが接続できない状態にあるか、不明な状況にあります。
こうした時は、<literal>connect = false</literal>を使ってサブスクリプションを作成することができます。
リモートホストにはまったく接続しません。
これは、<application>pg_dump</application>が使っている方法です。
サブスクリプションを有効にする前に、リモートホストのレプリケーションスロットを手動で作成しなければなりません。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       When dropping a subscription, the replication slot should be kept.
       This could be useful when the subscriber database is being moved to a
       different host and will be activated from there.  In that case,
       disassociate the slot from the subscription using
       <link linkend="sql-altersubscription"><command>ALTER SUBSCRIPTION</command></link>
       before attempting to drop the subscription.
-->
サブスクリプションを削除する際に、レプリケーションスロットを維持する必要があります。
サブスクライバーのデータベースが別のホストに移動中で、移動後にそこからデータベースを起動するときに有効です。
この場合、サブスクリプションを削除する前に、<link linkend="sql-altersubscription"><command>ALTER SUBSCRIPTION</command></link>でそのスロットを切り離します。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       When dropping a subscription, the remote host is not reachable.  In
       that case, disassociate the slot from the subscription
       using <command>ALTER SUBSCRIPTION</command> before attempting to drop
       the subscription.  If the remote database instance no longer exists, no
       further action is then necessary.  If, however, the remote database
       instance is just unreachable, the replication slot (and any still
       remaining table synchronization slots) should then be
       dropped manually; otherwise it/they would continue to reserve WAL and might
       eventually cause the disk to fill up.  Such cases should be carefully
       investigated.
-->
サブスクリプションを削除する際に、リモートホストに接続できません。
この場合、サブスクリプションを削除する前に、<command>ALTER SUBSCRIPTION</command>でそのスロットを切り離しを試みます。
リモートデータベースインスタンスが存在しない場合は、これ以上の操作は必要ありません。
しかし、単にリモートデータベースに接続できない状態ならば、レプリケーションスロット（および、未だ残っている全てのテーブル同期スロット）を手動で削除する必要があります。
そうでなければ、WALが保存され続け、いずれディスクを埋め尽くすかもしれません。
そのような状態は注意深く調査する必要があります。
      </para>
     </listitem>
    </itemizedlist>
   </para>
  </sect2>

  <sect2 id="logical-replication-subscription-examples">
<!--
    <title>Examples: Set Up Logical Replication</title>
-->
    <title>例: 論理レプリケーションの設定</title>

    <para>
<!--
     Create some test tables on the publisher.
-->
パブリッシャーでいくつかテストテーブルを作成します。
<programlisting>
/* pub # */ CREATE TABLE t1(a int, b text, PRIMARY KEY(a));
/* pub # */ CREATE TABLE t2(c int, d text, PRIMARY KEY(c));
/* pub # */ CREATE TABLE t3(e int, f text, PRIMARY KEY(e));
</programlisting></para>

    <para>
<!--
     Create the same tables on the subscriber.
-->
サブスクライバーに同じテーブルを作成します。
<programlisting>
/* sub # */ CREATE TABLE t1(a int, b text, PRIMARY KEY(a));
/* sub # */ CREATE TABLE t2(c int, d text, PRIMARY KEY(c));
/* sub # */ CREATE TABLE t3(e int, f text, PRIMARY KEY(e));
</programlisting></para>

    <para>
<!--
     Insert data to the tables at the publisher side.
-->
パブリッシャー側のテーブルにデータを挿入します。
<programlisting>
/* pub # */ INSERT INTO t1 VALUES (1, 'one'), (2, 'two'), (3, 'three');
/* pub # */ INSERT INTO t2 VALUES (1, 'A'), (2, 'B'), (3, 'C');
/* pub # */ INSERT INTO t3 VALUES (1, 'i'), (2, 'ii'), (3, 'iii');
</programlisting></para>

    <para>
<!--
     Create publications for the tables. The publications <literal>pub2</literal>
     and <literal>pub3a</literal> disallow some
     <link linkend="sql-createpublication-params-with-publish"><literal>publish</literal></link>
     operations. The publication <literal>pub3b</literal> has a row filter (see
     <xref linkend="logical-replication-row-filter"/>).
-->
テーブルのパブリケーションを作成します。
パブリケーション<literal>pub2</literal>と<literal>pub3a</literal>では、一部の<link linkend="sql-createpublication-params-with-publish"><literal>パブリッシュ</literal></link>操作が許可されません。
パブリケーション<literal>pub3b</literal>には行フィルタがあります（<xref linkend="logical-replication-row-filter"/>を参照）。
<programlisting><![CDATA[
/* pub # */ CREATE PUBLICATION pub1 FOR TABLE t1;
/* pub # */ CREATE PUBLICATION pub2 FOR TABLE t2 WITH (publish = 'truncate');
/* pub # */ CREATE PUBLICATION pub3a FOR TABLE t3 WITH (publish = 'truncate');
/* pub # */ CREATE PUBLICATION pub3b FOR TABLE t3 WHERE (e > 5);
]]></programlisting></para>

    <para>
<!--
     Create subscriptions for the publications. The subscription
     <literal>sub3</literal> subscribes to both <literal>pub3a</literal> and
     <literal>pub3b</literal>. All subscriptions will copy initial data by default.
-->
パブリケーションのサブスクリプションを作成します。
サブスクリプション<literal>sub3</literal>は、<literal>pub3a</literal>と<literal>pub3b</literal>の両方をサブスクライブします。
デフォルトでは、すべてのサブスクリプションによって初期データがコピーされます。
<programlisting>
/* sub # */ CREATE SUBSCRIPTION sub1
/* sub - */ CONNECTION 'host=localhost dbname=test_pub application_name=sub1'
/* sub - */ PUBLICATION pub1;
/* sub # */ CREATE SUBSCRIPTION sub2
/* sub - */ CONNECTION 'host=localhost dbname=test_pub application_name=sub2'
/* sub - */ PUBLICATION pub2;
/* sub # */ CREATE SUBSCRIPTION sub3
/* sub - */ CONNECTION 'host=localhost dbname=test_pub application_name=sub3'
/* sub - */ PUBLICATION pub3a, pub3b;
</programlisting></para>

    <para>
<!--
     Observe that initial table data is copied, regardless of the
     <literal>publish</literal> operation of the publication.
-->
パブリケーションの<literal>パブリッシュ</literal>操作に関係なく、初期テーブルデータがコピーされることに注意してください。
<programlisting>
/* sub # */ SELECT * FROM t1;
 a |   b
---+-------
 1 | one
 2 | two
 3 | three
(3 rows)

/* sub # */ SELECT * FROM t2;
 c | d
---+---
 1 | A
 2 | B
 3 | C
(3 rows)
</programlisting></para>

    <para>
<!--
     Furthermore, because the initial data copy ignores the <literal>publish</literal>
     operation, and because publication <literal>pub3a</literal> has no row filter,
     it means the copied table <literal>t3</literal> contains all rows even when
     they do not match the row filter of publication <literal>pub3b</literal>.
-->
さらに、最初のデータコピーでは<literal>パブリッシュ</literal>操作が無視され、パブリケーション<literal>pub3a</literal>には行フィルタがないため、コピーされたテーブル<literal>t3</literal>には、パブリケーション<literal>pub3b</literal>の行フィルタに一致しない場合でもすべての行が含まれていることになります。
<programlisting>
/* sub # */ SELECT * FROM t3;
 e |  f
---+-----
 1 | i
 2 | ii
 3 | iii
(3 rows)
</programlisting></para>

   <para>
<!--
    Insert more data to the tables at the publisher side.
-->
パブリッシャー側のテーブルにさらにデータを挿入します。
<programlisting>
/* pub # */ INSERT INTO t1 VALUES (4, 'four'), (5, 'five'), (6, 'six');
/* pub # */ INSERT INTO t2 VALUES (4, 'D'), (5, 'E'), (6, 'F');
/* pub # */ INSERT INTO t3 VALUES (4, 'iv'), (5, 'v'), (6, 'vi');
</programlisting></para>

   <para>
<!--
    Now the publisher side data looks like:
-->
パブリッシャー側のデータは次のようになります。
<programlisting>
/* pub # */ SELECT * FROM t1;
 a |   b
---+-------
 1 | one
 2 | two
 3 | three
 4 | four
 5 | five
 6 | six
(6 rows)

/* pub # */ SELECT * FROM t2;
 c | d
---+---
 1 | A
 2 | B
 3 | C
 4 | D
 5 | E
 6 | F
(6 rows)

/* pub # */ SELECT * FROM t3;
 e |  f
---+-----
 1 | i
 2 | ii
 3 | iii
 4 | iv
 5 | v
 6 | vi
(6 rows)
</programlisting></para>

   <para>
<!--
    Observe that during normal replication the appropriate
    <literal>publish</literal> operations are used. This means publications
    <literal>pub2</literal> and <literal>pub3a</literal> will not replicate the
    <literal>INSERT</literal>. Also, publication <literal>pub3b</literal> will
    only replicate data that matches the row filter of <literal>pub3b</literal>.
    Now the subscriber side data looks like:
-->
通常のレプリケーションでは、適切な<literal>パブリッシュ</literal>操作が使用されていることに注意してください。
これは、パブリケーション<literal>pub2</literal>および<literal>pub3a</literal>が<literal>INSERT</literal>をレプリケーションしないことを意味します。
また、パブリケーション<literal>pub3b</literal>は<literal>pub3b</literal>の行フィルタに一致するデータのみをレプリケーションします。
サブスクライバー側のデータは次のようになります:
<programlisting>
/* sub # */ SELECT * FROM t1;
 a |   b
---+-------
 1 | one
 2 | two
 3 | three
 4 | four
 5 | five
 6 | six
(6 rows)

/* sub # */ SELECT * FROM t2;
 c | d
---+---
 1 | A
 2 | B
 3 | C
(3 rows)

/* sub # */ SELECT * FROM t3;
 e |  f
---+-----
 1 | i
 2 | ii
 3 | iii
 6 | vi
(4 rows)
</programlisting></para>
  </sect2>

  <sect2 id="logical-replication-subscription-examples-deferred-slot">
<!--
   <title>Examples: Deferred Replication Slot Creation</title>
-->
   <title>例: レプリケーションスロットの遅延作成</title>

   <para>
<!--
    There are some cases (e.g.
    <xref linkend="logical-replication-subscription-slot"/>) where, if the
    remote replication slot was not created automatically, the user must create
    it manually before the subscription can be activated. The steps to create
    the slot and activate the subscription are shown in the following examples.
    These examples specify the standard logical decoding output plugin
    (<literal>pgoutput</literal>), which is what the built-in logical
    replication uses.
-->
リモートレプリケーションスロットが自動的に作成されない場合（例えば<xref linkend="logical-replication-subscription-slot"/>）があり、その場合、サブスクリプションをアクティブにする前に、ユーザが手動で作成しなければなりません。
スロットを作成してサブスクリプションをアクティブにする手順を、次の例に示します。
これらの例では、標準のロジカルデコーディング出力プラグイン（<literal>pgoutput</literal>）を指定しています。これは、組み込みの論理レプリケーションが使用するものです。
   </para>
   <para>
<!--
    First, create a publication for the examples to use.
-->
まず、サンプルで使用するパブリケーションを作成します。
<programlisting>
/* pub # */ CREATE PUBLICATION pub1 FOR ALL TABLES;
</programlisting></para>
   <para>
<!--
    Example 1: Where the subscription says <literal>connect = false</literal>
-->
例1: サブスクリプションが<literal>connect = false</literal>と記述されている場合
   </para>
   <para>
    <itemizedlist>
     <listitem>
      <para>
<!--
       Create the subscription.
-->
サブスクリプションを作成します。
<programlisting>
/* sub # */ CREATE SUBSCRIPTION sub1
/* sub - */ CONNECTION 'host=localhost dbname=test_pub'
/* sub - */ PUBLICATION pub1
/* sub - */ WITH (connect=false);
WARNING:  subscription was created, but is not connected
HINT:  To initiate replication, you must manually create the replication slot, enable the subscription, and refresh the subscription.
</programlisting></para>
     </listitem>
     <listitem>
      <para>
<!--
       On the publisher, manually create a slot. Because the name was not
       specified during <literal>CREATE SUBSCRIPTION</literal>, the name of the
       slot to create is same as the subscription name, e.g. "sub1".
-->
パブリッシャーで、スロットを手動で作成します。
<literal>CREATE SUBSCRIPTION</literal>時に名前が指定されていないため、作成するスロットの名前はサブスクリプション名と同じになります。たとえば、"sub1"です。
<programlisting>
/* pub # */ SELECT * FROM pg_create_logical_replication_slot('sub1', 'pgoutput');
 slot_name |    lsn
-----------+-----------
 sub1      | 0/19404D0
(1 row)
</programlisting></para>
     </listitem>
     <listitem>
      <para>
<!--
       On the subscriber, complete the activation of the subscription. After
       this the tables of <literal>pub1</literal> will start replicating.
-->
サブスクライバーで、サブスクリプションのアクティブ化を完了します。
これにより、<literal>pub1</literal>のテーブルはレプリケーションを開始します。
<programlisting>
/* sub # */ ALTER SUBSCRIPTION sub1 ENABLE;
/* sub # */ ALTER SUBSCRIPTION sub1 REFRESH PUBLICATION;
</programlisting></para>
     </listitem>
    </itemizedlist>
   </para>

   <para>
<!--
    Example 2: Where the subscription says <literal>connect = false</literal>,
    but also specifies the
    <link linkend="sql-createsubscription-params-with-slot-name"><literal>slot_name</literal></link>
    option.
-->
例2: サブスクリプションが<literal>connect = false</literal>と記述されているが、<link linkend="sql-createsubscription-params-with-slot-name"><literal>slot_name</literal></link>オプションも指定されている場合。
    <itemizedlist>
     <listitem>
      <para>
<!--
       Create the subscription.
-->
サブスクリプションを作成します。
<programlisting>
/* sub # */ CREATE SUBSCRIPTION sub1
/* sub - */ CONNECTION 'host=localhost dbname=test_pub'
/* sub - */ PUBLICATION pub1
/* sub - */ WITH (connect=false, slot_name='myslot');
WARNING:  subscription was created, but is not connected
HINT:  To initiate replication, you must manually create the replication slot, enable the subscription, and refresh the subscription.
</programlisting></para>
     </listitem>
     <listitem>
      <para>
<!--
       On the publisher, manually create a slot using the same name that was
       specified during <literal>CREATE SUBSCRIPTION</literal>, e.g. "myslot".
-->
パブリッシャーで、<literal>CREATE SUBSCRIPTION</literal>時に指定したものと同じ名前を使用して、スロットを手動で作成します。例えば、"myslot"です。
<programlisting>
/* pub # */ SELECT * FROM pg_create_logical_replication_slot('myslot', 'pgoutput');
 slot_name |    lsn
-----------+-----------
 myslot    | 0/19059A0
(1 row)
</programlisting></para>
     </listitem>
     <listitem>
      <para>
<!--
       On the subscriber, the remaining subscription activation steps are the
       same as before.
-->
サブスクライバーでは、残りのサブスクリプションのアクティブ化手順は以前と同じです。
<programlisting>
/* sub # */ ALTER SUBSCRIPTION sub1 ENABLE;
/* sub # */ ALTER SUBSCRIPTION sub1 REFRESH PUBLICATION;
</programlisting></para>
     </listitem>
    </itemizedlist>
   </para>

   <para>
<!--
    Example 3: Where the subscription specifies <literal>slot_name = NONE</literal>
-->
例3: サブスクリプションが<literal>slot_name = NONE</literal>を指定している場合
    <itemizedlist>
     <listitem>
      <para>
<!--
       Create the subscription. When <literal>slot_name = NONE</literal> then
       <literal>enabled = false</literal>, and
       <literal>create_slot = false</literal> are also needed.
-->
サブスクリプションを作成します。
 <literal>slot_name = NONE</literal>の場合、<literal>enabled = false</literal>と<literal>create_slot = false</literal>も必要です。
<programlisting>
/* sub # */ CREATE SUBSCRIPTION sub1
/* sub - */ CONNECTION 'host=localhost dbname=test_pub'
/* sub - */ PUBLICATION pub1
/* sub - */ WITH (slot_name=NONE, enabled=false, create_slot=false);
</programlisting></para>
     </listitem>
     <listitem>
      <para>
<!--
       On the publisher, manually create a slot using any name, e.g. "myslot".
-->
パブリッシャーで、"myslot"などの名前を使用してスロットを手動で作成します。
<programlisting>
/* pub # */ SELECT * FROM pg_create_logical_replication_slot('myslot', 'pgoutput');
 slot_name |    lsn
-----------+-----------
 myslot    | 0/1905930
(1 row)
</programlisting></para>
     </listitem>
     <listitem>
      <para>
<!--
       On the subscriber, associate the subscription with the slot name just
       created.
-->
サブスクライバーで、先ほど作成したスロット名にサブスクリプションを関連付けます。
<programlisting>
/* sub # */ ALTER SUBSCRIPTION sub1 SET (slot_name='myslot');
</programlisting></para>
     </listitem>
     <listitem>
      <para>
<!--
       The remaining subscription activation steps are same as before.
-->
残りのサブスクリプションのアクティブ化手順は、以前と同じです。
<programlisting>
/* sub # */ ALTER SUBSCRIPTION sub1 ENABLE;
/* sub # */ ALTER SUBSCRIPTION sub1 REFRESH PUBLICATION;
</programlisting></para>
     </listitem>
    </itemizedlist>
   </para>
  </sect2>

 </sect1>

 <sect1 id="logical-replication-failover">
<!--
  <title>Logical Replication Failover</title>
-->
  <title>論理レプリケーションのフェイルオーバー</title>

  <para>
<!--
   To allow subscriber nodes to continue replicating data from the publisher
   node even when the publisher node goes down, there must be a physical standby
   corresponding to the publisher node. The logical slots on the primary server
   corresponding to the subscriptions can be synchronized to the standby server by
   specifying <literal>failover = true</literal> when creating subscriptions. See
   <xref linkend="logicaldecoding-replication-slots-synchronization"/> for details.
   Enabling the
   <link linkend="sql-createsubscription-params-with-failover"><literal>failover</literal></link>
   parameter ensures a seamless transition of those subscriptions after the
   standby is promoted. They can continue subscribing to publications on the
   new primary server.
-->
パブリッシャーノードがダウンした場合でも、サブスクライバーノードがパブリッシャーノードからのデータの複製を継続できるようにするには、パブリッシャーノードに対応する物理スタンバイが必要です。
サブスクリプションに対応するプライマリサーバの論理スロットは、サブスクリプションの作成時に<literal>failover = true</literal>を指定することで、スタンバイサーバと同期させることができます。
詳細は<xref linkend="logicaldecoding-replication-slots-synchronization"/>を参照してください。
<link linkend="sql-createsubscription-params-with-failover"><literal>failover</literal></link>パラメータを有効にすると、スタンバイ昇格後のサブスクリプションのシームレスな移行が保証されます。
サブスクリプションは新しいプライマリサーバ上のパブリケーションへのサブスクライブを継続できます。
  </para>

  <para>
<!--
   Because the slot synchronization logic copies asynchronously, it is
   necessary to confirm that replication slots have been synced to the standby
   server before the failover happens. To ensure a successful failover, the
   standby server must be ahead of the subscriber. This can be achieved by
   configuring
   <link linkend="guc-synchronized-standby-slots"><varname>synchronized_standby_slots</varname></link>.
-->
スロット同期ロジックは非同期にコピーを行うため、フェイルオーバーが発生する前にレプリケーションスロットがスタンバイサーバに同期されているかを確認する必要があります。
フェイルオーバーの成功を保証するためには、スタンバイサーバはサブスクライバーよりも先行していなければいけません。
これは<link linkend="guc-synchronized-standby-slots"><varname>synchronized_standby_slots</varname></link>を設定することで実現できます。
  </para>

  <para>
<!--
   To confirm that the standby server is indeed ready for failover for a given subscriber, follow these
   steps to verify that all the logical replication slots required by that subscriber have been
   synchronized to the standby server:
-->
スタンバイサーバがフェイルオーバーの準備ができていることを確認するためには、次の手順に従って、サブスクライバーに必要なすべての論理レプリケーションスロットがスタンバイサーバと同期されていることを検証します。
  </para>

  <procedure>
   <step performance="required">
    <para>
<!--
     On the subscriber node, use the following SQL to identify which replication
     slots should be synced to the standby that we plan to promote. This query
     will return the relevant replication slots associated with the
     failover-enabled subscriptions.
-->
サブスクライバーノードで、次のSQLを使用して、昇格する予定のスタンバイに同期する必要があるレプリケーションスロットを特定します。
このクエリは、フェイルオーバーが有効になっているサブスクリプションと関連付けられている、関連するレプリケーションスロットを返します。
<programlisting>
/* sub # */ SELECT
               array_agg(quote_literal(s.subslotname)) AS slots
           FROM  pg_subscription s
           WHERE s.subfailover AND
                 s.subslotname IS NOT NULL;
 slots
-------
 {'sub1','sub2','sub3'}
(1 row)
</programlisting></para>
   </step>
   <step performance="required">
    <para>
<!--
     On the subscriber node, use the following SQL to identify which table
     synchronization slots should be synced to the standby that we plan to promote.
     This query needs to be run on each database that includes the failover-enabled
     subscription(s). Note that the table sync slot should be synced to the standby
     server only if the table copy is finished
     (See <xref linkend="catalog-pg-subscription-rel"/>).
     We don't need to ensure that the table sync slots are synced in other scenarios
     as they will either be dropped or re-created on the new primary server in those
     cases.
-->
サブスクライバーノードで、次のSQLを使用して、昇格する予定のスタンバイに同期する必要があるテーブル同期スロットを特定します。
このクエリは、フェイルオーバーが有効になっているサブスクリプションを持つ各データベースで実行する必要があります。
テーブル同期スロットは、テーブル同期が終了している場合にのみ同期されることに注意してください（<xref linkend="catalog-pg-subscription-rel"/>を参照）。
その他の場合では、テーブル同期スロットが同期されることを保証する必要はありません。これらは破棄されるか、新しいプライマリサーバで再作成されるためです。
<programlisting>
/* sub # */ SELECT
               array_agg(quote_literal(slot_name)) AS slots
           FROM
           (
               SELECT CONCAT('pg_', srsubid, '_sync_', srrelid, '_', ctl.system_identifier) AS slot_name
               FROM pg_control_system() ctl, pg_subscription_rel r, pg_subscription s
               WHERE r.srsubstate = 'f' AND s.oid = r.srsubid AND s.subfailover
           );
 slots
-------
 {'pg_16394_sync_16385_7394666715149055164'}
(1 row)
</programlisting></para>
   </step>
   <step performance="required">
    <para>
<!--
     Check that the logical replication slots identified above exist on
     the standby server and are ready for failover.
-->
上記で特定した論理レプリケーションスロットがスタンバイに存在し、フェイルオーバーの準備ができていることを確認します。
<programlisting>
/* standby # */ SELECT slot_name, (synced AND NOT temporary AND invalidation_reason IS NULL) AS failover_ready
               FROM pg_replication_slots
               WHERE slot_name IN
                   ('sub1','sub2','sub3', 'pg_16394_sync_16385_7394666715149055164');
  slot_name                                 | failover_ready
--------------------------------------------+----------------
  sub1                                      | t
  sub2                                      | t
  sub3                                      | t
  pg_16394_sync_16385_7394666715149055164   | t
(4 rows)
</programlisting></para>
    </step>
  </procedure>

  <para>
<!--
   If all the slots are present on the standby server and the result
   (<literal>failover_ready</literal>) of the above SQL query is true, then
   existing subscriptions can continue subscribing to publications on the new
   primary server.
-->
すべてのスロットがスタンバイサーバに存在し、上記のSQLクエリの結果（<literal>failover_ready</literal>）が真である場合、既存のサブスクリプションは、新しいプライマリサーバ上のパブリケーションへのサブスクライブを継続できます。
  </para>

  <para>
<!--
   The first two steps in the above procedure are meant for a
   <productname>PostgreSQL</productname> subscriber. It is recommended to run
   these steps on each subscriber node, that will be served by the designated
   standby after failover, to obtain the complete list of replication
   slots. This list can then be verified in Step 3 to ensure failover readiness.
   Non-<productname>PostgreSQL</productname> subscribers, on the other hand, may
   use their own methods to identify the replication slots used by their
   respective subscriptions.
-->
前述の手続きのうち最初の2つの手順は、<productname>PostgreSQL</productname>サブスクライバーを対象としています。
これらの手順は、フェイルオーバーの後に指定されたスタンバイに接続する各サブスクライバーノード上で実行することをお勧めします。これにより、レプリケーションスロットの完全なリストを取得できます。
このリストはフェイルオーバーの準備状況の確認のため、手順3で検証されます
一方、非<productname>PostgreSQL</productname>サブスクライバーは、独自の方法を使用して、それぞれのサブスクリプションで使用されるレプリケーションスロットを識別できます。
  </para>

  <para>
<!--
   In some cases, such as during a planned failover, it is necessary to confirm
   that all subscribers, whether <productname>PostgreSQL</productname> or
   non-<productname>PostgreSQL</productname>, will be able to continue
   replication after failover to a given standby server. In such cases, use the
   following SQL, instead of performing the first two steps above, to identify
   which replication slots on the primary need to be synced to the standby that
   is intended for promotion. This query returns the relevant replication slots
   associated with all the failover-enabled subscriptions.
-->
計画的なフェイルオーバー中など、場合によっては、<productname>PostgreSQL</productname>または非<productname>PostgreSQL</productname>のすべてのサブスクライバーが、特定のスタンバイサーバへのフェイルオーバーの後にレプリケーションを継続できることを確認する必要があります。
このような場合は、最初の2つの手順の代わりに以下のSQLを使用して、プライマリ上のどのレプリケーションスロットを昇格対象のスタンバイに同期する必要があるかを特定します。
この問い合わせは、すべてのフェイルオーバーが有効なサブスクリプションに紐づけられた関連するレプリケーションスロットを返します。
  </para>

   <para>
<programlisting>
/* primary # */ SELECT array_agg(quote_literal(r.slot_name)) AS slots
               FROM pg_replication_slots r
               WHERE r.failover AND NOT r.temporary;
 slots
-------
 {'sub1','sub2','sub3', 'pg_16394_sync_16385_7394666715149055164'}
(1 row)
</programlisting></para>
 </sect1>

 <sect1 id="logical-replication-row-filter">
<!--
  <title>Row Filters</title>
-->
  <title>行フィルタ</title>

  <para>
<!--
   By default, all data from all published tables will be replicated to the
   appropriate subscribers. The replicated data can be reduced by using a
   <firstterm>row filter</firstterm>. A user might choose to use row filters
   for behavioral, security or performance reasons. If a published table sets a
   row filter, a row is replicated only if its data satisfies the row filter
   expression. This allows a set of tables to be partially replicated. The row
   filter is defined per table. Use a <literal>WHERE</literal> clause after the
   table name for each published table that requires data to be filtered out.
   The <literal>WHERE</literal> clause must be enclosed by parentheses. See
   <xref linkend="sql-createpublication"/> for details.
-->
デフォルトでは、すべてのパブリッシュされたテーブルのすべてのデータが適切なサブスクライバーにレプリケーションされます。
レプリケーションされたデータは、<firstterm>行フィルタ</firstterm>を使用して削減できます。
ユーザは、動作、セキュリティまたはパフォーマンス上の理由で行フィルタの使用を選択できます。
パブリッシュされたテーブルに行フィルタが設定されている場合、行はそのデータが行フィルタ式を満たす場合にのみレプリケーションされます。
これにより、一連のテーブルを部分的にレプリケーションできます。
行フィルタはテーブルごとに定義されます。
データのフィルタ処理が必要なパブリッシュされたテーブルごとに、テーブル名の後に<literal>WHERE</literal>句を使用します。
<literal>WHERE</literal>句はカッコで囲む必要があります。
詳細は<xref linkend="sql-createpublication"/>を参照してください。
  </para>

  <sect2 id="logical-replication-row-filter-rules">
<!--
   <title>Row Filter Rules</title>
-->
   <title>行フィルタルール</title>

   <para>
<!--
    Row filters are applied <emphasis>before</emphasis> publishing the changes.
    If the row filter evaluates to <literal>false</literal> or <literal>NULL</literal>
    then the row is not replicated. The <literal>WHERE</literal> clause expression
    is evaluated with the same role used for the replication connection (i.e.
    the role specified in the
    <link linkend="sql-createsubscription-params-connection"><literal>CONNECTION</literal></link>
    clause of the <xref linkend="sql-createsubscription"/>). Row filters have
    no effect for <command>TRUNCATE</command> command.
-->
行フィルタは、<emphasis>変更を発行する前に</emphasis>適用されます。
行フィルタが<literal>false</literal>または<literal>NULL</literal>と評価される場合、行はレプリケーションされません。
<literal>WHERE</literal>句の式は、レプリケーション接続に使用されるロールと同じロール(<xref linkend="sql-createsubscription"/>の<link linkend="sql-createsubscription-params-connection"><literal>CONNECTION</literal></link>句で指定されたロール)で評価されます。
<command>TRUNCATE</command>コマンドに対しては、行フィルタは無効です。
   </para>

  </sect2>

  <sect2 id="logical-replication-row-filter-restrictions">
<!--
   <title>Expression Restrictions</title>
-->
   <title>式の制限</title>

   <para>
<!--
    The <literal>WHERE</literal> clause allows only simple expressions. It
    cannot contain user-defined functions, operators, types, and collations,
    system column references or non-immutable built-in functions.
-->
<literal>WHERE</literal>句では単純な式のみを使用できます。
ユーザ定義関数、演算子、型、照合、システム列参照、不変でない組み込み関数は使用できません。
   </para>

   <para>
<!--
    If a publication publishes <command>UPDATE</command> or
    <command>DELETE</command> operations, the row filter <literal>WHERE</literal>
    clause must contain only columns that are covered by the replica identity
    (see <xref linkend="sql-altertable-replica-identity"/>). If a publication
    publishes only <command>INSERT</command> operations, the row filter
    <literal>WHERE</literal> clause can use any column.
-->
パブリケーションが<command>UPDATE</command>または<command>DELETE</command>操作をパブリッシュする場合、行フィルタ<literal>WHERE</literal>句には、レプリカアイデンティティの対象となる列のみを含める必要があります(<xref linkend="sql-altertable-replica-identity"/>を参照)。
パブリケーションが<command>INSERT</command>操作のみをパブリッシュする場合、行フィルタ<literal>WHERE</literal>句は任意の列を使用できます。
   </para>

  </sect2>

  <sect2 id="logical-replication-row-filter-transformations">
<!--
   <title>UPDATE Transformations</title>
-->
   <title>UPDATE変換</title>

   <para>
<!--
    Whenever an <command>UPDATE</command> is processed, the row filter
    expression is evaluated for both the old and new row (i.e. using the data
    before and after the update). If both evaluations are <literal>true</literal>,
    it replicates the <command>UPDATE</command> change. If both evaluations are
    <literal>false</literal>, it doesn't replicate the change. If only one of
    the old/new rows matches the row filter expression, the <command>UPDATE</command>
    is transformed to <command>INSERT</command> or <command>DELETE</command>, to
    avoid any data inconsistency. The row on the subscriber should reflect what
    is defined by the row filter expression on the publisher.
-->
<command>UPDATE</command>が処理されるたびに、行フィルタ式は古い行と新しい行の両方に対して評価されます(つまり、更新前後のデータを使用します)。
両方の評価が<literal>true</literal>の場合、<command>UPDATE</command>変更がレプリケーションされます。
両方の評価が<literal>false</literal>の場合、変更はレプリケーションされません。
古い行と新しい行のいずれか1つのみが行フィルタ式に一致する場合、データの不整合を回避するために<command>UPDATE</command>が<command>INSERT</command>または<command>DELETE</command>に変換されます。
サブスクライバーの行は、パブリッシャーの行フィルタ式で定義されている内容を反映する必要があります。
   </para>

   <para>
<!--
    If the old row satisfies the row filter expression (it was sent to the
    subscriber) but the new row doesn't, then, from a data consistency
    perspective the old row should be removed from the subscriber.
    So the <command>UPDATE</command> is transformed into a <command>DELETE</command>.
-->
古い行が行フィルタ式を満たしていて(サブスクライバーに送信された)、新しい行が満たさない場合、データの整合性の観点から、古い行はサブスクライバーから削除される必要があります。
したがって、<command>UPDATE</command>は<command>DELETE</command>に変換されます。
   </para>

   <para>
<!--
    If the old row doesn't satisfy the row filter expression (it wasn't sent
    to the subscriber) but the new row does, then, from a data consistency
    perspective the new row should be added to the subscriber.
    So the <command>UPDATE</command> is transformed into an <command>INSERT</command>.
-->
古い行が行フィルタ式を満たさず(サブスクライバーに送信されなかった)、新しい行がそれを満たす場合は、データの整合性の観点から、新しい行をサブスクライバーに追加する必要があります。
したがって、<command>UPDATE</command>は<command>INSERT</command>に変換されます。
   </para>

   <para>
<!--
    <xref linkend="logical-replication-row-filter-transformations-summary"/>
    summarizes the applied transformations.
-->
<xref linkend="logical-replication-row-filter-transformations-summary"/>は、適用された変換を要約します。
   </para>

   <table id="logical-replication-row-filter-transformations-summary">
<!--
    <title><command>UPDATE</command> Transformation Summary</title>
-->
    <title><command>UPDATE</command>変換要約</title>
    <tgroup cols="3">
    <thead>
     <row>
<!--
      <entry>Old row</entry><entry>New row</entry><entry>Transformation</entry>
-->
      <entry>古い行</entry><entry>新しい行</entry><entry>変換</entry>
     </row>
    </thead>
    <tbody>
     <row>
<!--
      <entry>no match</entry><entry>no match</entry><entry>don't replicate</entry>
-->
      <entry>一致せず</entry><entry>一致せず</entry><entry>レプリケーションしない</entry>
     </row>
     <row>
<!--
      <entry>no match</entry><entry>match</entry><entry><literal>INSERT</literal></entry>
-->
      <entry>一致せず</entry><entry>一致</entry><entry><literal>INSERT</literal></entry>
     </row>
     <row>
<!--
      <entry>match</entry><entry>no match</entry><entry><literal>DELETE</literal></entry>
-->
      <entry>一致</entry><entry>一致せず</entry><entry><literal>DELETE</literal></entry>
     </row>
     <row>
<!--
      <entry>match</entry><entry>match</entry><entry><literal>UPDATE</literal></entry>
-->
      <entry>一致</entry><entry>一致</entry><entry><literal>UPDATE</literal></entry>
     </row>
    </tbody>
   </tgroup>
   </table>

  </sect2>

  <sect2 id="logical-replication-row-filter-partitioned-table">
<!--
   <title>Partitioned Tables</title>
-->
   <title>パーティション化テーブル</title>

   <para>
<!--
    If the publication contains a partitioned table, the publication parameter
    <link linkend="sql-createpublication-params-with-publish-via-partition-root"><literal>publish_via_partition_root</literal></link>
    determines which row filter is used. If <literal>publish_via_partition_root</literal>
    is <literal>true</literal>, the <emphasis>root partitioned table's</emphasis>
    row filter is used. Otherwise, if <literal>publish_via_partition_root</literal>
    is <literal>false</literal> (default), each <emphasis>partition's</emphasis>
    row filter is used.
-->
パブリケーションにパーティション化テーブルが含まれている場合、パブリケーションパラメータ<link linkend="sql-createpublication-params-with-publish-via-partition-root"><literal>publish_via_partition_root</literal></link>によって使用される行フィルタが決定されます。
<literal>publish_via_partition_root</literal>が<literal>true</literal>の場合、<emphasis>ルートのパーティション化テーブルの</emphasis>行フィルタが使用されます。
それ以外の場合、<literal>publish_via_partition_root</literal>が<literal>false</literal>(デフォルト)の場合、<emphasis>パーティションの</emphasis>行フィルタがそれぞれ使用されます。
   </para>

  </sect2>

  <sect2 id="logical-replication-row-filter-initial-data-sync">
<!--
   <title>Initial Data Synchronization</title>
-->
   <title>初期データ同期</title>

   <para>
<!--
    If the subscription requires copying pre-existing table data
    and a publication contains <literal>WHERE</literal> clauses, only data that
    satisfies the row filter expressions is copied to the subscriber.
-->
サブスクリプションで既存のテーブルデータをコピーする必要があり、パブリケーションに<literal>WHERE</literal>句が含まれている場合、行フィルタ式を満たすデータのみがサブスクライバーにコピーされます。
   </para>

   <para>
<!--
    If the subscription has several publications in which a table has been
    published with different <literal>WHERE</literal> clauses, rows that satisfy
    <emphasis>any</emphasis> of the expressions will be copied. See
    <xref linkend="logical-replication-row-filter-combining"/> for details.
-->
サブスクリプションに複数のパブリケーションがあり、テーブルが異なる<literal>WHERE</literal>句でパブリッシュされている場合は、式の<emphasis>any</emphasis>を満たす行がコピーされます。
詳細は<xref linkend="logical-replication-row-filter-combining"/>を参照してください。
   </para>

   <warning>
    <para>
<!--
     Because initial data synchronization does not take into account the
     <link linkend="sql-createpublication-params-with-publish"><literal>publish</literal></link>
     parameter when copying existing table data, some rows may be copied that
     would not be replicated using DML. Refer to
     <xref linkend="logical-replication-snapshot"/>, and see
     <xref linkend="logical-replication-subscription-examples"/> for examples.
-->
初期データ同期では、既存のテーブルデータをコピーする際に<link linkend="sql-createpublication-params-with-publish"><literal>publish</literal></link>パラメータが考慮されないため、DMLを使用してレプリケーションされない行がコピーされる場合があります。
<xref linkend="logical-replication-snapshot"/>および<xref linkend="logical-replication-subscription-examples"/>の例を参照してください。
    </para>
   </warning>

   <note>
    <para>
<!--
     If the subscriber is in a release prior to 15, copy pre-existing data
     doesn't use row filters even if they are defined in the publication.
     This is because old releases can only copy the entire table data.
-->
サブスクライバーが15より前のリリースにある場合、既存のデータのコピーでは、パブリケーションで定義されていても行フィルタは使用されません。
これは、古いリリースではテーブルデータ全体しかコピーできないためです。
    </para>
   </note>

  </sect2>

  <sect2 id="logical-replication-row-filter-combining">
<!--
   <title>Combining Multiple Row Filters</title>
-->
   <title>複数行フィルタの統合</title>

   <para>
<!--
    If the subscription has several publications in which the same table has
    been published with different row filters (for the same
    <link linkend="sql-createpublication-params-with-publish"><literal>publish</literal></link>
    operation), those expressions get ORed together, so that rows satisfying
    <emphasis>any</emphasis> of the expressions will be replicated. This means all
    the other row filters for the same table become redundant if:
-->
サブスクリプションに複数のパブリケーションがあり、その中で同じテーブルが異なる行フィルタを使用してパブリッシュされている場合（同じ<link linkend="sql-createpublication-params-with-publish"><literal>パブリッシュ</literal></link>操作の場合）、これらの式はOR結合され、式の<emphasis>いずれか</emphasis>を満たす行がレプリケーションされます。
これは、次の場合、同じテーブルの他のすべての行フィルタが冗長になることを意味します。
    <itemizedlist>
     <listitem>
      <para>
<!--
       One of the publications has no row filter.
-->
パブリケーションの１つに行フィルタがない。
      </para>
     </listitem>
     <listitem>
      <para>
<!--
       One of the publications was created using
       <link linkend="sql-createpublication-params-for-all-tables"><literal>FOR ALL TABLES</literal></link>.
       This clause does not allow row filters.
-->
パブリケーションの1つが<link linkend="sql-createpublication-params-for-all-tables"><literal>FOR ALL TABLES</literal></link>を使用して作成された。
この句では行フィルタを使用できません。
      </para>
     </listitem>
     <listitem>
      <para>
<!--
       One of the publications was created using
       <link linkend="sql-createpublication-params-for-tables-in-schema"><literal>FOR TABLES IN SCHEMA</literal></link>
       and the table belongs to the referred schema. This clause does not allow
       row filters.
-->
パブリケーションの1つが<link linkend="sql-createpublication-params-for-tables-in-schema"><literal>FOR TABLES IN SCHEMA</literal></link>を使用して作成され、テーブルは参照されたスキーマに属している。
この句では、行フィルタは使用できません。
      </para>
     </listitem>
    </itemizedlist></para>

  </sect2>

  <sect2 id="logical-replication-row-filter-examples">
<!--
   <title>Examples</title>
-->
   <title>例</title>

   <para>
<!--
    Create some tables to be used in the following examples.
-->
次の例で使用するテーブルをいくつか作成します。
<programlisting>
/* pub # */ CREATE TABLE t1(a int, b int, c text, PRIMARY KEY(a,c));
/* pub # */ CREATE TABLE t2(d int, e int, f int, PRIMARY KEY(d));
/* pub # */ CREATE TABLE t3(g int, h int, i int, PRIMARY KEY(g));
</programlisting></para>

   <para>
<!--
    Create some publications. Publication <literal>p1</literal> has one table
    (<literal>t1</literal>) and that table has a row filter. Publication
    <literal>p2</literal> has two tables. Table <literal>t1</literal> has no row
    filter, and table <literal>t2</literal> has a row filter. Publication
    <literal>p3</literal> has two tables, and both of them have a row filter.
-->
いくつかのパブリケーションを作成します。
パブリケーション<literal>p1</literal>には1つのテーブル<literal>t1</literal>があり、そのテーブルには行フィルタがあります。
パブリケーション<literal>p2</literal>には2つのテーブルがあります。
テーブル<literal>t1</literal>には行フィルタがなく、テーブル<literal>t2</literal>には行フィルタがあります。
パブリケーション<literal>p3</literal>には2つのテーブルがあり、両方に行フィルタがあります。
<programlisting><![CDATA[
/* pub # */ CREATE PUBLICATION p1 FOR TABLE t1 WHERE (a > 5 AND c = 'NSW');
/* pub # */ CREATE PUBLICATION p2 FOR TABLE t1, t2 WHERE (e = 99);
/* pub # */ CREATE PUBLICATION p3 FOR TABLE t2 WHERE (d = 10), t3 WHERE (g = 10);
]]></programlisting></para>

   <para>
<!--
    <command>psql</command> can be used to show the row filter expressions (if
    defined) for each publication.
-->
<command>psql</command>を使用して、各パブリケーションの行フィルタ式（定義されている場）を表示することができます。
<programlisting><![CDATA[
/* pub # */ \dRp+
                                         Publication p1
  Owner   | All tables | Inserts | Updates | Deletes | Truncates | Generated columns | Via root
----------+------------+---------+---------+---------+-----------+-------------------+----------
 postgres | f          | t       | t       | t       | t         | none              | f
Tables:
    "public.t1" WHERE ((a > 5) AND (c = 'NSW'::text))

                                         Publication p2
  Owner   | All tables | Inserts | Updates | Deletes | Truncates | Generated columns | Via root
----------+------------+---------+---------+---------+-----------+-------------------+----------
 postgres | f          | t       | t       | t       | t         | none              | f
Tables:
    "public.t1"
    "public.t2" WHERE (e = 99)

                                         Publication p3
  Owner   | All tables | Inserts | Updates | Deletes | Truncates | Generated columns | Via root
----------+------------+---------+---------+---------+-----------+-------------------+----------
 postgres | f          | t       | t       | t       | t         | none              | f
Tables:
    "public.t2" WHERE (d = 10)
    "public.t3" WHERE (g = 10)
]]></programlisting></para>

   <para>
<!--
    <command>psql</command> can be used to show the row filter expressions (if
    defined) for each table. See that table <literal>t1</literal> is a member
    of two publications, but has a row filter only in <literal>p1</literal>.
    See that table <literal>t2</literal> is a member of two publications, and
    has a different row filter in each of them.
-->
<command>psql</command>を使用して、各テーブルの行フィルタ式（定義されている場合）を表示できます。
テーブル<literal>t1</literal>は2つのパブリケーションのメンバですが、<literal>p1</literal>にのみ行フィルタがあります。
テーブル<literal>t2</literal>は2つのパブリケーションのメンバですが、それぞれに異なる行フィルタがあります。
<programlisting><![CDATA[
/* pub # */ \d t1
                 Table "public.t1"
 Column |  Type   | Collation | Nullable | Default
--------+---------+-----------+----------+---------
 a      | integer |           | not null |
 b      | integer |           |          |
 c      | text    |           | not null |
Indexes:
    "t1_pkey" PRIMARY KEY, btree (a, c)
Publications:
    "p1" WHERE ((a > 5) AND (c = 'NSW'::text))
    "p2"

/* pub # */ \d t2
                 Table "public.t2"
 Column |  Type   | Collation | Nullable | Default
--------+---------+-----------+----------+---------
 d      | integer |           | not null |
 e      | integer |           |          |
 f      | integer |           |          |
Indexes:
    "t2_pkey" PRIMARY KEY, btree (d)
Publications:
    "p2" WHERE (e = 99)
    "p3" WHERE (d = 10)

/* pub # */ \d t3
                 Table "public.t3"
 Column |  Type   | Collation | Nullable | Default
--------+---------+-----------+----------+---------
 g      | integer |           | not null |
 h      | integer |           |          |
 i      | integer |           |          |
Indexes:
    "t3_pkey" PRIMARY KEY, btree (g)
Publications:
    "p3" WHERE (g = 10)
]]></programlisting></para>

   <para>
<!--
    On the subscriber node, create a table <literal>t1</literal> with the same
    definition as the one on the publisher, and also create the subscription
    <literal>s1</literal> that subscribes to the publication <literal>p1</literal>.
-->
サブスクライバーノードで、パブリッシャーと同じ定義のテーブル<literal>t1</literal>を作成し、パブリケーション<literal>p1</literal>をサブスクライブするサブスクリプション<literal>s1</literal>も作成します。
<programlisting>
/* sub # */ CREATE TABLE t1(a int, b int, c text, PRIMARY KEY(a,c));
/* sub # */ CREATE SUBSCRIPTION s1
/* sub - */ CONNECTION 'host=localhost dbname=test_pub application_name=s1'
/* sub - */ PUBLICATION p1;
</programlisting></para>

   <para>
<!--
    Insert some rows. Only the rows satisfying the <literal>t1 WHERE</literal>
    clause of publication <literal>p1</literal> are replicated.
-->
いくつかの行を挿入します。
パブリケーション<literal>p1</literal>の<literal>t1 WHERE</literal>句を満たす行のみがレプリケーションされます。
<programlisting>
/* pub # */ INSERT INTO t1 VALUES (2, 102, 'NSW');
/* pub # */ INSERT INTO t1 VALUES (3, 103, 'QLD');
/* pub # */ INSERT INTO t1 VALUES (4, 104, 'VIC');
/* pub # */ INSERT INTO t1 VALUES (5, 105, 'ACT');
/* pub # */ INSERT INTO t1 VALUES (6, 106, 'NSW');
/* pub # */ INSERT INTO t1 VALUES (7, 107, 'NT');
/* pub # */ INSERT INTO t1 VALUES (8, 108, 'QLD');
/* pub # */ INSERT INTO t1 VALUES (9, 109, 'NSW');

/* pub # */ SELECT * FROM t1;
 a |  b  |  c
---+-----+-----
 2 | 102 | NSW
 3 | 103 | QLD
 4 | 104 | VIC
 5 | 105 | ACT
 6 | 106 | NSW
 7 | 107 | NT
 8 | 108 | QLD
 9 | 109 | NSW
(8 rows)
</programlisting>
<programlisting>
/* sub # */ SELECT * FROM t1;
 a |  b  |  c
---+-----+-----
 6 | 106 | NSW
 9 | 109 | NSW
(2 rows)
</programlisting></para>

   <para>
<!--
    Update some data, where the old and new row values both
    satisfy the <literal>t1 WHERE</literal> clause of publication
    <literal>p1</literal>. The <command>UPDATE</command> replicates
    the change as normal.
-->
古い行の値と新しい行の値の両方がパブリケーション<literal>p1</literal>の<literal>t1 WHERE</literal>句を満たすデータを更新します。
<command>UPDATE</command>は、通常のように変更をレプリケーションします。
<programlisting>
/* pub # */ UPDATE t1 SET b = 999 WHERE a = 6;

/* pub # */ SELECT * FROM t1;
 a |  b  |  c
---+-----+-----
 2 | 102 | NSW
 3 | 103 | QLD
 4 | 104 | VIC
 5 | 105 | ACT
 7 | 107 | NT
 8 | 108 | QLD
 9 | 109 | NSW
 6 | 999 | NSW
(8 rows)
</programlisting>
<programlisting>
/* sub # */ SELECT * FROM t1;
 a |  b  |  c
---+-----+-----
 9 | 109 | NSW
 6 | 999 | NSW
(2 rows)
</programlisting></para>

   <para>
<!--
    Update some data, where the old row values did not satisfy
    the <literal>t1 WHERE</literal> clause of publication <literal>p1</literal>,
    but the new row values do satisfy it. The <command>UPDATE</command> is
    transformed into an <command>INSERT</command> and the change is replicated.
    See the new row on the subscriber.
-->
古い行の値はパブリケーション<literal>p1</literal>の<literal>t1 WHERE</literal>句を満たしていませんが、新しい行の値はこの句を満たしているデータを更新します。
<command>UPDATE</command>は<command>INSERT</command>に変換され、変更がレプリケーションされます。
サブスクライバーの新しい行を参照してください。
<programlisting>
/* pub # */ UPDATE t1 SET a = 555 WHERE a = 2;

/* pub # */ SELECT * FROM t1;
  a  |  b  |  c
-----+-----+-----
   3 | 103 | QLD
   4 | 104 | VIC
   5 | 105 | ACT
   7 | 107 | NT
   8 | 108 | QLD
   9 | 109 | NSW
   6 | 999 | NSW
 555 | 102 | NSW
(8 rows)
</programlisting>
<programlisting>
/* sub # */ SELECT * FROM t1;
  a  |  b  |  c
-----+-----+-----
   9 | 109 | NSW
   6 | 999 | NSW
 555 | 102 | NSW
(3 rows)
</programlisting></para>

   <para>
<!--
    Update some data, where the old row values satisfied
    the <literal>t1 WHERE</literal> clause of publication <literal>p1</literal>,
    but the new row values do not satisfy it. The <command>UPDATE</command> is
    transformed into a <command>DELETE</command> and the change is replicated.
    See that the row is removed from the subscriber.
-->
古い行の値がパブリケーション<literal>p1</literal>の<literal>t1 WHERE</literal>句を満たしていますが、新しい行の値がこの句を満たしていないデータを更新します。
<command>UPDATE</command>は<command>DELETE</command>に変換され、変更がレプリケーションされます。
行がサブスクライバーから削除されていることを確認します。
<programlisting>
/* pub # */ UPDATE t1 SET c = 'VIC' WHERE a = 9;

/* pub # */ SELECT * FROM t1;
  a  |  b  |  c
-----+-----+-----
   3 | 103 | QLD
   4 | 104 | VIC
   5 | 105 | ACT
   7 | 107 | NT
   8 | 108 | QLD
   6 | 999 | NSW
 555 | 102 | NSW
   9 | 109 | VIC
(8 rows)
</programlisting>
<programlisting>
/* sub # */ SELECT * FROM t1;
  a  |  b  |  c
-----+-----+-----
   6 | 999 | NSW
 555 | 102 | NSW
(2 rows)
</programlisting></para>

   <para>
<!--
    The following examples show how the publication parameter
    <link linkend="sql-createpublication-params-with-publish-via-partition-root"><literal>publish_via_partition_root</literal></link>
    determines whether the row filter of the parent or child table will be used
    in the case of partitioned tables.
-->
次の例は、パブリケーションパラメータ<link linkend="sql-createpublication-params-with-publish-via-partition-root"><literal>publish_via_partition_root</literal></link>によって、親テーブルまたは子テーブルの行フィルタがパーティション化されたテーブルで使用されるかどうかがどのように決定されるかを示しています。
   </para>

   <para>
<!--
    Create a partitioned table on the publisher.
-->
パブリッシャーでパーティション化テーブルを作成します。
<programlisting>
/* pub # */ CREATE TABLE parent(a int PRIMARY KEY) PARTITION BY RANGE(a);
/* pub # */ CREATE TABLE child PARTITION OF parent DEFAULT;
</programlisting>
<!--
   Create the same tables on the subscriber.
-->
サブスクライバー上に同じテーブルを作成します。
<programlisting>
/* sub # */ CREATE TABLE parent(a int PRIMARY KEY) PARTITION BY RANGE(a);
/* sub # */ CREATE TABLE child PARTITION OF parent DEFAULT;
</programlisting></para>

   <para>
<!--
    Create a publication <literal>p4</literal>, and then subscribe to it. The
    publication parameter <literal>publish_via_partition_root</literal> is set
    as true. There are row filters defined on both the partitioned table
    (<literal>parent</literal>), and on the partition (<literal>child</literal>).
-->
パブリケーション<literal>p4</literal>を作成し、サブスクライブします。
パブリケーションパラメータ<literal>publish_via_partition_root</literal>はtrueに設定されています。
行フィルタは、パーティション化テーブル(<literal>parent</literal>)とパーティション(<literal>child</literal>)の両方に定義されています。
<programlisting><![CDATA[
/* pub # */ CREATE PUBLICATION p4 FOR TABLE parent WHERE (a < 5), child WHERE (a >= 5)
/* pub - */ WITH (publish_via_partition_root=true);
]]></programlisting>
<programlisting>
/* sub # */ CREATE SUBSCRIPTION s4
/* sub - */ CONNECTION 'host=localhost dbname=test_pub application_name=s4'
/* sub - */ PUBLICATION p4;
</programlisting></para>

   <para>
<!--
    Insert some values directly into the <literal>parent</literal> and
    <literal>child</literal> tables. They replicate using the row filter of
    <literal>parent</literal> (because <literal>publish_via_partition_root</literal>
    is true).
-->
一部の値を<literal>親</literal>および<literal>子</literal>テーブルに直接挿入します。
これらの値は、<literal>親</literal>の行フィルタを使用してレプリケーションされます（<literal>publish_via_partition_root</literal>がtrueであるため）。
<programlisting>
/* pub # */ INSERT INTO parent VALUES (2), (4), (6);
/* pub # */ INSERT INTO child VALUES (3), (5), (7);

/* pub # */ SELECT * FROM parent ORDER BY a;
 a
---
 2
 3
 4
 5
 6
 7
(6 rows)
</programlisting>
<programlisting>
/* sub # */ SELECT * FROM parent ORDER BY a;
 a
---
 2
 3
 4
(3 rows)
</programlisting></para>

   <para>
<!--
    Repeat the same test, but with a different value for <literal>publish_via_partition_root</literal>.
    The publication parameter <literal>publish_via_partition_root</literal> is
    set as false. A row filter is defined on the partition (<literal>child</literal>).
-->
同じテストを、異なる値<literal>publish_via_partition_root</literal>で繰り返します。
パブリケーションパラメータ<literal>publish_via_partition_root</literal>は偽に設定されています。
行フィルタがパーティション(<literal>child</literal>)に定義されています。
<programlisting><![CDATA[
/* pub # */ DROP PUBLICATION p4;
/* pub # */ CREATE PUBLICATION p4 FOR TABLE parent, child WHERE (a >= 5)
/* pub - */ WITH (publish_via_partition_root=false);
]]></programlisting>
<programlisting>
/* sub # */ ALTER SUBSCRIPTION s4 REFRESH PUBLICATION;
</programlisting></para>

   <para>
<!--
    Do the inserts on the publisher same as before. They replicate using the
    row filter of <literal>child</literal> (because
    <literal>publish_via_partition_root</literal> is false).
-->
パブリッシャーで挿入を前と同じように実行します。
これらは<literal>child</literal>の行フィルタを使用してレプリケーションされます(<literal>publish_via_partition_root</literal>がfalseであるため)。
<programlisting>
/* pub # */ TRUNCATE parent;
/* pub # */ INSERT INTO parent VALUES (2), (4), (6);
/* pub # */ INSERT INTO child VALUES (3), (5), (7);

/* pub # */ SELECT * FROM parent ORDER BY a;
 a
---
 2
 3
 4
 5
 6
 7
(6 rows)
</programlisting>
<programlisting>
/* sub # */ SELECT * FROM child ORDER BY a;
 a
---
 5
 6
 7
(3 rows)
</programlisting></para>

  </sect2>

 </sect1>

 <sect1 id="logical-replication-col-lists">
<!--
  <title>Column Lists</title>
-->
  <title>列リスト</title>

  <para>
<!--
   Each publication can optionally specify which columns of each table are
   replicated to subscribers. The table on the subscriber side must have at
   least all the columns that are published. If no column list is specified,
   then all columns on the publisher are replicated.
   See <xref linkend="sql-createpublication"/> for details on the syntax.
-->
各パブリケーションでは、オプションで各テーブルのどの列をサブスクライバーにレプリケーションするかを指定できます。
サブスクライバー側のテーブルには、少なくとも発行されるすべての列が必要です。
列リストが指定されていない場合は、パブリッシャーのすべての列がレプリケーションされます。
構文の詳細は<xref linkend="sql-createpublication"/>を参照してください。
  </para>

  <para>
<!--
   The choice of columns can be based on behavioral or performance reasons.
   However, do not rely on this feature for security: a malicious subscriber
   is able to obtain data from columns that are not specifically
   published.  If security is a consideration, protections can be applied
   at the publisher side.
-->
列の選択は、動作またはパフォーマンスの理由に基づいて行うことができます。
ただし、セキュリティのためにこの機能に依存しないでください。
悪意のあるサブスクライバーが、特に公開されていない列からデータを取得する可能性があります。
セキュリティを考慮する場合は、発行者側で保護を適用できます。
  </para>

  <para>
<!--
   If no column list is specified, any columns added to the table later are
   automatically replicated. This means that having a column list which names
   all columns is not the same as having no column list at all.
-->
列リストが指定されていない場合、後でテーブルに追加された列は自動的にレプリケーションされます。
つまり、すべての列に名前を付ける列リストがあることは、列リストがないこととは異なります。
  </para>

  <para>
<!--
   A column list can contain only simple column references.  The order
   of columns in the list is not preserved.
-->
列リストには、単純な列参照のみを含めることができます。
リスト内の列の順序は保持されません。
  </para>

  <para>
<!--
   Generated columns can also be specified in a column list. This allows
   generated columns to be published, regardless of the publication parameter
   <link linkend="sql-createpublication-params-with-publish-generated-columns">
   <literal>publish_generated_columns</literal></link>. See
   <xref linkend="logical-replication-gencols"/> for details.
-->
生成列も列リストに指定できます。
これにより、パブリケーションパラメータ<link linkend="sql-createpublication-params-with-publish-generated-columns"><literal>publish_generated_columns</literal></link>に関係なく生成列をパブリッシュできます。
詳細は<xref linkend="logical-replication-gencols"/>を参照してください。
  </para>

  <para>
<!--
   Specifying a column list when the publication also publishes
   <link linkend="sql-createpublication-params-for-tables-in-schema"><literal>FOR TABLES IN SCHEMA</literal></link>
   is not supported.
-->
パブリケーションもパブリッシュする場合の列リストの指定<link linkend="sql-createpublication-params-for-tables-in-schema"><literal>FOR TABLES IN SCHEMA</literal></link>はサポートされていません。
  </para>

  <para>
<!--
   For partitioned tables, the publication parameter
   <link linkend="sql-createpublication-params-with-publish-via-partition-root"><literal>publish_via_partition_root</literal></link>
   determines which column list is used. If <literal>publish_via_partition_root</literal>
   is <literal>true</literal>, the root partitioned table's column list is
   used. Otherwise, if <literal>publish_via_partition_root</literal> is
   <literal>false</literal> (the default), each partition's column list is used.
-->
パーティション化テーブルの場合、パブリケーションパラメータ<link linkend="sql-createpublication-params-with-publish-via-partition-root"><literal>publish_via_partition_root</literal></link>によって使用される列リストが決定されます。
<literal>publish_via_partition_root</literal>が<literal>true</literal>の場合、ルートのパーティション化テーブルの列リストが使用されます。
それ以外の場合、<literal>publish_via_partition_root</literal>が<literal>false</literal>（デフォルト）の場合、各パーティションの列リストが使用されます。
  </para>

  <para>
<!--
   If a publication publishes <command>UPDATE</command> or
   <command>DELETE</command> operations, any column list must include the
   table's replica identity columns (see
   <xref linkend="sql-altertable-replica-identity"/>).
   If a publication publishes only <command>INSERT</command> operations, then
   the column list may omit replica identity columns.
-->
パブリケーションが<command>UPDATE</command>または<command>DELETE</command>操作をパブリッシュする場合、どの列リストにもテーブルのレプリカアイデンティティ列が含まれている必要があります(<xref linkend="sql-altertable-replica-identity"/>を参照)。
パブリケーションが<command>INSERT</command>操作のみをパブリッシュする場合列リストでレプリカアイデンティティ列を省略できます。
  </para>

  <para>
<!--
   Column lists have no effect for the <literal>TRUNCATE</literal> command.
-->
列リストは、<literal>TRUNCATE</literal>コマンドには影響しません。
  </para>

  <para>
<!--
   During initial data synchronization, only the published columns are
   copied.  However, if the subscriber is from a release prior to 15, then
   all the columns in the table are copied during initial data synchronization,
   ignoring any column lists. If the subscriber is from a release prior to 18,
   then initial table synchronization won't copy generated columns even if they
   are defined in the publisher.
-->
初期データの同期化時には、公開済の列のみがコピーされます。
ただし、サブスクライバーが15より前のリリースの場合は、テーブルのすべての列が初期データの同期化時にコピーされ、列リストは無視されます。
サブスクライバーが18より前のリリースの場合、生成列がパブリッシャーで定義されている場合でも、初期テーブル同期は行われません。
  </para>

   <warning id="logical-replication-col-list-combining">
<!--
    <title>Warning: Combining Column Lists from Multiple Publications</title>
-->
    <title>警告: 複数のパブリケーションからの列リストの統合</title>
    <para>
<!--
     There's currently no support for subscriptions comprising several
     publications where the same table has been published with different
     column lists.  <xref linkend="sql-createsubscription"/> disallows
     creating such subscriptions, but it is still possible to get into
     that situation by adding or altering column lists on the publication
     side after a subscription has been created.
-->
現在、同じテーブルが異なる列リストで発行されている複数のパブリケーションで構成されるサブスクリプションはサポートされていません。
<xref linkend="sql-createsubscription"/>ではこのようなサブスクリプションの作成はできませんが、サブスクリプションの作成後にパブリケーション側で列リストを追加または変更することで、このような状況になる可能性はあります。
    </para>
    <para>
<!--
     This means changing the column lists of tables on publications that are
     already subscribed could lead to errors being thrown on the subscriber
     side.
-->
つまり、すでにサブスクライブされているパブリケーションのテーブルの列リストを変更すると、サブスクライバー側でエラーになる可能性があります。
    </para>
    <para>
<!--
     If a subscription is affected by this problem, the only way to resume
     replication is to adjust one of the column lists on the publication
     side so that they all match; and then either recreate the subscription,
     or use <link linkend="sql-altersubscription-params-setadddrop-publication">
     <literal>ALTER SUBSCRIPTION ... DROP PUBLICATION</literal></link> to
     remove one of the offending publications and add it again.
-->
サブスクリプションがこの問題の影響を受ける場合、レプリケーションを再開する唯一の方法は、パブリケーション側の列リストの1つを調整してすべて一致させてから、サブスクリプションを再作成するか、<link linkend="sql-altersubscription-params-setadddrop-publication"><literal>ALTER SUBSCRIPTION ... DROP PUBLICATION</literal></link>を使用して問題のパブリケーションの1つを削除し、再度追加することです。
    </para>
   </warning>

  <sect2 id="logical-replication-col-list-examples">
<!--
   <title>Examples</title>
-->
   <title>例</title>

   <para>
<!--
    Create a table <literal>t1</literal> to be used in the following example.
-->
次の例で使用するテーブル<literal>t1</literal>を作成します。
<programlisting>
/* pub # */ CREATE TABLE t1(id int, a text, b text, c text, d text, e text, PRIMARY KEY(id));
</programlisting></para>

   <para>
<!--
    Create a publication <literal>p1</literal>. A column list is defined for
    table <literal>t1</literal> to reduce the number of columns that will be
    replicated. Notice that the order of column names in the column list does
    not matter.
-->
パブリケーション<literal>p1</literal>を作成します。
レプリケーションされる列数を減らすために、テーブル<literal>t1</literal>に対して列リストが定義されます。
列リスト内の列名の順序は重要ではないことに注意してください。
<programlisting>
/* pub # */ CREATE PUBLICATION p1 FOR TABLE t1 (id, b, a, d);
</programlisting></para>

    <para>
<!--
     <literal>psql</literal> can be used to show the column lists (if defined)
     for each publication.
-->
<literal>psql</literal>を使用して、各パブリケーションの列リストを表示することができます（定義されている場合）。
<programlisting>
/* pub # */ \dRp+
                                         Publication p1
  Owner   | All tables | Inserts | Updates | Deletes | Truncates | Generated columns | Via root
----------+------------+---------+---------+---------+-----------+-------------------+----------
 postgres | f          | t       | t       | t       | t         | none              | f
Tables:
    "public.t1" (id, a, b, d)
</programlisting></para>

    <para>
<!--
     <literal>psql</literal> can be used to show the column lists (if defined)
     for each table.
-->
<literal>psql</literal>を使用して、各テーブルの列リストを表示することができます（定義されている場合）。
<programlisting>
/* pub # */ \d t1
                 Table "public.t1"
 Column |  Type   | Collation | Nullable | Default
--------+---------+-----------+----------+---------
 id     | integer |           | not null |
 a      | text    |           |          |
 b      | text    |           |          |
 c      | text    |           |          |
 d      | text    |           |          |
 e      | text    |           |          |
Indexes:
    "t1_pkey" PRIMARY KEY, btree (id)
Publications:
    "p1" (id, a, b, d)
</programlisting></para>

    <para>
<!--
     On the subscriber node, create a table <literal>t1</literal> which now
     only needs a subset of the columns that were on the publisher table
     <literal>t1</literal>, and also create the subscription
     <literal>s1</literal> that subscribes to the publication
     <literal>p1</literal>.
-->
サブスクライバーノードで、パブリッシャーテーブル<literal>t1</literal>にあった列のサブセットだけが必要なテーブル<literal>t1</literal>を作成し、パブリケーション<literal>p1</literal>をサブスクライブするサブスクリプション<literal>s1</literal>も作成します。
<programlisting>
/* sub # */ CREATE TABLE t1(id int, b text, a text, d text, PRIMARY KEY(id));
/* sub # */ CREATE SUBSCRIPTION s1
/* sub - */ CONNECTION 'host=localhost dbname=test_pub application_name=s1'
/* sub - */ PUBLICATION p1;
</programlisting></para>

    <para>
<!--
     On the publisher node, insert some rows to table <literal>t1</literal>.
-->
パブリッシャーノードで、テーブル<literal>t1</literal>に行を挿入します。
<programlisting>
/* pub # */ INSERT INTO t1 VALUES(1, 'a-1', 'b-1', 'c-1', 'd-1', 'e-1');
/* pub # */ INSERT INTO t1 VALUES(2, 'a-2', 'b-2', 'c-2', 'd-2', 'e-2');
/* pub # */ INSERT INTO t1 VALUES(3, 'a-3', 'b-3', 'c-3', 'd-3', 'e-3');
/* pub # */ SELECT * FROM t1 ORDER BY id;
 id |  a  |  b  |  c  |  d  |  e
----+-----+-----+-----+-----+-----
  1 | a-1 | b-1 | c-1 | d-1 | e-1
  2 | a-2 | b-2 | c-2 | d-2 | e-2
  3 | a-3 | b-3 | c-3 | d-3 | e-3
(3 rows)
</programlisting></para>

    <para>
<!--
     Only data from the column list of publication <literal>p1</literal> is
     replicated.
-->
パブリケーション<literal>p1</literal>の列リストからのデータのみがレプリケーションされます。
<programlisting>
/* sub # */ SELECT * FROM t1 ORDER BY id;
 id |  b  |  a  |  d
----+-----+-----+-----
  1 | b-1 | a-1 | d-1
  2 | b-2 | a-2 | d-2
  3 | b-3 | a-3 | d-3
(3 rows)
</programlisting></para>

  </sect2>

 </sect1>

 <sect1 id="logical-replication-gencols">
<!--
  <title>Generated Column Replication</title>
-->
  <title>生成列のレプリケーション</title>

  <para>
<!--
   Typically, a table at the subscriber will be defined the same as the
   publisher table, so if the publisher table has a <link linkend="ddl-generated-columns">
   <literal>GENERATED column</literal></link> then the subscriber table will
   have a matching generated column. In this case, it is always the subscriber
   table generated column value that is used.
-->
通常、サブスクライバーのテーブルはパブリッシャーのテーブルと同じように定義されます。そのため、パブリッシャーテーブルに<link linkend="ddl-generated-columns"><literal>生成列</literal></link>が存在する場合、サブスクライバーテーブルにも対応する生成列が存在します。
この場合、常にサブスクライバーテーブルの生成列の値が使用されます。
  </para>

  <para>
<!--
   For example, note below that subscriber table generated column value comes from the
   subscriber column's calculation.
-->
例えば以下の場合、サブスクライバーテーブルの生成列の値は、サブスクライバー列の計算から取得されることに注意してください。
<programlisting>
/* pub # */ CREATE TABLE tab_gen_to_gen (a int, b int GENERATED ALWAYS AS (a + 1) STORED);
/* pub # */ INSERT INTO tab_gen_to_gen VALUES (1),(2),(3);
/* pub # */ CREATE PUBLICATION pub1 FOR TABLE tab_gen_to_gen;
/* pub # */ SELECT * FROM tab_gen_to_gen;
 a | b
---+---
 1 | 2
 2 | 3
 3 | 4
(3 rows)

/* sub # */ CREATE TABLE tab_gen_to_gen (a int, b int GENERATED ALWAYS AS (a * 100) STORED);
/* sub # */ CREATE SUBSCRIPTION sub1 CONNECTION 'dbname=test_pub' PUBLICATION pub1;
/* sub # */ SELECT * from tab_gen_to_gen;
 a | b
---+----
 1 | 100
 2 | 200
 3 | 300
(3 rows)
</programlisting>
  </para>

  <para>
<!--
   In fact, prior to version 18.0, logical replication does not publish
   <literal>GENERATED</literal> columns at all.
-->
実際、バージョン18.0より前では、論理レプリケーションは<literal>生成</literal>列を全くパブリッシュしません。
  </para>

  <para>
<!--
   But, replicating a generated column to a regular column can sometimes be
   desirable.
-->
しかし、生成列の値を通常の列に複製することが望ましい場合もあります。
   <tip>
    <para>
<!--
     This feature may be useful when replicating data to a
     non-PostgreSQL database via output plugin, especially if the target database
     does not support generated columns.
-->
この機能は、出力プラグインを介してPostgreSQL以外のデータベースにデータを複製する場合、特にターゲットデータベースが生成列をサポートしていない場合に有用です。
    </para>
  </tip>
  </para>

  <para>
<!--
   Generated columns are not published by default, but users can opt to
   publish stored generated columns just like regular ones.
-->
生成列はデフォルトではパブリッシュされませんが、ユーザは格納生成列を通常の列と同様にパブリッシュすることを選択できます。
  </para>

  <para>
<!--
   There are two ways to do this:
-->
これには2つの方法があります。
   <itemizedlist>
     <listitem>
      <para>
<!--
       Set the <command>PUBLICATION</command> parameter
       <link linkend="sql-createpublication-params-with-publish-generated-columns">
       <literal>publish_generated_columns</literal></link> to <literal>stored</literal>.
       This instructs PostgreSQL logical replication to publish current and
       future stored generated columns of the publication's tables.
-->
<command>PUBLICATION</command>パラメータの<link linkend="sql-createpublication-params-with-publish-generated-columns"><literal>publish_generated_columns</literal></link>を<literal>stored</literal>に設定します。
これは、PostgreSQL論理レプリケーションに、パブリケーションのテーブルが持つ現在または将来の格納生成列をパブリッシュするように指示します。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       Specify a table <link linkend="logical-replication-col-lists">column list</link>
       to explicitly nominate which stored generated columns will be published.
-->
どの格納生成列がパブリッシュされるかを明示的に指定する、テーブルの<link linkend="logical-replication-col-lists">列リスト</link>を設定します。
      </para>

      <note>
       <para>
<!--
        When determining which table columns will be published, a column list
        takes precedence, overriding the effect of the
        <literal>publish_generated_columns</literal> parameter.
-->
どのテーブル列をパブリッシュするかを決定する際には、列リストが優先され、<literal>publish_generated_columns</literal>パラメータの効果を上書きします。
       </para>
      </note>
     </listitem>
   </itemizedlist>
  </para>

  <para>
<!--
   The following table summarizes behavior when there are generated columns
   involved in the logical replication. Results are shown for when
   publishing generated columns is not enabled, and for when it is
   enabled.
-->
以下の表は、論理レプリケーションに生成列が含まれる場合の動作をまとめたものです。
生成列のパブリッシュが有効になっていない場合と、有効になっている場合の結果を示しています。
  </para>

  <table id="logical-replication-gencols-table-summary">
<!--
   <title>Replication Result Summary</title>
-->
   <title>レプリケーション結果の概要</title>
   <tgroup cols="4">

    <thead>
     <row>
<!--
      <entry>Publish generated columns?</entry>
-->
      <entry>生成列をパブリッシュするか否か？</entry>
<!--
      <entry>Publisher table column</entry>
-->
      <entry>パブリッシャーテーブルの列</entry>
<!--
      <entry>Subscriber table column</entry>
-->
      <entry>サブスクライバーテーブルの列</entry>

<!--
      <entry>Result</entry>
-->
      <entry>結果</entry>
     </row>
    </thead>

    <tbody>
     <row>
<!--
      <entry>No</entry>
-->
      <entry>いいえ</entry>
<!--
      <entry>GENERATED</entry>
-->
      <entry>生成列</entry>
<!--
      <entry>GENERATED</entry>
-->
      <entry>生成列</entry>
<!--
      <entry>Publisher table column is not replicated. Use the subscriber table generated column value.</entry>
-->
      <entry>パブリッシャーテーブルの列はレプリケーションされません。サブスクライバーテーブルの生成列の値を使用します。</entry>
     </row>

     <row>
<!--
      <entry>No</entry>
-->
      <entry>いいえ</entry>
<!--
      <entry>GENERATED</entry>
-->
      <entry>生成列</entry>
<!--
      <entry>regular</entry>
-->
      <entry>通常の列</entry>
<!--
      <entry>Publisher table column is not replicated. Use the subscriber table regular column default value.</entry>
-->
      <entry>パブリッシャーテーブルの列はレプリケーションされません。サブスクライバーテーブルの通常の列の値を使用します。</entry>
     </row>

     <row>
<!--
      <entry>No</entry>
-->
      <entry>いいえ</entry>
<!--
      <entry>GENERATED</entry>
-->
      <entry>生成列</entry>
<!--
      <entry>&#45;-missing&#45;-</entry>
-->
      <entry>--存在しない--</entry>
<!--
      <entry>Publisher table column is not replicated. Nothing happens.</entry>
-->
      <entry>パブリッシャーテーブルの列はレプリケーションされません。何も起こりません。</entry>
     </row>

     <row>
<!--
      <entry>Yes</entry>
-->
      <entry>はい</entry>
<!--
      <entry>GENERATED</entry>
-->
      <entry>生成列</entry>
<!--
      <entry>GENERATED</entry>
-->
      <entry>生成列</entry>
<!--
      <entry>ERROR. Not supported.</entry>
-->
      <entry>エラー。サポートされていません。</entry>
     </row>

     <row>
<!--
      <entry>Yes</entry>
-->
      <entry>はい</entry>
<!--
      <entry>GENERATED</entry>
-->
      <entry>生成列</entry>
<!--
      <entry>regular</entry>
-->
      <entry>通常の列</entry>
<!--
      <entry>Publisher table column value is replicated to the subscriber table column.</entry>
-->
      <entry>パブリッシャーテーブルの列がサブスクライバーテーブルの列にレプリケーションされます。</entry>
     </row>

     <row>
<!--
      <entry>Yes</entry>
-->
      <entry>はい</entry>
<!--
      <entry>GENERATED</entry>
-->
      <entry>生成列</entry>
<!--
      <entry>&#45;-missing&#45;-</entry>
-->
      <entry>--存在しない--</entry>
<!--
      <entry>ERROR. The column is reported as missing from the subscriber table.</entry>
-->
      <entry>エラー。サブスクライバーテーブルに列が存在しないことが報告されます。</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <warning>
   <para>
<!--
    There's currently no support for subscriptions comprising several
    publications where the same table has been published with different column
    lists. See <xref linkend="logical-replication-col-lists"/>.
-->
現在のところ、同じテーブルが異なる列リストでパブリッシュされている複数のパブリケーションで構成されるサブスクリプションはサポートされていません。
<xref linkend="logical-replication-col-lists"/>を参照してください。
   </para>

   <para>
<!--
    This same situation can occur if one publication is publishing generated
    columns, while another publication in the same subscription is not
    publishing generated columns for the same table.
-->
同様の状況は、あるパブリケーションが生成列をパブリッシュしている一方で、同じサブスクリプション内の別のパブリケーションが同じテーブルに対して生成列をパブリッシュしていない場合にも発生します。
   </para>
  </warning>

  <note>
   <para>
<!--
    If the subscriber is from a release prior to 18, then initial table
    synchronization won't copy generated columns even if they are defined in
    the publisher.
-->
サブスクライバーが18より前のリリースの場合、生成列のパブリッシュがパブリッシャーで規定されている場合でも、初期テーブル同期ではそれらの列はコピーされません。
   </para>
  </note>
 </sect1>

 <sect1 id="logical-replication-conflicts">
<!--
  <title>Conflicts</title>
-->
  <title>コンフリクト</title>

  <para>
<!--
   Logical replication behaves similarly to normal DML operations in that
   the data will be updated even if it was changed locally on the subscriber
   node.  If incoming data violates any constraints the replication will
   stop.  This is referred to as a <firstterm>conflict</firstterm>.  When
   replicating <command>UPDATE</command> or <command>DELETE</command>
   operations, missing data is also considered as a
   <firstterm>conflict</firstterm>, but does not result in an error and such
   operations will simply be skipped.
-->
サブスクライバーノードでローカルにデータが変更された場合でも、データが更新されるという点では、論理レプリケーションは通常のDML操作と同じように振る舞います。
到着したデータが制約に違反すると、レプリケーションは停止します。
これは、<firstterm>コンフリクト</firstterm>と呼ばれます。
<command>UPDATE</command>あるいは<command>DELETE</command>操作をレプリケーションする場合は、
存在しないデータも<firstterm>コンフリクト</firstterm>とみなされますが、エラーにはならずそのような操作は単にスキップされます。
  </para>

  <para>
<!--
   Additional logging is triggered, and the conflict statistics are collected (displayed in the
   <link linkend="monitoring-pg-stat-subscription-stats"><structname>pg_stat_subscription_stats</structname></link> view)
   in the following <firstterm>conflict</firstterm> cases:
-->
次の<firstterm>コンフリクト</firstterm>の場合、追加のログが出力され、統計情報が収集されます（<link linkend="monitoring-pg-stat-subscription-stats"><structname>pg_stat_subscription_stats</structname></link>ビューに出力されます）。
   <variablelist>
    <varlistentry id="conflict-insert-exists" xreflabel="insert_exists">
     <term><literal>insert_exists</literal></term>
     <listitem>
      <para>
<!--
       Inserting a row that violates a <literal>NOT DEFERRABLE</literal>
       unique constraint. Note that to log the origin and commit
       timestamp details of the conflicting key,
       <link linkend="guc-track-commit-timestamp"><varname>track_commit_timestamp</varname></link>
       should be enabled on the subscriber. In this case, an error will be
       raised until the conflict is resolved manually.
-->
<literal>NOT DEFERRABLE</literal>な一意性制約に違反する行を挿入しています。
競合するキーのオリジンやコミットタイムスタンプの詳細をログ出力するためには、サブスクライバーで<link linkend="guc-track-commit-timestamp"><varname>track_commit_timestamp</varname></link>を有効にする必要があります。
この場合、コンフリクトが手動で解決されるまで、エラーが報告されます。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry id="conflict-update-origin-differs" xreflabel="update_origin_differs">
     <term><literal>update_origin_differs</literal></term>
     <listitem>
      <para>
<!--
       Updating a row that was previously modified by another origin.
       Note that this conflict can only be detected when
       <link linkend="guc-track-commit-timestamp"><varname>track_commit_timestamp</varname></link>
       is enabled on the subscriber. Currently, the update is always applied
       regardless of the origin of the local row.
-->
以前別のオリジンによって変更された行を更新しています。
このコンフリクトは、サブスクライバーで<link linkend="guc-track-commit-timestamp"><varname>track_commit_timestamp</varname></link>を有効にしている場合にのみ検出されます。
現在のところ、更新はローカル行のオリジンに関係なく常に適用されます。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry id="conflict-update-exists" xreflabel="update_exists">
     <term><literal>update_exists</literal></term>
     <listitem>
      <para>
<!--
       The updated value of a row violates a <literal>NOT DEFERRABLE</literal>
       unique constraint. Note that to log the origin and commit
       timestamp details of the conflicting key,
       <link linkend="guc-track-commit-timestamp"><varname>track_commit_timestamp</varname></link>
       should be enabled on the subscriber. In this case, an error will be
       raised until the conflict is resolved manually. Note that when updating a
       partitioned table, if the updated row value satisfies another partition
       constraint resulting in the row being inserted into a new partition, the
       <literal>insert_exists</literal> conflict may arise if the new row
       violates a <literal>NOT DEFERRABLE</literal> unique constraint.
-->
行の更新された値が<literal>NOT DEFERRABLE</literal>な一意性制約に違反しています。
競合するキーのオリジンやコミットタイムスタンプの詳細をログ出力するためには、サブスクライバーで<link linkend="guc-track-commit-timestamp"><varname>track_commit_timestamp</varname></link>を有効にする必要があります。
この場合、コンフリクトが手動で解決されるまで、エラーが報告されます。
パーティションテーブルを更新するときに、更新した行が別のパーティション制約を満たし、その結果行が別のパーティションに挿入される場合、新しい行が<literal>NOT DEFERRABLE</literal>な一意性制約に違反すると、<literal>insert_exists</literal>コンフリクトが検出される可能性があることに注意してください。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry id="conflict-update-missing" xreflabel="update_missing">
     <term><literal>update_missing</literal></term>
     <listitem>
      <para>
<!--
       The row to be updated was not found. The update will simply be
       skipped in this scenario.
-->
更新対象の行が見つかりませんでした。
このシナリオでは更新は単純にスキップされます。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry id="conflict-delete-origin-differs" xreflabel="delete_origin_differs">
     <term><literal>delete_origin_differs</literal></term>
     <listitem>
      <para>
<!--
       Deleting a row that was previously modified by another origin. Note that
       this conflict can only be detected when
       <link linkend="guc-track-commit-timestamp"><varname>track_commit_timestamp</varname></link>
       is enabled on the subscriber. Currently, the delete is always applied
       regardless of the origin of the local row.
-->
以前別のオリジンによって変更された行を削除しています。
このコンフリクトは、サブスクライバーで<link linkend="guc-track-commit-timestamp"><varname>track_commit_timestamp</varname></link>を有効にしている場合にのみ検出されます。
現在のところ、削除はローカル行のオリジンに関係なく常に適用されます。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry id="conflict-delete-missing" xreflabel="delete_missing">
     <term><literal>delete_missing</literal></term>
     <listitem>
      <para>
<!--
       The row to be deleted was not found. The delete will simply be
       skipped in this scenario.
-->
削除対象の行が見つかりませんでした。
このシナリオでは削除は単純にスキップされます。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry id="conflict-multiple-unique-conflicts" xreflabel="multiple_unique_conflicts">
     <term><literal>multiple_unique_conflicts</literal></term>
     <listitem>
      <para>
<!--
       Inserting or updating a row violates multiple
       <literal>NOT DEFERRABLE</literal> unique constraints. Note that to log
       the origin and commit timestamp details of conflicting keys, ensure
       that <link linkend="guc-track-commit-timestamp"><varname>track_commit_timestamp</varname></link>
       is enabled on the subscriber. In this case, an error will be raised until
       the conflict is resolved manually.
-->
挿入または更新行が、複数の<literal>NOT DEFERRABLE</literal>な一意性制約に違反しています。
このコンフリクトは、サブスクライバーで<link linkend="guc-track-commit-timestamp"><varname>track_commit_timestamp</varname></link>を有効にしている場合にのみ検出されます。
この場合、コンフリクトが手動で解決されるまで、エラーが報告されます。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
<!--
    Note that there are other conflict scenarios, such as exclusion constraint
    violations. Currently, we do not provide additional details for them in the
    log.
-->
排他制約違反など、他にもコンフリクトのシナリオが存在することに注意してください。
現在のところ、ログにはこれらのコンフリクトに関する詳細情報は出力されません。
  </para>

  <para>
<!--
   The log format for logical replication conflicts is as follows:
-->
論理レプリケーションコンフリクトのログフォーマットは以下の通りです。
<synopsis>
LOG:  conflict detected on relation "<replaceable>schemaname</replaceable>.<replaceable>tablename</replaceable>": conflict=<replaceable>conflict_type</replaceable>
DETAIL:  <replaceable class="parameter">detailed_explanation</replaceable>.
{<replaceable class="parameter">detail_values</replaceable> [; ... ]}.

<phrase>where <replaceable class="parameter">detail_values</replaceable> is one of:</phrase>

    <literal>Key</literal> (<replaceable>column_name</replaceable> <optional>, ...</optional>)=(<replaceable>column_value</replaceable> <optional>, ...</optional>)
    <literal>existing local row</literal> <optional>(<replaceable>column_name</replaceable> <optional>, ...</optional>)=</optional>(<replaceable>column_value</replaceable> <optional>, ...</optional>)
    <literal>remote row</literal> <optional>(<replaceable>column_name</replaceable> <optional>, ...</optional>)=</optional>(<replaceable>column_value</replaceable> <optional>, ...</optional>)
    <literal>replica identity</literal> {(<replaceable>column_name</replaceable> <optional>, ...</optional>)=(<replaceable>column_value</replaceable> <optional>, ...</optional>) | full <optional>(<replaceable>column_name</replaceable> <optional>, ...</optional>)=</optional>(<replaceable>column_value</replaceable> <optional>, ...</optional>)}
</synopsis>

<!--
   The log provides the following information:
-->
ログには次の情報が提供されます。
   <variablelist>
    <varlistentry>
     <term><literal>LOG</literal></term>
      <listitem>
       <itemizedlist>
        <listitem>
         <para>
<!--
         <replaceable>schemaname</replaceable>.<replaceable>tablename</replaceable>
         identifies the local relation involved in the conflict.
-->
<replaceable>schemaname</replaceable>.<replaceable>tablename</replaceable>は、コンフリクトに関係するローカルリレーションを識別します。
         </para>
        </listitem>
        <listitem>
         <para>
<!--
         <replaceable>conflict_type</replaceable> is the type of conflict that occurred
         (e.g., <literal>insert_exists</literal>, <literal>update_exists</literal>).
-->
<replaceable>conflict_type</replaceable>は発生したコンフリクトの種類です（例：<literal>insert_exists</literal>、<literal>update_exists</literal>）。
         </para>
        </listitem>
       </itemizedlist>
      </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>DETAIL</literal></term>
      <listitem>
      <itemizedlist>
       <listitem>
        <para>
<!--
         <replaceable class="parameter">detailed_explanation</replaceable> includes
         the origin, transaction ID, and commit timestamp of the transaction that
         modified the existing local row, if available.
-->
<replaceable class="parameter">detailed_explanation</replaceable>には、既存のローカル行を変更したトランザクションのオリジンとトランザクションID、そしてコミットタイムスタンプ（利用可能であれば）が含まれます。
        </para>
       </listitem>
       <listitem>
        <para>
<!--
         The <literal>Key</literal> section includes the key values of the local
         row that violated a unique constraint for
         <literal>insert_exists</literal>, <literal>update_exists</literal> or
         <literal>multiple_unique_conflicts</literal> conflicts.
-->
<literal>Key</literal>セクションには、<literal>insert_exists</literal>、<literal>update_exists</literal>または<literal>multiple_unique_conflicts</literal>コンフリクトの一意性制約に違反したローカル行のキー値が含まれます。
        </para>
       </listitem>
       <listitem>
        <para>
<!--
         The <literal>existing local row</literal> section includes the local
         row if its origin differs from the remote row for
         <literal>update_origin_differs</literal> or <literal>delete_origin_differs</literal>
         conflicts, or if the key value conflicts with the remote row for
         <literal>insert_exists</literal>, <literal>update_exists</literal> or
         <literal>multiple_unique_conflicts</literal> conflicts.
-->
<literal>existing local row</literal>セクションにはローカル行が含まれます。
ただし、<literal>update_origin_differs</literal>または<literal>delete_origin_differs</literal>コンフリクトではローカル行のオリジンがリモートと異なる場合、<literal>insert_exists</literal>、<literal>update_exists</literal>または<literal>multiple_unique_conflicts</literal>ではキー値がリモート行と競合する場合です。
        </para>
       </listitem>
       <listitem>
        <para>
<!--
         The <literal>remote row</literal> section includes the new row from
         the remote insert or update operation that caused the conflict. Note that
         for an update operation, the column value of the new row will be null
         if the value is unchanged and toasted.
-->
<literal>remote row</literal>セクションには、競合の原因となったリモート挿入または更新操作による新しい行が含まれます。
更新操作の場合、変更されなかった列やTOASTされた列の値はNULLとなることに注意してください。
        </para>
       </listitem>
       <listitem>
        <para>
<!--
         The <literal>replica identity</literal> section includes the replica
         identity key values that were used to search for the existing local
         row to be updated or deleted. This may include the full row value
         if the local relation is marked with
         <link linkend="sql-altertable-replica-identity-full"><literal>REPLICA IDENTITY FULL</literal></link>.
-->
<literal>replica identity</literal>セクションには、更新または削除対象となったローカル行の検索に使用されたレプリカアイデンティティが含まれます。
ローカルリレーションが<link linkend="sql-altertable-replica-identity-full"><literal>REPLICA IDENTITY FULL</literal></link>が指定されている場合は、行全体の値が含まれることがあります。
        </para>
       </listitem>
       <listitem>
        <para>
<!--
         <replaceable class="parameter">column_name</replaceable> is the column name.
         For <literal>existing local row</literal>, <literal>remote row</literal>,
         and <literal>replica identity full</literal> cases, column names are
         logged only if the user lacks the privilege to access all columns of
         the table. If column names are present, they appear in the same order
         as the corresponding column values.
-->
<replaceable class="parameter">column_name</replaceable>は列名です。
<literal>existing local row</literal>, <literal>remote row</literal>、および<literal>replica identity full</literal>の場合、ユーザがテーブルのすべての列に対するアクセス権限を持っていない場合にのみ列名が記録されます。
列名が存在する場合は、対応する列の値と同じオーダーに表示されます。
        </para>
       </listitem>
       <listitem>
        <para>
<!--
         <replaceable class="parameter">column_value</replaceable> is the column value.
         The large column values are truncated to 64 bytes.
-->
<replaceable class="parameter">column_value</replaceable>は列の値です。
長い列の値は64バイトに切り詰められます。
        </para>
       </listitem>
       <listitem>
        <para>
<!--
         Note that in case of <literal>multiple_unique_conflicts</literal> conflict,
         multiple <replaceable class="parameter">detailed_explanation</replaceable>
         and <replaceable class="parameter">detail_values</replaceable> lines
         will be generated, each detailing the conflict information associated
         with distinct unique
         constraints.
-->
<literal>multiple_unique_conflicts</literal>コンフリクトの場合は、複数の<replaceable class="parameter">detailed_explanation</replaceable>および<replaceable class="parameter">detail_values</replaceable>が生成され、それぞれが異なる一意性制約に関連付けられたコンフリクト情報を詳述することに注意してください。
        </para>
       </listitem>
      </itemizedlist>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

  <para>
<!--
   Logical replication operations are performed with the privileges of the role
   which owns the subscription.  Permissions failures on target tables will
   cause replication conflicts, as will enabled
   <link linkend="ddl-rowsecurity">row-level security</link> on target tables
   that the subscription owner is subject to, without regard to whether any
   policy would ordinarily reject the <command>INSERT</command>,
   <command>UPDATE</command>, <command>DELETE</command> or
   <command>TRUNCATE</command> which is being replicated.  This restriction on
   row-level security may be lifted in a future version of
   <productname>PostgreSQL</productname>.
-->
論理レプリケーション操作は、サブスクリプションを所有するロールの権限を使用して実行されます。
対象テーブルで権限違反が起こると、レプリケーション競合が発生します。
これは、サブスクリプション所有者が従う、対象テーブルで有効な<link linkend="ddl-rowsecurity">行レベルセキュリティ</link>と同じですが、レプリケーションされている<command>INSERT</command>、<command>UPDATE</command>、<command>DELETE</command>または<command>TRUNCATE</command>をポリシーが通常拒否するかどうかには関係ありません。
行レベルセキュリティに対するこの制限は、<productname>PostgreSQL</productname>の将来のバージョンで解除される可能性があります。
  </para>

  <para>
<!--
   A conflict that produces an error will stop the replication; it must be
   resolved manually by the user.  Details about the conflict can be found in
   the subscriber's server log.
-->
コンフリクトはエラーを生じさせ、レプリケーションを停止させます。
コンフリクトはユーザが手動で解消しなければなりません。
コンフリクトの詳細は、サブスクライバーのサーバログに出力されます。
  </para>

  <para>
<!--
   The resolution can be done either by changing data or permissions on the subscriber so
   that it does not conflict with the incoming change or by skipping the
   transaction that conflicts with the existing data.  When a conflict produces
   an error, the replication won't proceed, and the logical replication worker will
   emit the following kind of message to the subscriber's server log:
-->
この問題を解決するには、データを変更するか、サブスクライバーに対する権限を変更して、既存の変更でコンフリクトしないようにするか、既存のトランザクションと競合するデータをスキップします。
コンフリクトよってエラーが発生した場合、レプリケーションは処理を続行せず、論理レプリケーションワーカーは次のようなメッセージをサブスクライバーのサーバログに送信します。
<screen>
ERROR:  conflict detected on relation "public.test": conflict=insert_exists
DETAIL:  Key already exists in unique index "t_pkey", which was modified locally in transaction 740 at 2024-06-26 10:47:04.727375+08.
Key (c)=(1); existing local row (1, 'local'); remote row (1, 'remote').
CONTEXT:  processing remote data for replication origin "pg_16395" during "INSERT" for replication target relation "public.test" in transaction 725 finished at 0/14C0378
</screen>
<!--
   The LSN of the transaction that contains the change violating the constraint and
   the replication origin name can be found from the server log (LSN 0/14C0378 and
   replication origin <literal>pg_16395</literal> in the above case).  The
   transaction that produced the conflict can be skipped by using
   <link linkend="sql-altersubscription-params-skip"><command>ALTER SUBSCRIPTION ... SKIP</command></link>
   with the finish LSN
   (i.e., LSN 0/14C0378).  The finish LSN could be an LSN at which the transaction
   is committed or prepared on the publisher.  Alternatively, the transaction can
   also be skipped by calling the <link linkend="pg-replication-origin-advance">
   <function>pg_replication_origin_advance()</function></link> function.
   Before using this function, the subscription needs to be disabled temporarily
   either by <link linkend="sql-altersubscription-params-disable">
   <command>ALTER SUBSCRIPTION ... DISABLE</command></link> or, the
   subscription can be used with the
   <link linkend="sql-createsubscription-params-with-disable-on-error"><literal>disable_on_error</literal></link>
   option. Then, you can use <function>pg_replication_origin_advance()</function>
   function with the <parameter>node_name</parameter> (i.e., <literal>pg_16395</literal>)
   and the next LSN of the finish LSN (i.e., 0/14C0379).  The current position of
   origins can be seen in the <link linkend="view-pg-replication-origin-status">
   <structname>pg_replication_origin_status</structname></link> system view.
   Please note that skipping the whole transaction includes skipping changes that
   might not violate any constraint.  This can easily make the subscriber
   inconsistent.
   The additional details regarding conflicting rows, such as their origin and
   commit timestamp can be seen in the <literal>DETAIL</literal> line of the
   log. But note that this information is only available when
   <link linkend="guc-track-commit-timestamp"><varname>track_commit_timestamp</varname></link>
   is enabled on the subscriber. Users can use this information to decide
   whether to retain the local change or adopt the remote alteration. For
   instance, the <literal>DETAIL</literal> line in the above log indicates that
   the existing row was modified locally. Users can manually perform a
   remote-change-win.
-->
制約とレプリケーションの起点名に違反する変更を含むトランザクションのLSNは、サーバログ(LSN 0/14C0378とレプリケーション起点<literal>pg_16395</literal>)から見つけることができます。
競合を発生させたトランザクションは、終了LSN(LSN 0/14C0378)で<link linkend="sql-altersubscription-params-skip"><command>ALTER SUBSCRIPTION ... SKIP</command></link>を使用してスキップできます。
終了LSNは、パブリッシャーでトランザクションがコミットまたは準備されたLSNにすることができます。
あるいは、<link linkend="pg-replication-origin-advance"><function>pg_replication_origin_advance()</function></link>関数を呼び出して、トランザクションをスキップすることもできます。
この関数を使用する前に、<link linkend="sql-altersubscription-params-disable"><command>ALTER SUBSCRIPTION ... DISABLE</command></link>を使用してサブスクリプションを一時的に無効にするか、
<link linkend="sql-createsubscription-params-with-disable-on-error"><literal>disable_on_error</literal></link>オプションを使用します。
次に、<function>pg_replication_origin_advance()</function>関数を<parameter>node_name</parameter>(<literal>pg_16395</literal>)と終了LSNの次のLSN(0/14C0379)と共に使用します。
現在の起点の位置は、<link linkend="view-pg-replication-origin-status"><structname>pg_replication_origin_status</structname></link> システムビューで確認できます。
トランザクション全体をスキップすることは、いかなる制約にも違反しない可能性のある変更をスキップすることを含むことに注意してください。
これは容易にサブスクライバーを不整合にする可能性があります。
オリジンやコミットタイムスタンプのようなコンフリクト行に関する詳細は、ログの<literal>DETAIL</literal>行で確認できます。
しかし、これらの情報は、サブスクライバーで<link linkend="guc-track-commit-timestamp"><varname>track_commit_timestamp</varname></link>が有効な場合にのみ表示されます。
この情報はローカルの変更を保持するか、リモートの変更を採用するかを決定する際に使用できます。
例えば上記ログの<literal>DETAIL</literal>は、既存の行がローカルで変更されたことを示しています。
ユーザは手動でリモート変更優先を実行できます。
  </para>

  <para>
<!--
   When the
   <link linkend="sql-createsubscription-params-with-streaming"><literal>streaming</literal></link>
   mode is <literal>parallel</literal>, the finish LSN of failed transactions
   may not be logged. In that case, it may be necessary to change the streaming
   mode to <literal>on</literal> or <literal>off</literal> and cause the same
   conflicts again so the finish LSN of the failed transaction will be written
   to the server log. For the usage of finish LSN, please refer to <link
   linkend="sql-altersubscription"><command>ALTER SUBSCRIPTION ...
   SKIP</command></link>.
-->
<link linkend="sql-createsubscription-params-with-streaming"><literal>streaming</literal></link>モードが<literal>parallel</literal>の場合、失敗したトランザクションの終了LSNはログに書き込まれないことがあります。
その場合、ストリーミングモードを<literal>on</literal>または<literal>off</literal>に変更し、再度同じコンフリクトを起こすことで、失敗したトランザクションの終了LSNをサーバのログに書き込むようにする必要があるかもしれません。
終了LSNの使用方法については、<link linkend="sql-altersubscription"><command>ALTER SUBSCRIPTION ... SKIP</command></link>を参照してください。
  </para>
 </sect1>

 <sect1 id="logical-replication-restrictions">
<!--
  <title>Restrictions</title>
-->
  <title>制限事項</title>

  <para>
<!--
   Logical replication currently has the following restrictions or missing
   functionality.  These might be addressed in future releases.
-->
論理レプリケーションには、以下の制限事項とサポートされていない機能があります。
将来のリリースでは、これらは対処されるかもしれません。
  </para>

  <itemizedlist>
   <listitem>
    <para>
<!--
     The database schema and DDL commands are not replicated.  The initial
     schema can be copied by hand using <literal>pg_dump
     &#45;-schema-only</literal>.  Subsequent schema changes would need to be kept
     in sync manually.  (Note, however, that there is no need for the schemas
     to be absolutely the same on both sides.)  Logical replication is robust
     when schema definitions change in a live database: When the schema is
     changed on the publisher and replicated data starts arriving at the
     subscriber but does not fit into the table schema, replication will error
     until the schema is updated.  In many cases, intermittent errors can be
     avoided by applying additive schema changes to the subscriber first.
-->
データベーススキーマおよびDDLコマンドはレプリケーションされません。
初期スキーマは、<literal>pg_dump --schema-only</literal>を使ってコピーすることができます。
以後のスキーマ変更の同期は手動で行ないます。
（なお、両者でスキーマは完全に同じである必要はないことに留意してください。）
稼働中のスキーマ定義変更に対して、論理レプリケーションは頑健です。
スキーマがパブリッシャー側で変更され、レプリケーションデータがサブスクライバー側に到着し始めたものの、データがテーブルスキーマに合致しない場合は、スキーマが変更されるまではレプリケーションはエラーとなります。
多くの場合、間欠的なエラーは、サブスクライバーに先に追加的なスキーマ変更を行うことで避けることができます。
    </para>
   </listitem>

   <listitem>
    <para>
<!--
     Sequence data is not replicated.  The data in serial or identity columns
     backed by sequences will of course be replicated as part of the table,
     but the sequence itself would still show the start value on the
     subscriber.  If the subscriber is used as a read-only database, then this
     should typically not be a problem.  If, however, some kind of switchover
     or failover to the subscriber database is intended, then the sequences
     would need to be updated to the latest values, either by copying the
     current data from the publisher (perhaps
     using <command>pg_dump</command>) or by determining a sufficiently high
     value from the tables themselves.
-->
シーケンスデータはレプリケーションされません。
シーケンスによって裏付けされたSERIAL型や識別列のデータは、もちろんテーブルの一部としてレプリケーションされます。
しかし、シーケンス自体は、サブスクライバーがスタートした時の値のままです。
サブスクライバーが読み取り専用のデータベースとして使われているなら、通常は問題になりません。
しかし、サブスクライバーのデータベースをスイッチオーバーやフェイルオーバーするつもりなら、パブリッシャーから現在のデータをコピーするか（おそらく<command>pg_dump</command>を使います）、テーブル自身から十分に大きな値を決定し、シーケンスを最新の値に更新しなければなりません。
    </para>
   </listitem>

   <listitem>
    <para>
<!--
     Replication of <command>TRUNCATE</command> commands is supported, but
     some care must be taken when truncating groups of tables connected by
     foreign keys.  When replicating a truncate action, the subscriber will
     truncate the same group of tables that was truncated on the publisher,
     either explicitly specified or implicitly collected via
     <literal>CASCADE</literal>, minus tables that are not part of the
     subscription.  This will work correctly if all affected tables are part
     of the same subscription.  But if some tables to be truncated on the
     subscriber have foreign-key links to tables that are not part of the same
     (or any) subscription, then the application of the truncate action on the
     subscriber will fail.
-->
<command>TRUNCATE</command>コマンドのレプリケーションはサポートされますが、外部キーで結びついたテーブル群を削除する場合には注意が必要です。
削除処理をレプリケーションするとき、サブスクライバーはパブリッシャーで明示的に指定され削除された、もしくは<literal>CASCADE</literal>により暗黙的に削除されたテーブル群から、サブスクリプションの一部ではないテーブルを除いたテーブル群を削除します。
この処理は、外部キーで関連付けられた全てのテーブルが同一のサブスクリプションの一部であれば、正常に動作します。
しかし、サブスクライバーで削除されるテーブルが同一のサブスクリプションの一部でないテーブルと外部キーで接続されていた場合、サブスクライバー上の削除処理は失敗します。
    </para>
   </listitem>

   <listitem>
    <para>
<!--
     Large objects (see <xref linkend="largeobjects"/>) are not replicated.
     There is no workaround for that, other than storing data in normal
     tables.
-->
ラージオブジェクト（<xref linkend="largeobjects"/>参照）はレプリケーションされません。
通常のテーブルにデータを格納する以外に回避方法はありません。
    </para>
   </listitem>

   <listitem>
    <para>
<!--
     Replication is only supported by tables, including partitioned tables.
     Attempts to replicate other types of relations, such as views, materialized
     views, or foreign tables, will result in an error.
-->
レプリケーションは、パーティション化テーブルを含むテーブルでのみサポートされています。
ビュー、マテリアライズドビュー、外部テーブルのような、その他の種類のリレーションをレプリケーションしようとすると、エラーになります。
    </para>
   </listitem>

   <listitem>
    <para>
<!--
     When replicating between partitioned tables, the actual replication
     originates, by default, from the leaf partitions on the publisher, so
     partitions on the publisher must also exist on the subscriber as valid
     target tables. (They could either be leaf partitions themselves, or they
     could be further subpartitioned, or they could even be independent
     tables.)  Publications can also specify that changes are to be replicated
     using the identity and schema of the partitioned root table instead of
     that of the individual leaf partitions in which the changes actually
     originate (see
     <link linkend="sql-createpublication-params-with-publish-via-partition-root"><literal>publish_via_partition_root</literal></link>
     parameter of <command>CREATE PUBLICATION</command>).
-->
パーティション化テーブル間でレプリケーションする場合には、実際のレプリケーションは、デフォルトでは、パブリッシャー側の末端のパーティションから開始します。ですので、パブリッシャー側のパーティションがサブスクライバー側にも有効な対象テーブルとして存在していなければなりません。
(対象テーブルは、それ自身が末端のパーティションかもしれませんし、さらにサブパーティション化されているかもしれません。独立したテーブルであっても構いません。)
パブリケーションは、変更が実際に開始された個々の末端のパーティションのIDとスキーマの代わりに、パーティション化されたルートのテーブルのIDとスキーマを使って指定することもできます(<command>CREATE PUBLICATION</command>の<link linkend="sql-createpublication-params-with-publish-via-partition-root"><literal>publish_via_partition_root</literal></link>パラメータを参照してください)。
    </para>
   </listitem>

   <listitem>
    <para>
<!--
     When using
     <link linkend="sql-altertable-replica-identity-full"><literal>REPLICA IDENTITY FULL</literal></link>
     on published tables, it is important to note that the <literal>UPDATE</literal>
     and <literal>DELETE</literal> operations cannot be applied to subscribers
     if the tables include attributes with datatypes (such as point or box)
     that do not have a default operator class for B-tree or Hash. However,
     this limitation can be overcome by ensuring that the table has a primary
     key or replica identity defined for it.
-->
パブリッシュされたテーブルで<link linkend="sql-altertable-replica-identity-full"><literal>REPLICA IDENTITY FULL</literal></link>を使用する場合、テーブルにBツリーまたはハッシュのデフォルトの演算子クラスを持たないデータ型(pointやboxなど)の属性が含まれていると、<literal>UPDATE</literal>および<literal>DELETE</literal>操作をサブスクライバーに適用できないことに注意してください。
ただし、この制限は、テーブルに主キーまたはレプリカアイデンティティを定義することで回避できます。
    </para>
   </listitem>
  </itemizedlist>
 </sect1>

 <sect1 id="logical-replication-architecture">
<!--
  <title>Architecture</title>
-->
  <title>アーキテクチャ</title>

  <para>
<!--
   Logical replication is built with an architecture similar to physical
   streaming replication (see <xref linkend="streaming-replication"/>).  It is
   implemented by <literal>walsender</literal> and <literal>apply</literal>
   processes.  The walsender process starts logical decoding (described
   in <xref linkend="logicaldecoding"/>) of the WAL and loads the standard
   logical decoding output plugin (<literal>pgoutput</literal>).  The plugin
   transforms the changes read
   from WAL to the logical replication protocol
   (see <xref linkend="protocol-logical-replication"/>) and filters the data
   according to the publication specification.  The data is then continuously
   transferred using the streaming replication protocol to the apply worker,
   which maps the data to local tables and applies the individual changes as
   they are received, in correct transactional order.
-->
論理レプリケーションは物理ストリーミングレプリケーション(<xref linkend="streaming-replication"/>参照)と似たアーキテクチャで構成されています。
<literal>walsender</literal>（WAL送信）プロセスと<literal>apply</literal>（適用）プロセスで実装されています。
WAL送信プロセスはWALのロジカルデコーディング（<xref linkend="logicaldecoding"/>に記載）を開始し、標準のロジカルデコーディング出力プラグイン（<literal>pgoutput</literal>）をロードします。
このプラグインは、WALから読み込んだ更新を論理レプリケーションプロトコル（<xref linkend="protocol-logical-replication"/>参照）に変換します。
そして、パブリケーションの指定にしたがってフィルタします。
データは次に、ストリーミングレプリケーションプロトコルを使って継続的に適用ワーカーに転送されます。
適用ワーカーは、データをローカルテーブルにマップし、更新を受信すると正しいトランザクション順に個々の更新を適用します。
  </para>

  <para>
<!--
   The apply process on the subscriber database always runs with
   <link linkend="guc-session-replication-role"><varname>session_replication_role</varname></link>
   set to <literal>replica</literal>. This means that, by default,
   triggers and rules will not fire on a subscriber. Users can optionally choose to
   enable triggers and rules on a table using the
   <link linkend="sql-altertable"><command>ALTER TABLE</command></link> command
   and the <literal>ENABLE TRIGGER</literal> and <literal>ENABLE RULE</literal>
   clauses.
-->
サブスクライバーデータベース上の適用プロセスは、常に<link linkend="guc-session-replication-role"><varname>session_replication_role</varname></link>を<literal>replica</literal>に設定して実行されます。
これは、デフォルトでは、トリガとルールはサブスクライバー上では起動されないことを意味します。
ユーザは、必要に応じて、 <link linkend="sql-altertable"><command>ALTER TABLE</command></link>コマンド、<literal>ENABLE TRIGGER</literal>および<literal>ENABLE RULE</literal>句を使用して、テーブルのトリガおよびルールを有効にすることを選択できます。
  </para>

  <para>
<!--
   The logical replication apply process currently only fires row triggers,
   not statement triggers.  The initial table synchronization, however, is
   implemented like a <command>COPY</command> command and thus fires both row
   and statement triggers for <command>INSERT</command>.
-->
今のところ、論理レプリケーション適用プロセスは行トリガだけを起動し、文トリガは起動しません。
ただし、初期テーブル同期は<command>COPY</command>コマンドのように実装されているので、<command>INSERT</command>の行と文トリガの両方を起動します。
  </para>

  <sect2 id="logical-replication-snapshot">
<!--
    <title>Initial Snapshot</title>
-->
    <title>初期スナップショット</title>
    <para>
<!--
     The initial data in existing subscribed tables are snapshotted and
     copied in parallel instances of a special kind of apply process.
     These special apply processes are dedicated table synchronization
     workers, spawned for each table to be synchronized.  Each table
     synchronization process will create its own replication slot and
     copy the existing data.  As soon as the copy is finished the table
     contents will become visible to other backends.  Once existing data
     is copied, the worker enters synchronization mode, which ensures
     that the table is brought up to a synchronized state with the main
     apply process by streaming any changes that happened during the
     initial data copy using standard logical replication.  During this
     synchronization phase, the changes are applied and committed in the same
     order as they happened on the publisher.  Once synchronization is done,
     control of the replication of the table is given back to the main apply
     process where replication continues as normal.
-->
既存のサブスクライブされたテーブル中の初期データのスナップショットが取得さ
れ、特殊な適用プロセスの並列インスタンスにコピーされます。
これらの特殊な適用プロセスは、同期されるテーブルごとに生成された、専用のテーブル同期ワーカーです。
このプロセスは自身のレプリケーションスロットを作成し、既存のデータをコピー
します。
コピーが終わるとすぐにテーブル内容が他のバックエンドから見えるようになりま
す。
既存のデータのコピーが終わると、ワーカーは同期モードに入ります。
このモードでは、初期データのコピー中に起こった更新を標準の論理レプリケーシ
ョンを使ってストリーミングすることにより、テーブルが主適用プロセスと同期状態になることを保証します。
この同期フェーズの間、パブリッシャーで発生したのと同じ順序で変更が適用され
、コミットされます。
ひとたび同期が完了すれば、テーブルのレプリケーションの制御は主適用プロセス
に戻され、レプリケーションは通常通り継続されます。
    </para>
    <note>
     <para>
<!--
      The publication
      <link linkend="sql-createpublication-params-with-publish"><literal>publish</literal></link>
      parameter only affects what DML operations will be replicated. The
      initial data synchronization does not take this parameter into account
      when copying the existing table data.
-->
パブリケーションの<link linkend="sql-createpublication-params-with-publish"><literal>publish</literal></link>パラメータは、レプリケーションされるDML操作にのみ影響します。
初期データ同期では、既存のテーブルデータをコピーするときにこのパラメータは考慮されません。
     </para>
    </note>
    <note>
     <para>
<!--
      If a table synchronization worker fails during copy, the apply worker
      detects the failure and respawns the table synchronization worker to
      continue the synchronization process. This behaviour ensures that
      transient errors do not permanently disrupt the replication setup. See
      also <link linkend="guc-wal-retrieve-retry-interval"><varname>wal_retrieve_retry_interval</varname></link>.
-->
コピー中にテーブル同期ワーカーが失敗した場合、適用ワーカーが失敗を検出し、テーブル同期ワーカーを再生成して同期プロセスを続行します。
この動作により、一時的なエラーによってレプリケーションのセットアップが永続的に中断されることがなくなります。
<link linkend="guc-wal-retrieve-retry-interval"><varname>wal_retrieve_retry_interval</varname></link>も参照してください。
     </para>
    </note>
  </sect2>
 </sect1>

 <sect1 id="logical-replication-monitoring">
<!--
  <title>Monitoring</title>
-->
  <title>監視</title>

  <para>
<!--
   Because logical replication is based on a similar architecture as
   <link linkend="streaming-replication">physical streaming replication</link>,
   the monitoring on a publication node is similar to monitoring of a
   physical replication primary
   (see <xref linkend="streaming-replication-monitoring"/>).
-->
論理レプリケーションは<link linkend="streaming-replication">物理ストリーミングレプリケーション</link>と類似のアーキテクチャに基づいているので、パブリケーションノードの監視は、物理レプリケーションのプライマリ（<xref linkend="streaming-replication-monitoring"/>参照）の監視と似ています。
  </para>

  <para>
<!--
   The monitoring information about subscription is visible in
   <link linkend="monitoring-pg-stat-subscription">
   <structname>pg_stat_subscription</structname></link>.
   This view contains one row for every subscription worker.  A subscription
   can have zero or more active subscription workers depending on its state.
-->
サブスクリプションに関する監視情報は<link linkend="monitoring-pg-stat-subscription"><structname>pg_stat_subscription</structname></link>で見ることができます。
このビューは、個々のサブスクリプションワーカー毎に1つの行を含んでいます。
サブスクリプションは状態により、0以上のアクティブなサブスクリプションワーカーを持つことができます。
  </para>

  <para>
<!--
   Normally, there is a single apply process running for an enabled
   subscription.  A disabled subscription or a crashed subscription will have
   zero rows in this view.  If the initial data synchronization of any
   table is in progress, there will be additional workers for the tables
   being synchronized. Moreover, if the
   <link linkend="sql-createsubscription-params-with-streaming"><literal>streaming</literal></link>
   transaction is applied in parallel, there may be additional parallel apply
   workers.
-->
有効なサブスクリプションのために通常は一つの適用プロセスが実行中です。
無効なサブスクリプション、あるいはクラッシュしたサブスクリプションはこのビュー中に0個の行を持ちます。
テーブルの初期データの同期が進行中なら、同期中のテーブルのための追加ワーカーが存在するでしょう。
さらに、<link linkend="sql-createsubscription-params-with-streaming"><literal>streaming</literal></link>トランザクションが並列に適用される場合、追加のパラレル適用ワーカーが存在する可能性があります。
  </para>
 </sect1>

 <sect1 id="logical-replication-security">
<!--
  <title>Security</title>
-->
  <title>セキュリティ</title>

  <para>
<!--
   The role used for the replication connection must have
   the <literal>REPLICATION</literal> attribute (or be a superuser).  If the
   role lacks <literal>SUPERUSER</literal> and <literal>BYPASSRLS</literal>,
   publisher row security policies can execute.  If the role does not trust
   all table owners, include <literal>options=-crow_security=off</literal> in
   the connection string; if a table owner then adds a row security policy,
   that setting will cause replication to halt rather than execute the policy.
   Access for the role must be configured in <filename>pg_hba.conf</filename>
   and it must have the <literal>LOGIN</literal> attribute.
-->
レプリケーション接続のために使われるロールには、<literal>REPLICATION</literal>属性が付与されている（もしくはスーパーユーザである）必要があります。
ロールに <literal>SUPERUSER</literal>と<literal>BYPASSRLS</literal>がない場合は、パブリッシャーは行セキュリティポリシーを実行できます。
ロールが全てのテーブルの所有者を信頼していない場合、接続文字列に<literal>options=-crow_security=off</literal>を含めてください。
テーブルの所有者が行セキュリティポリシーを追加した場合、ポリシーが実行されるのではなく、レプリケーションが停止します。
接続のためのロールは<filename>pg_hba.conf</filename>で設定され、 <literal>LOGIN</literal>属性を持つ必要があります。
  </para>

  <para>
<!--
   In order to be able to copy the initial table data, the role used for the
   replication connection must have the <literal>SELECT</literal> privilege on
   a published table (or be a superuser).
-->
テーブルの初期データをコピーできるためには、レプリケーション接続に使用されるロールは、パブリッシュされるテーブルに対して<literal>SELECT</literal>権限を持っていなければなりません。
（あるいはスーパーユーザでなければなりません。）
  </para>

  <para>
<!--
   To create a publication, the user must have the <literal>CREATE</literal>
   privilege in the database.
-->
パブリケーションを作成するためには、ユーザはデータベース中の<literal>CREATE</literal>権限を持っていなければなりません。
  </para>

  <para>
<!--
   To add tables to a publication, the user must have ownership rights on the
   table. To add all tables in schema to a publication, the user must be a
   superuser. To create a publication that publishes all tables or all tables in
   schema automatically, the user must be a superuser.
-->
テーブルをパブリケーションに追加するためには、ユーザはテーブルの所有権限を持っていなければなりません。
スキーマのすべてのテーブルをパブリケーションに追加するには、ユーザがスーパーユーザである必要があります。
自動的にすべてのテーブルにパブリッシュするパブリケーションを作成するには、ユーザはスーパーユーザでなければなりません。
  </para>

  <para>
<!--
   There are currently no privileges on publications.  Any subscription (that
   is able to connect) can access any publication.  Thus, if you intend to
   hide some information from particular subscribers, such as by using row
   filters or column lists, or by not adding the whole table to the
   publication, be aware that other publications in the same database could
   expose the same information.  Publication privileges might be added to
   <productname>PostgreSQL</productname> in the future to allow for
   finer-grained access control.
-->
現在、パブリケーションに権限はありません。
（接続可能な）サブスクリプションはすべて、パブリケーションにアクセスできます。
そのため、行フィルタや列リストを使用したり、テーブル全体をパブリケーションに追加しないなどして、特定のサブスクライバーからの情報を隠したい場合は、同じデータベース内の他のパブリケーションが同じ情報にアクセスできる可能性があることに注意してください。
より細かいアクセス制御を可能にするために、パブリケーション権限が将来<productname>PostgreSQL</productname>に追加される可能性があります。
  </para>

  <para>
<!--
   To create a subscription, the user must have the privileges of
   the <literal>pg_create_subscription</literal> role, as well as
   <literal>CREATE</literal> privileges on the database.
-->
サブスクリプションを作成するためには、ユーザは<literal>pg_create_subscription</literal>ロールの権限と、データベースの<literal>CREATE</literal>権限を持っていることが必要です。
  </para>

  <para>
<!--
   The subscription apply process will, at a session level, run with the
   privileges of the subscription owner. However, when performing an insert,
   update, delete, or truncate operation on a particular table, it will switch
   roles to the table owner and perform the operation with the table owner's
   privileges. This means that the subscription owner needs to be able to
   <literal>SET ROLE</literal> to each role that owns a replicated table.
-->
サブスクリプション適用プロセスは、セッションレベルで、サブスクリプション所有者の権限で実行されます。
ただし、特定のテーブルに対して挿入、更新、削除または切捨て操作を実行すると、テーブルの所有者にロールを切り替え、テーブルの所有者の権限で操作が実行されます。
つまり、サブスクリプション所有者は、レプリケートされたテーブルを所有する各ロールに対して<literal>SET ROLE</literal>を実行できる必要があります。
  </para>

  <para>
<!--
   If the subscription has been configured with
   <literal>run_as_owner = true</literal>, then no user switching will
   occur. Instead, all operations will be performed with the permissions
   of the subscription owner. In this case, the subscription owner only
   needs privileges to <literal>SELECT</literal>, <literal>INSERT</literal>,
   <literal>UPDATE</literal>, and <literal>DELETE</literal> from the
   target table, and does not need privileges to <literal>SET ROLE</literal>
   to the table owner. However, this also means that any user who owns
   a table into which replication is happening can execute arbitrary code with
   the privileges of the subscription owner. For example, they could do this
   by simply attaching a trigger to one of the tables which they own.
   Because it is usually undesirable to allow one role to freely assume
   the privileges of another, this option should be avoided unless user
   security within the database is of no concern.
-->
サブスクリプションが <literal>run_as_owner = true</literal>で構成されている場合、ユーザの切り替えは発生しません。
その代わり、すべての操作は、サブスクリプションの所有者の権限で実行されます。
この場合、サブスクリプションの所有者は、対象テーブルからの<literal>SELECT</literal>、<literal>INSERT</literal>、<literal>UPDATE</literal>、および<literal>DELETE</literal>権限のみが必要であり、テーブル所有者に対する<literal>SET ROLE</literal>権限は不要です。
しかし、これはまた、レプリケーションが行われているテーブルを所有するユーザは、サブスクリプション所有者の権限で任意のコードを実行できることを意味します。
たとえば、所有するテーブルにトリガを付加するだけで、これを実行できます。
通常、あるロールが別のロールの権限を自由に引き受けることは望ましくないので、データベース内のユーザセキュリティが問題にならない場合以外は、このオプションを避けるべきです。
  </para>

  <para>
<!--
   On the publisher, privileges are only checked once at the start of a
   replication connection and are not re-checked as each change record is read.
-->
パブリッシャーでは、権限はレプリケーション接続の開始時に一度だけチェックされ、変更レコードが読み取られるたびに再チェックされません。
  </para>

  <para>
<!--
   On the subscriber, the subscription owner's privileges are re-checked for
   each transaction when applied. If a worker is in the process of applying a
   transaction when the ownership of the subscription is changed by a
   concurrent transaction, the application of the current transaction will
   continue under the old owner's privileges.
-->
サブスクライバーでは、サブスクリプション所有者の権限は、適用時にトランザクションごとに再チェックされます。
同時に並行しているトランザクションによってサブスクリプションの所有権が変更されたときにワーカーがトランザクションを適用している場合、現在のトランザクションの適用は古い所有者の権限で継続されます。
  </para>
 </sect1>

 <sect1 id="logical-replication-config">
<!--
  <title>Configuration Settings</title>
-->
  <title>構成設定</title>

  <para>
<!--
   Logical replication requires several configuration options to be set. These
   options are relevant only on one side of the replication.
-->
論理レプリケーションでは、いくつかの構成オプションを設定することが必要です。
これらのオプションは、レプリケーションの一方の側にのみ関連します。
  </para>

  <sect2 id="logical-replication-config-publisher">
<!--
   <title>Publishers</title>
-->
   <title>パブリッシャー</title>

   <para>
<!--
    <link linkend="guc-wal-level"><varname>wal_level</varname></link> must be
    set to <literal>logical</literal>.
-->
<link linkend="guc-wal-level"><varname>wal_level</varname></link>は<literal>logical</literal>に設定することが必要です。
   </para>

   <para>
<!--
    <link linkend="guc-max-replication-slots"><varname>max_replication_slots</varname></link>
    must be set to at least the number of subscriptions expected to connect,
    plus some reserve for table synchronization.
-->
<link linkend="guc-max-replication-slots"><varname>max_replication_slots</varname></link>は、接続する予定のサブスクリプション数と、テーブル同期のために予約された数を加えた数以上に設定することが必要です。
   </para>

   <para>
<!--
    Logical replication slots are also affected by
    <link linkend="guc-idle-replication-slot-timeout"><varname>idle_replication_slot_timeout</varname></link>.
-->
論理レプリケーションスロットも<link linkend="guc-idle-replication-slot-timeout"><varname>idle_replication_slot_timeout</varname></link>の影響を受けます。
   </para>

   <para>
<!--
    <link linkend="guc-max-wal-senders"><varname>max_wal_senders</varname></link>
    should be set to at least the same as
    <varname>max_replication_slots</varname>, plus the number of physical
    replicas that are connected at the same time.
-->
<link linkend="guc-max-wal-senders"><varname>max_wal_senders</varname></link>は、少なくとも<varname>max_replication_slots</varname>に同時に接続されている物理レプリカの数も加えたものと同じ数に設定することが必要です。
   </para>

   <para>
<!--
    Logical replication walsender is also affected by
    <link linkend="guc-wal-sender-timeout"><varname>wal_sender_timeout</varname></link>.
-->
論理レプリケーションのwalsenderも<link linkend="guc-wal-sender-timeout"><varname>wal_sender_timeout</varname></link>の影響を受けます。
   </para>

  </sect2>

  <sect2 id="logical-replication-config-subscriber">
<!--
   <title>Subscribers</title>
-->
   <title>サブスクライバー</title>

   <para>
<!--
    <link linkend="guc-max-active-replication-origins"><varname>max_active_replication_origins</varname></link>
    must be set to at least the number of subscriptions that will be added to
    the subscriber, plus some reserve for table synchronization.
-->
<link linkend="guc-max-active-replication-origins"><varname>max_active_replication_origins</varname></link>は、少なくともサブスクライバーに追加されるサブスクリプションの数に、テーブル同期用の予約を加えた数以上に設定することが必要です。
   </para>

   <para>
<!--
    <link linkend="guc-max-logical-replication-workers"><varname>max_logical_replication_workers</varname></link>
    must be set to at least the number of subscriptions (for leader apply
    workers), plus some reserve for the table synchronization workers and
    parallel apply workers.
-->
<link linkend="guc-max-logical-replication-workers"><varname>max_logical_replication_workers</varname></link>は、少なくともサブスクリプション数（リーダー適用ワーカー用）に加えて、テーブル同期ワーカーとパラレル適用ワーカー用に予約された数を加えた数以上に設定することが必要です。
   </para>

   <para>
<!--
    <link linkend="guc-max-worker-processes"><varname>max_worker_processes</varname></link>
    may need to be adjusted to accommodate for replication workers, at least
    (<link linkend="guc-max-logical-replication-workers"><varname>max_logical_replication_workers</varname></link>
    + <literal>1</literal>). Note, some extensions and parallel queries also
    take worker slots from <varname>max_worker_processes</varname>.
-->
<link linkend="guc-max-worker-processes"><varname>max_worker_processes</varname></link>は、少なくともレプリケーションワーカーに対応するように調整する必要があるかもしれません(<link linkend="guc-max-logical-replication-workers"><varname>max_logical_replication_workers</varname></link> + <literal>1</literal>)。
なお、一部の拡張機能やパラレルクエリも<varname>max_worker_processes</varname>からワーカースロットを取得することに注意してください。
   </para>

   <para>
<!--
    <link linkend="guc-max-sync-workers-per-subscription"><varname>max_sync_workers_per_subscription</varname></link>
     controls the amount of parallelism of the initial data copy during the
     subscription initialization or when new tables are added.
-->
<link linkend="guc-max-sync-workers-per-subscription"><varname>max_sync_workers_per_subscription</varname></link>は、サブスクリプション初期化時や新しいテーブルが追加されたときの初期データコピーの並列度を制御します。
   </para>

   <para>
<!--
    <link linkend="guc-max-parallel-apply-workers-per-subscription"><varname>max_parallel_apply_workers_per_subscription</varname></link>
     controls the amount of parallelism for streaming of in-progress
     transactions with subscription parameter
     <literal>streaming = parallel</literal>.
-->
<link linkend="guc-max-parallel-apply-workers-per-subscription"><varname>max_parallel_apply_workers_per_subscription</varname></link>は、サブスクリプションパラメータ<literal>streaming = parallel</literal>で進行中のトランザクションのストリーミングに対する並列度を制御します。
   </para>

   <para>
<!--
    Logical replication workers are also affected by
    <link linkend="guc-wal-receiver-timeout"><varname>wal_receiver_timeout</varname></link>,
    <link linkend="guc-wal-receiver-status-interval"><varname>wal_receiver_status_interval</varname></link> and
    <link linkend="guc-wal-retrieve-retry-interval"><varname>wal_retrieve_retry_interval</varname></link>.
-->
論理レプリケーションワーカーも、<link linkend="guc-wal-receiver-timeout"><varname>wal_receiver_timeout</varname></link>、<link linkend="guc-wal-receiver-status-interval"><varname>wal_receiver_status_interval</varname></link>、および<link linkend="guc-wal-retrieve-retry-interval"><varname>wal_retrieve_retry_interval</varname></link>の影響を受けます。
   </para>

  </sect2>

 </sect1>

 <sect1 id="logical-replication-upgrade">
<!--
  <title>Upgrade</title>
-->
  <title>アップグレード</title>

  <para>
<!--
   Migration of <glossterm linkend="glossary-logical-replication-cluster">logical replication clusters</glossterm>
   is possible only when all the members of the old logical replication
   clusters are version 17.0 or later.
-->
<glossterm linkend="glossary-logical-replication-cluster">論理レプリケーションクラスタ</glossterm>の移行は、旧論理レプリケーションクラスタがすべてバージョン17.0以降の場合にのみ可能です。
  </para>

  <sect2 id="prepare-publisher-upgrades">
<!--
   <title>Prepare for Publisher Upgrades</title>
-->
   <title>パブリッシャーのアップグレードの準備</title>

   <para>
<!--
    <application>pg_upgrade</application> attempts to migrate logical
    slots. This helps avoid the need for manually defining the same
    logical slots on the new publisher. Migration of logical slots is
    only supported when the old cluster is version 17.0 or later.
    Logical slots on clusters before version 17.0 will silently be
    ignored.
-->
<application>pg_upgrade</application>は論理スロットの移行を試みます。
これは、新しいパブリッシャー上で同じ論理スロットを手動で定義する必要性を回避するのに役立ちます。
論理スロットの移行は、古いクラスタがバージョン17.0以降の場合にのみサポートされます。
バージョン17.0より前のクラスタ上の論理スロットは、警告なく無視されます。
   </para>

   <para>
<!--
    Before you start upgrading the publisher cluster, ensure that the
    subscription is temporarily disabled, by executing
    <link linkend="sql-altersubscription"><command>ALTER SUBSCRIPTION ... DISABLE</command></link>.
    Re-enable the subscription after the upgrade.
-->
パブリッシャークラスタのアップグレードを開始する前に、<link linkend="sql-altersubscription"><command>ALTER SUBSCRIPTION ... DISABLE</command></link>を実行して、サブスクリプションが一時的に無効になっていることを確認してください。
アップグレード後にサブスクリプションを再度有効にしてください。
   </para>

   <para>
<!--
    There are some prerequisites for <application>pg_upgrade</application> to
    be able to upgrade the logical slots. If these are not met an error
    will be reported.
-->
<application>pg_upgrade</application>が論理スロットをアップグレードできるようにするための前提条件がいくつかあります。
これらが満たされていない場合はエラーが報告されます。
   </para>

   <itemizedlist>
    <listitem>
     <para>
<!--
      The new cluster must have
      <link linkend="guc-wal-level"><varname>wal_level</varname></link> as
      <literal>logical</literal>.
-->
新しいクラスタは<link linkend="guc-wal-level"><varname>wal_level</varname></link>を<literal>logical</literal>にする必要があります。
     </para>
    </listitem>
    <listitem>
     <para>
<!--
      The new cluster must have
      <link linkend="guc-max-replication-slots"><varname>max_replication_slots</varname></link>
      configured to a value greater than or equal to the number of slots
      present in the old cluster.
-->
新しいクラスタは、古いクラスタに存在するスロットの数以上の値に<link linkend="guc-max-replication-slots"><varname>max_replication_slots</varname></link>を設定する必要があります。
     </para>
    </listitem>
    <listitem>
     <para>
<!--
      The output plugins referenced by the slots on the old cluster must be
      installed in the new PostgreSQL executable directory.
-->
古いクラスタのスロットで参照される出力プラグインは、新しいPostgreSQLの実行ファイル格納ディレクトリにインストールする必要があります。
     </para>
    </listitem>
    <listitem>
     <para>
<!--
      The old cluster has replicated all the transactions and logical decoding
      messages to subscribers.
-->
古いクラスタは、すべてのトランザクションとロジカルデコーディングメッセージをサブスクライバーに複製済です。
     </para>
    </listitem>
    <listitem>
     <para>
<!--
      All slots on the old cluster must be usable, i.e., there are no slots
      whose
      <link linkend="view-pg-replication-slots">pg_replication_slots</link>.<structfield>conflicting</structfield>
      is not <literal>true</literal>.
-->
古いクラスタの全てのスロットが使用可能でなければなりません。
つまり<link linkend="view-pg-replication-slots">pg_replication_slots</link>.<structfield>conflicting</structfield>が<literal>true</literal>であってはいけません。
     </para>
    </listitem>
    <listitem>
     <para>
<!--
      The new cluster must not have permanent logical slots, i.e.,
      there must be no slots where
      <link linkend="view-pg-replication-slots">pg_replication_slots</link>.<structfield>temporary</structfield>
      is <literal>false</literal>.
-->
新しいクラスタは、永続的な論理スロットを持ってはなりません。
つまり、<link linkend="view-pg-replication-slots">pg_replication_slots</link>.<structfield>temporary</structfield>が<literal>false</literal>であってはいけません。
     </para>
    </listitem>
   </itemizedlist>
  </sect2>

  <sect2 id="prepare-subscriber-upgrades">
<!--
   <title>Prepare for Subscriber Upgrades</title>
-->
   <title>サブスクライバーのアップグレードの準備</title>

   <para>
<!--
    Setup the <link linkend="logical-replication-config-subscriber">
    subscriber configurations</link> in the new subscriber.
    <application>pg_upgrade</application> attempts to migrate subscription
    dependencies which includes the subscription's table information present in
    <link linkend="catalog-pg-subscription-rel">pg_subscription_rel</link>
    system catalog and also the subscription's replication origin. This allows
    logical replication on the new subscriber to continue from where the
    old subscriber was up to. Migration of subscription dependencies is only
    supported when the old cluster is version 17.0 or later. Subscription
    dependencies on clusters before version 17.0 will silently be ignored.
-->
新しいサブスクライバーに<link linkend="logical-replication-config-subscriber">サブスクライバー構成</link>を設定します。
<application>pg_upgrade</application>は、<link linkend="catalog-pg-subscription-rel">pg_subscription_rel</link>システムカタログに存在するサブスクリプションのテーブル情報と、サブスクリプションのレプリケーション元を含むサブスクリプション依存関係の移行を試みます。
これにより、新しいサブスクライバーで論理レプリケーションを、古いサブスクラ
イバーが存在していた場所から継続できます。
サブスクリプションの依存関係の移行は、古いクラスタがバージョン17.0以降の場
合にのみサポートされます。
バージョン17.0より前のクラスタに対するサブスクリプションの依存関係は、警告
なく無視されます。
   </para>

   <para>
<!--
    There are some prerequisites for <application>pg_upgrade</application> to
    be able to upgrade the subscriptions. If these are not met an error
    will be reported.
-->
<application>pg_upgrade</application>がサブスクリプションをアップグレードできるようにするための前提条件がいくつかあります。
これらが満たされていない場合はエラーが報告されます。
   </para>

   <itemizedlist>
    <listitem>
     <para>
<!--
      All the subscription tables in the old subscriber should be in state
      <literal>i</literal> (initialize) or <literal>r</literal> (ready). This
      can be verified by checking <link linkend="catalog-pg-subscription-rel">pg_subscription_rel</link>.<structfield>srsubstate</structfield>.
-->
古いサブスクライバーのすべてのサブスクリプションテーブルは<literal>i</literal>（初期化）または<literal>r</literal>（準備完了）の状態である必要があります。
これは<link linkend="catalog-pg-subscription-rel">pg_subscription_rel</link>.<structfield>srsubstate</structfield>を調べることで確認できます。
     </para>
    </listitem>
    <listitem>
     <para>
<!--
      The replication origin entry corresponding to each of the subscriptions
      should exist in the old cluster. This can be found by checking
      <link linkend="catalog-pg-subscription">pg_subscription</link> and
      <link linkend="catalog-pg-replication-origin">pg_replication_origin</link>
      system tables.
-->
各サブスクリプションに対応するレプリケーション起点エントリは、古いクラスタに存在する必要があります。
これは、<link linkend="catalog-pg-subscription">pg_subscription</link>と<link linkend="catalog-pg-replication-origin">pg_replication_origin</link>システムテーブルを調べることで見つけることができます。
     </para>
    </listitem>
    <listitem>
     <para>
<!--
      The new cluster must have
      <link linkend="guc-max-active-replication-origins"><varname>max_active_replication_origins</varname></link>
      configured to a value greater than or equal to the number of
      subscriptions present in the old cluster.
-->
新しいクラスタは、古いクラスタに存在するサブスクリプションの数以上の値に<link linkend="guc-max-replication-slots"><varname>max_replication_slots</varname></link>を設定する必要があります。
     </para>
    </listitem>
   </itemizedlist>
  </sect2>

  <sect2 id="upgrading-logical-replication-clusters">
<!--
   <title>Upgrading Logical Replication Clusters</title>
-->
   <title>論理レプリケーションクラスタのアップグレード</title>

   <para>
<!--
    While upgrading a subscriber, write operations can be performed in the
    publisher. These changes will be replicated to the subscriber once the
    subscriber upgrade is completed.
-->
サブスクライバーをアップグレードしている間、書き込み操作はパブリッシャーでのみ実行できます。
これらの変更は、サブスクライバーのアップグレードが完了すると複製されます。
   </para>

   <note>
    <para>
<!--
     The logical replication restrictions apply to logical replication cluster
     upgrades also. See <xref linkend="logical-replication-restrictions"/> for
     details.
-->
論理レプリケーションの制限は、論理レプリケーションクラスタのアップグレードにも適用されます。
詳細は<xref linkend="logical-replication-restrictions"/>を参照してください。
    </para>
    <para>
<!--
     The prerequisites of publisher upgrade apply to logical replication
     cluster upgrades also. See <xref linkend="prepare-publisher-upgrades"/>
     for details.
-->
パブリッシャーアップグレードの前提条件は、論理レプリケーションクラスタのアップグレードにも適用されます。
詳細は<xref linkend="prepare-publisher-upgrades"/>を参照してください。
    </para>
    <para>
<!--
     The prerequisites of subscriber upgrade apply to logical replication
     cluster upgrades also. See <xref linkend="prepare-subscriber-upgrades"/>
     for details.
-->
サブスクライバーアップグレードの前提条件は、論理レプリケーションクラスタのアップグレードにも適用されます。
詳細は<xref linkend="prepare-publisher-upgrades"/>を参照してください。
    </para>
   </note>

   <warning>
    <para>
<!--
     Upgrading logical replication cluster requires multiple steps to be
     performed on various nodes. Because not all operations are
     transactional, the user is advised to take backups as described in
     <xref linkend="backup-base-backup"/>.
-->
論理レプリケーションクラスタのアップグレードは、様々なノードで複数の手順を実行する必要があります。
すべての処理がトランザクションのように振る舞うわけではないため、<xref linkend="backup-base-backup"/>の手順に従ってバックアップを取得することをお薦めします。
    </para>
   </warning>

   <para>
<!--
    The steps to upgrade the following logical replication clusters are
    detailed below:
-->
論理レプリケーションクラスタをアップグレードする手順は以下の通りです。
    <itemizedlist>
     <listitem>
      <para>
<!--
       Follow the steps specified in
       <xref linkend="steps-two-node-logical-replication-cluster"/> to upgrade
       a two-node logical replication cluster.
-->
2ノードの論理レプリケーションクラスタをアップグレードする場合は、<xref linkend="steps-two-node-logical-replication-cluster"/>に指定されている手順に従います。
      </para>
     </listitem>
     <listitem>
      <para>
<!--
       Follow the steps specified in
       <xref linkend="steps-cascaded-logical-replication-cluster"/> to upgrade
       a cascaded logical replication cluster.
-->
カスケード論理レプリケーションクラスタをアップグレードする場合は、<xref linkend="steps-cascaded-logical-replication-cluster"/>に指定されている手順に従います。
      </para>
     </listitem>
     <listitem>
      <para>
<!--
       Follow the steps specified in
       <xref linkend="steps-two-node-circular-logical-replication-cluster"/>
       to upgrade a two-node circular logical replication cluster.
-->
2ノードの循環論理レプリケーションクラスタをアップグレードする場合は、<xref linkend="steps-two-node-circular-logical-replication-cluster"/>に指定されている手順に従います。
      </para>
     </listitem>
    </itemizedlist>
   </para>

   <sect3 id="steps-two-node-logical-replication-cluster">
<!--
    <title>Steps to Upgrade a Two-node Logical Replication Cluster</title>
-->
    <title>2ノードの論理レプリケーションクラスタをアップグレードする手順</title>
     <para>
<!--
      Let's say publisher is in <literal>node1</literal> and subscriber is
      in <literal>node2</literal>. The subscriber <literal>node2</literal> has
      a subscription <literal>sub1_node1_node2</literal> which is subscribing
      the changes from <literal>node1</literal>.
-->
パブリッシャーが<literal>node1</literal>にあり、サブスクライバーが<literal>node2</literal>にあるとします。
サブスクライバー<literal>node2</literal>には、<literal>node1</literal>から変更をサブスクライブしているサブスクリプション<literal>sub1_node1_node2</literal>があります。
     </para>

     <procedure>
      <step id="two-node-cluster-disable-subscriptions-node2">
       <para>
<!--
        Disable all the subscriptions on <literal>node2</literal> that are
        subscribing the changes from <literal>node1</literal> by using
        <link linkend="sql-altersubscription-params-disable"><command>ALTER SUBSCRIPTION ... DISABLE</command></link>,
        e.g.:
-->
<link linkend="sql-altersubscription-params-disable"><command>ALTER SUBSCRIPTION ... DISABLE</command></link>を使用して、<literal>node1</literal>からの変更をサブスクライブしている<literal>node2</literal>上のすべてのサブスクリプションを無効にします。以下は、その例です。
<programlisting>
/* node2 # */ ALTER SUBSCRIPTION sub1_node1_node2 DISABLE;
</programlisting>
       </para>
      </step>
      <step>
       <para>
<!--
        Stop the publisher server in <literal>node1</literal>, e.g.:
-->
<literal>node1</literal>にあるパブリッシャーサーバを停止します。
<programlisting>
pg_ctl -D /opt/PostgreSQL/data1 stop
</programlisting>
       </para>
      </step>

      <step>
       <para>
<!--
        Initialize <literal>data1_upgraded</literal> instance by using the
        required newer version.
-->
必要とされる新しいバージョンを使用して、<literal>data1_upgraded</literal>インスタンスを初期化します。
       </para>
      </step>

      <step>
       <para>
<!--
        Upgrade the publisher <literal>node1</literal>'s server to the
        required newer version, e.g.:
-->
必要とされる新しいバージョンを使用して、<literal>node1</literal>にあるパブリッシャーサーバをアップグレードします。
<programlisting>
pg_upgrade
        --old-datadir "/opt/PostgreSQL/postgres/17/data1"
        --new-datadir "/opt/PostgreSQL/postgres/18/data1_upgraded"
        --old-bindir "/opt/PostgreSQL/postgres/17/bin"
        --new-bindir "/opt/PostgreSQL/postgres/18/bin"
</programlisting>
       </para>
      </step>

      <step>
       <para>
<!--
        Start the upgraded publisher server in <literal>node1</literal>, e.g.:
-->
<literal>node1</literal>にあるアップグレードされたパブリッシャーサーバを起動します。
<programlisting>
pg_ctl -D /opt/PostgreSQL/data1_upgraded start -l logfile
</programlisting>
       </para>
      </step>

      <step>
       <para>
<!--
        Stop the subscriber server in <literal>node2</literal>, e.g.:
-->
<literal>node2</literal>にあるサブスクライバーサーバを停止します。
<programlisting>
pg_ctl -D /opt/PostgreSQL/data2 stop
</programlisting>
       </para>
      </step>

      <step>
       <para>
<!--
        Initialize <literal>data2_upgraded</literal> instance by using the
        required newer version.
-->
必要とされる新しいバージョンを使用して、<literal>data2_upgraded</literal>インスタンスを初期化します。
       </para>
      </step>

      <step>
       <para>
<!--
        Upgrade the subscriber <literal>node2</literal>'s server to
        the required new version, e.g.:
-->
必要とされる新しいバージョンを使用して、<literal>node2</literal>にあるサブスクライバーサーバをアップグレードします。
<programlisting>
pg_upgrade
       --old-datadir "/opt/PostgreSQL/postgres/17/data2"
       --new-datadir "/opt/PostgreSQL/postgres/18/data2_upgraded"
       --old-bindir "/opt/PostgreSQL/postgres/17/bin"
       --new-bindir "/opt/PostgreSQL/postgres/18/bin"
</programlisting>
       </para>
      </step>

      <step>
       <para>
<!--
        Start the upgraded subscriber server in <literal>node2</literal>, e.g.:
-->
<literal>node2</literal>にあるアップグレードされたサブスクライバーサーバを起動します。
<programlisting>
pg_ctl -D /opt/PostgreSQL/data2_upgraded start -l logfile
</programlisting>
       </para>
      </step>

      <step>
       <para>
<!--
        On <literal>node2</literal>, create any tables that were created in
        the upgraded publisher <literal>node1</literal> server between
        <xref linkend="two-node-cluster-disable-subscriptions-node2"/>
        and now, e.g.:
-->
<literal>node2</literal>上で、<xref linkend="two-node-cluster-disable-subscriptions-node2"/>と現在までの間に、パブリッシャーサーバ<literal>node1</literal>で作成されたすべてのテーブルを作成します。
<programlisting>
/* node2 # */ CREATE TABLE distributors (did integer PRIMARY KEY, name varchar(40));
</programlisting>
       </para>
      </step>

      <step>
       <para>
<!--
        Enable all the subscriptions on <literal>node2</literal> that are
        subscribing the changes from <literal>node1</literal> by using
        <link linkend="sql-altersubscription-params-enable"><command>ALTER SUBSCRIPTION ... ENABLE</command></link>,
        e.g.:
-->
<link linkend="sql-altersubscription-params-enable"><command>ALTER SUBSCRIPTION ... ENABLE</command></link>コマンドを使用して、<literal>node1</literal>からの変更をサブスクライブする<literal>node2</literal>上のすべてのサブスクリプションを有効にします。
<programlisting>
/* node2 # */ ALTER SUBSCRIPTION sub1_node1_node2 ENABLE;
</programlisting>
       </para>
      </step>

      <step>
       <para>
<!--
        Refresh the <literal>node2</literal> subscription's publications using
        <link linkend="sql-altersubscription-params-refresh-publication"><command>ALTER SUBSCRIPTION ... REFRESH PUBLICATION</command></link>,
        e.g.:
-->
<link linkend="sql-altersubscription-params-refresh-publication"><command>ALTER SUBSCRIPTION ... REFRESH PUBLICATION</command></link>コマンドを使用して、<literal>node2</literal>サブスクリプションのパブリケーションをリフレッシュします。
<programlisting>
/* node2 # */ ALTER SUBSCRIPTION sub1_node1_node2 REFRESH PUBLICATION;
</programlisting>
       </para>
      </step>
     </procedure>

     <note>
      <para>
<!--
       In the steps described above, the publisher is upgraded first, followed
       by the subscriber. Alternatively, the user can use similar steps to
       upgrade the subscriber first, followed by the publisher.
-->
上記の手順では、パブリッシャーが最初にアップグレードされ、次にサブスクライバーがアップグレードされます。
または、同様の手順を使用して、まずサブスクライバーをアップグレードし、次にパブリッシャーをアップグレードすることもできます。
      </para>
     </note>
    </sect3>

    <sect3 id="steps-cascaded-logical-replication-cluster">
<!--
     <title>Steps to Upgrade a Cascaded Logical Replication Cluster</title>
-->
     <title>カスケード論理レプリケーションクラスタをアップグレードする手順</title>
     <para>
<!--
      Let's say we have a cascaded logical replication setup
      <literal>node1</literal>-><literal>node2</literal>-><literal>node3</literal>.
      Here <literal>node2</literal> is subscribing the changes from
      <literal>node1</literal> and <literal>node3</literal> is subscribing
      the changes from <literal>node2</literal>. The <literal>node2</literal>
      has a subscription <literal>sub1_node1_node2</literal> which is
      subscribing the changes from <literal>node1</literal>. The
      <literal>node3</literal> has a subscription
      <literal>sub1_node2_node3</literal> which is subscribing the changes from
      <literal>node2</literal>.
-->
カスケードされた論理レプリケーションセットアップ<literal>node1</literal>-><literal>node2</literal>-><literal>node3</literal>があるとします。
ここで、<literal>node2</literal>は<literal>node1</literal>からの変更をサブスクライブしており、<literal>node3</literal>は<literal>node2</literal>からの変更をサブスクライブしています。
<literal>node2</literal>には<literal>node1</literal>からの変更をサブスクライブしている<literal>sub1_node1_node2</literal>サブスクリプションがあります。
<literal>node3</literal>には<literal>node2</literal>からの変更をサブスクライブしている<literal>sub1_node2_node3</literal>サブスクリプションがあります。
<literal>node3</literal>
     </para>

     <procedure>
      <step id="cascaded-cluster-disable-sub-node1-node2">
       <para>
<!--
        Disable all the subscriptions on <literal>node2</literal> that are
        subscribing the changes from <literal>node1</literal> by using
        <link linkend="sql-altersubscription-params-disable"><command>ALTER SUBSCRIPTION ... DISABLE</command></link>,
        e.g.:
-->
<link linkend="sql-altersubscription-params-disable"><command>ALTER SUBSCRIPTION ... DISABLE</command></link>を使用して、<literal>node1</literal>からの変更をサブスクライブしている<literal>node2</literal>上のすべてのサブスクリプションを無効にします。以下は、その例です。
<programlisting>
/* node2 # */ ALTER SUBSCRIPTION sub1_node1_node2 DISABLE;
</programlisting>
       </para>
      </step>

      <step>
       <para>
<!--
        Stop the server in <literal>node1</literal>, e.g.:
-->
<literal>node1</literal>にあるサーバを停止します。
<programlisting>
pg_ctl -D /opt/PostgreSQL/data1 stop
</programlisting>
       </para>
      </step>

      <step>
       <para>
<!--
        Initialize <literal>data1_upgraded</literal> instance by using the
        required newer version.
-->
必要とされる新しいバージョンを使用して、<literal>data1_upgraded</literal>インスタンスを初期化します。
       </para>
      </step>

      <step>
       <para>
<!--
        Upgrade the <literal>node1</literal>'s server to the required newer
        version, e.g.:
-->
必要とされる新しいバージョンを使用して、<literal>node1</literal>にあるサーバをアップグレードします。
<programlisting>
pg_upgrade
        --old-datadir "/opt/PostgreSQL/postgres/17/data1"
        --new-datadir "/opt/PostgreSQL/postgres/18/data1_upgraded"
        --old-bindir "/opt/PostgreSQL/postgres/17/bin"
        --new-bindir "/opt/PostgreSQL/postgres/18/bin"
</programlisting>
       </para>
      </step>

      <step>
       <para>
<!--
        Start the upgraded server in <literal>node1</literal>, e.g.:
-->
<literal>node1</literal>にあるアップグレードされたサーバを起動します。
<programlisting>
pg_ctl -D /opt/PostgreSQL/data1_upgraded start -l logfile
</programlisting>
       </para>
      </step>

      <step id="cascaded-cluster-disable-sub-node2-node3">
       <para>
<!--
        Disable all the subscriptions on <literal>node3</literal> that are
        subscribing the changes from <literal>node2</literal> by using
        <link linkend="sql-altersubscription-params-disable"><command>ALTER SUBSCRIPTION ... DISABLE</command></link>,
        e.g.:
-->
<link linkend="sql-altersubscription-params-disable"><command>ALTER SUBSCRIPTION ... DISABLE</command></link>を使用して、<literal>node2</literal>からの変更をサブスクライブしている<literal>node3</literal>上のすべてのサブスクリプションを無効にします。
<programlisting>
/* node3 # */ ALTER SUBSCRIPTION sub1_node2_node3 DISABLE;
</programlisting>
       </para>
      </step>

      <step>
       <para>
<!--
        Stop the server in <literal>node2</literal>, e.g.:
-->
<literal>node2</literal>にあるサーバを停止します。
<programlisting>
pg_ctl -D /opt/PostgreSQL/data2 stop
</programlisting>
       </para>
      </step>

      <step>
       <para>
<!--
        Initialize <literal>data2_upgraded</literal> instance by using the
        required newer version.
-->
必要とされる新しいバージョンを使用して、<literal>data2_upgraded</literal>インスタンスを初期化します。
       </para>
      </step>

      <step>
       <para>
<!--
        Upgrade the <literal>node2</literal>'s server to the required
        new version, e.g.:
-->
必要とされる新しいバージョンを使用して、<literal>node2</literal>にあるサーバをアップグレードします。
<programlisting>
pg_upgrade
        --old-datadir "/opt/PostgreSQL/postgres/17/data2"
        --new-datadir "/opt/PostgreSQL/postgres/18/data2_upgraded"
        --old-bindir "/opt/PostgreSQL/postgres/17/bin"
        --new-bindir "/opt/PostgreSQL/postgres/18/bin"
</programlisting>
       </para>
      </step>

      <step>
       <para>
<!--
        Start the upgraded server in <literal>node2</literal>, e.g.:
-->
<literal>node2</literal>にあるアップグレードされたサーバを起動します。
<programlisting>
pg_ctl -D /opt/PostgreSQL/data2_upgraded start -l logfile
</programlisting>
       </para>
      </step>

      <step>
       <para>
<!--
        On <literal>node2</literal>, create any tables that were created in
        the upgraded publisher <literal>node1</literal> server between
        <xref linkend="cascaded-cluster-disable-sub-node1-node2"/>
        and now, e.g.:
-->
<literal>node2</literal>上で、<xref linkend="cascaded-cluster-disable-sub-node1-node2"/>と現在までの間に、パブリッシャーサーバ<literal>node1</literal>で作成されたすべてのテーブルを作成します。
<programlisting>
/* node2 # */ CREATE TABLE distributors (did integer PRIMARY KEY, name varchar(40));
</programlisting>
       </para>
      </step>

      <step>
       <para>
<!--
        Enable all the subscriptions on <literal>node2</literal> that are
        subscribing the changes from <literal>node1</literal> by using
        <link linkend="sql-altersubscription-params-enable"><command>ALTER SUBSCRIPTION ... ENABLE</command></link>,
        e.g.:
-->
<link linkend="sql-altersubscription-params-enable"><command>ALTER SUBSCRIPTION ... ENABLE</command></link>コマンドを使用して、<literal>node1</literal>からの変更をサブスクライブする<literal>node2</literal>上のすべてのサブスクリプションを有効にします。
<programlisting>
/* node2 # */ ALTER SUBSCRIPTION sub1_node1_node2 ENABLE;
</programlisting>
       </para>
      </step>

      <step>
       <para>
<!--
        Refresh the <literal>node2</literal> subscription's publications using
        <link linkend="sql-altersubscription-params-refresh-publication"><command>ALTER SUBSCRIPTION ... REFRESH PUBLICATION</command></link>,
        e.g.:
-->
<link linkend="sql-altersubscription-params-refresh-publication"><command>ALTER SUBSCRIPTION ... REFRESH PUBLICATION</command></link>コマンドを使用して、<literal>node2</literal>サブスクリプションのパブリケーションをリフレッシュします。
<programlisting>
/* node2 # */ ALTER SUBSCRIPTION sub1_node1_node2 REFRESH PUBLICATION;
</programlisting>
       </para>
      </step>

      <step>
       <para>
<!--
        Stop the server in <literal>node3</literal>, e.g.:
-->
<literal>node3</literal>にあるサーバを停止します。
<programlisting>
pg_ctl -D /opt/PostgreSQL/data3 stop
</programlisting>
       </para>
      </step>

      <step>
       <para>
<!--
        Initialize <literal>data3_upgraded</literal> instance by using the
        required newer version.
-->
必要とされる新しいバージョンを使用して、<literal>data3_upgraded</literal>インスタンスを初期化します。
       </para>
      </step>

      <step>
       <para>
<!--
        Upgrade the <literal>node3</literal>'s server to the required
        new version, e.g.:
-->
必要とされる新しいバージョンを使用して、<literal>node3</literal>にあるサーバをアップグレードします。
<programlisting>
pg_upgrade
        --old-datadir "/opt/PostgreSQL/postgres/17/data3"
        --new-datadir "/opt/PostgreSQL/postgres/18/data3_upgraded"
        --old-bindir "/opt/PostgreSQL/postgres/17/bin"
        --new-bindir "/opt/PostgreSQL/postgres/18/bin"
</programlisting>
       </para>
      </step>

      <step>
       <para>
<!--
        Start the upgraded server in <literal>node3</literal>, e.g.:
-->
<literal>node3</literal>にあるアップグレードされたサーバを起動します。
<programlisting>
pg_ctl -D /opt/PostgreSQL/data3_upgraded start -l logfile
</programlisting>
       </para>
      </step>

      <step>
       <para>
<!--
        On <literal>node3</literal>, create any tables that were created in
        the upgraded <literal>node2</literal> between
        <xref linkend="cascaded-cluster-disable-sub-node2-node3"/> and now,
        e.g.:
-->
<literal>node3</literal>上で、<xref linkend="cascaded-cluster-disable-sub-node2-node3"/>と現在までの間に、パブリッシャーサーバ<literal>node2</literal>で作成されたすべてのテーブルを作成します。
<programlisting>
/* node3 # */ CREATE TABLE distributors (did integer PRIMARY KEY, name varchar(40));
</programlisting>
       </para>
      </step>

      <step>
       <para>
<!--
        Enable all the subscriptions on <literal>node3</literal> that are
        subscribing the changes from <literal>node2</literal> by using
        <link linkend="sql-altersubscription-params-enable"><command>ALTER SUBSCRIPTION ... ENABLE</command></link>,
        e.g.:
-->
<link linkend="sql-altersubscription-params-enable"><command>ALTER SUBSCRIPTION ... ENABLE</command></link>コマンドを使用して、<literal>node2</literal>からの変更をサブスクライブする<literal>node3</literal>上のすべてのサブスクリプションを有効にします。
<programlisting>
/* node3 # */ ALTER SUBSCRIPTION sub1_node2_node3 ENABLE;
</programlisting>
       </para>
      </step>

      <step>
       <para>
<!--
        Refresh the <literal>node3</literal> subscription's publications using
        <link linkend="sql-altersubscription-params-refresh-publication"><command>ALTER SUBSCRIPTION ... REFRESH PUBLICATION</command></link>,
        e.g.:
-->
<link linkend="sql-altersubscription-params-refresh-publication"><command>ALTER SUBSCRIPTION ... REFRESH PUBLICATION</command></link>コマンドを使用して、<literal>node3</literal>サブスクリプションのパブリケーションをリフレッシュします。
<programlisting>
/* node3 # */ ALTER SUBSCRIPTION sub1_node2_node3 REFRESH PUBLICATION;
</programlisting>
       </para>
      </step>
     </procedure>
    </sect3>

    <sect3 id="steps-two-node-circular-logical-replication-cluster">
<!--
     <title>Steps to Upgrade a Two-node Circular Logical Replication Cluster</title>
-->
     <title>2ノードの循環論理レプリケーションクラスタをアップグレードする手順</title>
     <para>
<!--
      Let's say we have a circular logical replication setup
      <literal>node1</literal>-><literal>node2</literal> and
      <literal>node2</literal>-><literal>node1</literal>. Here
      <literal>node2</literal> is subscribing the changes from
      <literal>node1</literal> and <literal>node1</literal> is subscribing
      the changes from <literal>node2</literal>. The <literal>node1</literal>
      has a subscription <literal>sub1_node2_node1</literal> which is
      subscribing the changes from <literal>node2</literal>. The
      <literal>node2</literal> has a subscription
      <literal>sub1_node1_node2</literal> which is subscribing the changes from
      <literal>node1</literal>.
-->
循環論理レプリケーションセットアップ<literal>node1</literal>-><literal>node2</literal>および<literal>node2</literal>-><literal>node1</literal>があるとします。
ここで、<literal>node2</literal>は<literal>node1</literal>からの変更をサブスクライブしており、<literal>node1</literal>は<literal>node2</literal>からの変更をサブスクライブしています。
<literal>node1</literal>には<literal>node2</literal>からの変更をサブスクライブしている<literal>sub1_node2_node1</literal>サブスクリプションがあります。
<literal>node2</literal>には<literal>node1</literal>からの変更をサブスクライブしている<literal>sub1_node1_node2</literal>サブスクリプションがあります。
     </para>

     <procedure>
      <step id="circular-cluster-disable-sub-node2">
       <para>
<!--
        Disable all the subscriptions on <literal>node2</literal> that are
        subscribing the changes from <literal>node1</literal> by using
        <link linkend="sql-altersubscription-params-disable"><command>ALTER SUBSCRIPTION ... DISABLE</command></link>,
        e.g.:
-->
<link linkend="sql-altersubscription-params-disable"><command>ALTER SUBSCRIPTION ... DISABLE</command></link>を使用して、<literal>node1</literal>からの変更をサブスクライブしている<literal>node2</literal>上のすべてのサブスクリプションを無効にします。
<programlisting>
/* node2 # */ ALTER SUBSCRIPTION sub1_node1_node2 DISABLE;
</programlisting>
       </para>
      </step>

      <step>
       <para>
<!--
        Stop the server in <literal>node1</literal>, e.g.:
-->
<literal>node1</literal>にあるサーバを停止します。
<programlisting>
pg_ctl -D /opt/PostgreSQL/data1 stop
</programlisting>
       </para>
      </step>

      <step>
       <para>
<!--
        Initialize <literal>data1_upgraded</literal> instance by using the
        required newer version.
-->
必要とされる新しいバージョンを使用して、<literal>data1_upgraded</literal>インスタンスを初期化します。
       </para>
      </step>

      <step>
       <para>
<!--
        Upgrade the <literal>node1</literal>'s server to the required
        newer version, e.g.:
-->
必要とされる新しいバージョンを使用して、<literal>node1</literal>にあるサーバをアップグレードします。
<programlisting>
pg_upgrade
        --old-datadir "/opt/PostgreSQL/postgres/17/data1"
        --new-datadir "/opt/PostgreSQL/postgres/18/data1_upgraded"
        --old-bindir "/opt/PostgreSQL/postgres/17/bin"
        --new-bindir "/opt/PostgreSQL/postgres/18/bin"
</programlisting>
       </para>
      </step>

      <step>
       <para>
<!--
        Start the upgraded server in <literal>node1</literal>, e.g.:
-->
<literal>node1</literal>にあるアップグレードされたサーバを起動します。
<programlisting>
pg_ctl -D /opt/PostgreSQL/data1_upgraded start -l logfile
</programlisting>
       </para>
      </step>

      <step>
       <para>
<!--
        Enable all the subscriptions on <literal>node2</literal> that are
        subscribing the changes from <literal>node1</literal> by using
        <link linkend="sql-altersubscription-params-enable"><command>ALTER SUBSCRIPTION ... ENABLE</command></link>,
        e.g.:
-->
<link linkend="sql-altersubscription-params-enable"><command>ALTER SUBSCRIPTION ... ENABLE</command></link>コマンドを使用して、<literal>node1</literal>からの変更をサブスクライブする<literal>node2</literal>上のすべてのサブスクリプションを有効にします。
<programlisting>
/* node2 # */ ALTER SUBSCRIPTION sub1_node1_node2 ENABLE;
</programlisting>
       </para>
      </step>

      <step>
       <para>
<!--
        On <literal>node1</literal>, create any tables that were created in
        <literal>node2</literal> between <xref linkend="circular-cluster-disable-sub-node2"/>
        and now, e.g.:
-->
<literal>node1</literal>上で、<xref linkend="circular-cluster-disable-sub-node2"/>と現在までの間に、パブリッシャーサーバ<literal>node2</literal>で作成されたすべてのテーブルを作成します。
<programlisting>
/* node1 # */ CREATE TABLE distributors (did integer PRIMARY KEY, name varchar(40));
</programlisting>
       </para>
      </step>


      <step>
       <para>
<!--
        Refresh the <literal>node1</literal> subscription's publications to
        copy initial table data from <literal>node2</literal> using
        <link linkend="sql-altersubscription-params-refresh-publication"><command>ALTER SUBSCRIPTION ... REFRESH PUBLICATION</command></link>,
        e.g.:
-->
<link linkend="sql-altersubscription-params-refresh-publication"><command>ALTER SUBSCRIPTION ... REFRESH PUBLICATION</command></link>コマンドを使用して、<literal>node1</literal>サブスクリプションのパブリケーションをリフレッシュします。
<programlisting>
/* node1 # */ ALTER SUBSCRIPTION sub1_node2_node1 REFRESH PUBLICATION;
</programlisting>
       </para>
      </step>

      <step id="circular-cluster-disable-sub-node1">
       <para>
<!--
        Disable all the subscriptions on <literal>node1</literal> that are
        subscribing the changes from <literal>node2</literal> by using
        <link linkend="sql-altersubscription-params-disable"><command>ALTER SUBSCRIPTION ... DISABLE</command></link>,
        e.g.:
-->
<link linkend="sql-altersubscription-params-disable"><command>ALTER SUBSCRIPTION ... DISABLE</command></link>を使用して、<literal>node2</literal>からの変更をサブスクライブしている<literal>node1</literal>上のすべてのサブスクリプションを無効にします。
<programlisting>
/* node1 # */ ALTER SUBSCRIPTION sub1_node2_node1 DISABLE;
</programlisting>
       </para>
      </step>

      <step>
       <para>
<!--
        Stop the server in <literal>node2</literal>, e.g.:
-->
<literal>node2</literal>にあるサーバを停止します。
<programlisting>
pg_ctl -D /opt/PostgreSQL/data2 stop
</programlisting>
       </para>
      </step>

      <step>
       <para>
<!--
        Initialize <literal>data2_upgraded</literal> instance by using the
        required newer version.
-->
必要とされる新しいバージョンを使用して、<literal>data2_upgraded</literal>インスタンスを初期化します。
       </para>
      </step>

      <step>
       <para>
<!--
        Upgrade the <literal>node2</literal>'s server to the required
        new version, e.g.:
-->
必要とされる新しいバージョンを使用して、<literal>node2</literal>にあるサーバをアップグレードします。
<programlisting>
pg_upgrade
        --old-datadir "/opt/PostgreSQL/postgres/17/data2"
        --new-datadir "/opt/PostgreSQL/postgres/18/data2_upgraded"
        --old-bindir "/opt/PostgreSQL/postgres/17/bin"
        --new-bindir "/opt/PostgreSQL/postgres/18/bin"
</programlisting>
       </para>
      </step>

      <step>
       <para>
<!--
        Start the upgraded server in <literal>node2</literal>, e.g.:
-->
<literal>node2</literal>にあるアップグレードされたサーバを起動します。
<programlisting>
pg_ctl -D /opt/PostgreSQL/data2_upgraded start -l logfile
</programlisting>
       </para>
      </step>

      <step>
       <para>
<!--
        Enable all the subscriptions on <literal>node1</literal> that are
        subscribing the changes from <literal>node2</literal> by using
        <link linkend="sql-altersubscription-params-enable"><command>ALTER SUBSCRIPTION ... ENABLE</command></link>,
        e.g.:
-->
<link linkend="sql-altersubscription-params-enable"><command>ALTER SUBSCRIPTION ... ENABLE</command></link>コマンドを使用して、<literal>node2</literal>からの変更をサブスクライブする<literal>node1</literal>上のすべてのサブスクリプションを有効にします。
<programlisting>
/* node1 # */ ALTER SUBSCRIPTION sub1_node2_node1 ENABLE;
</programlisting>
       </para>
      </step>

      <step>
       <para>
<!--
        On <literal>node2</literal>, create any tables that were created in
        the upgraded <literal>node1</literal> between <xref linkend="circular-cluster-disable-sub-node1"/>
        and now, e.g.:
-->
<literal>node2</literal>上で、<xref linkend="circular-cluster-disable-sub-node1"/>と現在までの間に、パブリッシャーサーバ<literal>node1</literal>で作成されたすべてのテーブルを作成します。
<programlisting>
/* node2 # */ CREATE TABLE distributors (did integer PRIMARY KEY, name varchar(40));
</programlisting>
       </para>
      </step>

      <step>
       <para>
<!--
        Refresh the <literal>node2</literal> subscription's publications to
        copy initial table data from <literal>node1</literal> using
        <link linkend="sql-altersubscription-params-refresh-publication"><command>ALTER SUBSCRIPTION ... REFRESH PUBLICATION</command></link>,
        e.g.:
-->
<link linkend="sql-altersubscription-params-refresh-publication"><command>ALTER SUBSCRIPTION ... REFRESH PUBLICATION</command></link>コマンドを使用して、<literal>node2</literal>サブスクリプションのパブリケーションをリフレッシュします。
<programlisting>
/* node2 # */ ALTER SUBSCRIPTION sub1_node1_node2 REFRESH PUBLICATION;
</programlisting>
       </para>
      </step>
     </procedure>
    </sect3>

   </sect2>
 </sect1>

 <sect1 id="logical-replication-quick-setup">
<!--
  <title>Quick Setup</title>
-->
  <title>簡単な設定</title>

  <para>
<!--
   First set the configuration options in <filename>postgresql.conf</filename>:
-->
まず<filename>postgresql.conf</filename>の設定オプションを設定してください。
<programlisting>
wal_level = logical
</programlisting>
<!--
   The other required settings have default values that are sufficient for a
   basic setup.
-->
基本的な設定のためには、それ以外の設定はデフォルトのままで十分です。
  </para>

  <para>
<!--
   <filename>pg_hba.conf</filename> needs to be adjusted to allow replication
   (the values here depend on your actual network configuration and user you
   want to use for connecting):
-->
<filename>pg_hba.conf</filename>はレプリケーションを許可するために調整が必要です。
（ここで示した値は、実際のネットワーク設定と、接続に使用するユーザにより異なります。）
<programlisting>
host     all     repuser     0.0.0.0/0     md5
</programlisting>
  </para>

  <para>
<!--
   Then on the publisher database:
-->
次にパブリッシャーデータベースで以下を実行します。
<programlisting>
CREATE PUBLICATION mypub FOR TABLE users, departments;
</programlisting>
  </para>

  <para>
<!--
   And on the subscriber database:
-->
サブスクライバーデータベースでは次を実行します。
<programlisting>
CREATE SUBSCRIPTION mysub CONNECTION 'dbname=foo host=bar user=repuser' PUBLICATION mypub;
</programlisting>
  </para>

  <para>
<!--
   The above will start the replication process, which synchronizes the
   initial table contents of the tables <literal>users</literal> and
   <literal>departments</literal> and then starts replicating
   incremental changes to those tables.
-->
上記により、テーブル<literal>users</literal>と<literal>departments</literal>の初期内容の同期プロセスが起動されます。
その後、これらのテーブルへの増分変更のレプリケーションが開始します。
  </para>
 </sect1>
</chapter>
