<!-- doc/src/sgml/datatype.sgml -->

 <chapter id="datatype">
<!--
  <title>Data Types</title>
-->
  <title>データ型</title>

  <indexterm zone="datatype">
   <primary>data type</primary>
  </indexterm>
  <indexterm zone="datatype">
   <primary>データ型</primary>
  </indexterm>

  <indexterm>
   <primary>type</primary>
   <see>data type</see>
  </indexterm>
  <indexterm>
   <primary>型</primary>
   <see>データ型</see>
  </indexterm>

  <para>
<!--
   <productname>PostgreSQL</productname> has a rich set of native data
   types available to users.  Users can add new types to
   <productname>PostgreSQL</productname> using the <xref
   linkend="sql-createtype"/> command.
-->
<productname>PostgreSQL</productname>にはユーザが使用可能な豊富なデータ型が始めから備わっています。
<xref linkend="sql-createtype"/>コマンドで<productname>PostgreSQL</productname>に対し新しいデータ型を追加できます。
  </para>

  <para>
<!--
   <xref linkend="datatype-table"/> shows all the built-in general-purpose data
   types. Most of the alternative names listed in the
   <quote>Aliases</quote> column are the names used internally by
   <productname>PostgreSQL</productname> for historical reasons.  In
   addition, some internally used or deprecated types are available,
   but are not listed here.
-->
<xref linkend="datatype-table"/>に組み込みの汎用データ型をすべて示します。
<quote>別名</quote>欄に列挙された代替名称のほとんどは、歴史的な理由により<productname>PostgreSQL</productname>の内部で使用されている名前です。
他にも、内部で使用されるデータ型、削除予定のデータ型もありますが、ここにはリストされていません。
  </para>

   <table id="datatype-table">
<!--
    <title>Data Types</title>
-->
    <title>データ型</title>
    <tgroup cols="3">
     <colspec colname="col1" colwidth="2*"/>
     <colspec colname="col2" colwidth="1*"/>
     <colspec colname="col3" colwidth="2*"/>
     <thead>
      <row>
<!--
       <entry>Name</entry>
       <entry>Aliases</entry>
       <entry>Description</entry>
-->
       <entry>名称</entry>
       <entry>別名</entry>
       <entry>説明</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry><type>bigint</type></entry>
       <entry><type>int8</type></entry>
<!--
       <entry>signed eight-byte integer</entry>
-->
       <entry>8バイト符号付き整数</entry>
      </row>

      <row>
       <entry><type>bigserial</type></entry>
       <entry><type>serial8</type></entry>
<!--
       <entry>autoincrementing eight-byte integer</entry>
-->
       <entry>自動増分8バイト整数</entry>
      </row>

      <row>
       <entry><type>bit [ (<replaceable>n</replaceable>) ]</type></entry>
       <entry></entry>
<!--
       <entry>fixed-length bit string</entry>
-->
       <entry>固定長ビット列</entry>
      </row>

      <row>
       <entry><type>bit varying [ (<replaceable>n</replaceable>) ]</type></entry>
       <entry><type>varbit [ (<replaceable>n</replaceable>) ]</type></entry>
<!--
       <entry>variable-length bit string</entry>
-->
       <entry>可変長ビット列</entry>
      </row>

      <row>
       <entry><type>boolean</type></entry>
       <entry><type>bool</type></entry>
<!--
       <entry>logical Boolean (true/false)</entry>
-->
       <entry>論理値（真/偽）</entry>
      </row>

      <row>
       <entry><type>box</type></entry>
       <entry></entry>
<!--
       <entry>rectangular box on a plane</entry>
-->
       <entry>平面上の矩形</entry>
      </row>

      <row>
       <entry><type>bytea</type></entry>
       <entry></entry>
<!--
       <entry>binary data (<quote>byte array</quote>)</entry>
-->
       <entry>バイナリデータ（<quote>バイトの配列（byte array）</quote>）</entry>
      </row>

      <row>
       <entry><type>character [ (<replaceable>n</replaceable>) ]</type></entry>
       <entry><type>char [ (<replaceable>n</replaceable>) ]</type></entry>
<!--
       <entry>fixed-length character string</entry>
-->
       <entry>固定長文字列</entry>
      </row>

      <row>
       <entry><type>character varying [ (<replaceable>n</replaceable>) ]</type></entry>
       <entry><type>varchar [ (<replaceable>n</replaceable>) ]</type></entry>
<!--
       <entry>variable-length character string</entry>
-->
       <entry>可変長文字列</entry>
      </row>

      <row>
       <entry><type>cidr</type></entry>
       <entry></entry>
<!--
       <entry>IPv4 or IPv6 network address</entry>
-->
       <entry>IPv4もしくはIPv6ネットワークアドレス</entry>
      </row>

      <row>
       <entry><type>circle</type></entry>
       <entry></entry>
<!--
       <entry>circle on a plane</entry>
-->
       <entry>平面上の円</entry>
      </row>

      <row>
       <entry><type>date</type></entry>
       <entry></entry>
<!--
       <entry>calendar date (year, month, day)</entry>
-->
       <entry>暦の日付（年月日）</entry>
      </row>

      <row>
       <entry><type>double precision</type></entry>
       <entry><type>float8</type></entry>
<!--
       <entry>double precision floating-point number (8 bytes)</entry>
-->
       <entry>倍精度浮動小数点（8バイト）</entry>
      </row>

      <row>
       <entry><type>inet</type></entry>
       <entry></entry>
<!--
       <entry>IPv4 or IPv6 host address</entry>
-->
       <entry>IPv4もしくはIPv6ホストアドレス</entry>
      </row>

      <row>
       <entry><type>integer</type></entry>
       <entry><type>int</type>, <type>int4</type></entry>
<!--
       <entry>signed four-byte integer</entry>
-->
       <entry>4バイト符号付き整数</entry>
      </row>

      <row>
       <entry><type>interval [ <replaceable>fields</replaceable> ] [ (<replaceable>p</replaceable>) ]</type></entry>
       <entry></entry>
<!--
       <entry>time span</entry>
-->
       <entry>時間間隔</entry>
      </row>

      <row>
       <entry><type>json</type></entry>
       <entry></entry>
<!--
       <entry>textual JSON data</entry>
-->
       <entry>テキストのJSONデータ</entry>
      </row>

      <row>
       <entry><type>jsonb</type></entry>
       <entry></entry>
<!--
       <entry>binary JSON data, decomposed</entry>
-->
       <entry>バイナリ JSON データ, 展開型</entry>
      </row>

      <row>
       <entry><type>line</type></entry>
       <entry></entry>
<!--
       <entry>infinite line on a plane</entry>
-->
       <entry>平面上の無限直線</entry>
      </row>

      <row>
       <entry><type>lseg</type></entry>
       <entry></entry>
<!--
       <entry>line segment on a plane</entry>
-->
       <entry>平面上の線分</entry>
      </row>

      <row>
       <entry><type>macaddr</type></entry>
       <entry></entry>
<!--
       <entry>MAC (Media Access Control) address</entry>
-->
       <entry>MAC（Media Access Control）アドレス</entry>
      </row>

      <row>
       <entry><type>macaddr8</type></entry>
       <entry></entry>
<!--
       <entry>MAC (Media Access Control) address (EUI-64 format)</entry>
-->
       <entry>MAC (Media Access Control) アドレス (EUI-64 形式)</entry>
      </row>

      <row>
       <entry><type>money</type></entry>
       <entry></entry>
<!--
       <entry>currency amount</entry>
-->
       <entry>貨幣金額</entry>
      </row>

      <row>
       <entry><type>numeric [ (<replaceable>p</replaceable>,
         <replaceable>s</replaceable>) ]</type></entry>
       <entry><type>decimal [ (<replaceable>p</replaceable>,
         <replaceable>s</replaceable>) ]</type></entry>
<!--
       <entry>exact numeric of selectable precision</entry>
-->
       <entry>精度の選択可能な高精度数値</entry>
      </row>

      <row>
       <entry><type>path</type></entry>
       <entry></entry>
<!--
       <entry>geometric path on a plane</entry>
-->
       <entry>平面上の幾何学的経路</entry>
      </row>

      <row>
       <entry><type>pg_lsn</type></entry>
       <entry></entry>
<!--
       <entry><productname>PostgreSQL</productname> Log Sequence Number</entry>
-->
       <entry><productname>PostgreSQL</productname>ログシーケンス番号</entry>
      </row>

      <row>
       <entry><type>pg_snapshot</type></entry>
       <entry></entry>
<!--
       <entry>user-level transaction ID snapshot</entry>
-->
       <entry>ユーザレベルのトランザクションIDスナップショット</entry>
      </row>

      <row>
       <entry><type>point</type></entry>
       <entry></entry>
<!--
       <entry>geometric point on a plane</entry>
-->
       <entry>平面上の幾何学的点</entry>
      </row>

      <row>
       <entry><type>polygon</type></entry>
       <entry></entry>
<!--
       <entry>closed geometric path on a plane</entry>
-->
       <entry>平面上の閉じた幾何学的経路</entry>
      </row>

      <row>
       <entry><type>real</type></entry>
       <entry><type>float4</type></entry>
<!--
       <entry>single precision floating-point number (4 bytes)</entry>
-->
       <entry>単精度浮動小数点（4バイト）</entry>
      </row>

      <row>
       <entry><type>smallint</type></entry>
       <entry><type>int2</type></entry>
<!--
       <entry>signed two-byte integer</entry>
-->
       <entry>2バイト符号付き整数</entry>
      </row>

      <row>
       <entry><type>smallserial</type></entry>
       <entry><type>serial2</type></entry>
<!--
       <entry>autoincrementing two-byte integer</entry>
-->
       <entry>自動増分2バイト整数</entry>
      </row>

      <row>
       <entry><type>serial</type></entry>
       <entry><type>serial4</type></entry>
<!--
       <entry>autoincrementing four-byte integer</entry>
-->
       <entry>自動増分4バイト整数</entry>
      </row>

      <row>
       <entry><type>text</type></entry>
       <entry></entry>
<!--
       <entry>variable-length character string</entry>
-->
       <entry>可変長文字列</entry>
      </row>

      <row>
       <entry><type>time [ (<replaceable>p</replaceable>) ] [ without time zone ]</type></entry>
       <entry></entry>
<!--
       <entry>time of day (no time zone)</entry>
-->
       <entry>時刻（時間帯なし）</entry>
      </row>

      <row>
       <entry><type>time [ (<replaceable>p</replaceable>) ] with time zone</type></entry>
       <entry><type>timetz</type></entry>
<!--
       <entry>time of day, including time zone</entry>
-->
       <entry>時間帯付き時刻</entry>
      </row>

      <row>
       <entry><type>timestamp [ (<replaceable>p</replaceable>) ] [ without time zone ]</type></entry>
       <entry></entry>
<!--
       <entry>date and time (no time zone)</entry>
-->
       <entry>日付と時刻（時間帯なし）</entry>
      </row>

      <row>
       <entry><type>timestamp [ (<replaceable>p</replaceable>) ] with time zone</type></entry>
       <entry><type>timestamptz</type></entry>
<!--
       <entry>date and time, including time zone</entry>
-->
       <entry>時間帯付き日付と時刻</entry>
      </row>

      <row>
       <entry><type>tsquery</type></entry>
       <entry></entry>
<!--
       <entry>text search query</entry>
-->
       <entry>テキスト検索問い合わせ</entry>
      </row>

      <row>
       <entry><type>tsvector</type></entry>
       <entry></entry>
<!--
       <entry>text search document</entry>
-->
       <entry>テキスト検索文書</entry>
      </row>

      <row>
       <entry><type>txid_snapshot</type></entry>
       <entry></entry>
<!--
       <entry>user-level transaction ID snapshot (deprecated; see <type>pg_snapshot</type>)</entry>
-->
       <entry>ユーザレベルのトランザクションIDスナップショット(廃止予定。<type>pg_snapshot</type>を参照)</entry>
      </row>

      <row>
       <entry><type>uuid</type></entry>
       <entry></entry>
<!--
       <entry>universally unique identifier</entry>
-->
       <entry>汎用一意識別子</entry>
      </row>

      <row>
       <entry><type>xml</type></entry>
       <entry></entry>
<!--
       <entry>XML data</entry>
-->
       <entry>XMLデータ</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <note>
<!--
   <title>Compatibility</title>
-->
   <title>互換性</title>
   <para>
<!--
    The following types (or spellings thereof) are specified by
    <acronym>SQL</acronym>: <type>bigint</type>, <type>bit</type>, <type>bit
    varying</type>, <type>boolean</type>, <type>char</type>,
    <type>character varying</type>, <type>character</type>,
    <type>varchar</type>, <type>date</type>, <type>double
    precision</type>, <type>integer</type>, <type>interval</type>,
    <type>numeric</type>, <type>decimal</type>, <type>real</type>,
    <type>smallint</type>, <type>time</type> (with or without time zone),
    <type>timestamp</type> (with or without time zone),
    <type>xml</type>.
-->
次に挙げるデータ型（あるいはその綴り方）は<acronym>SQL</acronym>で規定されています。
<type>bigint</type>、<type>bit</type>、<type>bit varying</type>、<type>boolean</type>、<type>char</type>、
<type>character varying</type>、<type>character</type>、<type>varchar</type>、
<type>date</type>、<type>double precision</type>、<type>integer</type>、
<type>interval</type>、<type>numeric</type>、<type>decimal</type>、<type>real</type>、
<type>smallint</type>、<type>time</type>（時間帯付き、なしの両方）、
<type>timestamp</type>（時間帯付き、なしの両方）、<type>xml</type>。
   </para>
  </note>

  <para>
<!--
   Each data type has an external representation determined by its input
   and output functions.  Many of the built-in types have
   obvious external formats.  However, several types are either unique
   to <productname>PostgreSQL</productname>, such as geometric
   paths, or have several possible formats, such as the date
   and time types.
   Some of the input and output functions are not invertible, i.e.,
   the result of an output function might lose accuracy when compared to
   the original input.
-->
それぞれのデータ型はそのデータ型の入出力関数で決定される外部表現を保有しています。
組み込みデータ型の多くには、自明の外部書式があります。
とは言っても、経路のような<productname>PostgreSQL</productname>に特有な型や、あるいは、日付や時刻データ型のように書式を複数選択できる型がいくつかあります。
一部の入出力関数は可逆ではありません。
つまり、出力関数による結果は元の入力と比較した場合精度を失う可能性があります。
  </para>

  <sect1 id="datatype-numeric">
<!--
   <title>Numeric Types</title>
-->
   <title>数値データ型</title>

   <indexterm zone="datatype-numeric">
    <primary>data type</primary>
    <secondary>numeric</secondary>
   </indexterm>
   <indexterm zone="datatype-numeric">
    <primary>データ型</primary>
    <secondary>数値</secondary>
   </indexterm>

   <para>
<!--
    Numeric types consist of two-, four-, and eight-byte integers,
    four- and eight-byte floating-point numbers, and selectable-precision
    decimals.  <xref linkend="datatype-numeric-table"/> lists the
    available types.
-->
数値データ型には2、4、8バイト整数と、4、8バイト浮動小数点および精度設定が可能な数があります。
<xref linkend="datatype-numeric-table"/>に使用可能な型を列挙します。
   </para>

    <table id="datatype-numeric-table">
<!--
     <title>Numeric Types</title>
-->
     <title>数値データ型</title>
     <tgroup cols="4">
      <colspec colname="col1" colwidth="2*"/>
      <colspec colname="col2" colwidth="1*"/>
      <colspec colname="col3" colwidth="2*"/>
      <colspec colname="col4" colwidth="2*"/>
      <thead>
       <row>
<!--
        <entry>Name</entry>
        <entry>Storage Size</entry>
        <entry>Description</entry>
        <entry>Range</entry>
-->
        <entry>型名</entry>
        <entry>格納サイズ</entry>
        <entry>説明</entry>
        <entry>範囲</entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry><type>smallint</type></entry>
<!--
        <entry>2 bytes</entry>
        <entry>small-range integer</entry>
        <entry>-32768 to +32767</entry>
-->
        <entry>2バイト</entry>
        <entry>狭範囲の整数</entry>
        <entry>-32768から+32767</entry>
       </row>
       <row>
        <entry><type>integer</type></entry>
<!--
        <entry>4 bytes</entry>
        <entry>typical choice for integer</entry>
        <entry>-2147483648 to +2147483647</entry>
-->
        <entry>4バイト</entry>
        <entry>典型的に使用する整数</entry>
        <entry>-2147483648から+2147483647</entry>
       </row>
       <row>
        <entry><type>bigint</type></entry>
<!--
        <entry>8 bytes</entry>
        <entry>large-range integer</entry>
        <entry>-9223372036854775808 to +9223372036854775807</entry>
-->
        <entry>8バイト</entry>
        <entry>広範囲整数</entry>
        <entry>-9223372036854775808から+9223372036854775807</entry>
       </row>

       <row>
        <entry><type>decimal</type></entry>
<!--
        <entry>variable</entry>
        <entry>user-specified precision, exact</entry>
        <entry>up to 131072 digits before the decimal point; up to 16383 digits after the decimal point</entry>
-->
        <entry>可変長</entry>
        <entry>ユーザ指定精度、正確</entry>
        <entry>小数点より上は131072桁まで、小数点より下は16383桁まで</entry>
       </row>
       <row>
        <entry><type>numeric</type></entry>
<!--
        <entry>variable</entry>
        <entry>user-specified precision, exact</entry>
        <entry>up to 131072 digits before the decimal point; up to 16383 digits after the decimal point</entry>
-->
        <entry>可変長</entry>
        <entry>ユーザ指定精度、正確</entry>
        <entry>小数点より上は131072桁まで、小数点より下は16383桁まで</entry>
       </row>

       <row>
        <entry><type>real</type></entry>
<!--
        <entry>4 bytes</entry>
        <entry>variable-precision, inexact</entry>
        <entry>6 decimal digits precision</entry>
-->
        <entry>4バイト</entry>
        <entry>可変精度、不正確</entry>
        <entry>6桁精度</entry>
       </row>
       <row>
        <entry><type>double precision</type></entry>
<!--
        <entry>8 bytes</entry>
        <entry>variable-precision, inexact</entry>
        <entry>15 decimal digits precision</entry>
-->
        <entry>8バイト</entry>
        <entry>可変精度、不正確</entry>
        <entry>15桁精度</entry>
       </row>

       <row>
        <entry><type>smallserial</type></entry>
<!--
        <entry>2 bytes</entry>
        <entry>small autoincrementing integer</entry>
        <entry>1 to 32767</entry>
-->
        <entry>2バイト</entry>
        <entry>狭範囲自動整数</entry>
        <entry>1から32767</entry>
       </row>

       <row>
        <entry><type>serial</type></entry>
<!--
        <entry>4 bytes</entry>
        <entry>autoincrementing integer</entry>
        <entry>1 to 2147483647</entry>
-->
        <entry>4バイト</entry>
        <entry>自動増分整数</entry>
        <entry>1から2147483647</entry>
       </row>

       <row>
        <entry><type>bigserial</type></entry>
<!--
        <entry>8 bytes</entry>
        <entry>large autoincrementing integer</entry>
        <entry>1 to 9223372036854775807</entry>
-->
        <entry>8バイト</entry>
        <entry>広範囲自動増分整数</entry>
        <entry>1から9223372036854775807</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
<!--
    The syntax of constants for the numeric types is described in
    <xref linkend="sql-syntax-constants"/>.  The numeric types have a
    full set of corresponding arithmetic operators and
    functions. Refer to <xref linkend="functions"/> for more
    information.  The following sections describe the types in detail.
-->
数値データ型に対する定数の構文は<xref linkend="sql-syntax-constants"/>で説明しています。
数値データ型には対応する算術演算子と関数の一式が揃っています。
詳細は<xref linkend="functions"/>を参照してください。
次節でデータ型について詳しく説明します。
   </para>

   <sect2 id="datatype-int">
<!--
    <title>Integer Types</title>
-->
    <title>整数データ型</title>

    <indexterm zone="datatype-int">
     <primary>integer</primary>
    </indexterm>

    <indexterm zone="datatype-int">
     <primary>smallint</primary>
    </indexterm>

    <indexterm zone="datatype-int">
     <primary>bigint</primary>
    </indexterm>

    <indexterm>
     <primary>int4</primary>
     <see>integer</see>
    </indexterm>

    <indexterm>
     <primary>int2</primary>
     <see>smallint</see>
    </indexterm>

    <indexterm>
     <primary>int8</primary>
     <see>bigint</see>
    </indexterm>

    <para>
<!--
     The types <type>smallint</type>, <type>integer</type>, and
     <type>bigint</type> store whole numbers, that is, numbers without
     fractional components, of various ranges.  Attempts to store
     values outside of the allowed range will result in an error.
-->
<type>smallint</type>、<type>integer</type>、<type>bigint</type>は各種範囲の整数、つまり小数点以下の端数がない数を保持します。
許容範囲から外れた値を保存しようとするとエラーになります。
    </para>

    <para>
<!--
     The type <type>integer</type> is the common choice, as it offers
     the best balance between range, storage size, and performance.
     The <type>smallint</type> type is generally only used if disk
     space is at a premium.  The <type>bigint</type> type is designed to be
     used when the range of the <type>integer</type> type is insufficient.
-->
<type>integer</type>型は数値の範囲、格納サイズおよび性能において最も釣合いが取れていますので、一般的に使用されます。
<type>smallint</type>型は通常はディスク容量に制限が付いている場合にのみ使用します。
<type>bigint</type>型は<type>integer</type>の許容範囲では十分ではない場合に使用されるよう設計されています。
    </para>

    <para>
<!--
     <acronym>SQL</acronym> only specifies the integer types
     <type>integer</type> (or <type>int</type>),
     <type>smallint</type>, and <type>bigint</type>.  The
     type names <type>int2</type>, <type>int4</type>, and
     <type>int8</type> are extensions, which are also used by some
     other <acronym>SQL</acronym> database systems.
-->
<acronym>SQL</acronym>では整数の型として<type>integer</type>（または<type>int</type>）と<type>smallint</type>、<type>bigint</type>のみを規定しています。
<type>int2</type>、<type>int4</type>および<type>int8</type>は拡張ですが、いくつか他の<acronym>SQL</acronym>データベースシステムでも使われています。
    </para>

   </sect2>

   <sect2 id="datatype-numeric-decimal">
<!--
    <title>Arbitrary Precision Numbers</title>
-->
    <title>任意の精度を持つ数</title>

    <indexterm>
     <primary>numeric (data type)</primary>
    </indexterm>
    <indexterm>
     <primary>numeric（データ型）</primary>
    </indexterm>

   <indexterm>
    <primary>arbitrary precision numbers</primary>
   </indexterm>
   <indexterm>
    <primary>任意精度の数</primary>
   </indexterm>

    <indexterm>
     <primary>decimal</primary>
     <see>numeric</see>
    </indexterm>
    <indexterm>
     <primary>10進数</primary>
     <see>numeric</see>
    </indexterm>

    <para>
<!--
     The type <type>numeric</type> can store numbers with a
     very large number of digits. It is especially recommended for
     storing monetary amounts and other quantities where exactness is
     required.  Calculations with <type>numeric</type> values yield exact
     results where possible, e.g.,  addition, subtraction, multiplication.
     However, calculations on <type>numeric</type> values are very slow
     compared to the integer types, or to the floating-point types
     described in the next section.
-->
<type>numeric</type>型は、非常に大きな桁数で数値を格納できます。
通貨金額やその他正確性が求められる数量を保存する時は特に、この型を推奨します。
<type>numeric</type>の値での計算は、可能なところ、例えば、足し算、引算、掛け算では、正確な結果（訳注：10進の小数で誤差が生じない、ということ）になります。
とは言っても、<type>numeric</type>の値に対する計算は整数型、もしくは次節で説明する浮動小数点データ型に比較し非常に遅くなります。
    </para>

    <para>
<!--
     We use the following terms below:  The
     <firstterm>precision</firstterm> of a <type>numeric</type>
     is the total count of significant digits in the whole number,
     that is, the number of digits to both sides of the decimal point.
     The <firstterm>scale</firstterm> of a <type>numeric</type> is the
     count of decimal digits in the fractional part, to the right of the
     decimal point.  So the number 23.5141 has a precision of 6 and a
     scale of 4.  Integers can be considered to have a scale of zero.
-->
この後の説明では、次の用語を使用します。
<type>numeric</type>の<firstterm>精度(precision)</firstterm>とは数字全体の有効桁数です。
すなわち、小数点をはさんでいる両側の桁数の合計です。
<type>numeric</type>の<firstterm>位取り(scale)</firstterm>とは、小数点の右側の小数部分の桁数をいいます。
そのため、23.5141という数値の精度は6で位取りは4となります。
整数の位取りは、ゼロであるとみなすことができます。
    </para>

    <para>
<!--
     Both the maximum precision and the maximum scale of a
     <type>numeric</type> column can be
     configured.  To declare a column of type <type>numeric</type> use
     the syntax:
-->
<type>numeric</type>列の数値の最大精度と最大位取りの両方を設定することができます。
<type>numeric</type>型の列を宣言するには次の構文を使います。
<programlisting>
NUMERIC(<replaceable>precision</replaceable>, <replaceable>scale</replaceable>)
</programlisting>
<!--
     The precision must be positive, while the scale may be positive or
     negative (see below).  Alternatively:
-->
精度は正でなければならず、位取りは正または負であることができます(以下を参照)。
または、次のように指定します
<programlisting>
NUMERIC(<replaceable>precision</replaceable>)
</programlisting>
<!--
     selects a scale of 0.  Specifying:
-->
は位取りが0であることを選択します。
精度も位取りも指定せず、
<programlisting>
NUMERIC
</programlisting>
<!--
     without any precision or scale creates an <quote>unconstrained
     numeric</quote> column in which numeric values of any length can be
     stored, up to the implementation limits.  A column of this kind will
     not coerce input values to any particular scale, whereas
     <type>numeric</type> columns with a declared scale will coerce
     input values to that scale.  (The <acronym>SQL</acronym> standard
     requires a default scale of 0, i.e., coercion to integer
     precision.  We find this a bit useless.  If you're concerned
     about portability, always specify the precision and scale
     explicitly.)
-->
と記述すると、実装されている限界の精度まで、いかなる精度あるいは位取りの値も格納できる<quote>制約の無い数値</quote>列が作られます。
この類の列は入力値をいかなる特定の位取りにも変換しませんが、宣言された位取りを持つ<type>numeric</type>列は入力値をその位取りに変換します。
（標準<acronym>SQL</acronym>はデフォルトとして位取り0を要求していて、つまり、整数の精度に変換されます。
しかし、この方法はあまり役に立たないと思われます。
もし移植性を心配するなら、常に精度と位取りを明示的に設定してください。）
    </para>

    <note>
     <para>
<!--
      The maximum precision that can be explicitly specified in
      a <type>numeric</type> type declaration is 1000.  An
      unconstrained <type>numeric</type> column is subject to the limits
      described in <xref linkend="datatype-numeric-table"/>.
-->
明示的に<type>numeric</type>型宣言で指定される場合の最大精度は1000です。
制約の無い<type>numeric</type>列は<xref linkend="datatype-numeric-table"/>で説明する制限に従います。
     </para>
    </note>

    <para>
<!--
     If the scale of a value to be stored is greater than the declared
     scale of the column, the system will round the value to the specified
     number of fractional digits.  Then, if the number of digits to the
     left of the decimal point exceeds the declared precision minus the
     declared scale, an error is raised.
     For example, a column declared as
-->
格納される値の位取りが宣言された列の位取りより大きかった場合、システムは指定された小数部の桁まで値を丸めます。
そして、小数点の左側の桁数が、宣言された精度から宣言された位取りを差し引いた数を超える場合にエラーとなります。
例えば、
<programlisting>
NUMERIC(3, 1)
</programlisting>
<!--
     will round values to 1 decimal place and can store values between
     -99.9 and 99.9, inclusive.
-->
として宣言された列は、値を小数第1位に丸め、-99.9から99.9までの値を格納できます。
    </para>

    <para>
<!--
     Beginning in <productname>PostgreSQL</productname> 15, it is allowed
     to declare a <type>numeric</type> column with a negative scale.  Then
     values will be rounded to the left of the decimal point.  The
     precision still represents the maximum number of non-rounded digits.
     Thus, a column declared as
-->
<productname>PostgreSQL</productname> 15以降では、負の位取りを持つ<type>numeric</type>列を宣言することが許可されました。
その場合、値は小数点の左側に丸められます。
精度は、依然として丸められない最大桁数を表します。
したがって、
<programlisting>
NUMERIC(2, -3)
</programlisting>
<!--
     will round values to the nearest thousand and can store values
     between -99000 and 99000, inclusive.
     It is also allowed to declare a scale larger than the declared
     precision.  Such a column can only hold fractional values, and it
     requires the number of zero digits just to the right of the decimal
     point to be at least the declared scale minus the declared precision.
     For example, a column declared as
-->
として宣言された列は、千に近い値に丸められ、-99000から99000までの値を格納できます。
また、宣言された精度よりも大きな位取りを宣言することも許可されます。
このような列は小数値しか保持できず、小数点のすぐ右の0桁は、少なくとも宣言された位取りから宣言された精度を引いた値である必要があります。
例えば、
<programlisting>
NUMERIC(3, 5)
</programlisting>
<!--
     will round values to 5 decimal places and can store values between
     -0.00999 and 0.00999, inclusive.
-->
として宣言された列は、小数点以下5桁に丸められ、-0.00999から0.00999までの値を格納できます。
    </para>

    <note>
     <para>
<!--
      <productname>PostgreSQL</productname> permits the scale in a
      <type>numeric</type> type declaration to be any value in the range
      -1000 to 1000.  However, the <acronym>SQL</acronym> standard requires
      the scale to be in the range 0 to <replaceable>precision</replaceable>.
      Using scales outside that range may not be portable to other database
      systems.
-->
<productname>PostgreSQL</productname>では、<type>numeric</type>型宣言の位取りを-1000～1000の範囲の任意の値にすることができます。
しかし、<acronym>SQL</acronym>標準では位取りを0～<replaceable>精度</replaceable>の範囲にする必要があります。
この範囲外の位取りを使用すると、他のデータベースシステムに移植できない可能性があります。
     </para>
    </note>

    <para>
<!--
     Numeric values are physically stored without any extra leading or
     trailing zeroes.  Thus, the declared precision and scale of a column
     are maximums, not fixed allocations.  (In this sense the <type>numeric</type>
     type is more akin to <type>varchar(<replaceable>n</replaceable>)</type>
     than to <type>char(<replaceable>n</replaceable>)</type>.)  The actual storage
     requirement is two bytes for each group of four decimal digits,
     plus three to eight bytes overhead.
-->
数値は物理的に先頭や末尾に0を付与されることなく格納されます。
したがって、列の宣言された精度と位取りは最大であり、固定的に割り当てられていません。
（この意味では<type>numeric</type>は<type>char(<replaceable>n</replaceable>)</type>よりも<type>varchar(<replaceable>n</replaceable>)</type>に似ています。）
実際の格納に必要な容量は、10進数4桁のそれぞれのグループに対して2バイトと、3から8バイトのオーバーヘッドです。
    </para>

    <indexterm>
     <primary>infinity</primary>
     <secondary>numeric (data type)</secondary>
    </indexterm>
    <indexterm>
     <primary>無限</primary>
     <secondary>numeric (データ型)</secondary>
    </indexterm>

    <indexterm>
     <primary>NaN</primary>
     <see>not a number</see>
   </indexterm>
    <indexterm>
     <primary>NaN</primary>
     <see>非数</see>
    </indexterm>

    <indexterm>
     <primary>not a number</primary>
     <secondary>numeric (data type)</secondary>
    </indexterm>
    <indexterm>
     <primary>非数</primary>
     <secondary>数値（データ型）</secondary>
    </indexterm>

    <para>
<!--
     In addition to ordinary numeric values, the <type>numeric</type> type
     has several special values:
-->
通常の数値に加え、<type>numeric</type>型はいくつかの特別な値を取ることができます。
<literallayout>
<literal>Infinity</literal>
<literal>-Infinity</literal>
<literal>NaN</literal>
</literallayout>
<!--
     These are adapted from the IEEE 754 standard, and represent
     <quote>infinity</quote>, <quote>negative infinity</quote>, and
     <quote>not-a-number</quote>, respectively. When writing these values
     as constants in an SQL command, you must put quotes around them,
     for example <literal>UPDATE table SET x = '-Infinity'</literal>.
     On input, these strings are recognized in a case-insensitive manner.
     The infinity values can alternatively be spelled <literal>inf</literal>
     and <literal>-inf</literal>.
-->
これらはIEEE 754標準から引用されたもので、それぞれ<quote>無限大</quote>、<quote>マイナス無限大</quote>そして<quote>非数値</quote>を表します。
SQLコマンドの定数として記述する場合は、例えば<literal>UPDATE table SET x = '-Infinity'</literal>のように、引用符でくくらなければなりません。
入力の際、これらの文字列は大文字小文字の区別なく認識されます。
無限の値は代わりに<literal>inf</literal>や<literal>-inf</literal>と綴ることもできます。
    </para>

    <para>
<!--
     The infinity values behave as per mathematical expectations.  For
     example, <literal>Infinity</literal> plus any finite value equals
     <literal>Infinity</literal>, as does <literal>Infinity</literal>
     plus <literal>Infinity</literal>; but <literal>Infinity</literal>
     minus <literal>Infinity</literal> yields <literal>NaN</literal> (not a
     number), because it has no well-defined interpretation.  Note that an
     infinity can only be stored in an unconstrained <type>numeric</type>
     column, because it notionally exceeds any finite precision limit.
-->
無限の値は数学的に期待されたとおりに振る舞います。
例えば、<literal>Infinity</literal>に有限な値を加算した場合や<literal>Infinity</literal>に<literal>Infinity</literal>を加算した場合は<literal>Infinity</literal>になります。しかし、<literal>Infinity</literal>から<literal>Infinity</literal>を減算した場合は、解釈が定まらないため<literal>NaN</literal>(数値では無い)になります。
無限大は制約が無い<type>numeric</type>列にのみ格納できることに注意してください。これは理論上、いかなる有限な精度も超えているためです。
    </para>

    <para>
<!--
     The <literal>NaN</literal> (not a number) value is used to represent
     undefined calculational results.  In general, any operation with
     a <literal>NaN</literal> input yields another <literal>NaN</literal>.
     The only exception is when the operation's other inputs are such that
     the same output would be obtained if the <literal>NaN</literal> were to
     be replaced by any finite or infinite numeric value; then, that output
     value is used for <literal>NaN</literal> too.  (An example of this
     principle is that <literal>NaN</literal> raised to the zero power
     yields one.)
-->
<literal>NaN</literal>(数値では無い)値は定義されていない計算の結果を表現するために使用されます。
通常、<literal>NaN</literal>入力を伴う操作は別の<literal>NaN</literal>を出力します。
その操作の入力が<literal>NaN</literal>を他の有限もしくは無限の数値型の値に置き換えられた場合に同じ出力が得られる時に限り例外があります。
この時は<literal>NaN</literal>の代わりにその操作の出力が使われます(この概念では例えば、<literal>NaN</literal>の0乗は1を出力します)。
    </para>

    <note>
     <para>
<!--
      In most implementations of the <quote>not-a-number</quote> concept,
      <literal>NaN</literal> is not considered equal to any other numeric
      value (including <literal>NaN</literal>).  In order to allow
      <type>numeric</type> values to be sorted and used in tree-based
      indexes, <productname>PostgreSQL</productname> treats <literal>NaN</literal>
      values as equal, and greater than all non-<literal>NaN</literal>
      values.
-->
ほとんどの<quote>非数</quote>の概念の実装において、<literal>NaN</literal>は（<literal>NaN</literal>を含む）他の数値と等価にならないとみなされています。
<type>numeric</type>値をソートできる、また、ツリーを基にしたインデックスで使用できるように、<productname>PostgreSQL</productname>は<literal>NaN</literal>同士は等しく、すべての<literal>NaN</literal>以外の値よりも大きな値となるものとして扱います。
     </para>
    </note>

    <para>
<!--
     The types <type>decimal</type> and <type>numeric</type> are
     equivalent.  Both types are part of the <acronym>SQL</acronym>
     standard.
-->
<type>decimal</type>と<type>numeric</type>型は等価です。
2つのデータ型はともに標準<acronym>SQL</acronym>に含まれます。
    </para>

    <para>
<!--
     When rounding values, the <type>numeric</type> type rounds ties away
     from zero, while (on most machines) the <type>real</type>
     and <type>double precision</type> types round ties to the nearest even
     number.  For example:
-->
値を丸める際、<type>numeric</type>型は0から離れるように丸めますが、一方で（ほとんどのマシンでは）<type>real</type>や<type>double precision</type>型ではその値に最も近い偶数に丸めます。
以下に例を示します。:

<programlisting>
SELECT x,
  round(x::numeric) AS num_round,
  round(x::double precision) AS dbl_round
FROM generate_series(-3.5, 3.5, 1) as x;
  x   | num_round | dbl_round
------+-----------+-----------
 -3.5 |        -4 |        -4
 -2.5 |        -3 |        -2
 -1.5 |        -2 |        -2
 -0.5 |        -1 |        -0
  0.5 |         1 |         0
  1.5 |         2 |         2
  2.5 |         3 |         2
  3.5 |         4 |         4
(8 rows)
</programlisting>
    </para>
   </sect2>


   <sect2 id="datatype-float">
<!--
    <title>Floating-Point Types</title>
-->
    <title>浮動小数点データ型</title>

    <indexterm zone="datatype-float">
     <primary>real</primary>
    </indexterm>

    <indexterm zone="datatype-float">
     <primary>double precision</primary>
    </indexterm>
    <indexterm zone="datatype-float">
     <primary>倍精度</primary>
    </indexterm>

    <indexterm>
     <primary>float4</primary>
     <see>real</see>
    </indexterm>

    <indexterm>
     <primary>float8</primary>
     <see>double precision</see>
    </indexterm>

    <indexterm zone="datatype-float">
     <primary>floating point</primary>
    </indexterm>
    <indexterm zone="datatype-float">
     <primary>浮動小数点</primary>
    </indexterm>

    <para>
<!--
     The data types <type>real</type> and <type>double precision</type> are
     inexact, variable-precision numeric types. On all currently supported
     platforms, these types are implementations of <acronym>IEEE</acronym>
     Standard 754 for Binary Floating-Point Arithmetic (single and double
     precision, respectively), to the extent that the underlying processor,
     operating system, and compiler support it.
-->
<type>real</type>と<type>double precision</type>は不正確な（訳注：10進の小数で誤差が生じる、ということ）可変精度の数値データ型です。
現在サポートされている全てのプラットフォーム上では、これらのデータ型は、使用しているプロセッサ、オペレーティングシステムおよびコンパイラがサポートしていれば、通常は（それぞれ単精度および倍精度の）バイナリ浮動小数点演算用の<acronym>IEEE</acronym>規格754の実装です。
    </para>

    <para>
<!--
     Inexact means that some values cannot be converted exactly to the
     internal format and are stored as approximations, so that storing
     and retrieving a value might show slight discrepancies.
     Managing these errors and how they propagate through calculations
     is the subject of an entire branch of mathematics and computer
     science and will not be discussed here, except for the
     following points:
-->
不正確というのは、ある値はそのままで内部形式に変換されずに近似値として保存されるということです。
ですから、保存しようとする値と抽出しようとする値の間に多少の差異が認められます。
これらのエラーを管理し計算によって補正をどうするかについては、数学とコンピュータ科学の系統すべてに関わることで、以下の点を除き触れません。
     <itemizedlist>
      <listitem>
       <para>
<!--
        If you require exact storage and calculations (such as for
        monetary amounts), use the <type>numeric</type> type instead.
-->
（金銭金額など）正確な記録と計算が必要な時は代わりに<type>numeric</type>を使用してください。
       </para>
      </listitem>

      <listitem>
       <para>
<!--
        If you want to do complicated calculations with these types
        for anything important, especially if you rely on certain
        behavior in boundary cases (infinity, underflow), you should
        evaluate the implementation carefully.
-->
これらのデータ型で何か重要な件に対し複雑な計算を必要とする時、特に（無限大やアンダーフローのような）境界線におけるある種の振舞いについて信頼を置かなければならないのであれば、実装を注意深く検証しなければなりません。
       </para>
      </listitem>

      <listitem>
       <para>
<!--
        Comparing two floating-point values for equality might not
        always work as expected.
-->
2つの浮動小数点値が等価であるのかどうかの比較は予想通りに行かない時もあります。
       </para>
      </listitem>
     </itemizedlist>
    </para>

    <para>
<!--
     On all currently supported platforms, the <type>real</type> type has a
     range of around 1E-37 to 1E+37 with a precision of at least 6 decimal
     digits. The <type>double precision</type> type has a range of around
     1E-307 to 1E+308 with a precision of at least 15 digits. Values that are
     too large or too small will cause an error. Rounding might take place if
     the precision of an input number is too high. Numbers too close to zero
     that are not representable as distinct from zero will cause an underflow
     error.
-->
現在サポートされている全てのプラットフォームでは、<type>real</type>型は最低6桁の精度を持ち、1E-37から1E+37までの範囲です。
<type>double precision</type>型は最低15桁の精度でおよそ1E-307から1E+308までの範囲です。
大き過ぎたり小さ過ぎる値はエラーの原因になります。
入力値の精度が高過ぎる場合は丸められることがあります。
ゼロに限りなく近い値で、しかもゼロと異なる値として表現できない数値はアンダーフローエラーになります。
    </para>

    <para>
<!--
     By default, floating point values are output in text form in their
     shortest precise decimal representation; the decimal value produced is
     closer to the true stored binary value than to any other value
     representable in the same binary precision. (However, the output value is
     currently never <emphasis>exactly</emphasis> midway between two
     representable values, in order to avoid a widespread bug where input
     routines do not properly respect the round-to-nearest-even rule.) This value will
     use at most 17 significant decimal digits for <type>float8</type>
     values, and at most 9 digits for <type>float4</type> values.
-->
デフォルトでは、浮動小数の値は最も短い正確な10進数のテキスト形式で出力されます。
生成される10進値は、同じバイナリ精度で表現できる他の値よりも、実際に格納されているバイナリ値に近い値になります。
(ただし、出力値が2つの表現可能な値の<emphasis>厳密な</emphasis>中間になることはありません。これは、入力ルーチンが最も近い偶数に丸める規則を適切に考慮しないという広範囲にわたる不具合を避けるためです。)
この値は<type>float8</type>型の値には最大17桁の10進数、<type>float4</type>型の値には最大9桁の10進数を使用します。
    </para>

    <note>
     <para>
<!--
      This shortest-precise output format is much faster to generate than the
      historical rounded format.
-->
この最も短く正確な出力フォーマットは従来の丸められた形式よりもはるかに速く値を生成します。
     </para>
    </note>

    <para>
<!--
     For compatibility with output generated by older versions
     of <productname>PostgreSQL</productname>, and to allow the output
     precision to be reduced, the <xref linkend="guc-extra-float-digits"/>
     parameter can be used to select rounded decimal output instead. Setting a
     value of 0 restores the previous default of rounding the value to 6
     (for <type>float4</type>) or 15 (for <type>float8</type>)
     significant decimal digits. Setting a negative value reduces the number
     of digits further; for example -2 would round output to 4 or 13 digits
     respectively.
-->
<productname>PostgreSQL</productname>の古いバージョンで生成された出力との互換性を確保し、出力精度を低くするために、代わりに<xref linkend="guc-extra-float-digits"/>パラメータを使用して丸めた10進数の出力を選択することができます。
値を0に設定した場合は、以前のデフォルト値である6(<type>float4</type>の場合)か15(<type>float8</type>の場合)の有効桁に丸めた値を戻します。
負の値を設定すると、桁数がさらに減少します。たとえば、-2を設定すると、出力はそれぞれ4桁または13桁に丸められます。
    </para>

    <para>
<!--
     Any value of <xref linkend="guc-extra-float-digits"/> greater than 0
     selects the shortest-precise format.
-->
0より大きい<xref linkend="guc-extra-float-digits"/>の値は、最短の正確なフォーマットを選択します。
    </para>

    <note>
     <para>
<!--
      Applications that wanted precise values have historically had to set
      <xref linkend="guc-extra-float-digits"/> to 3 to obtain them. For
      maximum compatibility between versions, they should continue to do so.
-->
精密な値を必要とするアプリケーションでは、従来、<xref linkend="guc-extra-float-digits"/>を3に設定して値を取得する必要がありました。
バージョン間の互換性を最大にするためには継続してそのように設定する必要があります。
     </para>
    </note>

    <indexterm>
     <primary>infinity</primary>
     <secondary>floating point</secondary>
    </indexterm>
    <indexterm>
     <primary>無限</primary>
     <secondary>浮動小数点</secondary>
    </indexterm>

    <indexterm>
     <primary>not a number</primary>
     <secondary>floating point</secondary>
    </indexterm>
    <indexterm>
     <primary>非数</primary>
     <secondary>浮動小数点</secondary>
    </indexterm>

    <para>
<!--
     In addition to ordinary numeric values, the floating-point types
     have several special values:
-->
通常の数値に加え、浮動小数点型では以下の特殊な値を取ります。
<literallayout>
<literal>Infinity</literal>
<literal>-Infinity</literal>
<literal>NaN</literal>
</literallayout>
<!--
     These represent the IEEE 754 special values
     <quote>infinity</quote>, <quote>negative infinity</quote>, and
     <quote>not-a-number</quote>, respectively. When writing these values
     as constants in an SQL command, you must put quotes around them,
     for example <literal>UPDATE table SET x = '-Infinity'</literal>.  On input,
     these strings are recognized in a case-insensitive manner.
     The infinity values can alternatively be spelled <literal>inf</literal>
     and <literal>-inf</literal>.
-->
これらはそれぞれ、IEEE 754の特殊な値、<quote>無限大</quote>、<quote>負の無限大</quote>、<quote>非数値</quote>を表します。
これらの値をSQLコマンドの定数として記述する場合、例えば<literal>UPDATE table SET x = '-Infinity'</literal>のように引用符でくくる必要があります。
入力の際、これらの文字列は大文字小文字の区別なく認識されます。
無限の値は代わりに<literal>inf</literal>や<literal>-inf</literal>と綴ることもできます。
    </para>

    <note>
     <para>
<!--
      IEEE 754 specifies that <literal>NaN</literal> should not compare equal
      to any other floating-point value (including <literal>NaN</literal>).
      In order to allow floating-point values to be sorted and used
      in tree-based indexes, <productname>PostgreSQL</productname> treats
      <literal>NaN</literal> values as equal, and greater than all
      non-<literal>NaN</literal> values.
-->
IEEE 754では、<literal>NaN</literal>は（<literal>NaN</literal>を含む）他のすべての浮動小数点値と比べた時に不等でなければならないと規定しています。
浮動小数点値をソートできる、また、ツリーを基にしたインデックスで使用できるように、<productname>PostgreSQL</productname>は<literal>NaN</literal>同士は等しく、すべての<literal>NaN</literal>以外の値よりも大きな値となるものとして扱います。
     </para>
    </note>

    <para>
<!--
     <productname>PostgreSQL</productname> also supports the SQL-standard
     notations <type>float</type> and
     <type>float(<replaceable>p</replaceable>)</type> for specifying
     inexact numeric types.  Here, <replaceable>p</replaceable> specifies
     the minimum acceptable precision in <emphasis>binary</emphasis> digits.
     <productname>PostgreSQL</productname> accepts
     <type>float(1)</type> to <type>float(24)</type> as selecting the
     <type>real</type> type, while
     <type>float(25)</type> to <type>float(53)</type> select
     <type>double precision</type>.  Values of <replaceable>p</replaceable>
     outside the allowed range draw an error.
     <type>float</type> with no precision specified is taken to mean
     <type>double precision</type>.
-->
また、<productname>PostgreSQL</productname>では不正確な数値型についての標準SQLの表記である<type>float</type>と<type>float(<replaceable>p</replaceable>)</type>をサポートしています。
ここで、<replaceable>p</replaceable>は<emphasis>2進数</emphasis>桁数で最低限、許容可能な精度を指定します。
<productname>PostgreSQL</productname>は<type>float(1)</type>から<type>float(24)</type>を<type>real</type>を選択するものとして受け付け、<type>float(25)</type>から<type>float(53)</type>を<type>double precision</type>を選択するものとして受け付けます。
許容範囲外の<replaceable>p</replaceable>の値はエラーになります。
精度指定のない<type>float</type>は<type>double precision</type>として解釈されます。
    </para>

   </sect2>

   <sect2 id="datatype-serial">
<!--
    <title>Serial Types</title>
-->
    <title>連番型</title>

    <indexterm zone="datatype-serial">
     <primary>smallserial</primary>
    </indexterm>

    <indexterm zone="datatype-serial">
     <primary>serial</primary>
    </indexterm>

    <indexterm zone="datatype-serial">
     <primary>bigserial</primary>
    </indexterm>

    <indexterm zone="datatype-serial">
     <primary>serial2</primary>
    </indexterm>

    <indexterm zone="datatype-serial">
     <primary>serial4</primary>
    </indexterm>

    <indexterm zone="datatype-serial">
     <primary>serial8</primary>
    </indexterm>

    <indexterm>
     <primary>auto-increment</primary>
     <see>serial</see>
    </indexterm>
    <indexterm>
     <primary>自動増分</primary>
     <see>serial</see>
    </indexterm>

    <indexterm>
     <primary>sequence</primary>
     <secondary>and serial type</secondary>
    </indexterm>
    <indexterm>
     <primary>シーケンス</primary>
     <secondary>連番型</secondary>
    </indexterm>

    <note>
     <para>
<!--
      This section describes a PostgreSQL-specific way to create an
      autoincrementing column.  Another way is to use the SQL-standard
      identity column feature, described at <xref linkend="sql-createtable"/>.
-->
このセクションではPostgreSQL固有の自動増分列の作成方法について記述します。
SQL標準の識別列を作成する方法は、<xref linkend="sql-createtable"/>に記述されています。
     </para>
    </note>

    <para>
<!--
     The data types <type>smallserial</type>, <type>serial</type> and
     <type>bigserial</type> are not true types, but merely
     a notational convenience for creating unique identifier columns
     (similar to the <literal>AUTO_INCREMENT</literal> property
     supported by some other databases). In the current
     implementation, specifying:
-->
<type>smallserial</type>、<type>serial</type>および<type>bigserial</type>データ型は正確にはデータ型ではなく、テーブルの列に一意の識別子を作成する簡便な表記法です
（他のデータベースでサポートされる<literal>AUTO_INCREMENT</literal>プロパティに似ています）。
現在の実装では、

<programlisting>
CREATE TABLE <replaceable class="parameter">tablename</replaceable> (
    <replaceable class="parameter">colname</replaceable> SERIAL
);
</programlisting>

<!--
     is equivalent to specifying:
-->
は以下を指定することと同じです。

<programlisting>
CREATE SEQUENCE <replaceable class="parameter">tablename</replaceable>_<replaceable class="parameter">colname</replaceable>_seq AS integer;
CREATE TABLE <replaceable class="parameter">tablename</replaceable> (
    <replaceable class="parameter">colname</replaceable> integer NOT NULL DEFAULT nextval('<replaceable class="parameter">tablename</replaceable>_<replaceable class="parameter">colname</replaceable>_seq')
);
ALTER SEQUENCE <replaceable class="parameter">tablename</replaceable>_<replaceable class="parameter">colname</replaceable>_seq OWNED BY <replaceable class="parameter">tablename</replaceable>.<replaceable class="parameter">colname</replaceable>;
</programlisting>

<!--
     Thus, we have created an integer column and arranged for its default
     values to be assigned from a sequence generator.  A <literal>NOT NULL</literal>
     constraint is applied to ensure that a null value cannot be
     inserted.  (In most cases you would also want to attach a
     <literal>UNIQUE</literal> or <literal>PRIMARY KEY</literal> constraint to prevent
     duplicate values from being inserted by accident, but this is
     not automatic.)  Lastly, the sequence is marked as <quote>owned by</quote>
     the column, so that it will be dropped if the column or table is dropped.
-->
このように整数列を作成し、その列のデフォルト値が連番ジェネレータから割り当てられるようにしました。
また、<literal>NOT NULL</literal>制約を適用することによって、NULL値が挿入されないようにします。
（たいていの場合は、重複する値を間違って挿入しないように、<literal>UNIQUE</literal>制約または<literal>PRIMARY KEY</literal>制約も追加することになるでしょうが、これは自動的には行われません。）
最後に、シーケンスは列に<quote>より所有</quote>されるものと印が付きます。
したがって、テーブルの列が削除された場合にシーケンスは削除されます。
    </para>

    <note>
      <para>
<!--
        Because <type>smallserial</type>, <type>serial</type> and
        <type>bigserial</type> are implemented using sequences, there may
        be "holes" or gaps in the sequence of values which appears in the
        column, even if no rows are ever deleted.  A value allocated
        from the sequence is still "used up" even if a row containing that
        value is never successfully inserted into the table column.  This
        may happen, for example, if the inserting transaction rolls back.
        See <literal>nextval()</literal> in <xref linkend="functions-sequence"/>
        for details.
-->
<type>smallserial</type>、 <type>serial</type>および<type>bigserial</type>はシーケンスを使って実装されているため、行の削除が行われていなくとも、列に"穴"や連番の抜けが発生するかもしれません。
また、テーブルへ正常に挿入されていないにも関わらず、シーケンスの値を"消費してしまう"こともあります。
これは、例えば挿入したトランザクションがロールバックされた時に発生することがあります。
詳細は<xref linkend="functions-sequence"/>の<literal>nextval()</literal>を参照してください。
      </para>
    </note>

    <para>
<!--
     To insert the next value of the sequence into the <type>serial</type>
     column, specify that the <type>serial</type>
     column should be assigned its default value. This can be done
     either by excluding the column from the list of columns in
     the <command>INSERT</command> statement, or through the use of
     the <literal>DEFAULT</literal> key word.
-->
<type>serial</type>列にシーケンスの次の値を挿入するには、<type>serial</type>列にそのデフォルト値を割り当てるよう指定してください。
これは、<command>INSERT</command>文の列リストからその列を除外する、もしくは<literal>DEFAULT</literal>キーワードを使用することで行うことができます。
    </para>

    <para>
<!--
     The type names <type>serial</type> and <type>serial4</type> are
     equivalent: both create <type>integer</type> columns.  The type
     names <type>bigserial</type> and <type>serial8</type> work
     the same way, except that they create a <type>bigint</type>
     column.  <type>bigserial</type> should be used if you anticipate
     the use of more than 2<superscript>31</superscript> identifiers over the
     lifetime of the table. The type names <type>smallserial</type> and
     <type>serial2</type> also work the same way, except that they
     create a <type>smallint</type> column.
-->
<type>serial</type>と<type>serial4</type>という型の名称は等価です。
ともに<type>integer</type>列を作成します。
<type>bigserial</type>と<type>serial8</type>という型の名称も<type>bigint</type>列を作成することを除いて同じ振舞いをします。
もしテーブルを使用する期間で2<superscript>31</superscript>以上の識別子を使用すると予測される場合、<type>bigserial</type>を使用すべきです。
<type>smallserial</type>と<type>serial2</type>という型の名称もまた、<type>smallint</type>列を作成することを除いて同じ振舞いをします。
    </para>

    <para>
<!--
     The sequence created for a <type>serial</type> column is
     automatically dropped when the owning column is dropped.
     You can drop the sequence without dropping the column, but this
     will force removal of the column default expression.
-->
<type>serial</type>列用に作成されたシーケンスは、それを所有する列が削除された時に自動的に削除されます。
列を削除せずにシーケンスを削除することができますが、これにより強制的に列のデフォルト式が削除されます。
    </para>
   </sect2>
  </sect1>

  <sect1 id="datatype-money">
<!--
   <title>Monetary Types</title>
-->
   <title>通貨型</title>

   <para>
<!--
    The <type>money</type> type stores a currency amount with a fixed
    fractional precision; see <xref
    linkend="datatype-money-table"/>.  The fractional precision is
    determined by the database's <xref linkend="guc-lc-monetary"/> setting.
    The range shown in the table assumes there are two fractional digits.
    Input is accepted in a variety of formats, including integer and
    floating-point literals, as well as typical
    currency formatting, such as <literal>'$1,000.00'</literal>.
    Output is generally in the latter form but depends on the locale.
-->
<type>money</type>型は貨幣金額を固定精度の小数点で格納します。
<xref linkend="datatype-money-table"/>を参照してください。
小数点精度はデータベースの<xref linkend="guc-lc-monetary"/>設定で決定されます。この表が示すように範囲は小数点2桁を想定しています。
<literal>'$1,000.00'</literal>などの典型的な通貨書式の他、整数、浮動小数点リテラルなど様々な書式の入力を受け付けます。
出力形式は通常は後者となりますが、ロケールによって異なります。
   </para>

    <table id="datatype-money-table">
<!--
     <title>Monetary Types</title>
-->
     <title>通貨型</title>
     <tgroup cols="4">
      <colspec colname="col1" colwidth="2*"/>
      <colspec colname="col2" colwidth="1*"/>
      <colspec colname="col3" colwidth="2*"/>
      <colspec colname="col4" colwidth="2*"/>
      <thead>
       <row>
<!--
        <entry>Name</entry>
        <entry>Storage Size</entry>
        <entry>Description</entry>
        <entry>Range</entry>
-->
        <entry>型名</entry>
        <entry>格納サイズ</entry>
        <entry>説明</entry>
        <entry>範囲</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><type>money</type></entry>
<!--
        <entry>8 bytes</entry>
        <entry>currency amount</entry>
        <entry>-92233720368547758.08 to +92233720368547758.07</entry>
-->
        <entry>8バイト</entry>
        <entry>貨幣金額</entry>
        <entry>-92233720368547758.08 から +92233720368547758.07</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
<!--
    Since the output of this data type is locale-sensitive, it might not
    work to load <type>money</type> data into a database that has a different
    setting of <varname>lc_monetary</varname>.  To avoid problems, before
    restoring a dump into a new database make sure <varname>lc_monetary</varname> has
    the same or equivalent value as in the database that was dumped.
-->
このデータ型の出力はロケールにより変動しますので、<varname>lc_monetary</varname>設定が異なるデータベースに<type>money</type>データをロードする場合には動作しない可能性があります。
この問題を防ぐためには、ダンプを新しいデータベースにリストアする前に、<varname>lc_monetary</varname>がダンプを行ったデータベースと同じまたは等価であることを確認してください。
   </para>

   <para>
<!--
    Values of the <type>numeric</type>, <type>int</type>, and
    <type>bigint</type> data types can be cast to <type>money</type>.
    Conversion from the <type>real</type> and <type>double precision</type>
    data types can be done by casting to <type>numeric</type> first, for
    example:
-->
<type>numeric</type>、<type>int</type>そして<type>bigint</type>型は<type>money</type>型にキャストすることができます。<type>real</type>型や<type>double precision</type>型は最初に<type>numeric</type> 型にキャストした後に行なう必要があります。以下に例を示します。
<programlisting>
SELECT '12.34'::float8::numeric::money;
</programlisting>
<!--
    However, this is not recommended.  Floating point numbers should not be
    used to handle money due to the potential for rounding errors.
-->
しかしこれは推奨されません。浮動小数点数値は丸め誤差の可能性がありますので貨幣を扱うために使用すべきではありません。
   </para>

   <para>
<!--
    A <type>money</type> value can be cast to <type>numeric</type> without
    loss of precision. Conversion to other types could potentially lose
    precision, and must also be done in two stages:
-->
<type>money</type>型の値は精度を落とすことなく<type>numeric</type>にキャストすることができます。
他の型への変換では精度を落とす可能性があり、また２段階で行う必要があります。
<programlisting>
SELECT '52093.89'::money::numeric::float8;
</programlisting>
   </para>

   <para>
<!--
    Division of a <type>money</type> value by an integer value is performed
    with truncation of the fractional part towards zero.  To get a rounded
    result, divide by a floating-point value, or cast the <type>money</type>
    value to <type>numeric</type> before dividing and back to <type>money</type>
    afterwards.  (The latter is preferable to avoid risking precision loss.)
    When a <type>money</type> value is divided by another <type>money</type>
    value, the result is <type>double precision</type> (i.e., a pure number,
    not money); the currency units cancel each other out in the division.
-->
<type>money</type>型の値を整数型の値で除算すると、小数部分を0に切り捨てるように実行されます。
四捨五入した結果を得るためには、小数部分を持つ値で割り算するか、割り算を行う前に<type>money</type>型の値を<type>numeric</type>型にキャストし、あとで<type>money</type>型に戻します。
（精度を落とすリスクを避けるため、後者の方が好ましいです。）
<type>money</type>型の値を別の<type>money</type>型の値で除算すると、結果は<type>double precision</type>型（通貨ではなく純粋な数値）になります。
除算では通貨の単位は相殺されます。
   </para>
  </sect1>


  <sect1 id="datatype-character">
<!--
   <title>Character Types</title>
-->
   <title>文字型</title>

   <indexterm zone="datatype-character">
    <primary>character string</primary>
    <secondary>data types</secondary>
   </indexterm>
   <indexterm zone="datatype-character">
    <primary>文字の並び</primary>
    <secondary>データ型</secondary>
   </indexterm>

   <indexterm>
    <primary>string</primary>
    <see>character string</see>
   </indexterm>
   <indexterm>
    <primary>文字列</primary>
    <see>文字の並び</see>
   </indexterm>

   <indexterm zone="datatype-character">
    <primary>character</primary>
   </indexterm>

   <indexterm zone="datatype-character">
    <primary>character varying</primary>
   </indexterm>

   <indexterm zone="datatype-character">
    <primary>text</primary>
   </indexterm>

   <indexterm zone="datatype-character">
    <primary>char</primary>
   </indexterm>

   <indexterm zone="datatype-character">
    <primary>varchar</primary>
   </indexterm>

   <indexterm zone="datatype-character">
    <primary>bpchar</primary>
   </indexterm>

    <table id="datatype-character-table">
<!--
     <title>Character Types</title>
-->
     <title>文字型</title>
     <tgroup cols="2">
      <thead>
       <row>
<!--
        <entry>Name</entry>
        <entry>Description</entry>
-->
        <entry>型名</entry>
        <entry>説明</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><type>character varying(<replaceable>n</replaceable>)</type>, <type>varchar(<replaceable>n</replaceable>)</type></entry>
<!--
        <entry>variable-length with limit</entry>
-->
        <entry>上限付き可変長</entry>
       </row>
       <row>
        <entry><type>character(<replaceable>n</replaceable>)</type>, <type>char(<replaceable>n</replaceable>)</type>, <type>bpchar(<replaceable>n</replaceable>)</type></entry>
<!--
        <entry>fixed-length, blank-padded</entry>
-->
        <entry>空白で埋められた固定長</entry>
       </row>
       <row>
        <entry><type>bpchar</type></entry>
        <entry>variable unlimited length, blank-trimmed</entry>
       </row>
       <row>
        <entry><type>text</type></entry>
<!--
        <entry>variable unlimited length</entry>
-->
        <entry>制限なし可変長</entry>
       </row>
     </tbody>
     </tgroup>
    </table>

   <para>
<!--
    <xref linkend="datatype-character-table"/> shows the
    general-purpose character types available in
    <productname>PostgreSQL</productname>.
-->
<xref linkend="datatype-character-table"/>は<productname>PostgreSQL</productname>で使用可能な汎用文字型を示したものです。
   </para>

   <para>
<!--
    <acronym>SQL</acronym> defines two primary character types:
    <type>character varying(<replaceable>n</replaceable>)</type> and
    <type>character(<replaceable>n</replaceable>)</type>, where <replaceable>n</replaceable>
    is a positive integer.  Both of these types can store strings up to
    <replaceable>n</replaceable> characters (not bytes) in length.  An attempt to store a
    longer string into a column of these types will result in an
    error, unless the excess characters are all spaces, in which case
    the string will be truncated to the maximum length. (This somewhat
    bizarre exception is required by the <acronym>SQL</acronym>
    standard.)
    However, if one explicitly casts a value to <type>character
    varying(<replaceable>n</replaceable>)</type> or
    <type>character(<replaceable>n</replaceable>)</type>, then an over-length
    value will be truncated to <replaceable>n</replaceable> characters without
    raising an error. (This too is required by the
    <acronym>SQL</acronym> standard.)
    If the string to be stored is shorter than the declared
    length, values of type <type>character</type> will be space-padded;
    values of type <type>character varying</type> will simply store the
    shorter
    string.
-->
<acronym>SQL</acronym>は2つの主要な文字データ型を定義しています。
<type>character varying(<replaceable>n</replaceable>)</type>と<type>character(<replaceable>n</replaceable>)</type>です。
ここで<replaceable>n</replaceable>は正の整数です。
これらのデータ型は2つとも<replaceable>n</replaceable>文字長（バイト数ではなく）までの文字列を保存できます。
上限を越えた文字列をこれらの型の列に保存しようとするとエラーになります。
ただし、上限を超えた部分にある文字がすべて空白の場合はエラーにはならず、文字列の最大長にまで切り詰められます。
（この一風変わった例外は標準<acronym>SQL</acronym>で要求されています。）
しかし、<type>character varying(<replaceable>n</replaceable>)</type>や<type>character(<replaceable>n</replaceable>)</type>に明示的なキャストが行われた場合、文字数の上限を超えた値は、エラーを発生させることなく<replaceable>n</replaceable>文字に切り捨てられます。
（これもまた、標準<acronym>SQL</acronym>で要求されています。）
もし宣言された上限よりも文字列が短い時は<type>character</type>の値は空白で埋められ、<type>character varying</type>の値は単にその短い文字列で保存されます。
   </para>

   <para>
<!--
    In addition, <productname>PostgreSQL</productname> provides the
    <type>text</type> type, which stores strings of any length.
    Although the <type>text</type> type is not in the
    <acronym>SQL</acronym> standard, several other SQL database
    management systems have it as well.
    <type>text</type> is <productname>PostgreSQL</productname>'s native
    string data type, in that most built-in functions operating on strings
    are declared to take or return <type>text</type> not <type>character
    varying</type>.  For many purposes, <type>character varying</type>
    acts as though it were a <link linkend="domains">domain</link>
    over <type>text</type>.
-->
さらに、<productname>PostgreSQL</productname>は、任意の長さの文字列を格納する<type>text</type>型を提供します。
<type>text</type>型は標準<acronym>SQL</acronym>にはありませんが、他のいくつかのSQLデータベース管理システムにもあります。
<type>text</type>は<productname>PostgreSQL</productname>ネイティブの文字列データ型であり、文字列を操作するほとんどの組み込み関数には、引数や戻り値に<type>character varying</type>ではなく、<type>text</type>が宣言されています。
多くの目的のために、<type>character varying</type>は<type>text</type>に対する<link linkend="domains">ドメイン</link>であるかのように動作します。
   </para>

   <para>
<!--
    The type name <type>varchar</type> is an alias for <type>character
    varying</type>, while <type>bpchar</type> (with length specifier) and
    <type>char</type> are aliases for <type>character</type>.  The
    <type>varchar</type> and <type>char</type> aliases are defined in the
    <acronym>SQL</acronym> standard;  <type>bpchar</type> is a
    <productname>PostgreSQL</productname> extension.
-->
型名<type>varchar</type>は<type>character varying</type>の別名で、（長さ指定子がある）<type>bpchar</type>と<type>char</type>は<type>character</type>の別名です。
<type>varchar</type>と<type>char</type>の別名は標準<acronym>SQL</acronym>で定義されています。<type>bpchar</type>は<productname>PostgreSQL</productname>の拡張です。
   </para>

   <para>
<!--
    If specified, the length <replaceable>n</replaceable> must be greater
    than zero and cannot exceed 10,485,760.  If <type>character
    varying</type> (or <type>varchar</type>) is used without
    length specifier, the type accepts strings of any length. If
    <type>bpchar</type> lacks a length specifier, it also accepts strings
    of any length, but trailing spaces are semantically insignificant.
    If <type>character</type> (or <type>char</type>) lacks a specifier,
    it is equivalent to <type>character(1)</type>.
-->
長さを指定する場合、<replaceable>n</replaceable>はゼロより大きな値でなければならず、10,485,760を超えることはできません。
長さ指定子なしで<type>character varying</type> （または<type>varchar</type>）が使用された場合、この型は任意の長さの文字列を受け入れます。
<type>bpchar</type>に長さ指定子がない場合、この型は任意の長さの文字列も受け付けますが、末尾の空白は意味的に重要ではありません。
<type>character</type>（または<type>char</type>）に指定子がない場合、この型は<type>character(1)</type>と同じです。
   </para>

   <para>
<!--
    Values of type <type>character</type> are physically padded
    with spaces to the specified width <replaceable>n</replaceable>, and are
    stored and displayed that way.  However, trailing spaces are treated as
    semantically insignificant and disregarded when comparing two values
    of type <type>character</type>.  In collations where whitespace
    is significant, this behavior can produce unexpected results;
    for example <command>SELECT 'a '::CHAR(2) collate "C" &lt;
    E'a\n'::CHAR(2)</command> returns true, even though <literal>C</literal>
    locale would consider a space to be greater than a newline.
    Trailing spaces are removed when converting a <type>character</type> value
    to one of the other string types.  Note that trailing spaces
    <emphasis>are</emphasis> semantically significant in
    <type>character varying</type> and <type>text</type> values, and
    when using pattern matching, that is <literal>LIKE</literal> and
    regular expressions.
-->
<type>character</type>型の値は、指定長<replaceable>n</replaceable>になるまで物理的に空白で埋められ、そのまま格納、表示されます。
しかし、最後の空白は、意味的に重要ではないものとして扱われ、2つの<type>character</type>型の値を比べる際には無視されます。
空白が重要な照合順序では、この挙動は予期しない結果を返す可能性があります。例えば、<command>SELECT 'a '::CHAR(2) collate "C" &lt; E'a\n'::CHAR(2)</command>は<literal>C</literal>ロケールでスペースが改行よりも大きいにも関わらず真を返します。
<type>character</type>値を他の文字列型に変換する際は、文字列の終わりの空白は除去されます。
<type>character varying</type>型と<type>text</type>型の値の中や、パターンマッチを行なう際、すなわち<literal>LIKE</literal>や正規表現では、最後の空白は意味的に重要なもの<emphasis>です</emphasis>ので、注意してください。
   </para>

   <para>
<!--
    The characters that can be stored in any of these data types are
    determined by the database character set, which is selected when
    the database is created.  Regardless of the specific character set,
    the character with code zero (sometimes called NUL) cannot be stored.
    For more information refer to <xref linkend="multibyte"/>.
-->
これらのデータ型のいずれかに格納できる文字はデータベースを作成するときに選択されるデータベースキャラクタセットによって決定されます。
特定のキャラクタセットに関わらず、コード0（時にはNULと呼ばれます）を格納することはできません。
より詳細な情報は<xref linkend="multibyte"/>を参照ください。
   </para>

   <para>
<!--
    The storage requirement for a short string (up to 126 bytes) is 1 byte
    plus the actual string, which includes the space padding in the case of
    <type>character</type>.  Longer strings have 4 bytes of overhead instead
    of 1.  Long strings are compressed by the system automatically, so
    the physical requirement on disk might be less. Very long values are also
    stored in background tables so that they do not interfere with rapid
    access to shorter column values. In any case, the longest
    possible character string that can be stored is about 1 GB. (The
    maximum value that will be allowed for <replaceable>n</replaceable> in the data
    type declaration is less than that. It wouldn't be useful to
    change this because with multibyte character encodings the number of
    characters and bytes can be quite different. If you desire to
    store long strings with no specific upper limit, use
    <type>text</type> or <type>character varying</type> without a length
    specifier, rather than making up an arbitrary length limit.)
-->
短い文字列（126バイトまで）の保存には、実際の文字列に１バイト加えたサイズが必要です。
<type>character</type>では空白埋め込み分もこれに含まれます。
より長い文字列では１バイトではなく４バイトのオーバーヘッドになります。
長い文字列はシステムにより自動的に圧縮されますので、ディスク上の物理的必要容量サイズはより小さくなるかもしれません。
また、非常に長い値はより短い列の値への高速アクセスに干渉しないように、バックグラウンドテーブルに格納されます。
いずれの場合にあっても保存できる最長の文字列は約1ギガバイトです。
（データ型宣言に使われる<replaceable>n</replaceable>に許される最大値はこれより小さいものです。
マルチバイト文字符号化方式においては文字数とバイト数はまったく異なっているため、この値の変更は便利ではありません。
特定の上限を設けずに長い文字列を保存したい場合は、適当な上限を設けるよりも、<type>text</type>もしくは長さの指定がない<type>character varying</type>を使用してください。）
   </para>

   <tip>
    <para>
<!--
     There is no performance difference among these three types,
     apart from increased storage space when using the blank-padded
     type, and a few extra CPU cycles to check the length when storing into
     a length-constrained column.  While
     <type>character(<replaceable>n</replaceable>)</type> has performance
     advantages in some other database systems, there is no such advantage in
     <productname>PostgreSQL</productname>; in fact
     <type>character(<replaceable>n</replaceable>)</type> is usually the slowest of
     the three because of its additional storage costs.  In most situations
     <type>text</type> or <type>character varying</type> should be used
     instead.
-->
空白で埋められる型を使用した場合の保存領域の増加、および、長さ制限付きの列に格納する際に長さを検査するためにいくつか余計なCPUサイクルが加わる点を別にして、これら3つの型の間で性能に関する差異はありません。
他の一部のデータベースシステムでは<type>character(<replaceable>n</replaceable>)</type>には性能的な優位性がありますが、<productname>PostgreSQL</productname>ではこうした利点はありません。
実際には、格納の際に追加のコストがあるため、<type>character(<replaceable>n</replaceable>)</type>は3つの中でもっとも低速です。
多くの場合、代わりに<type>text</type>か<type>character varying</type>を使うのがお薦めです。
    </para>
   </tip>

   <para>
<!--
    Refer to <xref linkend="sql-syntax-strings"/> for information about
    the syntax of string literals, and to <xref linkend="functions"/>
    for information about available operators and functions.
-->
文字列リテラルの構文については<xref linkend="sql-syntax-strings"/>、利用可能な演算子と関数については<xref linkend="functions"/>を参照してください。
   </para>

   <example>
<!--
    <title>Using the Character Types</title>
-->
    <title>文字データ型の使用</title>

<programlisting>
CREATE TABLE test1 (a character(4));
INSERT INTO test1 VALUES ('ok');
SELECT a, char_length(a) FROM test1; -- <co id="co.datatype-char"/>
<computeroutput>
  a   | char_length
------+-------------
 ok   |           2
</computeroutput>

CREATE TABLE test2 (b varchar(5));
INSERT INTO test2 VALUES ('ok');
INSERT INTO test2 VALUES ('good      ');
INSERT INTO test2 VALUES ('too long');
<computeroutput>ERROR:  value too long for type character varying(5)</computeroutput>
<!--
INSERT INTO test2 VALUES ('too long'::varchar(5)); &#45;- explicit truncation
-->
INSERT INTO test2 VALUES ('too long'::varchar(5)); -- 明示的な切り捨て
SELECT b, char_length(b) FROM test2;
<computeroutput>
   b   | char_length
-------+-------------
 ok    |           2
 good  |           5
 too l |           5
</computeroutput>
</programlisting>
    <calloutlist>
     <callout arearefs="co.datatype-char">
      <para>
<!--
       The <function>char_length</function> function is discussed in
       <xref linkend="functions-string"/>.
-->
<function>char_length</function>関数は<xref linkend="functions-string"/>で説明されています。
      </para>
     </callout>
    </calloutlist>
   </example>

   <para>
<!--
    There are two other fixed-length character types in
    <productname>PostgreSQL</productname>, shown in <xref
    linkend="datatype-character-special-table"/>.
    These are not intended for general-purpose use, only for use
    in the internal system catalogs.
    The <type>name</type> type is used to store identifiers. Its
    length is currently defined as 64 bytes (63 usable characters plus
    terminator) but should be referenced using the constant
    <symbol>NAMEDATALEN</symbol> in <literal>C</literal> source code.
    The length is set at compile time (and
    is therefore adjustable for special uses); the default maximum
    length might change in a future release. The type <type>"char"</type>
    (note the quotes) is different from <type>char(1)</type> in that it
    only uses one byte of storage, and therefore can store only a single
    ASCII character. It is used in the system
    catalogs as a simplistic enumeration type.
-->
<productname>PostgreSQL</productname>には、<xref linkend="datatype-character-special-table"/>に示すように、この他2つの固定長文字型があります。
これらは一般的な使用を目的としたものではなく、内部的なシステムカタログでのみ使用することを意図しています。
<type>name</type>型は識別子を格納するために使われます。
現在長さは64バイト（63バイトの利用可能文字と終止文字）と定義されていますが、<literal>C</literal>ソースコードにある<symbol>NAMEDATALEN</symbol>定数を使って参照される必要があります。
この長さはコンパイル時に設定されます（そのため特別な用途に合わせ調整できます）。
デフォルトの最大長は今後のリリースで変更される可能性があります。
<type>"char"</type>（二重引用符に注意）は、<type>char(1)</type>とは異なり、1バイトの領域しか使用せず、このため、シングルバイトのASCII文字のみを格納することができます。
過度に単純化した列挙型としてシステムカタログで内部的に使用されます。
   </para>

    <table id="datatype-character-special-table">
<!--
     <title>Special Character Types</title>
-->
     <title>特別な文字データ型</title>
     <tgroup cols="3">
      <thead>
       <row>
<!--
        <entry>Name</entry>
        <entry>Storage Size</entry>
        <entry>Description</entry>
-->
        <entry>型名</entry>
        <entry>格納サイズ</entry>
        <entry>説明</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><type>"char"</type></entry>
<!--
        <entry>1 byte</entry>
        <entry>single-byte internal type</entry>
-->
        <entry>1バイト</entry>
        <entry>単一バイト内部データ型</entry>
       </row>
       <row>
        <entry><type>name</type></entry>
<!--
        <entry>64 bytes</entry>
        <entry>internal type for object names</entry>
-->
        <entry>64バイト</entry>
        <entry>オブジェクト名用の内部データ型</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

  </sect1>

 <sect1 id="datatype-binary">
<!--
  <title>Binary Data Types</title>
-->
  <title>バイナリ列データ型</title>

  <indexterm zone="datatype-binary">
   <primary>binary data</primary>
  </indexterm>
  <indexterm zone="datatype-binary">
   <primary>バイナリデータ</primary>
  </indexterm>

  <indexterm zone="datatype-binary">
   <primary>bytea</primary>
  </indexterm>

   <para>
<!--
    The <type>bytea</type> data type allows storage of binary strings;
    see <xref linkend="datatype-binary-table"/>.
-->
<type>bytea</type>データ型はバイナリ列の保存を可能にします。
<xref linkend="datatype-binary-table"/>を参照してください。
   </para>

   <table id="datatype-binary-table">
<!--
    <title>Binary Data Types</title>
-->
    <title>バイナリ列データ型</title>
    <tgroup cols="3">
     <colspec colname="col1" colwidth="1*"/>
     <colspec colname="col2" colwidth="3*"/>
     <colspec colname="col3" colwidth="2*"/>
     <thead>
      <row>
<!--
       <entry>Name</entry>
       <entry>Storage Size</entry>
       <entry>Description</entry>
-->
       <entry>型名</entry>
       <entry>格納サイズ</entry>
       <entry>説明</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><type>bytea</type></entry>
<!--
       <entry>1 or 4 bytes plus the actual binary string</entry>
       <entry>variable-length binary string</entry>
-->
       <entry>1または4バイトと実際のバイナリ列の長さ</entry>
       <entry>可変長のバイナリ列</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
<!--
    A binary string is a sequence of octets (or bytes).  Binary
    strings are distinguished from character strings in two
    ways.  First, binary strings specifically allow storing
    octets of value zero and other <quote>non-printable</quote>
    octets (usually, octets outside the decimal range 32 to 126).
    Character strings disallow zero octets, and also disallow any
    other octet values and sequences of octet values that are invalid
    according to the database's selected character set encoding.
    Second, operations on binary strings process the actual bytes,
    whereas the processing of character strings depends on locale settings.
    In short, binary strings are appropriate for storing data that the
    programmer thinks of as <quote>raw bytes</quote>, whereas character
    strings are appropriate for storing text.
-->
バイナリ列はオクテット（またはバイト）の連続です。
バイナリ列は２つの点で文字列と区別されます。
1点目は、バイナリ列はゼロの値のオクテットと他の<quote>表示できない</quote>オクテット（通常10進数表記で32から126の範囲外のオクテット）を保存できるということです。
文字列ではゼロというオクテットは使用できません。
また、データベースで選択している文字セット符号化方式で無効なオクテット値やオクテット値の並びも使用できません。
2点目は、バイナリ列を演算すると実際のバイトが処理されるのに対して、文字列の処理はロケール設定に従うということです。
まとめると、バイナリ列はプログラマが<quote>バイト列そのもの</quote>と考えるものを格納するのに適し、文字列はテキストを格納するのに適しています。
   </para>

   <para>
<!--
    The <type>bytea</type> type supports two
    formats for input and output: <quote>hex</quote> format
    and <productname>PostgreSQL</productname>'s historical
    <quote>escape</quote> format.  Both
    of these are always accepted on input.  The output format depends
    on the configuration parameter <xref linkend="guc-bytea-output"/>;
    the default is hex.  (Note that the hex format was introduced in
    <productname>PostgreSQL</productname> 9.0; earlier versions and some
    tools don't understand it.)
-->
<type>bytea</type>型は入出力用に2つの書式をサポートします。
<quote>hex</quote>書式と<productname>PostgreSQL</productname>の歴史的な<quote>エスケープ</quote>書式です。
入力ではこれらの両方とも常に受け入れられます。
出力書式は<xref linkend="guc-bytea-output"/>設定パラメータに依存し、デフォルトではhexです。
（hex書式は<productname>PostgreSQL</productname> 9.0から導入されたものであることに注意してください。
以前のバージョンや一部のツールではこれを理解しません。）
   </para>

   <para>
<!--
    The <acronym>SQL</acronym> standard defines a different binary
    string type, called <type>BLOB</type> or <type>BINARY LARGE
    OBJECT</type>.  The input format is different from
    <type>bytea</type>, but the provided functions and operators are
    mostly the same.
-->
標準<acronym>SQL</acronym>は、<type>BLOB</type>または<type>BINARY LARGE OBJECT</type>という、異なるバイナリ列型を定義します。
入力書式は<type>bytea</type>と異なりますが、提供される関数および演算子はほぼ同じです。
   </para>

  <sect2 id="datatype-binary-bytea-hex-format">
<!--
   <title><type>bytea</type> Hex Format</title>
-->
   <title><type>bytea</type>のhex書式</title>

   <para>
<!--
    The <quote>hex</quote> format encodes binary data as 2 hexadecimal digits
    per byte, most significant nibble first.  The entire string is
    preceded by the sequence <literal>\x</literal> (to distinguish it
    from the escape format).  In some contexts, the initial backslash may
    need to be escaped by doubling it
    (see <xref linkend="sql-syntax-strings"/>).
    For input, the hexadecimal digits can
    be either upper or lower case, and whitespace is permitted between
    digit pairs (but not within a digit pair nor in the starting
    <literal>\x</literal> sequence).
    The hex format is compatible with a wide
    range of external applications and protocols, and it tends to be
    faster to convert than the escape format, so its use is preferred.
-->
<quote>hex</quote>書式ではバイナリデータの各バイトを上位4ビット、下位4ビットの順で2桁の16進数に符号化します。
（エスケープ書式と区別するために）文字列全体は<literal>\x</literal>という並びの後に付けられます。
一部の文脈では、先頭のバックスラッシュを二重にしてエスケープさせる必要があるかもしれません(以下を参照 <xref linkend="sql-syntax-strings"/>)。
これはエスケープ書式でバックスラッシュを二重にしなければならない場合と同じで、詳細は以下に示します。
入力する16進数の桁は大文字でも小文字でも構いません。
数字のペアの間に空白文字を入れることができます。
（しかし桁の組み合わせの間や先頭の<literal>\x</literal>の間には入れることはできません。）
hex書式は外部のアプリケーションおよびプロトコルの間で広く互換性を持ち、また、エスケープ書式と比べ変換が高速になる傾向があります。
このため使用が好まれます。
   </para>

   <para>
<!--
    Example:
-->
例
<programlisting>
SET bytea_output = 'hex';

SELECT '\xDEADBEEF'::bytea;
   bytea
------------
 \xdeadbeef
</programlisting>
   </para>
  </sect2>

  <sect2 id="datatype-binary-bytea-escape-format">
<!--
   <title><type>bytea</type> Escape Format</title>
-->
   <title><type>bytea</type>のエスケープ書式</title>

   <para>
<!--
    The <quote>escape</quote> format is the traditional
    <productname>PostgreSQL</productname> format for the <type>bytea</type>
    type.  It
    takes the approach of representing a binary string as a sequence
    of ASCII characters, while converting those bytes that cannot be
    represented as an ASCII character into special escape sequences.
    If, from the point of view of the application, representing bytes
    as characters makes sense, then this representation can be
    convenient.  But in practice it is usually confusing because it
    fuzzes up the distinction between binary strings and character
    strings, and also the particular escape mechanism that was chosen is
    somewhat unwieldy.  Therefore, this format should probably be avoided
    for most new applications.
-->
<quote>エスケープ</quote>書式は<type>bytea</type>型用の伝統的な<productname>PostgreSQL</productname>の書式です。
これは、バイナリ列をASCII文字の並びとして表現しASCII文字として表現できないバイトは特殊なエスケープシーケンスとして表現するという方式を取ります。
アプリケーションの見地から文字として表現されたバイトが有意であれば、この表現は簡便です。
しかし現実にはバイナリ列と文字列の間の区別があいまいになりますので、通常は混乱します。
また選択されたこのエスケープ機構自体が多少非効率的です。
このためこの書式はおそらくほとんどの新しいアプリケーションでは避けるべきでしょう。
   </para>

   <para>
<!--
    When entering <type>bytea</type> values in escape format,
    octets of certain
    values <emphasis>must</emphasis> be escaped, while all octet
    values <emphasis>can</emphasis> be escaped.  In
    general, to escape an octet, convert it into its three-digit
    octal value and precede it by a backslash.
    Backslash itself (octet decimal value 92) can alternatively be represented by
    double backslashes.
    <xref linkend="datatype-binary-sqlesc"/>
    shows the characters that must be escaped, and gives the alternative
    escape sequences where applicable.
-->
エスケープ書式で<type>bytea</type>値を入力する際に、特定の値のオクテットをエスケープする<emphasis>必要</emphasis>があります。
なお、すべてのオクテットの値をエスケープすることが<emphasis>できます</emphasis>。
一般的にあるオクテットをエスケープするには、それをその3桁の8進数に変換し、バックスラッシュを前に付けます。
他にもバックスラッシュ自体(10進数表記のオクテットで92)を二重のバックスラッシュとして表現することができます。
<xref linkend="datatype-binary-sqlesc"/>には、エスケープする必要がある文字と、その適用可能な代替エスケープシーケンスを示しています。
   </para>

   <table id="datatype-binary-sqlesc">
<!--
    <title><type>bytea</type> Literal Escaped Octets</title>
-->
    <title>オクテットをエスケープした<type>bytea</type>リテラル</title>
    <tgroup cols="5">
     <colspec colname="col1" colwidth="1*"/>
     <colspec colname="col2" colwidth="1*"/>
     <colspec colname="col3" colwidth="1*"/>
     <colspec colname="col4" colwidth="1.25*"/>
     <colspec colname="col5" colwidth="1*"/>
     <thead>
      <row>
<!--
       <entry>Decimal Octet Value</entry>
       <entry>Description</entry>
       <entry>Escaped Input Representation</entry>
       <entry>Example</entry>
       <entry>Hex Representation</entry>
-->
       <entry>10進オクテット値</entry>
       <entry>説明</entry>
       <entry>エスケープされた入力表現</entry>
       <entry>例</entry>
       <entry>出力表現</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry>0</entry>
<!--
       <entry>zero octet</entry>
       <entry><literal>'\000'</literal></entry>
       <entry><literal>'\000'::bytea</literal></entry>
       <entry><literal>\x00</literal></entry>
-->
       <entry>ゼロオクテット</entry>
       <entry><literal>'\000'</literal></entry>
       <entry><literal>'\000'::bytea;</literal></entry>
       <entry><literal>\x00</literal></entry>
      </row>

      <row>
       <entry>39</entry>
<!--
       <entry>single quote</entry>
-->
       <entry>単一引用符</entry>
<!--
       <entry><literal>''''</literal> or <literal>'\047'</literal></entry>
       <entry><literal>''''::bytea</literal></entry>
-->
       <entry><literal>''''</literal>もしくは<literal>'\047'</literal></entry>
       <entry><literal>''''::bytea;</literal></entry>
       <entry><literal>\x27</literal></entry>
      </row>

      <row>
       <entry>92</entry>
<!--
       <entry>backslash</entry>
-->
       <entry>バックスラッシュ</entry>
<!--
       <entry><literal>'\\'</literal> or <literal>'\134'</literal></entry>
       <entry><literal>'\\'::bytea</literal></entry>
-->
       <entry><literal>'\\'</literal>もしくは<literal>'\\134'</literal></entry>
       <entry><literal>'\\'::bytea;</literal></entry>
       <entry><literal>\x5c</literal></entry>
      </row>

      <row>
<!--
       <entry>0 to 31 and 127 to 255</entry>
       <entry><quote>non-printable</quote> octets</entry>
-->
       <entry>0から31まで、および127から255まで</entry>
       <entry><quote>表示できない</quote>オクテット</entry>
<!--
       <entry><literal>'\<replaceable>xxx'</replaceable></literal> (octal value)</entry>
       <entry><literal>'\001'::bytea</literal></entry>
-->
       <entry><literal>'\<replaceable>xxx'</replaceable></literal> (8進数)</entry>
       <entry><literal>'\001'::bytea;</literal></entry>
       <entry><literal>\x01</literal></entry>
      </row>

     </tbody>
    </tgroup>
   </table>

   <para>
<!--
    The requirement to escape <emphasis>non-printable</emphasis> octets
    varies depending on locale settings. In some instances you can get away
    with leaving them unescaped.
-->
実際には、<emphasis>表示できない</emphasis>オクテットに対するエスケープ要求はロケールの設定に依存して異なります。
ロケールの設定によっては、エスケープをしないで済むこともあります。
   </para>

   <para>
<!--
    The reason that single quotes must be doubled, as shown
    in <xref linkend="datatype-binary-sqlesc"/>, is that this
    is true for any string literal in an SQL command.  The generic
    string-literal parser consumes the outermost single quotes
    and reduces any pair of single quotes to one data character.
    What the <type>bytea</type> input function sees is just one
    single quote, which it treats as a plain data character.
    However, the <type>bytea</type> input function treats
    backslashes as special, and the other behaviors shown in
    <xref linkend="datatype-binary-sqlesc"/> are implemented by
    that function.
-->
<xref linkend="datatype-binary-sqlesc"/>で示したように、シングルクォートが二重に必要な理由は、SQLコマンド中のあらゆる文字列に当てはまるためです。
一般的な文字列パーサは最も外側のシングルクォートを消費し、シングルクォートのペアを一つの文字データに減らします。
<type>bytea</type>を入力する関数が見るのは単に一つのシングルクォートであり、一個の単純なデータ文字として扱います。
しかし、<type>bytea</type>を入力する関数はバックスラッシュを特別なものとして扱い、<xref linkend="datatype-binary-sqlesc"/>に示されているその他の動作はこの関数で実装されています。
   </para>

   <para>
<!--
    In some contexts, backslashes must be doubled compared to what is
    shown above, because the generic string-literal parser will also
    reduce pairs of backslashes to one data character;
    see <xref linkend="sql-syntax-strings"/>.
-->
一般的な文字列パーサはバックスラッシュのペアを一つの文字データに減らすため、文脈によってはバックスラッシュは上記に見られるように、重ねる必要があります。
<xref linkend="sql-syntax-strings"/>も参照ください。
   </para>

   <para>
<!--
    <type>Bytea</type> octets are output in <literal>hex</literal>
    format by default.  If you change <xref linkend="guc-bytea-output"/>
    to <literal>escape</literal>,
    <quote>non-printable</quote> octets are converted to their
    equivalent three-digit octal value and preceded by one backslash.
    Most <quote>printable</quote> octets are output by their standard
    representation in the client character set, e.g.:
-->
<type>Bytea</type>オクテットはデフォルトでは<literal>hex</literal>書式で出力されます。
<xref linkend="guc-bytea-output"/>を<literal>escape</literal>に変えると、<quote>表示できない</quote>オクテットは先頭にバックスラッシュがついた3桁のオクテットの値に変換されます。
ほとんどの<quote>表示可能な</quote>オクテットはクライアント文字セットの標準的な表示で出力されます。例:

<programlisting>
SET bytea_output = 'escape';

SELECT 'abc \153\154\155 \052\251\124'::bytea;
     bytea
----------------
 abc klm *\251T
</programlisting>

<!--
    The octet with decimal value 92 (backslash) is doubled in the output.
    Details are in <xref linkend="datatype-binary-resesc"/>.
-->
10進数で92(バックスラッシュ)を持つオクテットは出力時に二重になります。
詳細は<xref linkend="datatype-binary-resesc"/>を参照してください。
   </para>

   <table id="datatype-binary-resesc">
<!--
    <title><type>bytea</type> Output Escaped Octets</title>
-->
    <title><type>bytea</type>出力のエスケープされたオクテット</title>
    <tgroup cols="5">
     <colspec colname="col1" colwidth="1*"/>
     <colspec colname="col2" colwidth="1*"/>
     <colspec colname="col3" colwidth="1*"/>
     <colspec colname="col4" colwidth="1.25*"/>
     <colspec colname="col5" colwidth="1*"/>
     <thead>
      <row>
<!--
       <entry>Decimal Octet Value</entry>
       <entry>Description</entry>
       <entry>Escaped Output Representation</entry>
       <entry>Example</entry>
       <entry>Output Result</entry>
-->
       <entry>10進オクテット値</entry>
       <entry>説明</entry>
       <entry>エスケープされた出力表現</entry>
       <entry>例</entry>
       <entry>出力結果</entry>
      </row>
     </thead>

     <tbody>

      <row>
       <entry>92</entry>
<!--
       <entry>backslash</entry>
-->
       <entry>バックスラッシュ</entry>
       <entry><literal>\\</literal></entry>
       <entry><literal>'\134'::bytea</literal></entry>
       <entry><literal>\\</literal></entry>
      </row>

      <row>
<!--
       <entry>0 to 31 and 127 to 255</entry>
       <entry><quote>non-printable</quote> octets</entry>
-->
       <entry>0から31および127から255</entry>
       <entry><quote>表示できない</quote>オクテット</entry>
<!--
       <entry><literal>\<replaceable>xxx</replaceable></literal> (octal value)</entry>
       <entry><literal>'\001'::bytea</literal></entry>
-->
       <entry><literal>\<replaceable>xxx</replaceable></literal>（8進数）</entry>
       <entry><literal>'\001'::bytea;</literal></entry>
       <entry><literal>\001</literal></entry>
      </row>

      <row>
<!--
       <entry>32 to 126</entry>
       <entry><quote>printable</quote> octets</entry>
       <entry>client character set representation</entry>
       <entry><literal>'\176'::bytea</literal></entry>
       <entry><literal>~</literal></entry>
-->
       <entry>32から126</entry>
       <entry><quote>表示できる</quote>オクテット</entry>
       <entry>クライアント文字セットにおける表現</entry>
       <entry><literal>'\176'::bytea;</literal></entry>
       <entry><literal>~</literal></entry>
      </row>

     </tbody>
    </tgroup>
   </table>

   <para>
<!--
    Depending on the front end to <productname>PostgreSQL</productname> you use,
    you might have additional work to do in terms of escaping and
    unescaping <type>bytea</type> strings. For example, you might also
    have to escape line feeds and carriage returns if your interface
    automatically translates these.
-->
使用する<productname>PostgreSQL</productname>のフロントエンドによっては、<type>bytea</type>文字列をエスケープまたはアンエスケープする追加的な作業が必要になることがあります。
例えば、使用するインタフェースが改行文字や復帰文字を自動的に翻訳してしまう場合、これらの文字もエスケープしなければならないかもしれません。
   </para>
  </sect2>
 </sect1>


  <sect1 id="datatype-datetime">
<!--
   <title>Date/Time Types</title>
-->
   <title>日付/時刻データ型</title>

   <indexterm zone="datatype-datetime">
    <primary>date</primary>
   </indexterm>
   <indexterm zone="datatype-datetime">
    <primary>time</primary>
   </indexterm>
   <indexterm zone="datatype-datetime">
    <primary>time without time zone</primary>
   </indexterm>
   <indexterm zone="datatype-datetime">
    <primary>time with time zone</primary>
   </indexterm>
   <indexterm zone="datatype-datetime">
    <primary>timestamp</primary>
   </indexterm>
   <indexterm zone="datatype-datetime">
    <primary>timestamptz</primary>
   </indexterm>
   <indexterm zone="datatype-datetime">
    <primary>timestamp with time zone</primary>
   </indexterm>
   <indexterm zone="datatype-datetime">
    <primary>timestamp without time zone</primary>
   </indexterm>
   <indexterm zone="datatype-datetime">
    <primary>interval</primary>
   </indexterm>
   <indexterm zone="datatype-datetime">
    <primary>time span</primary>
   </indexterm>
   <indexterm zone="datatype-datetime">
    <primary>時間間隔</primary>
   </indexterm>

   <para>
<!--
    <productname>PostgreSQL</productname> supports the full set of
    <acronym>SQL</acronym> date and time types, shown in <xref
    linkend="datatype-datetime-table"/>.  The operations available
    on these data types are described in
    <xref linkend="functions-datetime"/>.
    Dates are counted according to the Gregorian calendar, even in
    years before that calendar was introduced (see <xref
    linkend="datetime-units-history"/> for more information).
-->
<productname>PostgreSQL</productname>では、<xref linkend="datatype-datetime-table"/>に示されている<acronym>SQL</acronym>の日付と時刻データ型のすべてがサポートされています。
これらのデータ型で利用できる演算については<xref linkend="functions-datetime"/>で説明します。
グレゴリオ暦が導入されるより前の年であっても（<xref linkend="datetime-units-history"/>参照）、日付はグレゴリオ暦にしたがって計算されます。
   </para>

    <table id="datatype-datetime-table">
<!--
     <title>Date/Time Types</title>
-->
     <title>日付/時刻データ型</title>
     <tgroup cols="6">
      <thead>
       <row>
<!--
        <entry>Name</entry>
        <entry>Storage Size</entry>
        <entry>Description</entry>
        <entry>Low Value</entry>
        <entry>High Value</entry>
        <entry>Resolution</entry>
-->
        <entry>型名</entry>
        <entry>格納サイズ</entry>
        <entry>説明</entry>
        <entry>最遠の過去</entry>
        <entry>最遠の未来</entry>
        <entry>精度</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><type>timestamp [ (<replaceable>p</replaceable>) ] [ without time zone ]</type></entry>
<!--
        <entry>8 bytes</entry>
        <entry>both date and time (no time zone)</entry>
-->
        <entry>8 バイト</entry>
        <entry>日付と時刻両方（時間帯なし）</entry>
        <entry>4713 BC</entry>
        <entry>294276 AD</entry>
<!--
        <entry>1 microsecond</entry>
-->
        <entry>1マイクロ秒</entry>
       </row>
       <row>
        <entry><type>timestamp [ (<replaceable>p</replaceable>) ] with time zone</type></entry>
<!--
        <entry>8 bytes</entry>
        <entry>both date and time, with time zone</entry>
-->
        <entry>8バイト</entry>
        <entry>日付と時刻両方、時間帯付き</entry>
        <entry>4713 BC</entry>
        <entry>294276 AD</entry>
<!--
        <entry>1 microsecond</entry>
-->
        <entry>1マイクロ秒</entry>
       </row>
       <row>
        <entry><type>date</type></entry>
<!--
        <entry>4 bytes</entry>
        <entry>date (no time of day)</entry>
-->
        <entry>4バイト</entry>
        <entry>日付（時刻なし）</entry>
        <entry>4713 BC</entry>
        <entry>5874897 AD</entry>
<!--
        <entry>1 day</entry>
-->
        <entry>1日</entry>
       </row>
       <row>
        <entry><type>time [ (<replaceable>p</replaceable>) ] [ without time zone ]</type></entry>
<!--
        <entry>8 bytes</entry>
        <entry>time of day (no date)</entry>
-->
        <entry>8バイト</entry>
        <entry>時刻（日付なし）</entry>
        <entry>00:00:00</entry>
        <entry>24:00:00</entry>
<!--
        <entry>1 microsecond</entry>
-->
        <entry>1マイクロ秒</entry>
       </row>
       <row>
        <entry><type>time [ (<replaceable>p</replaceable>) ] with time zone</type></entry>
<!--
        <entry>12 bytes</entry>
        <entry>time of day (no date), with time zone</entry>
        <!&#45;- see MAX_TZDISP_HOUR in datatype/timestamp.h &#45;->
        <entry>00:00:00+1559</entry>
        <entry>24:00:00-1559</entry>
        <entry>1 microsecond</entry>
-->
        <entry>12 バイト</entry>
        <entry>時刻（日付なし）、時間帯付き</entry>
        <entry>00:00:00+1559</entry>
        <entry>24:00:00-1559</entry>
        <entry>1 マイクロ秒</entry>
       </row>
       <row>
        <entry><type>interval [ <replaceable>fields</replaceable> ] [ (<replaceable>p</replaceable>) ]</type></entry>
<!--
        <entry>16 bytes</entry>
        <entry>time interval</entry>
        <entry>-178000000 years</entry>
        <entry>178000000 years</entry>
        <entry>1 microsecond</entry>
-->
        <entry>16バイト</entry>
        <entry>時間間隔</entry>
        <entry>-178000000年</entry>
        <entry>178000000年</entry>
        <entry>1マイクロ秒</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <note>
    <para>
<!--
     The SQL standard requires that writing just <type>timestamp</type>
     be equivalent to <type>timestamp without time
     zone</type>, and <productname>PostgreSQL</productname> honors that
     behavior.  <type>timestamptz</type> is accepted as an
     abbreviation for <type>timestamp with time zone</type>; this is a
     <productname>PostgreSQL</productname> extension.
-->
標準SQLでは、単なる<type>timestamp</type>という記述は<type>timestamp without time zone</type>と同じであることを要求します。
<productname>PostgreSQL</productname>はこれに準じます。
<type>timestamp with time zone</type>は<type>timestamptz</type>と省略することができますが、これは<productname>PostgreSQL</productname>の拡張です。
    </para>
   </note>

   <para>
<!--
    <type>time</type>, <type>timestamp</type>, and
    <type>interval</type> accept an optional precision value
    <replaceable>p</replaceable> which specifies the number of
    fractional digits retained in the seconds field. By default, there
    is no explicit bound on precision.  The allowed range of
    <replaceable>p</replaceable> is from 0 to 6.
-->
<type>time</type>、<type>timestamp</type>および<type>interval</type>は秒フィールドに保有されている小数点以下の桁数を指定する精度値<replaceable>p</replaceable>をオプションで受け付けます。
デフォルトでは、精度についての明示的な限界はありません。
<replaceable>p</replaceable>の許容範囲は0から6です。
   </para>

   <para>
<!--
    The <type>interval</type> type has an additional option, which is
    to restrict the set of stored fields by writing one of these phrases:
-->
<type>interval</type>データ型には追加のオプションがあり、以下の１つの語句を使用して格納されるフィールドの集合を制約します。
<literallayout class="monospaced">
YEAR
MONTH
DAY
HOUR
MINUTE
SECOND
YEAR TO MONTH
DAY TO HOUR
DAY TO MINUTE
DAY TO SECOND
HOUR TO MINUTE
HOUR TO SECOND
MINUTE TO SECOND
</literallayout>
<!--
    Note that if both <replaceable>fields</replaceable> and
    <replaceable>p</replaceable> are specified, the
    <replaceable>fields</replaceable> must include <literal>SECOND</literal>,
    since the precision applies only to the seconds.
-->
<replaceable>fields</replaceable>および<replaceable>p</replaceable>が共に指定されると、精度は秒のみに適用されるので、<replaceable>fields</replaceable>は<literal>SECOND</literal>を含まなければならないことに注意してください。
   </para>

   <para>
<!--
    The type <type>time with time zone</type> is defined by the SQL
    standard, but the definition exhibits properties which lead to
    questionable usefulness. In most cases, a combination of
    <type>date</type>, <type>time</type>, <type>timestamp without time
    zone</type>, and <type>timestamp with time zone</type> should
    provide a complete range of date/time functionality required by
    any application.
-->
<type>time with time zone</type>は標準SQLで定義されていますが、その定義は、その有用性を疑問視することになりかねない特性を示しています。
ほとんどの場合、<type>date</type>、<type>time</type>、<type>timestamp without time zone</type>、<type>timestamp with time zone</type>の組み合わせで、すべてのアプリケーションで要求される日付/時刻機能すべてを提供しているはずです。
   </para>

   <sect2 id="datatype-datetime-input">
<!--
    <title>Date/Time Input</title>
-->
    <title>日付/時刻の入力</title>

    <para>
<!--
     Date and time input is accepted in almost any reasonable format, including
     ISO 8601, <acronym>SQL</acronym>-compatible,
     traditional <productname>POSTGRES</productname>, and others.
     For some formats, ordering of day, month, and year in date input is
     ambiguous and there is support for specifying the expected
     ordering of these fields.  Set the <xref linkend="guc-datestyle"/> parameter
     to <literal>MDY</literal> to select month-day-year interpretation,
     <literal>DMY</literal> to select day-month-year interpretation, or
     <literal>YMD</literal> to select year-month-day interpretation.
-->
日付と時刻の入力は、ISO 8601、<acronym>SQL</acronym>互換、伝統的な<productname>POSTGRES</productname>、その他を含むほとんどの適正とみなされる書式を受け付けます。
一部の書式では日付の入力における日-月-年の順序が曖昧ですが、これらのフィールドの期待される順序を指定する方式が提供されています。
<xref linkend="guc-datestyle"/>パラメータを<literal>MDY</literal>に設定すれば、月日年という順で解釈され、<literal>DMY</literal>に設定すれば日月年という順で、<literal>YMD</literal>に設定すれば年月日という順で解釈されます。
    </para>

    <para>
<!--
     <productname>PostgreSQL</productname> is more flexible in
     handling date/time input than the
     <acronym>SQL</acronym> standard requires.
     See <xref linkend="datetime-appendix"/>
     for the exact parsing rules of date/time input and for the
     recognized text fields including months, days of the week, and
     time zones.
-->
<productname>PostgreSQL</productname>は日付/時刻入力の取扱いにおいて標準<acronym>SQL</acronym>の要求よりも柔軟です。
日付/時刻の入力における厳密な構文解析規則と、月および週、そして時間帯を含む使用可能なテキストフィールドに関しては<xref linkend="datetime-appendix"/>を参照してください。
    </para>

    <para>
<!--
     Remember that any date or time literal input needs to be enclosed
     in single quotes, like text strings.  Refer to
     <xref linkend="sql-syntax-constants-generic"/> for more
     information.
     <acronym>SQL</acronym> requires the following syntax
-->
日付や時刻リテラルの入力では、テキスト文字列のように、単一引用符で囲む必要があることを思い出してください。
詳細は<xref linkend="sql-syntax-constants-generic"/>を参照してください。
<acronym>SQL</acronym>では下記の構文が要求されます。
<synopsis>
<replaceable>type</replaceable> [ (<replaceable>p</replaceable>) ] '<replaceable>value</replaceable>'
</synopsis>
<!--
     where <replaceable>p</replaceable> is an optional precision
     specification giving the number of
     fractional digits in the seconds field. Precision can be
     specified for <type>time</type>, <type>timestamp</type>, and
     <type>interval</type> types, and can range from 0 to 6.
     If no precision is specified in a constant specification,
     it defaults to the precision of the literal value (but not
     more than 6 digits).
-->
ここで、<replaceable>p</replaceable>は秒フィールドの小数点以下の桁数を与えるオプションの精度の指定です。
精度は<type>time</type>、<type>timestamp</type>および<type>interval</type>型に対して0から6の範囲で設定できます。
値の許容範囲は既に説明しています。
定数指定において精度指定がない場合は、リテラル値の精度がデフォルトとして使われます(ただし、６桁を超えることはありません)。
    </para>

    <sect3 id="datatype-datetime-input-dates">
<!--
    <title>Dates</title>
-->
    <title>日付</title>

    <indexterm>
     <primary>date</primary>
    </indexterm>

    <para>
<!--
     <xref linkend="datatype-datetime-date-table"/> shows some possible
     inputs for the <type>date</type> type.
-->
<xref linkend="datatype-datetime-date-table"/>は<type>date</type>型で入力可能なものの一部を示します。
    </para>

     <table id="datatype-datetime-date-table">
<!--
      <title>Date Input</title>
-->
      <title>日付入力</title>
      <tgroup cols="2">
       <colspec colname="col1" colwidth="1*"/>
       <colspec colname="col2" colwidth="2*"/>
       <thead>
        <row>
<!--
         <entry>Example</entry>
         <entry>Description</entry>
-->
         <entry>例</entry>
         <entry>説明</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry>1999-01-08</entry>
<!--
         <entry>ISO 8601; January 8 in any mode
         (recommended format)</entry>
-->
         <entry>ISO 8601。すべてのモードで1月8日になります（推奨書式）。</entry>
        </row>
        <row>
         <entry>January 8, 1999</entry>
<!--
         <entry>unambiguous in any <varname>datestyle</varname> input mode</entry>
-->
         <entry>すべての<varname>datestyle</varname>入力モードにおいて曖昧さがありません。</entry>
        </row>
        <row>
         <entry>1/8/1999</entry>
<!--
         <entry>January 8 in <literal>MDY</literal> mode;
          August 1 in <literal>DMY</literal> mode</entry>
-->
         <entry><literal>MDY</literal>モードでは1月8日、<literal>DMY</literal>モードでは8月1日。</entry>
        </row>
        <row>
         <entry>1/18/1999</entry>
<!--
         <entry>January 18 in <literal>MDY</literal> mode;
          rejected in other modes</entry>
-->
         <entry><literal>MDY</literal>モードでは1月18日、他のモードでは拒絶されます。</entry>
        </row>
        <row>
         <entry>01/02/03</entry>
<!--
         <entry>January 2, 2003 in <literal>MDY</literal> mode;
          February 1, 2003 in <literal>DMY</literal> mode;
          February 3, 2001 in <literal>YMD</literal> mode
-->
         <entry>
<literal>MDY</literal>モードでは2003年1月2日、<literal>DMY</literal>モードでは2003年2月1日、<literal>YMD</literal>モードでは2001年2月3日。
         </entry>
        </row>
        <row>
         <entry>1999-Jan-08</entry>
<!--
         <entry>January 8 in any mode</entry>
-->
         <entry>すべてのモードで1月8日になります。</entry>
        </row>
        <row>
         <entry>Jan-08-1999</entry>
<!--
         <entry>January 8 in any mode</entry>
-->
         <entry>すべてのモードで1月8日になります。</entry>
        </row>
        <row>
         <entry>08-Jan-1999</entry>
<!--
         <entry>January 8 in any mode</entry>
-->
         <entry>すべてのモードで1月8日になります。</entry>
        </row>
        <row>
         <entry>99-Jan-08</entry>
<!--
         <entry>January 8 in <literal>YMD</literal> mode, else error</entry>
-->
         <entry><literal>YMD</literal>モードで1月8日、他のモードではエラー。</entry>
        </row>
        <row>
         <entry>08-Jan-99</entry>
<!--
         <entry>January 8, except error in <literal>YMD</literal> mode</entry>
-->
         <entry>1月8日。ただし<literal>YMD</literal>モードではエラー。</entry>
        </row>
        <row>
         <entry>Jan-08-99</entry>
<!--
         <entry>January 8, except error in <literal>YMD</literal> mode</entry>
-->
         <entry>1月8日。ただし<literal>YMD</literal>モードではエラー。</entry>
        </row>
        <row>
         <entry>19990108</entry>
<!--
         <entry>ISO 8601; January 8, 1999 in any mode</entry>
-->
         <entry>ISO 8601。すべてのモードで1999年1月8日になります。</entry>
        </row>
        <row>
         <entry>990108</entry>
<!--
         <entry>ISO 8601; January 8, 1999 in any mode</entry>
-->
         <entry>ISO 8601。すべてのモードで1999年1月8日になります。</entry>
        </row>
        <row>
         <entry>1999.008</entry>
<!--
         <entry>year and day of year</entry>
-->
         <entry>年と年間通算日</entry>
        </row>
        <row>
         <entry>J2451187</entry>
<!--
         <entry>Julian date</entry>
-->
         <entry>ユリウス日</entry>
        </row>
        <row>
         <entry>January 8, 99 BC</entry>
<!--
         <entry>year 99 BC</entry>
-->
         <entry>西暦紀元前99年</entry>
        </row>
       </tbody>
      </tgroup>
     </table>
    </sect3>

    <sect3 id="datatype-datetime-input-times">
<!--
     <title>Times</title>
-->
     <title>時刻</title>

     <indexterm>
      <primary>time</primary>
     </indexterm>
     <indexterm>
      <primary>time without time zone</primary>
     </indexterm>
     <indexterm>
      <primary>time with time zone</primary>
     </indexterm>

     <para>
<!--
      The time-of-day types are <type>time [
      (<replaceable>p</replaceable>) ] without time zone</type> and
      <type>time [ (<replaceable>p</replaceable>) ] with time
      zone</type>.  <type>time</type> alone is equivalent to
      <type>time without time zone</type>.
-->
ある一日の時刻を表す型は<type>time [(<replaceable>p</replaceable>) ] without time zone</type>と<type>time [ (<replaceable>p</replaceable>) ] with time zone</type>です。
<type>time</type>単独では<type>time without time zone</type>と同じです。
     </para>

     <para>
<!--
      Valid input for these types consists of a time of day followed
      by an optional time zone. (See <xref
      linkend="datatype-datetime-time-table"/>
      and <xref linkend="datatype-timezone-table"/>.)  If a time zone is
      specified in the input for <type>time without time zone</type>,
      it is silently ignored. You can also specify a date but it will
      be ignored, except when you use a time zone name that involves a
      daylight-savings rule, such as
      <literal>America/New_York</literal>. In this case specifying the date
      is required in order to determine whether standard or daylight-savings
      time applies.  The appropriate time zone offset is recorded in the
      <type>time with time zone</type> value and is output as stored;
      it is not adjusted to the active time zone.
-->
これらの型への有効な入力は、時刻、その後にオプションで時間帯からなります。
（<xref linkend="datatype-datetime-time-table"/>と<xref linkend="datatype-timezone-table"/>を参照してください。）
<type>time without time zone</type>への入力に時間帯が指定された場合、時間帯は警告なく無視されます。
また、日付を指定することもできますが、<literal>America/New_York</literal>のような夏時間規則を含む時間帯名を使用しているのでなければ、それは無視されます。
夏時間規則のある時間帯名の場合は、標準と夏時間のどちらを適用するかを決定できるように、日付の指定が必要です。
適切な時間帯オフセットは<type>time with time zone</type>型の値に記録され格納された通りに出力されます。アクティブなタイムゾーンに調整されることはありません。
     </para>

      <table id="datatype-datetime-time-table">
<!--
       <title>Time Input</title>
-->
       <title>時刻入力</title>
       <tgroup cols="2">
        <colspec colname="col1" colwidth="3*"/>
        <colspec colname="col2" colwidth="2*"/>
        <thead>
         <row>
<!--
          <entry>Example</entry>
          <entry>Description</entry>
-->
          <entry>例</entry>
          <entry>説明</entry>
         </row>
        </thead>
        <tbody>
         <row>
          <entry><literal>04:05:06.789</literal></entry>
          <entry>ISO 8601</entry>
         </row>
         <row>
          <entry><literal>04:05:06</literal></entry>
          <entry>ISO 8601</entry>
         </row>
         <row>
          <entry><literal>04:05</literal></entry>
          <entry>ISO 8601</entry>
         </row>
         <row>
          <entry><literal>040506</literal></entry>
          <entry>ISO 8601</entry>
         </row>
         <row>
          <entry><literal>04:05 AM</literal></entry>
<!--
          <entry>same as 04:05; AM does not affect value</entry>
-->
          <entry>04:05と同じ。AMは値に影響を与えない。</entry>
         </row>
         <row>
          <entry><literal>04:05 PM</literal></entry>
<!--
          <entry>same as 16:05; input hour must be &lt;= 12</entry>
-->
          <entry>16:05と同じ。時の入力は12以下でなければなりません。</entry>
         </row>
         <row>
          <entry><literal>04:05:06.789-8</literal></entry>
<!--
          <entry>ISO 8601, with time zone as UTC offset</entry>
-->
          <entry>ISO 8601, UTC オフセットとしてのタイムゾーン</entry>
         </row>
         <row>
          <entry><literal>04:05:06-08:00</literal></entry>
<!--
          <entry>ISO 8601, with time zone as UTC offset</entry>
-->
          <entry>ISO 8601, UTC オフセットとしてのタイムゾーン</entry>
         </row>
         <row>
          <entry><literal>04:05-08:00</literal></entry>
<!--
          <entry>ISO 8601, with time zone as UTC offset</entry>
-->
          <entry>ISO 8601, UTC オフセットとしてのタイムゾーン</entry>
         </row>
         <row>
          <entry><literal>040506-08</literal></entry>
<!--
          <entry>ISO 8601, with time zone as UTC offset</entry>
-->
          <entry>ISO 8601, UTC オフセットとしてのタイムゾーン</entry>
         </row>
         <row>
          <entry><literal>040506+0730</literal></entry>
<!--
          <entry>ISO 8601, with fractional-hour time zone as UTC offset</entry>
-->
          <entry>ISO 8601, UTC オフセットとしての小数付き時間のタイムゾーン</entry>
         </row>
         <row>
          <entry><literal>040506+07:30:00</literal></entry>
<!--
          <entry>UTC offset specified to seconds (not allowed in ISO 8601)</entry>
-->
          <entry>秒まで指定されたUTCオフセット(ISO 8601では未サポート)</entry>
         </row>
         <row>
          <entry><literal>04:05:06 PST</literal></entry>
<!--
          <entry>time zone specified by abbreviation</entry>
-->
          <entry>省略形による時間帯の指定。</entry>
         </row>
         <row>
          <entry><literal>2003-04-12 04:05:06 America/New_York</literal></entry>
<!--
          <entry>time zone specified by full name</entry>
-->
          <entry>名前による時間帯の指定。</entry>
         </row>
        </tbody>
       </tgroup>
      </table>

      <table tocentry="1" id="datatype-timezone-table">
<!--
       <title>Time Zone Input</title>
-->
       <title>時間帯入力</title>
       <tgroup cols="2">
        <thead>
         <row>
<!--
          <entry>Example</entry>
          <entry>Description</entry>
-->
          <entry>例</entry>
          <entry>説明</entry>
         </row>
        </thead>
        <tbody>
         <row>
          <entry><literal>PST</literal></entry>
<!--
          <entry>Abbreviation (for Pacific Standard Time)</entry>
-->
          <entry>省略形（米国太平洋標準時間）</entry>
         </row>
         <row>
          <entry><literal>America/New_York</literal></entry>
<!--
          <entry>Full time zone name</entry>
-->
          <entry>完全な時間帯名</entry>
         </row>
         <row>
          <entry><literal>PST8PDT</literal></entry>
<!--
          <entry>POSIX-style time zone specification</entry>
-->
          <entry>POSIX書式の時間帯指定</entry>
         </row>
         <row>
          <entry><literal>-8:00:00</literal></entry>
<!--
          <entry>UTC offset for PST</entry>
-->
          <entry>PSTのUTCオフセット</entry>
         </row>
         <row>
          <entry><literal>-8:00</literal></entry>
<!--
          <entry>UTC offset for PST (ISO 8601 extended format)</entry>
-->
          <entry>PSTのUTCオフセット(ISO 8601の拡張フォーマット)</entry>
         </row>
         <row>
          <entry><literal>-800</literal></entry>
<!--
          <entry>UTC offset for PST (ISO 8601 basic format)</entry>
-->
          <entry>PSTのUTCオフセット(ISO 8601の基本フォーマット)</entry>
         </row>
         <row>
          <entry><literal>-8</literal></entry>
<!--
          <entry>UTC offset for PST (ISO 8601 basic format)</entry>
-->
          <entry>PSTのUTCオフセット(ISO 8601の基本フォーマット)</entry>
         </row>
         <row>
          <entry><literal>zulu</literal></entry>
<!--
          <entry>Military abbreviation for UTC</entry>
-->
          <entry>UTC用の軍事用略記</entry>
         </row>
         <row>
          <entry><literal>z</literal></entry>
<!--
          <entry>Short form of <literal>zulu</literal> (also in ISO 8601)</entry>
-->
          <entry><literal>zulu</literal>の略記(また、ISO 8601)</entry>
         </row>
        </tbody>
       </tgroup>
      </table>

     <para>
<!--
     Refer to <xref linkend="datatype-timezones"/> for more information on how
     to specify time zones.
-->
時間帯の指定方法に関する詳細は<xref linkend="datatype-timezones"/>を参照してください。
    </para>
    </sect3>

    <sect3 id="datatype-datetime-input-time-stamps">
<!--
    <title>Time Stamps</title>
-->
    <title>タイムスタンプ</title>

    <indexterm>
     <primary>timestamp</primary>
    </indexterm>

    <indexterm>
     <primary>timestamp with time zone</primary>
    </indexterm>

    <indexterm>
     <primary>timestamp without time zone</primary>
    </indexterm>

     <para>
<!--
      Valid input for the time stamp types consists of the concatenation
      of a date and a time, followed by an optional time zone,
      followed by an optional <literal>AD</literal> or <literal>BC</literal>.
      (Alternatively, <literal>AD</literal>/<literal>BC</literal> can appear
      before the time zone, but this is not the preferred ordering.)
      Thus:
-->
タイムスタンプ型への有効な入力は、日付と時刻を連結し、さらにその後にオプションで時間帯、その後にオプションで<literal>AD</literal>もしくは<literal>BC</literal>からなります。
（他に<literal>AD</literal>/<literal>BC</literal>を時間帯の前に付ける方法もありますが、これは推奨される順序ではありません。）
したがって、

<programlisting>
1999-01-08 04:05:06
</programlisting>
<!--
      and:
-->
と
<programlisting>
1999-01-08 04:05:06 -8:00
</programlisting>

<!--
      are valid values, which follow the <acronym>ISO</acronym> 8601
      standard.  In addition, the common format:
-->
は有効な値で、<acronym>ISO</acronym> 8601に準拠しています。
また、広く使用されている
<programlisting>
January 8 04:05:06 1999 PST
</programlisting>
<!--
      is supported.
-->
という書式もサポートされます。
     </para>

     <para>
<!--
      The <acronym>SQL</acronym> standard differentiates
      <type>timestamp without time zone</type>
      and <type>timestamp with time zone</type> literals by the presence of a
      <quote>+</quote> or <quote>-</quote> symbol and time zone offset after
      the time.  Hence, according to the standard,
-->
標準<acronym>SQL</acronym>では、<type>timestamp without time zone</type>のリテラルと<type>timestamp with time zone</type>のリテラルを、時刻の後の<quote>+</quote>もしくは<quote>-</quote>記号と時間帯補正の有無により区別します。
そのため、標準に従うと、

<programlisting>
TIMESTAMP '2004-10-19 10:23:54'
</programlisting>

<!--
      is a <type>timestamp without time zone</type>, while
-->
は<type>timestamp without time zone</type>に、

<programlisting>
TIMESTAMP '2004-10-19 10:23:54+02'
</programlisting>

<!--
      is a <type>timestamp with time zone</type>.
      <productname>PostgreSQL</productname> never examines the content of a
      literal string before determining its type, and therefore will treat
      both of the above as <type>timestamp without time zone</type>.  To
      ensure that a literal is treated as <type>timestamp with time
      zone</type>, give it the correct explicit type:
-->
は<type>timestamp with time zone</type>になります。
<productname>PostgreSQL</productname>では、その型を決める前に文字列リテラルの内容を検証しません。
そのため上の例はいずれも<type>timestamp without time zone</type>として扱います。
リテラルが確実に<type>timestamp with time zone</type>として扱われるようにするには、例えば、

<programlisting>
TIMESTAMP WITH TIME ZONE '2004-10-19 10:23:54+02'
</programlisting>

<!--
      In a literal that has been determined to be <type>timestamp without time
      zone</type>, <productname>PostgreSQL</productname> will silently ignore
      any time zone indication.
      That is, the resulting value is derived from the date/time
      fields in the input value, and is not adjusted for time zone.
-->
のように正しい明示的な型を指定してください。
<type>timestamp without time zone</type>と決定済みのリテラルでは、<productname>PostgreSQL</productname>は警告なく時間帯情報をすべて無視します。
つまり、結果の値は明示された入力値の日付/時刻フィールドから持ち込まれますが、時間帯の調整はなされません。
     </para>

     <para>
<!--
      For <type>timestamp with time zone</type>, the internally stored
      value is always in UTC (Universal
      Coordinated Time, traditionally known as Greenwich Mean Time,
      <acronym>GMT</acronym>).  An input value that has an explicit
      time zone specified is converted to UTC using the appropriate offset
      for that time zone.  If no time zone is stated in the input string,
      then it is assumed to be in the time zone indicated by the system's
      <xref linkend="guc-timezone"/> parameter, and is converted to UTC using the
      offset for the <varname>timezone</varname> zone.
-->
<type>timestamp with time zone</type>について内部に格納されている値は常にUTCです（協定世界時、歴史的にグリニッジ標準時<acronym>GMT</acronym>として知られています）。
時間帯が明示的に指定された入力値は、その時間帯に適したオフセットを使用してUTCに変換されます。
入力文字列に時間帯が指定されていない場合は、システムの<xref linkend="guc-timezone"/>パラメータに示されている値が時間帯とみなされ、<varname>timezone</varname>時間帯用のオフセットを使用してUTCに変換されます。
     </para>

     <para>
<!--
      When a <type>timestamp with time
      zone</type> value is output, it is always converted from UTC to the
      current <varname>timezone</varname> zone, and displayed as local time in that
      zone.  To see the time in another time zone, either change
      <varname>timezone</varname> or use the <literal>AT TIME ZONE</literal> construct
      (see <xref linkend="functions-datetime-zoneconvert"/>).
-->
<type>timestamp with time zone</type>の値が出力されると、この値はUTCから現行の<varname>timezone</varname>に変換され、その時間帯のローカル時間として表示されます。
他の時間帯での時間を表示するには、<varname>timezone</varname>を変更するか、あるいは<literal>AT TIME ZONE</literal>構文（<xref linkend="functions-datetime-zoneconvert"/> を参照）を使用します。
     </para>

     <para>
<!--
      Conversions between <type>timestamp without time zone</type> and
      <type>timestamp with time zone</type> normally assume that the
      <type>timestamp without time zone</type> value should be taken or given
      as <varname>timezone</varname> local time.  A different time zone can
      be specified for the conversion using <literal>AT TIME ZONE</literal>.
-->
<type>timestamp without time zone</type>と<type>timestamp with time zone</type>の間の変換では、通常<type>timestamp without time zone</type>の値は<varname>timezone</varname>のローカル時間としてみなされる、または、指定されるものと想定されます。
<literal>AT TIME ZONE</literal>を使用する変換では、異なる時間帯を指定できます。
     </para>
    </sect3>

    <sect3 id="datatype-datetime-special-values">
<!--
     <title>Special Values</title>
-->
     <title>特別な値</title>

     <indexterm>
      <primary>time</primary>
      <secondary>constants</secondary>
     </indexterm>
     <indexterm>
      <primary>time</primary>
      <secondary>定数</secondary>
     </indexterm>

     <indexterm>
      <primary>date</primary>
      <secondary>constants</secondary>
     </indexterm>
     <indexterm>
      <primary>date</primary>
      <secondary>定数</secondary>
     </indexterm>

     <para>
<!--
      <productname>PostgreSQL</productname> supports several
      special date/time input values for convenience, as shown in <xref
      linkend="datatype-datetime-special-table"/>.  The values
      <literal>infinity</literal> and <literal>-infinity</literal>
      are specially represented inside the system and will be displayed
      unchanged; but the others are simply notational shorthands
      that will be converted to ordinary date/time values when read.
      (In particular, <literal>now</literal> and related strings are converted
      to a specific time value as soon as they are read.)
      All of these values need to be enclosed in single quotes when used
      as constants in SQL commands.
-->
<productname>PostgreSQL</productname>では利便性のために、<xref linkend="datatype-datetime-special-table"/>に示されているような特別な日付/時刻入力値をサポートしています。
<literal>infinity</literal>と<literal>-infinity</literal>の値は、特別にシステム内部で表現され、変更されずに表示されます。
他のものは、単に簡略化された表記で、読み込まれるときに通常の日付/時刻値に変換されます。
（特に<literal>now</literal>とその関連文字列は読み込まれるとすぐにその時点の値に変換されます。）
これらの値はすべて、SQLコマンドで定数として使う場合は、単一引用符でくくらなければなりません。
     </para>

      <table id="datatype-datetime-special-table">
<!--
       <title>Special Date/Time Inputs</title>
-->
       <title>特別な日付/時刻定数</title>
       <tgroup cols="3">
        <thead>
         <row>
<!--
          <entry>Input String</entry>
          <entry>Valid Types</entry>
          <entry>Description</entry>
-->
          <entry>入力文字列</entry>
          <entry>有効な型</entry>
          <entry>説明</entry>
         </row>
        </thead>
        <tbody>
         <row>
          <entry><literal>epoch</literal></entry>
          <entry><type>date</type>, <type>timestamp</type></entry>
<!--
          <entry>1970-01-01 00:00:00+00 (Unix system time zero)</entry>
-->
          <entry>1970-01-01 00:00:00+00（Unixシステム時間におけるゼロ）</entry>
         </row>
         <row>
          <entry><literal>infinity</literal></entry>
          <entry><type>date</type>, <type>timestamp</type></entry>
<!--
          <entry>later than all other time stamps</entry>
-->
          <entry>他のすべてのタイムスタンプより将来</entry>
         </row>
         <row>
          <entry><literal>-infinity</literal></entry>
          <entry><type>date</type>, <type>timestamp</type></entry>
<!--
          <entry>earlier than all other time stamps</entry>
-->
          <entry>他のすべてのタイムスタンプより過去</entry>
         </row>
         <row>
          <entry><literal>now</literal></entry>
          <entry><type>date</type>, <type>time</type>, <type>timestamp</type></entry>
<!--
          <entry>current transaction's start time</entry>
-->
          <entry>現トランザクションの開始時刻</entry>
         </row>
         <row>
          <entry><literal>today</literal></entry>
          <entry><type>date</type>, <type>timestamp</type></entry>
<!--
          <entry>midnight (<literal>00:00</literal>) today</entry>
-->
          <entry>今日の午前０時</entry>
         </row>
         <row>
          <entry><literal>tomorrow</literal></entry>
          <entry><type>date</type>, <type>timestamp</type></entry>
<!--
          <entry>midnight (<literal>00:00</literal>) tomorrow</entry>
-->
          <entry>明日の午前０時</entry>
         </row>
         <row>
          <entry><literal>yesterday</literal></entry>
          <entry><type>date</type>, <type>timestamp</type></entry>
<!--
          <entry>midnight (<literal>00:00</literal>) yesterday</entry>
-->
          <entry>昨日の午前０時</entry>
         </row>
         <row>
          <entry><literal>allballs</literal></entry>
          <entry><type>time</type></entry>
          <entry>00:00:00.00 UTC</entry>
         </row>
        </tbody>
       </tgroup>
      </table>

     <para>
<!--
      The following <acronym>SQL</acronym>-compatible functions can also
      be used to obtain the current time value for the corresponding data
      type:
      <literal>CURRENT_DATE</literal>, <literal>CURRENT_TIME</literal>,
      <literal>CURRENT_TIMESTAMP</literal>, <literal>LOCALTIME</literal>,
      <literal>LOCALTIMESTAMP</literal>.  (See <xref
      linkend="functions-datetime-current"/>.)  Note that these are
      SQL functions and are <emphasis>not</emphasis> recognized in data input strings.
-->
<acronym>SQL</acronym>互換の関数である、<literal>CURRENT_DATE</literal>、<literal>CURRENT_TIME</literal>、<literal>CURRENT_TIMESTAMP</literal>、<literal>LOCALTIME</literal>、<literal>LOCALTIMESTAMP</literal>も、対応するデータ型の現在の日付または時間の値を取得するために使用できます。
（<xref linkend="functions-datetime-current"/> を参照してください。）
これらはSQL関数であり、データ入力文字列として認識<emphasis>されない</emphasis>ことに注意してください。
     </para>

     <caution>
      <para>
<!--
       While the input strings <literal>now</literal>,
       <literal>today</literal>, <literal>tomorrow</literal>,
       and <literal>yesterday</literal> are fine to use in interactive SQL
       commands, they can have surprising behavior when the command is
       saved to be executed later, for example in prepared statements,
       views, and function definitions.  The string can be converted to a
       specific time value that continues to be used long after it becomes
       stale.  Use one of the SQL functions instead in such contexts.
       For example, <literal>CURRENT_DATE + 1</literal> is safer than
       <literal>'tomorrow'::date</literal>.
-->
入力する文字列として<literal>now</literal>、<literal>today</literal>、<literal>tomorrow</literal>及び<literal>yesterday</literal>はインタラクティブなSQLコマンドの中で利用する時は良いですが、コマンドが保存され後に実行されるような時には驚く挙動になることがあります。例えば、準備された文、ビューや関数の定義です。
文字列は特定の時間の値に変換され、その値が古くなってからもしばらく使い続けられることがあります。
このような状況では、代わりにSQL関数を使用してください。
例えば、<literal>'tomorrow'::date</literal>よりも<literal>CURRENT_DATE + 1</literal>の方が安全です。
      </para>
     </caution>

    </sect3>
   </sect2>

   <sect2 id="datatype-datetime-output">
<!--
    <title>Date/Time Output</title>
-->
    <title>日付/時刻の出力</title>

    <indexterm>
     <primary>date</primary>
     <secondary>output format</secondary>
     <seealso>formatting</seealso>
    </indexterm>
    <indexterm>
     <primary>date</primary>
     <secondary>出力書式</secondary>
     <seealso>書式設定</seealso>
    </indexterm>

    <indexterm>
     <primary>time</primary>
     <secondary>output format</secondary>
     <seealso>formatting</seealso>
    </indexterm>
    <indexterm>
     <primary>time</primary>
     <secondary>出力書式</secondary>
     <seealso>書式設定</seealso>
    </indexterm>

    <para>
<!--
     The output format of the date/time types can be set to one of the four
     styles ISO 8601,
     <acronym>SQL</acronym> (Ingres), traditional <productname>POSTGRES</productname>
     (Unix <application>date</application> format), or
     German.  The default
     is the <acronym>ISO</acronym> format.  (The
     <acronym>SQL</acronym> standard requires the use of the ISO 8601
     format.  The name of the <quote>SQL</quote> output format is a
     historical accident.)  <xref
     linkend="datatype-datetime-output-table"/> shows examples of each
     output style.  The output of the <type>date</type> and
     <type>time</type> types is generally only the date or time part
     in accordance with the given examples.  However, the
     <productname>POSTGRES</productname> style outputs date-only values in
     <acronym>ISO</acronym> format.
-->
日付/時刻型の出力書式は、ISO 8601、<acronym>SQL</acronym>（Ingres）、伝統的な<productname>POSTGRES</productname>（Unix <application>date</application>書式）またはGermanの４つのいずれかに設定できます。
デフォルトは<acronym>ISO</acronym>書式です。
（標準<acronym>SQL</acronym>ではISO 8601書式の使用が定められています。
<quote>SQL</quote>という出力書式名は歴史的な事故です。）
<xref linkend="datatype-datetime-output-table"/>に各出力書式の例を示します。
<type>date</type>と<type>time</type>の書式は、例にあるとおり、それぞれ日付と時刻の部分です。しかし、<productname>POSTGRES</productname>では<acronym>ISO</acronym>書式の日付部分のみを出力します。(YMDやMDYの場合12-17-1997を返し、DMYの場合17-12-1997を返します。)
    <!--
     However以下が原文のみだとわかりにくかったため
     http://www.postgresql.org/message-id/2598E90D3D534989905115C5C1172679@maumau
     より補足を追加
    -->
    </para>

     <table id="datatype-datetime-output-table">
<!--
      <title>Date/Time Output Styles</title>
-->
      <title>日付/時刻の出力形式</title>
      <tgroup cols="3">
       <colspec colname="col1" colwidth="1*"/>
       <colspec colname="col2" colwidth="1*"/>
       <colspec colname="col3" colwidth="2*"/>
       <thead>
        <row>
<!--
         <entry>Style Specification</entry>
         <entry>Description</entry>
         <entry>Example</entry>
-->
         <entry>様式指定</entry>
         <entry>説明</entry>
         <entry>例</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry><literal>ISO</literal></entry>
<!--
         <entry>ISO 8601, SQL standard</entry>
-->
         <entry>ISO 8601, 標準SQL</entry>
         <entry><literal>1997-12-17 07:37:16-08</literal></entry>
        </row>
        <row>
         <entry><literal>SQL</literal></entry>
<!--
         <entry>traditional style</entry>
-->
         <entry>伝統的な様式</entry>
         <entry><literal>12/17/1997 07:37:16.00 PST</literal></entry>
        </row>
        <row>
         <entry><literal>Postgres</literal></entry>
<!--
         <entry>original style</entry>
-->
         <entry>独自の様式</entry>
         <entry><literal>Wed Dec 17 07:37:16 1997 PST</literal></entry>
        </row>
        <row>
         <entry><literal>German</literal></entry>
<!--
         <entry>regional style</entry>
-->
         <entry>地域限定様式</entry>
         <entry><literal>17.12.1997 07:37:16.00 PST</literal></entry>
        </row>
       </tbody>
      </tgroup>
     </table>

    <note>
     <para>
<!--
      ISO 8601 specifies the use of uppercase letter <literal>T</literal> to separate
      the date and time.  <productname>PostgreSQL</productname> accepts that format on
      input, but on output it uses a space rather than <literal>T</literal>, as shown
      above.  This is for readability and for consistency with
      <ulink url="https://datatracker.ietf.org/doc/html/rfc3339">RFC 3339</ulink> as
      well as some other database systems.
-->
ISO 8601の仕様では日付と時刻を区切るために大文字の<literal>T</literal>を使用します。
<productname>PostgreSQL</productname>は入力ではこの書式を受け付けますが、上記のように出力では<literal>T</literal>ではなく空白を使用します。
これは読みやすさのため、そして<ulink url="https://datatracker.ietf.org/doc/html/rfc3339">RFC3339</ulink>や他のデータベースシステムとの整合性を保つためです。
     </para>
    </note>

    <para>
<!--
     In the <acronym>SQL</acronym> and POSTGRES styles, day appears before
     month if DMY field ordering has been specified, otherwise month appears
     before day.
     (See <xref linkend="datatype-datetime-input"/>
     for how this setting also affects interpretation of input values.)
     <xref linkend="datatype-datetime-output2-table"/> shows examples.
-->
<acronym>SQL</acronym>とPOSTGRESでは、DMYフィールド順が指定された場合は月の前に日が現れます。
指定がなければ日の前に月が現れます。
（この設定が入力値の解釈にどう影響を与えるのかについては<xref linkend="datatype-datetime-input"/>を参考にしてください）。
<xref linkend="datatype-datetime-output2-table"/>に例を示します。
    </para>

     <table id="datatype-datetime-output2-table">
<!--
      <title>Date Order Conventions</title>
-->
      <title>日付の順序の慣習</title>
      <tgroup cols="3">
       <colspec colname="col1" colwidth="1*"/>
       <colspec colname="col2" colwidth="1*"/>
       <colspec colname="col3" colwidth="2*"/>
       <thead>
        <row>
<!--
         <entry><varname>datestyle</varname> Setting</entry>
         <entry>Input Ordering</entry>
         <entry>Example Output</entry>
-->
         <entry><varname>datestyle</varname>の設定</entry>
         <entry>入力の順序</entry>
         <entry>出力例</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry><literal>SQL, DMY</literal></entry>
<!--
         <entry><replaceable>day</replaceable>/<replaceable>month</replaceable>/<replaceable>year</replaceable></entry>
-->
         <entry><replaceable>day</replaceable>（日）/<replaceable>month</replaceable>（月）/<replaceable>year</replaceable>（年）</entry>
         <entry><literal>17/12/1997 15:37:16.00 CET</literal></entry>
        </row>
        <row>
         <entry><literal>SQL, MDY</literal></entry>
<!--
         <entry><replaceable>month</replaceable>/<replaceable>day</replaceable>/<replaceable>year</replaceable></entry>
-->
         <entry><replaceable>month</replaceable>（月）/<replaceable>day</replaceable>（日）/<replaceable>year</replaceable>（年）</entry>
         <entry><literal>12/17/1997 07:37:16.00 PST</literal></entry>
        </row>
        <row>
         <entry><literal>Postgres, DMY</literal></entry>
<!--
         <entry><replaceable>day</replaceable>/<replaceable>month</replaceable>/<replaceable>year</replaceable></entry>
-->
         <entry><replaceable>day</replaceable>（日）/<replaceable>month</replaceable>（月）/<replaceable>year</replaceable>（年）</entry>
         <entry><literal>Wed 17 Dec 07:37:16 1997 PST</literal></entry>
        </row>
       </tbody>
      </tgroup>
     </table>

    <para>
<!--
     In the <acronym>ISO</acronym> style, the time zone is always shown as
     a signed numeric offset from UTC, with positive sign used for zones
     east of Greenwich.  The offset will be shown
     as <replaceable>hh</replaceable> (hours only) if it is an integral
     number of hours, else
     as <replaceable>hh</replaceable>:<replaceable>mm</replaceable> if it
     is an integral number of minutes, else as
     <replaceable>hh</replaceable>:<replaceable>mm</replaceable>:<replaceable>ss</replaceable>.
     (The third case is not possible with any modern time zone standard,
     but it can appear when working with timestamps that predate the
     adoption of standardized time zones.)
     In the other date styles, the time zone is shown as an alphabetic
     abbreviation if one is in common use in the current zone.  Otherwise
     it appears as a signed numeric offset in ISO 8601 basic format
     (<replaceable>hh</replaceable> or <replaceable>hhmm</replaceable>).
-->
<acronym>ISO</acronym>形式ではタイムゾーンはUTCからの符号付きの数値で表現され、グリニッジより東の地域では正の符号が使用されます。
オフセットは時間の整数倍であれば<replaceable>hh</replaceable>(時間のみ)、分の整数倍であれば<replaceable>hh</replaceable>:<replaceable>mm</replaceable>、それ以外の場合は、<replaceable>hh</replaceable>:<replaceable>mm</replaceable>:<replaceable>ss</replaceable>で表現されます（三番目のケースは現代のどのタイムゾーンの標準でもありえませんが、タイムゾーンが標準化される前に適用されたタイムスタンプで動いている場合に現れる可能性があります）。
他の日付スタイルでは、現在の地域で一般的に使われている場合、タイムゾーンは省略形で表現されます。
それ以外の場合はISO 8601の基本フォーマット(<replaceable>hh</replaceable>や<replaceable>hhmm</replaceable>)の符号付き数値のオフセットとして表示されます。
    </para>

    <para>
<!--
     The date/time style can be selected by the user using the
     <command>SET datestyle</command> command, the <xref
     linkend="guc-datestyle"/> parameter in the
     <filename>postgresql.conf</filename> configuration file, or the
     <envar>PGDATESTYLE</envar> environment variable on the server or
     client.
-->
ユーザは<command>SET DATESTYLE</command>コマンド、<filename>postgresql.conf</filename>構成ファイルの<xref linkend="guc-datestyle"/>パラメータ、そしてサーバかクライアントの<envar>PGDATESTYLE</envar>環境変数を使用して、日付/時刻の様式を選択することができます。
    </para>

    <para>
<!--
     The formatting function <function>to_char</function>
     (see <xref linkend="functions-formatting"/>) is also available as
     a more flexible way to format date/time output.
-->
日付/時刻出力のより柔軟な書式設定方法として、書式設定関数<function>to_char</function>（<xref linkend="functions-formatting"/>を参照）を使用することもできます。
    </para>
   </sect2>

   <sect2 id="datatype-timezones">
<!--
    <title>Time Zones</title>
-->
    <title>時間帯</title>

    <indexterm zone="datatype-timezones">
     <primary>time zone</primary>
    </indexterm>
    <indexterm zone="datatype-timezones">
     <primary>時間帯</primary>
    </indexterm>

   <para>
<!--
    Time zones, and time-zone conventions, are influenced by
    political decisions, not just earth geometry. Time zones around the
    world became somewhat standardized during the 1900s,
    but continue to be prone to arbitrary changes, particularly with
    respect to daylight-savings rules.
    <productname>PostgreSQL</productname> uses the widely-used
    IANA (Olson) time zone database for information about
    historical time zone rules.  For times in the future, the assumption
    is that the latest known rules for a given time zone will
    continue to be observed indefinitely far into the future.
-->
時間帯および時間帯の取り決めは地球の幾何学的要素のみでなく政治的決定に影響されます。
世界にまたがる時間帯は1900年代に標準化されたようですが、特に夏時間規則の点で、勝手に変更する傾向が続いています。
<productname>PostgreSQL</productname>は歴史的な時間帯ルールについての情報に、広く使われているIANA時間帯データベースを使用します。
将来の時間は、ある与えられた時間帯に対する最新の既知のルールが、将来長きに渡りそのまま遵守が継続されるということを前提としています。
   </para>

    <para>
<!--
     <productname>PostgreSQL</productname> endeavors to be compatible with
     the <acronym>SQL</acronym> standard definitions for typical usage.
     However, the <acronym>SQL</acronym> standard has an odd mix of date and
     time types and capabilities. Two obvious problems are:
-->
<productname>PostgreSQL</productname>は典型的な使用法については標準<acronym>SQL</acronym>への互換性に対し最大限の努力をしています。
しかし、標準<acronym>SQL</acronym>には、日付と時刻のデータ型と機能に関する混乱が見受けられます。
2つの明らかな問題点を以下に示します。

     <itemizedlist>
      <listitem>
       <para>
<!--
        Although the <type>date</type> type
        cannot have an associated time zone, the
        <type>time</type> type can.
        Time zones in the real world have little meaning unless
        associated with a date as well as a time,
        since the offset can vary through the year with daylight-saving
        time boundaries.
-->
<type>date</type>型にはそれに関連する時間帯を持てませんが、<type>time</type>型にはあります。
現実の世界において、時間帯のオフセットが夏時間への切り替えにより年間を通じて変化することから、時刻と同様に日付もそれに結び付けられていないと意味がありません。
       </para>
      </listitem>

      <listitem>
       <para>
<!--
        The default time zone is specified as a constant numeric offset
        from <acronym>UTC</acronym>. It is therefore impossible to adapt to
        daylight-saving time when doing date/time arithmetic across
        <acronym>DST</acronym> boundaries.
-->
デフォルトの時間帯は<acronym>UTC</acronym>からの整数定数オフセットとして指定されています。
したがって<acronym>DST</acronym>（夏時間）への切り替えをまたいで日付/時刻演算を行う場合、夏時間を適用することは不可能です。
       </para>
      </listitem>

     </itemizedlist>
    </para>

    <para>
<!--
     To address these difficulties, we recommend using date/time types
     that contain both date and time when using time zones. We
     do <emphasis>not</emphasis> recommend using the type <type>time with
     time zone</type> (though it is supported by
     <productname>PostgreSQL</productname> for legacy applications and
     for compliance with the <acronym>SQL</acronym> standard).
     <productname>PostgreSQL</productname> assumes
     your local time zone for any type containing only date or time.
-->
このような問題を解決するためには、時間帯を使用する際に日付と時刻の両方を保持できる日付/時刻データ型を使用することを勧めます。
<type>time with time zone</type>型の使用はお勧め<emphasis>しません</emphasis>
（もっとも<productname>PostgreSQL</productname>では、旧式のアプリケーションや、標準<acronym>SQL</acronym>との互換性のために、<type>time with time zone</type>型の使用をサポートしています）。
<productname>PostgreSQL</productname>は、日付または時刻のみを保持するデータ型のすべては使用中の時間帯であると前提しています。
    </para>

    <para>
<!--
     All timezone-aware dates and times are stored internally in
     <acronym>UTC</acronym>.  They are converted to local time
     in the zone specified by the <xref linkend="guc-timezone"/> configuration
     parameter before being displayed to the client.
-->
すべての時間帯付きの日付と時刻は<acronym>UTC</acronym>で内部的に保存されます。
これらはクライアントに表示される前に<xref linkend="guc-timezone"/>設定パラメータで指定された時間帯におけるローカル時間に変換されます。
    </para>

    <para>
<!--
     <productname>PostgreSQL</productname> allows you to specify time zones in
     three different forms:
-->
<productname>PostgreSQL</productname>では、3つの形式で時間帯を指定することができます。
     <itemizedlist>
      <listitem>
       <para>
<!--
        A full time zone name, for example <literal>America/New_York</literal>.
        The recognized time zone names are listed in the
        <literal>pg_timezone_names</literal> view (see <xref
        linkend="view-pg-timezone-names"/>).
        <productname>PostgreSQL</productname> uses the widely-used IANA
        time zone data for this purpose, so the same time zone
        names are also recognized by other software.
-->
<literal>America/New_York</literal>などの完全な時間帯名称。
認識できる時間帯名称は<literal>pg_timezone_names</literal>ビューに列挙されています（<xref linkend="view-pg-timezone-names"/>を参照してください）。
<productname>PostgreSQL</productname>はこの目的のためによく使用されているIANA時間帯データを使用します。
したがって、他のソフトウェアでも同じ名前が認識されます。
       </para>
      </listitem>
      <listitem>
       <para>
<!--
        A time zone abbreviation, for example <literal>PST</literal>.  Such a
        specification merely defines a particular offset from UTC, in
        contrast to full time zone names which can imply a set of daylight
        savings transition rules as well.  The recognized abbreviations
        are listed in the <literal>pg_timezone_abbrevs</literal> view (see <xref
        linkend="view-pg-timezone-abbrevs"/>).  You cannot set the
        configuration parameters <xref linkend="guc-timezone"/> or
        <xref linkend="guc-log-timezone"/> to a time
        zone abbreviation, but you can use abbreviations in
        date/time input values and with the <literal>AT TIME ZONE</literal>
        operator.
-->
<literal>PST</literal>などの時間帯省略形。
こうした指定は、単に特定のUTCからのオフセットを定義します。
一方、完全な時間帯名称では夏時間遷移規則群も組み込まれます。
認識可能な省略形は<literal>pg_timezone_abbrevs</literal>ビューに列挙されています（<xref linkend="view-pg-timezone-abbrevs"/>を参照してください）。
<xref linkend="guc-timezone"/>設定パラメータおよび<xref linkend="guc-log-timezone"/>設定パラメータを時間帯省略形に設定することはできませんが、日付時刻型の入力値や<literal>AT TIME ZONE</literal>演算子に省略形を使用することができます。
       </para>
      </listitem>
      <listitem>
       <para>
<!--
        In addition to the timezone names and abbreviations,
        <productname>PostgreSQL</productname> will accept POSIX-style time zone
        specifications, as described in
        <xref linkend="datetime-posix-timezone-specs"/>.  This option is not
        normally preferable to using a named time zone, but it may be
        necessary if no suitable IANA time zone entry is available.
-->
時間帯名やその省略形に加え、<productname>PostgreSQL</productname>は、<xref linkend="datetime-posix-timezone-specs"/>に記載されているPOSIX様式の時間帯指定を受付けます。
このオプションは通常、名前付きのタイムゾーンを使用するよりも好ましくありませんが、適切なIANAタイムゾーンのエントリが利用できない場合は必要になるかもしれません。
       </para>
      </listitem>
     </itemizedlist>

<!--
     In short, this is the difference between abbreviations
     and full names: abbreviations represent a specific offset from UTC,
     whereas many of the full names imply a local daylight-savings time
     rule, and so have two possible UTC offsets.  As an example,
     <literal>2014-06-04 12:00 America/New_York</literal> represents noon local
     time in New York, which for this particular date was Eastern Daylight
     Time (UTC-4).  So <literal>2014-06-04 12:00 EDT</literal> specifies that
     same time instant.  But <literal>2014-06-04 12:00 EST</literal> specifies
     noon Eastern Standard Time (UTC-5), regardless of whether daylight
     savings was nominally in effect on that date.
-->
一言で言うと、これは省略形と正式名称との差異です。
省略形はUTCから固定したオフセットを表わすのに対して、多くの正式名称はローカルの夏時間規定を暗示するので、2つのUTCオフセットがあるかもしれません。
例えば<literal>2014-06-04 12:00 America/New_York</literal>はニューヨークの正午を示しますが、これはこの日について言えば東部夏時間(UTC-4)です。
つまり<literal>2014-06-04 12:00 EDT</literal>はこれと同時刻を示します。
しかし、<literal>2014-06-04 12:00 EST</literal>は、その日に夏時間が使用されていたかどうかに関わらず、東部標準時間(UTC-5)での正午を示します。
    </para>

    <para>
<!--
     To complicate matters, some jurisdictions have used the same timezone
     abbreviation to mean different UTC offsets at different times; for
     example, in Moscow <literal>MSK</literal> has meant UTC+3 in some years and
     UTC+4 in others.  <productname>PostgreSQL</productname> interprets such
     abbreviations according to whatever they meant (or had most recently
     meant) on the specified date; but, as with the <literal>EST</literal> example
     above, this is not necessarily the same as local civil time on that date.
-->
問題を更に複雑にしているのは、一部の管轄は同じ略号を使って、年によって異なるUTCオフセットを表していることです。
例えばモスクワでは<literal>MSK</literal>はある年ではUTC+3を意味しますが、別の年ではUTC+4を意味します。
<productname>PostgreSQL</productname>ではそのような略号について、指定の日に何を意味していたか（あるいは最も最近にどういう意味だったか）に従って解釈します。
しかし、<literal>EST</literal>の例にあるように、必ずしもその日付における地方常用時を示しているとは限りません。
    </para>

    <para>
<!--
     In all cases, timezone names and abbreviations are recognized
     case-insensitively.  (This is a change from <productname>PostgreSQL</productname>
     versions prior to 8.2, which were case-sensitive in some contexts but
     not others.)
-->
すべての場合において、時間帯名や略号は大文字小文字の区別なく認識されます。
（これは<productname>PostgreSQL</productname>の8.2より前のバージョンからの変更です。
以前は、文脈によって大文字小文字が区別される場合と、されない場合がありました。）
    </para>

    <para>
<!--
     Neither timezone names nor abbreviations are hard-wired into the server;
     they are obtained from configuration files stored under
     <filename>.../share/timezone/</filename> and <filename>.../share/timezonesets/</filename>
     of the installation directory
     (see <xref linkend="datetime-config-files"/>).
-->
時間帯名、省略形のどちらもサーバ内に組み込まれるわけではありません。
インストールディレクトリの<filename>.../share/timezone/</filename>および<filename>.../share/timezonesets/</filename>の下に保存される構成ファイルから取得されます（<xref linkend="datetime-config-files"/>を参照ください）。
    </para>

    <para>
<!--
     The <xref linkend="guc-timezone"/> configuration parameter can
     be set in the file <filename>postgresql.conf</filename>, or in any of the
     other standard ways described in <xref linkend="runtime-config"/>.
     There are also some special ways to set it:
-->
<xref linkend="guc-timezone"/>は<filename>postgresql.conf</filename>ファイルや<xref linkend="runtime-config"/>で説明する他の標準的な方法で設定することができます。
以下に、いくつか特別な設定方法を示します。

     <itemizedlist>
      <listitem>
       <para>
<!--
        The <acronym>SQL</acronym> command <command>SET TIME ZONE</command>
        sets the time zone for the session.  This is an alternative spelling
        of <command>SET TIMEZONE TO</command> with a more SQL-spec-compatible syntax.
-->
<acronym>SQL</acronym>コマンド<command>SET TIME ZONE</command>はセッションの時間帯を設定します。
これは<command>SET TIMEZONE TO</command>の別名ですが、SQL仕様の構文へのより高い互換性があります。
       </para>
      </listitem>

      <listitem>
       <para>
<!--
        The <envar>PGTZ</envar> environment variable is used by
        <application>libpq</application> clients
        to send a <command>SET TIME ZONE</command>
        command to the server upon connection.
-->
<envar>PGTZ</envar>環境変数は、<application>libpq</application>クライアントが接続時にサーバに<command>SET TIME ZONE</command>コマンドを送信するために用いられます。
       </para>
      </listitem>
     </itemizedlist>
    </para>
   </sect2>

   <sect2 id="datatype-interval-input">
<!--
    <title>Interval Input</title>
-->
    <title>時間間隔の入力</title>

    <indexterm>
     <primary>interval</primary>
    </indexterm>
    <indexterm>
     <primary>時間間隔</primary>
    </indexterm>

     <para>
<!--
      <type>interval</type> values can be written using the following
      verbose syntax:
-->
<type>interval</type>値は以下の冗長な構文を使って記述されます。

<synopsis>
<optional>@</optional> <replaceable>quantity</replaceable> <replaceable>unit</replaceable> <optional><replaceable>quantity</replaceable> <replaceable>unit</replaceable>...</optional> <optional><replaceable>direction</replaceable></optional>
</synopsis>

<!--
     where <replaceable>quantity</replaceable> is a number (possibly signed);
     <replaceable>unit</replaceable> is <literal>microsecond</literal>,
     <literal>millisecond</literal>, <literal>second</literal>,
     <literal>minute</literal>, <literal>hour</literal>, <literal>day</literal>,
     <literal>week</literal>, <literal>month</literal>, <literal>year</literal>,
     <literal>decade</literal>, <literal>century</literal>, <literal>millennium</literal>,
     or abbreviations or plurals of these units;
     <replaceable>direction</replaceable> can be <literal>ago</literal> or
     empty.  The at sign (<literal>@</literal>) is optional noise.  The amounts
     of the different units are implicitly added with appropriate
     sign accounting.  <literal>ago</literal> negates all the fields.
     This syntax is also used for interval output, if
     <xref linkend="guc-intervalstyle"/> is set to
     <literal>postgres_verbose</literal>.
-->
ここで、<replaceable>quantity</replaceable>は（符号付き）時間量、<replaceable>unit</replaceable>（単位）は<literal>microsecond</literal>、<literal>millisecond</literal>、<literal>second</literal>（秒）、<literal>minute</literal>（分）、<literal>hour</literal>（時）、<literal>day</literal>（日）、<literal>week</literal>（週）、<literal>month</literal>（月）、<literal>year</literal>（年）、<literal>decade</literal>（10年単位）、<literal>century</literal>（100年単位）、<literal>millennium</literal>（1000年単位）あるいはこれらの単位の簡略形または複数形です。
<replaceable>direction</replaceable>（方向）は<literal>ago</literal>もしくは空です。
アットマーク（<literal>@</literal>）はオプションで、付けても付けなくても構いません。
異なる単位における時間量は適切に符号を考慮して暗黙的に足されます。
<literal>ago</literal>はすべてのフィールドの正負を逆にします。
この構文はまた、<xref linkend="guc-intervalstyle"/>が<literal>postgres_verbose</literal>に設定されている場合に時間間隔の出力でも使用されます。
    </para>

    <para>
<!--
     Quantities of days, hours, minutes, and seconds can be specified without
     explicit unit markings.  For example, <literal>'1 12:59:10'</literal> is read
     the same as <literal>'1 day 12 hours 59 min 10 sec'</literal>.  Also,
     a combination of years and months can be specified with a dash;
     for example <literal>'200-10'</literal> is read the same as <literal>'200 years
     10 months'</literal>.  (These shorter forms are in fact the only ones allowed
     by the <acronym>SQL</acronym> standard, and are used for output when
     <varname>IntervalStyle</varname> is set to <literal>sql_standard</literal>.)
-->
日、時、分、および秒の時間量は明示的に単位を指定しなくても構いません。
例えば、<literal>'1 12:59:10'</literal>は<literal>'1 day 12 hours 59 min 10 sec'</literal>（1日と12時間59分10秒）と解釈されます。
また年と月の組み合わせはダッシュを使って指定することができます。
例えば、<literal>'200-10'</literal>は<literal>'200 years 10 months'</literal>（200年と10か月）と解釈されます。
（実際のところ、標準<acronym>SQL</acronym>で許されている簡略形はこれらだけです。
そして<varname>IntervalStyle</varname>が<literal>sql_standard</literal>に設定されている場合には、これらが出力で使用されます。）
    </para>

    <para>
<!--
     Interval values can also be written as ISO 8601 time intervals, using
     either the <quote>format with designators</quote> of the standard's section
     4.4.3.2 or the <quote>alternative format</quote> of section 4.4.3.3.  The
     format with designators looks like this:
-->
標準の4.4.3.2節の<quote>指定文字付書式</quote>または4.4.3.3節の<quote>代替書式</quote>のどちらかを使用して、時間間隔値はISO 8601時間間隔として書くこともできます。
指定文字付の書式は以下のようなものです。
<synopsis>
P <replaceable>quantity</replaceable> <replaceable>unit</replaceable> <optional> <replaceable>quantity</replaceable> <replaceable>unit</replaceable> ...</optional> <optional> T <optional> <replaceable>quantity</replaceable> <replaceable>unit</replaceable> ...</optional></optional>
</synopsis>
<!--
      The string must start with a <literal>P</literal>, and may include a
      <literal>T</literal> that introduces the time-of-day units.  The
      available unit abbreviations are given in <xref
      linkend="datatype-interval-iso8601-units"/>.  Units may be
      omitted, and may be specified in any order, but units smaller than
      a day must appear after <literal>T</literal>.  In particular, the meaning of
      <literal>M</literal> depends on whether it is before or after
      <literal>T</literal>.
-->
文字列は<literal>P</literal>で始まらなければならず、また、日と時間を区切る<literal>T</literal>を含めることができます。
利用可能な単位の省略形を<xref linkend="datatype-interval-iso8601-units"/>に示します。
単位は省略しても構いませんし、任意の順番で指定できますが、1日より小さな単位は<literal>T</literal>の後に書かなければなりません。
特に<literal>M</literal>の意味は<literal>T</literal>の前にあるか後にあるかに依存します。
     </para>

     <table id="datatype-interval-iso8601-units">
<!--
      <title>ISO 8601 Interval Unit Abbreviations</title>
-->
      <title>ISO 8601における時間間隔単位の省略形</title>
     <tgroup cols="2">
       <thead>
        <row>
<!--
         <entry>Abbreviation</entry>
         <entry>Meaning</entry>
-->
         <entry>省略形</entry>
         <entry>意味</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry>Y</entry>
<!--
         <entry>Years</entry>
-->
         <entry>年</entry>
        </row>
        <row>
         <entry>M</entry>
<!--
         <entry>Months (in the date part)</entry>
-->
         <entry>月（日付部分における）</entry>
        </row>
        <row>
         <entry>W</entry>
<!--
         <entry>Weeks</entry>
-->
         <entry>週</entry>
        </row>
        <row>
         <entry>D</entry>
<!--
         <entry>Days</entry>
-->
         <entry>日</entry>
        </row>
        <row>
         <entry>H</entry>
<!--
         <entry>Hours</entry>
-->
         <entry>時間</entry>
        </row>
        <row>
         <entry>M</entry>
<!--
         <entry>Minutes (in the time part)</entry>
-->
         <entry>分（時刻部分における）</entry>
        </row>
        <row>
         <entry>S</entry>
<!--
         <entry>Seconds</entry>
-->
         <entry>秒</entry>
        </row>
       </tbody>
      </tgroup>
     </table>

     <para>
<!--
      In the alternative format:
-->
別の書式を示します。
<synopsis>
P <optional> <replaceable>years</replaceable>-<replaceable>months</replaceable>-<replaceable>days</replaceable> </optional> <optional> T <replaceable>hours</replaceable>:<replaceable>minutes</replaceable>:<replaceable>seconds</replaceable> </optional>
</synopsis>
<!--
      the string must begin with <literal>P</literal>, and a
      <literal>T</literal> separates the date and time parts of the interval.
      The values are given as numbers similar to ISO 8601 dates.
-->
上の代替書式では、文字列は<literal>P</literal>から始まらなければなりません。
そして、<literal>T</literal>は時間間隔の日付部分と時刻部分とを分割します。
値はISO 8601日付と同様の数字で指定されます。
    </para>

    <para>
<!--
     When writing an interval constant with a <replaceable>fields</replaceable>
     specification, or when assigning a string to an interval column that was
     defined with a <replaceable>fields</replaceable> specification, the interpretation of
     unmarked quantities depends on the <replaceable>fields</replaceable>.  For
     example <literal>INTERVAL '1' YEAR</literal> is read as 1 year, whereas
     <literal>INTERVAL '1'</literal> means 1 second.  Also, field values
     <quote>to the right</quote> of the least significant field allowed by the
     <replaceable>fields</replaceable> specification are silently discarded.  For
     example, writing <literal>INTERVAL '1 day 2:03:04' HOUR TO MINUTE</literal>
     results in dropping the seconds field, but not the day field.
-->
<replaceable>fields</replaceable>指定を使って時間間隔定数を記述する場合、または、<replaceable>fields</replaceable>仕様で定義された時間間隔列に文字列を割り当てる場合、マークされていない時間量の解釈は<replaceable>fields</replaceable>に依存します。
例えば<literal>INTERVAL '1' YEAR</literal>は1年と解釈され、一方で<literal>INTERVAL '1'</literal>は1秒と解釈されます。
同時に、<replaceable>fields</replaceable>仕様によって許可される最下位フィールドの<quote>右側の</quote>フィールド値は警告なしに破棄されます。
例えば、<literal>INTERVAL '1 day 2:03:04' HOUR TO MINUTE</literal>と書くことで、二番目のフィールドは削除されますが、日付フィールドは削除されません。
    </para>

    <para>
<!--
     According to the <acronym>SQL</acronym> standard all fields of an interval
     value must have the same sign, so a leading negative sign applies to all
     fields; for example the negative sign in the interval literal
     <literal>'-1 2:03:04'</literal> applies to both the days and hour/minute/second
     parts.  <productname>PostgreSQL</productname> allows the fields to have different
     signs, and traditionally treats each field in the textual representation
     as independently signed, so that the hour/minute/second part is
     considered positive in this example.  If <varname>IntervalStyle</varname> is
     set to <literal>sql_standard</literal> then a leading sign is considered
     to apply to all fields (but only if no additional signs appear).
     Otherwise the traditional <productname>PostgreSQL</productname> interpretation is
     used.  To avoid ambiguity, it's recommended to attach an explicit sign
     to each field if any field is negative.
-->
標準<acronym>SQL</acronym>に従うと、時間間隔値のフィールドはすべて同じ符号を持たなければなりません。
このため、先頭の負の符号はすべてのフィールドに適用されます。
例えば時間間隔リテラル<literal>'-1 2:03:04'</literal>の負の符号は、日付部分にも時、分、秒部分にも適用されます。
<productname>PostgreSQL</productname>ではフィールドに異なる符号を持たせることができます。
また伝統的にテキスト形式表現における各フィールドは独立した符号を持つものとして扱われます。
このため、この例では時、分、秒部分は正であるとみなされます。
<varname>IntervalStyle</varname>が<literal>sql_standard</literal>に設定されている場合、先頭の符号はすべてのフィールドに適用されるものとみなされます（ただし他に符号がない場合のみです）。
さもなくば、伝統的な<productname>PostgreSQL</productname>の解釈が使用されます。
あいまいさを防ぐために、負のフィールドがある場合には個別に明示的な符号を付けることを勧めます。
    </para>

    <para>
<!--
     Internally, <type>interval</type> values are stored as three integral
     fields: months, days, and microseconds.  These fields are kept
     separate because the number of days in a month varies, while a day
     can have 23 or 25 hours if a daylight savings time transition is
     involved.  An interval input string that uses other units is
     normalized into this format, and then reconstructed in a standardized
     way for output, for example:
-->
内部的には、<type>interval</type>値は3つの整数フィールドとして格納されます。
月、日、マイクロ秒です。
月の日数は変化したり、 夏時間の移行が含まれる場合は1日が23時間または25時間になったりするため、これらのフィールドは分けて保持されます。
他の単位を使用する時間間隔の入力文字列は、このフォーマットに正規化され、出力用に標準化された方法で再再構成されます。例えば以下のとおりです。

<programlisting>
SELECT '2 years 15 months 100 weeks 99 hours 123456789 milliseconds'::interval;
               interval
---------------------------------------
 3 years 3 mons 700 days 133:17:36.789
</programlisting>

<!--
     Here weeks, which are understood as <quote>7 days</quote>, have been
     kept separate, while the smaller and larger time units were
     combined and normalized.
-->
ここでは、週は<quote>7日</quote>と理解され、別々に保持されていますが、小さな時間単位と大きな時間単位は結合され、正規化されています。
    </para>

    <para>
<!--
     Input field values can have fractional parts, for example <literal>'1.5
     weeks'</literal> or <literal>'01:02:03.45'</literal>.  However,
     because <type>interval</type> internally stores only integral fields,
     fractional values must be converted into smaller
     units.  Fractional parts of units greater than months are rounded to
     be an integer number of months, e.g. <literal>'1.5 years'</literal>
     becomes <literal>'1 year 6 mons'</literal>.  Fractional parts of
     weeks and days are computed to be an integer number of days and
     microseconds, assuming 30 days per month and 24 hours per day, e.g.,
     <literal>'1.75 months'</literal> becomes <literal>1 mon 22 days
     12:00:00</literal>.  Only seconds will ever be shown as fractional
     on output.
-->
入力フィールドの値には小数部分が含まれる場合があります。例えば、<literal>'1.5 weeks'</literal>や<literal>'01:02:03.45'</literal>などです。
しかし、<type>interval</type>は内部的に整数フィールドでのみ格納されるため、小数の位はより小さな単位に変換する必要があります。
月より大きな小数部分の位は月の整数に丸められます。例えば、<literal>'1.5 years'</literal>は<literal>'1 year 6 mons'</literal>になります。
週と日の小数部分は、1ヶ月は30日、1日は24時間と想定して整数の日数やマイクロ秒として計算されます。例えば<literal>'1.75 months'</literal>は<literal>1 mon 22 days 12:00:00</literal>になります。
出力では秒だけが小数として表示されます。
    </para>

    <para>
<!--
     <xref linkend="datatype-interval-input-examples"/> shows some examples
     of valid <type>interval</type> input.
-->
<xref linkend="datatype-interval-input-examples"/>は有効な<type>interval</type>入力のいくつかの例を示しています。
    </para>

     <table id="datatype-interval-input-examples">
<!--
      <title>Interval Input</title>
-->
      <title>時間間隔入力</title>
      <tgroup cols="2">
       <thead>
        <row>
<!--
         <entry>Example</entry>
         <entry>Description</entry>
-->
         <entry>例</entry>
         <entry>説明</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry><literal>1-2</literal></entry>
<!--
         <entry>SQL standard format: 1 year 2 months</entry>
-->
         <entry>標準SQL書式。1年2ヶ月</entry>
        </row>
        <row>
         <entry><literal>3 4:05:06</literal></entry>
<!--
         <entry>SQL standard format: 3 days 4 hours 5 minutes 6 seconds</entry>
-->
         <entry>標準SQL書式。3日4時間5分6秒</entry>
        </row>
        <row>
         <entry><literal>1 year 2 months 3 days 4 hours 5 minutes 6 seconds</literal></entry>
<!--
         <entry>Traditional Postgres format: 1 year 2 months 3 days 4 hours 5 minutes 6 seconds</entry>
-->
         <entry>伝統的Postgres書式。1年2月3日4時間5分6秒</entry>
        </row>
        <row>
         <entry><literal>P1Y2M3DT4H5M6S</literal></entry>
<!--
         <entry>ISO 8601 <quote>format with designators</quote>: same meaning as above</entry>
-->
         <entry>ISO 8601 <quote>指定文字付き書式</quote>。意味は上と同じ</entry>
        </row>
        <row>
         <entry><literal>P0001-02-03T04:05:06</literal></entry>
<!--
         <entry>ISO 8601 <quote>alternative format</quote>: same meaning as above</entry>
-->
         <entry>ISO 8601 <quote>代替書式</quote>。意味は上と同じ</entry>
        </row>
       </tbody>
      </tgroup>
     </table>

   </sect2>

   <sect2 id="datatype-interval-output">
<!--
    <title>Interval Output</title>
-->
    <title>時間間隔の出力</title>

    <indexterm>
     <primary>interval</primary>
     <secondary>output format</secondary>
     <seealso>formatting</seealso>
    </indexterm>
    <indexterm>
     <primary>時間間隔</primary>
     <secondary>出力書式</secondary>
     <seealso>書式設定</seealso>
    </indexterm>

    <para>
<!--
     As previously explained, <productname>PostgreSQL</productname>
     stores <type>interval</type> values as months, days, and
     microseconds.  For output, the months field is converted to years and
     months by dividing by 12.  The days field is shown as-is.  The
     microseconds field is converted to hours, minutes, seconds, and
     fractional seconds.  Thus months, minutes, and seconds will never be
     shown as exceeding the ranges 0&ndash;11, 0&ndash;59, and 0&ndash;59
     respectively, while the displayed years, days, and hours fields can
     be quite large.  (The <link
     linkend="function-justify-days"><function>justify_days</function></link>
     and <link
     linkend="function-justify-hours"><function>justify_hours</function></link>
     functions can be used if it is desirable to transpose large days or
     hours values into the next higher field.)
-->
前述のように、<productname>PostgreSQL</productname>は<type>interval</type>値を月、日、マイクロ秒として格納します。
出力の場合、monthsフィールドは12で除算して年と月に変換されます。
daysフィールドはそのまま表示されます。
microseconds フィールドは、時間、分、秒、および小数の秒に変換されます。
したがって、月、分、秒はそれぞれ0~11、0~59、0~59の範囲を超えることはありませんが、表示される年、日、時間のフィールドは非常に大きくなる可能性があります。
（大きな日数または時間の値を次に高いフィールドに移すことが望ましい場合は、<link linkend="function-justify-days"><function>justify_days</function></link>および<link linkend="function-justify-hours"><function>justify_hours</function></link>関数を使用できます）。
    </para>

    <para>
<!--
     The output format of the interval type can be set to one of the
     four styles <literal>sql_standard</literal>, <literal>postgres</literal>,
     <literal>postgres_verbose</literal>, or <literal>iso_8601</literal>,
     using the command <literal>SET intervalstyle</literal>.
     The default is the <literal>postgres</literal> format.
     <xref linkend="interval-style-output-table"/> shows examples of each
     output style.
-->
時間間隔型の出力書式は、<literal>SET intervalstyle</literal>コマンドを使用して、<literal>sql_standard</literal>、<literal>postgres</literal>、<literal>postgres_verbose</literal>または<literal>iso_8601</literal>の４つのうちの１つを設定できます。
デフォルトは<literal>postgres</literal>書式です。
<xref linkend="interval-style-output-table"/>はそれぞれの出力形式を示した例です。
    </para>

    <para>
<!--
     The <literal>sql_standard</literal> style produces output that conforms to
     the SQL standard's specification for interval literal strings, if
     the interval value meets the standard's restrictions (either year-month
     only or day-time only, with no mixing of positive
     and negative components).  Otherwise the output looks like a standard
     year-month literal string followed by a day-time literal string,
     with explicit signs added to disambiguate mixed-sign intervals.
-->
<literal>sql_standard</literal>形式は、時間間隔値が標準制約（構成要素に正負が混在していない年数と月数のみ、または日数と時間のみ）を満足する場合、時間間隔リテラル文字列に対し標準SQLに準拠する出力を作成します。
それ以外の場合、出力は、標準的な年数-月数のリテラル文字列の後に日数-時間のリテラル文字列が続いたものになり、正負混在した時間間隔のあいまいさを無くすために明示的な符号が付加されます。
    </para>

    <para>
<!--
     The output of the <literal>postgres</literal> style matches the output of
     <productname>PostgreSQL</productname> releases prior to 8.4 when the
     <xref linkend="guc-datestyle"/> parameter was set to <literal>ISO</literal>.
-->
<literal>postgres</literal>書式の出力は、<xref linkend="guc-datestyle"/>パラメータが<literal>ISO</literal>に設定されたとき、<productname>PostgreSQL</productname> 8.4より前のリリースと一致します。
    </para>

    <para>
<!--
     The output of the <literal>postgres_verbose</literal> style matches the output of
     <productname>PostgreSQL</productname> releases prior to 8.4 when the
     <varname>DateStyle</varname> parameter was set to non-<literal>ISO</literal> output.
-->
<literal>postgres_verbose</literal>書式の出力は、<varname>DateStyle</varname>パラメータが<literal>ISO</literal>以外に設定されたとき、<productname>PostgreSQL</productname> 8.4より前のリリースと一致します。
    </para>

    <para>
<!--
     The output of the <literal>iso_8601</literal> style matches the <quote>format
     with designators</quote> described in section 4.4.3.2 of the
     ISO 8601 standard.
-->
<literal>iso_8601</literal>書式の出力はISO 8601 標準の4.4.3.2節に記述の<quote>format with designators（指名付き書式）</quote>に一致します。
    </para>

     <table id="interval-style-output-table">
<!--
       <title>Interval Output Style Examples</title>
-->
       <title>時間間隔出力形式の例</title>
       <tgroup cols="4">
        <thead>
         <row>
<!--
          <entry>Style Specification</entry>
          <entry>Year-Month Interval</entry>
          <entry>Day-Time Interval</entry>
          <entry>Mixed Interval</entry>
-->
          <entry>形式指定</entry>
          <entry>年-月時間間隔</entry>
          <entry>日-時刻時間間隔</entry>
          <entry>混在した時間間隔</entry>
         </row>
        </thead>
        <tbody>
         <row>
          <entry><literal>sql_standard</literal></entry>
          <entry>1-2</entry>
          <entry>3 4:05:06</entry>
          <entry>-1-2 +3 -4:05:06</entry>
         </row>
         <row>
          <entry><literal>postgres</literal></entry>
          <entry>1 year 2 mons</entry>
          <entry>3 days 04:05:06</entry>
          <entry>-1 year -2 mons +3 days -04:05:06</entry>
         </row>
         <row>
          <entry><literal>postgres_verbose</literal></entry>
          <entry>@ 1 year 2 mons</entry>
          <entry>@ 3 days 4 hours 5 mins 6 secs</entry>
          <entry>@ 1 year 2 mons -3 days 4 hours 5 mins 6 secs ago</entry>
         </row>
         <row>
          <entry><literal>iso_8601</literal></entry>
          <entry>P1Y2M</entry>
          <entry>P3DT4H5M6S</entry>
          <entry>P-1Y-2M3D&zwsp;T-4H-5M-6S</entry>
         </row>
        </tbody>
       </tgroup>
    </table>

   </sect2>

  </sect1>

  <sect1 id="datatype-boolean">
<!--
   <title>Boolean Type</title>
-->
   <title>論理値データ型</title>

   <indexterm zone="datatype-boolean">
    <primary>Boolean</primary>
    <secondary>data type</secondary>
   </indexterm>
   <indexterm zone="datatype-boolean">
    <primary>Boolean</primary>
    <secondary>データ型</secondary>
   </indexterm>

   <indexterm zone="datatype-boolean">
    <primary>true</primary>
   </indexterm>
   <indexterm zone="datatype-boolean">
    <primary>真</primary>
   </indexterm>

   <indexterm zone="datatype-boolean">
    <primary>false</primary>
   </indexterm>
   <indexterm zone="datatype-boolean">
    <primary>偽</primary>
   </indexterm>

   <para>
<!--
    <productname>PostgreSQL</productname> provides the
    standard <acronym>SQL</acronym> type <type>boolean</type>;
    see <xref linkend="datatype-boolean-table"/>.
    The <type>boolean</type> type can have several states:
    <quote>true</quote>, <quote>false</quote>, and a third state,
    <quote>unknown</quote>, which is represented by the
    <acronym>SQL</acronym> null value.
-->
<productname>PostgreSQL</productname>では、標準<acronym>SQL</acronym>の<type>boolean</type>型が提供されています。
<xref linkend="datatype-boolean-table"/>を参照してください。
<type>boolean</type>型はいくつかの状態を取ることができます。
<quote>真</quote>もしくは<quote>偽</quote>、そして第3の状態は<acronym>SQL</acronym>ではNULL値で表現される<quote>不明</quote>の状態です。
   </para>

   <table id="datatype-boolean-table">
<!--
    <title>Boolean Data Type</title>
-->
    <title>論理値データ型</title>
    <tgroup cols="3">
     <thead>
      <row>
<!--
       <entry>Name</entry>
       <entry>Storage Size</entry>
       <entry>Description</entry>
-->
       <entry>名前</entry>
       <entry>格納サイズ</entry>
       <entry>説明</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><type>boolean</type></entry>
<!--
       <entry>1 byte</entry>
       <entry>state of true or false</entry>
-->
       <entry>1バイト</entry>
       <entry>真または偽の状態</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
<!--
    Boolean constants can be represented in SQL queries by the SQL
    key words <literal>TRUE</literal>, <literal>FALSE</literal>,
    and <literal>NULL</literal>.
-->
論理定数はSQL問い合わせの中で、SQLキーワードの<literal>TRUE</literal>、<literal>FALSE</literal>および<literal>NULL</literal>によって表現できます。
   </para>

   <para>
<!--
    The datatype input function for type <type>boolean</type> accepts these
    string representations for the <quote>true</quote> state:
-->
<type>boolean</type>のデータ型を入力する関数には次の文字列表現を<quote>真</quote>の状態として使うことができます。
    <simplelist>
     <member><literal>true</literal></member>
     <member><literal>yes</literal></member>
     <member><literal>on</literal></member>
     <member><literal>1</literal></member>
    </simplelist>
<!--
    and these representations for the <quote>false</quote> state:
-->
<quote>偽</quote>の状態には以下の表現が使用できます。
    <simplelist>
     <member><literal>false</literal></member>
     <member><literal>no</literal></member>
     <member><literal>off</literal></member>
     <member><literal>0</literal></member>
    </simplelist>
<!--
    Unique prefixes of these strings are also accepted, for
    example <literal>t</literal> or <literal>n</literal>.
    Leading or trailing whitespace is ignored, and case does not matter.
-->
<literal>t</literal> や <literal>n</literal>など、これらの文字列固有の接頭辞も利用できます。
先頭または末尾の空白文字は無視され、大文字小文字の区別は関係ありません。
   </para>

   <para>
<!--
    The datatype output function for type <type>boolean</type> always emits
    either <literal>t</literal> or <literal>f</literal>, as shown in
    <xref linkend="datatype-boolean-example"/>.
-->
<type>boolean</type>のデータ型を出力する関数は<xref linkend="datatype-boolean-example"/>にあるように、常に<literal>t</literal>か<literal>f</literal>を出力します。
   </para>

   <example id="datatype-boolean-example">
<!--
    <title>Using the <type>boolean</type> Type</title>
-->
    <title><type>boolean</type>型の使用</title>

<programlisting>
CREATE TABLE test1 (a boolean, b text);
INSERT INTO test1 VALUES (TRUE, 'sic est');
INSERT INTO test1 VALUES (FALSE, 'non est');
SELECT * FROM test1;
 a |    b
---+---------
 t | sic est
 f | non est

SELECT * FROM test1 WHERE a;
 a |    b
---+---------
 t | sic est
</programlisting>
   </example>

   <para>
<!--
    The key words <literal>TRUE</literal> and <literal>FALSE</literal> are
    the preferred (<acronym>SQL</acronym>-compliant) method for writing
    Boolean constants in SQL queries.  But you can also use the string
    representations by following the generic string-literal constant syntax
    described in <xref linkend="sql-syntax-constants-generic"/>, for
    example <literal>'yes'::boolean</literal>.
-->
キーワードである<literal>TRUE</literal> と<literal>FALSE</literal>はSQLクエリの中で論理定数の記述として好ましい(<acronym>SQL</acronym>準拠)方式です。
しかし、 <xref linkend="sql-syntax-constants-generic"/>のリンクで記述されている、以下のような一般的な文字列リテラル定数の構文に従って<literal>'yes'::boolean</literal>というような文字表現することもできます。
   </para>

   <para>
<!--
    Note that the parser automatically understands
    that <literal>TRUE</literal> and <literal>FALSE</literal> are of
    type <type>boolean</type>, but this is not so
    for <literal>NULL</literal> because that can have any type.
    So in some contexts you might have to cast <literal>NULL</literal>
    to <type>boolean</type> explicitly, for
    example <literal>NULL::boolean</literal>.  Conversely, the cast can be
    omitted from a string-literal Boolean value in contexts where the parser
    can deduce that the literal must be of type <type>boolean</type>.
-->
パーサーは自動的に<literal>TRUE</literal>と<literal>FALSE</literal>は<type>boolean</type>型と理解しますが、<literal>NULL</literal>は他のすべての型に存在するため、<type>boolean</type>型と理解しない点に気をつけてください。
このため、コンテキストによっては<literal>NULL::boolean</literal>というように、<literal>NULL</literal>を<literal>boolean</literal>に明確にキャストする必要があります。
逆に、解析でリテラルが<type>boolean</type>型でなければならないと推論できるコンテキストでは、文字列リテラルブール値のキャストは省略できます。
   </para>
  </sect1>

  <sect1 id="datatype-enum">
<!--
   <title>Enumerated Types</title>
-->
   <title>列挙型</title>

   <indexterm zone="datatype-enum">
    <primary>data type</primary>
    <secondary>enumerated (enum)</secondary>
   </indexterm>
   <indexterm zone="datatype-enum">
    <primary>データ型</primary>
    <secondary>列挙（enum）</secondary>
   </indexterm>

   <indexterm zone="datatype-enum">
    <primary>enumerated types</primary>
   </indexterm>
   <indexterm zone="datatype-enum">
    <primary>列挙型</primary>
   </indexterm>

   <para>
<!--
    Enumerated (enum) types are data types that
    comprise a static, ordered set of values.
    They are equivalent to the <type>enum</type>
    types supported in a number of programming languages. An example of an enum
    type might be the days of the week, or a set of status values for
    a piece of data.
-->
列挙（enum）型は静的、順序付き集合から構成されるデータ型です。
これは、多くのプログラミング言語でサポートされている<type>enum</type>型と同じです。
列挙型の例として、曜日や個々のデータについての状態値の集合が挙げられます。
   </para>

   <sect2 id="datatype-enum-declaration">
<!--
    <title>Declaration of Enumerated Types</title>
-->
    <title>列挙型の宣言</title>

    <para>
<!--
     Enum types are created using the <xref
     linkend="sql-createtype"/> command,
     for example:
-->
列挙型は<xref linkend="sql-createtype"/>コマンドを使用して作成されます。
以下に例を示します。

<programlisting>
CREATE TYPE mood AS ENUM ('sad', 'ok', 'happy');
</programlisting>

<!--
     Once created, the enum type can be used in table and function
     definitions much like any other type:
-->
作成後、他のデータ型とほとんど同じように、列挙型をテーブルや関数定義で使用することができます。
<programlisting>
CREATE TYPE mood AS ENUM ('sad', 'ok', 'happy');
CREATE TABLE person (
    name text,
    current_mood mood
);
INSERT INTO person VALUES ('Moe', 'happy');
SELECT * FROM person WHERE current_mood = 'happy';
 name | current_mood
------+--------------
 Moe  | happy
(1 row)
</programlisting>
    </para>
    </sect2>

    <sect2 id="datatype-enum-ordering">
<!--
     <title>Ordering</title>
-->
     <title>順序</title>

     <para>
<!--
      The ordering of the values in an enum type is the
      order in which the values were listed when the type was created.
      All standard comparison operators and related
      aggregate functions are supported for enums.  For example:
-->
列挙型内の値の順序はその型が作成された時に値を列挙した順番になります。
列挙型に対して、すべての比較演算子と関連する集約関数がサポートされます。
以下に例を示します。

<programlisting>
INSERT INTO person VALUES ('Larry', 'sad');
INSERT INTO person VALUES ('Curly', 'ok');
SELECT * FROM person WHERE current_mood > 'sad';
 name  | current_mood
-------+--------------
 Moe   | happy
 Curly | ok
(2 rows)

SELECT * FROM person WHERE current_mood > 'sad' ORDER BY current_mood;
 name  | current_mood
-------+--------------
 Curly | ok
 Moe   | happy
(2 rows)

SELECT name
FROM person
WHERE current_mood = (SELECT MIN(current_mood) FROM person);
 name
-------
 Larry
(1 row)
</programlisting>
     </para>
   </sect2>

   <sect2 id="datatype-enum-type-safety">
<!--
    <title>Type Safety</title>
-->
    <title>型の安全性</title>

    <para>
<!--
     Each enumerated data type is separate and cannot
     be compared with other enumerated types.  See this example:
-->
それぞれの列挙型データ型は別個のもので、他の列挙型と比較することはできません。
以下の例を参照してください。

<programlisting>
CREATE TYPE happiness AS ENUM ('happy', 'very happy', 'ecstatic');
CREATE TABLE holidays (
    num_weeks integer,
    happiness happiness
);
INSERT INTO holidays(num_weeks,happiness) VALUES (4, 'happy');
INSERT INTO holidays(num_weeks,happiness) VALUES (6, 'very happy');
INSERT INTO holidays(num_weeks,happiness) VALUES (8, 'ecstatic');
INSERT INTO holidays(num_weeks,happiness) VALUES (2, 'sad');
ERROR:  invalid input value for enum happiness: "sad"
SELECT person.name, holidays.num_weeks FROM person, holidays
  WHERE person.current_mood = holidays.happiness;
ERROR:  operator does not exist: mood = happiness
</programlisting>
    </para>

    <para>
<!--
     If you really need to do something like that, you can either
     write a custom operator or add explicit casts to your query:
-->
もし本当に上のようなことが必要ならば、独自の演算子を作成するか、問い合わせに明示的なキャストを付けることで行うことができます。

<programlisting>
SELECT person.name, holidays.num_weeks FROM person, holidays
  WHERE person.current_mood::text = holidays.happiness::text;
 name | num_weeks
------+-----------
 Moe  |         4
(1 row)

</programlisting>
    </para>
   </sect2>

   <sect2 id="datatype-enum-implementation-details">
<!--
    <title>Implementation Details</title>
-->
    <title>実装の詳細</title>

    <para>
<!--
     Enum labels are case sensitive, so
     <type>'happy'</type> is not the same as <type>'HAPPY'</type>.
     White space in the labels is significant too.
-->
列挙型のラベルは大文字小文字の違いを意識します。
このため、<type>'happy'</type>と<type>'HAPPY'</type>は同じではありません。
同様にラベルの中の空白も重要です。
    </para>

    <para>
<!--
     Although enum types are primarily intended for static sets of values,
     there is support for adding new values to an existing enum type, and for
     renaming values (see <xref linkend="sql-altertype"/>).  Existing values
     cannot be removed from an enum type, nor can the sort ordering of such
     values be changed, short of dropping and re-creating the enum type.
-->
列挙型は主に静的な値のセットを対象としていますが、既存の列挙型に新しい値を加えることや名前を変更することをサポートしています(<xref linkend="sql-altertype"/>を参照)。
ただし、列挙型を削除して再作成せずに、既存の列挙型からラベルを削除することやソート順が変わる値に変更することはできません。
    </para>

    <para>
<!--
     An enum value occupies four bytes on disk.  The length of an enum
     value's textual label is limited by the <symbol>NAMEDATALEN</symbol>
     setting compiled into <productname>PostgreSQL</productname>; in standard
     builds this means at most 63 bytes.
-->
列挙型の値はディスク上では4バイトを占めます。
列挙型の値のテキストラベルの長さは、<productname>PostgreSQL</productname>に組み込まれた<symbol>NAMEDATALEN</symbol>設定により制限されます。
標準のビルドでは、これは最大63バイトを意味します。
    </para>

    <para>
<!--
     The translations from internal enum values to textual labels are
     kept in the system catalog
     <link linkend="catalog-pg-enum"><structname>pg_enum</structname></link>.
     Querying this catalog directly can be useful.
-->
列挙型の内部値からテキスト形式のラベルへの変換は、<link linkend="catalog-pg-enum"><structname>pg_enum</structname></link>システムカタログ内に保持されます。
このカタログを直接問い合わせることが役に立つ場合があります。
    </para>

   </sect2>
  </sect1>

  <sect1 id="datatype-geometric">
<!--
   <title>Geometric Types</title>
-->
   <title>幾何データ型</title>

   <para>
<!--
    Geometric data types represent two-dimensional spatial
    objects. <xref linkend="datatype-geo-table"/> shows the geometric
    types available in <productname>PostgreSQL</productname>.
-->
幾何データ型は2次元空間オブジェクトを表現します。
<xref linkend="datatype-geo-table"/>は、<productname>PostgreSQL</productname>で使用可能な幾何データ型を列挙したものです。
   </para>

    <table id="datatype-geo-table">
<!--
     <title>Geometric Types</title>
-->
     <title>幾何データ型</title>
     <tgroup cols="4">
      <colspec colname="col1" colwidth="1*"/>
      <colspec colname="col2" colwidth="1*"/>
      <colspec colname="col3" colwidth="2*"/>
      <colspec colname="col4" colwidth="1*"/>
      <thead>
       <row>
<!--
        <entry>Name</entry>
        <entry>Storage Size</entry>
        <entry>Description</entry>
        <entry>Representation</entry>
-->
        <entry>型名</entry>
        <entry>格納サイズ</entry>
        <entry>説明</entry>
        <entry>表現</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><type>point</type></entry>
<!--
        <entry>16 bytes</entry>
        <entry>Point on a plane</entry>
-->
        <entry>16バイト</entry>
        <entry>平面における座標点</entry>
        <entry>(x,y)</entry>
       </row>
       <row>
        <entry><type>line</type></entry>
        <entry>24 bytes</entry>
        <entry>Infinite line</entry>
        <entry>{A,B,C}</entry>
       </row>
       <row>
        <entry><type>lseg</type></entry>
<!--
        <entry>32 bytes</entry>
        <entry>Finite line segment</entry>
-->
        <entry>32バイト</entry>
        <entry>有限の線分</entry>
        <entry>((x1,y1),(x2,y2))</entry>
       </row>
       <row>
        <entry><type>box</type></entry>
<!--
        <entry>32 bytes</entry>
        <entry>Rectangular box</entry>
-->
        <entry>32バイト</entry>
        <entry>矩形</entry>
        <entry>((x1,y1),(x2,y2))</entry>
       </row>
       <row>
        <entry><type>path</type></entry>
<!--
        <entry>16+16n bytes</entry>
        <entry>Closed path (similar to polygon)</entry>
-->
        <entry>16+16nバイト</entry>
        <entry>閉経路（多角形に類似）</entry>
        <entry>((x1,y1),...)</entry>
       </row>
       <row>
        <entry><type>path</type></entry>
<!--
        <entry>16+16n bytes</entry>
        <entry>Open path</entry>
-->
        <entry>16+16nバイト</entry>
        <entry>開経路</entry>
        <entry>[(x1,y1),...]</entry>
       </row>
       <row>
        <entry><type>polygon</type></entry>
<!--
        <entry>40+16n bytes</entry>
        <entry>Polygon (similar to closed path)</entry>
-->
        <entry>40+16nバイト</entry>
        <entry>多角形（閉経路に類似）</entry>
        <entry>((x1,y1),...)</entry>
       </row>
       <row>
        <entry><type>circle</type></entry>
<!--
        <entry>24 bytes</entry>
        <entry>Circle</entry>
        <entry>&lt;(x,y),r&gt; (center point and radius)</entry>
-->
        <entry>24バイト</entry>
        <entry>円</entry>
        <entry>&lt;(x,y),r&gt;（中心と半径）</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
<!--
    In all these types, the individual coordinates are stored as
    <type>double precision</type> (<type>float8</type>) numbers.
-->
これらすべての型では個別の座標は<type>double precision</type> (<type>float8</type>)の数値として格納されます。
   </para>

   <para>
<!--
    A rich set of functions and operators is available to perform various geometric
    operations such as scaling, translation, rotation, and determining
    intersections.  They are explained in <xref linkend="functions-geometry"/>.
-->
拡大縮小、平行移動、回転、交点の算出といった様々な幾何学的操作を行う関数と演算子の集合が豊富に揃っています。
このことについては<xref linkend="functions-geometry"/>に説明があります。
   </para>

   <sect2 id="datatype-geometric-points">
<!--
    <title>Points</title>
-->
    <title>座標点</title>

    <indexterm>
     <primary>point</primary>
    </indexterm>

    <para>
<!--
     Points are the fundamental two-dimensional building block for geometric
     types.  Values of type <type>point</type> are specified using either of
     the following syntaxes:
-->
座標点は幾何データ型の基礎となる2次元構成要素です。
<type>point</type>型の値は次の構文のいずれかで指定されます。

<synopsis>
( <replaceable>x</replaceable> , <replaceable>y</replaceable> )
  <replaceable>x</replaceable> , <replaceable>y</replaceable>
</synopsis>

<!--
     where <replaceable>x</replaceable> and <replaceable>y</replaceable> are the respective
     coordinates, as floating-point numbers.
-->
ここで<replaceable>x</replaceable>と<replaceable>y</replaceable>は、それぞれの座標を浮動小数点数数値で表したものです。
    </para>

    <para>
<!--
     Points are output using the first syntax.
-->
座標点は1番目の構文で出力されます。
    </para>
   </sect2>

   <sect2 id="datatype-line">
<!--
    <title>Lines</title>
-->
    <title>直線</title>

    <indexterm>
     <primary>line</primary>
    </indexterm>
    <indexterm>
     <primary>直線</primary>
    </indexterm>

    <para>
<!--
     Lines are represented by the linear
     equation <replaceable>A</replaceable>x + <replaceable>B</replaceable>y + <replaceable>C</replaceable> = 0,
     where <replaceable>A</replaceable> and <replaceable>B</replaceable> are not both zero.  Values
     of type <type>line</type> are input and output in the following form:
-->
直線は線形方程式<replaceable>A</replaceable>x + <replaceable>B</replaceable>y + <replaceable>C</replaceable> = 0で表現されます。ここで<replaceable>A</replaceable>と<replaceable>B</replaceable>は同時に0になることはありません。
<type>line</type>型の値は以下の書式で入出力されます。
<synopsis>
{ <replaceable>A</replaceable>, <replaceable>B</replaceable>, <replaceable>C</replaceable> }
</synopsis>

<!--
     Alternatively, any of the following forms can be used for input:
-->
入力のためには以下の書式を代替として使用することもできます。

<synopsis>
[ ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> ) ]
( ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> ) )
  ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> )
    <replaceable>x1</replaceable> , <replaceable>y1</replaceable>   ,   <replaceable>x2</replaceable> , <replaceable>y2</replaceable>
</synopsis>

<!--
     where
     <literal>(<replaceable>x1</replaceable>,<replaceable>y1</replaceable>)</literal>
     and
     <literal>(<replaceable>x2</replaceable>,<replaceable>y2</replaceable>)</literal>
     are two different points on the line.
-->
ここで<literal>(<replaceable>x1</replaceable>,<replaceable>y1</replaceable>)</literal>と<literal>(<replaceable>x2</replaceable>,<replaceable>y2</replaceable>)</literal>はその直線上の2つの異なる点です。
    </para>
   </sect2>

   <sect2 id="datatype-lseg">
<!--
    <title>Line Segments</title>
-->
    <title>線分</title>

    <indexterm>
     <primary>lseg</primary>
    </indexterm>

    <indexterm>
     <primary>line segment</primary>
    </indexterm>
    <indexterm>
     <primary>線分</primary>
    </indexterm>

    <para>
<!--
     Line segments are represented by pairs of points that are the endpoints
     of the segment.  Values of type <type>lseg</type> are specified using any
     of the following syntaxes:
-->
線分は終点を示す2つの点の組み合わせで表現されます。
<type>lseg</type>型の値は以下の構文のいずれかで指定されます。

<synopsis>
[ ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> ) ]
( ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> ) )
  ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> )
    <replaceable>x1</replaceable> , <replaceable>y1</replaceable>   ,   <replaceable>x2</replaceable> , <replaceable>y2</replaceable>
</synopsis>

<!--
     where
     <literal>(<replaceable>x1</replaceable>,<replaceable>y1</replaceable>)</literal>
     and
     <literal>(<replaceable>x2</replaceable>,<replaceable>y2</replaceable>)</literal>
     are the end points of the line segment.
-->
ここで、<literal>(<replaceable>x1</replaceable>,<replaceable>y1</replaceable>)</literal>と<literal>(<replaceable>x2</replaceable>,<replaceable>y2</replaceable>)</literal>は線分の終端点です。
    </para>

    <para>
<!--
     Line segments are output using the first syntax.
-->
線分は1番目の構文で出力されます。
    </para>
   </sect2>

   <sect2 id="datatype-geometric-boxes">
<!--
    <title>Boxes</title>
-->
    <title>矩形</title>

    <indexterm>
     <primary>box (data type)</primary>
    </indexterm>
    <indexterm>
     <primary>box（データ型）</primary>
    </indexterm>

    <indexterm>
     <primary>rectangle</primary>
    </indexterm>
    <indexterm>
     <primary>矩形</primary>
    </indexterm>

    <para>
<!--
     Boxes are represented by pairs of points that are opposite
     corners of the box.
     Values of type <type>box</type> are specified using any of the following
     syntaxes:
-->
矩形は、矩形の対角線の両端の座標点の組み合わせで表されます。
<type>box</type>型の値は以下の構文のいずれかで指定されます。

<synopsis>
( ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> ) )
  ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> )
    <replaceable>x1</replaceable> , <replaceable>y1</replaceable>   ,   <replaceable>x2</replaceable> , <replaceable>y2</replaceable>
</synopsis>

<!--
     where
     <literal>(<replaceable>x1</replaceable>,<replaceable>y1</replaceable>)</literal>
     and
     <literal>(<replaceable>x2</replaceable>,<replaceable>y2</replaceable>)</literal>
     are any two opposite corners of the box.
-->
ここで<literal>(<replaceable>x1</replaceable>,<replaceable>y1</replaceable>)</literal>と<literal>(<replaceable>x2</replaceable>,<replaceable>y2</replaceable>)</literal>は矩形の対角線の両端です。
    </para>

    <para>
<!--
     Boxes are output using the second syntax.
-->
矩形は2番目の構文で出力されます。
    </para>

    <para>
<!--
     Any two opposite corners can be supplied on input, but the values
     will be reordered as needed to store the
     upper right and lower left corners, in that order.
-->
任意の対角頂点を入力として指定することができます。
しかし頂点は右上の頂点を最初に、左下の頂点をその後に格納するよう必要に応じて並べ替えられます。
    </para>
   </sect2>

   <sect2 id="datatype-geometric-paths">
<!--
    <title>Paths</title>
-->
    <title>経路</title>

    <indexterm>
     <primary>path (data type)</primary>
    </indexterm>
    <indexterm>
     <primary>path（データ型）</primary>
    </indexterm>

    <para>
<!--
     Paths are represented by lists of connected points. Paths can be
     <firstterm>open</firstterm>, where
     the first and last points in the list are considered not connected, or
     <firstterm>closed</firstterm>,
     where the first and last points are considered connected.
-->
経路は接続している座標点のリストで表現されます。
経路は最初の座標点と最後の座標点が接続されていないとみなされる<firstterm>開いている</firstterm>状態か、最初の座標点と最後の座標点が接続されているとみなされる<firstterm>閉じた</firstterm>状態かのいずれかです。
    </para>

    <para>
<!--
     Values of type <type>path</type> are specified using any of the following
     syntaxes:
-->
<type>path</type>型の値は次の構文のいずれかで指定されます。

<synopsis>
[ ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ... , ( <replaceable>xn</replaceable> , <replaceable>yn</replaceable> ) ]
( ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ... , ( <replaceable>xn</replaceable> , <replaceable>yn</replaceable> ) )
  ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ... , ( <replaceable>xn</replaceable> , <replaceable>yn</replaceable> )
  ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable>   , ... ,   <replaceable>xn</replaceable> , <replaceable>yn</replaceable> )
    <replaceable>x1</replaceable> , <replaceable>y1</replaceable>   , ... ,   <replaceable>xn</replaceable> , <replaceable>yn</replaceable>
</synopsis>

<!--
     where the points are the end points of the line segments
     comprising the path.  Square brackets (<literal>[]</literal>) indicate
     an open path, while parentheses (<literal>()</literal>) indicate a
     closed path.  When the outermost parentheses are omitted, as
     in the third through fifth syntaxes, a closed path is assumed.
-->
ここで、各座標点は、経路を構成する線分の終端点です。
大括弧（<literal>[]</literal>）は開経路を、括弧（<literal>()</literal>）は閉経路を示します。
3番目から4番目の構文のようにもっとも外側の括弧が省略された場合、閉経路と仮定されます。
    </para>

    <para>
<!--
     Paths are output using the first or second syntax, as appropriate.
-->
経路は最初または２番目の適切な構文で出力されます。
    </para>
   </sect2>

   <sect2 id="datatype-polygon">
<!--
    <title>Polygons</title>
-->
    <title>多角形(ポリゴン)</title>

    <indexterm>
     <primary>polygon</primary>
    </indexterm>

    <para>
<!--
     Polygons are represented by lists of points (the vertexes of the
     polygon). Polygons are very similar to closed paths; the essential
     semantic difference is that a polygon is considered to include the
     area within it, while a path is not.
-->
多角形は座標点（多角形の頂点）のリストで表現されます。
多角形は閉経路ととても良く似ています。多角形は領域をその内側に含むと考えますが、閉経路ではそのように考えない点が本質的な意味の違いです。
    </para>

    <para>
<!--
     An important implementation difference between polygons and
     paths is that the stored representation of a polygon includes its
     smallest bounding box.  This speeds up certain search operations,
     although computing the bounding box adds overhead while constructing
     new polygons.
-->
多角形と経路の重要な実装の違いは、格納された多角形の表現に最小の境界がある矩形を含むことです。
これは特定の検索操作を高速にしますが、新しい多角形を構築する際に境界がある矩形を計算するオーバヘッドが増えます。
    </para>

    <para>
<!--
     Values of type <type>polygon</type> are specified using any of the
     following syntaxes:
-->
<type>polygon</type>型の値は次の構文のいずれかで指定されます。

<synopsis>
( ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ... , ( <replaceable>xn</replaceable> , <replaceable>yn</replaceable> ) )
  ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ... , ( <replaceable>xn</replaceable> , <replaceable>yn</replaceable> )
  ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable>   , ... ,   <replaceable>xn</replaceable> , <replaceable>yn</replaceable> )
    <replaceable>x1</replaceable> , <replaceable>y1</replaceable>   , ... ,   <replaceable>xn</replaceable> , <replaceable>yn</replaceable>
</synopsis>

<!--
     where the points are the end points of the line segments
     comprising the boundary of the polygon.
-->
各座標点は多角形の境界を構成する線分の終端点です。
    </para>

    <para>
<!--
     Polygons are output using the first syntax.
-->
多角形は最初の構文で出力されます。
    </para>
   </sect2>

   <sect2 id="datatype-circle">
<!--
    <title>Circles</title>
-->
    <title>円</title>

    <indexterm>
     <primary>circle</primary>
    </indexterm>

    <para>
<!--
     Circles are represented by a center point and radius.
     Values of type <type>circle</type> are specified using any of the
     following syntaxes:
-->
円は中心座標点と半径で表現されます。
<type>circle</type>型の値は次の構文のいずれかで指定されます。

<synopsis>
&lt; ( <replaceable>x</replaceable> , <replaceable>y</replaceable> ) , <replaceable>r</replaceable> &gt;
( ( <replaceable>x</replaceable> , <replaceable>y</replaceable> ) , <replaceable>r</replaceable> )
  ( <replaceable>x</replaceable> , <replaceable>y</replaceable> ) , <replaceable>r</replaceable>
    <replaceable>x</replaceable> , <replaceable>y</replaceable>   , <replaceable>r</replaceable>
</synopsis>

<!--
     where
     <literal>(<replaceable>x</replaceable>,<replaceable>y</replaceable>)</literal>
     is the center point and <replaceable>r</replaceable> is the radius of the
     circle.
-->
ここで<literal>(<replaceable>x</replaceable>,<replaceable>y</replaceable>)</literal>は円の中心点、<replaceable>r</replaceable>は円の半径です。
    </para>

    <para>
<!--
     Circles are output using the first syntax.
-->
円は最初の構文で出力されます。
    </para>
   </sect2>

  </sect1>

  <sect1 id="datatype-net-types">
<!--
   <title>Network Address Types</title>
-->
   <title>ネットワークアドレス型</title>

   <indexterm zone="datatype-net-types">
    <primary>network</primary>
    <secondary>data types</secondary>
   </indexterm>
   <indexterm zone="datatype-net-types">
    <primary>ネットワーク</primary>
    <secondary>データ型</secondary>
   </indexterm>

   <para>
<!--
    <productname>PostgreSQL</productname> offers data types to store IPv4, IPv6, and MAC
    addresses, as shown in <xref linkend="datatype-net-types-table"/>.  It
    is better to use these types instead of plain text types to store
    network addresses, because
    these types offer input error checking and specialized
    operators and functions (see <xref linkend="functions-net"/>).
-->
<productname>PostgreSQL</productname>は、<xref linkend="datatype-net-types-table"/>に示すように、IPv4アドレス、IPv6アドレス、MACアドレスを格納するデータ型を提供します。
ネットワークアドレスを格納するには普通のテキストデータ型の代わりにこれらの型を使うことの方が優れています。
なぜなら、これらのデータ型は入力値のエラー検査と専用の演算子と関数を提供しているからです
（<xref linkend="functions-net"/>を参照してください）。
   </para>

    <table tocentry="1" id="datatype-net-types-table">
<!--
     <title>Network Address Types</title>
-->
     <title>ネットワークアドレスデータ型</title>
     <tgroup cols="3">
      <colspec colname="col1" colwidth="1*"/>
      <colspec colname="col2" colwidth="1*"/>
      <colspec colname="col3" colwidth="2*"/>
      <thead>
       <row>
<!--
        <entry>Name</entry>
        <entry>Storage Size</entry>
        <entry>Description</entry>
-->
        <entry>名前</entry>
        <entry>格納サイズ</entry>
        <entry>説明</entry>
       </row>
      </thead>
      <tbody>

       <row>
        <entry><type>cidr</type></entry>
<!--
        <entry>7 or 19 bytes</entry>
        <entry>IPv4 and IPv6 networks</entry>
-->
        <entry>7もしくは19バイト</entry>
        <entry>IPv4、およびIPv6ネットワーク</entry>
       </row>

       <row>
        <entry><type>inet</type></entry>
<!--
        <entry>7 or 19 bytes</entry>
        <entry>IPv4 and IPv6 hosts and networks</entry>
-->
        <entry>7もしくは19バイト</entry>
        <entry>IPv4もしくはIPv6ホスト、およびネットワーク</entry>
       </row>

       <row>
        <entry><type>macaddr</type></entry>
<!--
        <entry>6 bytes</entry>
        <entry>MAC addresses</entry>
-->
        <entry>6バイト</entry>
        <entry>MACアドレス</entry>
       </row>

       <row>
        <entry><type>macaddr8</type></entry>
<!--
        <entry>8 bytes</entry>
        <entry>MAC addresses (EUI-64 format)</entry>
-->
        <entry>8 バイト</entry>
        <entry>MAC アドレス (EUI-64 形式)</entry>
       </row>

      </tbody>
     </tgroup>
    </table>

   <para>
<!--
    When sorting <type>inet</type> or <type>cidr</type> data types,
    IPv4 addresses will always sort before IPv6 addresses, including
    IPv4 addresses encapsulated or mapped to IPv6 addresses, such as
    ::10.2.3.4 or ::ffff:10.4.3.2.
-->
<type>inet</type>もしくは<type>cidr</type>をソートする時、IPv4アドレスは常にIPv6よりも前にソートされます。
::10.2.3.4や::ffff:10.4.3.2などIPv6アドレス内に埋め込まれた、もしくは関連付けされたIPv4アドレスも同様です。
   </para>


   <sect2 id="datatype-inet">
    <title><type>inet</type></title>

    <indexterm>
     <primary>inet (data type)</primary>
    </indexterm>
    <indexterm>
     <primary>inet（データ型）</primary>
    </indexterm>

    <para>
<!--
     The <type>inet</type> type holds an IPv4 or IPv6 host address, and
     optionally its subnet, all in one field.
     The subnet is represented by the number of network address bits
     present in the host address (the
     <quote>netmask</quote>).  If the netmask is 32 and the address is IPv4,
     then the value does not indicate a subnet, only a single host.
     In IPv6, the address length is 128 bits, so 128 bits specify a
     unique host address.  Note that if you
     want to accept only networks, you should use the
     <type>cidr</type> type rather than <type>inet</type>.
-->
<type>inet</type>型はIPv4もしくはIPv6ホストアドレスとオプションでそのサブネットを１つのフィールドに保持します。
サブネットはホストアドレス内のネットワークアドレスのビット数（<quote>ネットマスク</quote>）により表現されます。
ネットマスクが32でアドレスがIPv4の場合、その値はサブネットを示さず、単一ホストを表します。
IPv6ではアドレス長は128ビットですので、128ビットが一意なホストアドレスを指定します。
ネットワークのみを使用したい場合は<type>inet</type>ではなく<type>cidr</type>型を利用してください。
    </para>

    <para>
<!--
      The input format for this type is
      <replaceable class="parameter">address/y</replaceable>
      where
      <replaceable class="parameter">address</replaceable>
      is an IPv4 or IPv6 address and
      <replaceable class="parameter">y</replaceable>
      is the number of bits in the netmask.  If the
      <replaceable class="parameter">/y</replaceable>
      portion is omitted, the
      netmask is taken to be 32 for IPv4 or 128 for IPv6,
      so the value represents
      just a single host.  On display, the
      <replaceable class="parameter">/y</replaceable>
      portion is suppressed if the netmask specifies a single host.
-->
このデータ型に対する入力書式は<replaceable class="parameter">address/y</replaceable>です。
ここで、<replaceable class="parameter">address</replaceable>はIPv4またはIPv6のアドレス、<replaceable class="parameter">y</replaceable>はネットマスクのビット数です。
<replaceable class="parameter">/y</replaceable>部分が省略された場合、ネットマスクはIPv4では32、IPv6では128となり、つまり、その値は単一ホストを表現します。
ネットマスクが単一ホストを表す場合、その表示時、<replaceable class="parameter">/y</replaceable>の部分は抑制されます。
    </para>
   </sect2>

   <sect2 id="datatype-cidr">
    <title><type>cidr</type></title>

    <indexterm>
     <primary>cidr</primary>
    </indexterm>

    <para>
<!--
     The <type>cidr</type> type holds an IPv4 or IPv6 network specification.
     Input and output formats follow Classless Internet Domain Routing
     conventions.
     The format for specifying networks is <replaceable
     class="parameter">address/y</replaceable> where <replaceable
     class="parameter">address</replaceable> is the network's lowest
     address represented as an
     IPv4 or IPv6 address, and <replaceable
     class="parameter">y</replaceable> is the number of bits in the netmask.  If
     <replaceable class="parameter">y</replaceable> is omitted, it is calculated
     using assumptions from the older classful network numbering system, except
     it will be at least large enough to include all of the octets
     written in the input.  It is an error to specify a network address
     that has bits set to the right of the specified netmask.
-->
<type>cidr</type>データ型はIPv4、IPv6ネットワーク仕様を保持します。
入出力書式はCIDR表記（クラスレスアドレッシング）に従います。
ネットワークを指定する時の書式は<replaceable class="parameter">address/y</replaceable>で、<replaceable class="parameter">address</replaceable>がIPv4もしくはIPv6アドレスで表したネットワークの最下位アドレスで、<replaceable class="parameter">y</replaceable>はネットマスクのビット数です。
<replaceable class="parameter">y</replaceable>が省略された場合には、従来のクラス付きアドレス番号指定システムに従って計算されますが、入力時に書き込まれたオクテットすべてが含まれるように大きさは確保されます。
指定したネットマスクの右側にビットをセットしたネットワークアドレスを指定するとエラーになります。
    </para>

    <para>
<!--
     <xref linkend="datatype-net-cidr-table"/> shows some examples.
-->
     <xref linkend="datatype-net-cidr-table"/>に例をいくつか示します。
    </para>

     <table id="datatype-net-cidr-table">
<!--
      <title><type>cidr</type> Type Input Examples</title>
-->
      <title><type>cidr</type>データ型入力例</title>
      <tgroup cols="3">
       <thead>
        <row>
<!--
         <entry><type>cidr</type> Input</entry>
         <entry><type>cidr</type> Output</entry>
-->
         <entry><type>cidr</type>入力</entry>
         <entry><type>cidr</type>出力</entry>
         <entry><literal><function>abbrev(<type>cidr</type>)</function></literal></entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry>192.168.100.128/25</entry>
         <entry>192.168.100.128/25</entry>
         <entry>192.168.100.128/25</entry>
        </row>
        <row>
         <entry>192.168/24</entry>
         <entry>192.168.0.0/24</entry>
         <entry>192.168.0/24</entry>
        </row>
        <row>
         <entry>192.168/25</entry>
         <entry>192.168.0.0/25</entry>
         <entry>192.168.0.0/25</entry>
        </row>
        <row>
         <entry>192.168.1</entry>
         <entry>192.168.1.0/24</entry>
         <entry>192.168.1/24</entry>
        </row>
        <row>
         <entry>192.168</entry>
         <entry>192.168.0.0/24</entry>
         <entry>192.168.0/24</entry>
        </row>
        <row>
         <entry>128.1</entry>
         <entry>128.1.0.0/16</entry>
         <entry>128.1/16</entry>
        </row>
        <row>
         <entry>128</entry>
         <entry>128.0.0.0/16</entry>
         <entry>128.0/16</entry>
        </row>
        <row>
         <entry>128.1.2</entry>
         <entry>128.1.2.0/24</entry>
         <entry>128.1.2/24</entry>
        </row>
        <row>
         <entry>10.1.2</entry>
         <entry>10.1.2.0/24</entry>
         <entry>10.1.2/24</entry>
        </row>
        <row>
         <entry>10.1</entry>
         <entry>10.1.0.0/16</entry>
         <entry>10.1/16</entry>
        </row>
        <row>
         <entry>10</entry>
         <entry>10.0.0.0/8</entry>
         <entry>10/8</entry>
        </row>
        <row>
         <entry>10.1.2.3/32</entry>
         <entry>10.1.2.3/32</entry>
         <entry>10.1.2.3/32</entry>
        </row>
        <row>
         <entry>2001:4f8:3:ba::/64</entry>
         <entry>2001:4f8:3:ba::/64</entry>
         <entry>2001:4f8:3:ba/64</entry>
        </row>
        <row>
         <entry>2001:4f8:3:ba:&zwsp;2e0:81ff:fe22:d1f1/128</entry>
         <entry>2001:4f8:3:ba:&zwsp;2e0:81ff:fe22:d1f1/128</entry>
         <entry>2001:4f8:3:ba:&zwsp;2e0:81ff:fe22:d1f1/128</entry>
        </row>
        <row>
         <entry>::ffff:1.2.3.0/120</entry>
         <entry>::ffff:1.2.3.0/120</entry>
         <entry>::ffff:1.2.3/120</entry>
        </row>
        <row>
         <entry>::ffff:1.2.3.0/128</entry>
         <entry>::ffff:1.2.3.0/128</entry>
         <entry>::ffff:1.2.3.0/128</entry>
        </row>
       </tbody>
      </tgroup>
     </table>
   </sect2>

   <sect2 id="datatype-inet-vs-cidr">
<!--
    <title><type>inet</type> vs. <type>cidr</type></title>
-->
    <title><type>inet</type>と<type>cidr</type>データ型の違い</title>

    <para>
<!--
    The essential difference between <type>inet</type> and <type>cidr</type>
    data types is that <type>inet</type> accepts values with nonzero bits to
    the right of the netmask, whereas <type>cidr</type> does not.  For
    example, <literal>192.168.0.1/24</literal> is valid for <type>inet</type>
    but not for <type>cidr</type>.
-->
<type>inet</type>データ型と<type>cidr</type>データ型との基本的な相違は、<type>inet</type>ではネットマスクの右側に0でないビット値を受け付けますが、<type>cidr</type>では受け付けないことです。
例えば、<literal>192.168.0.1/24</literal> は<type>inet</type>では有効ですが、<type>cidr</type>では有効ではありません。
    </para>

      <tip>
        <para>
<!--
        If you do not like the output format for <type>inet</type> or
        <type>cidr</type> values, try the functions <function>host</function>,
        <function>text</function>, and <function>abbrev</function>.
-->
もし<type>inet</type>もしくは<type>cidr</type>の値の出力書式が気に入らないのであれば、関数<function>host</function>、<function>text</function>および<function>abbrev</function>を試してください。
        </para>
      </tip>
   </sect2>

   <sect2 id="datatype-macaddr">
    <title><type>macaddr</type></title>

    <indexterm>
     <primary>macaddr (data type)</primary>
    </indexterm>
    <indexterm>
     <primary>macaddr (データ型)</primary>
    </indexterm>

    <indexterm>
     <primary>MAC address</primary>
     <see>macaddr</see>
    </indexterm>
    <indexterm>
     <primary>MACアドレス</primary>
     <see>macaddr</see>
    </indexterm>

    <para>
<!--
     The <type>macaddr</type> type stores MAC addresses, known for example
     from Ethernet card hardware addresses (although MAC addresses are
     used for other purposes as well).  Input is accepted in the
     following formats:
-->
<type>macaddr</type>データ型は例えばイーサネットカードのハードウェアアドレスとして知られるMACアドレスを保持します（MACアドレスは他の目的でも使われますが）。
入力は以下の形式を受け入れます。

     <simplelist>
      <member><literal>'08:00:2b:01:02:03'</literal></member>
      <member><literal>'08-00-2b-01-02-03'</literal></member>
      <member><literal>'08002b:010203'</literal></member>
      <member><literal>'08002b-010203'</literal></member>
      <member><literal>'0800.2b01.0203'</literal></member>
      <member><literal>'0800-2b01-0203'</literal></member>
      <member><literal>'08002b010203'</literal></member>
     </simplelist>

<!--
     These examples all specify the same address.  Upper and
     lower case is accepted for the digits
     <literal>a</literal> through <literal>f</literal>.  Output is always in the
     first of the forms shown.
-->
これらの例はすべて同一のアドレスを指定します。
<literal>a</literal>から<literal>f</literal>までの桁は大文字小文字どちらでも構いません。
出力は常に最初に示された形式となります。
    </para>

    <para>
<!--
     IEEE Standard 802-2001 specifies the second form shown (with hyphens)
     as the canonical form for MAC addresses, and specifies the first
     form (with colons) as used with bit-reversed, MSB-first notation, so that
     08-00-2b-01-02-03 = 10:00:D4:80:40:C0.  This convention is widely
     ignored nowadays, and it is relevant only for obsolete network
     protocols (such as Token Ring).  PostgreSQL makes no provisions
     for bit reversal; all accepted formats use the canonical LSB
     order.
-->
IEEE標準802-2001では、2番目の書式（ハイフンを使用）をMACアドレスの正規の表現と規定しています。
また、ビット反転で表記する最初の書式（コロンを使用）をMSBファーストの表記と規定しています。つまり08-00-2b-01-02-03は10:00:D4:80:40:C0です。
この規約は現在ではほぼ無視され、古びたネットワーク（トークンリングなど）のみに関連するものです。
PostgreSQLではビット反転に関する準備をしていません。
また、すべての受付け可能な書式では正規のLSB順を使用します。
    </para>

    <para>
<!--
     The remaining five input formats are not part of any standard.
-->
残る5つの入力書式はどの標準にも属しません。
    </para>
   </sect2>

   <sect2 id="datatype-macaddr8">
    <title><type>macaddr8</type></title>

    <indexterm>
     <primary>macaddr8 (data type)</primary>
    </indexterm>
    <indexterm>
     <primary>macaddr8 (データ型)</primary>
    </indexterm>

    <indexterm>
     <primary>MAC address (EUI-64 format)</primary>
     <see>macaddr</see>
    </indexterm>
    <indexterm>
     <primary>MACアドレス (EUI-64 形式)</primary>
     <see>macaddr</see>
    </indexterm>

    <para>
<!--
     The <type>macaddr8</type> type stores MAC addresses in EUI-64
     format, known for example from Ethernet card hardware addresses
     (although MAC addresses are used for other purposes as well).
     This type can accept both 6 and 8 byte length MAC addresses
     and stores them in 8 byte length format.  MAC addresses given
     in 6 byte format will be stored in 8 byte length format with the
     4th and 5th bytes set to FF and FE, respectively.
-->
<type>macaddr8</type>データ型はイーサネットカードのハードウェアアドレスなどで知られるEUI-64形式でデータを格納します（MACアドレスは他の目的にもよく使用されます）。
このデータ型は６バイト長と８バイト長の両方の長さのMACアドレスを受け入れることがき、８バイト長の形式で格納します。
6バイト形式で与えられたMACアドレスは8バイト長の形式では、それぞれ、４番目と５番目のバイトをFFとFEとして格納されます。

<!--
     Note that IPv6 uses a modified EUI-64 format where the 7th bit
     should be set to one after the conversion from EUI-48.  The
     function <function>macaddr8_set7bit</function> is provided to make this
     change.
-->
IPv6はEUI-48から変換後に７番目のビットに1となるべき設定がなされた修正EUI-64形式を使用する点に注意してください。
 <function>macaddr8_set7bit</function>関数がこの変換生成を提供します。

<!--
     Generally speaking, any input which is comprised of pairs of hex
     digits (on byte boundaries), optionally separated consistently by
     one of <literal>':'</literal>, <literal>'-'</literal> or <literal>'.'</literal>, is
     accepted.  The number of hex digits must be either 16 (8 bytes) or
     12 (6 bytes).  Leading and trailing whitespace is ignored.
-->
一般的には(バイト境界上での)16進数の対で構成され、任意に<literal>':'</literal>、<literal>'-'</literal> もしくは <literal>'.'</literal>のいずれかの一貫した記号で分割された入力を受け付けます。
16進数の桁数は16桁(8 バイト)か12桁(6バイト)のいずれかである必要があります。
前後の空白は無視されます。

<!--
     The following are examples of input formats that are accepted:
-->
以下の入力形式の例は受け付けられます。

     <simplelist>
      <member><literal>'08:00:2b:01:02:03:04:05'</literal></member>
      <member><literal>'08-00-2b-01-02-03-04-05'</literal></member>
      <member><literal>'08002b:0102030405'</literal></member>
      <member><literal>'08002b-0102030405'</literal></member>
      <member><literal>'0800.2b01.0203.0405'</literal></member>
      <member><literal>'0800-2b01-0203-0405'</literal></member>
      <member><literal>'08002b01:02030405'</literal></member>
      <member><literal>'08002b0102030405'</literal></member>
     </simplelist>

<!--
     These examples all specify the same address.  Upper and
     lower case is accepted for the digits
     <literal>a</literal> through <literal>f</literal>.  Output is always in the
     first of the forms shown.
-->
これらの例は全て同じアドレスを指します。
桁には大文字の<literal>A</literal> から<literal>F</literal>、小文字の<literal>a</literal> から<literal>f</literal>も受付けられます。
出力は常に１番目の形式です。
    </para>

    <para>
<!--
     The last six input formats shown above are not part of any standard.
-->
上記の最後の6つの形式は標準ではありません。
    </para>

    <para>
<!--
     To convert a traditional 48 bit MAC address in EUI-48 format to
     modified EUI-64 format to be included as the host portion of an
     IPv6 address, use <function>macaddr8_set7bit</function> as shown:
-->
従来のEUI-48形式の48ビットのMACアドレスからIPv6のホスト部を含む修正がなされたEUI-64形式へ変更するためには、以下に示すように<function>macaddr8_set7bit</function>を使用します。

<programlisting>
SELECT macaddr8_set7bit('08:00:2b:01:02:03');
<computeroutput>
    macaddr8_set7bit
-------------------------
 0a:00:2b:ff:fe:01:02:03
(1 row)
</computeroutput>
</programlisting>

    </para>

   </sect2>

  </sect1>

  <sect1 id="datatype-bit">
<!--
   <title>Bit String Types</title>
-->
   <title>ビット列データ型</title>

   <indexterm zone="datatype-bit">
    <primary>bit string</primary>
    <secondary>data type</secondary>
   </indexterm>
   <indexterm zone="datatype-bit">
    <primary>ビット列</primary>
    <secondary>データ型</secondary>
   </indexterm>

   <para>
<!--
    Bit strings are strings of 1's and 0's.  They can be used to store
    or visualize bit masks.  There are two SQL bit types:
    <type>bit(<replaceable>n</replaceable>)</type> and <type>bit
    varying(<replaceable>n</replaceable>)</type>, where
    <replaceable>n</replaceable> is a positive integer.
-->
ビット列とは1と0のビットが連続したものです。
ビットマスクを格納したり可視化するために使用されます。
SQLのビット型には2つあります。
<type>bit(<replaceable>n</replaceable>)</type>と<type>bit varying(<replaceable>n</replaceable>)</type>です。
ここで<replaceable>n</replaceable>は正の整数です。
   </para>

   <para>
<!--
    <type>bit</type> type data must match the length
    <replaceable>n</replaceable> exactly; it is an error to attempt to
    store shorter or longer bit strings.  <type>bit varying</type> data is
    of variable length up to the maximum length
    <replaceable>n</replaceable>; longer strings will be rejected.
    Writing <type>bit</type> without a length is equivalent to
    <literal>bit(1)</literal>, while <type>bit varying</type> without a length
    specification means unlimited length.
-->
<type>bit</type>型のデータは<replaceable>n</replaceable>で表される長さに正確に一致しなければなりません。
この長さより長いか短いビット列を格納しようとするとエラーになります。
<type>bit varying</type>型のデータは最大<replaceable>n</replaceable>までの可変長です。
最大長を超えるビット列は受け付けません。
長さ指定のない<type>bit</type>データ型は<literal>bit(1)</literal>データ型と同一で、長さ指定のない<type>bit varying</type>データ型は無限長を意味します。
   </para>

   <note>
    <para>
<!--
     If one explicitly casts a bit-string value to
     <type>bit(<replaceable>n</replaceable>)</type>, it will be truncated or
     zero-padded on the right to be exactly <replaceable>n</replaceable> bits,
     without raising an error.  Similarly,
     if one explicitly casts a bit-string value to
     <type>bit varying(<replaceable>n</replaceable>)</type>, it will be truncated
     on the right if it is more than <replaceable>n</replaceable> bits.
-->
ビット列の値を明示的に<type>bit(<replaceable>n</replaceable>)</type>にキャストすると、厳密に<replaceable>n</replaceable>ビットになるように、切り捨てられるか右側をゼロ詰めされ、エラーにはなりません。
同様に、ビット列の値を明示的に<type>bit varying(<replaceable>n</replaceable>)</type>にキャストすると、ビット数が<replaceable>n</replaceable>を超える場合は右側が切り捨てられます。
    </para>
   </note>

   <para>
<!--
    Refer to <xref
    linkend="sql-syntax-bit-strings"/> for information about the syntax
    of bit string constants.  Bit-logical operators and string
    manipulation functions are available; see <xref
    linkend="functions-bitstring"/>.
-->
ビット列定数に関する構文についての情報は<xref linkend="sql-syntax-bit-strings"/>を参照してください。
ビット論理演算子とビット列操作関数が利用可能ですが、<xref linkend="functions-bitstring"/>を参照してください。
   </para>

   <example>
<!--
    <title>Using the Bit String Types</title>
-->
    <title>ビット列データ型の使用</title>

<programlisting>
CREATE TABLE test (a BIT(3), b BIT VARYING(5));
INSERT INTO test VALUES (B'101', B'00');
INSERT INTO test VALUES (B'10', B'101');
<computeroutput>
ERROR:  bit string length 2 does not match type bit(3)
</computeroutput>
INSERT INTO test VALUES (B'10'::bit(3), B'101');
SELECT * FROM test;
<computeroutput>
  a  |  b
-----+-----
 101 | 00
 100 | 101
</computeroutput>
</programlisting>
   </example>

   <para>
<!--
    A bit string value requires 1 byte for each group of 8 bits, plus
    5 or 8 bytes overhead depending on the length of the string
    (but long values may be compressed or moved out-of-line, as explained
    in <xref linkend="datatype-character"/> for character strings).
-->
ビット列の値は8ビット毎に1バイト、さらにビット列長に応じた5または8バイトのオーバーヘッドが必要です。
（しかし、文字列に関する<xref linkend="datatype-character"/>で説明したように、長い値は圧縮または行外に移動する可能性があります。）
   </para>
  </sect1>

  <sect1 id="datatype-textsearch">
<!--
   <title>Text Search Types</title>
-->
   <title>テキスト検索に関する型</title>

   <indexterm zone="datatype-textsearch">
    <primary>full text search</primary>
    <secondary>data types</secondary>
   </indexterm>
   <indexterm zone="datatype-textsearch">
    <primary>全文検索</primary>
    <secondary>データ型</secondary>
   </indexterm>

   <indexterm zone="datatype-textsearch">
    <primary>text search</primary>
    <secondary>data types</secondary>
   </indexterm>
   <indexterm zone="datatype-textsearch">
    <primary>テキスト検索</primary>
    <secondary>データ型</secondary>
   </indexterm>

   <para>
<!--
    <productname>PostgreSQL</productname> provides two data types that
    are designed to support full text search, which is the activity of
    searching through a collection of natural-language <firstterm>documents</firstterm>
    to locate those that best match a <firstterm>query</firstterm>.
    The <type>tsvector</type> type represents a document in a form optimized
    for text search; the <type>tsquery</type> type similarly represents
    a text query.
    <xref linkend="textsearch"/> provides a detailed explanation of this
    facility, and <xref linkend="functions-textsearch"/> summarizes the
    related functions and operators.
-->
<productname>PostgreSQL</productname>は、自然言語の<firstterm>文書</firstterm>の集合を通して検索を行い<firstterm>問い合わせ</firstterm>に最も合致する文書を見つける機能である全文検索をサポートするために設計された2つのデータ型を提供します。
<type>tsvector</type>型はテキスト検索に最適化された形式で文書を表現します。
<type>tsquery</type>型は同様に問い合わせを表現します。
<xref linkend="textsearch"/>ではこの機能を詳しく説明します。
また、<xref linkend="functions-textsearch"/>では、関連する関数や演算子を要約します。
   </para>

   <sect2 id="datatype-tsvector">
    <title><type>tsvector</type></title>

    <indexterm>
     <primary>tsvector (data type)</primary>
    </indexterm>
    <indexterm>
     <primary>tsvector（データ型）</primary>
    </indexterm>

    <para>
<!--
     A <type>tsvector</type> value is a sorted list of distinct
     <firstterm>lexemes</firstterm>, which are words that have been
     <firstterm>normalized</firstterm> to merge different variants of the same word
     (see <xref linkend="textsearch"/> for details).  Sorting and
     duplicate-elimination are done automatically during input, as shown in
     this example:
-->
<type>tsvector</type>の値は重複がない<firstterm>語彙素</firstterm>のソート済みリストです。
語彙素とは同じ単語の変種をまとめるために<firstterm>正規化</firstterm>された単語です（詳細は<xref linkend="textsearch"/>を参照）。
以下の例に示すようにソートと重複除去は入力の際に自動的になされます。

<programlisting>
SELECT 'a fat cat sat on a mat and ate a fat rat'::tsvector;
                      tsvector
----------------------------------------------------
 'a' 'and' 'ate' 'cat' 'fat' 'mat' 'on' 'rat' 'sat'
</programlisting>

<!--
     To represent
     lexemes containing whitespace or punctuation, surround them with quotes:
-->
空白文字または句読点を含む語彙素を表現するには、引用符でくくってください。

<programlisting>
SELECT $$the lexeme '    ' contains spaces$$::tsvector;
                 tsvector
-------------------------------------------
 '    ' 'contains' 'lexeme' 'spaces' 'the'
</programlisting>

<!--
     (We use dollar-quoted string literals in this example and the next one
     to avoid the confusion of having to double quote marks within the
     literals.)  Embedded quotes and backslashes must be doubled:
-->
（この例と次の例では、リテラル内で引用符記号を二重にしなければならないことによる混乱を防ぐためにドル引用符付け文字列を使用します。）
引用符およびバックスラッシュが埋め込まれている場合は、以下のように二重にしなければなりません。

<programlisting>
SELECT $$the lexeme 'Joe''s' contains a quote$$::tsvector;
                    tsvector
------------------------------------------------
 'Joe''s' 'a' 'contains' 'lexeme' 'quote' 'the'
</programlisting>

<!--
     Optionally, integer <firstterm>positions</firstterm>
     can be attached to lexemes:
-->
オプションとして、語彙素に整数の<firstterm>位置</firstterm>を付けることもできます。

<programlisting>
SELECT 'a:1 fat:2 cat:3 sat:4 on:5 a:6 mat:7 and:8 ate:9 a:10 fat:11 rat:12'::tsvector;
                                  tsvector
-------------------------------------------------------------------&zwsp;------------
 'a':1,6,10 'and':8 'ate':9 'cat':3 'fat':2,11 'mat':7 'on':5 'rat':12 'sat':4
</programlisting>

<!--
     A position normally indicates the source word's location in the
     document.  Positional information can be used for
     <firstterm>proximity ranking</firstterm>.  Position values can
     range from 1 to 16383; larger numbers are silently set to 16383.
     Duplicate positions for the same lexeme are discarded.
-->
位置は通常、元の単語の文書中の位置を示します。
位置情報を<firstterm>近接順序</firstterm>に使用することができます。
位置の値は1から16383までで、これより大きな値は警告なく16383に設定されます。
同一語彙素に対する重複する位置項目は破棄されます。
    </para>

    <para>
<!--
     Lexemes that have positions can further be labeled with a
     <firstterm>weight</firstterm>, which can be <literal>A</literal>,
     <literal>B</literal>, <literal>C</literal>, or <literal>D</literal>.
     <literal>D</literal> is the default and hence is not shown on output:
-->
位置を持つ語彙素はさらに<firstterm>重み</firstterm>付きのラベルを付与することができます。
ラベルは<literal>A</literal>、<literal>B</literal>、<literal>C</literal>、<literal>D</literal>を取ることができます。
<literal>D</literal>はデフォルトですので、以下のように出力には現れません。

<programlisting>
SELECT 'a:1A fat:2B,4C cat:5D'::tsvector;
          tsvector
----------------------------
 'a':1A 'cat':5 'fat':2B,4C
</programlisting>

<!--
     Weights are typically used to reflect document structure, for example
     by marking title words differently from body words.  Text search
     ranking functions can assign different priorities to the different
     weight markers.
-->
典型的に重みは、例えば、表題の単語には本文の単語と異なる印をつけるといった、文書構造を反映させるために使用されます。
テキスト検索の順序付け関数は異なる重み印に異なる優先度を割り当てることができます。
    </para>

    <para>
<!--
     It is important to understand that the
     <type>tsvector</type> type itself does not perform any word
     normalization; it assumes the words it is given are normalized
     appropriately for the application.  For example,
-->
<type>tsvector</type>型自体は単語の正規化を行わないことを理解することは重要です。
与えられる単語はアプリケーションのために適切に正規化されていると仮定しています。
以下に例を示します。

<programlisting>
SELECT 'The Fat Rats'::tsvector;
      tsvector
--------------------
 'Fat' 'Rats' 'The'
</programlisting>

<!--
     For most English-text-searching applications the above words would
     be considered non-normalized, but <type>tsvector</type> doesn't care.
     Raw document text should usually be passed through
     <function>to_tsvector</function> to normalize the words appropriately
     for searching:
-->
ほとんどの英文テキスト検索アプリケーションでは、上の単語は正規化されていないとみなされますが、<type>tsvector</type>は気にしません。
検索用に単語を適切に正規化するために、生の文書テキストは通常<function>to_tsvector</function>経由で渡されます。

<programlisting>
SELECT to_tsvector('english', 'The Fat Rats');
   to_tsvector
-----------------
 'fat':2 'rat':3
</programlisting>

<!--
     Again, see <xref linkend="textsearch"/> for more detail.
-->
これについても、詳細は<xref linkend="textsearch"/>を参照してください。
    </para>

   </sect2>

   <sect2 id="datatype-tsquery">
    <title><type>tsquery</type></title>

    <indexterm>
     <primary>tsquery (data type)</primary>
    </indexterm>
    <indexterm>
     <primary>tsquery（データ型）</primary>
    </indexterm>

    <para>
<!--
     A <type>tsquery</type> value stores lexemes that are to be
     searched for, and can combine them using the Boolean operators
     <literal>&amp;</literal> (AND), <literal>|</literal> (OR), and
     <literal>!</literal> (NOT), as well as the phrase search operator
     <literal>&lt;-&gt;</literal> (FOLLOWED BY).  There is also a variant
     <literal>&lt;<replaceable>N</replaceable>&gt;</literal> of the FOLLOWED BY
     operator, where <replaceable>N</replaceable> is an integer constant that
     specifies the distance between the two lexemes being searched
     for.  <literal>&lt;-&gt;</literal> is equivalent to <literal>&lt;1&gt;</literal>.
-->
<type>tsquery</type>の値には検索される語彙素が格納されます。
それらは論理演算子<literal>&amp;</literal> (論理積)、<literal>|</literal> (論理和)、<literal>!</literal>(否定)および語句検索演算子<literal>&lt;-&gt;</literal>(FOLLOWED BY)を組み合わせることができます。
FOLLOWED BY演算子には<literal>&lt;<replaceable>N</replaceable>&gt;</literal>という変化形もあり、<replaceable>N</replaceable>は２つの検索される語彙素の距離を指定する数値型の定数です。
<literal>&lt;-&gt;</literal>と<literal>&lt;1&gt;</literal>は同じです。
    </para>

    <para>
<!--
     Parentheses can be used to enforce grouping of these operators.
     In the absence of parentheses, <literal>!</literal> (NOT) binds most tightly,
     <literal>&lt;-&gt;</literal> (FOLLOWED BY) next most tightly, then
     <literal>&amp;</literal> (AND), with <literal>|</literal> (OR) binding
     the least tightly.
-->
括弧を使用して演算子を強制的にグループ化することができます。
括弧が無い場合、<literal>!</literal> (NOT)が最も強く結合し、<literal>&lt;-&gt;</literal> (FOLLOWED BY)が次に強く結合します。
次いで、<literal>&amp;</literal> (AND)の結合が強く、 <literal>|</literal> (OR)の結合が最も弱くなります。
    </para>

    <para>
<!--
     Here are some examples:
-->
以下に例を示します：

<programlisting>
SELECT 'fat &amp; rat'::tsquery;
    tsquery
---------------
 'fat' &amp; 'rat'

SELECT 'fat &amp; (rat | cat)'::tsquery;
          tsquery
---------------------------
 'fat' &amp; ( 'rat' | 'cat' )

SELECT 'fat &amp; rat &amp; ! cat'::tsquery;
        tsquery
------------------------
 'fat' &amp; 'rat' &amp; !'cat'
</programlisting>
    </para>

    <para>
<!--
     Optionally, lexemes in a <type>tsquery</type> can be labeled with
     one or more weight letters, which restricts them to match only
     <type>tsvector</type> lexemes with one of those weights:
-->
省略することもできますが、<type>tsquery</type>内の語彙素に1つ以上の重み文字でラベルを付けることができます。
こうすると、これらの重みを持つ<type>tsvector</type>語彙素のみに一致するように制限することになります。

<programlisting>
SELECT 'fat:ab &amp; cat'::tsquery;
    tsquery
------------------
 'fat':AB &amp; 'cat'
</programlisting>
    </para>

    <para>
<!--
     Also, lexemes in a <type>tsquery</type> can be labeled with <literal>*</literal>
     to specify prefix matching:
-->
同時に、<type>tsquery</type>内の語彙素は、前方一致を指定するため<literal>*</literal>でラベルを付けることができます。
<programlisting>
SELECT 'super:*'::tsquery;
  tsquery
-----------
 'super':*
</programlisting>
<!--
     This query will match any word in a <type>tsvector</type> that begins
     with <quote>super</quote>.
-->
この問い合わせでは<quote>super</quote>で始まる<type>tsvector</type>中の全ての言葉と一致します。
    </para>

    <para>
<!--
     Quoting rules for lexemes are the same as described previously for
     lexemes in <type>tsvector</type>; and, as with <type>tsvector</type>,
     any required normalization of words must be done before converting
     to the <type>tsquery</type> type.  The <function>to_tsquery</function>
     function is convenient for performing such normalization:
-->
語彙素の引用符規則は前に説明した<type>tsvector</type>における語彙素と同じです。
また、<type>tsvector</type>同様、必要な単語の正規化は<type>tsquery</type>型に変換する前に行う必要があります。
こうした正規化の実行には<function>to_tsquery</function>関数が簡便です。

<programlisting>
SELECT to_tsquery('Fat:ab &amp; Cats');
    to_tsquery
------------------
 'fat':AB &amp; 'cat'
</programlisting>

<!--
     Note that <function>to_tsquery</function> will process prefixes in the same way
     as other words, which means this comparison returns true:
-->
<function>to_tsquery</function>は他の言葉と同じように接頭辞を扱うことに注意してください。
以下の比較の例ではtrueを返します。

<programlisting>
SELECT to_tsvector( 'postgraduate' ) @@ to_tsquery( 'postgres:*' );
 ?column?
----------
 t
</programlisting>
<!--
     because <literal>postgres</literal> gets stemmed to <literal>postgr</literal>:
-->
これは<literal>postgres</literal>には<literal>postgr</literal>の語幹を含んでいるためです。
<programlisting>
SELECT to_tsvector( 'postgraduate' ), to_tsquery( 'postgres:*' );
  to_tsvector  | to_tsquery
---------------+------------
 'postgradu':1 | 'postgr':*
</programlisting>
<!--
     which will match the stemmed form of <literal>postgraduate</literal>.
-->
これは<literal>postgraduate</literal>の語幹の形と一致します。
    </para>

   </sect2>

  </sect1>

  <sect1 id="datatype-uuid">
<!--
   <title><acronym>UUID</acronym> Type</title>
-->
   <title><acronym>UUID</acronym>型</title>

   <indexterm zone="datatype-uuid">
    <primary>UUID</primary>
   </indexterm>

   <para>
<!--
    The data type <type>uuid</type> stores Universally Unique Identifiers
    (UUID) as defined by <ulink url="https://datatracker.ietf.org/doc/html/rfc4122">RFC 4122</ulink>,
    ISO/IEC 9834-8:2005, and related standards.
    (Some systems refer to this data type as a globally unique identifier, or
    GUID,<indexterm><primary>GUID</primary></indexterm> instead.)  This
    identifier is a 128-bit quantity that is generated by an algorithm chosen
    to make it very unlikely that the same identifier will be generated by
    anyone else in the known universe using the same algorithm.  Therefore,
    for distributed systems, these identifiers provide a better uniqueness
    guarantee than sequence generators, which
    are only unique within a single database.
-->
<type>uuid</type>データ型は、<ulink url="https://datatracker.ietf.org/doc/html/rfc4122">RFC 4122</ulink>:、ISO/IEC 9834-8:2005および関連する標準に従う、汎用一意識別子（UUID）を格納します。
（一部のシステムでは、このデータ型をグローバル一意識別子（GUID<indexterm><primary>GUID</primary></indexterm>）と呼んでいます。）
この識別子は、同一のアルゴリズムを使用しても既知の世界上の他の誰かが同一識別子が生成される可能性がほとんどないように選択されたアルゴリズムで生成された128ビット量の値です。
したがって、分散システムにおいて、これら識別子は、単一データベース内でしか一意にならないシーケンスジェネレータよりも優れた一意性保証を提供します。
   </para>

   <para>
<!--
    A UUID is written as a sequence of lower-case hexadecimal digits,
    in several groups separated by hyphens, specifically a group of 8
    digits followed by three groups of 4 digits followed by a group of
    12 digits, for a total of 32 digits representing the 128 bits.  An
    example of a UUID in this standard form is:
-->
UUIDは、小文字の16進数表記桁の並びをいくつかのグループでハイフンで区切って表現されます。
具体的には、8桁のグループが1つ、4桁のグループが3つ、次いで、12桁のグループが1つとなり、合計32桁で128ビットを表します。
この標準形式のUUIDの例を以下に示します。
<programlisting>
a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11
</programlisting>
<!--
    <productname>PostgreSQL</productname> also accepts the following
    alternative forms for input:
    use of upper-case digits, the standard format surrounded by
    braces, omitting some or all hyphens, adding a hyphen after any
    group of four digits.  Examples are:
-->
また、<productname>PostgreSQL</productname>は入力の別形式として、桁を大文字表記したもの、標準形式を中括弧でくくったもの、いくつかまたはすべてのハイフンを省略したもの、４桁ごとのグループの間の任意の箇所にハイフンを付加したものも受け付けます。
以下に例を示します。
<programlisting>
A0EEBC99-9C0B-4EF8-BB6D-6BB9BD380A11
{a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11}
a0eebc999c0b4ef8bb6d6bb9bd380a11
a0ee-bc99-9c0b-4ef8-bb6d-6bb9-bd38-0a11
{a0eebc99-9c0b4ef8-bb6d6bb9-bd380a11}
</programlisting>
<!--
    Output is always in the standard form.
-->
出力は常に標準形式になります。
   </para>

   <para>
<!--
    See <xref linkend="functions-uuid"/> for how to generate a UUID in
    <productname>PostgreSQL</productname>.
-->
<productname>PostgreSQL</productname>でUUIDを生成する方法は<xref linkend="functions-uuid"/>を確認してください。
   </para>
  </sect1>

  <sect1 id="datatype-xml">
<!--
   <title><acronym>XML</acronym> Type</title>
-->
   <title><acronym>XML</acronym>型</title>

   <indexterm zone="datatype-xml">
    <primary>XML</primary>
   </indexterm>

   <para>
<!--
    The <type>xml</type> data type can be used to store XML data.  Its
    advantage over storing XML data in a <type>text</type> field is that it
    checks the input values for well-formedness, and there are support
    functions to perform type-safe operations on it; see <xref
    linkend="functions-xml"/>.  Use of this data type requires the
    installation to have been built with <command>configure
    &#45;-with-libxml</command>.
-->
<type>xml</type>データ型を使用して、XMLデータを格納することができます。
<type>text</type>型のフィールドにXMLデータを格納する方法より、入力された値が整形式かどうかを検査する利点があります。
また、型を安全に操作するサポート関数があります。
<xref linkend="functions-xml"/>を参照してください。
このデータ型を使用するためには、インストレーションが<command>configure --with-libxml</command>で構築されていることが必要です。
   </para>

   <para>
<!--
    The <type>xml</type> type can store well-formed
    <quote>documents</quote>, as defined by the XML standard, as well
    as <quote>content</quote> fragments, which are defined by reference
    to the more permissive
    <ulink url="https://www.w3.org/TR/2010/REC-xpath-datamodel-20101214/#DocumentNode"><quote>document node</quote></ulink>
    of the XQuery and XPath data model.
    Roughly, this means that content fragments can have
    more than one top-level element or character node.  The expression
    <literal><replaceable>xmlvalue</replaceable> IS DOCUMENT</literal>
    can be used to evaluate whether a particular <type>xml</type>
    value is a full document or only a content fragment.
-->
<type>xml</type>型は、XML標準で定義された整形式の<quote>文書</quote>およびXQueryとXPathデータモデルのより寛容な<ulink url="https://www.w3.org/TR/2010/REC-xpath-datamodel-20101214/#DocumentNode"><quote>文書ノード</quote></ulink>を参照して定義される<quote>コンテンツ</quote>フラグメントを格納できます。
大雑把に言うと、これは、コンテンツフラグメントが2つ以上の最上位要素や文字ノードを持つことができることを意味します。
<literal><replaceable>xmlvalue</replaceable> IS DOCUMENT</literal>という式を使用して、特定の<type>xml</type>値が完全な文書か単なるコンテンツフラグメントか評価することができます。
   </para>

   <para>
<!--
    Limits and compatibility notes for the <type>xml</type> data type
    can be found in <xref linkend="xml-limits-conformance"/>.
-->
<type>xml</type>データ型の制限と互換性に関する注意事項は、 <xref linkend="xml-limits-conformance"/>から確認できます。
   </para>

   <sect2 id="datatype-xml-creating">
<!--
    <title>Creating XML Values</title>
-->
    <title>XML値の作成</title>
   <para>
<!--
    To produce a value of type <type>xml</type> from character data,
    use the function
    <function>xmlparse</function>:<indexterm><primary>xmlparse</primary></indexterm>
-->
文字データから<type>xml</type>型の値を生成するためには、<function>xmlparse</function>関数を使用してください。
<indexterm><primary>xmlparse</primary></indexterm>
<synopsis>
XMLPARSE ( { DOCUMENT | CONTENT } <replaceable>value</replaceable>)
</synopsis>
<!--
    Examples:
-->
例：
<programlisting><![CDATA[
XMLPARSE (DOCUMENT '<?xml version="1.0"?><book><title>Manual</title><chapter>...</chapter></book>')
XMLPARSE (CONTENT 'abc<foo>bar</foo><bar>foo</bar>')
]]></programlisting>
<!--
    While this is the only way to convert character strings into XML
    values according to the SQL standard, the PostgreSQL-specific
    syntaxes:
-->
標準SQLに従って文字列をXML値に変換するためにはこの方法しかありませんが、次のようなPostgreSQL固有の構文も使用することができます。
<programlisting><![CDATA[
xml '<foo>bar</foo>'
'<foo>bar</foo>'::xml
]]></programlisting>
<!--
    can also be used.
-->
   </para>

   <para>
<!--
    The <type>xml</type> type does not validate input values
    against a document type declaration
    (DTD),<indexterm><primary>DTD</primary></indexterm>
    even when the input value specifies a DTD.
    There is also currently no built-in support for validating against
    other XML schema languages such as XML Schema.
-->
<type>xml</type>型では文書型定義（DTD）に対して入力値を検証することは、入力値がDTDを指定していたとしても、行いません。
<indexterm><primary>DTD</primary></indexterm>
また同様に、現時点ではXML Schemaなどの他のXMLスキーマ言語に対する検証サポートも組み込まれていません。
   </para>

   <para>
<!--
    The inverse operation, producing a character string value from
    <type>xml</type>, uses the function
    <function>xmlserialize</function>:<indexterm><primary>xmlserialize</primary></indexterm>
-->
<type>xml</type>から文字列値を生成するという逆演算では<function>xmlserialize</function>関数を使用してください。
<indexterm><primary>xmlserialize</primary></indexterm>
<synopsis>
XMLSERIALIZE ( { DOCUMENT | CONTENT } <replaceable>value</replaceable> AS <replaceable>type</replaceable> [ [ NO ] INDENT ] )
</synopsis>
<!--
    <replaceable>type</replaceable> can be
    <type>character</type>, <type>character varying</type>, or
    <type>text</type> (or an alias for one of those).  Again, according
    to the SQL standard, this is the only way to convert between type
    <type>xml</type> and character types, but PostgreSQL also allows
    you to simply cast the value.
-->
ここで、<replaceable>type</replaceable>は、<type>character</type>、<type>character varying</type>、<type>text</type>（またはこれらの別名）を取ることができます。
この場合も、標準SQLに従って<type>xml</type>と文字列型間の変換を行うためにはこの方法しかありません。
PostgreSQLでは単に値をキャストすることが可能です。
   </para>

   <para>
<!--
    The <literal>INDENT</literal> option causes the result to be
    pretty-printed, while <literal>NO INDENT</literal> (which is the
    default) just emits the original input string.  Casting to a character
    type likewise produces the original string.
-->
<literal>INDENT</literal>オプションを指定すると、結果は整形されます。<literal>NO INDENT</literal>(デフォルトです)はオリジナルの入力文字列を単に出力します。
文字列型にキャストすると、同様にオリジナル文字列が生成されます。
   </para>

   <para>
<!--
    When a character string value is cast to or from type
    <type>xml</type> without going through <type>XMLPARSE</type> or
    <type>XMLSERIALIZE</type>, respectively, the choice of
    <literal>DOCUMENT</literal> versus <literal>CONTENT</literal> is
    determined by the <quote>XML option</quote>
    <indexterm><primary>XML option</primary></indexterm>
    session configuration parameter, which can be set using the
    standard command:
-->
<type>XMLPARSE</type>や<type>XMLSERIALIZE</type>を使わずに文字列値と<type>xml</type>との間をキャストした場合、<literal>DOCUMENT</literal>か<literal>CONTENT</literal>かという選択が<quote>XML option</quote>セッション設定パラメータによって決定されます。
<indexterm><primary>XML option</primary></indexterm>
このパラメータは標準コマンド
<synopsis>
SET XML OPTION { DOCUMENT | CONTENT };
</synopsis>
<!--
    or the more PostgreSQL-like syntax
-->
または、よりPostgreSQLらしい構文
<synopsis>
SET xmloption TO { DOCUMENT | CONTENT };
</synopsis>
を使用して設定することができます。
<!--
    The default is <literal>CONTENT</literal>, so all forms of XML
    data are allowed.
-->
デフォルトは<literal>CONTENT</literal>ですので、すべての書式のXMLデータを扱うことができます。
   </para>

   </sect2>

   <sect2 id="datatype-xml-encoding-handling">
<!--
    <title>Encoding Handling</title>
-->
    <title>符号化方式の取扱い</title>
   <para>
<!--
    Care must be taken when dealing with multiple character encodings
    on the client, server, and in the XML data passed through them.
    When using the text mode to pass queries to the server and query
    results to the client (which is the normal mode), PostgreSQL
    converts all character data passed between the client and the
    server and vice versa to the character encoding of the respective
    end; see <xref linkend="multibyte"/>.  This includes string
    representations of XML values, such as in the above examples.
    This would ordinarily mean that encoding declarations contained in
    XML data can become invalid as the character data is converted
    to other encodings while traveling between client and server,
    because the embedded encoding declaration is not changed.  To cope
    with this behavior, encoding declarations contained in
    character strings presented for input to the <type>xml</type> type
    are <emphasis>ignored</emphasis>, and content is assumed
    to be in the current server encoding.  Consequently, for correct
    processing, character strings of XML data must be sent
    from the client in the current client encoding.  It is the
    responsibility of the client to either convert documents to the
    current client encoding before sending them to the server, or to
    adjust the client encoding appropriately.  On output, values of
    type <type>xml</type> will not have an encoding declaration, and
    clients should assume all data is in the current client
    encoding.
-->
クライアント側、サーバ側、および、これらを経由してやり取りされるXMLデータ内部で複数の文字符号化方式を扱う場合には注意が必要です。
テキストモードを使用してサーバに問い合わせを渡し、そしてクライアントに問い合わせ結果を渡す場合（これが通常のモードです）、PostgreSQLは、クライアントからサーバ、サーバからクライアントでやり取りされるすべての文字データを受信側の文字符号化方式に変換します。
<xref linkend="multibyte"/>を参照してください。
これには上の例のようなXML値の文字列表現も含まれます。
これは通常、埋め込まれたencoding宣言は変更されずに、クライアント/サーバ間でやり取りされる間に文字データが他方の符号化方式に変換されてしまうので、XMLデータ内のencodingが無効になる可能性があることを意味します。
この動作に対処するため、<type>xml</type>型の入力として表現された文字列に含まれているencoding宣言は<emphasis>無視</emphasis>され、その内容は常にサーバの現在の符号化方式になっているものと仮定されます。
したがって、正しく処理するためには、XMLデータにおける文字列をクライアントの現在の符号化方式で送信しなければなりません。
サーバに送信する前に文書を現在のクライアントの符号化方式に変換するか、クライアントの符号化方式を適切に調節するかは、クライアントの責任です。
出力では<type>xml</type>型の値はencoding宣言を持ちません。
クライアントはすべてのデータが現在のクライアントの符号化方式であることを前提としなければなりません。
   </para>

   <para>
<!--
    When using binary mode to pass query parameters to the server
    and query results back to the client, no encoding conversion
    is performed, so the situation is different.  In this case, an
    encoding declaration in the XML data will be observed, and if it
    is absent, the data will be assumed to be in UTF-8 (as required by
    the XML standard; note that PostgreSQL does not support UTF-16).
    On output, data will have an encoding declaration
    specifying the client encoding, unless the client encoding is
    UTF-8, in which case it will be omitted.
-->
バイナリモードを使用して、問い合わせパラメータをサーバに渡し、そして問い合わせ結果をクライアントに返す場合、符号化方式の変換は行われません。
このため状況は異なります。
この場合、XMLデータ内のencoding宣言が認識され、もし存在しなければ、データがUTF-8であると仮定されます。
（XML標準の要求通りです。
PostgreSQLはUTF-16をサポートしていないことに注意してください。）
出力では、データはクライアントの符号化方式を指定したencoding宣言を持ちます。
ただし、もしクライアントの符号化方式がUTF-8の場合はencoding宣言は省略されます。
<!-- 原文は"character set"ですが、"encoding"と混同しているとみなして「符号化方式」と訳しました -->
   </para>

   <para>
<!--
    Needless to say, processing XML data with PostgreSQL will be less
    error-prone and more efficient if the XML data encoding, client encoding,
    and server encoding are the same.  Since XML data is internally
    processed in UTF-8, computations will be most efficient if the
    server encoding is also UTF-8.
-->
言うまでもありませんが、PostgreSQLを使用したXML処理では、XMLデータの符号化方式、クライアントの符号化方式、サーバの符号化方式が同じ場合にエラーが起こりづらく、より効率的です。
XMLデータは内部的にUTF-8として処理されますので、サーバの符号化方式が同一のUTF-8である場合、最も効率が上がります。
   </para>

   <caution>
    <para>
<!--
     Some XML-related functions may not work at all on non-ASCII data
     when the server encoding is not UTF-8.  This is known to be an
     issue for <function>xmltable()</function> and <function>xpath()</function> in particular.
-->
サーバ符号化方式がUTF-8でない場合、いくつかのXMLに関係した関数は非ASCIIデータに対して全く機能しないことがあります。
これは特に<function>xmltable()</function>と<function>xpath()</function>に対する問題として知られています。
    </para>
   </caution>
   </sect2>

   <sect2 id="datatype-xml-accessing-xml-values">
<!--
   <title>Accessing XML Values</title>
-->
   <title>XML値へのアクセス</title>

   <para>
<!--
    The <type>xml</type> data type is unusual in that it does not
    provide any comparison operators.  This is because there is no
    well-defined and universally useful comparison algorithm for XML
    data.  One consequence of this is that you cannot retrieve rows by
    comparing an <type>xml</type> column against a search value.  XML
    values should therefore typically be accompanied by a separate key
    field such as an ID.  An alternative solution for comparing XML
    values is to convert them to character strings first, but note
    that character string comparison has little to do with a useful
    XML comparison method.
-->
<type>xml</type>データ型は、比較演算子をまったく提供しないというところが他と異なります。
これは、XMLデータに対し、よく定義され、誰にとっても有用な比較アルゴリズムが存在しないためです。
この結果、<type>xml</type>列を検索値と比べて行を取り出すことはできません。
したがって通常XML値には、IDなどの別のキーフィールドを一般的に付属させなければなりません。
XML値の比較を行うもうひとつの方法は、文字列に一度変換することです。
しかし、文字列比較は有用なXML比較方法といえないことに注意してください。
   </para>

   <para>
<!--
    Since there are no comparison operators for the <type>xml</type>
    data type, it is not possible to create an index directly on a
    column of this type.  If speedy searches in XML data are desired,
    possible workarounds include casting the expression to a
    character string type and indexing that, or indexing an XPath
    expression.  Of course, the actual query would have to be adjusted
    to search by the indexed expression.
-->
<type>xml</type>データ型用の比較演算子がありませんので、この型の列に直接インデックスを作成することはできません。
XMLデータを高速に検索することが望まれるなら、その表現を文字列型にキャストし、それをインデックス付けするか、または、XPath式をインデックス付けするかという対策をとることができます。
当然ながら、インデックス付けされた式で検索されるよう実際の問い合わせを調整する必要があります。
   </para>

   <para>
<!--
    The text-search functionality in PostgreSQL can also be used to speed
    up full-document searches of XML data.  The necessary
    preprocessing support is, however, not yet available in the PostgreSQL
    distribution.
-->
PostgreSQLのテキスト検索機能を使用して、XMLデータの全文検索速度をあげることもできます。
しかし、PostgreSQL配布物では必要な前処理を未だサポートしていません。
   </para>
   </sect2>
  </sect1>

  &json;

  &array;

  &rowtypes;

  &rangetypes;

  <sect1 id="domains">
<!--
   <title>Domain Types</title>
-->
   <title>ドメイン型</title>

   <indexterm zone="domains">
    <primary>domain</primary>
   </indexterm>
   <indexterm zone="domains">
    <primary>ドメイン</primary>
   </indexterm>

   <indexterm zone="domains">
    <primary>data type</primary>
    <secondary>domain</secondary>
   </indexterm>
   <indexterm zone="domains">
    <primary>データ型</primary>
    <secondary>ドメイン</secondary>
   </indexterm>

   <para>
<!--
    A <firstterm>domain</firstterm> is a user-defined data type that is
    based on another <firstterm>underlying type</firstterm>.  Optionally,
    it can have constraints that restrict its valid values to a subset of
    what the underlying type would allow.  Otherwise it behaves like the
    underlying type &mdash; for example, any operator or function that
    can be applied to the underlying type will work on the domain type.
    The underlying type can be any built-in or user-defined base type,
    enum type, array type, composite type, range type, or another domain.
-->
<firstterm>ドメイン</firstterm>は他の<firstterm>基となる型</firstterm>を元にしたユーザ定義のデータ型です。
オプションとして基となる型が許可する型のサブセットの有効な値を制限する制約を持つことができます。
他は基となる型のように振る舞います。&mdash;例えば、基となる型に適用できる演算子や関数はドメイン型でも動作します。
ビルトインもしくはユーザが定義した基本型や列挙型、配列型、複合化型、範囲型もしくは他のドメインが基となる型になれます。
   </para>

   <para>
<!--
    For example, we could create a domain over integers that accepts only
    positive integers:
-->
例として正の整数のみを許容する整数型のドメインを作成します。
<programlisting>
CREATE DOMAIN posint AS integer CHECK (VALUE &gt; 0);
CREATE TABLE mytable (id posint);
INSERT INTO mytable VALUES(1);   -- works
INSERT INTO mytable VALUES(-1);  -- fails
</programlisting>
   </para>

   <para>
<!--
    When an operator or function of the underlying type is applied to a
    domain value, the domain is automatically down-cast to the underlying
    type.  Thus, for example, the result of <literal>mytable.id - 1</literal>
    is considered to be of type <type>integer</type> not <type>posint</type>.
    We could write <literal>(mytable.id - 1)::posint</literal> to cast the
    result back to <type>posint</type>, causing the domain's constraints
    to be rechecked.  In this case, that would result in an error if the
    expression had been applied to an <structfield>id</structfield> value of
    1.  Assigning a value of the underlying type to a field or variable of
    the domain type is allowed without writing an explicit cast, but the
    domain's constraints will be checked.
-->
基となる型の演算子や関数にドメインの値が適用されると、ドメインは自動的に基となる型にダウンキャストされます。
このため、例えば、<literal>mytable.id - 1</literal>の結果は<type>posint</type>ではなく、<type>integer</type>型として考えられます。
ドメイン制約の再チェックが発生するので<type>posint</type>型にキャストするために<literal>(mytable.id - 1)::posint</literal>と記述することができます。
このケースでは、式に<structfield>id</structfield>の値として1が与えられると結果はエラーになるでしょう。
明確なキャストを書かずにドメイン型の変数やフィールドに基となる型の値を代入することが許容されていますが、ドメインの制約はチェックされます。
   </para>

   <para>
<!--
    For additional information see <xref linkend="sql-createdomain"/>.
-->
より詳細な情報は<xref linkend="sql-createdomain"/>を確認ください。
   </para>
  </sect1>

  <sect1 id="datatype-oid">
<!--
   <title>Object Identifier Types</title>
-->
   <title>オブジェクト識別子データ型</title>

   <indexterm zone="datatype-oid">
    <primary>object identifier</primary>
    <secondary>data type</secondary>
   </indexterm>
   <indexterm zone="datatype-oid">
    <primary>オブジェクト識別子</primary>
    <secondary>データ型</secondary>
   </indexterm>

   <indexterm zone="datatype-oid">
    <primary>oid</primary>
   </indexterm>

   <indexterm zone="datatype-oid">
    <primary>regclass</primary>
   </indexterm>

   <indexterm zone="datatype-oid">
    <primary>regcollation</primary>
   </indexterm>

   <indexterm zone="datatype-oid">
    <primary>regconfig</primary>
   </indexterm>

   <indexterm zone="datatype-oid">
    <primary>regdictionary</primary>
   </indexterm>

   <indexterm zone="datatype-oid">
    <primary>regnamespace</primary>
   </indexterm>

   <indexterm zone="datatype-oid">
    <primary>regoper</primary>
   </indexterm>

   <indexterm zone="datatype-oid">
    <primary>regoperator</primary>
   </indexterm>

   <indexterm zone="datatype-oid">
    <primary>regproc</primary>
   </indexterm>

   <indexterm zone="datatype-oid">
    <primary>regprocedure</primary>
   </indexterm>

   <indexterm zone="datatype-oid">
    <primary>regrole</primary>
   </indexterm>

   <indexterm zone="datatype-oid">
    <primary>regtype</primary>
   </indexterm>

   <indexterm zone="datatype-oid">
    <primary>xid8</primary>
   </indexterm>

   <indexterm zone="datatype-oid">
    <primary>cid</primary>
   </indexterm>

   <indexterm zone="datatype-oid">
    <primary>tid</primary>
   </indexterm>

   <indexterm zone="datatype-oid">
    <primary>xid</primary>
   </indexterm>

   <para>
<!--
    Object identifiers (OIDs) are used internally by
    <productname>PostgreSQL</productname> as primary keys for various
    system tables.
    Type <type>oid</type> represents an object identifier.  There are also
    several alias types for <type>oid</type>, each
    named <type>reg<replaceable>something</replaceable></type>.
    <xref linkend="datatype-oid-table"/> shows an
    overview.
-->
オブジェクト識別子（OID）は<productname>PostgreSQL</productname>の内部で様々なシステムテーブルの主キーとして使用されます。
<type>oid</type>データ型はオブジェクト識別子を表します。
<type>oid</type>には別名型もいくつかあります。
<type>reg<replaceable>何とか</replaceable></type>とそれぞれ名付けられた<type>oid</type>の様々なエイリアスの型は<xref linkend="datatype-oid-table"/>からその概要を見ることができます。
   </para>

   <para>
<!--
    The <type>oid</type> type is currently implemented as an unsigned
    four-byte integer.  Therefore, it is not large enough to provide
    database-wide uniqueness in large databases, or even in large
    individual tables.
-->
<type>oid</type>データ型は現在、符号なし4バイト整数として実装されています。
このため、大きなデータベース内でデータベース単位での一意性や個別の大きなテーブルで一意性を提供するためには十分な大きさではありません。
   </para>

   <para>
<!--
    The <type>oid</type> type itself has few operations beyond comparison.
    It can be cast to integer, however, and then manipulated using the
    standard integer operators.  (Beware of possible
    signed-versus-unsigned confusion if you do this.)
-->
<type>oid</type>データ型自体は、比較以外の演算はほとんど行いません。
しかし、整数としてキャストすることもでき、その場合標準の整数演算子を使用して操作することができます。
（これを行うと、符号付きと符号なしの間で混乱が起きかねないことに注意してください。）
   </para>

   <para>
<!--
    The OID alias types have no operations of their own except
    for specialized input and output routines.  These routines are able
    to accept and display symbolic names for system objects, rather than
    the raw numeric value that type <type>oid</type> would use.  The alias
    types allow simplified lookup of OID values for objects.  For example,
    to examine the <structname>pg_attribute</structname> rows related to a table
    <literal>mytable</literal>, one could write:
-->
OIDの別名データ型は、専用の入出力ルーチン以外には演算を行いません。
これらのルーチンでは、<type>oid</type>型が使用するような未加工の数値ではなく、システムオブジェクト用のシンボル名を受け入れたり表示したりできます。
別名データ型により、オブジェクトのOID値の検索が簡単になります。
例えば、<literal>mytable</literal>テーブルに関連した<structname>pg_attribute</structname>行を確認するには、以下のように記述することができます。
<programlisting>
SELECT * FROM pg_attribute WHERE attrelid = 'mytable'::regclass;
</programlisting>
<!--
    rather than:
-->
次のように記述する必要はありません。
<programlisting>
SELECT * FROM pg_attribute
  WHERE attrelid = (SELECT oid FROM pg_class WHERE relname = 'mytable');
</programlisting>
<!--
    While that doesn't look all that bad by itself, it's still oversimplified.
    A far more complicated sub-select would be needed to
    select the right OID if there are multiple tables named
    <literal>mytable</literal> in different schemas.
    The <type>regclass</type> input converter handles the table lookup according
    to the schema path setting, and so it does the <quote>right thing</quote>
    automatically.  Similarly, casting a table's OID to
    <type>regclass</type> is handy for symbolic display of a numeric OID.
-->
後者もそう悪くないように見えますが、これは過度に単純化されています。
異なるスキーマに<literal>mytable</literal>テーブルが複数ある場合には、正しいOIDを選択するために、より複雑な副SELECTが必要となります。
<type>regclass</type>入力変換ではスキーマパスの設定に従ってテーブル検索を扱いますので、自動的に<quote>正しい検索</quote>を行います。
同様に、テーブルのOIDを<type>regclass</type>にキャストすることは、数値のOIDのシンボル表示に便利です。
   </para>

    <table id="datatype-oid-table">
<!--
     <title>Object Identifier Types</title>
-->
     <title>オブジェクト識別子データ型</title>
     <tgroup cols="4">
      <thead>
       <row>
<!--
        <entry>Name</entry>
        <entry>References</entry>
        <entry>Description</entry>
        <entry>Value Example</entry>
-->
        <entry>型名</entry>
        <entry>参照</entry>
        <entry>説明</entry>
        <entry>値の例</entry>
       </row>
      </thead>

      <tbody>

       <row>
        <entry><type>oid</type></entry>
<!--
        <entry>any</entry>
        <entry>numeric object identifier</entry>
-->
        <entry>すべて</entry>
        <entry>数値オブジェクト識別子</entry>
        <entry><literal>564182</literal></entry>
       </row>

       <row>
        <entry><type>regclass</type></entry>
        <entry><structname>pg_class</structname></entry>
<!--
        <entry>relation name</entry>
-->
        <entry>リレーション名</entry>
        <entry><literal>pg_type</literal></entry>
       </row>

       <row>
        <entry><type>regcollation</type></entry>
        <entry><structname>pg_collation</structname></entry>
<!--
        <entry>collation name</entry>
-->
        <entry>照合名</entry>
        <entry><literal>"POSIX"</literal></entry>
       </row>

       <row>
        <entry><type>regconfig</type></entry>
        <entry><structname>pg_ts_config</structname></entry>
<!--
        <entry>text search configuration</entry>
-->
        <entry>テキスト検索設定</entry>
        <entry><literal>english</literal></entry>
       </row>

       <row>
        <entry><type>regdictionary</type></entry>
        <entry><structname>pg_ts_dict</structname></entry>
<!--
        <entry>text search dictionary</entry>
-->
        <entry>テキスト検索辞書</entry>
        <entry><literal>simple</literal></entry>
       </row>

       <row>
        <entry><type>regnamespace</type></entry>
        <entry><structname>pg_namespace</structname></entry>
<!--
        <entry>namespace name</entry>
-->
        <entry>名前空間名</entry>
        <entry><literal>pg_catalog</literal></entry>
       </row>

       <row>
        <entry><type>regoper</type></entry>
        <entry><structname>pg_operator</structname></entry>
<!--
        <entry>operator name</entry>
-->
        <entry>演算子名</entry>
        <entry><literal>+</literal></entry>
       </row>

       <row>
        <entry><type>regoperator</type></entry>
        <entry><structname>pg_operator</structname></entry>
<!--
        <entry>operator with argument types</entry>
-->
        <entry>引数の型を持つ演算子</entry>
        <entry><literal>*(integer,&zwsp;integer)</literal>
         or <literal>-(NONE,&zwsp;integer)</literal></entry>
       </row>

       <row>
        <entry><type>regproc</type></entry>
        <entry><structname>pg_proc</structname></entry>
<!--
        <entry>function name</entry>
-->
        <entry>関数名</entry>
        <entry><literal>sum</literal></entry>
       </row>

       <row>
        <entry><type>regprocedure</type></entry>
        <entry><structname>pg_proc</structname></entry>
<!--
        <entry>function with argument types</entry>
-->
        <entry>引数の型を持つ関数</entry>
        <entry><literal>sum(int4)</literal></entry>
       </row>

       <row>
        <entry><type>regrole</type></entry>
        <entry><structname>pg_authid</structname></entry>
<!--
        <entry>role name</entry>
-->
        <entry>ロール名</entry>
        <entry><literal>smithee</literal></entry>
       </row>

       <row>
        <entry><type>regtype</type></entry>
        <entry><structname>pg_type</structname></entry>
<!--
        <entry>data type name</entry>
-->
        <entry>データ型の名前</entry>
        <entry><literal>integer</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
<!--
    All of the OID alias types for objects that are grouped by namespace
    accept schema-qualified names, and will
    display schema-qualified names on output if the object would not
    be found in the current search path without being qualified.
    For example, <literal>myschema.mytable</literal> is acceptable input
    for <type>regclass</type> (if there is such a table).  That value
    might be output as <literal>myschema.mytable</literal>, or
    just <literal>mytable</literal>, depending on the current search path.
    The <type>regproc</type> and <type>regoper</type> alias types will only
    accept input names that are unique (not overloaded), so they are
    of limited use; for most uses <type>regprocedure</type> or
    <type>regoperator</type> are more appropriate.  For <type>regoperator</type>,
    unary operators are identified by writing <literal>NONE</literal> for the unused
    operand.
-->
名前空間でグループ化されたオブジェクトのOID別名型はすべてスキーマ修飾名を受け入れ、出力時にスキーマ修飾名を表示します。
ただし、現在の検索パスでオブジェクトが見つけられなければ、修飾せずに出力します。
例えば、<literal>myschema.mytable</literal>は<type>regclass</type>という入力を(そのようなテーブルがあれば)許容します。
この値の出力は現在の検索パス次第で<literal>myschema.mytable</literal>もしくは単に<literal>mytable</literal>と出力されるでしょう。
<type>regproc</type>と<type>regoper</type>別名型は、一意な（オーバーロードしていない）名前のみを入力として受け入れるため、これらの使用には限度があります。
ほとんどの場合、<type>regprocedure</type>または<type>regoperator</type>を使用するのが適切です。
<type>regoperator</type>の場合、単項演算子は未使用のオペランドを<literal>NONE</literal>と記述することによって指定されます。
   </para>

   <para>
<!--
    The input functions for these types allow whitespace between tokens,
    and will fold upper-case letters to lower case, except within double
    quotes; this is done to make the syntax rules similar to the way
    object names are written in SQL.  Conversely, the output functions
    will use double quotes if needed to make the output be a valid SQL
    identifier.  For example, the OID of a function
    named <literal>Foo</literal> (with upper case <literal>F</literal>)
    taking two integer arguments could be entered as
    <literal>' "Foo" ( int, integer ) '::regprocedure</literal>.  The
    output would look like <literal>"Foo"(integer,integer)</literal>.
    Both the function name and the argument type names could be
    schema-qualified, too.
-->
これらの型の入力を許容する関数はトークンの間に空白を入れることを許容し、二重引用符で囲まれたものを除き大文字は小文字に折りたたみます。
これはオブジェクト名がSQLで記述される方法と同じような文法のルールとするための動作です。
逆に出力する関数は有効なSQL識別子となるように必要に応じて二重引用符を使用します。
例えば、<literal>Foo</literal>(<literal>F</literal>が大文字)という２つの整数型の引数を持つ関数のOIDは<literal>' "Foo" ( int, integer ) '::regprocedure</literal>として入力できます。
出力は<literal>"Foo"(integer,integer)</literal>のようになります。
関数名も引数の型名も共にスキーマ修飾することもできます。
   </para>

   <para>
<!--
    Many built-in <productname>PostgreSQL</productname> functions accept
    the OID of a table, or another kind of database object, and for
    convenience are declared as taking <type>regclass</type> (or the
    appropriate OID alias type).  This means you do not have to look up
    the object's OID by hand, but can just enter its name as a string
    literal.  For example, the <function>nextval(regclass)</function> function
    takes a sequence relation's OID, so you could call it like this:
-->
<productname>PostgreSQL</productname>に組み込まれている多くの関数はテーブルやそれ以外の種類のデータベースオブジェクトのOIDを受け入れ、利便性のために <type>regclass</type>(もしくは適切なOIDのエイリアスである型)を取るものとして定義されています。
これはオブジェクトのOIDをわざわざ手動で調べる必要が無く、単にその名前を文字列として入力すれば良いことを意味します。
例えば、 <function>nextval(regclass)</function>関数はシーケンスリレーションのOIDを引数に取りますが、このように呼び出すことができます。
<programlisting>
<!--
nextval('foo')              <lineannotation>operates on sequence <literal>foo</literal></lineannotation>
nextval('FOO')              <lineannotation>same as above</lineannotation>
nextval('"Foo"')            <lineannotation>operates on sequence <literal>Foo</literal></lineannotation>
nextval('myschema.foo')     <lineannotation>operates on <literal>myschema.foo</literal></lineannotation>
nextval('"myschema".foo')   <lineannotation>same as above</lineannotation>
nextval('foo')              <lineannotation>searches search path for <literal>foo</literal></lineannotation>
-->
nextval('foo')              <lineannotation>シーケンス<literal>foo</literal>への操作</lineannotation>
nextval('FOO')              <lineannotation>上と同じ</lineannotation>
nextval('"Foo"')            <lineannotation>シーケンス<literal>Foo</literal>への操作</lineannotation>
nextval('myschema.foo')     <lineannotation><literal>myschema.foo</literal>への操作</lineannotation>
nextval('"myschema".foo')   <lineannotation>上と同じ</lineannotation>
nextval('foo')              <lineannotation><literal>foo</literal>のサーチパスの検索</lineannotation>
</programlisting>
   </para>

   <note>
    <para>
<!--
     When you write the argument of such a function as an unadorned
     literal string, it becomes a constant of type <type>regclass</type>
     (or the appropriate type).
     Since this is really just an OID, it will track the originally
     identified object despite later renaming, schema reassignment,
     etc.  This <quote>early binding</quote> behavior is usually desirable for
     object references in column defaults and views.  But sometimes you might
     want <quote>late binding</quote> where the object reference is resolved
     at run time.  To get late-binding behavior, force the constant to be
     stored as a <type>text</type> constant instead of <type>regclass</type>:
-->
そのような関数の引数を装飾のない文字列として記載した場合、それは<type>regclass</type>型(もしくは適切な型)の定数になります。
これは実際には単にOIDなので、スキーマの再割り当てなどで後からリネームされたとしても最初に識別されたオブジェクトを追跡します。
この<quote>早期バインディング(early binding)</quote>の動作は列のデフォルトを参照する列やビューにとっては望ましい動作です。
しかし、オブジェクトの参照を実行時に行う<quote>遅延バインディング(late binding)</quote>が望ましいこともあります。
遅延バインディングの動作とするためには、定数は<type>regclass</type>の代わりに<type>text</type>の定数として配置してください。
<programlisting>
nextval('foo'::text)      <lineannotation><literal>foo</literal> is looked up at runtime</lineannotation>
</programlisting>
<!--
     The <function>to_regclass()</function> function and its siblings
     can also be used to perform run-time lookups.  See
     <xref linkend="functions-info-catalog-table"/>.
-->
<function>to_regclass()</function>関数とその兄弟は実行時に参照させるために使用することもできます。
詳細は<xref linkend="functions-info-catalog-table"/>を参照ください。
    </para>
   </note>

   <para>
<!--
    Another practical example of use of <type>regclass</type>
    is to look up the OID of a table listed in
    the <literal>information_schema</literal> views, which don't supply
    such OIDs directly.  One might for example wish to call
    the <function>pg_relation_size()</function> function, which requires
    the table OID.  Taking the above rules into account, the correct way
    to do that is
-->
<type>regclass</type>のもう一つの実用的な使用例はそのようなOIDを直接提供しない<literal>information_schema</literal>ビューにリストされたテーブルのOIDを参照することです。
例えば、テーブルのOIDを必要とする<function>pg_relation_size()</function>関数を呼び出したい場合を考えます。
上記のルールを考慮すると、正しい方法は以下のとおりです。
<programlisting>
SELECT table_schema, table_name,
       pg_relation_size((quote_ident(table_schema) || '.' ||
                         quote_ident(table_name))::regclass)
FROM information_schema.tables
WHERE ...
</programlisting>
<!--
    The <function>quote_ident()</function> function will take care of
    double-quoting the identifiers where needed.  The seemingly easier
-->
<function>quote_ident()</function>関数は必要に応じて二重引用符をつけます。
より簡単そうに思われる
<programlisting>
SELECT pg_relation_size(table_name)
FROM information_schema.tables
WHERE ...
</programlisting>
<!--
    is <emphasis>not recommended</emphasis>, because it will fail for
    tables that are outside your search path or have names that require
    quoting.
-->
という方法は<emphasis>推奨されません</emphasis>。
テーブルがサーチパスの範囲外にあったり、引用符付けを必要とする名前であった場合に失敗するためです。
   </para>

   <para>
<!--
    An additional property of most of the OID alias types is the creation of
    dependencies.  If a
    constant of one of these types appears in a stored expression
    (such as a column default expression or view), it creates a dependency
    on the referenced object.  For example, if a column has a default
    expression <literal>nextval('my_seq'::regclass)</literal>,
    <productname>PostgreSQL</productname>
    understands that the default expression depends on the sequence
    <literal>my_seq</literal>, so the system will not let the sequence
    be dropped without first removing the default expression.  The
    alternative of <literal>nextval('my_seq'::text)</literal> does not
    create a dependency.
    (<type>regrole</type> is an exception to this property. Constants of this
    type are not allowed in stored expressions.)
-->
ほとんどのOID別名型のさらなる属性は依存性の作成です。
これらの型の1つの定数が格納された式内に存在する場合（列のデフォルト式やビューなど）、参照されるオブジェクトへの依存性を生成します。
例えば、列が<literal>nextval('my_seq'::regclass)</literal>というデフォルト式を持つ場合、<productname>PostgreSQL</productname>はデフォルト式が<literal>my_seq</literal>シーケンスに依存することを理解します。
システムは先にこのデフォルト式が削除されない限り、このシーケンスを削除させません。
代わりに<literal>nextval('my_seq'::text)</literal>を使用しても依存性は作成されません。
(このプロパティの例外は<type>regrole</type>です。
ストアド式では、この型の定数は使用できません。)
   </para>

   <para>
<!--
    Another identifier type used by the system is <type>xid</type>, or transaction
    (abbreviated <abbrev>xact</abbrev>) identifier.  This is the data type of the system columns
    <structfield>xmin</structfield> and <structfield>xmax</structfield>.  Transaction identifiers are 32-bit quantities.
    In some contexts, a 64-bit variant <type>xid8</type> is used.  Unlike
    <type>xid</type> values, <type>xid8</type> values increase strictly
    monotonically and cannot be reused in the lifetime of a database
    cluster.  See <xref linkend="transaction-id"/> for more details.
-->
システムが使用するもう1つの識別子の型は<type>xid</type>、すなわちトランザクション（略して<abbrev>xact</abbrev>）識別子です。
これは<structfield>xmin</structfield>システム列および<structfield>xmax</structfield>システム列のデータ型です。
トランザクション識別子は32ビット長です。
文脈によっては64ビットに変形した<type>xid8</type>が使われます。
<type>xid</type>の値と違い <type>xid8</type>の値は厳密に単調増加し、データベースクラスタのライフタイムの中で再利用されることはありません。
詳細は<xref linkend="transaction-id"/>を参照してください。
   </para>

   <para>
<!--
    A third identifier type used by the system is <type>cid</type>, or
    command identifier.  This is the data type of the system columns
    <structfield>cmin</structfield> and <structfield>cmax</structfield>. Command identifiers are also 32-bit quantities.
-->
システムが使用する3つ目の識別子は<type>cid</type>、すなわちコマンド識別子です。
これは<structfield>cmin</structfield>システム列および<structfield>cmax</structfield>システム列のデータ型です。
コマンド識別子も32ビット長です。
   </para>

   <para>
<!--
    A final identifier type used by the system is <type>tid</type>, or tuple
    identifier (row identifier).  This is the data type of the system column
    <structfield>ctid</structfield>.  A tuple ID is a pair
    (block number, tuple index within block) that identifies the
    physical location of the row within its table.
-->
システムが使用する最後の識別子は<type>tid</type>、すなわちタプル識別子（行識別子）です。
これは<structfield>ctid</structfield>システム列のデータ型です。
タプルIDはテーブル内の行の物理的位置を識別するための組（ブロック番号、ブロック内のタプルインデックス）です。
   </para>

   <para>
<!--
    (The system columns are further explained in <xref
    linkend="ddl-system-columns"/>.)
-->
（システム列の詳細は<xref linkend="ddl-system-columns"/>で説明します。）
   </para>
  </sect1>

  <sect1 id="datatype-pg-lsn">
<!--
   <title><type>pg_lsn</type> Type</title>
-->
   <title><type>pg_lsn</type>型</title>

   <indexterm zone="datatype-pg-lsn">
    <primary>pg_lsn</primary>
   </indexterm>

   <para>
<!--
    The <type>pg_lsn</type> data type can be used to store LSN (Log Sequence
    Number) data which is a pointer to a location in the WAL. This type is a
    representation of <type>XLogRecPtr</type> and an internal system type of
    <productname>PostgreSQL</productname>.
-->
<type>pg_lsn</type>型はWALの位置を示すLSN(Log Sequence Number)データを格納するために使用します。
この型は<type>XLogRecPtr</type>を示す<productname>PostgreSQL</productname>の内部的なシステムの型です。
   </para>

   <para>
<!--
    Internally, an LSN is a 64-bit integer, representing a byte position in
    the write-ahead log stream.  It is printed as two hexadecimal numbers of
    up to 8 digits each, separated by a slash; for example,
    <literal>16/B374D848</literal>.  The <type>pg_lsn</type> type supports the
    standard comparison operators, like <literal>=</literal> and
    <literal>&gt;</literal>.  Two LSNs can be subtracted using the
    <literal>-</literal> operator; the result is the number of bytes separating
    those write-ahead log locations.  Also the number of bytes can be
    added into and subtracted from LSN using the
    <literal>+(pg_lsn,numeric)</literal> and
    <literal>-(pg_lsn,numeric)</literal> operators, respectively. Note that
    the calculated LSN should be in the range of <type>pg_lsn</type> type,
    i.e., between <literal>0/0</literal> and
    <literal>FFFFFFFF/FFFFFFFF</literal>.
-->
内部的にはLSNは64bit整数型で、WALストリームのバイト位置を表現します。
LSNは例えば、<literal>16/B374D848</literal>のように２つのスラッシュで分けられた8桁の16進数で表示されます。
<type>pg_lsn</type>は例えば、<literal>=</literal>や<literal>&gt;</literal>などの標準の比較演算子をサポートしています。
2つのLSNは<literal>-</literal>演算子を使い引き算することも可能で、結果はこれらの2つのWALの位置のbytes差分です。
また、バイト数はそれぞれ<literal>+(pg_lsn,numeric)</literal>や<literal>-(pg_lsn,numeric)</literal>演算子を使って加算、減算ができます。
計算されたLSNは<type>pg_lsn</type>型の範囲、つまり、<literal>0/0</literal>と<literal>FFFFFFFF/FFFFFFFF</literal>の間にあるべきであることに注意してください。
   </para>
  </sect1>

  <sect1 id="datatype-pseudo">
<!--
   <title>Pseudo-Types</title>
-->
   <title>疑似データ型</title>

   <indexterm zone="datatype-pseudo">
    <primary>record</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>any</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>anyelement</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>anyarray</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>anynonarray</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>anyenum</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>anyrange</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>anymultirange</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>anycompatible</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>anycompatiblearray</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>anycompatiblenonarray</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>anycompatiblerange</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>anycompatiblemultirange</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>void</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>trigger</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>event_trigger</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>pg_ddl_command</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>language_handler</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>fdw_handler</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>table_am_handler</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>index_am_handler</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>tsm_handler</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>cstring</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>internal</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>unknown</primary>
   </indexterm>

   <para>
<!--
    The <productname>PostgreSQL</productname> type system contains a
    number of special-purpose entries that are collectively called
    <firstterm>pseudo-types</firstterm>.  A pseudo-type cannot be used as a
    column data type, but it can be used to declare a function's
    argument or result type.  Each of the available pseudo-types is
    useful in situations where a function's behavior does not
    correspond to simply taking or returning a value of a specific
    <acronym>SQL</acronym> data type.  <xref
    linkend="datatype-pseudotypes-table"/> lists the existing
    pseudo-types.
-->
<productname>PostgreSQL</productname>型システムには、<firstterm>疑似データ型</firstterm>と総称される特殊用途のエントリが多数含まれます。
疑似データ型は列データ型としては使用できませんが、関数の引数や結果データ型を宣言するために使用できます。
これらの使用可能な疑似データ型は、ある関数の振舞いが、特定の<acronym>SQL</acronym>データ型の値を単に取得したり返したりする操作に対応していない場合に便利です。
<xref linkend="datatype-pseudotypes-table"/>に既存の疑似データ型を列挙します。
   </para>

    <table id="datatype-pseudotypes-table">
<!--
     <title>Pseudo-Types</title>
-->
     <title>疑似データ型</title>
     <tgroup cols="2">
      <colspec colname="col1" colwidth="2*"/>
      <colspec colname="col2" colwidth="3*"/>
      <thead>
       <row>
<!--
        <entry>Name</entry>
        <entry>Description</entry>
-->
        <entry>型名</entry>
        <entry>説明</entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry><type>any</type></entry>
<!--
        <entry>Indicates that a function accepts any input data type.</entry>
-->
        <entry>関数がどのような入力データ型でも受け入れることを示します。</entry>
       </row>

       <row>
        <entry><type>anyelement</type></entry>
<!--
        <entry>Indicates that a function accepts any data type
        (see <xref linkend="extend-types-polymorphic"/>).</entry>
-->
        <entry>関数がどのような入力データ型でも受け入れることを示します(<xref linkend="extend-types-polymorphic"/>を参照)。</entry>
       </row>

       <row>
        <entry><type>anyarray</type></entry>
<!--
        <entry>Indicates that a function accepts any array data type
        (see <xref linkend="extend-types-polymorphic"/>).</entry>
-->
        <entry>関数がどのような配列データ型でも受け入れることを示します（<xref linkend="extend-types-polymorphic"/>を参照してください）。</entry>
       </row>

       <row>
        <entry><type>anynonarray</type></entry>
<!--
        <entry>Indicates that a function accepts any non-array data type
        (see <xref linkend="extend-types-polymorphic"/>).</entry>
-->
        <entry>関数がどのような非配列データ型でも受け入れることを示します（<xref linkend="extend-types-polymorphic"/>を参照してください）。</entry>
       </row>

       <row>
        <entry><type>anyenum</type></entry>
<!--
        <entry>Indicates that a function accepts any enum data type
        (see <xref linkend="extend-types-polymorphic"/> and
        <xref linkend="datatype-enum"/>).</entry>
-->
        <entry>関数が何らかの列挙データ型を受け入れることを示します（<xref linkend="extend-types-polymorphic"/>および<xref linkend="datatype-enum"/>を参照してください）。</entry>
       </row>

       <row>
        <entry><type>anyrange</type></entry>
<!--
        <entry>Indicates that a function accepts any range data type
        (see <xref linkend="extend-types-polymorphic"/> and
        <xref linkend="rangetypes"/>).</entry>
-->
        <entry>関数が範囲データ型を受け入れることを示します(<xref linkend="extend-types-polymorphic"/> と <xref linkend="rangetypes"/>を参照してください)。</entry>
       </row>

       <row>
        <entry><type>anymultirange</type></entry>
<!--
        <entry>Indicates that a function accepts any multirange data type
        (see <xref linkend="extend-types-polymorphic"/> and
        <xref linkend="rangetypes"/>).</entry>
-->
        <entry>関数が多重範囲型を受け入れることを示します(<xref linkend="extend-types-polymorphic"/>と<xref linkend="rangetypes"/>を参照してください)。</entry>
       </row>

       <row>
        <entry><type>anycompatible</type></entry>
<!--
        <entry>Indicates that a function accepts any data type,
        with automatic promotion of multiple arguments to a common data type
        (see <xref linkend="extend-types-polymorphic"/>).</entry>
-->
        <entry>関数が複数の引数を一般的なマルチデータ型に自動的に昇格させるどのようなデータ型でも受け入れることを示します(<xref linkend="extend-types-polymorphic"/>)を参照してください)。</entry>
       </row>

       <row>
        <entry><type>anycompatiblearray</type></entry>
<!--
        <entry>Indicates that a function accepts any array data type,
        with automatic promotion of multiple arguments to a common data type
        (see <xref linkend="extend-types-polymorphic"/>).</entry>
-->
        <entry>関数が複数の引数を一般的なデータ型に自動的に昇格させるどのような配列のデータ型でも受け入れることを示します(<xref linkend="extend-types-polymorphic"/>を参照してください)。</entry>
       </row>

       <row>
        <entry><type>anycompatiblenonarray</type></entry>
<!--
        <entry>Indicates that a function accepts any non-array data type,
        with automatic promotion of multiple arguments to a common data type
        (see <xref linkend="extend-types-polymorphic"/>).</entry>
-->
        <entry>関数が複数の引数を一般的なデータ型に自動的に昇格させるどのような非配列のデータ型でも受け入れることを示します(<xref linkend="extend-types-polymorphic"/>を参照ください)。 </entry>
       </row>

       <row>
        <entry><type>anycompatiblerange</type></entry>
<!--
        <entry>Indicates that a function accepts any range data type,
        with automatic promotion of multiple arguments to a common data type
        (see <xref linkend="extend-types-polymorphic"/> and
        <xref linkend="rangetypes"/>).</entry>
-->
        <entry>関数が複数の引数を一般的なデータ型に自動的に昇格させるどのような範囲データ型でも受け入れることを示します(<xref linkend="extend-types-polymorphic"/>と<xref linkend="rangetypes"/>を参照ください)。  </entry>
       </row>

       <row>
        <entry><type>anycompatiblemultirange</type></entry>
<!--
        <entry>Indicates that a function accepts any multirange data type,
        with automatic promotion of multiple arguments to a common data type
        (see <xref linkend="extend-types-polymorphic"/> and
        <xref linkend="rangetypes"/>).</entry>
-->
        <entry>関数が複数の引数を一般的なデータ型に自動的に昇格するすべての多重範囲データ型を受け入れることを示します。(<xref linkend="extend-types-polymorphic"/>と<xref linkend="rangetypes"/>を参照ください)。</entry>
       </row>

       <row>
        <entry><type>cstring</type></entry>
<!--
        <entry>Indicates that a function accepts or returns a null-terminated C string.</entry>
-->
        <entry>関数がヌル終端のC文字列を受け入れる、もしくは返すことを示します。</entry>
       </row>

       <row>
        <entry><type>internal</type></entry>
<!--
        <entry>Indicates that a function accepts or returns a server-internal
        data type.</entry>
-->
        <entry>関数がサーバ内部用データ型を受け入れる、もしくは返すことを示します。
        </entry>
       </row>

       <row>
        <entry><type>language_handler</type></entry>
<!--
        <entry>A procedural language call handler is declared to return <type>language_handler</type>.</entry>
-->
        <entry>
手続き言語呼び出しハンドラは<type>language_handler</type>を返すものとして宣言されます。
        </entry>
       </row>

       <row>
        <entry><type>fdw_handler</type></entry>
<!--
        <entry>A foreign-data wrapper handler is declared to return <type>fdw_handler</type>.</entry>
-->
        <entry>
外部データラッパーハンドラは<type>fdw_handler</type>を返すものとして宣言されます。
        </entry>
       </row>

       <row>
        <entry><type>table_am_handler</type></entry>
<!--
        <entry>A table access method handler is declared to return <type>table_am_handler</type>.</entry>
-->
        <entry>テーブルアクセスメソッドのハンドラは<type>table_am_handler</type>を返すものとして宣言されます。</entry>
       </row>

       <row>
        <entry><type>index_am_handler</type></entry>
<!--
        <entry>An index access method handler is declared to return <type>index_am_handler</type>.</entry>
-->
        <entry>インデックスアクセスメソッドのハンドラは <type>index_am_handler</type>を返すものとして宣言されます。</entry>
       </row>

       <row>
        <entry><type>tsm_handler</type></entry>
<!--
        <entry>A tablesample method handler is declared to return <type>tsm_handler</type>.</entry>
-->
        <entry>テーブルサンプリング方式のハンドラは<type>tsm_handler</type>を返すものとして宣言されます。</entry>
       </row>

       <row>
        <entry><type>record</type></entry>
<!--
        <entry>Identifies a function taking or returning an unspecified row type.</entry>
-->
        <entry>未指定の行型の引数を取る、あるいは返す関数を指定します。</entry>
       </row>

       <row>
        <entry><type>trigger</type></entry>
<!--
        <entry>A trigger function is declared to return <type>trigger.</type></entry>
-->
        <entry>トリガ関数は<type>trigger</type>を返すものとして宣言されます。
        </entry>
       </row>

       <row>
        <entry><type>event_trigger</type></entry>
<!--
        <entry>An event trigger function is declared to return <type>event_trigger.</type></entry>
-->
        <entry>イベントトリガ関数は<type>event_trigger</type>を返すものとして宣言されます。</entry>
       </row>

       <row>
        <entry><type>pg_ddl_command</type></entry>
<!--
        <entry>Identifies a representation of DDL commands that is available to event triggers.</entry>
-->
        <entry>イベントトリガが使用できるDDLコマンドの表現を指定します。</entry>
       </row>

       <row>
        <entry><type>void</type></entry>
<!--
        <entry>Indicates that a function returns no value.</entry>
-->
        <entry>関数が値を返さないことを示します。
        </entry>
       </row>

       <row>
        <entry><type>unknown</type></entry>
<!--
        <entry>Identifies a not-yet-resolved type, e.g., of an undecorated
         string literal.</entry>
-->
        <entry>未解決の型を特定します。例えば、修飾されていない文字列リテラルのような型です。</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
<!--
    Functions coded in C (whether built-in or dynamically loaded) can be
    declared to accept or return any of these pseudo-types.  It is up to
    the function author to ensure that the function will behave safely
    when a pseudo-type is used as an argument type.
-->
C言語で作成された関数（それが組み込みか動的にロードされるかに関係なく）は、これらの疑似データ型のどれでも受け入れたり返したりするように宣言することができます。
引数型として疑似データ型が使用されても関数が安全に機能するように、関数の作成時に気を付ける必要があります。
   </para>

   <para>
<!--
    Functions coded in procedural languages can use pseudo-types only as
    allowed by their implementation languages.  At present most procedural
    languages forbid use of a pseudo-type as an argument type, and allow
    only <type>void</type> and <type>record</type> as a result type (plus
    <type>trigger</type> or <type>event_trigger</type> when the function is used
    as a trigger or event trigger).  Some also support polymorphic functions
    using the polymorphic pseudo-types, which are shown above and discussed
    in detail in <xref linkend="extend-types-polymorphic"/>.
-->
手続き型言語で作成された関数では、実装する言語によって許可された疑似データ型のみを使用できます。
現在、ほとんどの手続き型言語では疑似データ型を引数型として使用することが原則として禁止されており、結果型としての<type>void</type>と<type>record</type>（および関数がトリガまたはイベントトリガとして使用される場合の<type>trigger</type>または<type>event_trigger</type>）のみが許可されています。
また、一部の関数は、多様な疑似型を使用する多様関数をサポートしています。
これについては、前述の<xref linkend="extend-types-polymorphic"/>で詳細に説明されています。
   </para>

   <para>
<!--
    The <type>internal</type> pseudo-type is used to declare functions
    that are meant only to be called internally by the database
    system, and not by direct invocation in an <acronym>SQL</acronym>
    query.  If a function has at least one <type>internal</type>-type
    argument then it cannot be called from <acronym>SQL</acronym>.  To
    preserve the type safety of this restriction it is important to
    follow this coding rule: do not create any function that is
    declared to return <type>internal</type> unless it has at least one
    <type>internal</type> argument.
-->
<type>internal</type>疑似データ型は、データベースシステムによって内部的にのみ呼び出される関数を宣言する場合に使用され、<acronym>SQL</acronym>問い合わせでの直接呼び出しには使用できません。
関数に少なくとも1つの<type>internal</type>型の引数があると、これを<acronym>SQL</acronym>から呼び出すことはできません。
この制限の影響からデータ型の安全性を保持するためには、次のコーディング規則に従うことが重要です。
<type>internal</type>引数が少なくとも1つある場合を除き、<type>internal</type>を返すと宣言される関数を作成すべきではありません。
   </para>

  </sect1>

 </chapter>
