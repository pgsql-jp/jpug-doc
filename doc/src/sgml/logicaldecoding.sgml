<!-- doc/src/sgml/logicaldecoding.sgml -->
 <chapter id="logicaldecoding">
<!--
  <title>Logical Decoding</title>
-->
  <title>ロジカルデコーディング</title>
  <indexterm zone="logicaldecoding">
   <primary>Logical Decoding</primary>
  </indexterm>
  <indexterm zone="logicaldecoding">
   <primary>ロジカルデコーディング</primary>
  </indexterm>
  <para>
<!--
   PostgreSQL provides infrastructure to stream the modifications performed
   via SQL to external consumers.  This functionality can be used for a
   variety of purposes, including replication solutions and auditing.
-->
PostgreSQLは、SQLによって実行された更新結果を外部のコンシューマにストリーミングする基盤を提供しています。
この機能は、レプリケーションソリューションや監査など、さまざまな目的に使用できます。
  </para>

  <para>
<!--
   Changes are sent out in streams identified by logical replication slots.
-->
更新結果は、ロジカルレプリケーションスロット(logical replication slots)で識別されるストリームに送出されます。
  </para>

  <para>
<!--
   The format in which those changes are streamed is determined by the output
   plugin used.  An example plugin is provided in the PostgreSQL distribution.
   Additional plugins can be
   written to extend the choice of available formats without modifying any
   core code.
   Every output plugin has access to each individual new row produced
   by <command>INSERT</command> and the new row version created
   by <command>UPDATE</command>.  Availability of old row versions for
   <command>UPDATE</command> and <command>DELETE</command> depends on
   the configured replica identity (see <xref linkend="sql-altertable-replica-identity"/>).
-->
ストリームに送出される更新データのフォーマットは、使用する出力プラグインで決まります。
サンプルプラグインがPostgreSQLの配布物に含まれています。
追加のプラグインを書くことにより、PostgreSQLのコア部分のコードを一切変更することなく、利用可能なフォーマットの選択肢を増やすことができます。
すべての出力プラグインから、<command>INSERT</command>によって作成された個々の新しい行と、<command>UPDATE</command>によって作成された新しいバージョンの行にアクセスできます。
<command>UPDATE</command>と<command>DELETE</command>によって生じた古いバージョンの行へのアクセスが可能かどうかは、レプリカアイデンティティ(replica identity)の設定によって決まります（<xref linkend="sql-altertable-replica-identity"/>参照）。
  </para>

  <para>
<!--
   Changes can be consumed either using the streaming replication protocol
   (see <xref linkend="protocol-replication"/> and
   <xref linkend="logicaldecoding-walsender"/>), or by calling functions
   via SQL (see <xref linkend="logicaldecoding-sql"/>). It is also possible
   to write additional methods of consuming the output of a replication slot
   without modifying core code
   (see <xref linkend="logicaldecoding-writer"/>).
-->
変更データの消費は、ストリーミングレプリケーションのプロトコル（<xref linkend="protocol-replication"/>と<xref linkend="logicaldecoding-walsender"/>を参照）を使うか、SQLを使って関数を呼び出します（<xref linkend="logicaldecoding-sql"/>を参照）。
また、コア部分に手を入れなくても、レプリケーションスロットの出力を消費する別の方法を実装することもできます（<xref linkend="logicaldecoding-writer"/>参照）。
  </para>

  <sect1 id="logicaldecoding-example">
<!--
   <title>Logical Decoding Examples</title>
-->
   <title>ロジカルデコーディングの例</title>

   <para>
<!--
    The following example demonstrates controlling logical decoding using the
    SQL interface.
-->
以下はロジカルデコーディングをSQLを使って制御する例です。
   </para>

   <para>
<!--
    Before you can use logical decoding, you must set
    <xref linkend="guc-wal-level"/> to <literal>logical</literal> and
    <xref linkend="guc-max-replication-slots"/> to at least 1.  Then, you
    should connect to the target database (in the example
    below, <literal>postgres</literal>) as a superuser.
-->
ロジカルデコーディングを使う前に、<xref linkend="guc-wal-level"/>を<literal>logical</literal>に、そして<xref linkend="guc-max-replication-slots"/>を少なくとも1に設定しなければなりません。
次に、使用するデータベースにスーパーユーザ(以下の例では<literal>postgres</literal>)として接続します。
   </para>

<programlisting>
postgres=# -- Create a slot named 'regression_slot' using the output plugin 'test_decoding'
postgres=# -- 出力プラグイン'test_decoding'を使用して'regression_slot'という名前のスロットを作成します。
postgres=# SELECT * FROM pg_create_logical_replication_slot('regression_slot', 'test_decoding', false, true);
    slot_name    |    lsn
-----------------+-----------
 regression_slot | 0/16B1970
(1 row)

postgres=# SELECT slot_name, plugin, slot_type, database, active, restart_lsn, confirmed_flush_lsn FROM pg_replication_slots;
    slot_name    |    plugin     | slot_type | database | active | restart_lsn | confirmed_flush_lsn
-----------------+---------------+-----------+----------+--------+-------------+-----------------
 regression_slot | test_decoding | logical   | postgres | f      | 0/16A4408   | 0/16A4440
(1 row)

postgres=# -- There are no changes to see yet
postgres=# -- まだ変更はありません
postgres=# SELECT * FROM pg_logical_slot_get_changes('regression_slot', NULL, NULL);
 lsn | xid | data
-----+-----+------
(0 rows)

postgres=# CREATE TABLE data(id serial primary key, data text);
CREATE TABLE

postgres=# -- DDL isn't replicated, so all you'll see is the transaction
postgres=# -- DDLはレプリケーションされないので、見えるのはトランザクションだけです
postgres=# SELECT * FROM pg_logical_slot_get_changes('regression_slot', NULL, NULL);
    lsn    |  xid  |     data
-----------+-------+--------------
 0/BA2DA58 | 10297 | BEGIN 10297
 0/BA5A5A0 | 10297 | COMMIT 10297
(2 rows)

postgres=# -- Once changes are read, they're consumed and not emitted
postgres=# -- in a subsequent call:
postgres=# -- 変更が読み込まれると、それらは消費され、次の呼び出しで送出されません:
postgres=# SELECT * FROM pg_logical_slot_get_changes('regression_slot', NULL, NULL);
 lsn | xid | data
-----+-----+------
(0 rows)

postgres=# BEGIN;
postgres=*# INSERT INTO data(data) VALUES('1');
postgres=*# INSERT INTO data(data) VALUES('2');
postgres=*# COMMIT;

postgres=# SELECT * FROM pg_logical_slot_get_changes('regression_slot', NULL, NULL);
    lsn    |  xid  |                          data
-----------+-------+---------------------------------------------------------
 0/BA5A688 | 10298 | BEGIN 10298
 0/BA5A6F0 | 10298 | table public.data: INSERT: id[integer]:1 data[text]:'1'
 0/BA5A7F8 | 10298 | table public.data: INSERT: id[integer]:2 data[text]:'2'
 0/BA5A8A8 | 10298 | COMMIT 10298
(4 rows)

postgres=# INSERT INTO data(data) VALUES('3');

postgres=# -- You can also peek ahead in the change stream without consuming changes
postgres=# -- 変更を消費せずに変更ストリームを先読みすることもできます
postgres=# SELECT * FROM pg_logical_slot_peek_changes('regression_slot', NULL, NULL);
    lsn    |  xid  |                          data
-----------+-------+---------------------------------------------------------
 0/BA5A8E0 | 10299 | BEGIN 10299
 0/BA5A8E0 | 10299 | table public.data: INSERT: id[integer]:3 data[text]:'3'
 0/BA5A990 | 10299 | COMMIT 10299
(3 rows)

postgres=# -- The next call to pg_logical_slot_peek_changes() returns the same changes again
postgres=# -- pg_logical_slot_peek_changes()の次の呼び出しでも同じ変更が返されます
postgres=# SELECT * FROM pg_logical_slot_peek_changes('regression_slot', NULL, NULL);
    lsn    |  xid  |                          data
-----------+-------+---------------------------------------------------------
 0/BA5A8E0 | 10299 | BEGIN 10299
 0/BA5A8E0 | 10299 | table public.data: INSERT: id[integer]:3 data[text]:'3'
 0/BA5A990 | 10299 | COMMIT 10299
(3 rows)

postgres=# -- options can be passed to output plugin, to influence the formatting
postgres=# -- 出力プラグインにオプションを渡すことで、フォーマットに影響を与えることができます
postgres=# SELECT * FROM pg_logical_slot_peek_changes('regression_slot', NULL, NULL, 'include-timestamp', 'on');
    lsn    |  xid  |                          data
-----------+-------+---------------------------------------------------------
 0/BA5A8E0 | 10299 | BEGIN 10299
 0/BA5A8E0 | 10299 | table public.data: INSERT: id[integer]:3 data[text]:'3'
 0/BA5A990 | 10299 | COMMIT 10299 (at 2017-05-10 12:07:21.272494-04)
(3 rows)

postgres=# -- Remember to destroy a slot you no longer need to stop it consuming
postgres=# -- server resources:
postgres=# -- サーバのリソースの消費を停止するためにもう必要ないスロットを破棄することを忘れないでください
postgres=# SELECT pg_drop_replication_slot('regression_slot');
 pg_drop_replication_slot
-----------------------

(1 row)
</programlisting>

   <para>
<!--
    The following examples show how logical decoding is controlled over the
    streaming replication protocol, using the
    program <xref linkend="app-pgrecvlogical"/> included in the PostgreSQL
    distribution.  This requires that client authentication is set up to allow
    replication connections
    (see <xref linkend="streaming-replication-authentication"/>) and
    that <varname>max_wal_senders</varname> is set sufficiently high to allow
    an additional connection.  The second example shows how to stream two-phase
    transactions.  Before you use two-phase commands, you must set
    <xref linkend="guc-max-prepared-transactions"/> to at least 1.
-->
以下はPostgreSQLに付属するプログラム<xref linkend="app-pgrecvlogical"/>を用いてロジカルデコーディングをストリーミングレプリケーションのプロトコルによって制御する例です。
この方法を使うには、レプリケーション接続を許すようにクライアント認証を設定し(<xref linkend="streaming-replication-authentication"/>参照)、<varname>max_wal_senders</varname>を十分に大きくして追加の接続ができるようにしておかなければなりません。
2番目の例は、2相トランザクションをストリームする例です。
2相コマンドを使用する前に、<xref linkend="guc-max-prepared-transactions"/>を少なくとも1に設定する必要があります。
   </para>
<programlisting>
Example 1:
$ pg_recvlogical -d postgres --slot=test --create-slot
$ pg_recvlogical -d postgres --slot=test --start -f -
<keycombo action="simul"><keycap>Control</keycap><keycap>Z</keycap></keycombo>
$ psql -d postgres -c "INSERT INTO data(data) VALUES('4');"
$ fg
BEGIN 693
table public.data: INSERT: id[integer]:4 data[text]:'4'
COMMIT 693
<keycombo action="simul"><keycap>Control</keycap><keycap>C</keycap></keycombo>
$ pg_recvlogical -d postgres --slot=test --drop-slot

Example 2:
$ pg_recvlogical -d postgres --slot=test --create-slot --two-phase
$ pg_recvlogical -d postgres --slot=test --start -f -
<keycombo action="simul"><keycap>Control</keycap><keycap>Z</keycap></keycombo>
$ psql -d postgres -c "BEGIN;INSERT INTO data(data) VALUES('5');PREPARE TRANSACTION 'test';"
$ fg
BEGIN 694
table public.data: INSERT: id[integer]:5 data[text]:'5'
PREPARE TRANSACTION 'test', txid 694
<keycombo action="simul"><keycap>Control</keycap><keycap>Z</keycap></keycombo>
$ psql -d postgres -c "COMMIT PREPARED 'test';"
$ fg
COMMIT PREPARED 'test', txid 694
<keycombo action="simul"><keycap>Control</keycap><keycap>C</keycap></keycombo>
$ pg_recvlogical -d postgres --slot=test --drop-slot
</programlisting>

  <para>
<!--
  The following example shows SQL interface that can be used to decode prepared
  transactions. Before you use two-phase commit commands, you must set
  <varname>max_prepared_transactions</varname> to at least 1. You must also have
  set the two-phase parameter as 'true' while creating the slot using
  <function>pg_create_logical_replication_slot</function>
  Note that we will stream the entire transaction after the commit if it
  is not already decoded.
-->
以下の例では、準備されたトランザクションのデコードに使用できるSQLインタフェースを示します。
2相コミットコマンドを使用する前に、<varname>max_prepared_transactions</varname>を少なくとも1に設定しなければなりません。
<function>pg_create_logical_replication_slot</function>を使用してスロットを作成する際に、2相パラメータを'true'に設定しておく必要もあります。
トランザクションがまだデコードされていない場合は、コミット後にトランザクション全体をストリームすることに注意してください。
  </para>
<programlisting>
postgres=# BEGIN;
postgres=*# INSERT INTO data(data) VALUES('5');
postgres=*# PREPARE TRANSACTION 'test_prepared1';

postgres=# SELECT * FROM pg_logical_slot_get_changes('regression_slot', NULL, NULL);
    lsn    | xid |                          data
-----------+-----+---------------------------------------------------------
 0/1689DC0 | 529 | BEGIN 529
 0/1689DC0 | 529 | table public.data: INSERT: id[integer]:3 data[text]:'5'
 0/1689FC0 | 529 | PREPARE TRANSACTION 'test_prepared1', txid 529
(3 rows)

postgres=# COMMIT PREPARED 'test_prepared1';
postgres=# select * from pg_logical_slot_get_changes('regression_slot', NULL, NULL);
    lsn    | xid |                    data
-----------+-----+--------------------------------------------
 0/168A060 | 529 | COMMIT PREPARED 'test_prepared1', txid 529
(4 row)

postgres=#-- you can also rollback a prepared transaction
postgres=#-- 準備されたトランザクションをロールバックすることもできます
postgres=# BEGIN;
postgres=*# INSERT INTO data(data) VALUES('6');
postgres=*# PREPARE TRANSACTION 'test_prepared2';
postgres=# select * from pg_logical_slot_get_changes('regression_slot', NULL, NULL);
    lsn    | xid |                          data
-----------+-----+---------------------------------------------------------
 0/168A180 | 530 | BEGIN 530
 0/168A1E8 | 530 | table public.data: INSERT: id[integer]:4 data[text]:'6'
 0/168A430 | 530 | PREPARE TRANSACTION 'test_prepared2', txid 530
(3 rows)

postgres=# ROLLBACK PREPARED 'test_prepared2';
postgres=# select * from pg_logical_slot_get_changes('regression_slot', NULL, NULL);
    lsn    | xid |                     data
-----------+-----+----------------------------------------------
 0/168A4B8 | 530 | ROLLBACK PREPARED 'test_prepared2', txid 530
(1 row)
</programlisting>
</sect1>

  <sect1 id="logicaldecoding-explanation">
<!--
   <title>Logical Decoding Concepts</title>
-->
   <title>ロジカルデコーディングのコンセプト</title>
   <sect2 id="logicaldecoding-explanation-log-dec">
<!--
    <title>Logical Decoding</title>
-->
    <title>ロジカルデコーディング</title>

    <indexterm>
     <primary>Logical Decoding</primary>
    </indexterm>
    <indexterm>
     <primary>ロジカルデコーディング</primary>
    </indexterm>

    <para>
<!--
     Logical decoding is the process of extracting all persistent changes
     to a database's tables into a coherent, easy to understand format which
     can be interpreted without detailed knowledge of the database's internal
     state.
-->
ロジカルデコーディングは、データベースのテーブルへの恒久的な更新を、一貫性があって、データベース内部の状態に関する詳細な知識がなくても容易に理解できる形式として取得するプロセスです。
    </para>

    <para>
<!--
     In <productname>PostgreSQL</productname>, logical decoding is implemented
     by decoding the contents of the <link linkend="wal">write-ahead
     log</link>, which describe changes on a storage level, into an
     application-specific form such as a stream of tuples or SQL statements.
-->
<productname>PostgreSQL</productname>においてロジカルデコーディングは、記憶装置のレベルで更新を記述する<link linkend="wal">書き込み先行ログ</link>の内容を、タプルやSQL文のストリームといったアプリケーション固有の形式にデコードすることによって実装されています。
    </para>
   </sect2>

   <sect2 id="logicaldecoding-replication-slots">
<!--
    <title>Replication Slots</title>
-->
    <title>レプリケーションスロット</title>

    <indexterm>
     <primary>replication slot</primary>
     <secondary>logical replication</secondary>
    </indexterm>
    <indexterm>
     <primary>レプリケーションスロット</primary>
     <secondary>ロジカルレプリケーション</secondary>
    </indexterm>

    <para>
<!--
     In the context of logical replication, a slot represents a stream of
     changes that can be replayed to a client in the order they were made on
     the origin server. Each slot streams a sequence of changes from a single
     database.
-->
ロジカルレプリケーションの文脈ではスロットは、元のサーバで行われた変更と同じ順序でクライアント上でリプレイできるようなストリームを表します。
それぞれのスロットは、単一のデータベース上の変更操作の連鎖をストリームとして流します。
    </para>

    <note>
<!--
     <para><productname>PostgreSQL</productname> also has streaming replication slots
     (see <xref linkend="streaming-replication"/>), but they are used somewhat
     differently there.
-->
<para>また<productname>PostgreSQL</productname>には、ストリーミングレプリケーションスロットがあります
(<xref linkend="streaming-replication"/>参照)。しかし、ここでの説明とは少し違う使い方がされています。
     </para>
    </note>

    <para>
<!--
     A replication slot has an identifier that is unique across all databases
     in a <productname>PostgreSQL</productname> cluster. Slots persist
     independently of the connection using them and are crash-safe.
-->
それぞれのレプリケーションスロットは<productname>PostgreSQL</productname>クラスタの中で一意な識別子を持っています。
スロットは、そのために使用される接続とは独立しており、クラッシュセーフです。
    </para>

    <para>
<!--
     A logical slot will emit each change just once in normal operation.
     The current position of each slot is persisted only at checkpoint, so in
     the case of a crash the slot may return to an earlier LSN, which will
     then cause recent changes to be sent again when the server restarts.
     Logical decoding clients are responsible for avoiding ill effects from
     handling the same message more than once.  Clients may wish to record
     the last LSN they saw when decoding and skip over any repeated data or
     (when using the replication protocol) request that decoding start from
     that LSN rather than letting the server determine the start point.
     The Replication Progress Tracking feature is designed for this purpose,
     refer to <link linkend="replication-origins">replication origins</link>.
-->
ロジカルスロットは、通常の操作においては、各々の変更操作を一度だけ送出します。
それぞれのスロットにおける現在位置は、チェックポイントのときにだけ永続的になります。
ですからクラッシュすると、スロットは以前のLSNに戻ってしまうかもしれませんし、サーバの再起動時には最近の変更が再送されることになります。
ロジカルデコーディングのクライアントは、同じメッセージを複数回扱うことによる好ましくない結果を避けることに対して責任を追っています。
クライアントはデコーディングの際に最後に確認したLSNを記録し、繰り返されるデータをスキップしたり、（レプリケーションプロトコルを使う場合に）サーバに開始時点を決めさせるのではなく、記録しておいたLSNからデコーディングを始めるように要求するかもしれません。
レプリケーション進捗追跡機能はこの目的のために設計されています。
<link linkend="replication-origins">replication origins</link>を参照してください。
    </para>

    <para>
<!--
     Multiple independent slots may exist for a single database. Each slot has
     its own state, allowing different consumers to receive changes from
     different points in the database change stream. For most applications, a
     separate slot will be required for each consumer.
-->
単一のデータベース中に、お互いに独立した複数のスロットが存在しても構いません。
それぞれのスロットは自分自身の状態を持っており、データベース更新のストリーム上の別の場所から変更データを受信する異なる消費者があり得ます。
多くのアプリケーションにとっては、各消費者に対して個別のスロットが必要となるでしょう。
    </para>

    <para>
<!--
     A logical replication slot knows nothing about the state of the
     receiver(s).  It's even possible to have multiple different receivers using
     the same slot at different times; they'll just get the changes following
     on from when the last receiver stopped consuming them. Only one receiver
     may consume changes from a slot at any given time.
-->
ロジカルレプリケーションスロットは、受信者の状態については関知しません。
同時にでなければ、同じスロットを使う複数の異なる受信者を持つことさえできます。
その場合は、直近の受信者がストリームの消費を終了した時点から更新データを受信するだけです。
どの時点でも1つのスロットからの変更を消費できるのは1つの受信側だけです。
    </para>

    <para>
<!--
     A logical replication slot can also be created on a hot standby. To prevent
     <command>VACUUM</command> from removing required rows from the system
     catalogs, <varname>hot_standby_feedback</varname> should be set on the
     standby. In spite of that, if any required rows get removed, the slot gets
     invalidated. It's highly recommended to use a physical slot between the
     primary and the standby. Otherwise, <varname>hot_standby_feedback</varname>
     will work but only while the connection is alive (for example a node
     restart would break it). Then, the primary may delete system catalog rows
     that could be needed by the logical decoding on the standby (as it does
     not know about the <literal>catalog_xmin</literal> on the standby).
     Existing logical slots on standby also get invalidated if
     <varname>wal_level</varname> on the primary is reduced to less than
     <literal>logical</literal>.
     This is done as soon as the standby detects such a change in the WAL stream.
     It means that, for walsenders that are lagging (if any), some WAL records up
     to the <varname>wal_level</varname> parameter change on the primary won't be
     decoded.
-->
ロジカルレプリケーションスロットは、ホットスタンバイ上でも作成できます。
システムカタログから必要な行を<command>VACUUM</command>が削除するのを防ぐためには、スタンバイ上で<varname>hot_standby_feedback</varname>を設定する必要があります。
それでも、必要な行が削除されると、スロットは無効になります。
プライマリとスタンバイの間に物理スロットを使用することを強くお勧めします。
そうしないと、<varname>hot_standby_feedback</varname>が動作するのは接続が生きている間だけです（たとえばノードの再起動で破壊されます）。
その場合、プライマリはスタンバイ上のロジカルデコーディングが必要とするシステムカタログ行を削除するかもしれません（スタンバイ上の<literal>catalog_xmin</literal>については知らないため）。
既存のスタンバイ上のロジカルスロットも、プライマリ上の<varname>wal_level</varname>が<literal>logical</literal>よりも小さくなると無効になります。
これはスタンバイがWALストリームでそのような変更を検出したときにすぐに行われます。
これは、遅れているwalsender（もしあれば）に対して、プライマリでの<varname>wal_level</varname>パラメータの変更までの一部のWALレコードがデコードされないことを意味します。
    </para>

    <para>
<!--
     Creation of a logical slot requires information about all the currently
     running transactions. On the primary, this information is available
     directly, but on a standby, this information has to be obtained from
     primary. Thus, slot creation may need to wait for some activity to happen
     on the primary. If the primary is idle, creating a logical slot on
     standby may take noticeable time. This can be sped up by calling the
     <function>pg_log_standby_snapshot</function> function on the primary.
-->
ロジカルスロットの作成には、現在実行中のすべてのトランザクションに関する情報が必要です。
プライマリではこの情報は直接利用できますが、スタンバイではこの情報をプライマリから取得する必要があります。
したがって、スロットの作成はプライマリで何らかのアクティビティが発生するのを待つ必要があるかもしれません。
プライマリがアイドル状態の場合、スタンバイ上でのロジカルスロットの作成にはかなりの時間がかかるかもしれません。
これは、プライマリで<function>pg_log_standby_snapshot</function>関数を呼び出すことで高速化できます。
    </para>

    <caution>
     <para>
<!--
      Replication slots persist across crashes and know nothing about the state
      of their consumer(s). They will prevent removal of required resources
      even when there is no connection using them. This consumes storage
      because neither required WAL nor required rows from the system catalogs
      can be removed by <command>VACUUM</command> as long as they are required by a replication
      slot.  In extreme cases this could cause the database to shut down to prevent
      transaction ID wraparound (see <xref linkend="vacuum-for-wraparound"/>).
      So if a slot is no longer required it should be dropped.
-->
レプリケーションスロットは、クラッシュをまたがって永続し、消費者の状態については関知しません。
スロットを使う接続がない場合でも、消費者が必要としているリソースが削除されることを防ぎます。
これによりストレージが消費されます。何故ならば、関連するWALもシステムカタログの行も、レプリケーションスロットが必要とする限り<command>VACUUM</command>によって削除されないからです。
極端な場合、トランザクションIDの周回（<xref linkend="vacuum-for-wraparound"/>を参照）を防ぐためのデータベース停止をもたらす可能性があります。
したがって、必要でなくなったスロットは削除すべきです。
     </para>
    </caution>

   </sect2>

   <sect2 id="logicaldecoding-replication-slots-synchronization">
<!--
    <title>Replication Slot Synchronization</title>
-->
    <title>レプリケーションスロットの同期</title>
    <para>
<!--
     The logical replication slots on the primary can be synchronized to
     the hot standby by using the <literal>failover</literal> parameter of
     <link linkend="pg-create-logical-replication-slot">
     <function>pg_create_logical_replication_slot</function></link>, or by
     using the <link linkend="sql-createsubscription-params-with-failover">
     <literal>failover</literal></link> option of
     <command>CREATE SUBSCRIPTION</command> during slot creation, and then calling
     <link linkend="pg-sync-replication-slots">
     <function>pg_sync_replication_slots</function></link>
     on the standby. By setting <link linkend="guc-sync-replication-slots">
     <varname>sync_replication_slots</varname></link>
     on the standby, the failover slots can be synchronized periodically in
     the slotsync worker. For the synchronization to work, it is mandatory to
     have a physical replication slot between the primary and the standby (i.e.,
     <link linkend="guc-primary-slot-name"><varname>primary_slot_name</varname></link>
     should be configured on the standby), and
     <link linkend="guc-hot-standby-feedback"><varname>hot_standby_feedback</varname></link>
     must be enabled on the standby. It is also necessary to specify a valid
     <literal>dbname</literal> in the
     <link linkend="guc-primary-conninfo"><varname>primary_conninfo</varname></link>.
     It's highly recommended that the said physical replication slot is named in
     <link linkend="guc-synchronized-standby-slots"><varname>synchronized_standby_slots</varname></link>
     list on the primary, to prevent the subscriber from consuming changes
     faster than the hot standby. Even when correctly configured, some latency
     is expected when sending changes to logical subscribers due to the waiting
     on slots named in
     <link linkend="guc-synchronized-standby-slots"><varname>synchronized_standby_slots</varname></link>.
     When <varname>synchronized_standby_slots</varname> is utilized, the
     primary server will not completely shut down until the corresponding
     standbys, associated with the physical replication slots specified
     in <varname>synchronized_standby_slots</varname>, have confirmed
     receiving the WAL up to the latest flushed position on the primary server.
-->
プライマリ上のロジカルレプリケーションスロットは、ホットスタンバイと同期させることができます。
これは、スロットの作成時に<link linkend="pg-create-logical-replication-slot"><function>pg_create_logical_replication_slot</function></link>の<literal>failover</literal>パラメータを指定するか、<command>CREATE SUBSCRIPTION</command>の<link linkend="sql-createsubscription-params-with-failover"><literal>failover</literal></link>オプションを指定したうえで、スタンバイで<link linkend="pg-sync-replication-slots"><function>pg_sync_replication_slots</function></link>を呼び出すことで可能です。
スタンバイで<link linkend="guc-sync-replication-slots"><varname>sync_replication_slots</varname></link>を設定すると、フェイルオーバースロットをスロット同期ワーカーによって定期的に同期させることができます。
同期を機能させるには、プライマリとスタンバイの間に物理レプリケーションスロットが必要であり（つまり、スタンバイで<link linkend="guc-primary-slot-name"><varname>primary_slot_name</varname></link>が設定されている必要があります）、スタンバイでは<link linkend="guc-hot-standby-feedback"><varname>hot_standby_feedback</varname></link>が有効になっている必要があります。
また、<link linkend="guc-primary-conninfo"><varname>primary_conninfo</varname></link>に有効な<literal>dbname</literal>を指定する必要があります。
この物理レプリケーションスロットを、プライマリの<link linkend="guc-synchronized-standby-slots"><varname>synchronized_standby_slots</varname></link>リスト内に指定することを強くお勧めします。
これは、サブスクライバーがホットスタンバイよりも早く変更を消費しないようにするためです。
正しく設定されていても、<link linkend="guc-synchronized-standby-slots"><varname>synchronized_standby_slots</varname></link>内に指定されたスロットを待つため、サブスクライバに変更を送信するときに多少の遅延が予想されます。
<varname>synchronized_standby_slots</varname>が使用されている場合、<varname>synchronized_standby_slots</varname>で指定された物理レプリケーションスロットに関連付けられた対応するスタンバイが、プライマリサーバ上の最新のフラッシュされた位置までWALを受信することを確認するまで、プライマリサーバは完全にはシャットダウンしません。
    </para>

    <para>
<!--
     The ability to resume logical replication after failover depends upon the
     <link linkend="view-pg-replication-slots">pg_replication_slots</link>.<structfield>synced</structfield>
     value for the synchronized slots on the standby at the time of failover.
     Only persistent slots that have attained synced state as true on the standby
     before failover can be used for logical replication after failover.
     Temporary synced slots cannot be used for logical decoding, therefore
     logical replication for those slots cannot be resumed. For example, if the
     synchronized slot could not become persistent on the standby due to a
     disabled subscription, then the subscription cannot be resumed after
     failover even when it is enabled.
-->
フェイルオーバー後にロジカルレプリケーションを再開できるかどうかは、フェイルオーバー時のスタンバイ上で同期されていたスロットの持つ<link linkend="view-pg-replication-slots">pg_replication_slots</link>.<structfield>synced</structfield>によって決まります。
フェイルオーバー前に、スタンバイで同期状態が真となっている永続スロットだけが、フェイルオーバー後の論理レプリケーションに使用できます。
同期されていた一時スロットはロジカルデコーディングには使用できないため、これらのスロットによるロジカルレプリケーションは再開できません。
例えば、サブスクリプション無効になっているため、同期されたスロットがスタンバイ上で永続化できなかった場合、フェイルオーバー後にサブスクリプションを有効にしても、そのサブスクリプションは再利用できません。
    </para>

    <para>
<!--
     To resume logical replication after failover from the synced logical
     slots, the subscription's 'conninfo' must be altered to point to the
     new primary server. This is done using
     <link linkend="sql-altersubscription-params-connection"><command>ALTER SUBSCRIPTION ... CONNECTION</command></link>.
     It is recommended that subscriptions are first disabled before promoting
     the standby and are re-enabled after altering the connection string.
-->
同期されたロジカルスロットからフェイルオーバーの後にロジカルレプリケーションを再開するには、サブスクリプションの'conninfo'オプションを新しいプライマリサーバを指すように変更する必要があります。
これは<link linkend="sql-altersubscription-params-connection"><command>ALTER SUBSCRIPTION ... CONNECTION</command></link>を使用して行います。
スタンバイが昇格する前に先にサブスクリプションを無効にし、接続文字列を変更した後に再度有効にすることをお勧めします。
    </para>
    <caution>
     <para>
<!--
      There is a chance that the old primary is up again during the promotion
      and if subscriptions are not disabled, the logical subscribers may
      continue to receive data from the old primary server even after promotion
      until the connection string is altered. This might result in data
      inconsistency issues, preventing the logical subscribers from being
      able to continue replication from the new primary server.
-->
昇格中に古いプライマリが再度起動する場合があります。
このときサブスクリプションが無効なっていない場合、サブスクライバは昇格後も接続文字列が変更されるまで、古いプライマリサーバからデータを受信し続ける可能性があります。
これによりデータの不整合の問題が生じ、サブスクライバが新しいプライマリからのレプリケーションを継続できなくなる可能性があります。
     </para>
    </caution>
   </sect2>

   <sect2 id="logicaldecoding-explanation-output-plugins">
<!--
    <title>Output Plugins</title>
-->
    <title>出力プラグイン</title>
    <para>
<!--
     Output plugins transform the data from the write-ahead log's internal
     representation into the format the consumer of a replication slot desires.
-->
出力プラグインは、書き込み先行ログの内部データ表現を、レプリケーションスロットの消費者が必要とする形式に変換します。
    </para>
   </sect2>

   <sect2 id="logicaldecoding-explanation-exported-snapshots">
<!--
    <title>Exported Snapshots</title>
-->
    <title>スナップショットのエクスポート</title>
    <para>
<!--
     When a new replication slot is created using the streaming replication
     interface (see <xref linkend="protocol-replication-create-replication-slot"/>), a
     snapshot is exported
     (see <xref linkend="functions-snapshot-synchronization"/>), which will show
     exactly the state of the database after which all changes will be
     included in the change stream. This can be used to create a new replica by
     using <link linkend="sql-set-transaction"><literal>SET TRANSACTION
     SNAPSHOT</literal></link> to read the state of the database at the moment
     the slot was created. This transaction can then be used to dump the
     database's state at that point in time, which afterwards can be updated
     using the slot's contents without losing any changes.
-->
ストリーミングレプリケーションのインタフェースを使って新しいスロットを作ると（<xref linkend="protocol-replication-create-replication-slot"/>参照）、スナップショットがエクスポートされます（<xref linkend="functions-snapshot-synchronization"/>参照）。
このスナップショットはまさにその時点でのデータベースの状態を示しており、スナップショット以後のすべての変更は更新ストリームに含まれるようになります。
このことを利用して、スロットが作られた際のデータベースの状態を<link linkend="sql-set-transaction"><literal>SET TRANSACTION SNAPSHOT</literal></link>を使って読み込むことにより、新しいレプリカを作ることができます。
このトランザクションは、その時点のデータベースの状態をダンプするために使用することができます。
また、スロットに含まれるデータを使って、ダンプした後で行われた更新を失うことなくデータベースを更新できます。
    </para>
    <para>
<!--
     Creation of a snapshot is not always possible.  In particular, it will
     fail when connected to a hot standby.  Applications that do not require
     snapshot export may suppress it with the <literal>NOEXPORT_SNAPSHOT</literal>
     option.
-->
スナップショットの作成はいつでも可能なわけではありません。
とりわけ、ホットスタンバイに接続するときは失敗します。
スナップショットのエクスポートが必要ないアプリケーションは、<literal>NOEXPORT_SNAPSHOT</literal>オプションを使ってスナップショットのエクスポートを抑止できます。
    </para>
   </sect2>
  </sect1>

  <sect1 id="logicaldecoding-walsender">
<!--
   <title>Streaming Replication Protocol Interface</title>
-->
   <title>ストリーミングレプリケーションプロトコルインタフェース</title>

   <para>
<!--
    The commands
-->
コマンド
    <itemizedlist>
     <listitem>
      <para><literal>CREATE_REPLICATION_SLOT <replaceable>slot_name</replaceable> LOGICAL <replaceable>output_plugin</replaceable></literal></para>
     </listitem>

     <listitem>
      <para><literal>DROP_REPLICATION_SLOT <replaceable>slot_name</replaceable></literal> <optional> <literal>WAIT</literal> </optional></para>
     </listitem>

     <listitem>
      <para><literal>START_REPLICATION SLOT <replaceable>slot_name</replaceable> LOGICAL ...</literal></para>
     </listitem>
    </itemizedlist>
<!--
    are used to create, drop, and stream changes from a replication
    slot, respectively. These commands are only available over a replication
    connection; they cannot be used via SQL.
    See <xref linkend="protocol-replication"/> for details on these commands.
-->
は、それぞれレプリケーションスロットに対して更新データを生成、削除、ストリームします。
これらのコマンドは、レプリケーション接続でのみ使用できます。
SQLでは使用できません。
これらのコマンドの詳細については<xref linkend="protocol-replication"/>を参照してください。
   </para>

   <para>
<!--
    The command <xref linkend="app-pgrecvlogical"/> can be used to control
    logical decoding over a streaming replication connection.  (It uses
    these commands internally.)
-->
コマンド<xref linkend="app-pgrecvlogical"/>を使ってストリーミングコネクション上のロジカルデコーディングを制御できます(このコマンドは内部で上記のコマンドを使っています)。
   </para>
  </sect1>

  <sect1 id="logicaldecoding-sql">
<!--
   <title>Logical Decoding <acronym>SQL</acronym> Interface</title>
-->
   <title>ロジカルデコーディング<acronym>SQL</acronym>インタフェース</title>

   <para>
<!--
     See <xref linkend="functions-replication"/> for detailed documentation on
     the SQL-level API for interacting with logical decoding.
-->
ロジカルデコーディングのSQLレベルのAPIの詳細については、<xref linkend="functions-replication"/>を参照してください。
   </para>

   <para>
<!--
    Synchronous replication (see <xref linkend="synchronous-replication"/>) is
    only supported on replication slots used over the streaming replication interface. The
    function interface and additional, non-core interfaces do not support
    synchronous replication.
-->
同期レプリケーション(<xref linkend="synchronous-replication"/>参照)は、ストリーミングレプリケーションによるレプリケーションスロット上でのみサポートされます。
関数インタフェースおよびコアに対する追加のインタフェースでは同期レプリケーションをサポートしていません。
   </para>
  </sect1>

  <sect1 id="logicaldecoding-catalogs">
<!--
   <title>System Catalogs Related to Logical Decoding</title>
-->
   <title>ロジカルデコーディング関連のシステムカタログ</title>

   <para>
<!--
    The <link linkend="view-pg-replication-slots"><structname>pg_replication_slots</structname></link>
    view and the
    <link linkend="monitoring-pg-stat-replication-view">
    <structname>pg_stat_replication</structname></link>
    view provide information about the current state of replication slots and
    streaming replication connections respectively. These views apply to both physical and
    logical replication. The
    <link linkend="monitoring-pg-stat-replication-slots-view">
    <structname>pg_stat_replication_slots</structname></link>
    view provides statistics information about the logical replication slots.
-->
<link linkend="view-pg-replication-slots"><structname>pg_replication_slots</structname></link>ビューと<link linkend="monitoring-pg-stat-replication-view"><structname>pg_stat_replication</structname></link>ビューは、レプリケーションスロット、ストリーミングレプリケーションのコネクションのそれぞれの現在の状態に関する情報を提供します。
<link linkend="monitoring-pg-stat-replication-slots-view"><structname>pg_stat_replication_slots</structname></link>ビューは、ロジカルレプリケーションスロットに関する統計情報を提供します。
   </para>
  </sect1>

  <sect1 id="logicaldecoding-output-plugin">
<!--
   <title>Logical Decoding Output Plugins</title>
-->
   <title>ロジカルデコーディングの出力プラグイン</title>
   <para>
<!--
    An example output plugin can be found in the
    <link linkend="test-decoding">
     <filename>contrib/test_decoding</filename>
    </link>
    subdirectory of the PostgreSQL source tree.
-->
PostgreSQLのソースコードのサブディレクトリ<link linkend="test-decoding">
     <filename>contrib/test_decoding</filename>
    </link>にサンプル出力プラグインがあります。
   </para>
   <sect2 id="logicaldecoding-output-init">
<!--
    <title>Initialization Function</title>
-->
    <title>初期化関数</title>
    <indexterm zone="logicaldecoding-output-init">
     <primary>_PG_output_plugin_init</primary>
    </indexterm>
    <para>
<!--
     An output plugin is loaded by dynamically loading a shared library with
     the output plugin's name as the library base name. The normal library
     search path is used to locate the library. To provide the required output
     plugin callbacks and to indicate that the library is actually an output
     plugin it needs to provide a function named
     <function>_PG_output_plugin_init</function>. This function is passed a
     struct that needs to be filled with the callback function pointers for
     individual actions.
-->
出力プラグインは、出力プラグインの名前をライブラリのベース名として持つ共有ライブラリを動的にロードすることによってロードされます。
必要な出力プラグインコールバックを提供し、そのライブラリが実際に出力プラグインであることを示すために、<function>_PG_output_plugin_init</function>という名前の関数を作成しなければなりません。
この関数には、各々のアクションに対応するコールバック関数へのポインタを持つ構造体が渡されます。
<programlisting>
typedef struct OutputPluginCallbacks
{
    LogicalDecodeStartupCB startup_cb;
    LogicalDecodeBeginCB begin_cb;
    LogicalDecodeChangeCB change_cb;
    LogicalDecodeTruncateCB truncate_cb;
    LogicalDecodeCommitCB commit_cb;
    LogicalDecodeMessageCB message_cb;
    LogicalDecodeFilterByOriginCB filter_by_origin_cb;
    LogicalDecodeShutdownCB shutdown_cb;
    LogicalDecodeFilterPrepareCB filter_prepare_cb;
    LogicalDecodeBeginPrepareCB begin_prepare_cb;
    LogicalDecodePrepareCB prepare_cb;
    LogicalDecodeCommitPreparedCB commit_prepared_cb;
    LogicalDecodeRollbackPreparedCB rollback_prepared_cb;
    LogicalDecodeStreamStartCB stream_start_cb;
    LogicalDecodeStreamStopCB stream_stop_cb;
    LogicalDecodeStreamAbortCB stream_abort_cb;
    LogicalDecodeStreamPrepareCB stream_prepare_cb;
    LogicalDecodeStreamCommitCB stream_commit_cb;
    LogicalDecodeStreamChangeCB stream_change_cb;
    LogicalDecodeStreamMessageCB stream_message_cb;
    LogicalDecodeStreamTruncateCB stream_truncate_cb;
} OutputPluginCallbacks;

typedef void (*LogicalOutputPluginInit) (struct OutputPluginCallbacks *cb);
</programlisting>
<!--
     The <function>begin_cb</function>, <function>change_cb</function>
     and <function>commit_cb</function> callbacks are required,
     while <function>startup_cb</function>, <function>truncate_cb</function>,
     <function>message_cb</function>, <function>filter_by_origin_cb</function>,
     and <function>shutdown_cb</function> are optional.
     If <function>truncate_cb</function> is not set but a
     <command>TRUNCATE</command> is to be decoded, the action will be ignored.
-->
コールバック関数の<function>begin_cb</function>、<function>change_cb</function>、および、<function>commit_cb</function>は必須ですが、<function>startup_cb</function>、<function>truncate_cb</function>、<function>message_cb</function>、<function>filter_by_origin_cb</function>、および、<function>shutdown_cb</function>は必須ではありません。
<function>truncate_cb</function>が設定されていないけれども、<command>TRUNCATE</command>がデコードされることになった場合、この動作は無視されます。
    </para>

    <para>
<!--
     An output plugin may also define functions to support streaming of large,
     in-progress transactions. The <function>stream_start_cb</function>,
     <function>stream_stop_cb</function>, <function>stream_abort_cb</function>,
     <function>stream_commit_cb</function>, and <function>stream_change_cb</function>
     are required, while <function>stream_message_cb</function> and
     <function>stream_truncate_cb</function> are optional. The
     <function>stream_prepare_cb</function> is also required if the output
     plugin also support two-phase commits.
-->
出力プラグインは、大きな継続中(in-progress)トランザクションのストリーミングをサポートする関数を定義することもできます。
<function>stream_start_cb</function>、<function>stream_stop_cb</function>、<function>stream_abort_cb</function>、<function>stream_commit_cb</function>、<function>stream_change_cb</function>は必須ですが、<function>stream_message_cb</function>と<function>stream_truncate_cb</function>は必須ではありません。
出力プラグインが2相コミットもサポートする場合は、<function>stream_prepare_cb</function>も必須です。
    </para>

    <para>
<!--
    An output plugin may also define functions to support two-phase commits,
    which allows actions to be decoded on the <command>PREPARE TRANSACTION</command>.
    The <function>begin_prepare_cb</function>, <function>prepare_cb</function>,
    <function>commit_prepared_cb</function> and <function>rollback_prepared_cb</function>
    callbacks are required, while <function>filter_prepare_cb</function> is optional.
    The <function>stream_prepare_cb</function> is also required if the output plugin
    also supports the streaming of large in-progress transactions.
-->
出力プラグインは、<command>PREPARE TRANSACTION</command>でアクションをデコードできるようにする2相コミットをサポートする関数を定義することもできます。
<function>begin_prepare_cb</function>、<function>prepare_cb</function>、<function>commit_prepared_cb</function>、<function>rollback_prepared_cb</function>コールバックは必須ですが、<function>filter_prepare_cb</function>は必須ではありません。
出力プラグインが大きな進行中のトランザクションのストリーミングもサポートしている場合は、<function>stream_prepare_cb</function>も必須です。
    </para>
   </sect2>

   <sect2 id="logicaldecoding-capabilities">
<!--
    <title>Capabilities</title>
-->
    <title>機能</title>

    <para>
<!--
     To decode, format and output changes, output plugins can use most of the
     backend's normal infrastructure, including calling output functions. Read
     only access to relations is permitted as long as only relations are
     accessed that either have been created by <command>initdb</command> in
     the <literal>pg_catalog</literal> schema, or have been marked as user
     provided catalog tables using
-->
更新データをデコード、整形、出力するために、出力関数を呼び出すことを含め、出力プラグインはバックエンドの通常のインフラストラクチャのほとんどを利用できます。
テーブルは、<command>initdb</command>で作られ、<literal>pg_catalog</literal>スキーマに含まれているか、以下のコマンドでユーザ定義のカタログテーブルであると印が付けられている限り、読み込み専用のアクセスが許可されます。
<programlisting>
ALTER TABLE user_catalog_table SET (user_catalog_table = true);
CREATE TABLE another_catalog_table(data text) WITH (user_catalog_table = true);
</programlisting>
<!--
     Note that access to user catalog tables or regular system catalog tables
     in the output plugins has to be done via the <literal>systable_*</literal>
     scan APIs only. Access via the <literal>heap_*</literal> scan APIs will
     error out. Additionally, any actions leading to transaction ID assignment
     are prohibited. That, among others, includes writing to tables, performing
     DDL changes, and calling <literal>pg_current_xact_id()</literal>.
-->
出力プラグイン内のユーザカタログテーブルまたは通常のシステムカタログテーブルへのアクセスは、<literal>systable_*</literal>スキャンAPIを介してのみ行う必要があることに注意してください。
<literal>heap_*</literal>スキャンAPIを介したアクセスはエラーになります。
さらに、トランザクションIDの割り当てにつながるアクションは禁止されています。
これには、テーブルへの書き込み、DDL変更の実行、<literal>pg_current_xact_id()</literal>の呼び出しなどが含まれます。
    </para>
   </sect2>

   <sect2 id="logicaldecoding-output-mode">
<!--
    <title>Output Modes</title>
-->
    <title>出力モード</title>

    <para>
<!--
     Output plugin callbacks can pass data to the consumer in nearly arbitrary
     formats. For some use cases, like viewing the changes via SQL, returning
     data in a data type that can contain arbitrary data (e.g., <type>bytea</type>) is
     cumbersome. If the output plugin only outputs textual data in the
     server's encoding, it can declare that by
     setting <literal>OutputPluginOptions.output_type</literal>
     to <literal>OUTPUT_PLUGIN_TEXTUAL_OUTPUT</literal> instead
     of <literal>OUTPUT_PLUGIN_BINARY_OUTPUT</literal> in
     the <link linkend="logicaldecoding-output-plugin-startup">startup
     callback</link>. In that case, all the data has to be in the server's encoding
     so that a <type>text</type> datum can contain it. This is checked in assertion-enabled
     builds.
-->
出力プラグインコールバックは、かなり自由な形式で消費者にデータを渡すことができます。
SQLで変更データを見るような場合、任意のかたちでデータを返すことのできるデータ型(たとえば<type>bytea</type>)は扱いにくいです。
出力プラグインがサーバエンコーディングのテキストデータのみを含むことにするには、<link linkend="logicaldecoding-output-plugin-startup">起動コールバック</link>で、<literal>OutputPluginOptions.output_type</literal>に<literal>OUTPUT_PLUGIN_BINARY_OUTPUT</literal>ではなく、<literal>OUTPUT_PLUGIN_TEXTUAL_OUTPUT</literal>を設定することによって宣言できます。
この場合、<type>text</type>datumが格納することができるように、すべてのデータはサーバエンコーディングでエンコードされていなければなりません。
    </para>
   </sect2>

   <sect2 id="logicaldecoding-output-plugin-callbacks">
<!--
    <title>Output Plugin Callbacks</title>
-->
    <title>出力プラグインコールバック</title>

    <para>
<!--
     An output plugin gets notified about changes that are happening via
     various callbacks it needs to provide.
-->
出力プラグインには、必要に応じて発生した更新に関する通知が様々なコールバックを通じて送られます。
    </para>

    <para>
<!--
     Concurrent transactions are decoded in commit order, and only changes
     belonging to a specific transaction are decoded between
     the <literal>begin</literal> and <literal>commit</literal>
     callbacks. Transactions that were rolled back explicitly or implicitly
     never get
     decoded. Successful savepoints are
     folded into the transaction containing them in the order they were
     executed within that transaction. A transaction that is prepared for
     a two-phase commit using <command>PREPARE TRANSACTION</command> will
     also be decoded if the output plugin callbacks needed for decoding
     them are provided. It is possible that the current prepared transaction
     which is being decoded is aborted concurrently via a
     <command>ROLLBACK PREPARED</command> command. In that case, the logical
     decoding of this transaction will be aborted too. All the changes of such
     a transaction are skipped once the abort is detected and the
     <function>prepare_cb</function> callback is invoked. Thus even in case of
     a concurrent abort, enough information is provided to the output plugin
     for it to properly deal with <command>ROLLBACK PREPARED</command> once
     that is decoded.
-->
同時に実行されたトランザクションは、コミットした順番にデコードされます。
指定したトランザクションに含まれる更新だけが<literal>begin</literal>と<literal>commit</literal>の間のコールバックによってデコードされます。
明示的あるいは暗黙的にロールバックされたトランザクションは、決してデコードされません。
成功したセーブポイントは、実行された順番にセーブポイントが実行されたトランザクションの中に折り込まれます。
<command>PREPARE TRANSACTION</command>を使用して2相コミット用に準備されたトランザクションも、デコードに必要な出力プラグインコールバックが提供されていればデコードされます。
<command>ROLLBACK PREPARED</command>コマンドを使用して、現在準備されているトランザクションが同時にアボートされる可能性があります。
その場合、このトランザクションのロジカルデコーディングもアボートされます。
そのようなトランザクションのすべての変更は、アボートが検出され、<function>prepare_cb</function>コールバックが呼び出されるとスキップされます。
このように、同時にアボートされた場合でも、デコードされた<command>ROLLBACK PREPARED</command>を適切に処理するために十分な情報が出力プラグインに提供されます。
    </para>

    <note>
     <para>
<!--
      Only transactions that have already safely been flushed to disk will be
      decoded. That can lead to a <command>COMMIT</command> not immediately being decoded in a
      directly following <literal>pg_logical_slot_get_changes()</literal>
      when <varname>synchronous_commit</varname> is set
      to <literal>off</literal>.
-->
ディスクに安全にフラッシュされたトランザクションだけがデコードされます。
そのため、<varname>synchronous_commit</varname>が<literal>off</literal>の場合には、直後に呼び出された<literal>pg_logical_slot_get_changes()</literal>がその<command>COMMIT</command>をデコードしないことがあります。
     </para>
    </note>

    <sect3 id="logicaldecoding-output-plugin-startup">
<!--
     <title>Startup Callback</title>
-->
     <title>開始コールバック</title>
     <para>
<!--
      The optional <function>startup_cb</function> callback is called whenever
      a replication slot is created or asked to stream changes, independent
      of the number of changes that are ready to be put out.
-->
ストリームに投入可能な更新の数に関係なく、レプリケーションスロットが作られるか、ストリームの変更がリクエストされた場合にオプションの<function>startup_cb</function>コールバック呼び出されます。
<programlisting>
typedef void (*LogicalDecodeStartupCB) (struct LogicalDecodingContext *ctx,
                                        OutputPluginOptions *options,
                                        bool is_init);
</programlisting>
<!--
      The <literal>is_init</literal> parameter will be true when the
      replication slot is being created and false
      otherwise. <parameter>options</parameter> points to a struct of options
      that output plugins can set:
-->
<literal>is_init</literal> パラメータは、レプリケーションスロットが作られる際にはtrue、それ以外ではfalseになります。
<parameter>options</parameter>は、出力プラグインが書き込む以下の構造体を指します。
<programlisting>
typedef struct OutputPluginOptions
{
    OutputPluginOutputType output_type;
    bool        receive_rewrites;
} OutputPluginOptions;
</programlisting>
<!--
      <literal>output_type</literal> has to either be set to
      <literal>OUTPUT_PLUGIN_TEXTUAL_OUTPUT</literal>
      or <literal>OUTPUT_PLUGIN_BINARY_OUTPUT</literal>. See also
      <xref linkend="logicaldecoding-output-mode"/>.
      If <literal>receive_rewrites</literal> is true, the output plugin will
      also be called for changes made by heap rewrites during certain DDL
      operations.  These are of interest to plugins that handle DDL
      replication, but they require special handling.
-->
<literal>output_type</literal>は<literal>OUTPUT_PLUGIN_TEXTUAL_OUTPUT</literal>か<literal>OUTPUT_PLUGIN_BINARY_OUTPUT</literal>のどちらかです。
<xref linkend="logicaldecoding-output-mode"/>も参照してください。
<literal>receive_rewrites</literal>が真なら、何らかDDL操作時のヒープ書き換えで生じた変更に対して、出力プラグインも呼ばれます。
これはDDLレプリケーションを処理するプラグインを対象としていますが、これらは特別な処理を必要とします。
     </para>

     <para>
<!--
      The startup callback should validate the options present in
      <literal>ctx-&gt;output_plugin_options</literal>. If the output plugin
      needs to have a state, it can
      use <literal>ctx-&gt;output_plugin_private</literal> to store it.
-->
開始コールバックでは、<literal>ctx-&gt;output_plugin_options</literal>で指定されるオプションを検証しましょう。
出力プラグインが状態を持つ必要がある場合には、<literal>ctx-&gt;output_plugin_private</literal>を利用できます。
     </para>
    </sect3>

    <sect3 id="logicaldecoding-output-plugin-shutdown">
<!--
     <title>Shutdown Callback</title>
-->
     <title>終了コールバック</title>

     <para>
<!--
      The optional <function>shutdown_cb</function> callback is called
      whenever a formerly active replication slot is not used anymore and can
      be used to deallocate resources private to the output plugin. The slot
      isn't necessarily being dropped, streaming is just being stopped.
-->
以前アクティブだったレプリケーションスロットが使われなくなったら、いつでも<function>shutdown_cb</function>コールバックが呼び出され、出力プラグインのプライベートリソースが解放されます。
スロットは削除される必要はありません。単にストリームが停止します。
<programlisting>
typedef void (*LogicalDecodeShutdownCB) (struct LogicalDecodingContext *ctx);
</programlisting>
     </para>
    </sect3>

    <sect3 id="logicaldecoding-output-plugin-begin">
<!--
     <title>Transaction Begin Callback</title>
-->
     <title>トランザクション開始コールバック</title>

     <para>
<!--
      The required <function>begin_cb</function> callback is called whenever a
      start of a committed transaction has been decoded. Aborted transactions
      and their contents never get decoded.
-->
必須である<function>begin_cb</function>コールバックは、コミットしたトランザクションの開始がデコードされる際に必ず呼び出されます。
アボートしたトランザクションとその内容は決してデコードされません。
<programlisting>
typedef void (*LogicalDecodeBeginCB) (struct LogicalDecodingContext *ctx,
                                      ReorderBufferTXN *txn);
</programlisting>
<!--
      The <parameter>txn</parameter> parameter contains meta information about
      the transaction, like the time stamp at which it has been committed and
      its XID.
-->
<parameter>txn</parameter>引数は、コミット時のタイムスタンプやトランザクションIDなどのトランザクションに関するメタ情報を含みます。
     </para>
    </sect3>

    <sect3 id="logicaldecoding-output-plugin-commit">
<!--
     <title>Transaction End Callback</title>
-->
     <title>トランザクション終了コールバック</title>

     <para>
<!--
      The required <function>commit_cb</function> callback is called whenever
      a transaction commit has been
      decoded. The <function>change_cb</function> callbacks for all modified
      rows will have been called before this, if there have been any modified
      rows.
-->
必須である<function>commit_cb</function>コールバックは、トランザクションのコミットがデコードされる際に必ず呼び出されます。
行が更新された場合は、それぞれの行に対して<function>change_cb</function>コールバックが、<function>commit_cb</function>の前に呼び出されます。
<programlisting>
typedef void (*LogicalDecodeCommitCB) (struct LogicalDecodingContext *ctx,
                                       ReorderBufferTXN *txn,
                                       XLogRecPtr commit_lsn);
</programlisting>
     </para>
    </sect3>

    <sect3 id="logicaldecoding-output-plugin-change">
<!--
     <title>Change Callback</title>
-->
     <title>更新コールバック</title>

     <para>
<!--
      The required <function>change_cb</function> callback is called for every
      individual row modification inside a transaction, may it be
      an <command>INSERT</command>, <command>UPDATE</command>,
      or <command>DELETE</command>. Even if the original command modified
      several rows at once the callback will be called individually for each
      row. The <function>change_cb</function> callback may access system or
      user catalog tables to aid in the process of outputting the row
      modification details. In case of decoding a prepared (but yet
      uncommitted) transaction or decoding of an uncommitted transaction, this
      change callback might also error out due to simultaneous rollback of
      this very same transaction. In that case, the logical decoding of this
      aborted transaction is stopped gracefully.
-->
トランザクション内の<command>INSERT</command>、<command>UPDATE</command>、<command>DELETE</command>の更新に対して、必須コールバックである<function>change_cb</function>が呼び出されます。
元の更新コマンドが複数の行を一度に更新する場合は、それぞれの行に対してこのコールバックが呼び出されます。
<function>change_cb</function>コールバックは、システムまたはユーザカタログテーブルにアクセスして、行変更の詳細を出力する処理を支援することができます。
準備された(まだコミットされていない)トランザクションをデコードする場合、またはコミットされていないトランザクションをデコードする場合、この変更コールバックは、まったく同じトランザクションが同時にロールバックされるためにエラーになることもあります。
この場合、このアボートされたトランザクションのロジカルデコーディングは正常に停止されます。
<programlisting>
typedef void (*LogicalDecodeChangeCB) (struct LogicalDecodingContext *ctx,
                                       ReorderBufferTXN *txn,
                                       Relation relation,
                                       ReorderBufferChange *change);
</programlisting>
<!--
      The <parameter>ctx</parameter> and <parameter>txn</parameter> parameters
      have the same contents as for the <function>begin_cb</function>
      and <function>commit_cb</function> callbacks, but additionally the
      relation descriptor <parameter>relation</parameter> points to the
      relation the row belongs to and a struct
      <parameter>change</parameter> describing the row modification are passed
      in.
-->
<parameter>ctx</parameter>と<parameter>txn</parameter>は、<function>begin_cb</function>、<function>commit_cb</function>コールバックでは同じ内容になります。
これに加えて<parameter>relation</parameter>は行が属するリレーションを指定し、行の変更を記述する<parameter>change</parameter>パラメータが渡されます。
     </para>

     <note>
      <para>
<!--
       Only changes in user defined tables that are not unlogged
       (see <xref linkend="sql-createtable-unlogged"/>) and not temporary
       (see <xref linkend="sql-createtable-temporary"/>) can be extracted using
       logical decoding.
-->
ユーザ定義テーブルでは、ログを取らないテーブル（<xref linkend="sql-createtable-unlogged"/>参照）ではなく、一時テーブル（<xref linkend="sql-createtable-temporary"/>参照）でもないテーブルが、ロジカルデコーディングを使って更新データを取得できます。
      </para>
     </note>
    </sect3>

    <sect3 id="logicaldecoding-output-plugin-truncate">
<!--
     <title>Truncate Callback</title>
-->
     <title>TRUNCATEコールバック</title>

     <para>
<!--
      The optional <function>truncate_cb</function> callback is called for a
      <command>TRUNCATE</command> command.
-->
オプションの<function>truncate_cb</function>コールバックは、<command>TRUNCATE</command>コマンドに対して呼ばれます。
<programlisting>
typedef void (*LogicalDecodeTruncateCB) (struct LogicalDecodingContext *ctx,
                                         ReorderBufferTXN *txn,
                                         int nrelations,
                                         Relation relations[],
                                         ReorderBufferChange *change);
</programlisting>
<!--
      The parameters are analogous to the <function>change_cb</function>
      callback.  However, because <command>TRUNCATE</command> actions on
      tables connected by foreign keys need to be executed together, this
      callback receives an array of relations instead of just a single one.
      See the description of the <xref linkend="sql-truncate"/> statement for
      details.
-->
パラメータは<function>change_cb</function>コールバックと似ています。
しかしながら、外部キーで結びついたテーブル群の<command>TRUNCATE</command>動作は一緒に実行される必要があるため、このコールバックは単一リレーションではなく、リレーションの配列を受け取ります。
詳しくは<xref linkend="sql-truncate"/>文の説明を参照してください。
     </para>
    </sect3>

     <sect3 id="logicaldecoding-output-plugin-filter-origin">
<!--
     <title>Origin Filter Callback</title>
-->
     <title>オリジンフィルタコールバック</title>

     <para>
<!--
       The optional <function>filter_by_origin_cb</function> callback
       is called to determine whether data that has been replayed
       from <parameter>origin_id</parameter> is of interest to the
       output plugin.
-->
オプションの<function>filter_by_origin_cb</function>コールバックは、<parameter>origin_id</parameter>からリプレイされたデータが出力プラグインの対象となるかどうかを判定するために呼び出されます。
<programlisting>
typedef bool (*LogicalDecodeFilterByOriginCB) (struct LogicalDecodingContext *ctx,
                                               RepOriginId origin_id);
</programlisting>
<!--
      The <parameter>ctx</parameter> parameter has the same contents
      as for the other callbacks. No information but the origin is
      available. To signal that changes originating on the passed in
      node are irrelevant, return true, causing them to be filtered
      away; false otherwise. The other callbacks will not be called
      for transactions and changes that have been filtered away.
-->
<parameter>ctx</parameter>パラメータは、他のコールバックと同じ内容を持ちます。
オリジンの情報だけが得られます。
渡されたノードで発生した変更が無関係であることを伝えるには、trueを返します。
これにより、その変更は無視されることになります。
無視されたトランザクション変更に関わる他のコールバックは呼び出されません。
     </para>
     <para>
<!--
       This is useful when implementing cascading or multidirectional
       replication solutions. Filtering by the origin allows to
       prevent replicating the same changes back and forth in such
       setups.  While transactions and changes also carry information
       about the origin, filtering via this callback is noticeably
       more efficient.
-->
これは、カスケード、あるいは双方向レプリケーションソリューションを実装する際に有用です。
オリジンでフィルタすることにより、そのような構成で、同じ変更のレプリケーションが往復するのを防ぐことができます。
トランザクションや変更もオリジンに関する情報を持っていますが、このコールバックでフィルタするほうがずっと効率的です。
     </para>
     </sect3>

    <sect3 id="logicaldecoding-output-plugin-message">
<!--
     <title>Generic Message Callback</title>
-->
     <title>汎用メッセージコールバック</title>

     <para>
<!--
      The optional <function>message_cb</function> callback is called whenever
      a logical decoding message has been decoded.
-->
オプションの<function>message_cb</function>コールバックは、ロジカルデコーディングメッセージがデコードされる度に呼び出されます。
<programlisting>
typedef void (*LogicalDecodeMessageCB) (struct LogicalDecodingContext *ctx,
                                        ReorderBufferTXN *txn,
                                        XLogRecPtr message_lsn,
                                        bool transactional,
                                        const char *prefix,
                                        Size message_size,
                                        const char *message);
</programlisting>
<!--
      The <parameter>txn</parameter> parameter contains meta information about
      the transaction, like the time stamp at which it has been committed and
      its XID. Note however that it can be NULL when the message is
      non-transactional and the XID was not assigned yet in the transaction
      which logged the message. The <parameter>lsn</parameter> has WAL
      location of the message. The <parameter>transactional</parameter> says
      if the message was sent as transactional or not. Similar to the change
      callback, in case of decoding a prepared (but yet uncommitted)
      transaction or decoding of an uncommitted transaction, this message
      callback might also error out due to simultaneous rollback of
      this very same transaction. In that case, the logical decoding of this
      aborted transaction is stopped gracefully.

      The <parameter>prefix</parameter> is arbitrary null-terminated prefix
      which can be used for identifying interesting messages for the current
      plugin. And finally the <parameter>message</parameter> parameter holds
      the actual message of <parameter>message_size</parameter> size.
-->
<parameter>txn</parameter>パラメータは、コミット時のタイムスタンプとXIDのような、トランザクションに関するメタ情報を含んでいます。
ただし、そのメッセージがトランザクション扱いではなく、メッセージをログしたトランザクションにXIDが割り当てられてない場合はNULLになることに注意してください。
<parameter>lsn</parameter>は、メッセージに対応するWALの位置です。
<parameter>transactional</parameter>は、メッセージがトランザクションとして送られたものかどうかを表しています。
変更コールバックと同様に、準備された(まだコミットされていない)トランザクションをデコードする場合、またはコミットされていないトランザクションをデコードする場合、このメッセージコールバックも、まったく同じトランザクションの同時ロールバックのためにエラーになることがあります。
この場合、アボートされたトランザクションのロジカルデコーディングは正常に停止されます。

<parameter>prefix</parameter>はnull終端された任意の接頭辞で、現在のプラグインが興味のあるメッセージを特定するために利用できます。
最後に、<parameter>message</parameter>パラメータは、大きさが<parameter>message_size</parameter>の、実際のメッセージを保持します。
     </para>
     <para>
<!--
      Extra care should be taken to ensure that the prefix the output plugin
      considers interesting is unique. Using name of the extension or the
      output plugin itself is often a good choice.
-->
出力プラグインが利用を考慮している接頭辞が一意になるように、特に注意を払ってください。
拡張の名前か、出力プラグインの名前を使うのが良い場合が多いです。
     </para>
    </sect3>

    <sect3 id="logicaldecoding-output-plugin-filter-prepare">
<!--
     <title>Prepare Filter Callback</title>
-->
     <title>フィルタコールバックの準備</title>

     <para>
<!--
       The optional <function>filter_prepare_cb</function> callback
       is called to determine whether data that is part of the current
       two-phase commit transaction should be considered for decoding
       at this prepare stage or later as a regular one-phase transaction at
       <command>COMMIT PREPARED</command> time. To signal that
       decoding should be skipped, return <literal>true</literal>;
       <literal>false</literal> otherwise. When the callback is not
       defined, <literal>false</literal> is assumed (i.e. no filtering, all
       transactions using two-phase commit are decoded in two phases as well).
-->
オプションの<function>filter_prepare_cb</function>コールバックは、現在の2相コミットトランザクションの一部であるデータを、この準備段階でデコードするか、または<command>COMMIT PREPARED</command>時に通常の1相トランザクションとしてデコードするかを決定するために呼び出されます。
デコードをスキップするように合図するには、<literal>true</literal>を返します。
そうでなければ<literal>false</literal>を返します。
コールバックが定義されていない場合、<literal>false</literal>が想定されます(すなわち、フィルタリングなしで、2相コミットを使用するすべてのトランザクションも同様に2相でデコードされます)。
<programlisting>
typedef bool (*LogicalDecodeFilterPrepareCB) (struct LogicalDecodingContext *ctx,
                                              TransactionId xid,
                                              const char *gid);
</programlisting>
<!--
       The <parameter>ctx</parameter> parameter has the same contents as for
       the other callbacks. The parameters <parameter>xid</parameter>
       and <parameter>gid</parameter> provide two different ways to identify
       the transaction.  The later <command>COMMIT PREPARED</command> or
       <command>ROLLBACK PREPARED</command> carries both identifiers,
       providing an output plugin the choice of what to use.
-->
<parameter>ctx</parameter>パラメータは他のコールバックと同じ内容です。
パラメータ<parameter>xid</parameter>と<parameter>gid</parameter>は、トランザクションを識別するための2つの異なる方法を提供します。
後の<command>COMMIT PREPARED</command>または<command>ROLLBACK PREPARED</command>は両方の識別子を持ち、出力プラグインに何を使用するかの選択を提供します。
     </para>
     <para>
<!--
       The callback may be invoked multiple times per transaction to decode
       and must provide the same static answer for a given pair of
       <parameter>xid</parameter> and <parameter>gid</parameter> every time
       it is called.
-->
このコールバックは、デコードするトランザクションごとに複数回呼び出すことができ、呼び出されるたびに<parameter>xid</parameter>と<parameter>gid</parameter>の与えられたペアに対して同じ静的な答えを提供しなければなりません。
     </para>
     </sect3>

    <sect3 id="logicaldecoding-output-plugin-begin-prepare">
<!--
     <title>Transaction Begin Prepare Callback</title>
-->
     <title>トランザクション開始準備コールバック</title>

     <para>
<!--
      The required <function>begin_prepare_cb</function> callback is called
      whenever the start of a prepared transaction has been decoded. The
      <parameter>gid</parameter> field, which is part of the
      <parameter>txn</parameter> parameter, can be used in this callback to
      check if the plugin has already received this <command>PREPARE</command>
      in which case it can either error out or skip the remaining changes of
      the transaction.
-->
必須である<function>begin_prepare_cb</function>コールバックは、準備されたトランザクションの開始がデコードされるたびに呼び出されます。
<parameter>txn</parameter>パラメータの一部である<parameter>gid</parameter>フィールドをこのコールバックで使用して、プラグインがこの<command>PREPARE</command>を既に受信しているかどうかをチェックできます。
この場合、エラーになるか、トランザクションの残りの変更をスキップできます。
<programlisting>
typedef void (*LogicalDecodeBeginPrepareCB) (struct LogicalDecodingContext *ctx,
                                             ReorderBufferTXN *txn);
</programlisting>
     </para>
    </sect3>

    <sect3 id="logicaldecoding-output-plugin-prepare">
<!--
     <title>Transaction Prepare Callback</title>
-->
     <title>トランザクション準備コールバック</title>

     <para>
<!--
      The required <function>prepare_cb</function> callback is called whenever
      a transaction which is prepared for two-phase commit has been
      decoded. The <function>change_cb</function> callback for all modified
      rows will have been called before this, if there have been any modified
      rows. The <parameter>gid</parameter> field, which is part of the
      <parameter>txn</parameter> parameter, can be used in this callback.
-->
必須である<function>prepare_cb</function>コールバックは、2相コミット用に準備されたトランザクションがデコードされるたびに呼び出されます。
修正された行がある場合、すべての修正された行に対する<function>change_cb</function>コールバックはこの前に呼び出されています。
<parameter>txn</parameter>パラメータの一部である<parameter>gid</parameter>フィールドは、このコールバックで使用できます。
<programlisting>
typedef void (*LogicalDecodePrepareCB) (struct LogicalDecodingContext *ctx,
                                        ReorderBufferTXN *txn,
                                        XLogRecPtr prepare_lsn);
</programlisting>
     </para>
    </sect3>

    <sect3 id="logicaldecoding-output-plugin-commit-prepared">
<!--
     <title>Transaction Commit Prepared Callback</title>
-->
     <title>トランザクションコミット準備コールバック</title>

     <para>
<!--
      The required <function>commit_prepared_cb</function> callback is called
      whenever a transaction <command>COMMIT PREPARED</command> has been decoded.
      The <parameter>gid</parameter> field, which is part of the
      <parameter>txn</parameter> parameter, can be used in this callback.
-->
必須である<function>commit_prepared_cb</function>コールバックは、トランザクション<command>COMMIT PREPARED</command>がデコードされるたびに呼び出されます。
<parameter>txn</parameter>パラメータの一部である<parameter>gid</parameter>フィールドは、このコールバックで使用できます。
<programlisting>
typedef void (*LogicalDecodeCommitPreparedCB) (struct LogicalDecodingContext *ctx,
                                               ReorderBufferTXN *txn,
                                               XLogRecPtr commit_lsn);
</programlisting>
     </para>
    </sect3>

    <sect3 id="logicaldecoding-output-plugin-rollback-prepared">
<!--
     <title>Transaction Rollback Prepared Callback</title>
-->
     <title>トランザクションロールバック準備コールバック</title>

     <para>
<!--
      The required <function>rollback_prepared_cb</function> callback is called
      whenever a transaction <command>ROLLBACK PREPARED</command> has been
      decoded. The <parameter>gid</parameter> field, which is part of the
      <parameter>txn</parameter> parameter, can be used in this callback. The
      parameters <parameter>prepare_end_lsn</parameter> and
      <parameter>prepare_time</parameter> can be used to check if the plugin
      has received this <command>PREPARE TRANSACTION</command> in which case
      it can apply the rollback, otherwise, it can skip the rollback operation. The
      <parameter>gid</parameter> alone is not sufficient because the downstream
      node can have a prepared transaction with same identifier.
-->
必須である<function>rollback_prepared_cb</function>コールバックは、トランザクション<command>ROLLBACK PREPARED</command>がデコードされるたびに呼び出されます。
<parameter>txn</parameter>パラメータの一部である<parameter>gid</parameter>フィールドは、このコールバックで使用できます。
パラメータ<parameter>prepare_end_lsn</parameter>と<parameter>prepare_time</parameter>は、プラグインがこの<command>PREPARE TRANSACTION</command>を受信したかどうかをチェックするために使用できます。
この場合、プラグインはロールバックを適用できます。
そうでない場合は、ロールバック操作をスキップできます。
<parameter>gid</parameter>だけでは十分ではありません。
なぜなら、下流ノードは同じ識別子を持つ準備されたトランザクションを持つことができるからです。
<programlisting>
typedef void (*LogicalDecodeRollbackPreparedCB) (struct LogicalDecodingContext *ctx,
                                                 ReorderBufferTXN *txn,
                                                 XLogRecPtr prepare_end_lsn,
                                                 TimestampTz prepare_time);
</programlisting>
     </para>
    </sect3>

    <sect3 id="logicaldecoding-output-plugin-stream-start">
<!--
     <title>Stream Start Callback</title>
-->
     <title>ストリーム開始コールバック</title>
     <para>
<!--
      The required <function>stream_start_cb</function> callback is called when
      opening a block of streamed changes from an in-progress transaction.
-->
必須である<function>stream_start_cb</function>コールバックは、進行中のトランザクションからストリーム化された変更ブロックを開くときに呼び出されます。
<programlisting>
typedef void (*LogicalDecodeStreamStartCB) (struct LogicalDecodingContext *ctx,
                                            ReorderBufferTXN *txn);
</programlisting>
     </para>
    </sect3>

    <sect3 id="logicaldecoding-output-plugin-stream-stop">
<!--
     <title>Stream Stop Callback</title>
-->
     <title>ストリーム停止コールバック</title>
     <para>
<!--
      The required <function>stream_stop_cb</function> callback is called when
      closing a block of streamed changes from an in-progress transaction.
-->
必須である<function>stream_stop_cb</function>コールバックは、進行中のトランザクションからのストリーミング変更ブロックを閉じるときに呼び出されます。
<programlisting>
typedef void (*LogicalDecodeStreamStopCB) (struct LogicalDecodingContext *ctx,
                                           ReorderBufferTXN *txn);
</programlisting>
     </para>
    </sect3>

    <sect3 id="logicaldecoding-output-plugin-stream-abort">
<!--
     <title>Stream Abort Callback</title>
-->
     <title>ストリームアボートコールバック</title>
     <para>
<!--
      The required <function>stream_abort_cb</function> callback is called to
      abort a previously streamed transaction.
-->
必須である<function>stream_abort_cb</function>コールバックは、以前にストリームされたトランザクションを中止するために呼び出されます。
<programlisting>
typedef void (*LogicalDecodeStreamAbortCB) (struct LogicalDecodingContext *ctx,
                                            ReorderBufferTXN *txn,
                                            XLogRecPtr abort_lsn);
</programlisting>
     </para>
    </sect3>

    <sect3 id="logicaldecoding-output-plugin-stream-prepare">
<!--
     <title>Stream Prepare Callback</title>
-->
     <title>ストリーム準備コールバック</title>
     <para>
<!--
      The <function>stream_prepare_cb</function> callback is called to prepare
      a previously streamed transaction as part of a two-phase commit. This
      callback is required when the output plugin supports both the streaming
      of large in-progress transactions and two-phase commits.
-->
<function>stream_prepare_cb</function>コールバックは、2相コミットの一部としてストリーミングされているトランザクションを準備するために呼び出されます。
 このコールバックは、出力プラグインが大きな進行中のトランザクションと2相コミットの両方をストリーミングする場合に必要です。
      <programlisting>
typedef void (*LogicalDecodeStreamPrepareCB) (struct LogicalDecodingContext *ctx,
                                              ReorderBufferTXN *txn,
                                              XLogRecPtr prepare_lsn);
</programlisting>
     </para>
    </sect3>

    <sect3 id="logicaldecoding-output-plugin-stream-commit">
<!--
     <title>Stream Commit Callback</title>
-->
     <title>ストリームコミットコールバック</title>
     <para>
<!--
      The required <function>stream_commit_cb</function> callback is called to
      commit a previously streamed transaction.
-->
必須である<function>stream_commit_cb</function>コールバックは、以前にストリーミングされたトランザクションをコミットするために呼び出されます。
<programlisting>
typedef void (*LogicalDecodeStreamCommitCB) (struct LogicalDecodingContext *ctx,
                                             ReorderBufferTXN *txn,
                                             XLogRecPtr commit_lsn);
</programlisting>
     </para>
    </sect3>

    <sect3 id="logicaldecoding-output-plugin-stream-change">
<!--
     <title>Stream Change Callback</title>
-->
     <title>ストリーム変更コールバック</title>
     <para>
<!--
      The required <function>stream_change_cb</function> callback is called
      when sending a change in a block of streamed changes (demarcated by
      <function>stream_start_cb</function> and <function>stream_stop_cb</function> calls).
      The actual changes are not displayed as the transaction can abort at a later
      point in time and we don't decode changes for aborted transactions.
-->
必須である<function>stream_change_cb</function>コールバックは、ストリーム化された変更のブロック（<function>stream_start_cb</function>と<function>stream_stop_cb</function>呼び出しで区切られます）で変更を送信するときに呼び出されます。
実際の変更は表示されません。
なぜなら、トランザクションは後の時点でアボートする可能性があり、アボートされたトランザクションの変更はデコードされないからです。
<programlisting>
typedef void (*LogicalDecodeStreamChangeCB) (struct LogicalDecodingContext *ctx,
                                             ReorderBufferTXN *txn,
                                             Relation relation,
                                             ReorderBufferChange *change);
</programlisting>
     </para>
    </sect3>

    <sect3 id="logicaldecoding-output-plugin-stream-message">
<!--
     <title>Stream Message Callback</title>
-->
     <title>ストリームメッセージコールバック</title>
     <para>
<!--
      The optional <function>stream_message_cb</function> callback is called when
      sending a generic message in a block of streamed changes (demarcated by
      <function>stream_start_cb</function> and <function>stream_stop_cb</function> calls).
      The message contents for transactional messages are not displayed as the transaction
      can abort at a later point in time and we don't decode changes for aborted
      transactions.
-->
オプションの<function>stream_message_cb</function>コールバックは、ストリーム化された変更のブロック（<function>stream_start_cb</function>と<function>stream_stop_cb</function>コールで区切られた）で汎用メッセージを送信するときに呼び出されます。
トランザクションメッセージのメッセージ内容は表示されません。
なぜなら、トランザクションは後の時点でアボートする可能性があり、アボートされたトランザクションの変更はデコードされないからです。
<programlisting>
typedef void (*LogicalDecodeStreamMessageCB) (struct LogicalDecodingContext *ctx,
                                              ReorderBufferTXN *txn,
                                              XLogRecPtr message_lsn,
                                              bool transactional,
                                              const char *prefix,
                                              Size message_size,
                                              const char *message);
</programlisting>
     </para>
    </sect3>

    <sect3 id="logicaldecoding-output-plugin-stream-truncate">
<!--
     <title>Stream Truncate Callback</title>
-->
     <title>ストリームTRUNCATEコールバック</title>
     <para>
<!--
      The optional <function>stream_truncate_cb</function> callback is called
      for a <command>TRUNCATE</command> command in a block of streamed changes
      (demarcated by <function>stream_start_cb</function> and
      <function>stream_stop_cb</function> calls).
-->
オプションの<function>stream_truncate_cb</function>コールバックは、ストリーム化された変更のブロック（<function>stream_start_cb</function>と<function>stream_stop_cb</function>呼び出しで区切られます）内の<command>TRUNCATE</command>コマンドに対して呼び出されます。
<programlisting>
typedef void (*LogicalDecodeStreamTruncateCB) (struct LogicalDecodingContext *ctx,
                                               ReorderBufferTXN *txn,
                                               int nrelations,
                                               Relation relations[],
                                               ReorderBufferChange *change);
</programlisting>
<!--
      The parameters are analogous to the <function>stream_change_cb</function>
      callback.  However, because <command>TRUNCATE</command> actions on
      tables connected by foreign keys need to be executed together, this
      callback receives an array of relations instead of just a single one.
      See the description of the <xref linkend="sql-truncate"/> statement for
      details.
-->
パラメータは<function>stream_change_cb</function>コールバックに類似しています。
ただし、外部キーで接続されたテーブルに対する<command>TRUNCATE</command>アクションは一緒に実行する必要があるため、このコールバックは単一のリレーションではなくリレーションの配列を受け取ります。
詳細は<xref linkend="sql-truncate"/>文の説明を参照してください。
     </para>
    </sect3>

   </sect2>

   <sect2 id="logicaldecoding-output-plugin-output">
<!--
    <title>Functions for Producing Output</title>
-->
    <title>出力生成関数</title>

    <para>
<!--
     To actually produce output, output plugins can write data to
     the <literal>StringInfo</literal> output buffer
     in <literal>ctx-&gt;out</literal> when inside
     the <function>begin_cb</function>, <function>commit_cb</function>,
     or <function>change_cb</function> callbacks. Before writing to the output
     buffer, <function>OutputPluginPrepareWrite(ctx, last_write)</function> has
     to be called, and after finishing writing to the
     buffer, <function>OutputPluginWrite(ctx, last_write)</function> has to be
     called to perform the write. The <parameter>last_write</parameter>
     indicates whether a particular write was the callback's last write.
-->
<function>begin_cb</function>、<function>commit_cb</function>、<function>change_cb</function>コールバックにおいて、出力プラグインは実際にデータ出力するために<literal>ctx-&gt;out</literal>の<literal>StringInfo</literal>出力バッファに書き込みます。
出力バッファに書き込む前に、<function>OutputPluginPrepareWrite(ctx, last_write)</function>を呼び出します。
また、書き込みバッファにデータを書き終えたら、<function>OutputPluginWrite(ctx, last_write)</function>を呼び出してデータの書き込みを実施します。
<parameter>last_write</parameter>引数により、その書き込みがコールバックの最終的な書き込みであるかどうかを指定します。
    </para>

    <para>
<!--
     The following example shows how to output data to the consumer of an
     output plugin:
-->
以下の例では、出力プラグインにおいて消費者に向けてデータを出力する方法を示します。
<programlisting>
OutputPluginPrepareWrite(ctx, true);
appendStringInfo(ctx->out, "BEGIN %u", txn->xid);
OutputPluginWrite(ctx, true);
</programlisting>
    </para>
   </sect2>
  </sect1>

  <sect1 id="logicaldecoding-writer">
<!--
   <title>Logical Decoding Output Writers</title>
-->
   <title>ロジカルデコーディング出力ライタ</title>

   <para>
<!--
    It is possible to add more output methods for logical decoding.
    For details, see
    <filename>src/backend/replication/logical/logicalfuncs.c</filename>.
    Essentially, three functions need to be provided: one to read WAL, one to
    prepare writing output, and one to write the output
    (see <xref linkend="logicaldecoding-output-plugin-output"/>).
-->
ロジカルデコーディングに、別な出力方法を追加することもできます。
<filename>src/backend/replication/logical/logicalfuncs.c</filename>を参照してください。
基本的に、3つの関数を用意する必要があります。
WALを読む関数、出力データの書き込みを準備する関数、それに出力データを書き込む関数です。
(<xref linkend="logicaldecoding-output-plugin-output"/>参照)。
   </para>
  </sect1>

  <sect1 id="logicaldecoding-synchronous">
<!--
   <title>Synchronous Replication Support for Logical Decoding</title>
-->
   <title>ロジカルデコーディングにおける同期レプリケーションのサポート</title>
   <sect2 id="logicaldecoding-synchronous-overview">
<!--
    <title>Overview</title>
-->
    <title>概要</title>

    <para>
<!--
     Logical decoding can be used to build
     <link linkend="synchronous-replication">synchronous
     replication</link> solutions with the same user interface as synchronous
     replication for <link linkend="streaming-replication">streaming
     replication</link>.  To do this, the streaming replication interface
     (see <xref linkend="logicaldecoding-walsender"/>) must be used to stream out
     data. Clients have to send <literal>Standby status update (F)</literal>
     (see <xref linkend="protocol-replication"/>) messages, just like streaming
     replication clients do.
-->
<link linkend="streaming-replication">ストリーミングレプリケーション</link>における同期レプリケーションと同じユーザインタフェースで、ロジカルデコーディングを使って<link linkend="synchronous-replication">同期レプリケーション</link>ソリューションを構築することができます。
そのためには、ストリーミングレプリケーションインタフェース（<xref linkend="logicaldecoding-walsender"/>参照）を使ってデータをストリーム出力します。
クライアントは、ストリーミングレプリケーションクライアントと同様に、<literal>スタンバイ状態の更新(F)</literal>メッセージを送信する必要があります（<xref linkend="protocol-replication"/>参照）。
    </para>

    <note>
     <para>
<!--
      A synchronous replica receiving changes via logical decoding will work in
      the scope of a single database. Since, in contrast to
      that, <parameter>synchronous_standby_names</parameter> currently is
      server wide, this means this technique will not work properly if more
      than one database is actively used.
-->
<parameter>synchronous_standby_names</parameter>がサーバ全体に適用されるのに対し、ロジカルデコーディングを通じて変更データを受け取る同期レプリカは、単一のデータベースのスコープの範囲で動作します。
このことにより、複数のデータベースが同時に使用される環境では、ロジカルデコーディングを使った同期レプリケーションはうまく動きません。
     </para>
    </note>
   </sect2>

   <sect2 id="logicaldecoding-synchronous-caveats">
<!--
    <title>Caveats</title>
-->
    <title>警告</title>

    <para>
<!--
     In synchronous replication setup, a deadlock can happen, if the transaction
     has locked [user] catalog tables exclusively. See
     <xref linkend="logicaldecoding-capabilities"/> for information on user
     catalog tables. This is because logical decoding of transactions can lock
     catalog tables to access them. To avoid this users must refrain from taking
     an exclusive lock on [user] catalog tables. This can happen in the following
     ways:
-->
同期レプリケーション設定では、トランザクションが[user]カタログテーブルを排他的にロックした場合、デッドロックが発生する可能性があります。
ユーザカタログテーブルに関する情報については<xref linkend="logicaldecoding-capabilities"/>を参照してください。
これは、トランザクションの論理的なデコードがカタログテーブルをロックしてアクセスできるためです。
これを回避するために、ユーザは[user]カタログテーブルに対する排他ロックの取得を控える必要があります。
これは以下の方法で発生します。

     <itemizedlist>
      <listitem>
       <para>
<!--
        Issuing an explicit <command>LOCK</command> on <structname>pg_class</structname>
        in a transaction.
-->
トランザクションの<structname>pg_class</structname>に対する明示的な<command>LOCK</command>の発行。
       </para>
      </listitem>

      <listitem>
       <para>
<!--
        Perform <command>CLUSTER</command> on <structname>pg_class</structname> in
        a transaction.
-->
トランザクション内の<structname>pg_class</structname>に対して<command>CLUSTER</command>を実行。
       </para>
      </listitem>

      <listitem>
       <para>
<!--
        <command>PREPARE TRANSACTION</command> after <command>LOCK</command> command
        on <structname>pg_class</structname> and allow logical decoding of two-phase
        transactions.
-->
<structname>pg_class</structname>上の<command>LOCK</command>コマンドの後に<command>PREPARE TRANSACTION</command>を実行し、2相トランザクションのロジカルデコーディングを可能にする。
       </para>
      </listitem>

      <listitem>
       <para>
<!--
        <command>PREPARE TRANSACTION</command> after <command>CLUSTER</command>
        command on <structname>pg_trigger</structname> and allow logical decoding of
        two-phase transactions. This will lead to deadlock only when published table
        have a trigger.
-->
<structname>pg_trigger</structname>上の<command>CLUSTER</command>コマンドの後に<command>PREPARE TRANSACTION</command>を実行し、2相トランザクションのロジカルデコーディングを可能にする。
これにより、発行されたテーブルにトリガがある場合にのみデッドロックが発生します。
       </para>
      </listitem>

      <listitem>
       <para>
<!--
        Executing <command>TRUNCATE</command> on [user] catalog table in a
        transaction.
-->
トランザクションの[user]カタログテーブルに対して<command>TRUNCATE</command>を実行。
       </para>
      </listitem>
     </itemizedlist>

<!--
     Note that these commands can cause deadlocks not only for the system
     catalog tables listed above but for other catalog tables.
-->
これらのコマンドは、上記のシステムカタログテーブルだけでなく、他のカタログテーブルにもデッドロックを引き起こす可能性があることに注意してください。
    </para>
   </sect2>
  </sect1>

  <sect1 id="logicaldecoding-streaming">
<!--
   <title>Streaming of Large Transactions for Logical Decoding</title>
-->
   <title>ロジカルデコーディングための大規模トランザクションのストリーミング</title>

   <para>
<!--
    The basic output plugin callbacks (e.g., <function>begin_cb</function>,
    <function>change_cb</function>, <function>commit_cb</function> and
    <function>message_cb</function>) are only invoked when the transaction
    actually commits. The changes are still decoded from the transaction
    log, but are only passed to the output plugin at commit (and discarded
    if the transaction aborts).
-->
基本的な出力プラグインコールバック(<function>begin_cb</function>、<function>change_cb</function>、<function>commit_cb</function>、<function>message_cb</function>など)は、トランザクションが実際にコミットしたときにのみ呼び出されます。
変更はトランザクションログからデコードされますが、コミット時に出力プラグインに渡されるだけです(トランザクションがアボートした場合は破棄されます)。
   </para>

   <para>
<!--
    This means that while the decoding happens incrementally, and may spill
    to disk to keep memory usage under control, all the decoded changes have
    to be transmitted when the transaction finally commits (or more precisely,
    when the commit is decoded from the transaction log). Depending on the
    size of the transaction and network bandwidth, the transfer time may
    significantly increase the apply lag.
-->
つまり、デコードは増分的に行われ、メモリ使用量を制御するためにディスクにオーバーフローする場合がありますが、デコードされたすべての変更は、トランザクションが最終的にコミットされたとき(より正確には、コミットがトランザクションログからデコードされたとき)に送信される必要があります。
トランザクションおよびネットワーク帯域幅のサイズによっては、転送時間によって適用ラグが大幅に増加する場合があります。
   </para>

   <para>
<!--
    To reduce the apply lag caused by large transactions, an output plugin
    may provide additional callback to support incremental streaming of
    in-progress transactions. There are multiple required streaming callbacks
    (<function>stream_start_cb</function>, <function>stream_stop_cb</function>,
    <function>stream_abort_cb</function>, <function>stream_commit_cb</function>
    and <function>stream_change_cb</function>) and two optional callbacks
    (<function>stream_message_cb</function> and <function>stream_truncate_cb</function>).
    Also, if streaming of two-phase commands is to be supported, then additional
    callbacks must be provided. (See <xref linkend="logicaldecoding-two-phase-commits"/>
    for details).
-->
大規模なトランザクションによって発生する適用遅延を軽減するために、出力プラグインは、継続中のトランザクションの増分ストリーミングをサポートする追加のコールバックを提供できます。
複数の必要なストリーミングコールバック(<function>stream_start_cb</function>、<function>stream_stop_cb</function>、<function>stream_abort_cb</function>、<function>stream_commit_cb</function>および<function>stream_change_cb</function>)と2つのオプションのコールバック(<function>stream_message_cb</function>および<function>stream_truncate_cb</function>)があります。
2相コマンドのストリーミングをサポートする場合は、追加のコールバックを提供する必要があります（詳細は<xref linkend="logicaldecoding-two-phase-commits"/>を参照してください）。
   </para>

   <para>
<!--
    When streaming an in-progress transaction, the changes (and messages) are
    streamed in blocks demarcated by <function>stream_start_cb</function>
    and <function>stream_stop_cb</function> callbacks. Once all the decoded
    changes are transmitted, the transaction can be committed using the
    <function>stream_commit_cb</function> callback
    (or possibly aborted using the <function>stream_abort_cb</function> callback).
    If two-phase commits are supported, the transaction can be prepared using the
    <function>stream_prepare_cb</function> callback,
    <command>COMMIT PREPARED</command> using the
    <function>commit_prepared_cb</function> callback or aborted using the
    <function>rollback_prepared_cb</function>.
-->
継続中のトランザクションをストリーミングする場合、変更(およびメッセージ)は<function>stream_start_cb</function>および<function>stream_stop_cb</function>コールバックで区切られたブロックでストリーミングされます。
デコードされたすべての変更が送信されると、トランザクションは<function>stream_commit_cb</function>コールバックを使用してコミットできます(または<function>stream_abort_cb</function>コールバックを使用してアボートできます)。
2相コミットがサポートされている場合、トランザクションは<function>stream_prepare_cb</function>コールバックを使用して準備できます。
<command>COMMIT PREPARED</command>は<function>commit_prepared_cb</function>コールバックを使用して準備できます。
または<function>rollback_prepared_cb</function>を使用してアボートできます。
   </para>

   <para>
<!--
    One example sequence of streaming callback calls for one transaction may
    look like this:
-->
1つのトランザクションに対するストリーミングコールバック呼び出しのシーケンスの例は、次のようになります。
<programlisting>
stream_start_cb(...);   &lt;-- start of first block of changes
  stream_change_cb(...);
  stream_change_cb(...);
  stream_message_cb(...);
  stream_change_cb(...);
  ...
  stream_change_cb(...);
stream_stop_cb(...);    &lt;-- end of first block of changes

stream_start_cb(...);   &lt;-- start of second block of changes
  stream_change_cb(...);
  stream_change_cb(...);
  stream_change_cb(...);
  ...
  stream_message_cb(...);
  stream_change_cb(...);
stream_stop_cb(...);    &lt;-- end of second block of changes


[a. when using normal commit]
stream_commit_cb(...);    &lt;-- commit of the streamed transaction

[b. when using two-phase commit]
stream_prepare_cb(...);   &lt;-- prepare the streamed transaction
commit_prepared_cb(...);  &lt;-- commit of the prepared transaction
</programlisting>
   </para>

   <para>
<!--
    The actual sequence of callback calls may be more complicated, of course.
    There may be blocks for multiple streamed transactions, some of the
    transactions may get aborted, etc.
-->
もちろん、実際のコールバック呼び出しのシーケンスはもっと複雑かもしれません。
ストリーム化された複数のトランザクションにブロックがあったり、一部のトランザクションがアボートされたりするなどです。
   </para>

   <para>
<!--
    Similar to spill-to-disk behavior, streaming is triggered when the total
    amount of changes decoded from the WAL (for all in-progress transactions)
    exceeds the limit defined by <varname>logical_decoding_work_mem</varname> setting.
    At that point, the largest top-level transaction (measured by the amount of memory
    currently used for decoded changes) is selected and streamed.  However, in
    some cases we still have to spill to disk even if streaming is enabled
    because we exceed the memory threshold but still have not decoded the
    complete tuple e.g., only decoded toast table insert but not the main table
    insert.
-->
ディスクへのスピル動作と同様に、ストリーミングは、WALからデコードされた変更の合計量(すべての継続中のトランザクションについて)が<varname>logical_decoding_work_mem</varname>設定で定義された制限を超えたときにトリガされます。
その時点で、最大のトップレベルトランザクション(デコードされた変更に現在使用されているメモリ量で測定されます)が選択され、ストリーミングされます。
ただし、場合によっては、ストリーミングが有効になっていても、メモリしきい値を超えても完全なタプルがまだデコードされていない(例えば、メインテーブルの挿入ではなくトーストテーブルの挿入のみがデコードされているなど)ため、ディスクへのスピルが必要になることがあります。
   </para>

   <para>
<!--
    Even when streaming large transactions, the changes are still applied in
    commit order, preserving the same guarantees as the non-streaming mode.
-->
大規模なトランザクションをストリーミングする場合でも、変更はコミット順に適用され、非ストリーミングモードと同じ保証が維持されます。
   </para>

  </sect1>

  <sect1 id="logicaldecoding-two-phase-commits">
<!--
   <title>Two-phase Commit Support for Logical Decoding</title>
-->
   <title>ロジカルデコーディングための2相コミット</title>

   <para>
<!--
    With the basic output plugin callbacks (eg., <function>begin_cb</function>,
    <function>change_cb</function>, <function>commit_cb</function> and
    <function>message_cb</function>) two-phase commit commands like
    <command>PREPARE TRANSACTION</command>, <command>COMMIT PREPARED</command>
    and <command>ROLLBACK PREPARED</command> are not decoded. While the
    <command>PREPARE TRANSACTION</command> is ignored,
    <command>COMMIT PREPARED</command> is decoded as a <command>COMMIT</command>
    and <command>ROLLBACK PREPARED</command> is decoded as a
    <command>ROLLBACK</command>.
-->
基本的な出力プラグインコールバック(例えば、<function>begin_cb</function>、<function>change_cb</function>、<function>commit_cb</function>、<function>message_cb</function>)では、<command>PREPARE TRANSACTION</command>、<command>COMMIT PREPARED</command>、<command>ROLLBACK PREPARED</command>のような2相コミットコマンドはデコードされません。
<command>PREPARE TRANSACTION</command>は無視されますが、<command>COMMIT PREPARED</command>は<command>COMMIT</command>としてデコードされ、<command>ROLLBACK PREPARED</command>は<command>ROLLBACK</command>としてデコードされます。
   </para>

   <para>
<!--
    To support the streaming of two-phase commands, an output plugin needs to
    provide additional callbacks. There are multiple two-phase commit callbacks
    that are required, (<function>begin_prepare_cb</function>,
    <function>prepare_cb</function>, <function>commit_prepared_cb</function>,
    <function>rollback_prepared_cb</function> and
    <function>stream_prepare_cb</function>) and an optional callback
    (<function>filter_prepare_cb</function>).
-->
2相コマンドのストリーミングをサポートするために、出力プラグインは追加のコールバックを提供する必要があります。
複数の必要な2相コミットコールバック(<function>begin_prepare_cb</function>、<function>prepare_cb</function>、<function>commit_prepared_cb</function>、<function>rollback_prepared_cb</function>、<function>stream_prepare_cb</function>)とオプションのコールバック(<function>filter_prepare_cb</function>)があります。
   </para>

   <para>
<!--
    If the output plugin callbacks for decoding two-phase commit commands are
    provided, then on <command>PREPARE TRANSACTION</command>, the changes of
    that transaction are decoded, passed to the output plugin, and the
    <function>prepare_cb</function> callback is invoked. This differs from the
    basic decoding setup where changes are only passed to the output plugin
    when a transaction is committed. The start of a prepared transaction is
    indicated by the <function>begin_prepare_cb</function> callback.
-->
2相コミットコマンドをデコードするための出力プラグインコールバックが提供されている場合、<command>PREPARE TRANSACTION</command>で、そのトランザクションの変更がデコードされ、出力プラグインに渡され、<function>prepare_cb</function>コールバックが呼び出されます。
これは、トランザクションがコミットされたときにのみ変更が出力プラグインに渡される基本的なデコード設定とは異なります。
準備されたトランザクションの開始は、<function>begin_prepare_cb</function>コールバックによって示されます。
   </para>

   <para>
<!--
    When a prepared transaction is rolled back using the
    <command>ROLLBACK PREPARED</command>, then the
    <function>rollback_prepared_cb</function> callback is invoked and when the
    prepared transaction is committed using <command>COMMIT PREPARED</command>,
    then the <function>commit_prepared_cb</function> callback is invoked.
-->
準備されたトランザクションが<command>ROLLBACK PREPARED</command>を使用してロールバックされると、<function>rollback_prepared_cb</function>コールバックが呼び出されます。
準備されたトランザクションが<command>COMMIT PREPARED</command>を使用してコミットされると、<function>commit_prepared_cb</function>コールバックが呼び出されます。
   </para>

   <para>
<!--
    Optionally the output plugin can define filtering rules via
    <function>filter_prepare_cb</function> to decode only specific transaction
    in two phases.  This can be achieved by pattern matching on the
    <parameter>gid</parameter> or via lookups using the
    <parameter>xid</parameter>.
-->
オプションで、出力プラグインは<function>filter_prepare_cb</function>を使ってフィルタリング規則を定義し、特定のトランザクションのみを2つの相でデコードすることができます。
これは<parameter>gid</parameter>でパターンマッチングを行うか、<parameter>xid</parameter>を使って検索することで実現できます。
   </para>

   <para>
<!--
    The users that want to decode prepared transactions need to be careful about
    below mentioned points:
-->
準備されたトランザクションをデコードしようとするユーザは、以下の点に注意する必要があります。

    <itemizedlist>
     <listitem>
      <para>
<!--
       If the prepared transaction has locked [user] catalog tables exclusively
       then decoding prepare can block till the main transaction is committed.
-->
準備されたトランザクションが[user]カタログテーブルを排他的にロックしている場合、メイントランザクションがコミットされるまで準備のデコードをブロックできます。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       The logical replication solution that builds distributed two phase commit
       using this feature can deadlock if the prepared transaction has locked
       [user] catalog tables exclusively. To avoid this users must refrain from
       having locks on catalog tables (e.g. explicit <command>LOCK</command> command)
       in such transactions.
       See <xref linkend="logicaldecoding-synchronous-caveats"/> for the details.
-->
この機能を使用して分散2相コミットを構築するロジカルレプリケーションソリューションは、準備されたトランザクションが[user]カタログテーブルを排他的にロックした場合にデッドロックを発生する可能性があります。
これを回避するために、ユーザはこのようなトランザクションでカタログテーブルをロック(例えば明示的な<command>LOCK</command>コマンド)しないようにしなければなりません。
詳細については<xref linkend="logicaldecoding-synchronous-caveats"/>を参照してください。
      </para>
     </listitem>
    </itemizedlist>
   </para>

  </sect1>
 </chapter>
