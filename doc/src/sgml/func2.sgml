<!-- split-func2-start -->

  <sect1 id="functions-formatting">
<!--
   <title>Data Type Formatting Functions</title>
-->
   <title>データ型書式設定関数</title>

   <indexterm>
<!--
    <primary>formatting</primary>
-->
    <primary>書式設定</primary>
   </indexterm>

   <para>
<!--
    The <productname>PostgreSQL</productname> formatting functions
    provide a powerful set of tools for converting various data types
    (date/time, integer, floating point, numeric) to formatted strings
    and for converting from formatted strings to specific data types.
    <xref linkend="functions-formatting-table"> lists them.
    These functions all follow a common calling convention: the first
    argument is the value to be formatted and the second argument is a
    template that defines the output or input format.
-->
<productname>PostgreSQL</productname>の書式設定関数は多彩なデータ型（日付/時刻データ型、整数データ型、浮動小数点数データ型、数値データ型）を整形された文字列に変換したり、整形された文字列を特定のデータ型に変換する強力なツールの一式を提供しています。
<xref linkend="functions-formatting-table">にこれらを列挙しています。
これら関数は共通の呼び出し規約を踏襲しています。最初の引数は整形される値で2番目の引数は入力書式または出力書式を定義するテンプレートです。
   </para>
   <para>
<!--
    A single-argument <function>to_timestamp</function> function is also
    available;  it accepts a
    <type>double precision</type> argument and converts from Unix epoch
    (seconds since 1970-01-01 00:00:00+00) to
    <type>timestamp with time zone</type>.
    (<type>Integer</type> Unix epochs are implicitly cast to
    <type>double precision</type>.)
-->
単一引数の<function>to_timestamp</function>関数も利用可能です。
これは<type>double precision</type>型の引数を取り、Unix時刻（1970-01-01 00:00:00+00からの秒数）から<type>timestamp with time zone</type>に変換します。
（<type>Integer</type>型のUnix時刻は暗黙的に<type>double precision</type>にキャストされます。）
   </para>

    <table id="functions-formatting-table">
<!--
     <title>Formatting Functions</title>
-->
     <title>書式設定関数</title>
     <tgroup cols="4">
      <thead>
       <row>
<!--
        <entry>Function</entry>
        <entry>Return Type</entry>
        <entry>Description</entry>
        <entry>Example</entry>
-->
        <entry>関数</entry>
        <entry>戻り値</entry>
        <entry>説明</entry>
        <entry>例</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>
         <indexterm>
          <primary>to_char</primary>
         </indexterm>
         <literal><function>to_char(<type>timestamp</type>, <type>text</type>)</function></literal>
        </entry>
        <entry><type>text</type></entry>
<!--
        <entry>convert time stamp to string</entry>
-->
        <entry>タイムスタンプを文字列に変換</entry>
        <entry><literal>to_char(current_timestamp, 'HH12:MI:SS')</literal></entry>
       </row>
       <row>
        <entry><literal><function>to_char(<type>interval</type>, <type>text</type>)</function></literal></entry>
        <entry><type>text</type></entry>
<!--
        <entry>convert interval to string</entry>
-->
        <entry>時間間隔を文字列に変換</entry>
        <entry><literal>to_char(interval '15h&nbsp;2m&nbsp;12s', 'HH24:MI:SS')</literal></entry>
       </row>
       <row>
        <entry><literal><function>to_char(<type>int</type>, <type>text</type>)</function></literal></entry>
        <entry><type>text</type></entry>
<!--
        <entry>convert integer to string</entry>
-->
        <entry>整数を文字列に変換</entry>
        <entry><literal>to_char(125, '999')</literal></entry>
       </row>
       <row>
        <entry><literal><function>to_char</function>(<type>double precision</type>,
        <type>text</type>)</literal></entry>
        <entry><type>text</type></entry>
<!--
        <entry>convert real/double precision to string</entry>
-->
        <entry>実数、倍精度数を文字列に変換</entry>
        <entry><literal>to_char(125.8::real, '999D9')</literal></entry>
       </row>
       <row>
        <entry><literal><function>to_char(<type>numeric</type>, <type>text</type>)</function></literal></entry>
        <entry><type>text</type></entry>
<!--
        <entry>convert numeric to string</entry>
-->
        <entry>数値を文字列に変換</entry>
        <entry><literal>to_char(-125.8, '999D99S')</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>to_date</primary>
         </indexterm>
         <literal><function>to_date(<type>text</type>, <type>text</type>)</function></literal>
        </entry>
        <entry><type>date</type></entry>
<!--
        <entry>convert string to date</entry>
-->
        <entry>文字列を日付に変換</entry>
        <entry><literal>to_date('05&nbsp;Dec&nbsp;2000', 'DD&nbsp;Mon&nbsp;YYYY')</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>to_number</primary>
         </indexterm>
         <literal><function>to_number(<type>text</type>, <type>text</type>)</function></literal>
        </entry>
        <entry><type>numeric</type></entry>
<!--
        <entry>convert string to numeric</entry>
-->
        <entry>文字列を数値に変換</entry>
        <entry><literal>to_number('12,454.8-', '99G999D9S')</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>to_timestamp</primary>
         </indexterm>
         <literal><function>to_timestamp(<type>text</type>, <type>text</type>)</function></literal>
        </entry>
        <entry><type>timestamp with time zone</type></entry>
<!--
        <entry>convert string to time stamp</entry>
-->
        <entry>文字列をタイムスタンプに変換</entry>
        <entry><literal>to_timestamp('05&nbsp;Dec&nbsp;2000', 'DD&nbsp;Mon&nbsp;YYYY')</literal></entry>
       </row>
       <row>
        <entry><literal><function>to_timestamp(<type>double precision</type>)</function></literal></entry>
        <entry><type>timestamp with time zone</type></entry>
<!--
        <entry>convert Unix epoch to time stamp</entry>
-->
        <entry>Unix時刻をタイムスタンプに変換</entry>
        <entry><literal>to_timestamp(1284352323)</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
<!--
    In a <function>to_char</> output template string, there are certain
    patterns that are recognized and replaced with appropriately-formatted
    data based on the given value.  Any text that is not a template pattern is
    simply copied verbatim.  Similarly, in an input template string (for the
    other functions), template patterns identify the values to be supplied by
    the input data string.
-->
<function>to_char</>用の出力テンプレート文字列には、値に基づいて認識され、適切に整形されたデータで置き換えられるパターンがあります。
テンプレートパターンではない全てのテキストは単にそのままコピーされます。
同様に、（その他の関数用の）入力テンプレート文字列では、テンプレートパターンは入力されたデータ文字列で供給される値を特定します。
   </para>

  <para>
<!--
   <xref linkend="functions-formatting-datetime-table"> shows the
   template patterns available for formatting date and time values.
-->
<xref linkend="functions-formatting-datetime-table">に、日付/時刻型の値の書式に使用可能なテンプレートパターンを示します。
  </para>

    <table id="functions-formatting-datetime-table">
<!--
     <title>Template Patterns for Date/Time Formatting</title>
-->
     <title>日付/時刻型の書式テンプレートパターン</title>
     <tgroup cols="2">
      <thead>
       <row>
<!--
        <entry>Pattern</entry>
        <entry>Description</entry>
-->
        <entry>パターン</entry>
        <entry>説明</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><literal>HH</literal></entry>
<!--
        <entry>hour of day (01-12)</entry>
-->
        <entry>時（01〜12）</entry>
       </row>
       <row>
        <entry><literal>HH12</literal></entry>
<!--
        <entry>hour of day (01-12)</entry>
-->
        <entry>時（01〜12）</entry>
       </row>
       <row>
        <entry><literal>HH24</literal></entry>
<!--
        <entry>hour of day (00-23)</entry>
-->
        <entry>時（00〜23）</entry>
       </row>
       <row>
        <entry><literal>MI</literal></entry>
<!--
        <entry>minute (00-59)</entry>
-->
        <entry>分（00〜59）</entry>
       </row>
       <row>
        <entry><literal>SS</literal></entry>
<!--
        <entry>second (00-59)</entry>
-->
        <entry>秒（00〜59）</entry>
       </row>
       <row>
        <entry><literal>MS</literal></entry>
<!--
        <entry>millisecond (000-999)</entry>
-->
        <entry>ミリ秒（000〜999）</entry>
       </row>
       <row>
        <entry><literal>US</literal></entry>
<!--
        <entry>microsecond (000000-999999)</entry>
-->
        <entry>マイクロ秒（000000〜999999）</entry>
       </row>
       <row>
        <entry><literal>SSSS</literal></entry>
<!--
        <entry>seconds past midnight (0-86399)</entry>
-->
        <entry>深夜0時からの秒数（0〜86399）</entry>
       </row>
       <row>
<!--
        <entry><literal>AM</literal>, <literal>am</literal>,
        <literal>PM</literal> or <literal>pm</literal></entry>
-->
        <entry><literal>AM</literal>、<literal>am</literal>、
        <literal>PM</literal>、または<literal>pm</literal></entry>
<!--
        <entry>meridiem indicator (without periods)</entry>
-->
        <entry>午前/午後の指定（ピリオドなし）</entry>
       </row>
       <row>
<!--
        <entry><literal>A.M.</literal>, <literal>a.m.</literal>,
        <literal>P.M.</literal> or <literal>p.m.</literal></entry>
-->
        <entry><literal>A.M.</literal>、<literal>a.m.</literal>、
        <literal>P.M.</literal>、または<literal>p.m.</literal></entry>
<!--
        <entry>meridiem indicator (with periods)</entry>
-->
        <entry>午前/午後の指定（ピリオド付き）</entry>
       </row>
       <row>
        <entry><literal>Y,YYY</literal></entry>
<!--
        <entry>year (4 or more digits) with comma</entry>
-->
        <entry>コンマ付き年（4桁以上）</entry>
       </row>
       <row>
        <entry><literal>YYYY</literal></entry>
<!--
        <entry>year (4 or more digits)</entry>
-->
        <entry>年（4桁以上）</entry>
       </row>
       <row>
        <entry><literal>YYY</literal></entry>
<!--
        <entry>last 3 digits of year</entry>
-->
        <entry>年の下3桁</entry>
       </row>
       <row>
        <entry><literal>YY</literal></entry>
<!--
        <entry>last 2 digits of year</entry>
-->
        <entry>年の下2桁</entry>
       </row>
       <row>
        <entry><literal>Y</literal></entry>
<!--
        <entry>last digit of year</entry>
-->
        <entry>年の下1桁</entry>
       </row>
       <row>
        <entry><literal>IYYY</literal></entry>
<!--
        <entry>ISO 8601 week-numbering year (4 or more digits)</entry>
-->
        <entry>ISO 8601週番号年（4桁以上）</entry>
       </row>
       <row>
        <entry><literal>IYY</literal></entry>
<!--
        <entry>last 3 digits of ISO 8601 week-numbering year</entry>
-->
        <entry>ISO 8601週番号年の下3桁</entry>
       </row>
       <row>
        <entry><literal>IY</literal></entry>
<!--
        <entry>last 2 digits of ISO 8601 week-numbering year</entry>
-->
        <entry>ISO 8601週番号年の下2桁</entry>
       </row>
       <row>
        <entry><literal>I</literal></entry>
<!--
        <entry>last digit of ISO 8601 week-numbering year</entry>
-->
        <entry>ISO 8601週番号年の下1桁</entry>
       </row>
       <row>
<!--
        <entry><literal>BC</literal>, <literal>bc</literal>,
        <literal>AD</literal> or <literal>ad</literal></entry>
-->
        <entry><literal>BC</literal>、<literal>bc</literal>、
        <literal>AD</literal>、または<literal>ad</literal></entry>
<!--
        <entry>era indicator (without periods)</entry>
-->
        <entry>紀元前後の指定（ピリオドなし）</entry>
       </row>
       <row>
<!--
        <entry><literal>B.C.</literal>, <literal>b.c.</literal>,
        <literal>A.D.</literal> or <literal>a.d.</literal></entry>
-->
        <entry><literal>B.C.</literal>、<literal>b.c.</literal>、
        <literal>A.D.</literal>、または<literal>a.d.</literal></entry>
<!--
        <entry>era indicator (with periods)</entry>
-->
        <entry>紀元前後の指定（ピリオド付き）</entry>
       </row>
       <row>
        <entry><literal>MONTH</literal></entry>
<!--
        <entry>full upper case month name (blank-padded to 9 chars)</entry>
-->
        <entry>大文字での完全な月名（9文字になるように空白文字を埋める）</entry>
       </row>
       <row>
        <entry><literal>Month</literal></entry>
<!--
        <entry>full capitalized month name (blank-padded to 9 chars)</entry>
-->
        <entry>大文字で書き始める完全な月名（9文字になるように空白文字を埋める）</entry>
       </row>
       <row>
        <entry><literal>month</literal></entry>
<!--
        <entry>full lower case month name (blank-padded to 9 chars)</entry>
-->
        <entry>小文字での完全な月名（9文字になるように空白文字を埋める）</entry>
       </row>
       <row>
        <entry><literal>MON</literal></entry>
<!--
        <entry>abbreviated upper case month name (3 chars in English, localized lengths vary)</entry>
-->
        <entry>大文字での短縮形の月名（英語では3文字、現地語化された場合は可変長）</entry>
       </row>
       <row>
        <entry><literal>Mon</literal></entry>
<!--
        <entry>abbreviated capitalized month name (3 chars in English, localized lengths vary)</entry>
-->
        <entry>大文字で書き始める短縮形の月名（英語では3文字。現地語化された場合は可変長）</entry>
       </row>
       <row>
        <entry><literal>mon</literal></entry>
<!--
        <entry>abbreviated lower case month name (3 chars in English, localized lengths vary)</entry>
-->
        <entry>小文字での短縮形の月名（英語では3文字。現地語化された場合は可変長）</entry>
       </row>
       <row>
        <entry><literal>MM</literal></entry>
<!--
        <entry>month number (01-12)</entry>
-->
        <entry>月番号（01〜12）</entry>
       </row>
       <row>
        <entry><literal>DAY</literal></entry>
<!--
        <entry>full upper case day name (blank-padded to 9 chars)</entry>
-->
        <entry>大文字での完全な曜日名（9文字になるように空白文字を埋める）</entry>
       </row>
       <row>
        <entry><literal>Day</literal></entry>
<!--
        <entry>full capitalized day name (blank-padded to 9 chars)</entry>
-->
        <entry>大文字で書き始める完全な曜日名（9文字になるように空白文字を埋める）</entry>
       </row>
       <row>
        <entry><literal>day</literal></entry>
<!--
        <entry>full lower case day name (blank-padded to 9 chars)</entry>
-->
        <entry>小文字での完全な曜日名（9文字になるように空白文字を埋める）</entry>
       </row>
       <row>
        <entry><literal>DY</literal></entry>
<!--
        <entry>abbreviated upper case day name (3 chars in English, localized lengths vary)</entry>
-->
        <entry>短縮形の大文字での短縮形の曜日名（英語では3文字。現地語化された場合は可変長）</entry>
       </row>
       <row>
        <entry><literal>Dy</literal></entry>
<!--
        <entry>abbreviated capitalized day name (3 chars in English, localized lengths vary)</entry>
-->
        <entry>大文字で書き始める短縮形の曜日名（英語では3文字。現地語化された場合は可変長）</entry>
       </row>
       <row>
        <entry><literal>dy</literal></entry>
<!--
        <entry>abbreviated lower case day name (3 chars in English, localized lengths vary)</entry>
-->
        <entry>小文字での短縮形の曜日名（英語では3文字。現地語化された場合は可変長）</entry>
       </row>
       <row>
        <entry><literal>DDD</literal></entry>
<!--
        <entry>day of year (001-366)</entry>
-->
        <entry>通年の日にち番号（001〜366）</entry>
       </row>
       <row>
        <entry><literal>IDDD</literal></entry>
<!--
        <entry>day of ISO 8601 week-numbering year (001-371; day 1 of the year is Monday of the first ISO week)</entry>
-->
        <entry>ISO 8601週番号年の日にち番号（001-371：通年 第１日は最初のISO週の月曜日）</entry>
       </row>
       <row>
        <entry><literal>DD</literal></entry>
<!--
        <entry>day of month (01-31)</entry>
-->
        <entry>月内の日にち番号（01〜31）</entry>
       </row>
       <row>
        <entry><literal>D</literal></entry>
<!--
        <entry>day of the week, Sunday (<literal>1</>) to Saturday (<literal>7</>)</entry>
-->
        <entry>曜日番号、日曜日（<literal>1</>）から土曜日（<literal>7</>）まで</entry>
       </row>
       <row>
        <entry><literal>ID</literal></entry>
<!--
        <entry>ISO 8601 day of the week, Monday (<literal>1</>) to Sunday (<literal>7</>)</entry>
-->
        <entry>ISO 8601の曜日番号、月曜日（<literal>1</>）から日曜日（<literal>7</>）まで</entry>
       </row>
       <row>
        <entry><literal>W</literal></entry>
<!--
        <entry>week of month (1-5) (the first week starts on the first day of the month)</entry>
-->
        <entry>月中の週番号（1〜5）（その月の初日がある週が第1週）</entry>
       </row>
       <row>
        <entry><literal>WW</literal></entry>
<!--
        <entry>week number of year (1-53) (the first week starts on the first day of the year)</entry>
-->
        <entry>年間を通じた週番号（1〜53）（元日のある週が第1週）</entry>
       </row>
       <row>
        <entry><literal>IW</literal></entry>
<!--
        <entry>week number of ISO 8601 week-numbering year (01-53; the first Thursday of the year is in week 1)</entry>
-->
        <entry>ISO 8601週番号年の年間を通じた週番号（01 - 53：新年の最初の木曜日がある週が第1週）</entry>
       </row>
       <row>
        <entry><literal>CC</literal></entry>
<!--
        <entry>century (2 digits) (the twenty-first century starts on 2001-01-01)</entry>
-->
        <entry>世紀（2桁。21世紀は2001-01-01から開始）</entry>
       </row>
       <row>
        <entry><literal>J</literal></entry>
<!--
        <entry>Julian Day (integer days since November 24, 4714 BC at midnight UTC)</entry>
-->
        <entry>ユリウス日（UTC紀元前4714年11月24日午前零時からの整数による通算経過日）</entry>
       </row>
       <row>
        <entry><literal>Q</literal></entry>
<!--
        <entry>quarter (ignored by <function>to_date</> and <function>to_timestamp</>)</entry>
-->
        <entry>四半期（<function>to_date</>と<function>to_timestamp</>は無視します）</entry>
       </row>
       <row>
        <entry><literal>RM</literal></entry>
<!--
        <entry>month in upper case Roman numerals (I-XII; I=January)</entry>
-->
        <entry>大文字ローマ数字による月（I〜XII、Iは1月）</entry>
       </row>
       <row>
        <entry><literal>rm</literal></entry>
<!--
        <entry>month in lower case Roman numerals (i-xii; i=January)</entry>
-->
        <entry>小文字ローマ数字による月（i〜xii、iは1月）</entry>
       </row>
       <row>
        <entry><literal>TZ</literal></entry>
<!--
        <entry>upper case time-zone name</entry>
-->
        <entry>大文字による時間帯名</entry>
       </row>
       <row>
        <entry><literal>tz</literal></entry>
<!--
        <entry>lower case time-zone name</entry>
-->
        <entry>小文字による時間帯名</entry>
       </row>
       <row>
        <entry><literal>OF</literal></entry>
<!--
        <entry>time-zone offset</entry>
-->
        <entry>時間帯オフセット</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
<!--
    Modifiers can be applied to any template pattern to alter its
    behavior.  For example, <literal>FMMonth</literal>
    is the <literal>Month</literal> pattern with the
    <literal>FM</literal> modifier.
    <xref linkend="functions-formatting-datetimemod-table"> shows the
    modifier patterns for date/time formatting.
-->
どのようなテンプレートパターンに対しても、その振舞いを変更するために修飾子を適用できます。
例えば、<literal>FMMonth</literal>は<literal>FM</literal>修飾子の付いた<literal>Month</literal>パターンです。
<xref linkend="functions-formatting-datetimemod-table">に、日付/時刻書式の修飾子パターンを示します。
   </para>

    <table id="functions-formatting-datetimemod-table">
<!--
     <title>Template Pattern Modifiers for Date/Time Formatting</title>
-->
     <title>日付/時刻書式用のテンプレートパターン修飾子</title>
     <tgroup cols="3">
      <thead>
       <row>
<!--
        <entry>Modifier</entry>
        <entry>Description</entry>
        <entry>Example</entry>
-->
        <entry>修飾子</entry>
        <entry>説明</entry>
        <entry>例</entry>
       </row>
      </thead>
      <tbody>
       <row>
<!--
        <entry><literal>FM</literal> prefix</entry>
-->
        <entry><literal>FM</literal>接頭辞</entry>
<!--
        <entry>fill mode (suppress leading zeroes and padding blanks)</entry>
-->
        <entry>字詰めモード（先頭の0、およびを空白のパディングを無効）</entry>
        <entry><literal>FMMonth</literal></entry>
       </row>
       <row>
<!--
        <entry><literal>TH</literal> suffix</entry>
-->
        <entry><literal>TH</literal>接尾辞</entry>
<!--
        <entry>upper case ordinal number suffix</entry>
-->
        <entry>大文字の序数を追加</entry>
<!--
        <entry><literal>DDTH</literal>, e.g., <literal>12TH</></entry>
-->
        <entry><literal>DDTH</literal>、例えば<literal>12TH</></entry>
       </row>
       <row>
<!--
        <entry><literal>th</literal> suffix</entry>
-->
        <entry><literal>th</literal>接尾辞</entry>
<!--
        <entry>lower case ordinal number suffix</entry>
-->
        <entry>小文字の序数を追加</entry>
<!--
        <entry><literal>DDth</literal>, e.g., <literal>12th</></entry>
-->
        <entry><literal>DDth</literal>、例えば<literal>12th</></entry>
       </row>
       <row>
<!--
        <entry><literal>FX</literal> prefix</entry>
-->
        <entry><literal>FX</literal>接頭辞</entry>
<!--
        <entry>fixed format global option (see usage notes)</entry>
-->
        <entry>固定書式のグローバルオプション（使用上の注意事項を参照）</entry>
        <entry><literal>FX&nbsp;Month&nbsp;DD&nbsp;Day</literal></entry>
       </row>
       <row>
<!--
        <entry><literal>TM</literal> prefix</entry>
-->
        <entry><literal>TM</literal>接頭辞</entry>
<!--
        <entry>translation mode (print localized day and month names based on
         <xref linkend="guc-lc-time">)</entry>
-->
        <entry>翻訳モード（<xref linkend="guc-lc-time">に基づき、現地語化された曜日、月名を表示します)</entry>
        <entry><literal>TMMonth</literal></entry>
       </row>
       <row>
<!--
        <entry><literal>SP</literal> suffix</entry>
-->
        <entry><literal>SP</literal>接尾辞</entry>
<!--
        <entry>spell mode (not implemented)</entry>
-->
        <entry>スペルモード（未実装）</entry>
        <entry><literal>DDSP</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
<!--
    Usage notes for date/time formatting:
-->
日付/時刻型書式の使用上の注意事項は次のとおりです。

    <itemizedlist>
     <listitem>
      <para>
<!--
       <literal>FM</literal> suppresses leading zeroes and trailing blanks
       that would otherwise be added to make the output of a pattern be
       fixed-width.  In <productname>PostgreSQL</productname>,
       <literal>FM</literal> modifies only the next specification, while in
       Oracle <literal>FM</literal> affects all subsequent
       specifications, and repeated <literal>FM</literal> modifiers
       toggle fill mode on and off.
-->
<literal>FM</literal>は、先頭にはゼロ、末尾には空白を追加してパターンを固定長にする機能を無効にします。
<productname>PostgreSQL</productname>では、<literal>FM</literal>はその次に記述されたものだけを変更します。一方Oracleでは、<literal>FM</literal>はそれに続く全ての記述に対して影響し、<literal>FM</literal>修飾詞を繰り返すと、ゼロや空白を埋めるモードのオンとオフが切り替わります。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       <literal>TM</literal> does not include trailing blanks.
       <function>to_timestamp</> and <function>to_date</> ignore
       the <literal>TM</literal> modifier.
-->
<literal>TM</literal>には末尾の空白は含まれません。
<function>to_timestamp</>と<function>to_date</>は<literal>TM</literal>修飾詞を無視します。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       <function>to_timestamp</function> and <function>to_date</function>
       skip multiple blank spaces in the input string unless the
       <literal>FX</literal> option is used. For example,
       <literal>to_timestamp('2000&nbsp;&nbsp;&nbsp;&nbsp;JUN', 'YYYY MON')</literal> works, but
       <literal>to_timestamp('2000&nbsp;&nbsp;&nbsp;&nbsp;JUN', 'FXYYYY MON')</literal> returns an error
       because <function>to_timestamp</function> expects one space only.
       <literal>FX</literal> must be specified as the first item in
       the template.
-->
<literal>FX</literal>オプションが使用されていない場合、<function>to_timestamp</function>と<function>to_date</function>は入力文字列内の複数の空白スペースを無視します。
例えば、<literal>to_timestamp('2000&nbsp;&nbsp;&nbsp;&nbsp;JUN', 'YYYY MON')</literal>は動作しますが、<literal>to_timestamp('2000&nbsp;&nbsp;&nbsp;&nbsp;JUN','FXYYYY MON')</literal>はエラーを返します。
後者の<function>to_timestamp</function>はスペースが1つだけあることを期待するからです。
<literal>FX</literal>はテンプレートの第1項目として指定される必要があります。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       <function>to_timestamp</function> and <function>to_date</function>
       exist to handle input formats that cannot be converted by
       simple casting.  These functions interpret input liberally,
       with minimal error checking.  While they produce valid output,
       the conversion can yield unexpected results.  For example,
       input to these functions is not restricted by normal ranges,
       thus <literal>to_date('20096040','YYYYMMDD')</literal> returns
       <literal>2014-01-17</literal> rather than causing an error.
       Casting does not have this behavior.
-->
<function>to_timestamp</function>と<function>to_date</function>は単純なキャストでは変換できない入力書式を扱うために存在します。
この関数は最低限のエラー検査で入力を自由に解釈します。
有効な出力を生成しますが、変換は思わぬ結果を生じることがあります。
例えば、この関数への入力は通常の範囲で制限されてはいませんので、<literal>to_date('20096040','YYYYMMDD')</literal>はエラーを起こすのではなく、<literal>2014-01-17</literal>を返します。
キャストにはこのような動作はありません。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       Ordinary text is allowed in <function>to_char</function>
       templates and will be output literally.  You can put a substring
       in double quotes to force it to be interpreted as literal text
       even if it contains pattern key words.  For example, in
       <literal>'"Hello Year "YYYY'</literal>, the <literal>YYYY</literal>
       will be replaced by the year data, but the single <literal>Y</literal> in <literal>Year</literal>
       will not be.  In <function>to_date</>, <function>to_number</>,
       and <function>to_timestamp</>, double-quoted strings skip the number of
       input characters contained in the string, e.g. <literal>"XX"</>
       skips two input characters.
-->
<function>to_char</function>テンプレートには、通常のテキストを入れることができ、それはそのまま出力されます。
部分文字列を二重引用符で括ることで、部分文字列にパターン用のキーワードがあったとしても、強制的にリテラルテキストとして解釈させることができます。
例えば、<literal>'"Hello Year "YYYY'</literal>では<literal>YYYY</literal>は年データに置換されてしまいますが、<literal>Year</literal>内の<literal>Y</literal>は置換されません。
<function>to_date</>、<function>to_number</>、<function>to_timestamp</>では、二重引用符で括られた文字の数だけ入力された文字をスキップします。例えば<literal>"XX"</>が指定された場合は2文字がスキップされます。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       If you want to have a double quote in the output you must
       precede it with a backslash, for example <literal>'\"YYYY
       Month\"'</literal>. <!&#045;- 原文コメント "" font-lock sanity :-) &#045;->
-->
出力に二重引用符を付けたい場合、<literal>'\"YYYY Month\"'</literal>のようにその前にバックスラッシュを付けなければなりません。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       If the year format specification is less than four digits, e.g.
       <literal>YYY</>, and the supplied year is less than four digits,
       the year will be adjusted to be nearest to the year 2020, e.g.
       <literal>95</> becomes 1995.
-->
もし、<literal>YYY</>の様に4桁未満の年書式が指定され、かつ与えられる年が4桁未満だった場合、年は2020年に最も近くなるよう調整されます。例えば、<literal>95</>の場合は1995年になります。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       The <literal>YYYY</literal> conversion from string to <type>timestamp</type> or
       <type>date</type> has a restriction when processing years with more than 4 digits. You must
       use some non-digit character or template after <literal>YYYY</literal>,
       otherwise the year is always interpreted as 4 digits. For example
       (with the year 20000):
       <literal>to_date('200001131', 'YYYYMMDD')</literal> will be
       interpreted as a 4-digit year; instead use a non-digit
       separator after the year, like
       <literal>to_date('20000-1131', 'YYYY-MMDD')</literal> or
       <literal>to_date('20000Nov31', 'YYYYMonDD')</literal>.
-->
文字列を<type>timestamp</type>型もしくは<type>date</type>型にする<literal>YYYY</literal>変換は、5桁以上の年数値を処理するときに制限事項があります。
このような場合、<literal>YYYY</literal>の後に数字以外の文字またはテンプレートを使わなければなりません。 そうしないと年は常に4桁と解釈されます。
例えば（20000年として）、<literal>to_date('200001131', 'YYYYMMDD')</literal>は4桁の年と解釈されるので、代わりに<literal>to_date('20000-1131', 'YYYY-MMDD')</literal>または<literal>to_date('20000Nov31', 'YYYYMonDD')</literal>のように数字でない区切り文字を使用してください。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       In conversions from string to <type>timestamp</type> or
       <type>date</type>, the <literal>CC</literal> (century) field is ignored
       if there is a <literal>YYY</literal>, <literal>YYYY</literal> or
       <literal>Y,YYY</literal> field. If <literal>CC</literal> is used with
       <literal>YY</literal> or <literal>Y</literal> then the year is computed
       as the year in the specified century.  If the century is
       specified but the year is not, the first year of the century
       is assumed.
-->
文字列から<type>timestamp</type>もしくは<type>date</type>への変換において、<literal>YYY</literal>、<literal>YYYY</literal>、もしくは<literal>Y,YYY</literal>フィールドが存在すると<literal>CC</literal>（世紀）フィールドは無視されます。
<literal>CC</literal>が<literal>YY</literal>もしくは<literal>Y</literal>と共に使用されると、指定された世紀の年と計算されます。
世紀が指定され、年が指定されないときは、その世紀の最初の年と想定されます。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       An ISO 8601 week-numbering date (as distinct from a Gregorian date)
       can be specified to <function>to_timestamp</function> and
       <function>to_date</function> in one of two ways:
-->
ISO 8601週番号日は（グレゴリオ暦の日付とは異なって）<function>to_timestamp</function>と<function>to_date</function>で２つの方法のうちのひとつで指定できます。
       <itemizedlist>
        <listitem>
         <para>
<!--
          Year, week number, and weekday:  for
          example <literal>to_date('2006-42-4', 'IYYY-IW-ID')</literal>
          returns the date <literal>2006-10-19</literal>.
          If you omit the weekday it is assumed to be 1 (Monday).
-->
年、通年の週番号、曜日番号。
例えば、<literal>to_date('2006-42-4', 'IYYY-IW-ID')</literal>は、日付<literal>2006-10-19</literal>を返します。
曜日番号を省略した場合、1（月曜日）と想定されます。
         </para>
        </listitem>
        <listitem>
         <para>
<!--
          Year and day of year:  for example <literal>to_date('2006-291',
          'IYYY-IDDD')</literal> also returns <literal>2006-10-19</literal>.
-->
年と通年の日付番号。例えば、<literal>to_date('2006-291', 'IYYY-IDDD')</literal>も<literal>2006-10-19</literal>を返します。
         </para>
        </listitem>
       </itemizedlist>
      </para>
      <para>
<!--
       Attempting to enter a date using a mixture of ISO 8601 week-numbering
       fields and Gregorian date fields is nonsensical, and will cause an
       error.  In the context of an ISO 8601 week-numbering year, the
       concept of a <quote>month</> or <quote>day of month</> has no
       meaning.  In the context of a Gregorian year, the ISO week has no
       meaning.
-->
ISO 8601週番号とグレゴリオ暦日のフィールドを混在して使用して日付を構築する試みは無意味なことで、エラーの原因になります。
ISO 8601週番号年の文脈では、<quote>月</>、あるいは<quote>月内の日付番号</>は意味を持ちません。
グレゴリオ暦の年の文脈では、ISO週番号は意味を持ちません。
      </para>
      <caution>
       <para>
<!--
        While <function>to_date</function> will reject a mixture of
        Gregorian and ISO week-numbering date
        fields, <function>to_char</function> will not, since output format
        specifications like <literal>YYYY-MM-DD (IYYY-IDDD)</> can be
        useful.  But avoid writing something like <literal>IYYY-MM-DD</>;
        that would yield surprising results near the start of the year.
        (See <xref linkend="functions-datetime-extract"> for more
        information.)
-->
<function>to_date</function>はグレゴリオとISO週番号日のフィールドの混在を拒否しますが、<function>to_char</function>はそうではありません。<literal>YYYY-MM-DD (IYYY-IDDD)</>のような出力書式指定が有用な場合があるからです。
しかし、<literal>IYYY-MM-DD</>のような書き方は避けてください。年の初めの近くで驚くべき結果になるでしょう。
(より詳細な情報は<xref linkend="functions-datetime-extract">を参照してください。)
       </para>
      </caution>
     </listitem>

     <listitem>
      <para>
<!--
       In a conversion from string to <type>timestamp</type>, millisecond
       (<literal>MS</literal>) or microsecond (<literal>US</literal>)
       values are used as the
       seconds digits after the decimal point. For example
       <literal>to_timestamp('12:3', 'SS:MS')</literal> is not 3 milliseconds,
       but 300, because the conversion counts it as 12 + 0.3 seconds.
       This means for the format <literal>SS:MS</literal>, the input values
       <literal>12:3</literal>, <literal>12:30</literal>, and <literal>12:300</literal> specify the
       same number of milliseconds. To get three milliseconds, one must use
       <literal>12:003</literal>, which the conversion counts as
       12 + 0.003 = 12.003 seconds.
-->
文字列型から<type>timestamp</type>型への変換に際し、ミリ秒(<literal>MS</literal>)またはマイクロ秒(<literal>US</literal>)の値は小数点の位置の後の秒の桁として使用されます。
例えば、<literal>to_timestamp('12:3', 'SS:MS')</literal>は3ミリ秒ではなく300ミリ秒です。なぜなら変換においてこれは12 + 0.3と計算されるからです。
ということは、<literal>SS:MS</literal>書式に対して入力値である<literal>12:3</literal>、<literal>12:30</literal>、および<literal>12:300</literal>は同じミリ秒数を指定します。
3ミリ秒数が必要な場合には<literal>12:003</literal>のようにしなければなりません。この時、変換において12 + 0.003 = 12.003秒と計算します。
      </para>

      <para>
<!--
       Here is a more
       complex example:
       <literal>to_timestamp('15:12:02.020.001230', 'HH:MI:SS.MS.US')</literal>
       is 15 hours, 12 minutes, and 2 seconds + 20 milliseconds +
       1230 microseconds = 2.021230 seconds.
-->
もう少し複雑な例を挙げます。
<literal>to_timestamp('15:12:02.020.001230','HH:MI:SS.MS.US')</literal>は15時間12分と2秒+20ミリ秒+1230マイクロ秒 = 2.021230秒です。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
        <function>to_char(..., 'ID')</function>'s day of the week numbering
        matches the <function>extract(isodow from ...)</function> function, but
        <function>to_char(..., 'D')</function>'s does not match
        <function>extract(dow from ...)</function>'s day numbering.
-->
<function>to_char(..., 'ID')</function>の曜日番号付けは<function>extract(isodow from ...)</function>関数に一致しますが、<function>to_char(..., 'D')</function>の曜日番号付けは<function>extract(dow from ...)</function>の曜日番号付けに一致しません。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
        <function>to_char(interval)</function> formats <literal>HH</> and
        <literal>HH12</> as shown on a 12-hour clock, i.e. zero hours
        and 36 hours output as <literal>12</>, while <literal>HH24</>
        outputs the full hour value, which can exceed 23 for intervals.
-->
<function>to_char(interval)</function>関数は、<literal>HH</>と<literal>HH12</>を12時間の時計に表示されるように整形します。
すなわち0時間と36時間を<literal>12</>として出力します。
一方<literal>HH24</>は時間の値をそのまま出力し、時間間隔は23を超えることが可能です。
      </para>
     </listitem>

    </itemizedlist>
   </para>

  <para>
<!--
   <xref linkend="functions-formatting-numeric-table"> shows the
   template patterns available for formatting numeric values.
-->
<xref linkend="functions-formatting-numeric-table">に、数値の書式設定に使用可能なテンプレートパターンを示します。
  </para>

    <table id="functions-formatting-numeric-table">
<!--
     <title>Template Patterns for Numeric Formatting</title>
-->
     <title>数値書式用のテンプレートパターン</title>
     <tgroup cols="2">
      <thead>
       <row>
<!--
        <entry>Pattern</entry>
        <entry>Description</entry>
-->
        <entry>パターン</entry>
        <entry>説明</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><literal>9</literal></entry>
<!--
        <entry>value with the specified number of digits</entry>
-->
        <entry>指定された桁数での値</entry>
       </row>
       <row>
        <entry><literal>0</literal></entry>
<!--
        <entry>value with leading zeros</entry>
-->
        <entry>前にゼロが付いた値</entry>
       </row>
       <row>
<!--
        <entry><literal>.</literal> (period)</entry>
        <entry>decimal point</entry>
-->
        <entry><literal>.</literal>（ピリオド）</entry>
        <entry>小数点</entry>
       </row>
       <row>
<!--
        <entry><literal>,</literal> (comma)</entry>
        <entry>group (thousand) separator</entry>
-->
        <entry><literal>,</literal> (コンマ)</entry>
        <entry>千単位で区切る符号</entry>
       </row>
       <row>
        <entry><literal>PR</literal></entry>
<!--
        <entry>negative value in angle brackets</entry>
-->
        <entry>負の値の角括弧表示</entry>
       </row>
       <row>
        <entry><literal>S</literal></entry>
<!--
        <entry>sign anchored to number (uses locale)</entry>
-->
        <entry>符号付き値（ロケールを使用）</entry>
       </row>
       <row>
        <entry><literal>L</literal></entry>
<!--
        <entry>currency symbol (uses locale)</entry>
-->
        <entry>通貨記号（ロケールを使用）</entry>
       </row>
       <row>
        <entry><literal>D</literal></entry>
<!--
        <entry>decimal point (uses locale)</entry>
-->
        <entry>小数点（ロケールを使用）</entry>
       </row>
       <row>
        <entry><literal>G</literal></entry>
<!--
        <entry>group separator (uses locale)</entry>
-->
        <entry>グループ区切り文字（ロケールを使用）</entry>
       </row>
       <row>
        <entry><literal>MI</literal></entry>
<!--
        <entry>minus sign in specified position (if number &lt; 0)</entry>
-->
        <entry>（数値 &lt; 0であれば）指定位置にマイナス記号</entry>
       </row>
       <row>
        <entry><literal>PL</literal></entry>
<!--
        <entry>plus sign in specified position (if number &gt; 0)</entry>
-->
        <entry>（数値 &gt; 0であれば）指定位置にプラス記号</entry>
       </row>
       <row>
        <entry><literal>SG</literal></entry>
<!--
        <entry>plus/minus sign in specified position</entry>
-->
        <entry>指定された位置にプラス/マイナス記号</entry>
       </row>
       <row>
        <entry><literal>RN</literal></entry>
<!--
        <entry>Roman numeral (input between 1 and 3999)</entry>
-->
        <entry>ローマ数字（入力は1～3999）</entry>
       </row>
       <row>
<!--
        <entry><literal>TH</literal> or <literal>th</literal></entry>
        <entry>ordinal number suffix</entry>
-->
        <entry><literal>TH</literal>または<literal>th</literal></entry>
        <entry>序数接尾辞</entry>
       </row>
       <row>
        <entry><literal>V</literal></entry>
<!--
        <entry>shift specified number of digits (see notes)</entry>
-->
        <entry><replaceable>n</replaceable> 桁シフト（注意事項を参照）</entry>
       </row>
       <row>
        <entry><literal>EEEE</literal></entry>
<!--
        <entry>exponent for scientific notation</entry>
-->
        <entry>科学技術表記法用の指数</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
<!--
    Usage notes for numeric formatting:
-->
数値型書式の使用上の注意事項は次のとおりです。

    <itemizedlist>
     <listitem>
      <para>
<!--
       A sign formatted using <literal>SG</literal>, <literal>PL</literal>, or
       <literal>MI</literal> is not anchored to
       the number; for example,
       <literal>to_char(-12, 'MI9999')</literal> produces <literal>'-&nbsp;&nbsp;12'</literal>
       but <literal>to_char(-12, 'S9999')</literal> produces <literal>'&nbsp;&nbsp;-12'</literal>.
       The Oracle implementation does not allow the use of
       <literal>MI</literal> before <literal>9</literal>, but rather
       requires that <literal>9</literal> precede
       <literal>MI</literal>.
-->
<literal>SG</literal>、<literal>PL</literal>、または<literal>MI</literal>で整形された符号は、数値と関連付けられません。
例えば、<literal>to_char(-12, 'MI9999')</literal>は<literal>'-&nbsp;&nbsp;12'</literal>となる一方、<literal>to_char(-12, 'S9999')</literal>は<literal>'&nbsp;&nbsp;-12'</literal>となります。
Oracleの実装では<literal>9</literal>の前に<literal>MI</literal>が置かれてはならず、<literal>9</literal>の後に<literal>MI</literal>が置かれることを要求しています。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       <literal>9</literal> results in a value with the same number of
       digits as there are <literal>9</literal>s. If a digit is
       not available it outputs a space.
-->
<literal>9</literal>は<literal>9</literal>が並んでいる数と同じ桁数の値を出力します。
桁が使用可能でない場合、スペースを出力します。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       <literal>TH</literal> does not convert values less than zero
       and does not convert fractional numbers.
-->
<literal>TH</literal>はゼロ未満の値と小数は変換しません
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       <literal>PL</literal>, <literal>SG</literal>, and
       <literal>TH</literal> are <productname>PostgreSQL</productname>
       extensions.
-->
<literal>PL</literal>、<literal>SG</literal>、および<literal>TH</literal>は<productname>PostgreSQL</productname>の拡張です。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       <literal>V</literal> effectively
       multiplies the input values by
       <literal>10^<replaceable>n</replaceable></literal>, where
       <replaceable>n</replaceable> is the number of digits following
       <literal>V</literal>.
       <function>to_char</function> does not support the use of
       <literal>V</literal> combined with a decimal point
       (e.g., <literal>99.9V99</literal> is not allowed).
-->
<literal>V</literal>は入力値を実質的に<literal>10^<replaceable>n</replaceable></literal>乗します。
ここで<replaceable>n</replaceable>は<literal>V</literal>に続く桁数です。
<function>to_char</function>関数は小数点と<literal>V</literal>との混在をサポートしません（例えば、<literal>99.9V99</literal> とはできません）。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       <literal>EEEE</literal> (scientific notation) cannot be used in
       combination with any of the other formatting patterns or
       modifiers other than digit and decimal point patterns, and must be at the end of the format string
       (e.g., <literal>9.99EEEE</literal> is a valid pattern).
-->
<literal>EEEE</literal>(科学技術表記)は、桁と小数点のパターンを除き、他の書式パターンや修飾子と組み合わせて使うことはできず、また必ず書式文字列の最後に位置しなければなりません(例えば、<literal>9.99EEEE</literal>は正しい表記となります)。
      </para>
     </listitem>
    </itemizedlist>
   </para>

   <para>
<!--
    Certain modifiers can be applied to any template pattern to alter its
    behavior.  For example, <literal>FM9999</literal>
    is the <literal>9999</literal> pattern with the
    <literal>FM</literal> modifier.
    <xref linkend="functions-formatting-numericmod-table"> shows the
    modifier patterns for numeric formatting.
-->
すべてのテンプレートについて、その動作を変えるために、いくつかの修飾子を適用できます。
例えば、<literal>FM9999</literal>は<literal>FM</literal>修飾子が付いた<literal>9999</literal>パターンです。
<xref linkend="functions-formatting-numericmod-table">に、数値の書式用の修飾子パターンを示します。
   </para>

    <table id="functions-formatting-numericmod-table">
<!--
     <title>Template Pattern Modifiers for Numeric Formatting</title>
-->
     <title>数値の書式用テンプレートパターン修飾子</title>
     <tgroup cols="3">
      <thead>
       <row>
<!--
        <entry>Modifier</entry>
        <entry>Description</entry>
        <entry>Example</entry>
-->
        <entry>修飾子</entry>
        <entry>説明</entry>
        <entry>例</entry>
       </row>
      </thead>
      <tbody>
       <row>
<!--
        <entry><literal>FM</literal> prefix</entry>
-->
        <entry><literal>FM</literal>添え字</entry>
<!--
        <entry>fill mode (suppress leading zeroes and padding blanks)</entry>
-->
        <entry>字詰めモード（先頭の0、および空白の埋め字を無効）</entry>
        <entry><literal>FM9999</literal></entry>
       </row>
       <row>
<!--
        <entry><literal>TH</literal> suffix</entry>
-->
        <entry><literal>TH</literal>添え字</entry>
<!--
        <entry>upper case ordinal number suffix</entry>
-->
        <entry>大文字による序数添え字</entry>
        <entry><literal>999TH</literal></entry>
       </row>
       <row>
<!--
        <entry><literal>th</literal> suffix</entry>
-->
        <entry><literal>th</literal>添え字</entry>
<!--
        <entry>lower case ordinal number suffix</entry>
-->
        <entry>子文字による序数添え字</entry>
        <entry><literal>999th</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

  <para>
<!--
   <xref linkend="functions-formatting-examples-table"> shows some
   examples of the use of the <function>to_char</function> function.
-->
<xref linkend="functions-formatting-examples-table">に、<function>to_char</function>関数を使用した例をいくつか示します。
  </para>

    <table id="functions-formatting-examples-table">
<!--
     <title><function>to_char</function> Examples</title>
-->
     <title><function>to_char</function>の例</title>
     <tgroup cols="2">
      <thead>
       <row>
<!--
        <entry>Expression</entry>
        <entry>Result</entry>
-->
        <entry>式</entry>
        <entry>結果</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><literal>to_char(current_timestamp, 'Day,&nbsp;DD&nbsp;&nbsp;HH12:MI:SS')</literal></entry>
        <entry><literal>'Tuesday&nbsp;&nbsp;,&nbsp;06&nbsp;&nbsp;05:39:18'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(current_timestamp, 'FMDay,&nbsp;FMDD&nbsp;&nbsp;HH12:MI:SS')</literal></entry>
        <entry><literal>'Tuesday,&nbsp;6&nbsp;&nbsp;05:39:18'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(-0.1, '99.99')</literal></entry>
        <entry><literal>'&nbsp;&nbsp;-.10'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(-0.1, 'FM9.99')</literal></entry>
        <entry><literal>'-.1'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(0.1, '0.9')</literal></entry>
        <entry><literal>'&nbsp;0.1'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(12, '9990999.9')</literal></entry>
        <entry><literal>'&nbsp;&nbsp;&nbsp;&nbsp;0012.0'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(12, 'FM9990999.9')</literal></entry>
        <entry><literal>'0012.'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485, '999')</literal></entry>
        <entry><literal>'&nbsp;485'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(-485, '999')</literal></entry>
        <entry><literal>'-485'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485, '9&nbsp;9&nbsp;9')</literal></entry>
        <entry><literal>'&nbsp;4&nbsp;8&nbsp;5'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(1485, '9,999')</literal></entry>
        <entry><literal>'&nbsp;1,485'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(1485, '9G999')</literal></entry>
        <entry><literal>'&nbsp;1&nbsp;485'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(148.5, '999.999')</literal></entry>
        <entry><literal>'&nbsp;148.500'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(148.5, 'FM999.999')</literal></entry>
        <entry><literal>'148.5'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(148.5, 'FM999.990')</literal></entry>
        <entry><literal>'148.500'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(148.5, '999D999')</literal></entry>
        <entry><literal>'&nbsp;148,500'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(3148.5, '9G999D999')</literal></entry>
        <entry><literal>'&nbsp;3&nbsp;148,500'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(-485, '999S')</literal></entry>
        <entry><literal>'485-'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(-485, '999MI')</literal></entry>
        <entry><literal>'485-'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485, '999MI')</literal></entry>
        <entry><literal>'485&nbsp;'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485, 'FM999MI')</literal></entry>
        <entry><literal>'485'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485, 'PL999')</literal></entry>
        <entry><literal>'+485'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485, 'SG999')</literal></entry>
        <entry><literal>'+485'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(-485, 'SG999')</literal></entry>
        <entry><literal>'-485'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(-485, '9SG99')</literal></entry>
        <entry><literal>'4-85'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(-485, '999PR')</literal></entry>
        <entry><literal>'&lt;485&gt;'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485, 'L999')</literal></entry>
        <entry><literal>'DM&nbsp;485'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485, 'RN')</literal></entry>
        <entry><literal>'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CDLXXXV'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485, 'FMRN')</literal></entry>
        <entry><literal>'CDLXXXV'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(5.2, 'FMRN')</literal></entry>
        <entry><literal>'V'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(482, '999th')</literal></entry>
        <entry><literal>'&nbsp;482nd'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485, '"Good&nbsp;number:"999')</literal></entry>
        <entry><literal>'Good&nbsp;number:&nbsp;485'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485.8, '"Pre:"999"&nbsp;Post:"&nbsp;.999')</literal></entry>
        <entry><literal>'Pre:&nbsp;485&nbsp;Post:&nbsp;.800'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(12, '99V999')</literal></entry>
        <entry><literal>'&nbsp;12000'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(12.4, '99V999')</literal></entry>
        <entry><literal>'&nbsp;12400'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(12.45, '99V9')</literal></entry>
        <entry><literal>'&nbsp;125'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(0.0004859, '9.99EEEE')</literal></entry>
        <entry><literal>' 4.86e-04'</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

  </sect1>


  <sect1 id="functions-datetime">
<!--
   <title>Date/Time Functions and Operators</title>
-->
   <title>日付/時刻関数と演算子</title>

  <para>
<!--
   <xref linkend="functions-datetime-table"> shows the available
   functions for date/time value processing, with details appearing in
   the following subsections.  <xref
   linkend="operators-datetime-table"> illustrates the behaviors of
   the basic arithmetic operators (<literal>+</literal>,
   <literal>*</literal>, etc.).  For formatting functions, refer to
   <xref linkend="functions-formatting">.  You should be familiar with
   the background information on date/time data types from <xref
   linkend="datatype-datetime">.
-->
<xref linkend="functions-datetime-table">は、日付/時刻型の値の処理で使用可能な関数を示しています。詳細は、以下の副節で説明します。
<xref linkend="operators-datetime-table">は、（<literal>+</literal>、<literal>*</literal>等の）基本的な算術演算子の振舞いを説明しています。
書式設定関数については<xref linkend="functions-formatting">を参照してください。
<xref linkend="datatype-datetime">を参照して、日付/時刻データ型についての背景となっている情報に精通していなければなりません。
  </para>

  <para>
<!--
   All the functions and operators described below that take <type>time</type> or <type>timestamp</type>
   inputs actually come in two variants: one that takes <type>time with time zone</type> or <type>timestamp
   with time zone</type>, and one that takes <type>time without time zone</type> or <type>timestamp without time zone</type>.
   For brevity, these variants are not shown separately.  Also, the
   <literal>+</> and <literal>*</> operators come in commutative pairs (for
   example both date + integer and integer + date); we show only one of each
   such pair.
-->
以下の<type>time</type>もしくは<type>timestamp</type>型の入力を受け取る関数および演算子は全て、実際には2つの種類があります。1つは<type>time with time zone</type>型または<type>timestamp with time zone</type>型を取るもので、もう1つは<type>time without time zone</type>型もしくは<type>timestamp without time zone</type>型を取るものです。
簡略化のため、これらの種類の違いは個別に示していません。
また、<literal>+</>と<literal>*</>演算子は可換な2項をとります（例えばdate + integerとinteger + date）。こうした組み合わせは片方のみ示します。
  </para>

    <table id="operators-datetime-table">
<!--
     <title>Date/Time Operators</title>
-->
     <title>日付/時刻演算子</title>

     <tgroup cols="3">
      <thead>
       <row>
<!--
        <entry>Operator</entry>
        <entry>Example</entry>
        <entry>Result</entry>
-->
        <entry>演算子名</entry>
        <entry>例</entry>
        <entry>結果</entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry> <literal>+</literal> </entry>
        <entry><literal>date '2001-09-28' + integer '7'</literal></entry>
        <entry><literal>date '2001-10-05'</literal></entry>
       </row>

       <row>
        <entry> <literal>+</literal> </entry>
        <entry><literal>date '2001-09-28' + interval '1 hour'</literal></entry>
        <entry><literal>timestamp '2001-09-28 01:00:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>+</literal> </entry>
        <entry><literal>date '2001-09-28' + time '03:00'</literal></entry>
        <entry><literal>timestamp '2001-09-28 03:00:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>+</literal> </entry>
        <entry><literal>interval '1 day' + interval '1 hour'</literal></entry>
        <entry><literal>interval '1 day 01:00:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>+</literal> </entry>
        <entry><literal>timestamp '2001-09-28 01:00' + interval '23 hours'</literal></entry>
        <entry><literal>timestamp '2001-09-29 00:00:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>+</literal> </entry>
        <entry><literal>time '01:00' + interval '3 hours'</literal></entry>
        <entry><literal>time '04:00:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>-</literal> </entry>
        <entry><literal>- interval '23 hours'</literal></entry>
        <entry><literal>interval '-23:00:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>-</literal> </entry>
        <entry><literal>date '2001-10-01' - date '2001-09-28'</literal></entry>
<!--
        <entry><literal>integer '3'</literal> (days)</entry>
-->
        <entry><literal>integer '3'</literal>（日付）</entry>
       </row>

       <row>
        <entry> <literal>-</literal> </entry>
        <entry><literal>date '2001-10-01' - integer '7'</literal></entry>
        <entry><literal>date '2001-09-24'</literal></entry>
       </row>

       <row>
        <entry> <literal>-</literal> </entry>
        <entry><literal>date '2001-09-28' - interval '1 hour'</literal></entry>
        <entry><literal>timestamp '2001-09-27 23:00:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>-</literal> </entry>
        <entry><literal>time '05:00' - time '03:00'</literal></entry>
        <entry><literal>interval '02:00:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>-</literal> </entry>
        <entry><literal>time '05:00' - interval '2 hours'</literal></entry>
        <entry><literal>time '03:00:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>-</literal> </entry>
        <entry><literal>timestamp '2001-09-28 23:00' - interval '23 hours'</literal></entry>
        <entry><literal>timestamp '2001-09-28 00:00:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>-</literal> </entry>
        <entry><literal>interval '1 day' - interval '1 hour'</literal></entry>
        <entry><literal>interval '1 day -01:00:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>-</literal> </entry>
        <entry><literal>timestamp '2001-09-29 03:00' - timestamp '2001-09-27 12:00'</literal></entry>
        <entry><literal>interval '1 day 15:00:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>*</literal> </entry>
        <entry><literal>900 * interval '1 second'</literal></entry>
        <entry><literal>interval '00:15:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>*</literal> </entry>
        <entry><literal>21 * interval '1 day'</literal></entry>
        <entry><literal>interval '21 days'</literal></entry>
       </row>

       <row>
        <entry> <literal>*</literal> </entry>
        <entry><literal>double precision '3.5' * interval '1 hour'</literal></entry>
        <entry><literal>interval '03:30:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>/</literal> </entry>
        <entry><literal>interval '1 hour' / double precision '1.5'</literal></entry>
        <entry><literal>interval '00:40:00'</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

    <table id="functions-datetime-table">
<!--
     <title>Date/Time Functions</title>
-->
     <title>日付/時刻関数</title>
     <tgroup cols="5">
      <thead>
       <row>
<!--
        <entry>Function</entry>
        <entry>Return Type</entry>
        <entry>Description</entry>
        <entry>Example</entry>
        <entry>Result</entry>
-->
        <entry>関数名</entry>
        <entry>戻り値型</entry>
        <entry>説明</entry>
        <entry>例</entry>
        <entry>結果</entry>
    
       </row>
      </thead>

      <tbody>
       <row>
        <entry>
         <indexterm>
          <primary>age</primary>
         </indexterm>
         <literal><function>age(<type>timestamp</type>, <type>timestamp</type>)</function></literal>
        </entry>
        <entry><type>interval</type></entry>
<!--
        <entry>Subtract arguments, producing a <quote>symbolic</> result that
        uses years and months, rather than just days</entry>
-->
        <entry>引数間の減算。日数だけでなく年と月を使用した<quote>言葉による</>結果を生成</entry>
        <entry><literal>age(timestamp '2001-04-10', timestamp '1957-06-13')</literal></entry>
        <entry><literal>43 years 9 mons 27 days</literal></entry>
       </row>

       <row>
        <entry><literal><function>age(<type>timestamp</type>)</function></literal></entry>
        <entry><type>interval</type></entry>
<!--
        <entry>Subtract from <function>current_date</function> (at midnight)</entry>
-->
        <entry><function>current_date</function>（午前零時）から減算</entry>
        <entry><literal>age(timestamp '1957-06-13')</literal></entry>
        <entry><literal>43 years 8 mons 3 days</literal></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>clock_timestamp</primary>
         </indexterm>
         <literal><function>clock_timestamp()</function></literal>
        </entry>
        <entry><type>timestamp with time zone</type></entry>
<!--
        <entry>Current date and time (changes during statement execution);
         see <xref linkend="functions-datetime-current">
-->
        <entry>現在の日付と時刻（文実行中に変化する）。<xref linkend="functions-datetime-current">を参照。
        </entry>
        <entry></entry>
        <entry></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>current_date</primary>
         </indexterm>
         <literal><function>current_date</function></literal>
        </entry>
        <entry><type>date</type></entry>
<!--
        <entry>Current date;
         see <xref linkend="functions-datetime-current">
-->
        <entry>現在の日付。<xref linkend="functions-datetime-current">を参照
        </entry>
        <entry></entry>
        <entry></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>current_time</primary>
         </indexterm>
         <literal><function>current_time</function></literal>
        </entry>
        <entry><type>time with time zone</type></entry>
<!--
        <entry>Current time of day;
         see <xref linkend="functions-datetime-current">
-->
        <entry>現在の時刻。<xref linkend="functions-datetime-current">を参照。
        </entry>
        <entry></entry>
        <entry></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>current_timestamp</primary>
         </indexterm>
         <literal><function>current_timestamp</function></literal>
        </entry>
        <entry><type>timestamp with time zone</type></entry>
<!--
        <entry>Current date and time (start of current transaction);
         see <xref linkend="functions-datetime-current">
-->
        <entry>現在の日付と時刻（現在のトランザクションの開始時）。<xref linkend="functions-datetime-current">を参照。
        </entry>
        <entry></entry>
        <entry></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>date_part</primary>
         </indexterm>
         <literal><function>date_part(<type>text</type>, <type>timestamp</type>)</function></literal>
        </entry>
        <entry><type>double precision</type></entry>
<!--
        <entry>Get subfield (equivalent to <function>extract</function>);
         see <xref linkend="functions-datetime-extract">
-->
        <entry>部分フィールドの取得（<function>extract</function>と同じ）。<xref linkend="functions-datetime-extract">を参照。
        </entry>
        <entry><literal>date_part('hour', timestamp '2001-02-16 20:38:40')</literal></entry>
        <entry><literal>20</literal></entry>
       </row>

       <row>
        <entry><literal><function>date_part(<type>text</type>, <type>interval</type>)</function></literal></entry>
        <entry><type>double precision</type></entry>
<!--
        <entry>Get subfield (equivalent to
         <function>extract</function>); see <xref linkend="functions-datetime-extract">
-->
        <entry>部分フィールドの取得（<function>extract</function>と同じ）。<xref linkend="functions-datetime-extract">を参照。
        </entry>
        <entry><literal>date_part('month', interval '2 years 3 months')</literal></entry>
        <entry><literal>3</literal></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>date_trunc</primary>
         </indexterm>
         <literal><function>date_trunc(<type>text</type>, <type>timestamp</type>)</function></literal>
        </entry>
        <entry><type>timestamp</type></entry>
<!--
        <entry>Truncate to specified precision; see also <xref linkend="functions-datetime-trunc">
-->
        <entry>指定された精度で切り捨て。<xref linkend="functions-datetime-trunc">も参照。
        </entry>
        <entry><literal>date_trunc('hour', timestamp '2001-02-16 20:38:40')</literal></entry>
        <entry><literal>2001-02-16 20:00:00</literal></entry>
       </row>

       <row>
        <entry><literal><function>date_trunc(<type>text</type>, <type>interval</type>)</function></literal></entry>
        <entry><type>interval</type></entry>
<!--
        <entry>Truncate to specified precision; see also <xref linkend="functions-datetime-trunc">
-->
        <entry>指定された精度で切り捨て。<xref linkend="functions-datetime-trunc">も参照。
        </entry>
        <entry><literal>date_trunc('hour', interval '2 days 3 hours 40 minutes')</literal></entry>
        <entry><literal>2 days 03:00:00</literal></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>extract</primary>
         </indexterm>
         <literal><function>extract</function>(<parameter>field</parameter> from
         <type>timestamp</type>)</literal>
        </entry>
        <entry><type>double precision</type></entry>
<!--
        <entry>Get subfield; see <xref linkend="functions-datetime-extract">
-->
        <entry>部分フィールドの取得。<xref linkend="functions-datetime-extract">を参照。
        </entry>
        <entry><literal>extract(hour from timestamp '2001-02-16 20:38:40')</literal></entry>
        <entry><literal>20</literal></entry>
       </row>

       <row>
        <entry><literal><function>extract</function>(<parameter>field</parameter> from
         <type>interval</type>)</literal></entry>
        <entry><type>double precision</type></entry>
<!--
        <entry>Get subfield; see <xref linkend="functions-datetime-extract">
-->
        <entry>部分フィールドの取得。<xref linkend="functions-datetime-extract">を参照。
        </entry>
        <entry><literal>extract(month from interval '2 years 3 months')</literal></entry>
        <entry><literal>3</literal></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>isfinite</primary>
         </indexterm>
         <literal><function>isfinite(<type>date</type>)</function></literal>
        </entry>
        <entry><type>boolean</type></entry>
<!--
        <entry>Test for finite date (not +/-infinity)</entry>
-->
        <entry>日付が有限（+/-無限でない）かどうかの検査</entry>
        <entry><literal>isfinite(date '2001-02-16')</literal></entry>
        <entry><literal>true</literal></entry>
       </row>

       <row>
        <entry><literal><function>isfinite(<type>timestamp</type>)</function></literal></entry>
        <entry><type>boolean</type></entry>
<!--
        <entry>Test for finite time stamp (not +/-infinity)</entry>
-->
        <entry>タイムスタンプが有限（+/-無限でない）かどうかの検査</entry>
        <entry><literal>isfinite(timestamp '2001-02-16 21:28:30')</literal></entry>
        <entry><literal>true</literal></entry>
       </row>

       <row>
        <entry><literal><function>isfinite(<type>interval</type>)</function></literal></entry>
        <entry><type>boolean</type></entry>
<!--
        <entry>Test for finite interval</entry>
-->
        <entry>時間間隔が有限かどうかの検査</entry>
        <entry><literal>isfinite(interval '4 hours')</literal></entry>
        <entry><literal>true</literal></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>justify_days</primary>
         </indexterm>
         <literal><function>justify_days(<type>interval</type>)</function></literal>
        </entry>
        <entry><type>interval</type></entry>
<!--
        <entry>Adjust interval so 30-day time periods are represented as months</entry>
-->
        <entry>30日周期が1月を表すように時間間隔を調整</entry>
        <entry><literal>justify_days(interval '35 days')</literal></entry>
        <entry><literal>1 mon 5 days</literal></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>justify_hours</primary>
         </indexterm>
         <literal><function>justify_hours(<type>interval</type>)</function></literal>
        </entry>
        <entry><type>interval</type></entry>
<!--
        <entry>Adjust interval so 24-hour time periods are represented as days</entry>
-->
        <entry>24時間を1日とする時間間隔の調整</entry>
        <entry><literal>justify_hours(interval '27 hours')</literal></entry>
        <entry><literal>1 day 03:00:00</literal></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>justify_interval</primary>
         </indexterm>
         <literal><function>justify_interval(<type>interval</type>)</function></literal>
        </entry>
        <entry><type>interval</type></entry>
<!--
        <entry>Adjust interval using <function>justify_days</> and <function>justify_hours</>, with additional sign adjustments</entry>
-->
        <entry><function>justify_days</>および<function>justify_hours</>を使用し、さらに符号による調整を行っての時間間隔の調整</entry>
        <entry><literal>justify_interval(interval '1 mon -1 hour')</literal></entry>
        <entry><literal>29 days 23:00:00</literal></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>localtime</primary>
         </indexterm>
         <literal><function>localtime</function></literal>
        </entry>
        <entry><type>time</type></entry>
<!--
        <entry>Current time of day;
         see <xref linkend="functions-datetime-current">
-->
        <entry>現在の時刻。<xref linkend="functions-datetime-current">を参照。
        </entry>
        <entry></entry>
        <entry></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>localtimestamp</primary>
         </indexterm>
         <literal><function>localtimestamp</function></literal>
        </entry>
        <entry><type>timestamp</type></entry>
<!--
        <entry>Current date and time (start of current transaction);
         see <xref linkend="functions-datetime-current">
-->
        <entry>現在の日付と時刻（現在のトランザクションの開始時）。<xref linkend="functions-datetime-current">を参照。
        </entry>
        <entry></entry>
        <entry></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>make_date</primary>
         </indexterm>
         <literal>
            <function>
             make_date(<parameter>year</parameter> <type>int</type>,
             <parameter>month</parameter> <type>int</type>,
             <parameter>day</parameter> <type>int</type>)
            </function>
         </literal>
        </entry>
        <entry><type>date</type></entry>
        <entry>
<!--
         Create date from year, month and day fields
-->
         年、月、日フィールドから日付を作成
        </entry>
        <entry><literal>make_date(2013, 7, 15)</literal></entry>
        <entry><literal>2013-07-15</literal></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>make_interval</primary>
         </indexterm>
         <literal>
          <function>
           make_interval(<parameter>years</parameter> <type>int</type> DEFAULT 0,
           <parameter>months</parameter> <type>int</type> DEFAULT 0,
           <parameter>weeks</parameter> <type>int</type> DEFAULT 0,
           <parameter>days</parameter> <type>int</type> DEFAULT 0,
           <parameter>hours</parameter> <type>int</type> DEFAULT 0,
           <parameter>mins</parameter> <type>int</type> DEFAULT 0,
           <parameter>secs</parameter> <type>double precision</type> DEFAULT 0.0)
          </function>
         </literal>
        </entry>
        <entry><type>interval</type></entry>
        <entry>
<!--
         Create interval from years, months, weeks, days, hours, minutes and
         seconds fields
-->
         年、月、週、日、時間、分、秒フィールドから時間間隔を作成
        </entry>
        <entry><literal>make_interval(days => 10)</literal></entry>
        <entry><literal>10 days</literal></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>make_time</primary>
         </indexterm>
         <literal>
          <function>
           make_time(<parameter>hour</parameter> <type>int</type>,
           <parameter>min</parameter> <type>int</type>,
           <parameter>sec</parameter> <type>double precision</type>)
          </function>
         </literal>
        </entry>
        <entry><type>time</type></entry>
        <entry>
<!--
         Create time from hour, minute and seconds fields
-->
         時、分、秒フィールドから時刻を作成
        </entry>
        <entry><literal>make_time(8, 15, 23.5)</literal></entry>
        <entry><literal>08:15:23.5</literal></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>make_timestamp</primary>
         </indexterm>
         <literal>
          <function>
           make_timestamp(<parameter>year</parameter> <type>int</type>,
           <parameter>month</parameter> <type>int</type>,
           <parameter>day</parameter> <type>int</type>,
           <parameter>hour</parameter> <type>int</type>,
           <parameter>min</parameter> <type>int</type>,
           <parameter>sec</parameter> <type>double precision</type>)
          </function>
         </literal>
        </entry>
        <entry><type>timestamp</type></entry>
        <entry>
<!--
         Create timestamp from year, month, day, hour, minute and seconds fields
-->
         年、月、日、時、分、秒フィールドから時刻を作成
        </entry>
        <entry><literal>make_timestamp(2013, 7, 15, 8, 15, 23.5)</literal></entry>
        <entry><literal>2013-07-15 08:15:23.5</literal></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>make_timestamptz</primary>
         </indexterm>
         <literal>
          <function>
           make_timestamptz(<parameter>year</parameter> <type>int</type>,
           <parameter>month</parameter> <type>int</type>,
           <parameter>day</parameter> <type>int</type>,
           <parameter>hour</parameter> <type>int</type>,
           <parameter>min</parameter> <type>int</type>,
           <parameter>sec</parameter> <type>double precision</type>,
           <optional> <parameter>timezone</parameter> <type>text</type> </optional>)
          </function>
         </literal>
        </entry>
        <entry><type>timestamp with time zone</type></entry>
        <entry>
<!--
         Create timestamp with time zone from year, month, day, hour, minute
         and seconds fields. When <parameter>timezone</parameter> is not specified,
         then current time zone is used.
-->
         年、月、日、時、分、秒フィールドから時間帯付きの時刻を作成。<parameter>timezone</parameter>が指定されていなければ、現在の時間帯が使われる。
        </entry>
        <entry><literal>make_timestamptz(2013, 7, 15, 8, 15, 23.5)</literal></entry>
        <entry><literal>2013-07-15 08:15:23.5+01</literal></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>now</primary>
         </indexterm>
         <literal><function>now()</function></literal>
        </entry>
        <entry><type>timestamp with time zone</type></entry>
<!--
        <entry>Current date and time (start of current transaction);
         see <xref linkend="functions-datetime-current">
-->
        <entry>現在の日付と時刻（現在のトランザクションの開始時）。
<xref linkend="functions-datetime-current">を参照。
        </entry>
        <entry></entry>
        <entry></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>statement_timestamp</primary>
         </indexterm>
         <literal><function>statement_timestamp()</function></literal>
        </entry>
        <entry><type>timestamp with time zone</type></entry>
<!--
        <entry>Current date and time (start of current statement);
         see <xref linkend="functions-datetime-current">
-->
        <entry>現在の日付と時刻（現在の文の開始時）。
<xref linkend="functions-datetime-current">を参照。
        </entry>
        <entry></entry>
        <entry></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>timeofday</primary>
         </indexterm>
         <literal><function>timeofday()</function></literal>
        </entry>
        <entry><type>text</type></entry>
<!--
        <entry>Current date and time
         (like <function>clock_timestamp</>, but as a <type>text</> string);
         see <xref linkend="functions-datetime-current">
-->
        <entry>現在の日付と時刻（<function>clock_timestamp</>と似ているが、<type>text</>型文字列として返す）。<xref linkend="functions-datetime-current">を参照。
        </entry>
        <entry></entry>
        <entry></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>transaction_timestamp</primary>
         </indexterm>
         <literal><function>transaction_timestamp()</function></literal>
        </entry>
        <entry><type>timestamp with time zone</type></entry>
<!--
        <entry>Current date and time (start of current transaction);
         see <xref linkend="functions-datetime-current">
-->
        <entry>現在の日付と時刻（現在のトランザクションの開始時）。
<xref linkend="functions-datetime-current">を参照。
        </entry>
        <entry></entry>
        <entry></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
    <indexterm>
      <primary>OVERLAPS</primary>
    </indexterm>
<!--
    In addition to these functions, the SQL <literal>OVERLAPS</> operator is
    supported:
-->
これらの関数に加え、<literal>OVERLAPS</> SQL演算子がサポートされています。
<synopsis>
(<replaceable>start1</replaceable>, <replaceable>end1</replaceable>) OVERLAPS (<replaceable>start2</replaceable>, <replaceable>end2</replaceable>)
(<replaceable>start1</replaceable>, <replaceable>length1</replaceable>) OVERLAPS (<replaceable>start2</replaceable>, <replaceable>length2</replaceable>)
</synopsis>
<!--
    This expression yields true when two time periods (defined by their
    endpoints) overlap, false when they do not overlap.  The endpoints
    can be specified as pairs of dates, times, or time stamps; or as
    a date, time, or time stamp followed by an interval.  When a pair
    of values is provided, either the start or the end can be written
    first; <literal>OVERLAPS</> automatically takes the earlier value
    of the pair as the start.  Each time period is considered to
    represent the half-open interval <replaceable>start</> <literal>&lt;=</>
    <replaceable>time</> <literal>&lt;</> <replaceable>end</>, unless
    <replaceable>start</> and <replaceable>end</> are equal in which case it
    represents that single time instant.  This means for instance that two
    time periods with only an endpoint in common do not overlap.
-->
この式は、2つの時間間隔（その両端で定義されます）が重なる時に真を返します。重ならない場合は偽を返します。
両端は2つの日付、時刻、タイムスタンプとして、もしくは、日付/時刻/タイムスタンプとそれに続く時間間隔として指定できます。
値の組み合わせで指定する場合、開始と終了のいずれを先に記述しても構いません。<literal>OVERLAPS</>は与えられた値のうち、早い方を開始として扱います。
各時間間隔は、<replaceable>start</> <literal>&lt;=</> <replaceable>time</> <literal>&lt;</> <replaceable>end</>という半開区間として見なされます。ただし、<replaceable>start</>と<replaceable>end</>が同じ値の場合には単一の時間点となります。
これは、例えば端点のみが共通である2つの時間間隔は、重ならないということを意味します。
   </para>

<screen>
SELECT (DATE '2001-02-16', DATE '2001-12-21') OVERLAPS
       (DATE '2001-10-30', DATE '2002-10-30');
<lineannotation>Result: </lineannotation><computeroutput>true</computeroutput>
SELECT (DATE '2001-02-16', INTERVAL '100 days') OVERLAPS
       (DATE '2001-10-30', DATE '2002-10-30');
<lineannotation>Result: </lineannotation><computeroutput>false</computeroutput>
SELECT (DATE '2001-10-29', DATE '2001-10-30') OVERLAPS
       (DATE '2001-10-30', DATE '2001-10-31');
<lineannotation>Result: </lineannotation><computeroutput>false</computeroutput>
SELECT (DATE '2001-10-30', DATE '2001-10-30') OVERLAPS
       (DATE '2001-10-30', DATE '2001-10-31');
<lineannotation>Result: </lineannotation><computeroutput>true</computeroutput>
</screen>

  <para>
<!--
   When adding an <type>interval</type> value to (or subtracting an
   <type>interval</type> value from) a <type>timestamp with time zone</type>
   value, the days component advances or decrements the date of the
   <type>timestamp with time zone</type> by the indicated number of days.
   Across daylight saving time changes (when the session time zone is set to a
   time zone that recognizes DST), this means <literal>interval '1 day'</literal>
   does not necessarily equal <literal>interval '24 hours'</literal>.
   For example, with the session time zone set to <literal>CST7CDT</literal>,
   <literal>timestamp with time zone '2005-04-02 12:00-07' + interval '1 day'</literal>
   will produce <literal>timestamp with time zone '2005-04-03 12:00-06'</literal>,
   while adding <literal>interval '24 hours'</literal> to the same initial
   <type>timestamp with time zone</type> produces
   <literal>timestamp with time zone '2005-04-03 13:00-06'</literal>, as there is
   a change in daylight saving time at <literal>2005-04-03 02:00</literal> in time zone
   <literal>CST7CDT</literal>.
-->
<type>timestamp with time zone</type>の値に<type>interval</type>の値を加える時（または<type>interval</type>の値を引く時）、日にちの部分は、<type>timestamp with time zone</type>の日付を指定された日数だけ先に進める、もしくは後に戻します。
（セッションの時間帯がDSTを認識する設定の場合）夏時間の移行に跨っての変化に関しては、<literal>interval '1 day'</literal>が<literal>interval '24 hours'</literal>に等しいとは限りません。
例えば、セッションの時間帯が <literal>CST7CDT</literal>に設定されている時に、 <literal>timestamp with time zone '2005-04-02 12:00-07' + interval '1 day' </literal>は、<literal>timestamp with time zone '2005-04-03 12:00-06'</literal>となります。一方、元の同じ<type>timestamp with time zone</type>に<literal>interval '24 hours'</literal>を加えると、<literal>timestamp with time zone '2005-04-03 13:00-06'</literal>という結果になります。その理由は<literal>CST7CDT</literal>時間帯で<literal>2005-04-03 02:00</literal>に夏時間への変更があるからです。
  </para>

  <para>
<!--
   Note there can be ambiguity in the <literal>months</> field returned by
   <function>age</> because different months have different numbers of
   days.  <productname>PostgreSQL</>'s approach uses the month from the
   earlier of the two dates when calculating partial months.  For example,
   <literal>age('2004-06-01', '2004-04-30')</> uses April to yield
   <literal>1 mon 1 day</>, while using May would yield <literal>1 mon 2
   days</> because May has 31 days, while April has only 30.
-->
異なる月では日数が異なりますので<function>age</>で返される<literal>months</>フィールドにはあいまいさがあります。
<productname>PostgreSQL</>のやり方は月をまたがる２つの日付の計算において、日付の早いほうの月を使用します。
例えば、<literal>age('2004-06-01', '2004-04-30')</>は4月を使用して<literal>1 mon 1 day</>を得ます。5月は31日あり、4月は30日のため、もし5月を使用するなら結果は<literal>1 mon 2 days</>となるでしょう。
  </para>

  <para>
<!--
   Subtraction of dates and timestamps can also be complex.  One conceptually
   simple way to perform subtraction is to convert each value to a number
   of seconds using <literal>EXTRACT(EPOCH FROM ...)</>, then subtract the
   results; this produces the
   number of <emphasis>seconds</> between the two values.  This will adjust
   for the number of days in each month, timezone changes, and daylight
   saving time adjustments.  Subtraction of date or timestamp
   values with the <quote><literal>-</></quote> operator
   returns the number of days (24-hours) and hours/minutes/seconds
   between the values, making the same adjustments.  The <function>age</>
   function returns years, months, days, and hours/minutes/seconds,
   performing field-by-field subtraction and then adjusting for negative
   field values.  The following queries illustrate the differences in these
   approaches.  The sample results were produced with <literal>timezone
   = 'US/Eastern'</>; there is a daylight saving time change between the
   two dates used:
-->
日付とタイムスタンプの引き算は複雑になることがあります。
引き算をする概念的に単純な方法は、それぞれの値を秒数に<literal>EXTRACT(EPOCH FROM ...)</>で変換してから、結果を引き算する方法です。この結果は2つの値の間の<emphasis>秒</>数になります。
これは各月の日数、時間帯の変更、夏時間の調整に対して調整されるでしょう。
<quote><literal>-</></quote>演算子での日付やタイムスタンプの引き算は値の間の(24時間の)日数と時間/分/秒を、同様に調整して返します。
<function>age</>関数は年、月、日、時間/分/秒をフィールド毎に引き算し、負のフィールドの値を調整します。
以下の問い合わせは上の各方法の違いを説明する例です。
例の結果は<literal>timezone = 'US/Eastern'</>で生成されました。2つの日付の間には夏時間の変更があります。
  </para>

<screen>
SELECT EXTRACT(EPOCH FROM timestamptz '2013-07-01 12:00:00') -
       EXTRACT(EPOCH FROM timestamptz '2013-03-01 12:00:00');
<!--
<lineannotation>Result: </lineannotation><computeroutput>10537200</computeroutput>
-->
<lineannotation>結果: </lineannotation><computeroutput>10537200</computeroutput>
SELECT (EXTRACT(EPOCH FROM timestamptz '2013-07-01 12:00:00') -
        EXTRACT(EPOCH FROM timestamptz '2013-03-01 12:00:00'))
        / 60 / 60 / 24;
<!--
<lineannotation>Result: </lineannotation><computeroutput>121.958333333333</computeroutput>
-->
<lineannotation>結果: </lineannotation><computeroutput>121.958333333333</computeroutput>
SELECT timestamptz '2013-07-01 12:00:00' - timestamptz '2013-03-01 12:00:00';
<!--
<lineannotation>Result: </lineannotation><computeroutput>121 days 23:00:00</computeroutput>
-->
<lineannotation>結果: </lineannotation><computeroutput>121 days 23:00:00</computeroutput>
SELECT age(timestamptz '2013-07-01 12:00:00', timestamptz '2013-03-01 12:00:00');
<!--
<lineannotation>Result: </lineannotation><computeroutput>4 mons</computeroutput>
-->
<lineannotation>結果: </lineannotation><computeroutput>4 mons</computeroutput>
</screen>

  <sect2 id="functions-datetime-extract">
   <title><function>EXTRACT</function>, <function>date_part</function></title>

   <indexterm>
    <primary>date_part</primary>
   </indexterm>
   <indexterm>
    <primary>extract</primary>
   </indexterm>

<synopsis>
EXTRACT(<replaceable>field</replaceable> FROM <replaceable>source</replaceable>)
</synopsis>

   <para>
<!--
    The <function>extract</function> function retrieves subfields
    such as year or hour from date/time values.
    <replaceable>source</replaceable> must be a value expression of
    type <type>timestamp</type>, <type>time</type>, or <type>interval</type>.
    (Expressions of type <type>date</type> are
    cast to <type>timestamp</type> and can therefore be used as
    well.)  <replaceable>field</replaceable> is an identifier or
    string that selects what field to extract from the source value.
    The <function>extract</function> function returns values of type
    <type>double precision</type>.
    The following are valid field names:
-->
<function>extract</function>関数は、日付/時刻の値から年や時などの部分フィールドを抽出します。
<replaceable>source</replaceable>は<type>timestamp</type>型、<type>time</type>型、または<type>interval</type>型の評価式でなければなりません（<type>date</type>型の式は<type>timestamp</type>型にキャストされますので、同様に使用可能です）。
<replaceable>field</replaceable>はsourceの値からどのフィールドを抽出するかを選択する識別子もしくは文字列です。
<function>extract</function>関数は<type>double precision</type>型の値を返します。以下に有効なフィールド名を示します。

    <!-- alphabetical -->
    <variablelist>
     <varlistentry>
      <term><literal>century</literal></term>
      <listitem>
       <para>
<!--
        The century
-->
世紀
       </para>

<screen>
SELECT EXTRACT(CENTURY FROM TIMESTAMP '2000-12-16 12:21:13');
<lineannotation>Result: </lineannotation><computeroutput>20</computeroutput>
SELECT EXTRACT(CENTURY FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>21</computeroutput>
</screen>

       <para>
<!--
        The first century starts at 0001-01-01 00:00:00 AD, although
        they did not know it at the time. This definition applies to all
        Gregorian calendar countries. There is no century number 0,
        you go from -1 century to 1 century.

        If you disagree with this, please write your complaint to:
        Pope, Cathedral Saint-Peter of Roma, Vatican.
-->
当時の人々にはそのような意識はありませんでしたが、最初の世紀は0001-01-01 00:00:00 ADから始まります。
この定義は全てのグレゴリオ暦を使用する国で適用されています。
0という値の世紀はありません。-1世紀の次は1世紀です。

この定義に納得できなければ、苦情をバチカンローマ聖パウロ大聖堂のローマ法王に伝えてください。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>day</literal></term>
      <listitem>
       <para>
<!--
        For <type>timestamp</type> values, the day (of the month) field
        (1 - 31) ; for <type>interval</type> values, the number of days
-->
<type>timestamp</type>値については、(月内の）日付フィールド（1〜31)。<type>interval</type>値については日数。
       </para>

<screen>
SELECT EXTRACT(DAY FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>16</computeroutput>

SELECT EXTRACT(DAY FROM INTERVAL '40 days 1 minute');
<lineannotation>Result: </lineannotation><computeroutput>40</computeroutput>
</screen>



      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>decade</literal></term>
      <listitem>
       <para>
<!--
        The year field divided by 10
-->
年フィールドを10で割ったもの
       </para>

<screen>
SELECT EXTRACT(DECADE FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>200</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>dow</literal></term>
      <listitem>
       <para>
<!--
        The day of the week as Sunday (<literal>0</>) to
        Saturday (<literal>6</>)
-->
日曜日（<literal>0</>）から土曜日（<literal>6</>）までの曜日
       </para>

<screen>
SELECT EXTRACT(DOW FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>5</computeroutput>
</screen>
       <para>
<!--
        Note that <function>extract</function>'s day of the week numbering
        differs from that of the <function>to_char(...,
        'D')</function> function.
-->
<function>extract</function>関数の曜日番号は<function>to_char(...,'D')</function>関数のそれとは異なる点に注意してください。
       </para>

      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>doy</literal></term>
      <listitem>
       <para>
<!--
        The day of the year (1 - 365/366)
-->
年内での通算日数（1〜365/366）
       </para>

<screen>
SELECT EXTRACT(DOY FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>47</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>epoch</literal></term>
      <listitem>
       <para>
<!--
        For <type>timestamp with time zone</type> values, the
        number of seconds since 1970-01-01 00:00:00 UTC (can be negative);
        for <type>date</type> and <type>timestamp</type> values, the
        number of seconds since 1970-01-01 00:00:00 local time;
        for <type>interval</type> values, the total number
        of seconds in the interval
-->
<type>timestamp with time zone</type>型の値において、1970-01-01 00:00:00 UTCからの秒数（負の数の場合もあり）。<type>date</type>と<type>timestamp</type>型の値において、ローカルタイムの1970-01-01 00:00:00からの秒数。<type>interval</type>型の値ではその時間間隔における全体の秒数。
       </para>

<screen>
SELECT EXTRACT(EPOCH FROM TIMESTAMP WITH TIME ZONE '2001-02-16 20:38:40.12-08');
<lineannotation>Result: </lineannotation><computeroutput>982384720.12</computeroutput>

SELECT EXTRACT(EPOCH FROM INTERVAL '5 days 3 hours');
<lineannotation>Result: </lineannotation><computeroutput>442800</computeroutput>
</screen>

       <para>
<!--
        Here is how you can convert an epoch value back to a time
        stamp:
-->
以下に、この経過秒数をタイムスタンプ値に変換する方法を示します。
       </para>
<screen>
SELECT TIMESTAMP WITH TIME ZONE 'epoch' + 982384720.12 * INTERVAL '1 second';
</screen>
       <para>
<!--
        (The <function>to_timestamp</> function encapsulates the above
        conversion.)
-->
(<function>to_timestamp</>関数は上記の変換をカプセル化します。)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>hour</literal></term>
      <listitem>
       <para>
<!--
        The hour field (0 - 23)
-->
時のフィールド（0〜23）
       </para>

<screen>
SELECT EXTRACT(HOUR FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>20</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>isodow</literal></term>
      <listitem>
       <para>
<!--
        The day of the week as Monday (<literal>1</>) to
        Sunday (<literal>7</>)
-->
月曜日（<literal>1</>）から日曜日（<literal>7</>）までの曜日
       </para>

<screen>
SELECT EXTRACT(ISODOW FROM TIMESTAMP '2001-02-18 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>7</computeroutput>
</screen>
       <para>
<!--
        This is identical to <literal>dow</> except for Sunday.  This
        matches the <acronym>ISO</> 8601 day of the week numbering.
-->
日曜日を除き<literal>dow</>と同一です。
これは<acronym>ISO</> 8601曜日番号付けに一致します。
       </para>

      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>isoyear</literal></term>
      <listitem>
       <para>
<!--
        The <acronym>ISO</acronym> 8601 week-numbering year that the date
        falls in (not applicable to intervals)
-->
日付に当てはまる<acronym>ISO</acronym> 8601週番号年（intervalには適用できない）。
       </para>

<screen>
SELECT EXTRACT(ISOYEAR FROM DATE '2006-01-01');
<lineannotation>Result: </lineannotation><computeroutput>2005</computeroutput>
SELECT EXTRACT(ISOYEAR FROM DATE '2006-01-02');
<lineannotation>Result: </lineannotation><computeroutput>2006</computeroutput>
</screen>

       <para>
<!--
        Each <acronym>ISO</acronym> 8601 week-numbering year begins with the
        Monday of the week containing the 4th of January, so in early
        January or late December the <acronym>ISO</acronym> year may be
        different from the Gregorian year.  See the <literal>week</literal>
        field for more information.
-->
すべての<acronym>ISO</acronym> 8601週番号年は1月4日を含む週の月曜日から開始されます。従って、1月上旬、または12月下旬で<acronym>ISO</acronym>年がグレゴリオ年と異なる可能性があります。
より詳細は<literal>week</literal>フィールドを参照してください。
       </para>
       <para>
<!--
        This field is not available in PostgreSQL releases prior to 8.3.
-->
このフィールドは8.3より前のPostgreSQLリリースでは有効でありません。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>microseconds</literal></term>
      <listitem>
       <para>
<!--
        The seconds field, including fractional parts, multiplied by 1
        000 000;  note that this includes full seconds
-->
端数部分も含む秒フィールドに、1,000,000を乗じた値。秒の整数部を含むことに注意。
       </para>

<screen>
SELECT EXTRACT(MICROSECONDS FROM TIME '17:12:28.5');
<lineannotation>Result: </lineannotation><computeroutput>28500000</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>millennium</literal></term>
      <listitem>
       <para>
<!--
        The millennium
-->
ミレニアム（千年期）
       </para>

<screen>
SELECT EXTRACT(MILLENNIUM FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>3</computeroutput>
</screen>

       <para>
<!--
        Years in the 1900s are in the second millennium.
        The third millennium started January 1, 2001.
-->
1900年代の年は第2ミレニアムです。第3ミレニアムは2001年1月1日から始まりました。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>milliseconds</literal></term>
      <listitem>
       <para>
<!--
        The seconds field, including fractional parts, multiplied by
        1000.  Note that this includes full seconds.
-->
端数部分も含む秒フィールドに、1000を乗た値。秒の整数部を含むことに注意してください。
       </para>

<screen>
SELECT EXTRACT(MILLISECONDS FROM TIME '17:12:28.5');
<lineannotation>Result: </lineannotation><computeroutput>28500</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>minute</literal></term>
      <listitem>
       <para>
<!--
        The minutes field (0 - 59)
-->
分フィールド（0〜59）
       </para>

<screen>
SELECT EXTRACT(MINUTE FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>38</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>month</literal></term>
      <listitem>
       <para>
<!--
        For <type>timestamp</type> values, the number of the month
        within the year (1 - 12) ; for <type>interval</type> values,
        the number of months, modulo 12 (0 - 11)
-->
<type>timestamp</type>型の値に対しては年内の月番号（1〜12）。<type>interval</type>型の値に対しては月数を12で割った余り（0〜11）。
       </para>

<screen>
SELECT EXTRACT(MONTH FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>2</computeroutput>

SELECT EXTRACT(MONTH FROM INTERVAL '2 years 3 months');
<lineannotation>Result: </lineannotation><computeroutput>3</computeroutput>

SELECT EXTRACT(MONTH FROM INTERVAL '2 years 13 months');
<lineannotation>Result: </lineannotation><computeroutput>1</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>quarter</literal></term>
      <listitem>
       <para>
<!--
        The quarter of the year (1 - 4) that the date is in
-->
その日付が含まれる年の四半期（1〜4）。
       </para>

<screen>
SELECT EXTRACT(QUARTER FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>1</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>second</literal></term>
      <listitem>
       <para>
<!--
        The seconds field, including fractional parts (0 -
        59<footnote><simpara>60 if leap seconds are
        implemented by the operating system</simpara></footnote>)
-->
端数を含んだ秒フィールド（0〜59<footnote><simpara>オペレーティングシステムでうるう秒が実装されている場合は60まで。</simpara></footnote>）。
       </para>

<screen>
SELECT EXTRACT(SECOND FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>40</computeroutput>

SELECT EXTRACT(SECOND FROM TIME '17:12:28.5');
<lineannotation>Result: </lineannotation><computeroutput>28.5</computeroutput>
</screen>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>timezone</literal></term>
      <listitem>
       <para>
<!--
        The time zone offset from UTC, measured in seconds.  Positive values
        correspond to time zones east of UTC, negative values to
        zones west of UTC.  (Technically,
        <productname>PostgreSQL</productname> uses <acronym>UT1</> because
        leap seconds are not handled.)
-->
秒単位のUTCからの時間帯オフセット。正の値はUTCより東の時間帯に対応し、負の値はUTCより西の時間帯に対応。
(技術的には、<productname>PostgreSQL</productname>はうるう秒を制御しないため<acronym>UT1</>を使用。)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>timezone_hour</literal></term>
      <listitem>
       <para>
<!--
        The hour component of the time zone offset
-->
時間帯オフセットの時の成分。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>timezone_minute</literal></term>
      <listitem>
       <para>
<!--
        The minute component of the time zone offset
-->
時間帯オフセットの分の成分。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>week</literal></term>
      <listitem>
       <para>
<!--
        The number of the <acronym>ISO</acronym> 8601 week-numbering week of
        the year.  By definition, ISO weeks start on Mondays and the first
        week of a year contains January 4 of that year.  In other words, the
        first Thursday of a year is in week 1 of that year.
-->
<acronym>ISO</acronym> 8601週番号。
定義ではISO週は月曜日から始まり、その年の1月4日を含む週をその年の第1週としています。
つまり、年の最初の木曜日がある週がその年の第1週となります。
       </para>
       <para>
<!--
        In the ISO week-numbering system, it is possible for early-January
        dates to be part of the 52nd or 53rd week of the previous year, and for
        late-December dates to be part of the first week of the next year.
        For example, <literal>2005-01-01</> is part of the 53rd week of year
        2004, and <literal>2006-01-01</> is part of the 52nd week of year
        2005, while <literal>2012-12-31</> is part of the first week of 2013.
        It's recommended to use the <literal>isoyear</> field together with
        <literal>week</> to get consistent results.
-->
ISO週番号システムでは、1月の早い日にちは前年の第52週もしくは第53週となることがあり、12月の遅い日にちには次年の最初の週の一部となることがあります。
例えば、<literal>2005-01-01</>は2004年の第53週であり、<literal>2006-01-01</>は2005年の第52週の一部です、一方<literal>2012-12-31</>は2013年の第1週の一部となります。
整合性のある結果を得るため、<literal>isoyear</>フィールドと<literal>week</>を併用することを推奨します。
       </para>

<screen>
SELECT EXTRACT(WEEK FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>7</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>year</literal></term>
      <listitem>
       <para>
<!--
        The year field.  Keep in mind there is no <literal>0 AD</>, so subtracting
        <literal>BC</> years from <literal>AD</> years should be done with care.
-->
年フィールド。<literal>AD零年</>が存在しないことは忘れないでください。このため<literal>AD</>の年から<literal>BC</>の年を減ずる時には注意が必要です。
       </para>

<screen>
SELECT EXTRACT(YEAR FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>2001</computeroutput>
</screen>
      </listitem>
     </varlistentry>

    </variablelist>
   </para>

   <para>
<!--
    The <function>extract</function> function is primarily intended
    for computational processing.  For formatting date/time values for
    display, see <xref linkend="functions-formatting">.
-->
<function>extract</function>関数は主に演算処理を意図しています。
日付/時刻の値を表示する目的での書式については<xref linkend="functions-formatting">を参照してください。
   </para>

   <para>
<!--
    The <function>date_part</function> function is modeled on the traditional
    <productname>Ingres</productname> equivalent to the
    <acronym>SQL</acronym>-standard function <function>extract</function>:
-->
<function>date_part</function>関数は伝統的な<productname>Ingres</productname>上で設計されたもので、標準<acronym>SQL</acronym>の<function>extract</function>関数と等価です。
<synopsis>
date_part('<replaceable>field</replaceable>', <replaceable>source</replaceable>)
</synopsis>
<!--
    Note that here the <replaceable>field</replaceable> parameter needs to
    be a string value, not a name.  The valid field names for
    <function>date_part</function> are the same as for
    <function>extract</function>.
-->
ここで<replaceable>field</replaceable>パラメータが名前ではなく文字列値である必要があることに注意してください。
<function>date_part</function>で有効なフィールド名は<function>extract</function>と同じです。
   </para>

<screen>
SELECT date_part('day', TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>16</computeroutput>

SELECT date_part('hour', INTERVAL '4 hours 3 minutes');
<lineannotation>Result: </lineannotation><computeroutput>4</computeroutput>
</screen>

  </sect2>

  <sect2 id="functions-datetime-trunc">
   <title><function>date_trunc</function></title>

   <indexterm>
    <primary>date_trunc</primary>
   </indexterm>

   <para>
<!--
    The function <function>date_trunc</function> is conceptually
    similar to the <function>trunc</function> function for numbers.
-->
<function>date_trunc</function>関数は概念的に数値に対する<function>trunc</function>関数と類似しています。
   </para>

   <para>
<synopsis>
date_trunc('<replaceable>field</replaceable>', <replaceable>source</replaceable>)
</synopsis>
<!--
    <replaceable>source</replaceable> is a value expression of type
    <type>timestamp</type> or <type>interval</>.
    (Values of type <type>date</type> and
    <type>time</type> are cast automatically to <type>timestamp</type> or
    <type>interval</>, respectively.)
    <replaceable>field</replaceable> selects to which precision to
    truncate the input value.  The return value is of type
    <type>timestamp</type> or <type>interval</>
    with all fields that are less significant than the
    selected one set to zero (or one, for day and month).
-->
<replaceable>source</replaceable>は、データ型<type>timestamp</type>もしくは<type>interval</>の評価式です
（<type>date</type>型と<type>time</type>型の値はそれぞれ自動的に<type>timestamp</type>もしくは<type>interval</>にキャストされます。）
<replaceable>field</replaceable>は、入力値の値をどの精度で切り捨てるかを選択します。
戻り値は<type>timestamp</type>もしくは<type>interval</>型で、指定した精度より下のすべてのフィールドがゼロに設定（日と月については1に設定）されます。
   </para>

   <para>
<!--
    Valid values for <replaceable>field</replaceable> are:
-->
<replaceable>field</replaceable>の有効値には次のものがあります。
    <simplelist>
     <member><literal>microseconds</literal></member>
     <member><literal>milliseconds</literal></member>
     <member><literal>second</literal></member>
     <member><literal>minute</literal></member>
     <member><literal>hour</literal></member>
     <member><literal>day</literal></member>
     <member><literal>week</literal></member>
     <member><literal>month</literal></member>
     <member><literal>quarter</literal></member>
     <member><literal>year</literal></member>
     <member><literal>decade</literal></member>
     <member><literal>century</literal></member>
     <member><literal>millennium</literal></member>
    </simplelist>
   </para>

   <para>
<!--
    Examples:
-->
例：
<screen>
SELECT date_trunc('hour', TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>2001-02-16 20:00:00</computeroutput>

SELECT date_trunc('year', TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>2001-01-01 00:00:00</computeroutput>
</screen>
   </para>
  </sect2>

  <sect2 id="functions-datetime-zoneconvert">
   <title><literal>AT TIME ZONE</literal></title>

   <indexterm>
<!--
    <primary>time zone</primary>
    <secondary>conversion</secondary>
-->
    <primary>時間帯</primary>
    <secondary>変換</secondary>
   </indexterm>

   <indexterm>
    <primary>AT TIME ZONE</primary>
   </indexterm>

   <para>
<!--
    The <literal>AT TIME ZONE</literal> construct allows conversions
    of time stamps to different time zones.  <xref
    linkend="functions-datetime-zoneconvert-table"> shows its
    variants.
-->
<function>AT TIME ZONE</function>構文を使用することにより、タイムスタンプを異なる時間帯に変換することができます。
<xref linkend="functions-datetime-zoneconvert-table">にその種類を示します。
   </para>

    <table id="functions-datetime-zoneconvert-table">
<!--
     <title><literal>AT TIME ZONE</literal> Variants</title>
-->
     <title><literal>AT TIME ZONE</literal>の種類</title>
     <tgroup cols="3">
      <thead>
       <row>
<!--
        <entry>Expression</entry>
        <entry>Return Type</entry>
        <entry>Description</entry>
-->
        <entry>式</entry>
        <entry>戻り値</entry>
        <entry>説明</entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry>
         <literal><type>timestamp without time zone</type> AT TIME ZONE <replaceable>zone</></literal>
        </entry>
        <entry><type>timestamp with time zone</type></entry>
<!--
        <entry>Treat given time stamp <emphasis>without time zone</> as located in the specified time zone</entry>
-->
        <entry>与えられた<emphasis>時間帯なし</>タイムスタンプを指定された時間帯にあるとして取り扱います。</entry>
       </row>

       <row>
        <entry>
         <literal><type>timestamp with time zone</type> AT TIME ZONE <replaceable>zone</></literal>
        </entry>
        <entry><type>timestamp without time zone</type></entry>
<!--
        <entry>Convert given time stamp <emphasis>with time zone</> to the new time
        zone, with no time zone designation</entry>
-->
        <entry>与えられた<emphasis>時間帯付き</>タイムスタンプを新規の時間帯に、時間帯の指定なく変換します。</entry>
       </row>

       <row>
        <entry>
         <literal><type>time with time zone</type> AT TIME ZONE <replaceable>zone</></literal>
        </entry>
        <entry><type>time with time zone</type></entry>
<!--
        <entry>Convert given time <emphasis>with time zone</> to the new time zone</entry>
-->
        <entry>与えられた時刻<emphasis>with time zone</>を新しい時間帯に変換します。</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
<!--
    In these expressions, the desired time zone <replaceable>zone</> can be
    specified either as a text string (e.g., <literal>'PST'</literal>)
    or as an interval (e.g., <literal>INTERVAL '-08:00'</literal>).
    In the text case, a time zone name can be specified in any of the ways
    described in <xref linkend="datatype-timezones">.
-->
これらの式では、設定する時間帯<replaceable>zone</>は、（<literal>'PST'</literal>のような）テキスト文字列、または（<literal>INTERVAL '-08:00'</literal>のような）時間間隔で指定することができます。
テキストの場合、<xref linkend="datatype-timezones">に示した方法で時間帯名称を指定することができます。
   </para>

   <para>
<!--
    Examples (assuming the local time zone is <literal>PST8PDT</>):
-->
以下に例を示します（ローカル時間帯を<literal>PST8PDT</>と想定しています）。
<screen>
SELECT TIMESTAMP '2001-02-16 20:38:40' AT TIME ZONE 'MST';
<lineannotation>Result: </lineannotation><computeroutput>2001-02-16 19:38:40-08</computeroutput>

SELECT TIMESTAMP WITH TIME ZONE '2001-02-16 20:38:40-05' AT TIME ZONE 'MST';
<lineannotation>Result: </lineannotation><computeroutput>2001-02-16 18:38:40</computeroutput>
</screen>
<!--
    The first example takes a time stamp without time zone and interprets it as MST time
    (UTC-7), which is then converted to PST (UTC-8) for display.  The second example takes
    a time stamp specified in EST (UTC-5) and converts it to local time in MST (UTC-7).
-->
最初の例は、時間帯のないタイプスタンプを使用し、それをMST時間（UTC-7）として解釈し、そして表示用にPST（UTC-7）に変換します。
2番目の例は、EST（UTC-5）で指定されたタイムスタンプを使用し、MST（UTC-7）でのローカル時間に変換しています。
   </para>

   <para>
<!--
    The function <literal><function>timezone</function>(<replaceable>zone</>,
    <replaceable>timestamp</>)</literal> is equivalent to the SQL-conforming construct
    <literal><replaceable>timestamp</> AT TIME ZONE
    <replaceable>zone</></literal>.
-->
関数<function>timezone</function>(<replaceable>zone</>, <replaceable>timestamp</>)は、SQL準拠の構文<literal><replaceable>timestamp</> AT TIME ZONE <replaceable>zone</></literal>と等価です。
   </para>
  </sect2>

  <sect2 id="functions-datetime-current">
   <title>Current Date/Time</title>

   <indexterm>
<!--
    <primary>date</primary>
    <secondary>current</secondary>
-->
    <primary>日付</primary>
    <secondary>現在</secondary>
   </indexterm>

   <indexterm>
<!--
    <primary>time</primary>
    <secondary>current</secondary>
-->
    <primary>時刻</primary>
    <secondary>現在</secondary>
   </indexterm>

   <para>
<!--
    <productname>PostgreSQL</productname> provides a number of functions
    that return values related to the current date and time.  These
    SQL-standard functions all return values based on the start time of
    the current transaction:
-->
<productname>PostgreSQL</productname>は、現在の日付時刻に関した値を返す多くの関数を提供します。
これらの標準SQL関数はすべて、現在のトランザクションの開始時刻に基づいた値を返します。
<synopsis>
CURRENT_DATE
CURRENT_TIME
CURRENT_TIMESTAMP
CURRENT_TIME(<replaceable>precision</replaceable>)
CURRENT_TIMESTAMP(<replaceable>precision</replaceable>)
LOCALTIME
LOCALTIMESTAMP
LOCALTIME(<replaceable>precision</replaceable>)
LOCALTIMESTAMP(<replaceable>precision</replaceable>)
</synopsis>
    </para>

    <para>
<!--
     <function>CURRENT_TIME</function> and
     <function>CURRENT_TIMESTAMP</function> deliver values with time zone;
     <function>LOCALTIME</function> and
     <function>LOCALTIMESTAMP</function> deliver values without time zone.
-->
<function>CURRENT_TIME</function>および<function>CURRENT_TIMESTAMP</function>関数では、時間帯を伴う値を扱います。一方、<function>LOCALTIME</function>および<function>LOCALTIMESTAMP</function>関数では、時間帯を伴わない値を扱います。
    </para>

    <para>
<!--
     <function>CURRENT_TIME</function>,
     <function>CURRENT_TIMESTAMP</function>,
     <function>LOCALTIME</function>, and
     <function>LOCALTIMESTAMP</function>
     can optionally take
     a precision parameter, which causes the result to be rounded
     to that many fractional digits in the seconds field.  Without a precision parameter,
     the result is given to the full available precision.
-->
<function>CURRENT_TIME</function>、<function>CURRENT_TIMESTAMP</function>、<function>LOCALTIME</function>、および<function>LOCALTIMESTAMP</function>関数では、精度のパラメータをオプションで取ることができ、それに合わせて秒フィールドの端数桁を丸める結果をもたらします。
精度のパラメータがない場合、結果は使用可能な最大精度で出力されます。
    </para>

   <para>
<!--
    Some examples:
-->
例：
<screen>
SELECT CURRENT_TIME;
<lineannotation>Result: </lineannotation><computeroutput>14:39:53.662522-05</computeroutput>

SELECT CURRENT_DATE;
<lineannotation>Result: </lineannotation><computeroutput>2001-12-23</computeroutput>

SELECT CURRENT_TIMESTAMP;
<lineannotation>Result: </lineannotation><computeroutput>2001-12-23 14:39:53.662522-05</computeroutput>

SELECT CURRENT_TIMESTAMP(2);
<lineannotation>Result: </lineannotation><computeroutput>2001-12-23 14:39:53.66-05</computeroutput>

SELECT LOCALTIMESTAMP;
<lineannotation>Result: </lineannotation><computeroutput>2001-12-23 14:39:53.662522</computeroutput>
</screen>
   </para>

   <para>
<!--
    Since these functions return
    the start time of the current transaction, their values do not
    change during the transaction. This is considered a feature:
    the intent is to allow a single transaction to have a consistent
    notion of the <quote>current</quote> time, so that multiple
    modifications within the same transaction bear the same
    time stamp.
-->
これらの関数は現在のトランザクションの開始時刻を返すため、その値はトランザクションが実行されている間は変化しません。
これは仕様であると考えられており、その意図は、単一のトランザクションが一貫性のある<quote>現在</quote>時刻の概念を持ち、同一トランザクション内の複数の変更が同一のタイムスタンプを持つようにすることにあります。
   </para>

   <note>
    <para>
<!--
     Other database systems might advance these values more
     frequently.
-->
他のデータベースシステムでは、これらの値をより頻繁に増加させることがあります。
    </para>
   </note>

   <para>
<!--
    <productname>PostgreSQL</productname> also provides functions that
    return the start time of the current statement, as well as the actual
    current time at the instant the function is called.  The complete list
    of non-SQL-standard time functions is:
-->
<productname>PostgreSQL</productname>はまた、関数を呼び出した時の実際の現在時刻や現在の文の開始時刻を返す関数も提供します。
非標準SQLの時間関数の全一覧を以下に示します。
<synopsis>
transaction_timestamp()
statement_timestamp()
clock_timestamp()
timeofday()
now()
</synopsis>
   </para>

   <para>
<!--
    <function>transaction_timestamp()</> is equivalent to
    <function>CURRENT_TIMESTAMP</function>, but is named to clearly reflect
    what it returns.
    <function>statement_timestamp()</> returns the start time of the current
    statement (more specifically, the time of receipt of the latest command
    message from the client).
    <function>statement_timestamp()</> and <function>transaction_timestamp()</>
    return the same value during the first command of a transaction, but might
    differ during subsequent commands.
    <function>clock_timestamp()</> returns the actual current time, and
    therefore its value changes even within a single SQL command.
    <function>timeofday()</> is a historical
    <productname>PostgreSQL</productname> function.  Like
    <function>clock_timestamp()</>, it returns the actual current time,
    but as a formatted <type>text</> string rather than a <type>timestamp
    with time zone</> value.
    <function>now()</> is a traditional <productname>PostgreSQL</productname>
    equivalent to <function>transaction_timestamp()</function>.
-->
<function>transaction_timestamp()</>は<function>CURRENT_TIMESTAMP</function>と等価ですが、明確に何を返すかを反映する名前になっています。
<function>statement_timestamp()</>は現在の文の実行開始時刻を返すものです（より具体的にいうと、直前のコマンドメッセージをクライアントから受け取った時刻です）。
<function>statement_timestamp()</>および<function>transaction_timestamp()</>はトランザクションの最初のコマンドでは同じ値を返しますが、その後に引き続くコマンドでは異なる可能性があります。
<function>clock_timestamp()</>は実際の現在時刻を返しますので、その値は単一のSQLコマンドであっても異なります。
<function>timeofday()</>は<productname>PostgreSQL</productname>の歴史的な関数です。
<function>clock_timestamp()</>同様、実際の現在時刻を返しますが、<type>timestamp with time zone</>型の値ではなく、整形された<type>text</>文字列を返します。<function>now()</>は<function>transaction_timestamp()</function>と同じもので、伝統的な<productname>PostgreSQL</productname>関数です。
   </para>

   <para>
<!--
    All the date/time data types also accept the special literal value
    <literal>now</literal> to specify the current date and time (again,
    interpreted as the transaction start time).  Thus,
    the following three all return the same result:
-->
すべての日付/時刻型はまた、特殊なリテラル値 <literal>now</literal>を受け付け、これは現在の日付と時刻（ここでも、トランザクションの開始時刻として解釈されます）を表します。
したがって、下記の３つの実行結果は全て同じものとなります。
<programlisting>
SELECT CURRENT_TIMESTAMP;
SELECT now();
<!--
SELECT TIMESTAMP 'now';  &#045;- incorrect for use with DEFAULT
-->
SELECT TIMESTAMP 'now';  -- DEFAULTで使用するのは正しくない
</programlisting>
   </para>

    <tip>
     <para>
<!--
      You do not want to use the third form when specifying a <literal>DEFAULT</>
      clause while creating a table.  The system will convert <literal>now</literal>
      to a <type>timestamp</type> as soon as the constant is parsed, so that when
      the default value is needed,
      the time of the table creation would be used!  The first two
      forms will not be evaluated until the default value is used,
      because they are function calls.  Thus they will give the desired
      behavior of defaulting to the time of row insertion.
-->
テーブルを作成する時、<literal>DEFAULT</>句を指定するのに3番目の形式を使おうとは思わないでしょう。
システムは<literal>now</literal>という定数を解析すると、すぐにそれを<type>timestamp</type>に変換するので、デフォルト値が必要が時には、テーブルが作成された時刻が使われます。最初の2つの形式は関数呼び出しなので、デフォルト値が使用されるまで評価されません。ですから、これらの関数は列の挿入時間をデフォルトとする、望ましい振舞いをします。
     </para>
    </tip>
  </sect2>

  <sect2 id="functions-datetime-delay">
<!--
   <title>Delaying Execution</title>
-->
   <title>遅延実行</title>

   <indexterm>
    <primary>pg_sleep</primary>
   </indexterm>
   <indexterm>
    <primary>pg_sleep_for</primary>
   </indexterm>
   <indexterm>
    <primary>pg_sleep_until</primary>
   </indexterm>
   <indexterm>
<!--
    <primary>sleep</primary>
-->
    <primary>休止</primary>
   </indexterm>
   <indexterm>
<!--
    <primary>delay</primary>
-->
    <primary>遅延</primary>
   </indexterm>

   <para>
<!--
    The following functions are available to delay execution of the server
    process:
-->
以下の関数は、サーバプロセスの実行を遅延させるために使用可能です。
<synopsis>
pg_sleep(<replaceable>seconds</replaceable>)
pg_sleep_for(<type>interval</>)
pg_sleep_until(<type>timestamp with time zone</>)
</synopsis>

<!--
    <function>pg_sleep</function> makes the current session's process
    sleep until <replaceable>seconds</replaceable> seconds have
    elapsed.  <replaceable>seconds</replaceable> is a value of type
    <type>double precision</>, so fractional-second delays can be specified.
    <function>pg_sleep_for</function> is a convenience function for larger
    sleep times specified as an <type>interval</>.
    <function>pg_sleep_until</function> is a convenience function for when
    a specific wake-up time is desired.
    For example:
-->
<function>pg_sleep</function>は、<replaceable>seconds</replaceable>秒経過するまで、現在のセッションのプロセスを休止させます。
<replaceable>seconds</replaceable>は<type>double precision</>型の値です。そのため、小数単位で休止秒数を指定することができます。
<function>pg_sleep_for</function>は<type>interval</>でより長い休止時間を指定する便利な関数です。
<function>pg_sleep_until</function>は特定の起床時刻が望まれる場合に便利な関数です。
以下に例を示します。

<programlisting>
SELECT pg_sleep(1.5);
SELECT pg_sleep_for('5 minutes');
SELECT pg_sleep_until('tomorrow 03:00');
</programlisting>
   </para>

   <note>
     <para>
<!--
      The effective resolution of the sleep interval is platform-specific;
      0.01 seconds is a common value.  The sleep delay will be at least as long
      as specified. It might be longer depending on factors such as server load.
      In particular, <function>pg_sleep_until</function> is not guaranteed to
      wake up exactly at the specified time, but it will not wake up any earlier.
-->
休止時間の有効な分解能はプラットフォームに依存します。0.01秒が一般的な値です。
休止による遅延は最短で指定した時間と同じになります。
サーバの負荷などが要因となり、より長くなる可能性があります。
特に、<function>pg_sleep_until</function>は指定した時刻ちょうどに起床する保証はありませんが、それより早く起床することはありません。
     </para>
   </note>

   <warning>
     <para>
<!--
      Make sure that your session does not hold more locks than necessary
      when calling <function>pg_sleep</function> or its variants.  Otherwise
      other sessions might have to wait for your sleeping process, slowing down
      the entire system.
-->
<function>pg_sleep</function>またはその亜種を呼び出す時、セッションが必要以上のロックを保持していないことを確実にしてください。
さもないと、他のセッションが休止中のプロセスを待機しなければならないかもしれません。そのためシステム全体の速度が低下することになるかもしれません。
     </para>
   </warning>
  </sect2>

 </sect1>


 <sect1 id="functions-enum">
<!--
  <title>Enum Support Functions</title>
-->
  <title>列挙型サポート関数</title>

  <para>
<!--
   For enum types (described in <xref linkend="datatype-enum">),
   there are several functions that allow cleaner programming without
   hard-coding particular values of an enum type.
   These are listed in <xref linkend="functions-enum-table">. The examples
   assume an enum type created as:
-->
列挙型（<xref linkend="datatype-enum">で解説）に対し、特に列挙型の値をハードコーディングせず簡潔なプログラミングを可能にするいくつかの関数があります。
それらの関数は<xref linkend="functions-enum-table">で一覧されています。
例は以下のようにして列挙型が作成されていることを想定しています。

<programlisting>
CREATE TYPE rainbow AS ENUM ('red', 'orange', 'yellow', 'green', 'blue', 'purple');
</programlisting>

  </para>

  <table id="functions-enum-table">
<!--
    <title>Enum Support Functions</title>
-->
    <title>列挙型サポート関数</title>
    <tgroup cols="4">
     <thead>
      <row>
<!--
       <entry>Function</entry>
       <entry>Description</entry>
       <entry>Example</entry>
       <entry>Example Result</entry>
-->
       <entry>関数</entry>
       <entry>説明</entry>
       <entry>例</entry>
       <entry>例の結果</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>
         <indexterm>
          <primary>enum_first</primary>
         </indexterm>
         <literal>enum_first(anyenum)</literal>
       </entry>
<!--
       <entry>Returns the first value of the input enum type</entry>
-->
       <entry>入力列挙型の最初の値を返す</entry>
       <entry><literal>enum_first(null::rainbow)</literal></entry>
       <entry><literal>red</literal></entry>
      </row>
      <row>
       <entry>
         <indexterm>
          <primary>enum_last</primary>
         </indexterm>
         <literal>enum_last(anyenum)</literal>
       </entry>
<!--
       <entry>Returns the last value of the input enum type</entry>
-->
       <entry>入力列挙型の最後の値を返す</entry>
       <entry><literal>enum_last(null::rainbow)</literal></entry>
       <entry><literal>purple</literal></entry>
      </row>
      <row>
       <entry>
         <indexterm>
          <primary>enum_range</primary>
         </indexterm>
         <literal>enum_range(anyenum)</literal>
       </entry>
<!--
       <entry>Returns all values of the input enum type in an ordered array</entry>
-->
       <entry>入力列挙型の全ての値を順序配列として返す</entry>
       <entry><literal>enum_range(null::rainbow)</literal></entry>
       <entry><literal>{red,orange,yellow,green,blue,purple}</literal></entry>
      </row>
      <row>
       <entry morerows="2"><literal>enum_range(anyenum, anyenum)</literal></entry>
       <entry morerows="2">
<!--
        Returns the range between the two given enum values, as an ordered
        array. The values must be from the same enum type. If the first
        parameter is null, the result will start with the first value of
        the enum type.
        If the second parameter is null, the result will end with the last
        value of the enum type.
-->
与えられた２つの列挙型値の範囲を、順序配列として返す。
値は同一の列挙型に拠らなければならない。
１番目のパラメータがNULLの場合、結果は列挙型の最初の値から始まる。
２番目のパラメータがNULLの場合、結果は列挙型の最後の値で終わる。
       </entry>
       <entry><literal>enum_range('orange'::rainbow, 'green'::rainbow)</literal></entry>
       <entry><literal>{orange,yellow,green}</literal></entry>
      </row>
      <row>
       <entry><literal>enum_range(NULL, 'green'::rainbow)</literal></entry>
       <entry><literal>{red,orange,yellow,green}</literal></entry>
      </row>
      <row>
       <entry><literal>enum_range('orange'::rainbow, NULL)</literal></entry>
       <entry><literal>{orange,yellow,green,blue,purple}</literal></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
<!--
    Notice that except for the two-argument form of <function>enum_range</>,
    these functions disregard the specific value passed to them; they care
    only about its declared data type.  Either null or a specific value of
    the type can be passed, with the same result.  It is more common to
    apply these functions to a table column or function argument than to
    a hardwired type name as suggested by the examples.
-->
<function>enum_range</>の２引数の形式を除き、これらの関数は、渡された特定の値を無視することに注意してください。関数は宣言されたデータ型のみ配慮します。
その型のNULLまたは特定の値を渡すことができ、同一の結果が得られます。
例で示したような直書きした型名に対してではなく、テーブル列もしくは関数引数にこれらの関数を適用することがより一般的です。
   </para>
 </sect1>

 <sect1 id="functions-geometry">
<!--
  <title>Geometric Functions and Operators</title>
-->
  <title>幾何関数と演算子</title>

   <para>
<!--
    The geometric types <type>point</type>, <type>box</type>,
    <type>lseg</type>, <type>line</type>, <type>path</type>,
    <type>polygon</type>, and <type>circle</type> have a large set of
    native support functions and operators, shown in <xref
    linkend="functions-geometry-op-table">, <xref
    linkend="functions-geometry-func-table">, and <xref
    linkend="functions-geometry-conv-table">.
-->
<type>point</type>、<type>box</type>、<type>lseg</type>、<type>line</type>、<type>path</type>、<type>polygon</type>、および<type>circle</type>幾何データ型には、PostgreSQLが元々サポートしている関数と演算子が豊富に揃っています（<xref linkend="functions-geometry-op-table">、<xref linkend="functions-geometry-func-table">、および<xref linkend="functions-geometry-conv-table">を参照してください）。
   </para>

   <caution>
    <para>
<!--
     Note that the <quote>same as</> operator, <literal>~=</>, represents
     the usual notion of equality for the <type>point</type>,
     <type>box</type>, <type>polygon</type>, and <type>circle</type> types.
     Some of these types also have an <literal>=</> operator, but
     <literal>=</> compares
     for equal <emphasis>areas</> only.  The other scalar comparison operators
     (<literal>&lt;=</> and so on) likewise compare areas for these types.
-->
<quote>同じを示す</><literal>~=</>演算子は<type>point</type>、<type>box</type>、<type>polygon</type>、および<type>circle</type>型に対し通常の等価概念を示すことに注意してください。これらのいくつかの型は<literal>=</>演算子を持ちますが、<literal>=</>は<emphasis>面積</>の等しさのみを比較します。その他のスカラー比較演算子（<literal>&lt;=</>など）は同様にこれらの型の面積を比較します。
    </para>
   </caution>

   <table id="functions-geometry-op-table">
<!--
     <title>Geometric Operators</title>
-->
     <title>幾何データ演算子</title>
     <tgroup cols="3">
      <thead>
       <row>
<!--
        <entry>Operator</entry>
        <entry>Description</entry>
        <entry>Example</entry>
-->
        <entry>演算子</entry>
        <entry>説明</entry>
        <entry>例</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry> <literal>+</literal> </entry>
<!--
        <entry>Translation</entry>
-->
        <entry>平行移動</entry>
        <entry><literal>box '((0,0),(1,1))' + point '(2.0,0)'</literal></entry>
       </row>
       <row>
        <entry> <literal>-</literal> </entry>
<!--
        <entry>Translation</entry>
-->
        <entry>平行移動</entry>
        <entry><literal>box '((0,0),(1,1))' - point '(2.0,0)'</literal></entry>
       </row>
       <row>
        <entry> <literal>*</literal> </entry>
<!--
        <entry>Scaling/rotation</entry>
-->
        <entry>拡大縮小/回転</entry>
        <entry><literal>box '((0,0),(1,1))' * point '(2.0,0)'</literal></entry>
       </row>
       <row>
        <entry> <literal>/</literal> </entry>
<!--
        <entry>Scaling/rotation</entry>
-->
        <entry>拡大縮小/回転</entry>
        <entry><literal>box '((0,0),(2,2))' / point '(2.0,0)'</literal></entry>
       </row>
       <row>
        <entry> <literal>#</literal> </entry>
<!--
        <entry>Point or box of intersection</entry>
-->
        <entry>交差点、交差矩形</entry>
        <entry><literal>'((1,-1),(-1,1))' # '((1,1),(-1,-1))'</literal></entry>
       </row>
       <row>
        <entry> <literal>#</literal> </entry>
<!--
        <entry>Number of points in path or polygon</entry>
-->
        <entry>経路もしくは多角形の点の数</entry>
        <entry><literal># '((1,0),(0,1),(-1,0))'</literal></entry>
       </row>
       <row>
        <entry> <literal>@-@</literal> </entry>
<!--
        <entry>Length or circumference</entry>
-->
        <entry>長さもしくは円周</entry>
        <entry><literal>@-@ path '((0,0),(1,0))'</literal></entry>
       </row>
       <row>
        <entry> <literal>@@</literal> </entry>
<!--
        <entry>Center</entry>
-->
        <entry>中心</entry>
        <entry><literal>@@ circle '((0,0),10)'</literal></entry>
       </row>
       <row>
        <entry> <literal>##</literal> </entry>
<!--
        <entry>Closest point to first operand on second operand</entry>
-->
        <entry>第2オペランド上の第1オペランドへの近接点</entry>
        <entry><literal>point '(0,0)' ## lseg '((2,0),(0,2))'</literal></entry>
       </row>
       <row>
        <entry> <literal>&lt;-&gt;</literal> </entry>
<!--
        <entry>Distance between</entry>
-->
        <entry>距離</entry>
        <entry><literal>circle '((0,0),1)' &lt;-&gt; circle '((5,0),1)'</literal></entry>
       </row>
       <row>
        <entry> <literal>&amp;&amp;</literal> </entry>
<!--
        <entry>Overlaps?  (One point in common makes this true.)</entry>
-->
        <entry>重なっているかどうか？(一つでも共通する点があれば真となります)</entry>
        <entry><literal>box '((0,0),(1,1))' &amp;&amp; box '((0,0),(2,2))'</literal></entry>
       </row>
       <row>
        <entry> <literal>&lt;&lt;</literal> </entry>
<!--
        <entry>Is strictly left of?</entry>
-->
        <entry>厳密に左側にあるか？</entry>
        <entry><literal>circle '((0,0),1)' &lt;&lt; circle '((5,0),1)'</literal></entry>
       </row>
       <row>
        <entry> <literal>&gt;&gt;</literal> </entry>
<!--
        <entry>Is strictly right of?</entry>
-->
        <entry>厳密に右側にあるか？</entry>
        <entry><literal>circle '((5,0),1)' &gt;&gt; circle '((0,0),1)'</literal></entry>
       </row>
       <row>
        <entry> <literal>&amp;&lt;</literal> </entry>
<!--
        <entry>Does not extend to the right of?</entry>
-->
        <entry>右側にはみ出さないか？</entry>
        <entry><literal>box '((0,0),(1,1))' &amp;&lt; box '((0,0),(2,2))'</literal></entry>
       </row>
       <row>
        <entry> <literal>&amp;&gt;</literal> </entry>
<!--
        <entry>Does not extend to the left of?</entry>
-->
        <entry>左側にはみ出さないか？</entry>
        <entry><literal>box '((0,0),(3,3))' &amp;&gt; box '((0,0),(2,2))'</literal></entry>
       </row>
       <row>
        <entry> <literal>&lt;&lt;|</literal> </entry>
<!--
        <entry>Is strictly below?</entry>
-->
        <entry>厳密に下側にあるか？</entry>
        <entry><literal>box '((0,0),(3,3))' &lt;&lt;| box '((3,4),(5,5))'</literal></entry>
       </row>
       <row>
        <entry> <literal>|&gt;&gt;</literal> </entry>
<!--
        <entry>Is strictly above?</entry>
-->
        <entry>厳密に上側にあるか？</entry>
        <entry><literal>box '((3,4),(5,5))' |&gt;&gt; box '((0,0),(3,3))'</literal></entry>
       </row>
       <row>
        <entry> <literal>&amp;&lt;|</literal> </entry>
<!--
        <entry>Does not extend above?</entry>
-->
        <entry>上側に出ていないか？</entry>
        <entry><literal>box '((0,0),(1,1))' &amp;&lt;| box '((0,0),(2,2))'</literal></entry>
       </row>
       <row>
        <entry> <literal>|&amp;&gt;</literal> </entry>
<!--
        <entry>Does not extend below?</entry>
-->
        <entry>下側に出ていないか？</entry>
        <entry><literal>box '((0,0),(3,3))' |&amp;&gt; box '((0,0),(2,2))'</literal></entry>
       </row>
       <row>
        <entry> <literal>&lt;^</literal> </entry>
<!--
        <entry>Is below (allows touching)?</entry>
-->
        <entry>（接触を許可し）下側にあるか？</entry>
        <entry><literal>circle '((0,0),1)' &lt;^ circle '((0,5),1)'</literal></entry>
       </row>
       <row>
        <entry> <literal>&gt;^</literal> </entry>
<!--
        <entry>Is above (allows touching)?</entry>
-->
        <entry>（接触を許可し）上側にあるか？</entry>
        <entry><literal>circle '((0,5),1)' &gt;^ circle '((0,0),1)'</literal></entry>
       </row>
       <row>
        <entry> <literal>?#</literal> </entry>
<!--
        <entry>Intersects?</entry>
-->
        <entry>交わるか？</entry>
        <entry><literal>lseg '((-1,0),(1,0))' ?# box '((-2,-2),(2,2))'</literal></entry>
       </row>
       <row>
        <entry> <literal>?-</literal> </entry>
<!--
        <entry>Is horizontal?</entry>
-->
        <entry>水平か？</entry>
        <entry><literal>?- lseg '((-1,0),(1,0))'</literal></entry>
       </row>
       <row>
        <entry> <literal>?-</literal> </entry>
<!--
        <entry>Are horizontally aligned?</entry>
-->
        <entry>水平方向に揃っているか？</entry>
        <entry><literal>point '(1,0)' ?- point '(0,0)'</literal></entry>
       </row>
       <row>
        <entry> <literal>?|</literal> </entry>
<!--
        <entry>Is vertical?</entry>
-->
        <entry>垂直か？</entry>
        <entry><literal>?| lseg '((-1,0),(1,0))'</literal></entry>
       </row>
       <row>
        <entry> <literal>?|</literal> </entry>
<!--
        <entry>Are vertically aligned?</entry>
-->
        <entry>垂直方向に揃っているか？</entry>
        <entry><literal>point '(0,1)' ?| point '(0,0)'</literal></entry>
       </row>
       <row>
        <entry> <literal>?-|</literal> </entry>
<!--
        <entry>Is perpendicular?</entry>
-->
        <entry>直角をなしているか？</entry>
        <entry><literal>lseg '((0,0),(0,1))' ?-| lseg '((0,0),(1,0))'</literal></entry>
       </row>
       <row>
        <entry> <literal>?||</literal> </entry>
<!--
        <entry>Are parallel?</entry>
-->
        <entry>平行か？</entry>
        <entry><literal>lseg '((-1,0),(1,0))' ?|| lseg '((-1,2),(1,2))'</literal></entry>
       </row>
       <row>
        <entry> <literal>@&gt;</literal> </entry>
<!--
        <entry>Contains?</entry>
-->
        <entry>包含しているか？</entry>
        <entry><literal>circle '((0,0),2)' @&gt; point '(1,1)'</literal></entry>
       </row>
       <row>
        <entry> <literal>&lt;@</literal> </entry>
<!--
        <entry>Contained in or on?</entry>
-->
        <entry>包含されているかもしくは境界上か？</entry>
        <entry><literal>point '(1,1)' &lt;@ circle '((0,0),2)'</literal></entry>
       </row>
       <row>
        <entry> <literal>~=</literal> </entry>
<!--
        <entry>Same as?</entry>
-->
        <entry>同等か？</entry>
        <entry><literal>polygon '((0,0),(1,1))' ~= polygon '((1,1),(0,0))'</literal></entry>
       </row>
      </tbody>
     </tgroup>
   </table>

   <note>
    <para>
<!--
     Before <productname>PostgreSQL</productname> 8.2, the containment
     operators <literal>@&gt;</> and <literal>&lt;@</> were respectively
     called <literal>~</> and <literal>@</>.  These names are still
     available, but are deprecated and will eventually be removed.
-->
<productname>PostgreSQL</productname>の8.2より前では、包含演算子<literal>@&gt;</>および<literal>&lt;@</>はそれぞれ<literal>~</>および<literal>@</>という名前でした。
これらの名前はまだ利用できますが、削除予定であり最終的にはなくなるでしょう。
    </para>
   </note>

   <indexterm>
    <primary>area</primary>
   </indexterm>
   <indexterm>
    <primary>center</primary>
   </indexterm>
   <indexterm>
    <primary>diameter</primary>
   </indexterm>
   <indexterm>
    <primary>height</primary>
   </indexterm>
   <indexterm>
    <primary>isclosed</primary>
   </indexterm>
   <indexterm>
    <primary>isopen</primary>
   </indexterm>
   <indexterm>
    <primary>length</primary>
   </indexterm>
   <indexterm>
    <primary>npoints</primary>
   </indexterm>
   <indexterm>
    <primary>pclose</primary>
   </indexterm>
   <indexterm>
    <primary>popen</primary>
   </indexterm>
   <indexterm>
    <primary>radius</primary>
   </indexterm>
   <indexterm>
    <primary>width</primary>
   </indexterm>

   <table id="functions-geometry-func-table">
<!--
     <title>Geometric Functions</title>
-->
     <title>幾何データ型関数</title>
     <tgroup cols="4">
      <thead>
       <row>
<!--
        <entry>Function</entry>
        <entry>Return Type</entry>
        <entry>Description</entry>
        <entry>Example</entry>
-->
        <entry>関数</entry>
        <entry>戻り値</entry>
        <entry>説明</entry>
        <entry>例</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><literal><function>area(<replaceable>object</>)</function></literal></entry>
        <entry><type>double precision</type></entry>
<!--
        <entry>area</entry>
-->
        <entry>面積</entry>
        <entry><literal>area(box '((0,0),(1,1))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>center(<replaceable>object</>)</function></literal></entry>
        <entry><type>point</type></entry>
<!--
        <entry>center</entry>
-->
        <entry>中心</entry>
        <entry><literal>center(box '((0,0),(1,2))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>diameter(<type>circle</>)</function></literal></entry>
        <entry><type>double precision</type></entry>
<!--
        <entry>diameter of circle</entry>
-->
        <entry>円の直径</entry>
        <entry><literal>diameter(circle '((0,0),2.0)')</literal></entry>
       </row>
       <row>
        <entry><literal><function>height(<type>box</>)</function></literal></entry>
        <entry><type>double precision</type></entry>
<!--
        <entry>vertical size of box</entry>
-->
        <entry>矩形の高さ</entry>
        <entry><literal>height(box '((0,0),(1,1))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>isclosed(<type>path</>)</function></literal></entry>
        <entry><type>boolean</type></entry>
<!--
        <entry>a closed path?</entry>
-->
        <entry>閉経路か？</entry>
        <entry><literal>isclosed(path '((0,0),(1,1),(2,0))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>isopen(<type>path</>)</function></literal></entry>
        <entry><type>boolean</type></entry>
<!--
        <entry>an open path?</entry>
-->
        <entry>開経路か？</entry>
        <entry><literal>isopen(path '[(0,0),(1,1),(2,0)]')</literal></entry>
       </row>
       <row>
        <entry><literal><function>length(<replaceable>object</>)</function></literal></entry>
        <entry><type>double precision</type></entry>
<!--
        <entry>length</entry>
-->
        <entry>長さ</entry>
        <entry><literal>length(path '((-1,0),(1,0))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>npoints(<type>path</>)</function></literal></entry>
        <entry><type>int</type></entry>
<!--
        <entry>number of points</entry>
-->
        <entry>点の数</entry>
        <entry><literal>npoints(path '[(0,0),(1,1),(2,0)]')</literal></entry>
       </row>
       <row>
        <entry><literal><function>npoints(<type>polygon</>)</function></literal></entry>
        <entry><type>int</type></entry>
<!--
        <entry>number of points</entry>
-->
        <entry>点の数</entry>
        <entry><literal>npoints(polygon '((1,1),(0,0))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>pclose(<type>path</>)</function></literal></entry>
        <entry><type>path</type></entry>
<!--
        <entry>convert path to closed</entry>
-->
        <entry>閉経路に変換</entry>
        <entry><literal>pclose(path '[(0,0),(1,1),(2,0)]')</literal></entry>
       </row>
<![IGNORE[
<!-- Not defined by this name. Implements the intersection operator '#' -->
       <row>
        <entry><literal><function>point(<type>lseg</>, <type>lseg</>)</function></literal></entry>
        <entry><type>point</type></entry>
<!--
        <entry>intersection</entry>
-->
        <entry>交点</entry>
        <entry><literal>point(lseg '((-1,0),(1,0))',lseg '((-2,-2),(2,2))')</literal></entry>
       </row>
]]>
       <row>
        <entry><literal><function>popen(<type>path</>)</function></literal></entry>
        <entry><type>path</type></entry>
<!--
        <entry>convert path to open</entry>
-->
        <entry>開経路に変換</entry>
        <entry><literal>popen(path '((0,0),(1,1),(2,0))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>radius(<type>circle</type>)</function></literal></entry>
        <entry><type>double precision</type></entry>
<!--
        <entry>radius of circle</entry>
-->
        <entry>円の半径</entry>
        <entry><literal>radius(circle '((0,0),2.0)')</literal></entry>
       </row>
       <row>
        <entry><literal><function>width(<type>box</>)</function></literal></entry>
        <entry><type>double precision</type></entry>
<!--
        <entry>horizontal size of box</entry>
-->
        <entry>矩形の幅</entry>
        <entry><literal>width(box '((0,0),(1,1))')</literal></entry>
       </row>
      </tbody>
     </tgroup>
   </table>

   <table id="functions-geometry-conv-table">
<!--
     <title>Geometric Type Conversion Functions</title>
-->
     <title>幾何型変換関数</title>
     <tgroup cols="4">
      <thead>
       <row>
<!--
        <entry>Function</entry>
        <entry>Return Type</entry>
        <entry>Description</entry>
        <entry>Example</entry>
-->
        <entry>関数</entry>
        <entry>戻り値</entry>
        <entry>説明</entry>
        <entry>例</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>
         <indexterm>
          <primary>box</primary>
         </indexterm>
         <literal><function>box(<type>circle</type>)</function></literal>
        </entry>
        <entry><type>box</type></entry>
<!--
        <entry>circle to box</entry>
-->
        <entry>円を矩形に変換</entry>
        <entry><literal>box(circle '((0,0),2.0)')</literal></entry>
       </row>
       <row>
        <entry><literal><function>box(<type>point</type>)</function></literal></entry>
        <entry><type>box</type></entry>
<!--
        <entry>point to empty box</entry>
-->
        <entry>点を空の矩形に変換</entry>
        <entry><literal>box(point '(0,0)')</literal></entry>
       </row>
       <row>
        <entry><literal><function>box(<type>point</type>, <type>point</type>)</function></literal></entry>
        <entry><type>box</type></entry>
<!--
        <entry>points to box</entry>
-->
        <entry>座標点を矩形に変換</entry>
        <entry><literal>box(point '(0,0)', point '(1,1)')</literal></entry>
       </row>
       <row>
        <entry><literal><function>box(<type>polygon</type>)</function></literal></entry>
        <entry><type>box</type></entry>
<!--
        <entry>polygon to box</entry>
-->
        <entry>多角形を矩形に変換</entry>
        <entry><literal>box(polygon '((0,0),(1,1),(2,0))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>bound_box(<type>box</type>, <type>box</type>)</function></literal></entry>
        <entry><type>box</type></entry>
<!--
        <entry>boxes to bounding box</entry>
-->
        <entry>矩形を外接矩形に変換</entry>
        <entry><literal>bound_box(box '((0,0),(1,1))', box '((3,3),(4,4))')</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>circle</primary>
         </indexterm>
         <literal><function>circle(<type>box</type>)</function></literal>
        </entry>
        <entry><type>circle</type></entry>
<!--
        <entry>box to circle</entry>
-->
        <entry>矩形を円に変換</entry>
        <entry><literal>circle(box '((0,0),(1,1))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>circle(<type>point</type>, <type>double precision</type>)</function></literal></entry>
        <entry><type>circle</type></entry>
<!--
        <entry>center and radius to circle</entry>
-->
        <entry>中心と半径から円に変換</entry>
        <entry><literal>circle(point '(0,0)', 2.0)</literal></entry>
       </row>
       <row>
        <entry><literal><function>circle(<type>polygon</type>)</function></literal></entry>
        <entry><type>circle</type></entry>
<!--
        <entry>polygon to circle</entry>
-->
        <entry>多角形を円に変換</entry>
        <entry><literal>circle(polygon '((0,0),(1,1),(2,0))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>line(<type>point</type>, <type>point</type>)</function></literal></entry>
        <entry><type>line</type></entry>
<!--
        <entry>points to line</entry>
-->
        <entry>座標点を直線に変換</entry>
        <entry><literal>line(point '(-1,0)', point '(1,0)')</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>lseg</primary>
         </indexterm>
         <literal><function>lseg(<type>box</type>)</function></literal>
        </entry>
        <entry><type>lseg</type></entry>
<!--
        <entry>box diagonal to line segment</entry>
-->
        <entry>矩形の対角線を線分に変換</entry>
        <entry><literal>lseg(box '((-1,0),(1,0))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>lseg(<type>point</type>, <type>point</type>)</function></literal></entry>
        <entry><type>lseg</type></entry>
<!--
        <entry>points to line segment</entry>
-->
        <entry>座標点を線分に変換</entry>
        <entry><literal>lseg(point '(-1,0)', point '(1,0)')</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>path</primary>
         </indexterm>
         <literal><function>path(<type>polygon</type>)</function></literal>
        </entry>
        <entry><type>path</type></entry>
<!--
        <entry>polygon to path</entry>
-->
        <entry>多角形を経路に変換</entry>
        <entry><literal>path(polygon '((0,0),(1,1),(2,0))')</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>point</primary>
         </indexterm>
         <literal><function>point</function>(<type>double
         precision</type>, <type>double precision</type>)</literal>
        </entry>
        <entry><type>point</type></entry>
<!--
        <entry>construct point</entry>
-->
        <entry>座標点の構築</entry>
        <entry><literal>point(23.4, -44.5)</literal></entry>
       </row>
       <row>
        <entry><literal><function>point(<type>box</type>)</function></literal></entry>
        <entry><type>point</type></entry>
<!--
        <entry>center of box</entry>
-->
        <entry>矩形の中心</entry>
        <entry><literal>point(box '((-1,0),(1,0))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>point(<type>circle</type>)</function></literal></entry>
        <entry><type>point</type></entry>
<!--
        <entry>center of circle</entry>
-->
        <entry>円の中心</entry>
        <entry><literal>point(circle '((0,0),2.0)')</literal></entry>
       </row>
       <row>
        <entry><literal><function>point(<type>lseg</type>)</function></literal></entry>
        <entry><type>point</type></entry>
<!--
        <entry>center of line segment</entry>
-->
        <entry>線分の中心</entry>
        <entry><literal>point(lseg '((-1,0),(1,0))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>point(<type>polygon</type>)</function></literal></entry>
        <entry><type>point</type></entry>
<!--
        <entry>center of polygon</entry>
-->
        <entry>多角形の中心</entry>
        <entry><literal>point(polygon '((0,0),(1,1),(2,0))')</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>polygon</primary>
         </indexterm>
         <literal><function>polygon(<type>box</type>)</function></literal>
        </entry>
        <entry><type>polygon</type></entry>
<!--
        <entry>box to 4-point polygon</entry>
-->
        <entry>矩形を4頂点の多角形に変換</entry>
        <entry><literal>polygon(box '((0,0),(1,1))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>polygon(<type>circle</type>)</function></literal></entry>
        <entry><type>polygon</type></entry>
<!--
        <entry>circle to 12-point polygon</entry>
-->
        <entry>円を12角形に変換</entry>
        <entry><literal>polygon(circle '((0,0),2.0)')</literal></entry>
       </row>
       <row>
        <entry><literal><function>polygon(<replaceable class="parameter">npts</replaceable>, <type>circle</type>)</function></literal></entry>
        <entry><type>polygon</type></entry>
<!--
        <entry>circle to <replaceable class="parameter">npts</replaceable>-point polygon</entry>
-->
        <entry>円を<replaceable class="parameter">npts</replaceable>角形に変換</entry>
        <entry><literal>polygon(12, circle '((0,0),2.0)')</literal></entry>
       </row>
       <row>
        <entry><literal><function>polygon(<type>path</type>)</function></literal></entry>
        <entry><type>polygon</type></entry>
<!--
        <entry>path to polygon</entry>
-->
        <entry>経路を多角形に変換</entry>
        <entry><literal>polygon(path '((0,0),(1,1),(2,0))')</literal></entry>
       </row>
      </tbody>
     </tgroup>
   </table>

    <para>
<!--
     It is possible to access the two component numbers of a <type>point</>
     as though the point were an array with indexes 0 and 1.  For example, if
     <literal>t.p</> is a <type>point</> column then
     <literal>SELECT p[0] FROM t</> retrieves the X coordinate and
     <literal>UPDATE t SET p[1] = ...</> changes the Y coordinate.
     In the same way, a value of type <type>box</> or <type>lseg</> can be treated
     as an array of two <type>point</> values.
-->
あたかもpointは添字0、1を有する配列であるかのように、<type>point</>の２つの構成要素にアクセスすることができます。
例えば、<literal>t.p</>が<type>point</>列の場合、<literal>SELECT p[0] FROM t</>という式でX座標を抽出できます。また、<literal>UPDATE t SET p[1] = ...</>でY座標を変更できます。
同様に、<type>box</>型または<type>lseg</>型の値も、2つの<type>point</>型の値の配列のように扱えます。
    </para>

    <para>
<!--
     The <function>area</function> function works for the types
     <type>box</type>, <type>circle</type>, and <type>path</type>.
     The <function>area</function> function only works on the
     <type>path</type> data type if the points in the
     <type>path</type> are non-intersecting.  For example, the
     <type>path</type>
     <literal>'((0,0),(0,1),(2,1),(2,2),(1,2),(1,0),(0,0))'::PATH</literal>
     will not work;  however, the following visually identical
     <type>path</type>
     <literal>'((0,0),(0,1),(1,1),(1,2),(2,2),(2,1),(1,1),(1,0),(0,0))'::PATH</literal>
     will work.  If the concept of an intersecting versus
     non-intersecting <type>path</type> is confusing, draw both of the
     above <type>path</type>s side by side on a piece of graph paper.
-->
<function>area</function>関数は、<type>box</type>、<type>circle</type>、<type>path</type>型に対して動作します。
<type>path</type>データ型に対する<function>area</function>関数は、その<type>path</type>が交差しない場合にのみ動作します。
例えば、<literal>'((0,0),(0,1),(2,1),(2,2),(1,2),(1,0),(0,0))'::PATH</literal>という<type>path</type>は動作しません。しかし、見た目は同じですが、<literal>'((0,0),(0,1),(1,1),(1,2),(2,2),(2,1),(1,1),(1,0),(0,0))'::PATH</literal>という<type>path</type>では動作します。
<type>path</type>の交差する、しないという概念がよくわからなければ、上の2つの<type>path</type>を並べてグラフ用紙に書いてみてください。
    </para>

  </sect1>


 <sect1 id="functions-net">
<!--
  <title>Network Address Functions and Operators</title>
-->
  <title>ネットワークアドレス関数と演算子</title>

  <para>
<!--
   <xref linkend="cidr-inet-operators-table"> shows the operators
   available for the <type>cidr</type> and <type>inet</type> types.
   The operators <literal>&lt;&lt;</literal>,
   <literal>&lt;&lt;=</literal>, <literal>&gt;&gt;</literal>,
   <literal>&gt;&gt;=</literal>, and <literal>&amp;&amp;</literal>
   test for subnet inclusion.  They
   consider only the network parts of the two addresses (ignoring any
   host part) and determine whether one network is identical to
   or a subnet of the other.
-->
<xref linkend="cidr-inet-operators-table">に、<type>inet</type>型および<type>cidr</type>型で使用可能な演算子を示します。
演算子 <literal>&lt;&lt;</literal>、<literal>&lt;&lt;=</literal>、<literal>&gt;&gt;</literal>、<literal>&gt;&gt;=</literal>および<literal>&amp;&amp;</literal>はサブネットの包含関係を調べるものです。
これらは2つのアドレスのネットワークの部分のみを考慮（ホスト部分を無視）して2つのネットワークアドレスが等しいか、もしくは一方のネットワークが他方のサブネットになっているかを特定します。
  </para>

    <table id="cidr-inet-operators-table">
<!--
     <title><type>cidr</type> and <type>inet</type> Operators</title>
-->
     <title><type>cidr</type>と<type>inet</type>演算子</title>
     <tgroup cols="3">
      <thead>
       <row>
<!--
        <entry>Operator</entry>
        <entry>Description</entry>
        <entry>Example</entry>
-->
        <entry>演算子</entry>
        <entry>説明</entry>
        <entry>例</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry> <literal>&lt;</literal> </entry>
<!--
        <entry>is less than</entry>
-->
        <entry>未満</entry>
        <entry><literal>inet '192.168.1.5' &lt; inet '192.168.1.6'</literal></entry>
       </row>
       <row>
        <entry> <literal>&lt;=</literal> </entry>
<!--
        <entry>is less than or equal</entry>
-->
        <entry>未満もしくは等しい（以下）</entry>
        <entry><literal>inet '192.168.1.5' &lt;= inet '192.168.1.5'</literal></entry>
       </row>
       <row>
        <entry> <literal>=</literal> </entry>
<!--
        <entry>equals</entry>
-->
        <entry>等しい</entry>
        <entry><literal>inet '192.168.1.5' = inet '192.168.1.5'</literal></entry>
       </row>
       <row>
        <entry> <literal>&gt;=</literal> </entry>
<!--
        <entry>is greater or equal</entry>
-->
        <entry>より大きいもしくは等しい（以上）</entry>
        <entry><literal>inet '192.168.1.5' &gt;= inet '192.168.1.5'</literal></entry>
       </row>
       <row>
        <entry> <literal>&gt;</literal> </entry>
<!--
        <entry>is greater than</entry>
-->
        <entry>より大きい</entry>
        <entry><literal>inet '192.168.1.5' &gt; inet '192.168.1.4'</literal></entry>
       </row>
       <row>
        <entry> <literal>&lt;&gt;</literal> </entry>
<!--
        <entry>is not equal</entry>
-->
        <entry>等しくない</entry>
        <entry><literal>inet '192.168.1.5' &lt;&gt; inet '192.168.1.4'</literal></entry>
       </row>
       <row>
        <entry> <literal>&lt;&lt;</literal> </entry>
<!--
        <entry>is contained by</entry>
-->
        <entry>内包される</entry>
        <entry><literal>inet '192.168.1.5' &lt;&lt; inet '192.168.1/24'</literal></entry>
       </row>
       <row>
        <entry> <literal>&lt;&lt;=</literal> </entry>
<!--
        <entry>is contained by or equals</entry>
-->
        <entry>内包されるか等しい</entry>
        <entry><literal>inet '192.168.1/24' &lt;&lt;= inet '192.168.1/24'</literal></entry>
       </row>
       <row>
        <entry> <literal>&gt;&gt;</literal> </entry>
<!--
        <entry>contains</entry>
-->
        <entry>内包する</entry>
        <entry><literal>inet '192.168.1/24' &gt;&gt; inet '192.168.1.5'</literal></entry>
       </row>
       <row>
        <entry> <literal>&gt;&gt;=</literal> </entry>
<!--
        <entry>contains or equals</entry>
-->
        <entry>内包するか等しい</entry>
        <entry><literal>inet '192.168.1/24' &gt;&gt;= inet '192.168.1/24'</literal></entry>
       </row>
       <row>
        <entry> <literal>&amp;&amp;</literal> </entry>
<!--
        <entry>contains or is contained by</entry>
-->
        <entry>内包するか内包されるか</entry>
        <entry><literal>inet '192.168.1/24' &amp;&amp; inet '192.168.1.80/28'</literal></entry>
       </row>
       <row>
        <entry> <literal>~</literal> </entry>
<!--
        <entry>bitwise NOT</entry>
-->
        <entry>ビット否定</entry>
        <entry><literal>~ inet '192.168.1.6'</literal></entry>
       </row>
       <row>
        <entry> <literal>&amp;</literal> </entry>
<!--
        <entry>bitwise AND</entry>
-->
        <entry>ビット積</entry>
        <entry><literal>inet '192.168.1.6' &amp; inet '0.0.0.255'</literal></entry>
       </row>
       <row>
        <entry> <literal>|</literal> </entry>
<!--
        <entry>bitwise OR</entry>
-->
        <entry>ビット和</entry>
        <entry><literal>inet '192.168.1.6' | inet '0.0.0.255'</literal></entry>
       </row>
       <row>
        <entry> <literal>+</literal> </entry>
<!--
        <entry>addition</entry>
-->
        <entry>加算</entry>
        <entry><literal>inet '192.168.1.6' + 25</literal></entry>
       </row>
       <row>
        <entry> <literal>-</literal> </entry>
<!--
        <entry>subtraction</entry>
-->
        <entry>減算</entry>
        <entry><literal>inet '192.168.1.43' - 36</literal></entry>
       </row>
       <row>
        <entry> <literal>-</literal> </entry>
<!--
        <entry>subtraction</entry>
-->
        <entry>減算</entry>
        <entry><literal>inet '192.168.1.43' - inet '192.168.1.19'</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

  <para>
<!--
   <xref linkend="cidr-inet-functions-table"> shows the functions
   available for use with the <type>cidr</type> and <type>inet</type>
   types.  The <function>abbrev</function>, <function>host</function>,
   and <function>text</function>
   functions are primarily intended to offer alternative display
   formats.
-->
<xref linkend="cidr-inet-functions-table">に、<type>inet</type>型および<type>cidr</type>型で使用可能な関数を示します。
関数<function>abbrev</function>、<function>host</function>、および<function>text</function>、は主として、代替の整形表示を提供する目的のものです。
  </para>

    <table id="cidr-inet-functions-table">
<!--
     <title><type>cidr</type> and <type>inet</type> Functions</title>
-->
     <title><type>cidr</type>および<type>inet</type>型関数</title>
     <tgroup cols="5">
      <thead>
       <row>
<!--
        <entry>Function</entry>
        <entry>Return Type</entry>
        <entry>Description</entry>
        <entry>Example</entry>
        <entry>Result</entry>
-->
        <entry>関数</entry>
        <entry>戻り値</entry>
        <entry>説明</entry>
        <entry>例</entry>
        <entry>結果</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>
         <indexterm>
          <primary>abbrev</primary>
         </indexterm>
         <literal><function>abbrev(<type>inet</type>)</function></literal>
        </entry>
        <entry><type>text</type></entry>
<!--
        <entry>abbreviated display format as text</entry>
-->
        <entry>表示用テキスト省略形</entry>
        <entry><literal>abbrev(inet '10.1.0.0/16')</literal></entry>
        <entry><literal>10.1.0.0/16</literal></entry>
       </row>
       <row>
        <entry><literal><function>abbrev(<type>cidr</type>)</function></literal></entry>
        <entry><type>text</type></entry>
<!--
        <entry>abbreviated display format as text</entry>
-->
        <entry>表示用テキスト省略形</entry>
        <entry><literal>abbrev(cidr '10.1.0.0/16')</literal></entry>
        <entry><literal>10.1/16</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>broadcast</primary>
         </indexterm>
         <literal><function>broadcast(<type>inet</type>)</function></literal>
        </entry>
        <entry><type>inet</type></entry>
<!--
        <entry>broadcast address for network</entry>
-->
        <entry>ネットワークブロードキャストアドレス</entry>
        <entry><literal>broadcast('192.168.1.5/24')</literal></entry>
        <entry><literal>192.168.1.255/24</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>family</primary>
         </indexterm>
         <literal><function>family(<type>inet</type>)</function></literal>
        </entry>
        <entry><type>int</type></entry>
<!--
        <entry>extract family of address; <literal>4</literal> for IPv4,
         <literal>6</literal> for IPv6</entry>
-->
         <entry>アドレスファミリの取り出し。IPv4では<literal>4</literal>、IPv6では<literal>6</literal>。</entry>
        <entry><literal>family('::1')</literal></entry>
        <entry><literal>6</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>host</primary>
         </indexterm>
         <literal><function>host(<type>inet</type>)</function></literal>
        </entry>
        <entry><type>text</type></entry>
<!--
        <entry>extract IP address as text</entry>
-->
        <entry>IPアドレスをテキストで抽出</entry>
        <entry><literal>host('192.168.1.5/24')</literal></entry>
        <entry><literal>192.168.1.5</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>hostmask</primary>
         </indexterm>
         <literal><function>hostmask(<type>inet</type>)</function></literal>
        </entry>
        <entry><type>inet</type></entry>
<!--
        <entry>construct host mask for network</entry>
-->
        <entry>ネットワーク用のホストマスクの構築</entry>
        <entry><literal>hostmask('192.168.23.20/30')</literal></entry>
        <entry><literal>0.0.0.3</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>masklen</primary>
         </indexterm>
         <literal><function>masklen(<type>inet</type>)</function></literal>
        </entry>
        <entry><type>int</type></entry>
<!--
        <entry>extract netmask length</entry>
-->
        <entry>ネットマスク長の抽出</entry>
        <entry><literal>masklen('192.168.1.5/24')</literal></entry>
        <entry><literal>24</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>netmask</primary>
         </indexterm>
         <literal><function>netmask(<type>inet</type>)</function></literal>
        </entry>
        <entry><type>inet</type></entry>
<!--
        <entry>construct netmask for network</entry>
-->
        <entry>ネットワーク用ネットマスクの構築</entry>
        <entry><literal>netmask('192.168.1.5/24')</literal></entry>
        <entry><literal>255.255.255.0</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>network</primary>
         </indexterm>
         <literal><function>network(<type>inet</type>)</function></literal>
        </entry>
        <entry><type>cidr</type></entry>
<!--
        <entry>extract network part of address</entry>
-->
        <entry>ネットワークアドレスからネットワーク部を抽出</entry>
        <entry><literal>network('192.168.1.5/24')</literal></entry>
        <entry><literal>192.168.1.0/24</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>set_masklen</primary>
         </indexterm>
         <literal><function>set_masklen(<type>inet</type>, <type>int</type>)</function></literal>
        </entry>
        <entry><type>inet</type></entry>
<!--
        <entry>set netmask length for <type>inet</type> value</entry>
-->
        <entry><type>inet</type>値のネットマスク長を設定</entry>
        <entry><literal>set_masklen('192.168.1.5/24', 16)</literal></entry>
        <entry><literal>192.168.1.5/16</literal></entry>
       </row>
       <row>
        <entry><literal><function>set_masklen(<type>cidr</type>, <type>int</type>)</function></literal></entry>
        <entry><type>cidr</type></entry>
<!--
        <entry>set netmask length for <type>cidr</type> value</entry>
-->
        <entry><type>cidr</type>値のネットマスク長を設定</entry>
        <entry><literal>set_masklen('192.168.1.0/24'::cidr, 16)</literal></entry>
        <entry><literal>192.168.0.0/16</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>text</primary>
         </indexterm>
         <literal><function>text(<type>inet</type>)</function></literal>
        </entry>
        <entry><type>text</type></entry>
<!--
        <entry>extract IP address and netmask length as text</entry>
-->
        <entry>IPアドレスとネットマスク長をテキストで抽出</entry>
        <entry><literal>text(inet '192.168.1.5')</literal></entry>
        <entry><literal>192.168.1.5/32</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>inet_same_family</primary>
         </indexterm>
         <literal><function>inet_same_family(<type>inet</type>, <type>inet</type>)</function></literal>
        </entry>
        <entry><type>boolean</type></entry>
<!--
        <entry>are the addresses from the same family?</entry>
-->
        <entry>同じアドレスファミリかどうかを返す</entry>
        <entry><literal>inet_same_family('192.168.1.5/24', '::1')</literal></entry>
        <entry><literal>false</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>inet_merge</primary>
         </indexterm>
         <literal><function>inet_merge(<type>inet</type>, <type>inet</type>)</function></literal>
        </entry>
        <entry><type>cidr</type></entry>
<!--
        <entry>the smallest network which includes both of the given networks</entry>
-->
        <entry>両方のネットワークを含む最小のネットワークを返す</entry>
        <entry><literal>inet_merge('192.168.1.5/24', '192.168.2.5/24')</literal></entry>
        <entry><literal>192.168.0.0/22</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

  <para>
<!--
   Any <type>cidr</> value can be cast to <type>inet</> implicitly
   or explicitly; therefore, the functions shown above as operating on
   <type>inet</> also work on <type>cidr</> values.  (Where there are
   separate functions for <type>inet</> and <type>cidr</>, it is because
   the behavior should be different for the two cases.)
   Also, it is permitted to cast an <type>inet</> value to <type>cidr</>.
   When this is done, any bits to the right of the netmask are silently zeroed
   to create a valid <type>cidr</> value.
   In addition,
   you can cast a text value to <type>inet</> or <type>cidr</>
   using normal casting syntax: for example,
   <literal>inet(<replaceable>expression</>)</literal> or
   <literal><replaceable>colname</>::cidr</literal>.
-->
<type>cidr</>値はすべて、暗黙的または明示的に<type>inet</>型にキャスト可能です。
したがって、上で示した<type>inet</>に対する操作を行う関数は<type>cidr</>値でも動作します。
（<type>inet</>と<type>cidr</>で別々に関数が存在するものがありますが、それは、この2つで動作に違いがあるためです。）
また、<type>inet</>値から<type>cidr</>へのキャストも許されます。これが行われると、ネットマスクの右側のビットは、<type>cidr</>として有効な値とするために0となります。
さらに、通常のキャスト構文、例えば、<literal>inet(<replaceable>expression</>)</literal>や<literal><replaceable>colname</>::cidr</literal>を使用して、テキスト値を<type>inet</>や<type>cidr</>にキャストすることもできます。
  </para>

  <para>
<!--
   <xref linkend="macaddr-functions-table"> shows the functions
   available for use with the <type>macaddr</type> type.  The function
   <literal><function>trunc(<type>macaddr</type>)</function></literal> returns a MAC
   address with the last 3 bytes set to zero.  This can be used to
   associate the remaining prefix with a manufacturer.
-->
<xref linkend="macaddr-functions-table">に、<type>macaddr</type>型で使用可能な関数を示します。
関数<literal><function>trunc(<type>macaddr</type>)</function></literal>は終わりの3バイトがゼロに設定されたMACアドレスを返します。
これは、残った接頭部を製造者に対応させることに使えます。
  </para>

    <table id="macaddr-functions-table">
<!--
     <title><type>macaddr</type> Functions</title>
-->
     <title><type>macaddr</type>型関数</title>
     <tgroup cols="5">
      <thead>
       <row>
<!--
        <entry>Function</entry>
        <entry>Return Type</entry>
        <entry>Description</entry>
        <entry>Example</entry>
        <entry>Result</entry>
-->
        <entry>関数</entry>
        <entry>戻り値</entry>
        <entry>説明</entry>
        <entry>例</entry>
        <entry>結果</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>
         <indexterm>
          <primary>trunc</primary>
         </indexterm>
         <literal><function>trunc(<type>macaddr</type>)</function></literal>
        </entry>
        <entry><type>macaddr</type></entry>
<!--
        <entry>set last 3 bytes to zero</entry>
-->
        <entry>終わりの３バイトをゼロに設定</entry>
        <entry><literal>trunc(macaddr '12:34:56:78:90:ab')</literal></entry>
        <entry><literal>12:34:56:00:00:00</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
<!--
    The <type>macaddr</type> type also supports the standard relational
    operators (<literal>&gt;</literal>, <literal>&lt;=</literal>, etc.) for
    lexicographical ordering, and the bitwise arithmetic operators
    (<literal>~</literal>, <literal>&amp;</literal> and <literal>|</literal>)
    for NOT, AND and OR.
-->
<type>macaddr</type>型は（<literal>&gt;</literal>、<literal>&lt;=</literal>等の）辞書編集順に並べる標準関係演算子とNOT、AND、ORのビット演算子(<literal>~</literal>、<literal>&amp;</literal>、<literal>|</literal>)もサポートしています。
   </para>

  </sect1>


 <sect1 id="functions-textsearch">
<!--
  <title>Text Search Functions and Operators</title>
-->
  <title>テキスト検索関数と演算子</title>

   <indexterm zone="datatype-textsearch">
<!--
    <primary>full text search</primary>
    <secondary>functions and operators</secondary>
-->
    <primary>全文テキスト検索</primary>
    <secondary>関数と演算子</secondary>
   </indexterm>

   <indexterm zone="datatype-textsearch">
<!--
    <primary>text search</primary>
    <secondary>functions and operators</secondary>
-->
    <primary>テキスト検索</primary>
    <secondary>関数と演算子</secondary>
   </indexterm>

  <para>
<!--
   <xref linkend="textsearch-operators-table">,
   <xref linkend="textsearch-functions-table"> and
   <xref linkend="textsearch-functions-debug-table">
   summarize the functions and operators that are provided
   for full text searching.  See <xref linkend="textsearch"> for a detailed
   explanation of <productname>PostgreSQL</productname>'s text search
   facility.
-->
   <xref linkend="textsearch-operators-table">、
   <xref linkend="textsearch-functions-table">および 
   <xref linkend="textsearch-functions-debug-table">は全文検索用に提供されている関数と演算子を要約しています。<productname>PostgreSQL</productname>のテキスト検索機能の詳細は<xref linkend="textsearch">を参照してください。
  </para>

    <table id="textsearch-operators-table">
<!--
     <title>Text Search Operators</title>
-->
     <title>テキスト検索演算子</title>
     <tgroup cols="4">
      <thead>
       <row>
<!--
        <entry>Operator</entry>
        <entry>Description</entry>
        <entry>Example</entry>
        <entry>Result</entry>
-->
        <entry>演算子</entry>
        <entry>説明</entry>
        <entry>例</entry>
        <entry>結果</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry> <literal>@@</literal> </entry>
<!--
        <entry><type>tsvector</> matches <type>tsquery</> ?</entry>
-->
        <entry><type>tsvector</>が<type>tsquery</>の条件に合うか？</entry>
        <entry><literal>to_tsvector('fat cats ate rats') @@ to_tsquery('cat &amp; rat')</literal></entry>
        <entry><literal>t</literal></entry>
       </row>
       <row>
        <entry> <literal>@@@</literal> </entry>
<!--
        <entry>deprecated synonym for <literal>@@</></entry>
-->
        <entry><literal>@@</>に対する廃止予定の同義語</entry>
        <entry><literal>to_tsvector('fat cats ate rats') @@@ to_tsquery('cat &amp; rat')</literal></entry>
        <entry><literal>t</literal></entry>
       </row>
       <row>
        <entry> <literal>||</literal> </entry>
<!--
        <entry>concatenate <type>tsvector</>s</entry>
-->
        <entry><type>tsvector</>を連結</entry>
        <entry><literal>'a:1 b:2'::tsvector || 'c:1 d:2 b:3'::tsvector</literal></entry>
        <entry><literal>'a':1 'b':2,5 'c':3 'd':4</literal></entry>
       </row>
       <row>
        <entry> <literal>&amp;&amp;</literal> </entry>
<!--
        <entry>AND <type>tsquery</>s together</entry>
-->
        <entry><type>tsquery</>にAND演算を行う</entry>
        <entry><literal>'fat | rat'::tsquery &amp;&amp; 'cat'::tsquery</literal></entry>
        <entry><literal>( 'fat' | 'rat' ) &amp; 'cat'</literal></entry>
       </row>
       <row>
        <entry> <literal>||</literal> </entry>
<!--
        <entry>OR <type>tsquery</>s together</entry>
-->
        <entry><type>tsquery</>にOR演算を行う</entry>
        <entry><literal>'fat | rat'::tsquery || 'cat'::tsquery</literal></entry>
        <entry><literal>( 'fat' | 'rat' ) | 'cat'</literal></entry>
       </row>
       <row>
        <entry> <literal>!!</literal> </entry>
<!--
        <entry>negate a <type>tsquery</></entry>
-->
        <entry><type>tsquery</>を否定</entry>
        <entry><literal>!! 'cat'::tsquery</literal></entry>
        <entry><literal>!'cat'</literal></entry>
       </row>
       <row>
        <entry> <literal>@&gt;</literal> </entry>
<!--
        <entry><type>tsquery</> contains another ?</entry>
-->
        <entry><type>tsquery</>は他方を包含するか？</entry>
        <entry><literal>'cat'::tsquery @&gt; 'cat &amp; rat'::tsquery</literal></entry>
        <entry><literal>f</literal></entry>
       </row>
       <row>
        <entry> <literal>&lt;@</literal> </entry>
<!--
        <entry><type>tsquery</> is contained in ?</entry>
-->
        <entry><type>tsquery</>は他方に包含されるか？</entry>
        <entry><literal>'cat'::tsquery &lt;@ 'cat &amp; rat'::tsquery</literal></entry>
        <entry><literal>t</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

    <note>
     <para>
<!--
      The <type>tsquery</> containment operators consider only the lexemes
      listed in the two queries, ignoring the combining operators.
-->
<type>tsquery</>の包含演算子は２つの問い合わせで列挙された語彙素のみを対象とし、結合演算子を無視します。
     </para>
    </note>

    <para>
<!--
     In addition to the operators shown in the table, the ordinary B-tree
     comparison operators (<literal>=</>, <literal>&lt;</>, etc) are defined
     for types <type>tsvector</> and <type>tsquery</>.  These are not very
     useful for text searching but allow, for example, unique indexes to be
     built on columns of these types.
-->
表に示された演算子に加え、通常のB-tree比較演算子（<literal>=</>、<literal>&lt;</>など）が、型<type>tsvector</>および<type>tsquery</>に対して定義されます。
これらはテキスト検索に対してそれほど有用ではありませんが、例えばこれらの型の列に一意インデックスを作成することを可能にします。
    </para>

    <table id="textsearch-functions-table">
<!--
     <title>Text Search Functions</title>
-->
     <title>テキスト検索関数</title>
     <tgroup cols="5">
      <thead>
       <row>
<!--
        <entry>Function</entry>
        <entry>Return Type</entry>
        <entry>Description</entry>
        <entry>Example</entry>
        <entry>Result</entry>
-->
        <entry>関数</entry>
        <entry>戻り値型</entry>
        <entry>説明</entry>
        <entry>例</entry>
        <entry>結果</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>
         <indexterm>
          <primary>get_current_ts_config</primary>
         </indexterm>
         <literal><function>get_current_ts_config()</function></literal>
        </entry>
        <entry><type>regconfig</type></entry>
<!--
        <entry>get default text search configuration</entry>
-->
        <entry>
         デフォルトのテキスト検索設定の取得
        </entry>
        <entry><literal>get_current_ts_config()</literal></entry>
        <entry><literal>english</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>length</primary>
         </indexterm>
         <literal><function>length(<type>tsvector</>)</function></literal>
        </entry>
        <entry><type>integer</type></entry>
<!--
        <entry>number of lexemes in <type>tsvector</></entry>
-->
        <entry><type>tsvector</>にある語彙素の数</entry>
        <entry><literal>length('fat:2,4 cat:3 rat:5A'::tsvector)</literal></entry>
        <entry><literal>3</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>numnode</primary>
         </indexterm>
         <literal><function>numnode(<type>tsquery</>)</function></literal>
        </entry>
        <entry><type>integer</type></entry>
<!--
        <entry>number of lexemes plus operators in <type>tsquery</></entry>
-->
        <entry>
         <type>tsquery</>にある語彙素の数と演算子の数の和
        </entry>
        <entry><literal> numnode('(fat &amp; rat) | cat'::tsquery)</literal></entry>
        <entry><literal>5</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>plainto_tsquery</primary>
         </indexterm>
         <literal><function>plainto_tsquery(<optional> <replaceable class="PARAMETER">config</> <type>regconfig</> , </optional> <replaceable class="PARAMETER">query</> <type>text</type>)</function></literal>
        </entry>
        <entry><type>tsquery</type></entry>
<!--
        <entry>produce <type>tsquery</> ignoring punctuation</entry>
-->
        <entry>句読点を無視して、<type>tsquery</>を作成</entry>
        <entry><literal>plainto_tsquery('english', 'The Fat Rats')</literal></entry>
        <entry><literal>'fat' &amp; 'rat'</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>querytree</primary>
         </indexterm>
         <literal><function>querytree(<replaceable class="PARAMETER">query</replaceable> <type>tsquery</>)</function></literal>
        </entry>
        <entry><type>text</type></entry>
<!--
        <entry>get indexable part of a <type>tsquery</></entry>
-->
        <entry><type>tsquery</>のインデックス付け可能部分の取得</entry>
        <entry><literal>querytree('foo &amp; ! bar'::tsquery)</literal></entry>
        <entry><literal>'foo'</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>setweight</primary>
         </indexterm>
         <literal><function>setweight(<type>tsvector</>, <type>"char"</>)</function></literal>
        </entry>
        <entry><type>tsvector</type></entry>
<!--
        <entry>assign weight to each element of <type>tsvector</></entry>
-->
        <entry><type>tsvector</>のそれぞれの要素に重みを割り当て</entry>
        <entry><literal>setweight('fat:2,4 cat:3 rat:5B'::tsvector, 'A')</literal></entry>
        <entry><literal>'cat':3A 'fat':2A,4A 'rat':5A</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>strip</primary>
         </indexterm>
         <literal><function>strip(<type>tsvector</>)</function></literal>
        </entry>
        <entry><type>tsvector</type></entry>
<!--
        <entry>remove positions and weights from <type>tsvector</></entry>
-->
        <entry><type>tsvector</>から位置と重みを削除</entry>
        <entry><literal>strip('fat:2,4 cat:3 rat:5A'::tsvector)</literal></entry>
        <entry><literal>'cat' 'fat' 'rat'</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>to_tsquery</primary>
         </indexterm>
         <literal><function>to_tsquery(<optional> <replaceable class="PARAMETER">config</> <type>regconfig</> , </optional> <replaceable class="PARAMETER">query</> <type>text</type>)</function></literal>
        </entry>
        <entry><type>tsquery</type></entry>
<!--
        <entry>normalize words and convert to <type>tsquery</></entry>
-->
        <entry>単語（複数）を正規化し<type>tsquery</>に変換</entry>
        <entry><literal>to_tsquery('english', 'The &amp; Fat &amp; Rats')</literal></entry>
        <entry><literal>'fat' &amp; 'rat'</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>to_tsvector</primary>
         </indexterm>
         <literal><function>to_tsvector(<optional> <replaceable class="PARAMETER">config</> <type>regconfig</> , </optional> <replaceable class="PARAMETER">document</> <type>text</type>)</function></literal>
        </entry>
        <entry><type>tsvector</type></entry>
<!--
        <entry>reduce document text to <type>tsvector</></entry>
-->
        <entry>ドキュメントテキストを<type>tsvector</>に縮小</entry>
        <entry><literal>to_tsvector('english', 'The Fat Rats')</literal></entry>
        <entry><literal>'fat':2 'rat':3</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>ts_headline</primary>
         </indexterm>
         <literal><function>ts_headline(<optional> <replaceable class="PARAMETER">config</replaceable> <type>regconfig</>, </optional> <replaceable class="PARAMETER">document</replaceable> <type>text</>, <replaceable class="PARAMETER">query</replaceable> <type>tsquery</> <optional>, <replaceable class="PARAMETER">options</replaceable> <type>text</> </optional>)</function></literal>
        </entry>
        <entry><type>text</type></entry>
<!--
        <entry>display a query match</entry>
-->
        <entry>問い合わせによるマッチを表示</entry>
        <entry><literal>ts_headline('x y z', 'z'::tsquery)</literal></entry>
        <entry><literal>x y &lt;b&gt;z&lt;/b&gt;</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>ts_rank</primary>
         </indexterm>
         <literal><function>ts_rank(<optional> <replaceable class="PARAMETER">weights</replaceable> <type>float4[]</>, </optional> <replaceable class="PARAMETER">vector</replaceable> <type>tsvector</>, <replaceable class="PARAMETER">query</replaceable> <type>tsquery</> <optional>, <replaceable class="PARAMETER">normalization</replaceable> <type>integer</> </optional>)</function></literal>
        </entry>
        <entry><type>float4</type></entry>
<!--
        <entry>rank document for query</entry>
-->
        <entry>問い合わせのためのドキュメント順位付け</entry>
        <entry><literal>ts_rank(textsearch, query)</literal></entry>
        <entry><literal>0.818</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>ts_rank_cd</primary>
         </indexterm>
         <literal><function>ts_rank_cd(<optional> <replaceable class="PARAMETER">weights</replaceable> <type>float4[]</>, </optional> <replaceable class="PARAMETER">vector</replaceable> <type>tsvector</>, <replaceable class="PARAMETER">query</replaceable> <type>tsquery</> <optional>, <replaceable class="PARAMETER">normalization</replaceable> <type>integer</> </optional>)</function></literal>
        </entry>
        <entry><type>float4</type></entry>
<!--
        <entry>rank document for query using cover density</entry>
-->
        <entry>被覆密度を用いた問い合わせのためのドキュメント順位付け</entry>
        <entry><literal>ts_rank_cd('{0.1, 0.2, 0.4, 1.0}', textsearch, query)</literal></entry>
        <entry><literal>2.01317</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>ts_rewrite</primary>
         </indexterm>
         <literal><function>ts_rewrite(<replaceable class="PARAMETER">query</replaceable> <type>tsquery</>, <replaceable class="PARAMETER">target</replaceable> <type>tsquery</>, <replaceable class="PARAMETER">substitute</replaceable> <type>tsquery</>)</function></literal>
        </entry>
        <entry><type>tsquery</type></entry>
<!--
        <entry>replace target with substitute within query</entry>
-->
        <entry>問い合わせ内で対象を代替と置換</entry>
        <entry><literal>ts_rewrite('a &amp; b'::tsquery, 'a'::tsquery, 'foo|bar'::tsquery)</literal></entry>
        <entry><literal>'b' &amp; ( 'foo' | 'bar' )</literal></entry>
       </row>
       <row>
        <entry><literal><function>ts_rewrite(<replaceable class="PARAMETER">query</replaceable> <type>tsquery</>, <replaceable class="PARAMETER">select</replaceable> <type>text</>)</function></literal></entry>
        <entry><type>tsquery</type></entry>
<!--
        <entry>replace using targets and substitutes from a <command>SELECT</> command</entry>
-->
        <entry><command>SELECT</>から対象と代替を使用して置換</entry>
        <entry><literal>SELECT ts_rewrite('a &amp; b'::tsquery, 'SELECT t,s FROM aliases')</literal></entry>
        <entry><literal>'b' &amp; ( 'foo' | 'bar' )</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>tsvector_update_trigger</primary>
         </indexterm>
         <literal><function>tsvector_update_trigger()</function></literal>
        </entry>
        <entry><type>trigger</type></entry>
<!--
        <entry>trigger function for automatic <type>tsvector</> column update</entry>
-->
        <entry><type>tsvector</>列の自動更新のためのトリガ関数</entry>
        <entry><literal>CREATE TRIGGER ... tsvector_update_trigger(tsvcol, 'pg_catalog.swedish', title, body)</literal></entry>
        <entry><literal></literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>tsvector_update_trigger_column</primary>
         </indexterm>
         <literal><function>tsvector_update_trigger_column()</function></literal>
        </entry>
        <entry><type>trigger</type></entry>
<!--
        <entry>trigger function for automatic <type>tsvector</> column update</entry>
-->
        <entry><type>tsvector</>列の自動更新のためのトリガ関数</entry>
        <entry><literal>CREATE TRIGGER ... tsvector_update_trigger_column(tsvcol, configcol, title, body)</literal></entry>
        <entry><literal></literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

  <note>
   <para>
<!--
    All the text search functions that accept an optional <type>regconfig</>
    argument will use the configuration specified by
    <xref linkend="guc-default-text-search-config">
    when that argument is omitted.
-->
オプションの<type>regconfig</>引数を受け付ける全てのテキスト検索関数は、その引数が省略された場合<xref linkend="guc-default-text-search-config">で指定された構成を使用します。
   </para>
  </note>

  <para>
<!--
   The functions in
   <xref linkend="textsearch-functions-debug-table">
   are listed separately because they are not usually used in everyday text
   searching operations.  They are helpful for development and debugging
   of new text search configurations.
-->
<xref linkend="textsearch-functions-debug-table">の関数は、日常のテキスト検索操作では通常使用されないので、別の表にしました。
これらは新しいテキスト検索設定の開発およびデバッグに役立ちます。
  </para>

    <table id="textsearch-functions-debug-table">
<!--
     <title>Text Search Debugging Functions</title>
-->
     <title>テキスト検索デバッグ関数</title>
     <tgroup cols="5">
      <thead>
       <row>
<!--
        <entry>Function</entry>
        <entry>Return Type</entry>
        <entry>Description</entry>
        <entry>Example</entry>
        <entry>Result</entry>
-->
        <entry>関数</entry>
        <entry>戻り値型</entry>
        <entry>説明</entry>
        <entry>例</entry>
        <entry>結果</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>
         <indexterm>
          <primary>ts_debug</primary>
         </indexterm>
         <literal><function>ts_debug(<optional> <replaceable class="PARAMETER">config</replaceable> <type>regconfig</>, </optional> <replaceable class="PARAMETER">document</replaceable> <type>text</>, OUT <replaceable class="PARAMETER">alias</> <type>text</>, OUT <replaceable class="PARAMETER">description</> <type>text</>, OUT <replaceable class="PARAMETER">token</> <type>text</>, OUT <replaceable class="PARAMETER">dictionaries</> <type>regdictionary[]</>, OUT <replaceable class="PARAMETER">dictionary</> <type>regdictionary</>, OUT <replaceable class="PARAMETER">lexemes</> <type>text[]</>)</function></literal>
        </entry>
        <entry><type>setof record</type></entry>
<!--
        <entry>test a configuration</entry>
-->
        <entry>構成を検査</entry>
        <entry><literal>ts_debug('english', 'The Brightest supernovaes')</literal></entry>
        <entry><literal>(asciiword,"Word, all ASCII",The,{english_stem},english_stem,{}) ...</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>ts_lexize</primary>
         </indexterm>
         <literal><function>ts_lexize(<replaceable class="PARAMETER">dict</replaceable> <type>regdictionary</>, <replaceable class="PARAMETER">token</replaceable> <type>text</>)</function></literal>
        </entry>
        <entry><type>text[]</type></entry>
<!--
        <entry>test a dictionary</entry>
-->
        <entry>辞書を検査</entry>
        <entry><literal>ts_lexize('english_stem', 'stars')</literal></entry>
        <entry><literal>{star}</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>ts_parse</primary>
         </indexterm>
         <literal><function>ts_parse(<replaceable class="PARAMETER">parser_name</replaceable> <type>text</>, <replaceable class="PARAMETER">document</replaceable> <type>text</>, OUT <replaceable class="PARAMETER">tokid</> <type>integer</>, OUT <replaceable class="PARAMETER">token</> <type>text</>)</function></literal>
        </entry>
        <entry><type>setof record</type></entry>
<!--
        <entry>test a parser</entry>
-->
        <entry>パーサを検査</entry>
        <entry><literal>ts_parse('default', 'foo - bar')</literal></entry>
        <entry><literal>(1,foo) ...</literal></entry>
       </row>
       <row>
        <entry><literal><function>ts_parse(<replaceable class="PARAMETER">parser_oid</replaceable> <type>oid</>, <replaceable class="PARAMETER">document</replaceable> <type>text</>, OUT <replaceable class="PARAMETER">tokid</> <type>integer</>, OUT <replaceable class="PARAMETER">token</> <type>text</>)</function></literal></entry>
        <entry><type>setof record</type></entry>
<!--
        <entry>test a parser</entry>
-->
        <entry>パーサを検査</entry>
        <entry><literal>ts_parse(3722, 'foo - bar')</literal></entry>
        <entry><literal>(1,foo) ...</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>ts_token_type</primary>
         </indexterm>
         <literal><function>ts_token_type(<replaceable class="PARAMETER">parser_name</> <type>text</>, OUT <replaceable class="PARAMETER">tokid</> <type>integer</>, OUT <replaceable class="PARAMETER">alias</> <type>text</>, OUT <replaceable class="PARAMETER">description</> <type>text</>)</function></literal>
        </entry>
        <entry><type>setof record</type></entry>
<!--
        <entry>get token types defined by parser</entry>
-->
    <entry>パーサで定義されたトークンの型を入手</entry>
        <entry><literal>ts_token_type('default')</literal></entry>
        <entry><literal>(1,asciiword,"Word, all ASCII") ...</literal></entry>
       </row>
       <row>
        <entry><literal><function>ts_token_type(<replaceable class="PARAMETER">parser_oid</> <type>oid</>, OUT <replaceable class="PARAMETER">tokid</> <type>integer</>, OUT <replaceable class="PARAMETER">alias</> <type>text</>, OUT <replaceable class="PARAMETER">description</> <type>text</>)</function></literal></entry>
        <entry><type>setof record</type></entry>
<!--
        <entry>get token types defined by parser</entry>
-->
        <entry>パーサで定義されたトークンの型を入手</entry>
        <entry><literal>ts_token_type(3722)</literal></entry>
        <entry><literal>(1,asciiword,"Word, all ASCII") ...</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>ts_stat</primary>
         </indexterm>
         <literal><function>ts_stat(<replaceable class="PARAMETER">sqlquery</replaceable> <type>text</>, <optional> <replaceable class="PARAMETER">weights</replaceable> <type>text</>, </optional> OUT <replaceable class="PARAMETER">word</replaceable> <type>text</>, OUT <replaceable class="PARAMETER">ndoc</replaceable> <type>integer</>, OUT <replaceable class="PARAMETER">nentry</replaceable> <type>integer</>)</function></literal>
        </entry>
        <entry><type>setof record</type></entry>
<!--
        <entry>get statistics of a <type>tsvector</> column</entry>
-->
        <entry><type>tsvector</>列の統計情報を入手</entry>
        <entry><literal>ts_stat('SELECT vector from apod')</literal></entry>
        <entry><literal>(foo,10,15) ...</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

 </sect1>


 <sect1 id="functions-xml">
<!--
  <title>XML Functions</title>
-->
  <title>XML関数</title>

  <para>
<!--
   The functions and function-like expressions described in this
   section operate on values of type <type>xml</type>.  Check <xref
   linkend="datatype-xml"> for information about the <type>xml</type>
   type.  The function-like expressions <function>xmlparse</function>
   and <function>xmlserialize</function> for converting to and from
   type <type>xml</type> are not repeated here.  Use of most of these
   functions requires the installation to have been built
   with <command>configure &#045;-with-libxml</>.
-->
この節で説明される関数および擬似関数式は、<type>xml</type>型の値に対して機能します。
<type>xml</type>型についての情報は<xref linkend="datatype-xml">を点検してください。
<type>xml</type>型のやりとりを変換する<function>xmlparse</function>および<function>xmlserialize</function>擬似関数式はここでは繰り返しません。
これらの多くの関数を使用するには、インストレーションの際<command>configure --with-libxml</>付きでビルドされていることが必要です。
  </para>

  <sect2 id="functions-producing-xml">
<!--
   <title>Producing XML Content</title>
-->
   <title>XML内容の生成</title>

   <para>
<!--
    A set of functions and function-like expressions are available for
    producing XML content from SQL data.  As such, they are
    particularly suitable for formatting query results into XML
    documents for processing in client applications.
-->
SQLデータからXML内容を生成するために関数と擬似関数式の一式が提供されています。
そのようなものとして、クライアントアプリケーションが問い合わせ結果を処理のためXML文書に書式化するのにこれらは特に適しています。
   </para>

   <sect3>
    <title><literal>xmlcomment</literal></title>

    <indexterm>
     <primary>xmlcomment</primary>
    </indexterm>

<synopsis>
<function>xmlcomment</function>(<replaceable>text</replaceable>)
</synopsis>

    <para>
<!--
     The function <function>xmlcomment</function> creates an XML value
     containing an XML comment with the specified text as content.
     The text cannot contain <quote><literal>&#045;-</literal></quote> or end with a
     <quote><literal>-</literal></quote> so that the resulting construct is a valid
     XML comment.  If the argument is null, the result is null.
-->
関数<function>xmlcomment</function>は指定のテキストを内容とするXMLコメントを含んだXML値を作成します。
結果として構築されるXMLコメントが有効になるよう、テキストは<quote><literal>--</literal></quote>を含むこと、または<quote><literal>-</literal></quote>で終結することはできません。
引数がNULLならば結果もNULLになります。
    </para>

    <para>
<!--
     Example:
-->
例：
<screen><![CDATA[
SELECT xmlcomment('hello');

  xmlcomment
--------------
 <!--hello-->
]]></screen>
    </para>
   </sect3>

   <sect3>
    <title><literal>xmlconcat</literal></title>

    <indexterm>
     <primary>xmlconcat</primary>
    </indexterm>

<synopsis>
<function>xmlconcat</function>(<replaceable>xml</replaceable><optional>, ...</optional>)
</synopsis>

    <para>
<!--
     The function <function>xmlconcat</function> concatenates a list
     of individual XML values to create a single value containing an
     XML content fragment.  Null values are omitted; the result is
     only null if there are no nonnull arguments.
-->
関数<function>xmlconcat</function>は、個々のXML値のリストを結合し、XMLの内容断片を含む単一の値を作成します。
NULL値は削除され、NULL以外の引数が存在しないときのみ結果はNULLになります。
    </para>

    <para>
<!--
     Example:
-->
例：
<screen><![CDATA[
SELECT xmlconcat('<abc/>', '<bar>foo</bar>');

      xmlconcat
----------------------
 <abc/><bar>foo</bar>
]]></screen>
    </para>

    <para>
<!--
     XML declarations, if present, are combined as follows.  If all
     argument values have the same XML version declaration, that
     version is used in the result, else no version is used.  If all
     argument values have the standalone declaration value
     <quote>yes</quote>, then that value is used in the result.  If
     all argument values have a standalone declaration value and at
     least one is <quote>no</quote>, then that is used in the result.
     Else the result will have no standalone declaration.  If the
     result is determined to require a standalone declaration but no
     version declaration, a version declaration with version 1.0 will
     be used because XML requires an XML declaration to contain a
     version declaration.  Encoding declarations are ignored and
     removed in all cases.
-->
XML宣言が提示されている場合は次のように組み合わされます。
全ての引数の値が同一のXMLversion宣言を持っていれば、そのversionが結果に使用されます。さもなければversionは使用されません。
全ての引数の値でstandaloneの宣言値が<quote>yes</quote>であれば、その値が結果に使用されます。
全ての引数の値にstandalone宣言値があり、その中で１つでも<quote>no</quote>がある場合、それが結果に使用されます。
それ以外の場合は、結果はstandalone宣言を持ちません。
standalone宣言を必要とするが、standalone宣言がないという結果になった場合には、version 1.0のversion宣言が使用されます。
これはXMLがXML宣言においてversion宣言を含むことを要求するためです。
encoding宣言は無視され、全ての場合で削除されます。
    </para>

    <para>
<!--
     Example:
-->
例：
<screen><![CDATA[
SELECT xmlconcat('<?xml version="1.1"?><foo/>', '<?xml version="1.1" standalone="no"?><bar/>');

             xmlconcat
-----------------------------------
 <?xml version="1.1"?><foo/><bar/>
]]></screen>
    </para>
   </sect3>

   <sect3>
    <title><literal>xmlelement</literal></title>

   <indexterm>
    <primary>xmlelement</primary>
   </indexterm>

<synopsis>
<function>xmlelement</function>(name <replaceable>name</replaceable> <optional>, xmlattributes(<replaceable>value</replaceable> <optional>AS <replaceable>attname</replaceable></optional> <optional>, ... </optional>)</optional> <optional><replaceable>, content, ...</replaceable></optional>)
</synopsis>

    <para>
<!--
     The <function>xmlelement</function> expression produces an XML
     element with the given name, attributes, and content.
-->
<function>xmlelement</function>式は与えられた名前、属性、および内容を持つXML要素を生成します。
    </para>

    <para>
<!--
     Examples:
-->
例：
<screen><![CDATA[
SELECT xmlelement(name foo);

 xmlelement
------------
 <foo/>

SELECT xmlelement(name foo, xmlattributes('xyz' as bar));

    xmlelement
------------------
 <foo bar="xyz"/>

SELECT xmlelement(name foo, xmlattributes(current_date as bar), 'cont', 'ent');

             xmlelement
-------------------------------------
 <foo bar="2007-01-26">content</foo>
]]></screen>
    </para>

    <para>
<!--
     Element and attribute names that are not valid XML names are
     escaped by replacing the offending characters by the sequence
     <literal>_x<replaceable>HHHH</replaceable>_</literal>, where
     <replaceable>HHHH</replaceable> is the character's Unicode
     codepoint in hexadecimal notation.  For example:
-->
有効なXML名ではない要素名と属性名は、シーケンス<literal>_x<replaceable>HHHH</replaceable>_</literal>により障害となる文字を置換することでエスケープされます。ここで、<replaceable>HHHH</replaceable>は16進数によるその文字のUnicode文字コード番号です。
例をあげます。
<screen><![CDATA[
SELECT xmlelement(name "foo$bar", xmlattributes('xyz' as "a&b"));

            xmlelement
----------------------------------
 <foo_x0024_bar a_x0026_b="xyz"/>
]]></screen>
    </para>

    <para>
<!--
     An explicit attribute name need not be specified if the attribute
     value is a column reference, in which case the column's name will
     be used as the attribute name by default.  In other cases, the
     attribute must be given an explicit name.  So this example is
     valid:
-->
属性値が列参照の場合、明示的な属性名を指定する必要はありません。この場合、デフォルトで列名が属性名として使用されます。
その他の場合には、属性は明示的な名前で与えられなければなりません。
従って、以下の例は有効です。
<screen>
CREATE TABLE test (a xml, b xml);
SELECT xmlelement(name test, xmlattributes(a, b)) FROM test;
</screen>
<!--
     But these are not:
-->
しかし、以下の例は有効ではありません。
<screen>
SELECT xmlelement(name test, xmlattributes('constant'), a, b) FROM test;
SELECT xmlelement(name test, xmlattributes(func(a, b))) FROM test;
</screen>
    </para>

    <para>
<!--
     Element content, if specified, will be formatted according to
     its data type.  If the content is itself of type <type>xml</type>,
     complex XML documents can be constructed.  For example:
-->
もし要素内容が指定されればそのデータ型に従って書式化されます。
もし内容そのものが<type>xml</type>型であれば、複合XML文書が構築されます。
例をあげます。
<screen><![CDATA[
SELECT xmlelement(name foo, xmlattributes('xyz' as bar),
                            xmlelement(name abc),
                            xmlcomment('test'),
                            xmlelement(name xyz));

                  xmlelement
----------------------------------------------
 <foo bar="xyz"><abc/><!--test--><xyz/></foo>
]]></screen>

<!--
     Content of other types will be formatted into valid XML character
     data.  This means in particular that the characters &lt;, &gt;,
     and &amp; will be converted to entities.  Binary data (data type
     <type>bytea</type>) will be represented in base64 or hex
     encoding, depending on the setting of the configuration parameter
     <xref linkend="guc-xmlbinary">.  The particular behavior for
     individual data types is expected to evolve in order to align the
     SQL and PostgreSQL data types with the XML Schema specification,
     at which point a more precise description will appear.
-->
そのほかの型の内容は有効なXML文字データにフォーマットされます。
これは特に文字&lt;、&gt;、および&amp;がエンティティに変換されることを意味します。
バイナリデータ（データ型は<type>bytea</type>）は、設定パラメータ<xref linkend="guc-xmlbinary">の設定にしたがって、base64もしくは16進符号化方式で表現されます。
個々のデータ型に対する特定の動作は、XMLスキーマ仕様でのSQLおよびPostgreSQLデータ型に調整するため発展すると期待されます。
その時点で記述がより詳細になるでしょう。
    </para>
   </sect3>

   <sect3>
    <title><literal>xmlforest</literal></title>

   <indexterm>
    <primary>xmlforest</primary>
   </indexterm>

<synopsis>
<function>xmlforest</function>(<replaceable>content</replaceable> <optional>AS <replaceable>name</replaceable></optional> <optional>, ...</optional>)
</synopsis>

    <para>
<!--
     The <function>xmlforest</function> expression produces an XML
     forest (sequence) of elements using the given names and content.
-->
<function>xmlforest</function>式は与えられた名前と内容を使用し、要素のXMLフォレスト（シーケンス）を生成します。
    </para>

    <para>
<!--
     Examples:
-->
例：
<screen><![CDATA[
SELECT xmlforest('abc' AS foo, 123 AS bar);

          xmlforest
------------------------------
 <foo>abc</foo><bar>123</bar>


SELECT xmlforest(table_name, column_name)
FROM information_schema.columns
WHERE table_schema = 'pg_catalog';

                                         xmlforest
-------------------------------------------------------------------------------------------
 <table_name>pg_authid</table_name><column_name>rolname</column_name>
 <table_name>pg_authid</table_name><column_name>rolsuper</column_name>
 ...
]]></screen>

<!--
     As seen in the second example, the element name can be omitted if
     the content value is a column reference, in which case the column
     name is used by default.  Otherwise, a name must be specified.
-->
第２の例に見られるように、内容の値が列参照の場合、要素名は省略可能です。この時は、列名がデフォルトで使用されます。
そうでない時は、名前が指定されなければなりません。
    </para>

    <para>
<!--
     Element names that are not valid XML names are escaped as shown
     for <function>xmlelement</function> above.  Similarly, content
     data is escaped to make valid XML content, unless it is already
     of type <type>xml</type>.
-->
有効なXML名ではない要素名は上の<function>xmlelement</function>で説明した通りエスケープされます。
同様にして、既に<type>xml</type>型であるものを除き、内容データは有効なXML内容になるようにエスケープされます。
    </para>

    <para>
<!--
     Note that XML forests are not valid XML documents if they consist
     of more than one element, so it might be useful to wrap
     <function>xmlforest</function> expressions in
     <function>xmlelement</function>.
-->
XMLフォレストは２つ以上の要素からなる場合、有効なXML文書ではないことに注意してください。
したがって、<function>xmlelement</function>内に<function>xmlforest</function>式をラップすることが有用なことがあります。
    </para>
   </sect3>

   <sect3>
    <title><literal>xmlpi</literal></title>

   <indexterm>
    <primary>xmlpi</primary>
   </indexterm>

<synopsis>
<function>xmlpi</function>(name <replaceable>target</replaceable> <optional>, <replaceable>content</replaceable></optional>)
</synopsis>

    <para>
<!--
     The <function>xmlpi</function> expression creates an XML
     processing instruction.  The content, if present, must not
     contain the character sequence <literal>?&gt;</literal>.
-->
<function>xmlpi</function>式はXML処理命令を作成します。
内容が存在すれば、その内容は<literal>?&gt;</literal>文字シーケンスを含んではなりません。
    </para>

    <para>
<!--
     Example:
-->
例：
<screen><![CDATA[
SELECT xmlpi(name php, 'echo "hello world";');

            xmlpi
-----------------------------
 <?php echo "hello world";?>
]]></screen>
    </para>
   </sect3>

   <sect3>
    <title><literal>xmlroot</literal></title>

   <indexterm>
    <primary>xmlroot</primary>
   </indexterm>

<synopsis>
<function>xmlroot</function>(<replaceable>xml</replaceable>, version <replaceable>text</replaceable> | no value <optional>, standalone yes|no|no value</optional>)
</synopsis>

    <para>
<!--
     The <function>xmlroot</function> expression alters the properties
     of the root node of an XML value.  If a version is specified,
     it replaces the value in the root node's version declaration; if a
     standalone setting is specified, it replaces the value in the
     root node's standalone declaration.
-->
<function>xmlroot</function>式はXML値のルートノードの属性を変更します。
versionが指定されていると、ルートノードのversion宣言での値を変更し、standalone設定が指定されていると、ルートノードのstandalone宣言での値を変更します。
    </para>

    <para>
<screen><![CDATA[
SELECT xmlroot(xmlparse(document '<?xml version="1.1"?><content>abc</content>'),
               version '1.0', standalone yes);

                xmlroot
----------------------------------------
 <?xml version="1.0" standalone="yes"?>
 <content>abc</content>
]]></screen>
    </para>
   </sect3>

   <sect3 id="functions-xml-xmlagg">
    <title><literal>xmlagg</literal></title>

    <indexterm>
     <primary>xmlagg</primary>
    </indexterm>

<synopsis>
<function>xmlagg</function>(<replaceable>xml</replaceable>)
</synopsis>

    <para>
<!--
     The function <function>xmlagg</function> is, unlike the other
     functions described here, an aggregate function.  It concatenates the
     input values to the aggregate function call,
     much like <function>xmlconcat</function> does, except that concatenation
     occurs across rows rather than across expressions in a single row.
     See <xref linkend="functions-aggregate"> for additional information
     about aggregate functions.
-->
ここで説明している他の関数とは異なり、<function>xmlagg</function>関数は集約関数です。
これは<function>xmlconcat</function>が行うように、入力値を連結する集約関数ですが、単一行内の複数の式にまたがった連結ではなく、複数行にまたがった連結を行います。
集約関数についての追加情報は<xref linkend="functions-aggregate">を参照してください。
    </para>

    <para>
<!--
     Example:
-->
例：
<screen><![CDATA[
CREATE TABLE test (y int, x xml);
INSERT INTO test VALUES (1, '<foo>abc</foo>');
INSERT INTO test VALUES (2, '<bar/>');
SELECT xmlagg(x) FROM test;
        xmlagg
----------------------
 <foo>abc</foo><bar/>
]]></screen>
    </para>

    <para>
<!--
     To determine the order of the concatenation, an <literal>ORDER BY</>
     clause may be added to the aggregate call as described in
     <xref linkend="syntax-aggregates">. For example:
-->
連結の順序を決定するため、<xref linkend="syntax-aggregates">に記述されているように<literal>ORDER BY</>句を集計呼び出しに追加することができます。
以下は例です。

<screen><![CDATA[
SELECT xmlagg(x ORDER BY y DESC) FROM test;
        xmlagg
----------------------
 <bar/><foo>abc</foo>
]]></screen>
    </para>

    <para>
<!--
     The following non-standard approach used to be recommended
     in previous versions, and may still be useful in specific
     cases:
-->
下記は以前のバージョンで推奨されていた、非標準的な方法例です。特定のケースでは有用かもしれません。

<screen><![CDATA[
SELECT xmlagg(x) FROM (SELECT * FROM test ORDER BY y DESC) AS tab;
        xmlagg
----------------------
 <bar/><foo>abc</foo>
]]></screen>
    </para>
   </sect3>
   </sect2>

   <sect2 id="functions-xml-predicates">
<!--
    <title>XML Predicates</title>
-->
    <title>XML述語</title>

    <para>
<!--
     The expressions described in this section check properties
     of <type>xml</type> values.
-->
この節で記述されている式は、<type>xml</type>値の属性をチェックします。
    </para>

   <sect3>
    <title><literal>IS DOCUMENT</literal></title>

    <indexterm>
     <primary>IS DOCUMENT</primary>
    </indexterm>

<synopsis>
<replaceable>xml</replaceable> IS DOCUMENT
</synopsis>

    <para>
<!--
     The expression <literal>IS DOCUMENT</literal> returns true if the
     argument XML value is a proper XML document, false if it is not
     (that is, it is a content fragment), or null if the argument is
     null.  See <xref linkend="datatype-xml"> about the difference
     between documents and content fragments.
-->
式<literal>IS DOCUMENT</literal>は引数XML値が適切なXML文書であれば真を返し、そうでなければ（つまり、内容の断片）偽を返すか、もしくは引数がNULLであればNULLを返します。
文書と内容の断片の差異については<xref linkend="datatype-xml">を参照してください。
    </para>
   </sect3>

   <sect3 id="xml-exists">
    <title><literal>XMLEXISTS</literal></title>

    <indexterm>
     <primary>XMLEXISTS</primary>
    </indexterm>

<synopsis>
<function>XMLEXISTS</function>(<replaceable>text</replaceable> PASSING <optional>BY REF</optional> <replaceable>xml</replaceable> <optional>BY REF</optional>)
</synopsis>

    <para>
<!--
     The function <function>xmlexists</function> returns true if the
     XPath expression in the first argument returns any nodes, and
     false otherwise.  (If either argument is null, the result is
     null.)
-->
関数<function>xmlexists</function>は第一引数のXPath式が何かしらのノードであれば真を返し、そうでなければ偽を返します。
(もしいずれの引数もNULLであった場合はNULLを返します。)
    </para>

    <para>
<!--
     Example:
-->
例:
     <screen><![CDATA[
SELECT xmlexists('//town[text() = ''Toronto'']' PASSING BY REF '<towns><town>Toronto</town><town>Ottawa</town></towns>');

 xmlexists
------------
 t
(1 row)
]]></screen>
    </para>

    <para>
<!--
     The <literal>BY REF</literal> clauses have no effect in
     PostgreSQL, but are allowed for SQL conformance and compatibility
     with other implementations.  Per SQL standard, the
     first <literal>BY REF</literal> is required, the second is
     optional.  Also note that the SQL standard specifies
     the <function>xmlexists</function> construct to take an XQuery
     expression as first argument, but PostgreSQL currently only
     supports XPath, which is a subset of XQuery.
-->
<literal>BY REF</literal>句は、PostgreSQLには何の影響も与えませんが、他の実装とのSQL互換性や順応性のため、付与することができます。
SQL標準では1つ目の<literal>BY REF</literal>を必要としており、2つ目はオプショナルです。
加えてSQL標準では<function>xmlexists</function>はXQuery式を第一引数として取る構成としていますが、PostgreSQLでは現在XQueryのサブセットにあたるXPathのみサポートしていることに注意してください。
    </para>
   </sect3>

   <sect3 id="xml-is-well-formed">
    <title><literal>xml_is_well_formed</literal></title>

    <indexterm>
     <primary>xml_is_well_formed</primary>
    </indexterm>

    <indexterm>
     <primary>xml_is_well_formed_document</primary>
    </indexterm>

    <indexterm>
     <primary>xml_is_well_formed_content</primary>
    </indexterm>

<synopsis>
<function>xml_is_well_formed</function>(<replaceable>text</replaceable>)
<function>xml_is_well_formed_document</function>(<replaceable>text</replaceable>)
<function>xml_is_well_formed_content</function>(<replaceable>text</replaceable>)
</synopsis>

    <para>
<!--
     These functions check whether a <type>text</> string is well-formed XML,
     returning a Boolean result.
     <function>xml_is_well_formed_document</function> checks for a well-formed
     document, while <function>xml_is_well_formed_content</function> checks
     for well-formed content.  <function>xml_is_well_formed</function> does
     the former if the <xref linkend="guc-xmloption"> configuration
     parameter is set to <literal>DOCUMENT</>, or the latter if it is set to
     <literal>CONTENT</>.  This means that
     <function>xml_is_well_formed</function> is useful for seeing whether
     a simple cast to type <type>xml</> will succeed, whereas the other two
     functions are useful for seeing whether the corresponding variants of
     <function>XMLPARSE</> will succeed.
-->
これらの関数は<type>text</>文字列が整形式かどうかをチェックし、論理値で結果を返します。
<function>xml_is_well_formed_document</function>は文書が整形式かをチェックし、一方<function>xml_is_well_formed_content</function>は内容が整形式かをチェックします。
<function>xml_is_well_formed</function>は、<xref linkend="guc-xmloption">パラメータ値が<literal>DOCUMENT</>に設定されていれば前者を、<literal>CONTENT</>が設定されていれば後者のチェックを実施します。
これは、<function>xml_is_well_formed</function>は単純な<type>xml</>型へのキャストが成功するかの判断に有用であり、その他の２つの関数は<function>XMLPARSE</>の対応による変換が成功するかの判断に有用であることを意味します。
    </para>

    <para>
<!--
     Examples:
-->
例:

<screen><![CDATA[
SET xmloption TO DOCUMENT;
SELECT xml_is_well_formed('<>');
 xml_is_well_formed 
--------------------
 f
(1 row)

SELECT xml_is_well_formed('<abc/>');
 xml_is_well_formed 
--------------------
 t
(1 row)

SET xmloption TO CONTENT;
SELECT xml_is_well_formed('abc');
 xml_is_well_formed 
--------------------
 t
(1 row)

SELECT xml_is_well_formed_document('<pg:foo xmlns:pg="http://postgresql.org/stuff">bar</pg:foo>');
 xml_is_well_formed_document 
-----------------------------
 t
(1 row)

SELECT xml_is_well_formed_document('<pg:foo xmlns:pg="http://postgresql.org/stuff">bar</my:foo>');
 xml_is_well_formed_document 
-----------------------------
 f
(1 row)
]]></screen>

<!--
     The last example shows that the checks include whether
     namespaces are correctly matched.
-->
最後の例は、名前空間が正しく一致しているかのチェックも含むことを示しています。
    </para>
   </sect3>
  </sect2>

  <sect2 id="functions-xml-processing">
<!--
   <title>Processing XML</title>
-->
   <title>XMLの処理</title>

   <indexterm>
    <primary>XPath</primary>
   </indexterm>

   <para>
<!--
    To process values of data type <type>xml</type>, PostgreSQL offers
    the functions <function>xpath</function> and
    <function>xpath_exists</function>, which evaluate XPath 1.0
    expressions.
-->
データ型<type>xml</type>の値を処理するため、PostgreSQLは関数<function>xpath</function>と<function>xpath_exists</function>を提供しており、それはXPath 1.0式を評価します。
   </para>

<synopsis>
<function>xpath</function>(<replaceable>xpath</replaceable>, <replaceable>xml</replaceable> <optional>, <replaceable>nsarray</replaceable></optional>)
</synopsis>

   <para>
<!--
    The function <function>xpath</function> evaluates the XPath
    expression <replaceable>xpath</replaceable> (a <type>text</> value)
    against the XML value
    <replaceable>xml</replaceable>.  It returns an array of XML values
    corresponding to the node set produced by the XPath expression.
    If the XPath expression returns a scalar value rather than a node set,
    a single-element array is returned.
-->
関数<function>xpath</function>は、XML値<replaceable>xml</replaceable>に対し、XPath式<replaceable>xpath</replaceable>(ひとつの<type>text</>値)を評価します。そして、XPath式で作成されたノードセットに対応するXML値の配列を返します。
もし、XPath式がノードセットではなくスカラー値を返す場合、単一要素の配列が返されます。
   </para>

  <para>
<!--
    The second argument must be a well formed XML document. In particular,
    it must have a single root node element.
-->
2番目の引数は整形済XML文書でなければなりません。特に、単一のルートノード要素を持たなければなりません。
  </para>

   <para>
<!--
    The optional third argument of the function is an array of namespace
    mappings.  This array should be a two-dimensional <type>text</> array with
    the length of the second axis being equal to 2 (i.e., it should be an
    array of arrays, each of which consists of exactly 2 elements).
    The first element of each array entry is the namespace name (alias), the
    second the namespace URI. It is not required that aliases provided in
    this array be the same as those being used in the XML document itself (in
    other words, both in the XML document and in the <function>xpath</function>
    function context, aliases are <emphasis>local</>).
-->
オプショナルな関数の３番目の引数は名前空間マッピング配列です。
この配列は、第２軸が２に等しい長さをもつ２次元<type>text</>配列です（つまり、それは配列の配列で、それぞれは正確に２つの要素からなります）。
それぞれの配列のエントリの最初の要素は名前空間の名前（別名）で、２番目は名前空間のURIです。
この配列内で提供される別名がXML文書自身で使用されるものと同じであることは必要ではありません（言い換えると、XML文書内および<function>xpath</function>関数の両方の文脈の中で、別名は<emphasis>ローカル</>です）。
   </para>

   <para>
<!--
    Example:
-->
例：
<screen><![CDATA[
SELECT xpath('/my:a/text()', '<my:a xmlns:my="http://example.com">test</my:a>',
             ARRAY[ARRAY['my', 'http://example.com']]);

 xpath  
--------
 {test}
(1 row)
]]></screen>
   </para>

   <para>
<!--
    To deal with default (anonymous) namespaces, do something like this:
-->
デフォルト(匿名)名前空間を取り扱うためには、以下のようなことを実施してください。
<screen><![CDATA[
SELECT xpath('//mydefns:b/text()', '<a xmlns="http://example.com"><b>test</b></a>',
             ARRAY[ARRAY['mydefns', 'http://example.com']]);

 xpath
--------
 {test}
(1 row)
]]></screen>
   </para>

   <indexterm>
    <primary>xpath_exists</primary>
   </indexterm>

<synopsis>
<function>xpath_exists</function>(<replaceable>xpath</replaceable>, <replaceable>xml</replaceable> <optional>, <replaceable>nsarray</replaceable></optional>)
</synopsis>

   <para>
<!--
    The function <function>xpath_exists</function> is a specialized form
    of the <function>xpath</function> function.  Instead of returning the
    individual XML values that satisfy the XPath, this function returns a
    Boolean indicating whether the query was satisfied or not.  This
    function is equivalent to the standard <literal>XMLEXISTS</> predicate,
    except that it also offers support for a namespace mapping argument.
-->
関数<function>xpath_exists</function>は、<function>xpath</function>関数の特別な形式です。この関数は、XPathを満足する個別のXML値を返す代わりに、問い合わせがそれを満足するかどうかを論理値で返します。
この関数は、名前空間にマッピングされた引数をもサポートする点を除き、標準の<literal>XMLEXISTS</>述語と同じです。
   </para>

   <para>
<!--
    Example:
-->
例:
<screen><![CDATA[
SELECT xpath_exists('/my:a/text()', '<my:a xmlns:my="http://example.com">test</my:a>',
                     ARRAY[ARRAY['my', 'http://example.com']]);

 xpath_exists  
--------------
 t
(1 row)
]]></screen>
   </para>
  </sect2>

  <sect2 id="functions-xml-mapping">
<!--
   <title>Mapping Tables to XML</title>
-->
   <title>XMLにテーブルをマップ</title>

   <indexterm zone="functions-xml-mapping">
<!--
    <primary>XML export</primary>
-->
    <primary>XMLエクスポート</primary>
   </indexterm>

   <para>
<!--
    The following functions map the contents of relational tables to
    XML values.  They can be thought of as XML export functionality:
-->
以下の関数はリレーショナルテーブルの内容をXML値にマップします。
これらはXMLエクスポート機能と考えることができます。
<synopsis>
table_to_xml(tbl regclass, nulls boolean, tableforest boolean, targetns text)
query_to_xml(query text, nulls boolean, tableforest boolean, targetns text)
cursor_to_xml(cursor refcursor, count int, nulls boolean,
              tableforest boolean, targetns text)
</synopsis>
<!--
    The return type of each function is <type>xml</type>.
-->
それぞれの関数の戻り値型は<type>xml</type>です。
   </para>

   <para>
<!--
    <function>table_to_xml</function> maps the content of the named
    table, passed as parameter <parameter>tbl</parameter>.  The
    <type>regclass</type> type accepts strings identifying tables using the
    usual notation, including optional schema qualifications and
    double quotes.  <function>query_to_xml</function> executes the
    query whose text is passed as parameter
    <parameter>query</parameter> and maps the result set.
    <function>cursor_to_xml</function> fetches the indicated number of
    rows from the cursor specified by the parameter
    <parameter>cursor</parameter>.  This variant is recommended if
    large tables have to be mapped, because the result value is built
    up in memory by each function.
-->
<function>table_to_xml</function>は、パラメータ<parameter>tbl</parameter>として渡された名前付きのテーブルの内容をマップします。
<type>regclass</type>型はオプションのスキーマ修飾と二重引用符を含む、通常の表記法を使用しテーブルを特定する文字列を受け付けます。
<function>query_to_xml</function>は、パラメータ<parameter>query</parameter>としてテキストが渡された問い合わせを実行し、結果セットをマップします。
<function>cursor_to_xml</function>は、パラメータ<parameter>cursor</parameter>で指定されたカーソルから提示された行数を取得します。
それぞれの関数により結果値がメモリーに構築されるため、この異形は巨大なテーブルをマップする必要がある場合推奨されます。
   </para>

   <para>
<!--
    If <parameter>tableforest</parameter> is false, then the resulting
    XML document looks like this:
-->
<parameter>tableforest</parameter>が偽であれば、結果のXML文書は以下のようになります。
<screen><![CDATA[
<tablename>
  <row>
    <columnname1>data</columnname1>
    <columnname2>data</columnname2>
  </row>

  <row>
    ...
  </row>

  ...
</tablename>
]]></screen>

<!--
    If <parameter>tableforest</parameter> is true, the result is an
    XML content fragment that looks like this:
-->
<parameter>tableforest</parameter>が真であれば、結果は以下のようなXML文書の断片です。
<screen><![CDATA[
<tablename>
  <columnname1>data</columnname1>
  <columnname2>data</columnname2>
</tablename>

<tablename>
  ...
</tablename>

...
]]></screen>

<!--
    If no table name is available, that is, when mapping a query or a
    cursor, the string <literal>table</literal> is used in the first
    format, <literal>row</literal> in the second format.
-->
テーブル名が利用できないとき、つまり、問い合わせ、またはカーソルをマップする時は、最初の書式では文字列<literal>table</literal>が使用され、２番目の書式では<literal>row</literal>が使用されます。
   </para>

   <para>
<!--
    The choice between these formats is up to the user.  The first
    format is a proper XML document, which will be important in many
    applications.  The second format tends to be more useful in the
    <function>cursor_to_xml</function> function if the result values are to be
    reassembled into one document later on.  The functions for
    producing XML content discussed above, in particular
    <function>xmlelement</function>, can be used to alter the results
    to taste.
-->
これらどの書式を選択するのかはユーザ次第です。
最初の書式は適切なXML文書で、多くのアプリケーションにおいて重要です。
第２の書式は、後に結果値が１つの文書に再び組み立てられる場合、<function>cursor_to_xml</function>関数内でより有用になる傾向があります。
上記で説明したXML内容を作成する関数、特に<function>xmlelement</function>は結果を好みにかえるために使用することができます。
   </para>

   <para>
<!--
    The data values are mapped in the same way as described for the
    function <function>xmlelement</function> above.
-->
データの値は上記関数<function>xmlelement</function>で説明したのと同じ方法でマップされます。
   </para>

   <para>
<!--
    The parameter <parameter>nulls</parameter> determines whether null
    values should be included in the output.  If true, null values in
    columns are represented as:
-->
パラメータ<parameter>nulls</parameter>は出力にNULL値が含まれる必要があるかを決定します。
もし真であれば列内のNULL値は以下のように表現されます。
<screen><![CDATA[
<columnname xsi:nil="true"/>
]]></screen>
<!--
    where <literal>xsi</literal> is the XML namespace prefix for XML
    Schema Instance.  An appropriate namespace declaration will be
    added to the result value.  If false, columns containing null
    values are simply omitted from the output.
-->
ここで<literal>xsi</literal>はXMLスキーマインスタンスに対するXML名前空間接頭辞です。
適切な名前空間宣言が結果値に追加されます。
もし偽の場合、NULL値を含む列は単に出力から削除されます。
   </para>

   <para>
<!--
    The parameter <parameter>targetns</parameter> specifies the
    desired XML namespace of the result.  If no particular namespace
    is wanted, an empty string should be passed.
-->
パラメータ<parameter>targetns</parameter>は結果の希望するXML名前空間を指定します。
特定の名前空間が必要なければ、空文字列を渡す必要があります。
   </para>

   <para>
<!--
    The following functions return XML Schema documents describing the
    mappings performed by the corresponding functions above:
-->
以下の関数は、対応する上記関数により行われたマッピングを記述するXMLスキーマ文書を返します。
<synopsis>
table_to_xmlschema(tbl regclass, nulls boolean, tableforest boolean, targetns text)
query_to_xmlschema(query text, nulls boolean, tableforest boolean, targetns text)
cursor_to_xmlschema(cursor refcursor, nulls boolean, tableforest boolean, targetns text)
</synopsis>
<!--
    It is essential that the same parameters are passed in order to
    obtain matching XML data mappings and XML Schema documents.
-->
    一致するXMLデータマッピングとXMLスキーマ文書を取得するため、同じパラメータが渡されることが不可欠です。
   </para>

   <para>
<!--
    The following functions produce XML data mappings and the
    corresponding XML Schema in one document (or forest), linked
    together.  They can be useful where self-contained and
    self-describing results are wanted:
-->
以下の関数は、XMLデータマッピングとそれに対応するXMLスキーマがお互いにリンクされた、１つの文書（またはフォレスト）を作成します。
これらは自己完結した、自己記述的な結果を希望する場合に便利です。
<synopsis>
table_to_xml_and_xmlschema(tbl regclass, nulls boolean, tableforest boolean, targetns text)
query_to_xml_and_xmlschema(query text, nulls boolean, tableforest boolean, targetns text)
</synopsis>
   </para>

   <para>
<!--
    In addition, the following functions are available to produce
    analogous mappings of entire schemas or the entire current
    database:
-->
さらに、以下の関数がスキーマ全体、または現在のデータベース全体の類似マッピングを作成するため利用できます。
<synopsis>
schema_to_xml(schema name, nulls boolean, tableforest boolean, targetns text)
schema_to_xmlschema(schema name, nulls boolean, tableforest boolean, targetns text)
schema_to_xml_and_xmlschema(schema name, nulls boolean, tableforest boolean, targetns text)

database_to_xml(nulls boolean, tableforest boolean, targetns text)
database_to_xmlschema(nulls boolean, tableforest boolean, targetns text)
database_to_xml_and_xmlschema(nulls boolean, tableforest boolean, targetns text)
</synopsis>

<!--
    Note that these potentially produce a lot of data, which needs to
    be built up in memory.  When requesting content mappings of large
    schemas or databases, it might be worthwhile to consider mapping the
    tables separately instead, possibly even through a cursor.
-->
これらはメモリー内に作成される必要がある、多くのデータを生成する潜在的可能性があることに注意してください。
巨大なスキーマ、またはデータベースの内容マッピングを要求する際は、その代わりにテーブルを別々にマップすること、さらにはカーソル経由とすることさえ、検討することは無駄ではありません。
   </para>

   <para>
<!--
    The result of a schema content mapping looks like this:
-->
スキーマ内容マッピングの結果は以下のようになります。

<screen><![CDATA[
<schemaname>

table1-mapping

table2-mapping

...

</schemaname>]]></screen>

<!--
    where the format of a table mapping depends on the
    <parameter>tableforest</parameter> parameter as explained above.
-->
ここで、テーブルマッピング書式は上で説明したとおり<parameter>tableforest</parameter>パラメータに依存します。
   </para>

   <para>
<!--
    The result of a database content mapping looks like this:
-->
データベース内容マッピング書式は以下のようになります。

<screen><![CDATA[
<dbname>

<schema1name>
  ...
</schema1name>

<schema2name>
  ...
</schema2name>

...

</dbname>]]></screen>

<!--
    where the schema mapping is as above.
-->
ここで、スキーママッピングは上記のとおりです。
   </para>

   <para>
<!--
    As an example of using the output produced by these functions,
    <xref linkend="xslt-xml-html"> shows an XSLT stylesheet that
    converts the output of
    <function>table_to_xml_and_xmlschema</function> to an HTML
    document containing a tabular rendition of the table data.  In a
    similar manner, the results from these functions can be
    converted into other XML-based formats.
-->
これらの関数で作成された出力を使用する１つの例として、<xref linkend="xslt-xml-html">は、テーブルデータの表形式への翻訳を含む<function>table_to_xml_and_xmlschema</function>からHTML文書への出力の変換をおこなうXSLTスタイルシートを示します。
同じようにして、これらの関数の結果は他のXML基準書式に変換されます。
   </para>

   <figure id="xslt-xml-html">
<!--
    <title>XSLT Stylesheet for Converting SQL/XML Output to HTML</title>
-->
    <title>SQL/XML出力をHTMLに変換するXSLTスタイルシート</title>
<programlisting><![CDATA[
<?xml version="1.0"?>
<xsl:stylesheet version="1.0"
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:xsd="http://www.w3.org/2001/XMLSchema"
    xmlns="http://www.w3.org/1999/xhtml"
>

  <xsl:output method="xml"
      doctype-system="http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"
      doctype-public="-//W3C/DTD XHTML 1.0 Strict//EN"
      indent="yes"/>

  <xsl:template match="/*">
    <xsl:variable name="schema" select="//xsd:schema"/>
    <xsl:variable name="tabletypename"
                  select="$schema/xsd:element[@name=name(current())]/@type"/>
    <xsl:variable name="rowtypename"
                  select="$schema/xsd:complexType[@name=$tabletypename]/xsd:sequence/xsd:element[@name='row']/@type"/>

    <html>
      <head>
        <title><xsl:value-of select="name(current())"/></title>
      </head>
      <body>
        <table>
          <tr>
            <xsl:for-each select="$schema/xsd:complexType[@name=$rowtypename]/xsd:sequence/xsd:element/@name">
              <th><xsl:value-of select="."/></th>
            </xsl:for-each>
          </tr>

          <xsl:for-each select="row">
            <tr>
              <xsl:for-each select="*">
                <td><xsl:value-of select="."/></td>
              </xsl:for-each>
            </tr>
          </xsl:for-each>
        </table>
      </body>
    </html>
  </xsl:template>

</xsl:stylesheet>
]]></programlisting>
   </figure>
  </sect2>
 </sect1>

<!-- split-func2-end -->
