<!--
doc/src/sgml/ref/create_type.sgml
PostgreSQL documentation
-->

<refentry id="SQL-CREATETYPE">
 <indexterm zone="sql-createtype">
  <primary>CREATE TYPE</primary>
 </indexterm>

 <refmeta>
  <refentrytitle>CREATE TYPE</refentrytitle>
  <manvolnum>7</manvolnum>
<!--
  <refmiscinfo>SQL - Language Statements</refmiscinfo>
-->
<refmiscinfo>SQL - 言語</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>CREATE TYPE</refname>
<!--
  <refpurpose>define a new data type</refpurpose>
-->
  <refpurpose>新しいデータ型を定義する</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>
CREATE TYPE <replaceable class="parameter">name</replaceable> AS
    ( [ <replaceable class="PARAMETER">attribute_name</replaceable> <replaceable class="PARAMETER">data_type</replaceable> [ COLLATE <replaceable>collation</replaceable> ] [, ... ] ] )

CREATE TYPE <replaceable class="parameter">name</replaceable> AS ENUM
    ( [ '<replaceable class="parameter">label</replaceable>' [, ... ] ] )

CREATE TYPE <replaceable class="parameter">name</replaceable> AS RANGE (
    SUBTYPE = <replaceable class="parameter">subtype</replaceable>
    [ , SUBTYPE_OPCLASS = <replaceable class="parameter">subtype_operator_class</replaceable> ]
    [ , COLLATION = <replaceable class="parameter">collation</replaceable> ]
    [ , CANONICAL = <replaceable class="parameter">canonical_function</replaceable> ]
    [ , SUBTYPE_DIFF = <replaceable class="parameter">subtype_diff_function</replaceable> ]
)

CREATE TYPE <replaceable class="parameter">name</replaceable> (
    INPUT = <replaceable class="parameter">input_function</replaceable>,
    OUTPUT = <replaceable class="parameter">output_function</replaceable>
    [ , RECEIVE = <replaceable class="parameter">receive_function</replaceable> ]
    [ , SEND = <replaceable class="parameter">send_function</replaceable> ]
    [ , TYPMOD_IN = <replaceable class="parameter">type_modifier_input_function</replaceable> ]
    [ , TYPMOD_OUT = <replaceable class="parameter">type_modifier_output_function</replaceable> ]
    [ , ANALYZE = <replaceable class="parameter">analyze_function</replaceable> ]
    [ , INTERNALLENGTH = { <replaceable class="parameter">internallength</replaceable> | VARIABLE } ]
    [ , PASSEDBYVALUE ]
    [ , ALIGNMENT = <replaceable class="parameter">alignment</replaceable> ]
    [ , STORAGE = <replaceable class="parameter">storage</replaceable> ]
    [ , LIKE = <replaceable class="parameter">like_type</replaceable> ]
    [ , CATEGORY = <replaceable class="parameter">category</replaceable> ]
    [ , PREFERRED = <replaceable class="parameter">preferred</replaceable> ]
    [ , DEFAULT = <replaceable class="parameter">default</replaceable> ]
    [ , ELEMENT = <replaceable class="parameter">element</replaceable> ]
    [ , DELIMITER = <replaceable class="parameter">delimiter</replaceable> ]
    [ , COLLATABLE = <replaceable class="parameter">collatable</replaceable> ]
)

CREATE TYPE <replaceable class="parameter">name</replaceable>
</synopsis>
 </refsynopsisdiv>

 <refsect1>
<!--
  <title>Description</title>
-->
  <title>説明</title>

  <para>
<!--
   <command>CREATE TYPE</command> registers a new data type for use in
   the current database.  The user who defines a type becomes its
   owner.
-->
<command>CREATE TYPE</command>は、現在のデータベースで使用できる新しいデータ型を登録します。
型を定義したユーザがその所有者となります。
  </para>

  <para>
<!--
   If a schema name is given then the type is created in the specified
   schema.  Otherwise it is created in the current schema.  The type
   name must be distinct from the name of any existing type or domain
   in the same schema.  (Because tables have associated data types,
   the type name must also be distinct from the name of any existing
   table in the same schema.)
-->
スキーマ名が与えられている場合、型は指定されたスキーマに作成されます。
スキーマ名がなければ、その型は現在のスキーマに作成されます。
型名は、同じスキーマにある既存の型もしくはドメインとは、異なる名前にする必要があります
（さらに、テーブルはデータ型と関連しているため、データ型名は同じスキーマのテーブル名とも競合しないようにしてください）。
  </para>

  <para>
<!--
   There are five forms of <command>CREATE TYPE</command>, as shown in the
   syntax synopsis above.  They respectively create a <firstterm>composite
   type</>, an <firstterm>enum type</>, a <firstterm>range type</>, a
   <firstterm>base type</>, or a <firstterm>shell type</>.  The first four
   of these are discussed in turn below.  A shell type is simply a placeholder
   for a type to be defined later; it is created by issuing <command>CREATE
   TYPE</command> with no parameters except for the type name.  Shell types
   are needed as forward references when creating range types and base types,
   as discussed in those sections.
-->
上の構文概要に示すように、<command>CREATE TYPE</command>には５つの構文があります。
これらはそれぞれ、<firstterm>複合型</>, <firstterm>列挙型</>、<firstterm>範囲型</>、<firstterm>基本型</>、<firstterm>シェル型</>を作成します。
これらの内最初の４個についてはここで順番に説明します。
シェル型は、後で定義される型用の単なるプレースホルダで、型名以外のパラメータをつけずに<command>CREATE TYPE</command>を実行することで作成されます。
シェル型は、範囲型と基本型を作成するときの前方参照として必要となるもので、それぞれの節で説明します。
  </para>

  <refsect2>
<!--
   <title>Composite Types</title>
-->
   <title>複合型</title>

  <para>
<!--
   The first form of <command>CREATE TYPE</command>
   creates a composite type.
   The composite type is specified by a list of attribute names and data types.
   An attribute's collation can be specified too, if its data type is
   collatable.  A composite type is essentially the same as the row type
   of a table, but using <command>CREATE TYPE</command> avoids the need to
   create an actual table when all that is wanted is to define a type.
   A stand-alone composite type is useful, for example, as the argument or
   return type of a function.
-->
<command>CREATE TYPE</command>の最初の構文を使用すると、複合型を作成できます。
複合型は、属性名およびデータ型のリストにより指定されます。
データ型の照合順序が設定可能である場合、属性の照合順序も指定することができます。
複合型は本質的にはテーブルの行型と同じです。
しかし、型を定義することだけが必要なのであれば、<command>CREATE TYPE</command>を使用することで、実際のテーブルを作成する必要がなくなります。
スタンドアロンの複合型は、例えば関数の引数や戻り値の型として有用です。
  </para>

  <para>
<!--
   To be able to create a composite type, you must
   have <literal>USAGE</literal> privilege on all attribute types.
-->
複合型を作成するためには、すべての属性型に対して<literal>USAGE</literal>権限を持たなければなりません。
  </para>
  </refsect2>

  <refsect2 id="SQL-CREATETYPE-enum">
<!--
   <title>Enumerated Types</title>
-->
   <title>列挙型</title>


   <para>
<!--
    The second form of <command>CREATE TYPE</command> creates an enumerated
    (enum) type, as described in <xref linkend="datatype-enum">.
    Enum types take a list of one or more quoted labels, each of which
    must be less than <symbol>NAMEDATALEN</symbol> bytes long (64 bytes in a
    standard <productname>PostgreSQL</productname> build).
-->
<command>CREATE TYPE</command>の2つ目の構文を使用すると、<xref linkend="datatype-enum">で説明する列挙型（enum）を作成します。
列挙型は、1つ以上の引用符付きのラベルのリストを取ります。
ラベルは<symbol>NAMEDATALEN</symbol>（<productname>PostgreSQL</productname>の標準のビルドでは64バイト）バイトよりも少ない長さでなければなりません。
   </para>
  </refsect2>

  <refsect2 id="SQL-CREATETYPE-RANGE">
<!--
   <title>Range Types</title>
-->
   <title>範囲型</title>

   <para>
<!--
    The third form of <command>CREATE TYPE</command> creates a new
    range type, as described in <xref linkend="rangetypes">.
-->
<command>CREATE TYPE</command>の三番目の構文は、<xref linkend="rangetypes">で説明する範囲型を新規に作成します。
   </para>

   <para>
<!--
    The range type's <replaceable class="parameter">subtype</replaceable> can
    be any type with an associated b-tree operator class (to determine the
    ordering of values for the range type).  Normally the subtype's default
    b-tree operator class is used to determine ordering; to use a non-default
    operator class, specify its name with <replaceable
    class="parameter">subtype_opclass</replaceable>.  If the subtype is
    collatable, and you want to use a non-default collation in the range's
    ordering, specify the desired collation with the <replaceable
    class="parameter">collation</replaceable> option.
-->
範囲型の<replaceable class="parameter">subtype</replaceable>は、関連する（範囲型の値を順序を決定するための）b-tree演算子クラスを持つ任意の型を取ることができます。
通常、派生元型のデフォルトのb-tree演算子クラスが順序を決定するために使用されます。
デフォルト以外の演算子クラスを使用するためには、<replaceable class="parameter">subtype_opclass</replaceable>でその名前を指定してください。
派生元型が照合順序変更可能であり、範囲の順序付けでデフォルト以外の照合順序を使用したい場合は、<replaceable class="parameter">collation</replaceable>オプションで使用したい照合順序を指定してください。
   </para>

   <para>
<!--
    The optional <replaceable class="parameter">canonical</replaceable>
    function must take one argument of the range type being defined, and
    return a value of the same type.  This is used to convert range values
    to a canonical form, when applicable.  See <xref
    linkend="rangetypes-defining"> for more information.  Creating a
    <replaceable class="parameter">canonical</replaceable> function
    is a bit tricky, since it must be defined before the range type can be
    declared.  To do this, you must first create a shell type, which is a
    placeholder type that has no properties except a name and an
    owner.  This is done by issuing the command <literal>CREATE TYPE
    <replaceable>name</></literal>, with no additional parameters.  Then
    the function can be declared using the shell type as argument and result,
    and finally the range type can be declared using the same name.  This
    automatically replaces the shell type entry with a valid range type.
-->
<replaceable class="parameter">canonical</replaceable>関数(省略可能)は、定義する範囲型の引数を１つ取り、同じ型の値を返さなければなりません。
これは適切な時に範囲値を正規形式に変換するために使用されます。
詳細については<xref linkend="rangetypes-defining">を参照してください。
<replaceable class="parameter">canonical</replaceable>関数を作成することは多少厄介です、というのは、範囲型を定義できるようになる前に定義されている必要があるからです。
このためには、まず、名前と所有者以外の属性を持たないプレースホルダであるシェル型を作成しなければなりません。
これは、他にパラメータをつけずに<literal>CREATE TYPE <replaceable>name</></literal>を実行することで行われます。
その後、このシェル型を引数と結果として使用する関数を宣言することができます。
最後に同じ名前を用いて範囲型を宣言することができます。
これは自動的にシェル型の項目を有効な範囲型に置き換えます。
   </para>

   <para>
<!--
    The optional <replaceable class="parameter">subtype_diff</replaceable>
    function must take two values of the
    <replaceable class="parameter">subtype</replaceable> type as argument,
    and return a <type>double precision</type> value representing the
    difference between the two given values.  While this is optional,
    providing it allows much greater efficiency of GiST indexes on columns of
    the range type.  See <xref linkend="rangetypes-defining"> for more
    information.
-->
<replaceable class="parameter">subtype_diff</replaceable>関数(省略可能)は、<replaceable class="parameter">subtype</replaceable>型の２つの値を引数として取り、与えられた２つの値の差異を表す<type>double precision</type>型を返さなければなりません。
これは省略することができますが、提供することでその範囲型の列に対するGiSTインデックスの効率を大きく向上させることができます。
詳細については<xref linkend="rangetypes-defining">を参照してください。
   </para>
  </refsect2>

  <refsect2>
<!--
   <title>Base Types</title>
-->
   <title>基本型</title>

  <para>
<!--
   The fourth form of <command>CREATE TYPE</command> creates a new base type
   (scalar type).  To create a new base type, you must be a superuser.
   (This restriction is made because an erroneous type definition could
   confuse or even crash the server.)
-->
<command>CREATE TYPE</command>の４つ目の構文を使用すると、基本型（スカラ型）を新しく作成できます。
新しい基本型を作成するにはスーパーユーザでなければなりません。
（エラーがある型定義が混乱を招き、サーバがクラッシュすることすらあるため、この制限がなされました。）
  </para>

  <para>
<!--
   The parameters can appear in any order, not only that
   illustrated above, and most are optional.  You must register
   two or more functions (using <command>CREATE FUNCTION</command>) before
   defining the type.  The support functions
   <replaceable class="parameter">input_function</replaceable> and
   <replaceable class="parameter">output_function</replaceable>
   are required, while the functions
   <replaceable class="parameter">receive_function</replaceable>,
   <replaceable class="parameter">send_function</replaceable>,
   <replaceable class="parameter">type_modifier_input_function</replaceable>,
   <replaceable class="parameter">type_modifier_output_function</replaceable> and
   <replaceable class="parameter">analyze_function</replaceable>
   are optional.  Generally these functions have to be coded in C
   or another low-level language.
-->
パラメータは、上述の順番である必要はなく、任意の順番で指定することができ、多くは省略可能です。
型を定義する前に、（<command>CREATE FUNCTION</command>を用いて）2つ以上の関数を登録しておく必要があります。
サポート関数である<replaceable class="parameter">input_function</replaceable>と<replaceable class="parameter">output_function</replaceable>は必須です。
<replaceable class="parameter">receive_function</replaceable>関数、<replaceable class="parameter">send_function</replaceable>関数、<replaceable class="parameter">type_modifier_input_function</replaceable>関数、<replaceable class="parameter">type_modifier_output_function</replaceable>関数、および<replaceable class="parameter">analyze_function</replaceable>関数は省略可能です。
通常、これらの関数は、C言語やその他の低レベル言語で作成されなければなりません。
  </para>

  <para>
<!--
   The <replaceable class="parameter">input_function</replaceable>
   converts the type's external textual representation to the internal
   representation used by the operators and functions defined for the type.
   <replaceable class="parameter">output_function</replaceable>
   performs the reverse transformation.  The input function can be
   declared as taking one argument of type <type>cstring</type>,
   or as taking three arguments of types
   <type>cstring</type>, <type>oid</type>, <type>integer</type>.
   The first argument is the input text as a C string, the second
   argument is the type's own OID (except for array types, which instead
   receive their element type's OID),
   and the third is the <literal>typmod</> of the destination column, if known
   (-1 will be passed if not).
   The input function must return a value of the data type itself.
   Usually, an input function should be declared STRICT; if it is not,
   it will be called with a NULL first parameter when reading a NULL
   input value.  The function must still return NULL in this case, unless
   it raises an error.
   (This case is mainly meant to support domain input functions, which
   might need to reject NULL inputs.)
   The output function must be
   declared as taking one argument of the new data type.
   The output function must return type <type>cstring</type>.
   Output functions are not invoked for NULL values.
-->
<replaceable class="parameter">input_function</replaceable>は、型のテキストによる外部表現を内部表現形式に変換するものであり、その型用に定義される演算子や関数で使用されます。
<replaceable class="parameter">output_function</replaceable>はこの逆の変換を行うものです。
入力関数は、1つの<type>cstring</type>型の引数、あるいは、<type>cstring</type>型、<type>oid</type>型、<type>integer</type>型という3つの引数を取るように宣言されます。
最初の引数にはC言語文字列の入力テキスト、2番目には型自体のOID（配列型の場合は例外で要素の型のOIDとなります）、3番目は、判明していれば対象列の<literal>typmod</>を渡します
（不明な場合は-1を渡します）。
この入力関数では、データ型自身の値を返さなければなりません。 
通常入力関数はSTRICTとして宣言しなければなりません。
そうしないと、NULLという入力値を読み取った時、NULLという最初のパラメータを持って呼び出されます。
この場合でもエラーを発生させるのでなければ、関数はNULLを返さなければなりません。
（こうした状況はほとんどの場合、ドメイン入力関数をサポートすることを意図しています。ドメイン入力関数ではNULL入力を拒絶しなければならない可能性があります。）
出力関数は、新しいデータ型の引数を1つ取るように宣言しなければなりません。
出力関数は、<type>cstring</type>型を返さなければなりません。
出力関数はNULL値に対して呼び出されることはありません。
  </para>

  <para>
<!--
   The optional <replaceable class="parameter">receive_function</replaceable>
   converts the type's external binary representation to the internal
   representation.  If this function is not supplied, the type cannot
   participate in binary input.  The binary representation should be
   chosen to be cheap to convert to internal form, while being reasonably
   portable.  (For example, the standard integer data types use network
   byte order as the external binary representation, while the internal
   representation is in the machine's native byte order.)  The receive
   function should perform adequate checking to ensure that the value is
   valid.
   The receive function can be declared as taking one argument of type
   <type>internal</type>, or as taking three arguments of types
   <type>internal</type>, <type>oid</type>, <type>integer</type>.
   The first argument is a pointer to a <type>StringInfo</type> buffer
   holding the received byte string; the optional arguments are the
   same as for the text input function.
   The receive function must return a value of the data type itself.
   Usually, a receive function should be declared STRICT; if it is not,
   it will be called with a NULL first parameter when reading a NULL
   input value.  The function must still return NULL in this case, unless
   it raises an error.
   (This case is mainly meant to support domain receive functions, which
   might need to reject NULL inputs.)
   Similarly, the optional
   <replaceable class="parameter">send_function</replaceable> converts
   from the internal representation to the external binary representation.
   If this function is not supplied, the type cannot participate in binary
   output.  The send function must be
   declared as taking one argument of the new data type.
   The send function must return type <type>bytea</type>.
   Send functions are not invoked for NULL values.
-->
<replaceable class="parameter">receive_function</replaceable>では、型のバイナリによる外部表現を内部表現に変換します。この関数は省略可能です。
この関数が与えられない場合、この型ではバイナリ入力を行うことができません。
バイナリ表現の方法は、適度な可搬性を保ちつつ、内部表現への変換コストが小さくなるよう選択すべきです
（例えば標準の整数データ型は、外部バイナリ表現としてはネットワークバイトオーダを使用し、内部表現ではマシン固有のバイトオーダを使用します）。
この受信関数では、値が有効かどうかを判定するための適切な検査を行わなければなりません。
受信関数は、<type>internal</type>型の引数1つ、または、<type>internal</type>型と<type>oid</type>、<type>integer</type>型の3つの引数を取るように宣言されます。
最初の引数は受信したバイト文字列を保持する<type>StringInfo</type>バッファへのポインタ、省略可能な引数は、テキスト入力関数の説明と同じです。
受信関数は、データ型自体の値を返す必要があります。
通常受信関数はSTRICTとして宣言しなければなりません。
そうしないと、NULLという入力値を読み取った時、NULLという最初のパラメータを持って呼び出されます。
この場合でも関数はエラーを発生させるのでなければNULLを返さなければなりません。
（こうした状況はほとんどの場合、ドメイン受信関数をサポートすることを意図しています。ドメイン受信関数ではNULL入力を拒絶しなければならない可能性があります。）
同様に、<replaceable class="parameter">send_function</replaceable>は、内部表現からバイナリによる外部表現に変換します。この関数も省略可能です。
この関数が与えられない場合、この型ではバイナリ出力を行うことができません。
この送信関数は、新しいデータ型の引数1つを取るように宣言しなければなりません。
送信関数は<type>bytea</type>型を返さなければなりません。
送信関数はNULL値に対して呼び出されません。
  </para>

  <para>
<!--
   You should at this point be wondering how the input and output functions
   can be declared to have results or arguments of the new type, when they
   have to be created before the new type can be created.  The answer is that
   the type should first be defined as a <firstterm>shell type</>, which is a
   placeholder type that has no properties except a name and an owner.  This
   is done by issuing the command <literal>CREATE TYPE
   <replaceable>name</></literal>, with no additional parameters.  Then the
   I/O functions can be defined referencing the shell type.  Finally,
   <command>CREATE TYPE</> with a full definition replaces the shell entry
   with a complete, valid type definition, after which the new type can be
   used normally.
-->
ここで、新しいデータ型を作成する前に入力関数と出力関数を作成する必要があるのに、どのようにしてそれらの関数で新しいデータ型を戻り値や入力として宣言できるのか、疑問に思うかもしれません。
その答えは、まず型が最初に<firstterm>シェル型</>として定義されます。
これは名称と所有者以外の属性を持たないプレースホルダ型です。
これは、コマンド<literal>CREATE TYPE <replaceable>name</></literal>を他にパラメータをつけずに発行することで行われます。
この後、入出力関数をこのシェル型を参照するように定義することができます。
最後に完全な定義を持った<command>CREATE TYPE</>によって、シェル型の項目が完全かつ有効な型定義に置き換わり、新しい型を普通に使用することができるようになります。
  </para>

  <para>
<!--
   The optional
   <replaceable class="parameter">type_modifier_input_function</replaceable>
   and <replaceable class="parameter">type_modifier_output_function</replaceable>
   are needed if the type supports modifiers, that is optional constraints
   attached to a type declaration, such as <literal>char(5)</> or
   <literal>numeric(30,2)</>.  <productname>PostgreSQL</productname> allows
   user-defined types to take one or more simple constants or identifiers as
   modifiers.  However, this information must be capable of being packed into a
   single non-negative integer value for storage in the system catalogs.  The
   <replaceable class="parameter">type_modifier_input_function</replaceable>
   is passed the declared modifier(s) in the form of a <type>cstring</>
   array.  It must check the values for validity (throwing an error if they
   are wrong), and if they are correct, return a single non-negative
   <type>integer</> value that will be stored as the column <quote>typmod</>.
   Type modifiers will be rejected if the type does not have a
   <replaceable class="parameter">type_modifier_input_function</replaceable>.
   The <replaceable class="parameter">type_modifier_output_function</replaceable>
   converts the internal integer typmod value back to the correct form for
   user display.  It must return a <type>cstring</> value that is the exact
   string to append to the type name; for example <type>numeric</>'s
   function might return <literal>(30,2)</>.
   It is allowed to omit the
   <replaceable class="parameter">type_modifier_output_function</replaceable>,
   in which case the default display format is just the stored typmod integer
   value enclosed in parentheses.
-->
<replaceable class="parameter">type_modifier_input_function</replaceable>と<replaceable class="parameter">type_modifier_output_function</replaceable>は必須ではありませんが、型が修飾子をサポートする場合は必要です。
修飾子とは、<literal>char(5)</>や<literal>numeric(30,2)</>などの型宣言に付与されるオプションの制約です。
<productname>PostgreSQL</productname>では、ユーザ定義型が1つ以上の整数定数または識別子を修飾子として取ることができます。
しかし、この情報はシステムカタログに格納される時に0以上の整数1つにまとめられるものでなければなりません。
<replaceable class="parameter">type_modifier_input_function</replaceable>には、<type>cstring</>型配列の形で宣言された修飾子が渡されます。
その値について妥当性を検査しなければなりません（不当な場合はエラーとします）。
そして、正しい場合は、<quote>typmod</>列として格納される、0以上の<type>integer</>値を1つ返さなければなりません。
型が<replaceable class="parameter">type_modifier_input_function</replaceable>を持たない場合、型修飾子は拒否されます。
<replaceable class="parameter">type_modifier_output_function</replaceable>は内部的な整数typmod値をユーザ側の表示に合わせて変換します。
この関数は型名に付与する正確な文字列となる<type>cstring</>値を返さなければなりません。
たとえば<type>numeric</>用の関数では<literal>(30,2)</>を返すかもしれません。
デフォルトの表示用書式が保管されたtypmod整数値を括弧で括ったものと一致している場合は、<replaceable class="parameter">type_modifier_output_function</replaceable>を省略することができます。

  </para>

  <para>
<!--
   The optional <replaceable class="parameter">analyze_function</replaceable>
   performs type-specific statistics collection for columns of the data type.
   By default, <command>ANALYZE</> will attempt to gather statistics using
   the type's <quote>equals</> and <quote>less-than</> operators, if there
   is a default b-tree operator class for the type.  For non-scalar types
   this behavior is likely to be unsuitable, so it can be overridden by
   specifying a custom analysis function.  The analysis function must be
   declared to take a single argument of type <type>internal</>, and return
   a <type>boolean</> result.  The detailed API for analysis functions appears
   in <filename>src/include/commands/vacuum.h</>.
-->
オプションの<replaceable class="parameter">analyze_function</replaceable>は、このデータ型の列に対する、型固有の統計情報の収集を行います。
その型用のデフォルトのB-tree演算子クラスがあれば、<command>ANALYZE</>はデフォルトでは型の<quote>等価</>演算子と<quote>小なり</>演算子を使用して統計情報を集めようと試みます。
非スカラ型には、この振舞いはあまり適していません。
そのため、独自の解析関数を指定することで、この振舞いを上書きすることができます。
この解析関数は、<type>internal</>型の引数を1つ取り、戻り値として<type>boolean</>を返すように宣言する必要があります。
解析関数用のAPIの詳細は、<filename>src/include/commands/vacuum.h</>にあります。
  </para>

  <para>
<!--
   While the details of the new type's internal representation are only
   known to the I/O functions and other functions you create to work with
   the type, there are several properties of the internal representation
   that must be declared to <productname>PostgreSQL</productname>.
   Foremost of these is
   <replaceable class="parameter">internallength</replaceable>.
   Base data types can be fixed-length, in which case
   <replaceable class="parameter">internallength</replaceable> is a
   positive integer, or variable  length, indicated by setting
   <replaceable class="parameter">internallength</replaceable>
   to <literal>VARIABLE</literal>.  (Internally, this is represented
   by setting <literal>typlen</> to -1.)  The internal representation of all
   variable-length types must start with a 4-byte integer giving the total
   length of this value of the type.
-->
新しい型の内部表現の詳細を理解しなければならないのは、これらのI/O関数とその型に関連して動作するユーザ定義の関数のみですが、内部表現には、<productname>PostgreSQL</productname>に対し宣言しなければならない複数の属性値があります。
属性の中で最も重要なものは<replaceable class="parameter">internallength</replaceable>です。
基本データ型は、<replaceable class="parameter">internallength</replaceable>に正の整数を指定して固定長として作成するだけでなく、<replaceable class="parameter">internallength</replaceable>に<literal>VARIABLE</literal>と設定し可変長として作成することもできます
（内部的には、これは<literal>typlen</>を-1に設定することで表現されます）。  
全ての可変長型の内部表現は、型の値の全長を示す4バイトの整数値から始まらなければなりません。

  </para>

  <para>
<!--
   The optional flag <literal>PASSEDBYVALUE</literal> indicates that
   values of this data type are passed by value, rather than by
   reference.  You cannot pass by value types whose internal
   representation is larger than the size of the <type>Datum</> type
   (4 bytes on most machines, 8 bytes on a few).
-->
オプションの<option>PASSEDBYVALUE</option>フラグは、このデータ型の値が参照ではなく値によって渡されることを示します。
<type>Datum</>型のサイズ（ほとんどのマシンでは4バイトだが、まれに8バイト）よりも長い内部表現の型は値で渡すことができません。
  </para>

  <para>
<!--
   The <replaceable class="parameter">alignment</replaceable> parameter
   specifies the storage alignment required for the data type.  The
   allowed values equate to alignment on 1, 2, 4, or 8 byte boundaries.
   Note that variable-length types must have an alignment of at least
   4, since they necessarily contain an <type>int4</> as their first component.
-->
<replaceable class="parameter">alignment</replaceable>パラメータは、そのデータ型の格納の際に必要な整列を指定します。
設定可能な値は、1、2、4、8バイト境界での整列です。
可変長の型は最低でも4の整列を持たなければならないことに注意してください。
最初の要素として<type>int4</>を持たなければならないからです。
  </para>

  <para>
<!--
   The <replaceable class="parameter">storage</replaceable> parameter
   allows selection of storage strategies for variable-length data
   types.  (Only <literal>plain</literal> is allowed for fixed-length
   types.)  <literal>plain</literal> specifies that data of the type
   will always be stored in-line and not compressed.
   <literal>extended</literal> specifies that the system will first
   try to compress a long data value, and will move the value out of
   the main table row if it's still too long.
   <literal>external</literal> allows the value to be moved out of the
   main table, but the system will not try to compress it.
   <literal>main</literal> allows compression, but discourages moving
   the value out of the main table.  (Data items with this storage
   strategy might still be moved out of the main table if there is no
   other way to make a row fit, but they will be kept in the main
   table preferentially over <literal>extended</literal> and
   <literal>external</literal> items.)
-->
<replaceable class="parameter">storage</replaceable>パラメータを使用することで、可変長データ型を格納する際の戦略を選択することができます
（固定長の型には<literal>plain</literal>のみが使用できます）。
<literal>plain</literal>を指定すると、その型のデータは常にインラインで格納され、圧縮されません。
<literal>extended</literal>を指定すると、システムはまず長いデータ値を圧縮しようとし、それでもまだ長過ぎる場合は値をメインテーブルの行から削除して移動します。
<literal>external</literal>はメインテーブルから値を削除して移動することを許しますが、システムはデータを圧縮しようとしません。
<literal>main</literal>はデータの圧縮を許しますが、できるだけ値をメインテーブルから削除しないようにします
（行を収めるために他に方法がない場合にはメインテーブルから削除されてしまう可能性がありますが、<literal>extended</literal>や<literal>external</literal>が指定されたアイテムよりも優先してメインテーブルに残されます）。
  </para>

  <para>
<!--
   The <replaceable class="parameter">like_type</replaceable> parameter
   provides an alternative method for specifying the basic representation
   properties of a data type: copy them from some existing type. The values of
   <replaceable class="parameter">internallength</replaceable>,
   <replaceable class="parameter">passedbyvalue</replaceable>,
   <replaceable class="parameter">alignment</replaceable>, and
   <replaceable class="parameter">storage</replaceable> are copied from the
   named type.  (It is possible, though usually undesirable, to override
   some of these values by specifying them along with the <literal>LIKE</>
   clause.)  Specifying representation this way is especially useful when
   the low-level implementation of the new type <quote>piggybacks</> on an
   existing type in some fashion.
-->
<replaceable class="parameter">like_type</replaceable>パラメータは、何らかの既存のデータ型から複製するという、データ型の基本表現プロパティを指定する、別の方法を提供します。
<replaceable class="parameter">internallength</replaceable>、<replaceable class="parameter">passedbyvalue</replaceable>、<replaceable class="parameter">alignment</replaceable>、<replaceable class="parameter">storage</replaceable>の値が指定された型から複製されます。
（通常は望ましくありませんが、<literal>LIKE</>句と一緒にこれらの値を指定することで、値を上書きすることも可能です。）
新しい型の低レベル実装にある流儀に従った既存の型を<quote>移す</>時に、この方法で表現を指定することが特に有用です。
  </para>

  <para>
<!--
   The <replaceable class="parameter">category</replaceable> and
   <replaceable class="parameter">preferred</replaceable> parameters can be
   used to help control which implicit cast will be applied in ambiguous
   situations.  Each data type belongs to a category named by a single ASCII
   character, and each type is either <quote>preferred</> or not within its
   category.  The parser will prefer casting to preferred types (but only from
   other types within the same category) when this rule is helpful in
   resolving overloaded functions or operators.  For more details see <xref
   linkend="typeconv">.  For types that have no implicit casts to or from any
   other types, it is sufficient to leave these settings at the defaults.
   However, for a group of related types that have implicit casts, it is often
   helpful to mark them all as belonging to a category and select one or two
   of the <quote>most general</> types as being preferred within the category.
   The <replaceable class="parameter">category</replaceable> parameter is
   especially useful when adding a user-defined type to an existing built-in
   category, such as the numeric or string types.  However, it is also
   possible to create new entirely-user-defined type categories.  Select any
   ASCII character other than an upper-case letter to name such a category.
-->
<replaceable class="parameter">category</replaceable>と<replaceable class="parameter">preferred</replaceable>パラメータは、あいまいな状況でどの暗黙的なキャストが適用されるかについての制御を補助するために使用することができます。
各データ型は単一のASCII文字で命名されるカテゴリに属しています。
そして、各型はそのカテゴリで<quote>好まれる（preferred）</>か否かを持ちます。
パーサは（同一のカテゴリ内の他の型からの）好まれる型へのキャストを、この規則が上書きされた関数または演算子の解決に有用な場合に優先します。
より詳細は<xref linkend="typeconv">を参照してください。
他の型への、または、ほかの型からの暗黙的なキャストを持たない型では、これらの設定をデフォルトのままにしておくことで十分です。
しかし、暗黙的なキャストを持つ関連する型のグループでは、それらすべてをカテゴリに属し、カテゴリ内で好まれるものとしてその1つまたは2つの<quote>最も一般的な</>型を選択することが有用となる場合が多くあります。
ユーザ定義型を、数値型や文字列型などの既存の組み込みカテゴリに追加する場合に、<replaceable class="parameter">category</replaceable>パラメータは特に有用です。
しかし、すべてがユーザ定義型のカテゴリを作成することもできます。
カテゴリの命名には大文字以外の任意のASCII文字を選択してください。
  </para>

  <para>
<!--
   A default value can be specified, in case a user wants columns of the
   data type to default to something other than the null value.
   Specify the default with the <literal>DEFAULT</literal> key word.
   (Such a default can be overridden by an explicit <literal>DEFAULT</literal>
   clause attached to a particular column.)
-->
ユーザがそのデータ型の列のデフォルトをNULL以外にしたい場合は、デフォルト値を指定することができます。
デフォルト値は<option>DEFAULT</option>キーワードで指定してください
（この方法で指定されたデフォルト値を、特定の列に付与された、明示的な<option>DEFAULT</option>句によって上書きすることができます）。
  </para>

  <para>
<!--
   To indicate that a type is an array, specify the type of the array
   elements using the <literal>ELEMENT</> key word.  For example, to
   define an array of 4-byte integers (<type>int4</type>), specify
   <literal>ELEMENT = int4</literal>. More details about array types
   appear below.
-->
データ型が配列であることを示すには、<option>ELEMENT</>キーワードを使用して配列要素の型を指定してください。
例えば、4バイト整数（<type>int4</type>）の配列を定義するには、<literal>ELEMENT = int4</literal>と指定してください。
配列型の詳細は後述します。
  </para>

  <para>
<!--
   To indicate the delimiter to be used between values in the external
   representation of arrays of this type, <replaceable
   class="parameter">delimiter</replaceable> can be
   set to a specific character.  The default delimiter is the comma
   (<literal>,</literal>).  Note that the delimiter is associated
   with the array element type, not the array type itself.
-->
この型による配列の外部形式における値間の区切り文字を示すために、<replaceable class="parameter">delimiter</replaceable>で特定の文字を設定することができます。
デフォルトの区切り文字はカンマ（'<literal>,</literal>'）です。
この区切り文字は、配列要素の型に関係するものであり、配列型自体に関係するものでないことに注意してください。
  </para>

  <para>
<!--
   If the optional Boolean
   parameter <replaceable class="parameter">collatable</replaceable>
   is true, column definitions and expressions of the type may carry
   collation information through use of
   the <literal>COLLATE</literal> clause.  It is up to the
   implementations of the functions operating on the type to actually
   make use of the collation information; this does not happen
   automatically merely by marking the type collatable.
-->
論理型の<replaceable class="parameter">collatable</replaceable>パラメータ(省略可能)が真の場合、<literal>COLLATE</literal>句を使用することによって、型の列定義と式は照合順序情報を持つことができます。
照合順序情報を実際に使用するかどうかは、型に対する操作を行う関数実装に任されています。
照合順序を設定可能な型を作成することにより、これが自動的に行われることはありません。
  </para>
  </refsect2>

  <refsect2>
<!--
   <title>Array Types</title>
-->
<title>配列型</title>

   <para>
<!--
    Whenever a user-defined type is created,
    <productname>PostgreSQL</productname> automatically creates an
    associated array type, whose name consists of the element type's
    name prepended with an underscore, and truncated if necessary to keep
    it less than <symbol>NAMEDATALEN</symbol> bytes long.  (If the name
    so generated collides with an existing type name, the process is
    repeated until a non-colliding name is found.)
    This implicitly-created array type is variable length and uses the
    built-in input and output functions <literal>array_in</> and
    <literal>array_out</>.  The array type tracks any changes in its
    element type's owner or schema, and is dropped if the element type is.
-->
ユーザ定義型が作成されると、<productname>PostgreSQL</productname>は、自動的に関連する配列型を作成します。
その要素型の名前の前にアンダースコアを付け、必要に応じて<symbol>NAMEDATALEN</symbol>長より短くなるように切り詰められた名前になります。
（こうして付けられた名前が既存の型名と競合する場合、競合する名称がなくなるまでこの処理が繰り返されます。）
この暗黙的に作成される配列型は可変長で、組み込み入出力関数<literal>array_in</>と<literal>array_out</>を使用します。
配列型はその要素となる型の所有者とスキーマのなんらかの変更に追従し、また、要素となる型が削除された場合に削除されます。
   </para>

   <para>
<!--
    You might reasonably ask why there is an <option>ELEMENT</>
    option, if the system makes the correct array type automatically.
    The only case where it's useful to use <option>ELEMENT</> is when you are
    making a fixed-length type that happens to be internally an array of a number of
    identical things, and you want to allow these things to be accessed
    directly by subscripting, in addition to whatever operations you plan
    to provide for the type as a whole.  For example, type <type>point</>
    is represented as just two floating-point numbers, each can be accessed using
    <literal>point[0]</> and <literal>point[1]</>.
    Note that
    this facility only works for fixed-length types whose internal form
    is exactly a sequence of identical fixed-length fields.  A subscriptable
    variable-length type must have the generalized internal representation
    used by <literal>array_in</> and <literal>array_out</>.
    For historical reasons (i.e., this is clearly wrong but it's far too
    late to change it), subscripting of fixed-length array types starts from
    zero, rather than from one as for variable-length arrays.
-->
「システムが自動的に配列型を正しく作成するのであれば、<option>ELEMENT</>オプションはどうして存在するのだろう」と疑問に思うのも道理です疑問に思うのも道理です。
<option>ELEMENT</>が意味を持つ、唯一の場合は次のような条件を満たす固定長の型を作成する時です。
その条件とは、内部的に大量の同一の要素からなる配列となっていること、その配列に対して添字を指定して直接アクセスできること、加えて、今後作成する型全体に対する操作がどのようなものであっても、それらから直接アクセスできることです。
例えば、<type>point</>型では、その構成要素である2つの浮動小数点にそれぞれ<literal>point[0]</>および<literal>point[1]</>を用いてアクセスすることができます。
この機能は、その内部形式が同一の固定長フィールドの正確な並びである、固定長の型でのみ動作することに注意してください。
添字による指定が可能な可変長型は、<literal>array_in</>と<literal>array_out</>を使用して、一般化された内部表現を持つ必要があります。 
歴史的な理由（明らかに間違いなのですが、変更するには遅すぎたため）により、固定長配列型への要素番号指定は0から始まり、可変長配列の場合は1から始まります。 
   </para>
  </refsect2>
 </refsect1>

 <refsect1>
<!--
  <title>Parameters</title>
-->
  <title>パラメータ</title>

  <variablelist>
   <varlistentry>
    <term><replaceable class="parameter">name</replaceable></term>
    <listitem>
     <para>
<!--
      The name (optionally schema-qualified) of a type to be created.
-->
作成するデータ型の名前です（スキーマ修飾名も可）。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">attribute_name</replaceable></term>
    <listitem>
     <para>
<!--
      The name of an attribute (column) for the composite type.
-->
複合型用の属性（列）名です。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">data_type</replaceable></term>
    <listitem>
     <para>
<!--
      The name of an existing data type to become a column of the
      composite type.
-->
複合型の列となる、既存のデータ型の名前です。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">collation</replaceable></term>
    <listitem>
     <para>
<!--
      The name of an existing collation to be associated with a column of
      a composite type, or with a range type.
-->
複合型の列または範囲型に関連付けされる、既存の照合順序の名前です。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">label</replaceable></term>
    <listitem>
     <para>
<!--
      A string literal representing the textual label associated with
      one value of an enum type.
-->
列挙型の1つの値に関連付けられるテキスト形式のラベルを表す、文字列リテラルです。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">subtype</replaceable></term>
    <listitem>
     <para>
<!--
      The name of the element type that the range type will represent ranges
      of.
-->
範囲型がその範囲の対象として表現する、要素型の名前です。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">subtype_operator_class</replaceable></term>
    <listitem>
     <para>
<!--
      The name of a b-tree operator class for the subtype.
-->
派生元型のb-tree演算子クラスの名前です。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">canonical_function</replaceable></term>
    <listitem>
     <para>
<!--
      The name of the canonicalization function for the range type.
-->
範囲型の正規化関数の名前です。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">subtype_diff_function</replaceable></term>
    <listitem>
     <para>
<!--
      The name of a difference function for the subtype.
-->
派生元型の差異をとる関数の名前です。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">input_function</replaceable></term>
    <listitem>
     <para>
<!--
      The name of a function that converts data from the type's
      external textual form to its internal form.
-->
指定された型のテキストによる外部形式のデータを内部形式に変換する関数の名前です。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">output_function</replaceable></term>
    <listitem>
     <para>
<!--
      The name of a function that converts data from the type's
      internal form to its external textual form.
-->
指定された型の内部形式のデータをテキストによる外部形式に変換する関数の名前です。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">receive_function</replaceable></term>
    <listitem>
     <para>
<!--
      The name of a function that converts data from the type's
      external binary form to its internal form.
-->
指定された型のバイナリによる外部形式のデータを内部形式に変換する関数の名前です。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">send_function</replaceable></term>
    <listitem>
     <para>
<!--
      The name of a function that converts data from the type's
      internal form to its external binary form.
-->
指定された型の内部形式のデータをバイナリによる外部形式に変換する関数の名前です。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">type_modifier_input_function</replaceable></term>
    <listitem>
     <para>
<!--
      The name of a function that converts an array of modifier(s) for the type
      into internal form.
-->
型に関する修飾子の配列を内部形式に変換する関数の名前です。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">type_modifier_output_function</replaceable></term>
    <listitem>
     <para>
<!--
      The name of a function that converts the internal form of the type's
      modifier(s) to external textual form.
-->
内部形式の型修飾子をテキストの外部形式に変換する関数の名前です。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">analyze_function</replaceable></term>
    <listitem>
     <para>
<!--
      The name of a function that performs statistical analysis for the
      data type.
-->
指定したデータ型の統計情報解析を行う関数の名前です。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">internallength</replaceable></term>
    <listitem>
     <para>
<!--
      A numeric constant that specifies the length in bytes of the new
      type's internal representation.  The default assumption is that
      it is variable-length.
-->
新しいデータ型の内部表現のバイト長を表す数値定数です。
デフォルトでは、可変長であるとみなされます。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">alignment</replaceable></term>
    <listitem>
     <para>
<!--
      The storage alignment requirement of the data type.  If specified,
      it must be <literal>char</literal>, <literal>int2</literal>,
      <literal>int4</literal>, or <literal>double</literal>; the
      default is <literal>int4</literal>.
-->
データ型の格納整列条件です。  
このオプションを指定する場合は、<literal>char</literal>、<literal>int2</literal>、<literal>int4</literal>、<literal>double</literal>のいずれかでなければなりません。 
デフォルトは<literal>int4</literal>です。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">storage</replaceable></term>
    <listitem>
     <para>
<!--
      The storage strategy for the data type.  If specified, must be
      <literal>plain</literal>, <literal>external</literal>,
      <literal>extended</literal>, or <literal>main</literal>; the
      default is <literal>plain</literal>.
-->
データ型の格納戦略です。
このオプションを指定する場合は、<literal>plain</literal>、<literal>external</literal>、<literal>extended</literal>、<literal>main</literal>のいずれかでなければなりません。 
デフォルトは<literal>plain</literal>です。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">like_type</replaceable></term>
    <listitem>
     <para>
<!--
      The name of an existing data type that the new type will have the
      same representation as.  The values of
      <replaceable class="parameter">internallength</replaceable>,
      <replaceable class="parameter">passedbyvalue</replaceable>,
      <replaceable class="parameter">alignment</replaceable>, and
      <replaceable class="parameter">storage</replaceable>
      are copied from that type, unless overridden by explicit
      specification elsewhere in this <command>CREATE TYPE</> command.
-->
新しい型に同じ表現を持たせる既存のデータ型の名前です。
<replaceable class="parameter">internallength</replaceable>、<replaceable class="parameter">passedbyvalue</replaceable>、<replaceable class="parameter">alignment</replaceable>、<replaceable class="parameter">storage</replaceable>の値が、この<command>CREATE TYPE</>コマンドのどこかで明示的な指定により上書きされない限り、型から複製されます。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">category</replaceable></term>
    <listitem>
     <para>
<!--
      The category code (a single ASCII character) for this type.
      The default is <literal>'U'</> for <quote>user-defined type</>.
      Other standard category codes can be found in
      <xref linkend="catalog-typcategory-table">.  You may also choose
      other ASCII characters in order to create custom categories.
-->
この型用のカテゴリコード（単一のASCII文字）です。
デフォルトは<quote>ユーザ定義型</>を表す<literal>'U'</>です。
他の標準カテゴリコードを<xref linkend="catalog-typcategory-table">に示します。
独自のカテゴリを作成するために他のASCII文字を選択することもできます。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">preferred</replaceable></term>
    <listitem>
     <para>
<!--
      True if this type is a preferred type within its type category,
      else false.  The default is false.  Be very careful about creating
      a new preferred type within an existing type category, as this
      could cause surprising changes in behavior.
-->
この型がカテゴリ内で優先される型である場合に真、さもなくば偽です。
デフォルトは偽です。
動作に予想外の変化を引き起こしますので既存の型カテゴリに新しく優先される型を作成することには十分注意してください。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">default</replaceable></term>
    <listitem>
     <para>
<!--
      The default value for the data type.  If this is omitted, the
      default is null.
-->
そのデータ型のデフォルト値です。
省略された場合、デフォルトはNULLです。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">element</replaceable></term>
    <listitem>
     <para>
<!--
      The type being created is an array; this specifies the type of
      the array elements.
-->
配列型を作成する場合、その配列の要素の型を指定します。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">delimiter</replaceable></term>
    <listitem>
     <para>
<!--
      The delimiter character to be used between values in arrays made
      of this type.
-->
このデータ型による配列で、値間の区切り文字として使われる文字です。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">collatable</replaceable></term>
    <listitem>
     <para>
<!--
      True if this type's operations can use collation information.
      The default is false.
-->
この型を操作する時に照合順序情報を使用することができる場合に真を取ります。
デフォルトは偽です。
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1 id="SQL-CREATETYPE-notes">
<!--
  <title>Notes</title>
-->
  <title>注釈</title>

  <para>
<!--
   Because there are no restrictions on use of a data type once it's been
   created, creating a base type or range type is tantamount to granting
   public execute permission on the functions mentioned in the type definition.
   This is usually
   not an issue for the sorts of functions that are useful in a type
   definition.  But you might want to think twice before designing a type
   in a way that would require <quote>secret</> information to be used
   while converting it to or from external form.
-->
一度作成したデータ型の使用には制限はありませんので、基本型または範囲型の作成は型定義で言及した関数の実行権をPUBLICに対して付与することと同じです。
この種の型定義において有用な関数では、これは通常問題になりません。
しかし、外部形式から、または、外部形式への変換を行う時に、その関数が<quote>秘密の</>情報を必要とする場合、型を設計する前に熟考してください。
  </para>

  <para>
<!--
   Before <productname>PostgreSQL</productname> version 8.3, the name of
   a generated array type was always exactly the element type's name with one
   underscore character (<literal>_</literal>) prepended.  (Type names were
   therefore restricted in length to one less character than other names.)
   While this is still usually the case, the array type name may vary from
   this in case of maximum-length names or collisions with user type names
   that begin with underscore.  Writing code that depends on this convention
   is therefore deprecated.  Instead, use
   <structname>pg_type</>.<structfield>typarray</> to locate the array type
   associated with a given type.
-->
<productname>PostgreSQL</productname>バージョン8.3より前のバージョンでは、生成される配列型の名前は常に要素型の名前の前に１つのアンダースコア文字（<literal>_</literal>）を付けたものになりました。
（このため型の名前は他の名前よりも1文字短く制限されていました。）
通常はこのように名付けられることは変わりありませんが、最大長の名前の場合やアンダースコアから始まるユーザ定義の型と競合する場合、配列型の名前はこの変換とは変わることがあります。
このため、この規則に依存したコードを書くことは避けてください。
代わりに、<structname>pg_type</>.<structfield>typarray</>を使用して、指定した型に関連した配列型を特定してください。
  </para>

  <para>
<!--
   It may be advisable to avoid using type and table names that begin with
   underscore.  While the server will change generated array type names to
   avoid collisions with user-given names, there is still risk of confusion,
   particularly with old client software that may assume that type names
   beginning with underscores always represent arrays.
-->
アンダースコアから始まる型やテーブル名の使用を避けることが賢明です。
サーバは生成された配列型名称をユーザ指定の名前と競合しないように変更しますが、混乱する危険があります。
特に古いクライアントソフトウェアを使用する場合、名前がアンダースコアから始まる型を常に配列を表すものと想定しているかもしれません。
  </para>

  <para>
<!--
   Before <productname>PostgreSQL</productname> version 8.2, the shell-type
   creation syntax
   <literal>CREATE TYPE <replaceable>name</></literal> did not exist.
   The way to create a new base type was to create its input function first.
   In this approach, <productname>PostgreSQL</productname> will first see
   the name of the new data type as the return type of the input function.
   The shell type is implicitly created in this situation, and then it
   can be referenced in the definitions of the remaining I/O functions.
   This approach still works, but is deprecated and might be disallowed in
   some future release.  Also, to avoid accidentally cluttering
   the catalogs with shell types as a result of simple typos in function
   definitions, a shell type will only be made this way when the input
   function is written in C.
-->
<productname>PostgreSQL</productname>バージョン8.2より前まででは、シェル型を作成する<literal>CREATE TYPE <replaceable>name</></literal>構文は存在しません。
新規に基本型を作成する方法は、最初に入力関数を作成することでした。
この方法では、<productname>PostgreSQL</productname>は新しいデータ型の名称を、入力関数の戻り値型で初めて見ます。
このときに、シェル型が暗黙的に作成され、残りの入出力関数の定義で参照することができます。
この方法もまだ使用できますが、廃止予定であり、将来のリリースで禁止される可能性があります。
また、関数定義における単純なタイプミスの結果作成されるシェル型によって起こるカタログの混乱を防止するため、入力関数がCで作成された場合にのみこの方法によってシェル型が作成されます。
  </para>

  <para>
<!--
   In <productname>PostgreSQL</productname> versions before 7.3, it
   was customary to avoid creating a shell type at all, by replacing the
   functions' forward references to the type name with the placeholder
   pseudotype <type>opaque</>.  The <type>cstring</> arguments and
   results also had to be declared as <type>opaque</> before 7.3.  To
   support loading of old dump files, <command>CREATE TYPE</> will
   accept I/O functions declared using <type>opaque</>, but it will issue
   a notice and change the function declarations to use the correct
   types.
-->
<productname>PostgreSQL</productname> 7.3より前のバージョンでは、関数の下位参照を、プレースホルダとなる疑似データ型である<type>opaque</>型のデータ型名と置き換えることによって、shell型を作成することを完全に、慣習的に避けていました。
また、7.3より前のバージョンでは、<type>cstring</>型の引数および結果も<type>opaque</>型として宣言する必要がありました。
古いダンプファイルのロードをサポートするため、<command>CREATE TYPE</>では<type>opaque</>型を使用するよう宣言された入出力関数を受け入れます。
しかし、注意を促すメッセージを表示し、正しいデータ型を使用するように関数の宣言を変更します。
  </para>

 </refsect1>

 <refsect1>
<!--
  <title>Examples</title>
-->
  <title>例</title>

  <para>
<!--
   This example creates a composite type and uses it in
   a function definition:
-->
次の例では、複合型を作成し、それを関数定義で使用します。
<programlisting>
CREATE TYPE compfoo AS (f1 int, f2 text);

CREATE FUNCTION getfoo() RETURNS SETOF compfoo AS $$
    SELECT fooid, fooname FROM foo
$$ LANGUAGE SQL;
</programlisting>
  </para>

  <para>
<!--
   This example creates an enumerated type and uses it in
   a table definition:
-->
次の例では、列挙型を作成し、それをテーブル定義に使用します。
<programlisting>
CREATE TYPE bug_status AS ENUM ('new', 'open', 'closed');

CREATE TABLE bug (
    id serial,
    description text,
    status bug_status
);
</programlisting>
  </para>

  <para>
<!--
   This example creates a range type:
-->
次の例では、範囲型を作成します。
<programlisting>
CREATE TYPE float8_range AS RANGE (subtype = float8, subtype_diff = float8mi);
</programlisting>
  </para>

  <para>
<!--
   This example creates the base data type <type>box</type> and then uses the
   type in a table definition:
-->
次の例では、基本データ型<type>box</type>を作成し、その型をテーブル定義の中で使用しています。
<programlisting>
CREATE TYPE box;

CREATE FUNCTION my_box_in_function(cstring) RETURNS box AS ... ;
CREATE FUNCTION my_box_out_function(box) RETURNS cstring AS ... ;

CREATE TYPE box (
    INTERNALLENGTH = 16,
    INPUT = my_box_in_function,
    OUTPUT = my_box_out_function
);

CREATE TABLE myboxes (
    id integer,
    description box
);
</programlisting>
  </para>

  <para>
<!--
   If the internal structure of <type>box</type> were an array of four
   <type>float4</> elements, we might instead use:
-->
<type>box</type>型の内部構造が<type>float4</>型が4つの配列の場合、このように書き換えることもできます。
<programlisting>
CREATE TYPE box (
    INTERNALLENGTH = 16,
    INPUT = my_box_in_function,
    OUTPUT = my_box_out_function,
    ELEMENT = float4
);
</programlisting>
<!--
   which would allow a box value's component numbers to be accessed
   by subscripting.  Otherwise the type behaves the same as before.
-->
このようにすると、box値の要素に要素番号でアクセスできます。
その他は、上の例と同様の動作をします。
  </para>

  <para>
<!--
   This example creates a large object type and uses it in
   a table definition:
-->
次の例では、ラージオブジェクト型を作成し、テーブル定義にてそれを使用します。
<programlisting>
CREATE TYPE bigobj (
    INPUT = lo_filein, OUTPUT = lo_fileout,
    INTERNALLENGTH = VARIABLE
);
CREATE TABLE big_objs (
    id integer,
    obj bigobj
);
</programlisting>
  </para>

  <para>
<!--
   More examples, including suitable input and output functions, are
   in <xref linkend="xtypes">.
-->
その他の例は、<xref linkend="xtypes">を参照してください。ここには、入力関数、出力関数などを使った例があります。
  </para>
 </refsect1>

 <refsect1 id="SQL-CREATETYPE-compatibility">
<!--
  <title>Compatibility</title>
-->
<title>互換性</title>

  <para>
<!--
   The first form of the <command>CREATE TYPE</command> command, which
   creates a composite type, conforms to the <acronym>SQL</> standard.
   The other forms are <productname>PostgreSQL</productname>
   extensions.  The <command>CREATE TYPE</command> statement in
   the <acronym>SQL</> standard also defines other forms that are not
   implemented in <productname>PostgreSQL</>.
-->
複合型を作成する、最初の<command>CREATE TYPE</command>コマンドの構文は標準<acronym>SQL</>に従います。
他の構文は<productname>PostgreSQL</productname>の拡張です。
標準<acronym>SQL</>ではまた他の<command>CREATE TYPE</command>構文を定義していますが、<productname>PostgreSQL</>では実装されていません。
  </para>

  <para>
<!--
   The ability to create a composite type with zero attributes is
   a <productname>PostgreSQL</productname>-specific deviation from the
   standard (analogous to the same case in <command>CREATE TABLE</command>).
-->
ゼロ個の要素を持つ複合型を作成する機能は標準から派生した<productname>PostgreSQL</productname>固有のもの（<command>CREATE TABLE</command>の場合と同様）です。
  </para>
 </refsect1>

 <refsect1 id="SQL-CREATETYPE-see-also">
<!--
  <title>See Also</title>
-->
  <title>関連項目</title>

  <simplelist type="inline">
   <member><xref linkend="sql-altertype"></member>
   <member><xref linkend="sql-createdomain"></member>
   <member><xref linkend="sql-createfunction"></member>
   <member><xref linkend="sql-droptype"></member>
  </simplelist>
 </refsect1>

</refentry>
