<!-- doc/src/sgml/func.sgml -->

 <chapter id="functions">
<!--
  <title>Functions and Operators</title>
-->
  <title>関数と演算子</title>

  <indexterm zone="functions">
<!--
   <primary>function</primary>
-->
  <primary>関数</primary>
  </indexterm>

  <indexterm zone="functions">
<!--
   <primary>operator</primary>
-->
   <primary>演算子</primary>
  </indexterm>

  <para>
<!--
   <productname>PostgreSQL</productname> provides a large number of
   functions and operators for the built-in data types.  Users can also
   define their own functions and operators, as described in
   <xref linkend="server-programming"/>.  The
   <application>psql</application> commands <command>\df</command> and
   <command>\do</command> can be used to list all
   available functions and operators, respectively.
-->
<productname>PostgreSQL</productname>は組み込みデータ型に対して数多くの関数と演算子を用意しています。
また、<xref linkend="server-programming"/>で解説しているように、ユーザは独自の関数と演算子を定義することもできます。
<application>psql</application>の<command>\df</command>コマンドと<command>\do</command>コマンドはそれぞれ全ての使用可能な関数と演算子をリストするのに使用されます。
  </para>

  <para>
<!--
   If you are concerned about portability then note that most of
   the functions and operators described in this chapter, with the
   exception of the most trivial arithmetic and comparison operators
   and some explicitly marked functions, are not specified by the
   <acronym>SQL</acronym> standard. Some of this extended functionality
   is present in other <acronym>SQL</acronym> database management
   systems, and in many cases this functionality is compatible and
   consistent between the various implementations.  This chapter is also
   not exhaustive;  additional functions appear in relevant sections of
   the manual.
-->
もし移植性が気になるのであれば、最も基本的な算術および比較演算子と、いくつかの明示的に印を付けた関数を除き、本章で説明する大多数の関数と演算子は、標準<acronym>SQL</acronym>で規定されていない点に注意してください。
この拡張機能のいくつかは、他の<acronym>SQL</acronym>データベース管理システムにも備わっており、多くの場合この機能には各種実装間で互換性と整合性があります。
同時に、本節は完全なものではありません。追加の関数はマニュアルの関連のある節に出てきます。
  </para>

<!-- split-func0-end -->
<!-- split-func1-start -->

  <sect1 id="functions-logical">
<!--
   <title>Logical Operators</title>
-->
   <title>論理演算子</title>

   <indexterm zone="functions-logical">
<!--
    <primary>operator</primary>
    <secondary>logical</secondary>
-->
    <primary>演算子</primary>
    <secondary>論理</secondary>
   </indexterm>

   <indexterm>
<!--
    <primary>Boolean</primary>
    <secondary>operators</secondary>
    <see>operators, logical</see>
-->
    <primary>論理値</primary>
    <secondary>演算子</secondary>
    <see>演算子, 論理</see>
   </indexterm>

   <para>
<!--
    The usual logical operators are available:
-->
    通常の論理演算子が使用できます。

    <indexterm>
<!--
     <primary>AND (operator)</primary>
-->
     <primary>AND（演算子）</primary>
    </indexterm>

    <indexterm>
<!--
     <primary>OR (operator)</primary>
-->
     <primary>OR（演算子）</primary>
    </indexterm>

    <indexterm>
<!--
     <primary>NOT (operator)</primary>
-->
     <primary>NOT（演算子）</primary>
    </indexterm>

    <indexterm>
<!--
     <primary>conjunction</primary>
-->
     <primary>論理積</primary>
    </indexterm>

    <indexterm>
<!--
     <primary>disjunction</primary>
-->
     <primary>論理和</primary>
    </indexterm>

    <indexterm>
<!--
     <primary>negation</primary>
-->
     <primary>否定</primary>
    </indexterm>

    <simplelist>
     <member><literal>AND</literal></member>
     <member><literal>OR</literal></member>
     <member><literal>NOT</literal></member>
    </simplelist>

<!--
    <acronym>SQL</acronym> uses a three-valued logic system with true,
    false, and <literal>null</literal>, which represents <quote>unknown</quote>.
    Observe the following truth tables:
-->
<acronym>SQL</acronym>はtrue、false、そして<quote>不明</quote>を意味する<literal>null</literal>の3値の論理システムを使用します。
以下の真理値表を参照してください。

    <informaltable>
     <tgroup cols="4">
      <thead>
       <row>
        <entry><replaceable>a</replaceable></entry>
        <entry><replaceable>b</replaceable></entry>
        <entry><replaceable>a</replaceable> AND <replaceable>b</replaceable></entry>
        <entry><replaceable>a</replaceable> OR <replaceable>b</replaceable></entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry>TRUE</entry>
        <entry>TRUE</entry>
        <entry>TRUE</entry>
        <entry>TRUE</entry>
       </row>

       <row>
        <entry>TRUE</entry>
        <entry>FALSE</entry>
        <entry>FALSE</entry>
        <entry>TRUE</entry>
       </row>

       <row>
        <entry>TRUE</entry>
        <entry>NULL</entry>
        <entry>NULL</entry>
        <entry>TRUE</entry>
       </row>

       <row>
        <entry>FALSE</entry>
        <entry>FALSE</entry>
        <entry>FALSE</entry>
        <entry>FALSE</entry>
       </row>

       <row>
        <entry>FALSE</entry>
        <entry>NULL</entry>
        <entry>FALSE</entry>
        <entry>NULL</entry>
       </row>

       <row>
        <entry>NULL</entry>
        <entry>NULL</entry>
        <entry>NULL</entry>
        <entry>NULL</entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>

    <informaltable>
     <tgroup cols="2">
      <thead>
       <row>
        <entry><replaceable>a</replaceable></entry>
        <entry>NOT <replaceable>a</replaceable></entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry>TRUE</entry>
        <entry>FALSE</entry>
       </row>

       <row>
        <entry>FALSE</entry>
        <entry>TRUE</entry>
       </row>

       <row>
        <entry>NULL</entry>
        <entry>NULL</entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>
   </para>

   <para>
<!--
    The operators <literal>AND</literal> and <literal>OR</literal> are
    commutative, that is, you can switch the left and right operand
    without affecting the result.  But see <xref
    linkend="syntax-express-eval"/> for more information about the
    order of evaluation of subexpressions.
-->
<literal>AND</literal>演算子と<literal>OR</literal>演算子は可換です。
つまり、結果に影響を与えることなく左右のオペランドを交換することができます。
しかし、副式の評価順についてのより詳細は<xref linkend="syntax-express-eval"/>を参照してください。
   </para>
  </sect1>

  <sect1 id="functions-comparison">
<!--
   <title>Comparison Functions and Operators</title>
-->
   <title>比較関数および演算子</title>

   <indexterm zone="functions-comparison">
<!--
    <primary>comparison</primary>
    <secondary>operators</secondary>
-->
    <primary>比較</primary>
    <secondary>演算子</secondary>
   </indexterm>

   <para>
<!--
    The usual comparison operators are available, as shown in <xref
    linkend="functions-comparison-op-table"/>.
-->
<xref linkend="functions-comparison-op-table"/>に示すように、通常の比較演算子が使用可能です。
   </para>

   <table id="functions-comparison-op-table">
<!--
    <title>Comparison Operators</title>
-->
    <title>比較演算子</title>
    <tgroup cols="2">
     <thead>
      <row>
<!--
       <entry>Operator</entry>
       <entry>Description</entry>
-->
       <entry>演算子</entry>
       <entry>説明</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry> <literal>&lt;</literal> </entry>
<!--
       <entry>less than</entry>
-->
       <entry>小なり</entry>
      </row>

      <row>
       <entry> <literal>&gt;</literal> </entry>
<!--
       <entry>greater than</entry>
-->
       <entry>大なり</entry>
      </row>

      <row>
       <entry> <literal>&lt;=</literal> </entry>
<!--
       <entry>less than or equal to</entry>
-->
       <entry>等しいかそれ以下</entry>
      </row>

      <row>
       <entry> <literal>&gt;=</literal> </entry>
<!--
       <entry>greater than or equal to</entry>
-->
       <entry>等しいかそれ以上</entry>
      </row>

      <row>
       <entry> <literal>=</literal> </entry>
<!--
       <entry>equal</entry>
-->
       <entry>等しい</entry>
      </row>

      <row>
<!--
       <entry> <literal>&lt;&gt;</literal> or <literal>!=</literal> </entry>
-->
       <entry> <literal>&lt;&gt;</literal> または <literal>!=</literal> </entry>
<!--
       <entry>not equal</entry>
-->
       <entry>等しくない</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <note>
    <para>
<!--
     The <literal>!=</literal> operator is converted to
     <literal>&lt;&gt;</literal> in the parser stage.  It is not
     possible to implement <literal>!=</literal> and
     <literal>&lt;&gt;</literal> operators that do different things.
-->
<literal>!=</literal>演算子は構文解析で<literal>&lt;&gt;</literal>に変換されます。
<literal>!=</literal>演算子と<literal>&lt;&gt;</literal>演算子に異なる処理を行わせる実装はできません。
    </para>
   </note>

   <para>
<!--
    Comparison operators are available for all relevant data types.
    All comparison operators are binary operators that
    return values of type <type>boolean</type>; expressions like
    <literal>1 &lt; 2 &lt; 3</literal> are not valid (because there is
    no <literal>&lt;</literal> operator to compare a Boolean value with
    <literal>3</literal>).
-->
比較演算子は関連性のある全てのデータ型で使用できます。
全ての比較演算子は二項演算子で、<type>boolean</type>型の値を返します。<literal>1 &lt; 2 &lt; 3</literal>のような式は（ブール値と<literal>3</literal>を比較する<literal>&lt;</literal>演算子がないので）無効です。
   </para>

   <para>
<!--
    There are also some comparison predicates, as shown in <xref
    linkend="functions-comparison-pred-table"/>.  These behave much like
    operators, but have special syntax mandated by the SQL standard.
-->
<xref linkend="functions-comparison-pred-table"/>に示すように、比較の述語がいくつかあります。
これらは演算子と同様に振る舞いますが、標準SQLによって強制される特別の構文があります。
   </para>

   <table id="functions-comparison-pred-table">
<!--
    <title>Comparison Predicates</title>
-->
    <title>比較述語</title>
    <tgroup cols="2">
     <thead>
      <row>
<!--
       <entry>Predicate</entry>
       <entry>Description</entry>
-->
       <entry>述語</entry>
       <entry>説明</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry> <replaceable>a</replaceable> <literal>BETWEEN</literal> <replaceable>x</replaceable> <literal>AND</literal> <replaceable>y</replaceable> </entry>
<!--
       <entry>between</entry>
-->
       <entry>間にある</entry>
      </row>

      <row>
       <entry> <replaceable>a</replaceable> <literal>NOT BETWEEN</literal> <replaceable>x</replaceable> <literal>AND</literal> <replaceable>y</replaceable> </entry>
<!--
       <entry>not between</entry>
-->
       <entry>間にない</entry>
      </row>

      <row>
       <entry> <replaceable>a</replaceable> <literal>BETWEEN SYMMETRIC</literal> <replaceable>x</replaceable> <literal>AND</literal> <replaceable>y</replaceable> </entry>
<!--
       <entry>between, after sorting the comparison values</entry>
-->
       <entry>間にある（比較値をソートする）</entry>
      </row>

      <row>
       <entry> <replaceable>a</replaceable> <literal>NOT BETWEEN SYMMETRIC</literal> <replaceable>x</replaceable> <literal>AND</literal> <replaceable>y</replaceable> </entry>
<!--
       <entry>not between, after sorting the comparison values</entry>
-->
       <entry>間にない（比較値をソートする）</entry>
      </row>

      <row>
       <entry> <replaceable>a</replaceable> <literal>IS DISTINCT FROM</literal> <replaceable>b</replaceable> </entry>
<!--
       <entry>not equal, treating null like an ordinary value</entry>
-->
       <entry>等しくない（NULLは通常の値と同様に扱う）</entry>
      </row>

      <row>
       <entry><replaceable>a</replaceable> <literal>IS NOT DISTINCT FROM</literal> <replaceable>b</replaceable></entry>
<!--
       <entry>equal, treating null like an ordinary value</entry>
-->
       <entry>等しい（NULLは通常の値と同様に扱う）</entry>
      </row>

      <row>
       <entry> <replaceable>expression</replaceable> <literal>IS NULL</literal> </entry>
<!--
       <entry>is null</entry>
-->
       <entry>NULLである</entry>
      </row>

      <row>
       <entry> <replaceable>expression</replaceable> <literal>IS NOT NULL</literal> </entry>
<!--
       <entry>is not null</entry>
-->
       <entry>NULLでない</entry>
      </row>

      <row>
       <entry> <replaceable>expression</replaceable> <literal>ISNULL</literal> </entry>
<!--
       <entry>is null (nonstandard syntax)</entry>
-->
       <entry>NULLである（非標準の構文）</entry>
      </row>

      <row>
       <entry> <replaceable>expression</replaceable> <literal>NOTNULL</literal> </entry>
<!--
       <entry>is not null (nonstandard syntax)</entry>
-->
       <entry>NULLでない（非標準の構文）</entry>
      </row>

      <row>
       <entry> <replaceable>boolean_expression</replaceable> <literal>IS TRUE</literal> </entry>
<!--
       <entry>is true</entry>
-->
       <entry>真である</entry>
      </row>

      <row>
       <entry> <replaceable>boolean_expression</replaceable> <literal>IS NOT TRUE</literal> </entry>
<!--
       <entry>is false or unknown</entry>
-->
       <entry>偽あるいは不明である</entry>
      </row>

      <row>
       <entry> <replaceable>boolean_expression</replaceable> <literal>IS FALSE</literal> </entry>
<!--
       <entry>is false</entry>
-->
       <entry>偽である</entry>
      </row>

      <row>
       <entry> <replaceable>boolean_expression</replaceable> <literal>IS NOT FALSE</literal> </entry>
<!--
       <entry>is true or unknown</entry>
-->
       <entry>真あるいは不明である</entry>
      </row>

      <row>
       <entry> <replaceable>boolean_expression</replaceable> <literal>IS UNKNOWN</literal> </entry>
<!--
       <entry>is unknown</entry>
-->
       <entry>不明である</entry>
      </row>

      <row>
       <entry> <replaceable>boolean_expression</replaceable> <literal>IS NOT UNKNOWN</literal> </entry>
<!--
       <entry>is true or false</entry>
-->
       <entry>真あるいは偽である</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
    <indexterm>
     <primary>BETWEEN</primary>
    </indexterm>
<!--
    The <token>BETWEEN</token> predicate simplifies range tests:
-->
<token>BETWEEN</token>述語は範囲の検査を次のように単純にします。
<synopsis>
<replaceable>a</replaceable> BETWEEN <replaceable>x</replaceable> AND <replaceable>y</replaceable>
</synopsis>
<!--
    is equivalent to
-->
は
<synopsis>
<replaceable>a</replaceable> &gt;= <replaceable>x</replaceable> AND <replaceable>a</replaceable> &lt;= <replaceable>y</replaceable>
</synopsis>
と同じです。
<!--
    Notice that <token>BETWEEN</token> treats the endpoint values as included
    in the range.
    <literal>NOT BETWEEN</literal> does the opposite comparison:
-->
<token>BETWEEN</token>は範囲内に含まれるとして終点値を扱うことに注意してください。
<literal>NOT BETWEEN</literal>はその反対の比較をします（指定した値は包括しません）。
<synopsis>
<replaceable>a</replaceable> NOT BETWEEN <replaceable>x</replaceable> AND <replaceable>y</replaceable>
</synopsis>
<!--
    is equivalent to
-->
は
<synopsis>
<replaceable>a</replaceable> &lt; <replaceable>x</replaceable> OR <replaceable>a</replaceable> &gt; <replaceable>y</replaceable>
</synopsis>
と同一です。
    <indexterm>
     <primary>BETWEEN SYMMETRIC</primary>
    </indexterm>
<!--
    <literal>BETWEEN SYMMETRIC</literal> is like <literal>BETWEEN</literal>
    except there is no requirement that the argument to the left of
    <literal>AND</literal> be less than or equal to the argument on the right.
    If it is not, those two arguments are automatically swapped, so that
    a nonempty range is always implied.
-->
<literal>BETWEEN SYMMETRIC</literal>は、<literal>AND</literal>の左側の引数が右側の引数より小さいか、もしくは等しいという必要性が無い点を除き<literal>BETWEEN</literal>と同様です。
この条件を満たしていない場合、2つの引数は自動的に交換されますので、常に空ではない範囲となります。
   </para>

   <para>
    <indexterm>
     <primary>IS DISTINCT FROM</primary>
    </indexterm>
    <indexterm>
     <primary>IS NOT DISTINCT FROM</primary>
    </indexterm>
<!--
    Ordinary comparison operators yield null (signifying <quote>unknown</quote>),
    not true or false, when either input is null.  For example,
    <literal>7 = NULL</literal> yields null, as does <literal>7 &lt;&gt; NULL</literal>.  When
    this behavior is not suitable, use the
    <literal>IS <optional> NOT </optional> DISTINCT FROM</literal> predicates:
-->
入力のどちらかがNULLの場合、通常の比較演算子は真や偽ではなく（<quote>不明</quote>を意味する）nullを生成します。
例えば<literal>7 = NULL</literal>はnullになります。<literal>7 &lt;&gt; NULL</literal>も同様です。
この動作が適切でない場合は、<literal>IS <optional> NOT </optional> DISTINCT FROM</literal>述語を使用してください。
<synopsis>
<replaceable>a</replaceable> IS DISTINCT FROM <replaceable>b</replaceable>
<replaceable>a</replaceable> IS NOT DISTINCT FROM <replaceable>b</replaceable>
</synopsis>
<!--
    For non-null inputs, <literal>IS DISTINCT FROM</literal> is
    the same as the <literal>&lt;&gt;</literal> operator.  However, if both
    inputs are null it returns false, and if only one input is
    null it returns true.  Similarly, <literal>IS NOT DISTINCT
    FROM</literal> is identical to <literal>=</literal> for non-null
    inputs, but it returns true when both inputs are null, and false when only
    one input is null. Thus, these predicates effectively act as though null
    were a normal data value, rather than <quote>unknown</quote>.
-->
非NULLの入力では、<literal>IS DISTINCT FROM</literal>は<literal>&lt;&gt;</literal>演算子と同じです。
しかし、入力がどちらもNULLの場合、これは偽を返し、片方の入力のみがNULLの場合は真を返します。
同様に、<literal>IS NOT DISTINCT FROM</literal>は非NULL入力では<literal>=</literal>と同じですが、両方の入力がNULLであれば真を、片方のみがNULLの場合は偽を返します。
このように、これらの述語はNULLを<quote>不明な値</quote>ではなく、通常の値かのように動作します。
   </para>

   <para>
    <indexterm>
     <primary>IS NULL</primary>
    </indexterm>
    <indexterm>
     <primary>IS NOT NULL</primary>
    </indexterm>
    <indexterm>
     <primary>ISNULL</primary>
    </indexterm>
    <indexterm>
     <primary>NOTNULL</primary>
    </indexterm>
<!--
    To check whether a value is or is not null, use the predicates:
-->
値がNULLかNULLでないかを検証するには次の述語を使います。
<synopsis>
<replaceable>expression</replaceable> IS NULL
<replaceable>expression</replaceable> IS NOT NULL
</synopsis>
<!--
    or the equivalent, but nonstandard, predicates:
-->
あるいは、これと同等の、非標準の述語も使えます。
<synopsis>
<replaceable>expression</replaceable> ISNULL
<replaceable>expression</replaceable> NOTNULL
</synopsis>
<!--
    <indexterm><primary>null value</primary><secondary>comparing</secondary></indexterm>
-->
    <indexterm><primary>NULL値</primary><secondary>比較</secondary></indexterm>
   </para>

   <para>
<!--
    Do <emphasis>not</emphasis> write
    <literal><replaceable>expression</replaceable> = NULL</literal>
    because <literal>NULL</literal> is not <quote>equal to</quote>
    <literal>NULL</literal>.  (The null value represents an unknown value,
    and it is not known whether two unknown values are equal.)
-->
<literal>NULL</literal>と<literal>NULL</literal>とは<quote>等しい</quote>関係にはありませんので、<literal><replaceable>expression</replaceable> = NULL</literal>と記述しては<emphasis>いけません</emphasis>
（NULL値は不明の値を表しているため、不明な値同士が同じかどうかは識別できません）。
   </para>

  <tip>
   <para>
<!--
    Some applications might expect that
    <literal><replaceable>expression</replaceable> = NULL</literal>
    returns true if <replaceable>expression</replaceable> evaluates to
    the null value.  It is highly recommended that these applications
    be modified to comply with the SQL standard. However, if that
    cannot be done the <xref linkend="guc-transform-null-equals"/>
    configuration variable is available. If it is enabled,
    <productname>PostgreSQL</productname> will convert <literal>x =
    NULL</literal> clauses to <literal>x IS NULL</literal>.
-->
アプリケーションによっては、<literal><replaceable>expression</replaceable> = NULL</literal>が、<replaceable>expression</replaceable>がNULL値と評価されるのであれば真を返すことを期待することがあります。
こうしたアプリケーションは標準SQLに従うように改修することを強く推奨します。
しかし、それができなければ<xref linkend="guc-transform-null-equals"/>を使用することで対応することができます。
これを有効にした場合、<productname>PostgreSQL</productname>は<literal>x = NULL</literal>句を<literal>x IS NULL</literal>に変換します。
   </para>
  </tip>

   <para>
<!--
    If the <replaceable>expression</replaceable> is row-valued, then
    <literal>IS NULL</literal> is true when the row expression itself is null
    or when all the row's fields are null, while
    <literal>IS NOT NULL</literal> is true when the row expression itself is non-null
    and all the row's fields are non-null.  Because of this behavior,
    <literal>IS NULL</literal> and <literal>IS NOT NULL</literal> do not always return
    inverse results for row-valued expressions; in particular, a row-valued
    expression that contains both null and non-null fields will return false
    for both tests.  In some cases, it may be preferable to
    write <replaceable>row</replaceable> <literal>IS DISTINCT FROM NULL</literal>
    or <replaceable>row</replaceable> <literal>IS NOT DISTINCT FROM NULL</literal>,
    which will simply check whether the overall row value is null without any
    additional tests on the row fields.
-->
<replaceable>expression</replaceable>が行値の場合、行式自体がNULLまたは、行のフィールドすべてがNULLの場合に<literal>IS NULL</literal>は真となります。
一方<literal>IS NOT NULL</literal>は、行式自体が非NULLかつ、行のフィールドすべてが非NULLの場合に真となります。
この動作により、<literal>IS NULL</literal>および<literal>IS NOT NULL</literal>は行値評価式に対し常に反対の結果を返すわけではありません。
特に、NULLと非NULLの値の両方を含む行値式はどちらの試験でも偽を返します。
場合によっては、<replaceable>row</replaceable> <literal>IS DISTINCT FROM NULL</literal>あるいは<replaceable>row</replaceable> <literal>IS NOT DISTINCT FROM NULL</literal>と記述する方が望ましいことがあるでしょう。
これらは単に行全体の値がNULLかどうかを検査し、行のフィールドについての追加的検査を全く行わないからです。
   </para>

   <para>
    <indexterm>
     <primary>IS TRUE</primary>
    </indexterm>
    <indexterm>
     <primary>IS NOT TRUE</primary>
    </indexterm>
    <indexterm>
     <primary>IS FALSE</primary>
    </indexterm>
    <indexterm>
     <primary>IS NOT FALSE</primary>
    </indexterm>
    <indexterm>
     <primary>IS UNKNOWN</primary>
    </indexterm>
    <indexterm>
     <primary>IS NOT UNKNOWN</primary>
    </indexterm>
<!--
    Boolean values can also be tested using the predicates
-->
論理値も次の述語で検証できます。
<synopsis>
<replaceable>boolean_expression</replaceable> IS TRUE
<replaceable>boolean_expression</replaceable> IS NOT TRUE
<replaceable>boolean_expression</replaceable> IS FALSE
<replaceable>boolean_expression</replaceable> IS NOT FALSE
<replaceable>boolean_expression</replaceable> IS UNKNOWN
<replaceable>boolean_expression</replaceable> IS NOT UNKNOWN
</synopsis>
<!--
    These will always return true or false, never a null value, even when the
    operand is null.
    A null input is treated as the logical value <quote>unknown</quote>.
    Notice that <literal>IS UNKNOWN</literal> and <literal>IS NOT UNKNOWN</literal> are
    effectively the same as <literal>IS NULL</literal> and
    <literal>IS NOT NULL</literal>, respectively, except that the input
    expression must be of Boolean type.
-->
これらは、常に真か偽を返し、演算項目がNULLであってもNULL値を返すことはありません。
NULL値が入力されると、<quote>不明</quote>という論理値として扱われます。
<literal>IS UNKNOWN</literal>と<literal>IS NOT UNKNOWN</literal>が、入力式が論理値型でなければならないという点を除き、それぞれ実質的に<literal>IS NULL</literal>と<literal>IS NOT NULL</literal>と同じであることに注意してください。
   </para>

<!-- IS OF does not conform to the ISO SQL behavior, so it is undocumented here
   <para>
    <indexterm>
     <primary>IS OF</primary>
    </indexterm>
    <indexterm>
     <primary>IS NOT OF</primary>
    </indexterm>
    It is possible to check the data type of an expression using the
    predicates
<synopsis>
<replaceable>expression</replaceable> IS OF (typename, ...)
<replaceable>expression</replaceable> IS NOT OF (typename, ...)
</synopsis>
    They return a boolean value based on whether the expression's data
    type is one of the listed data types.
   </para>
-->

   <para>
<!--
    Some comparison-related functions are also available, as shown in <xref
    linkend="functions-comparison-func-table"/>.
-->
<xref linkend="functions-comparison-func-table"/>に示すように、比較に関連した関数がいくつか使用可能です。
   </para>

  <table id="functions-comparison-func-table">
<!--
    <title>Comparison Functions</title>
-->
    <title>比較関数</title>
    <tgroup cols="4">
     <thead>
      <row>
<!--
       <entry>Function</entry>
       <entry>Description</entry>
       <entry>Example</entry>
       <entry>Example Result</entry>
-->
       <entry>関数</entry>
       <entry>説明</entry>
       <entry>例</entry>
       <entry>例の結果</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>
         <indexterm>
          <primary>num_nonnulls</primary>
         </indexterm>
         <literal>num_nonnulls(VARIADIC "any")</literal>
       </entry>
<!--
       <entry>returns the number of non-null arguments</entry>
-->
       <entry>非NULLの引数の個数を返す</entry>
       <entry><literal>num_nonnulls(1, NULL, 2)</literal></entry>
       <entry><literal>2</literal></entry>
      </row>
      <row>
       <entry>
         <indexterm>
          <primary>num_nulls</primary>
         </indexterm>
         <literal>num_nulls(VARIADIC "any")</literal>
       </entry>
<!--
       <entry>returns the number of null arguments</entry>
-->
       <entry>NULLの引数の個数を返す</entry>
       <entry><literal>num_nulls(1, NULL, 2)</literal></entry>
       <entry><literal>1</literal></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  </sect1>

  <sect1 id="functions-math">
<!--
   <title>Mathematical Functions and Operators</title>
-->
   <title>算術関数と演算子</title>

   <para>
<!--
    Mathematical operators are provided for many
    <productname>PostgreSQL</productname> types. For types without
    standard mathematical conventions
    (e.g., date/time types) we
    describe the actual behavior in subsequent sections.
-->
<productname>PostgreSQL</productname>の数多くの型に対する算術演算子が用意されています。
標準算術表現法が存在しない型（例えば、日付/時刻データ型）については、後続する節で実際の動作を説明します。
   </para>

   <para>
<!--
    <xref linkend="functions-math-op-table"/> shows the available mathematical operators.
-->
<xref linkend="functions-math-op-table"/>は使用可能な算術演算子を示しています。
   </para>

   <table id="functions-math-op-table">
<!--
    <title>Mathematical Operators</title>
-->
    <title>算術演算子</title>

    <tgroup cols="4">
     <thead>
      <row>
<!--
       <entry>Operator</entry>
       <entry>Description</entry>
       <entry>Example</entry>
       <entry>Result</entry>
-->
       <entry>演算子名</entry>
       <entry>説明</entry>
       <entry>例</entry>
       <entry>結果</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry> <literal>+</literal> </entry>
<!--
       <entry>addition</entry>
-->
       <entry>和</entry>
       <entry><literal>2 + 3</literal></entry>
       <entry><literal>5</literal></entry>
      </row>

      <row>
       <entry> <literal>-</literal> </entry>
<!--
       <entry>subtraction</entry>
-->
       <entry>差</entry>
       <entry><literal>2 - 3</literal></entry>
       <entry><literal>-1</literal></entry>
      </row>

      <row>
       <entry> <literal>*</literal> </entry>
<!--
       <entry>multiplication</entry>
-->
       <entry>積</entry>
       <entry><literal>2 * 3</literal></entry>
       <entry><literal>6</literal></entry>
      </row>

      <row>
       <entry> <literal>/</literal> </entry>
<!--
       <entry>division (integer division truncates the result)</entry>
-->
       <entry>商（整数の割り算では余りを切り捨て）</entry>
       <entry><literal>4 / 2</literal></entry>
       <entry><literal>2</literal></entry>
      </row>

      <row>
       <entry> <literal>%</literal> </entry>
<!--
       <entry>modulo (remainder)</entry>
-->
       <entry>剰余（余り）</entry>
       <entry><literal>5 % 4</literal></entry>
       <entry><literal>1</literal></entry>
      </row>

      <row>
       <entry> <literal>^</literal> </entry>
<!--
       <entry>exponentiation (associates left to right)</entry>
-->
       <entry>累乗(左から右に適用)</entry>
       <entry><literal>2.0 ^ 3.0</literal></entry>
       <entry><literal>8</literal></entry>
      </row>

      <row>
       <entry> <literal>|/</literal> </entry>
<!--
       <entry>square root</entry>
-->
       <entry>平方根</entry>
       <entry><literal>|/ 25.0</literal></entry>
       <entry><literal>5</literal></entry>
      </row>

      <row>
       <entry> <literal>||/</literal> </entry>
<!--
       <entry>cube root</entry>
-->
       <entry>立方根</entry>
       <entry><literal>||/ 27.0</literal></entry>
       <entry><literal>3</literal></entry>
      </row>

      <row>
       <entry> <literal>!</literal> </entry>
<!--
       <entry>factorial</entry>
-->
       <entry>階乗</entry>
       <entry><literal>5 !</literal></entry>
       <entry><literal>120</literal></entry>
      </row>

      <row>
       <entry> <literal>!!</literal> </entry>
<!--
       <entry>factorial (prefix operator)</entry>
-->
       <entry>階乗（前置演算子）</entry>
       <entry><literal>!! 5</literal></entry>
       <entry><literal>120</literal></entry>
      </row>

      <row>
       <entry> <literal>@</literal> </entry>
<!--
       <entry>absolute value</entry>
-->
       <entry>絶対値</entry>
       <entry><literal>@ -5.0</literal></entry>
       <entry><literal>5</literal></entry>
      </row>

      <row>
       <entry> <literal>&amp;</literal> </entry>
<!--
       <entry>bitwise AND</entry>
-->
       <entry>ビットごとのAND</entry>
       <entry><literal>91 &amp; 15</literal></entry>
       <entry><literal>11</literal></entry>
      </row>

      <row>
       <entry> <literal>|</literal> </entry>
<!--
       <entry>bitwise OR</entry>
-->
       <entry>ビットごとのOR</entry>
       <entry><literal>32 | 3</literal></entry>
       <entry><literal>35</literal></entry>
      </row>

      <row>
       <entry> <literal>#</literal> </entry>
<!--
       <entry>bitwise XOR</entry>
-->
       <entry>ビットごとのXOR</entry>
       <entry><literal>17 # 5</literal></entry>
       <entry><literal>20</literal></entry>
      </row>

      <row>
       <entry> <literal>~</literal> </entry>
<!--
       <entry>bitwise NOT</entry>
-->
       <entry>ビットごとのNOT</entry>
       <entry><literal>~1</literal></entry>
       <entry><literal>-2</literal></entry>
      </row>

      <row>
       <entry> <literal>&lt;&lt;</literal> </entry>
<!--
       <entry>bitwise shift left</entry>
-->
       <entry>ビットごとの左シフト</entry>
       <entry><literal>1 &lt;&lt; 4</literal></entry>
       <entry><literal>16</literal></entry>
      </row>

      <row>
       <entry> <literal>&gt;&gt;</literal> </entry>
<!--
       <entry>bitwise shift right</entry>
-->
       <entry>ビットごとの右シフト</entry>
       <entry><literal>8 &gt;&gt; 2</literal></entry>
       <entry><literal>2</literal></entry>
      </row>

     </tbody>
    </tgroup>
   </table>

   <para>
<!--
    The bitwise operators work only on integral data types, whereas
    the others are available for all numeric data types.  The bitwise
    operators are also available for the bit
    string types <type>bit</type> and <type>bit varying</type>, as
    shown in <xref linkend="functions-bit-string-op-table"/>.
-->
ビット演算子は整数データ型のみに使用できます。一方他の演算子は全ての数値データ型に使用できます。
また、ビット演算子は<xref linkend="functions-bit-string-op-table"/>に示すように、<type>bit</type>、<type>bit varying</type>ビット文字列型に対しても使用することができます。
   </para>

  <para>
<!--
   <xref linkend="functions-math-func-table"/> shows the available
   mathematical functions.  In the table, <literal>dp</literal>
   indicates <type>double precision</type>.  Many of these functions
   are provided in multiple forms with different argument types.
   Except where noted, any given form of a function returns the same
   data type as its argument.
   The functions working with <type>double precision</type> data are mostly
   implemented on top of the host system's C library; accuracy and behavior in
   boundary cases can therefore vary depending on the host system.
-->
<xref linkend="functions-math-func-table"/>に使用可能な算術関数を示します。
この表内の<literal>dp</literal>は、<type>double precision</type>を意味します。
これら関数の多くは、異なる引数型を持つ複数の形で提供されています。
特に記述がある場合を除き、すべての形式の関数はその引数と同じデータ型を返します。
<type>double precision</type>データに対する関数のほとんどはホストシステムのCライブラリの上層に実装されています。このため、精度と境界近くの場合の振舞いはホストシステムに依存して変わります。
  </para>

   <table id="functions-math-func-table">
<!--
    <title>Mathematical Functions</title>
-->
    <title>算術関数</title>
    <tgroup cols="5">
     <thead>
      <row>
<!--
       <entry>Function</entry>
       <entry>Return Type</entry>
       <entry>Description</entry>
       <entry>Example</entry>
       <entry>Result</entry>
-->
       <entry>関数</entry>
       <entry>戻り値型</entry>
       <entry>説明</entry>
       <entry>例</entry>
       <entry>結果</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry>
        <indexterm>
         <primary>abs</primary>
        </indexterm>
        <literal><function>abs(<replaceable>x</replaceable>)</function></literal>
       </entry>
<!--
       <entry>(same as input)</entry>
-->
       <entry>（入力と同じ）</entry>
<!--
       <entry>absolute value</entry>
-->
       <entry>絶対値</entry>
       <entry><literal>abs(-17.4)</literal></entry>
       <entry><literal>17.4</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>cbrt</primary>
        </indexterm>
        <literal><function>cbrt(<type>dp</type>)</function></literal>
       </entry>
       <entry><type>dp</type></entry>
<!--
       <entry>cube root</entry>
-->
       <entry>立方根</entry>
       <entry><literal>cbrt(27.0)</literal></entry>
       <entry><literal>3</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>ceil</primary>
        </indexterm>
        <literal><function>ceil(<type>dp</type> or <type>numeric</type>)</function></literal>
       </entry>
<!--
       <entry>(same as input)</entry>
       <entry>nearest integer greater than or equal to argument</entry>
-->
       <entry>引数より大きいか等しく、引数に最も近い整数</entry>
       <entry><literal>ceil(-42.8)</literal></entry>
       <entry><literal>-42</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>ceiling</primary>
        </indexterm>
        <literal><function>ceiling(<type>dp</type> or <type>numeric</type>)</function></literal>
       </entry>
<!--
       <entry>(same as input)</entry>
-->
       <entry>（入力型と同一）</entry>
<!--
       <entry>nearest integer greater than or equal to argument (same as <function>ceil</function>)</entry>
-->
       <entry>引数より大きいか等しく、引数に最も近い整数（<function>ceil</function>と同じ）</entry>
       <entry><literal>ceiling(-95.3)</literal></entry>
       <entry><literal>-95</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>degrees</primary>
        </indexterm>
        <literal><function>degrees(<type>dp</type>)</function></literal>
       </entry>
       <entry><type>dp</type></entry>
<!--
       <entry>radians to degrees</entry>
-->
       <entry>ラジアンを度に変換</entry>
       <entry><literal>degrees(0.5)</literal></entry>
       <entry><literal>28.6478897565412</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>div</primary>
        </indexterm>
        <literal><function>div(<parameter>y</parameter> <type>numeric</type>,
         <parameter>x</parameter> <type>numeric</type>)</function></literal>
       </entry>
       <entry><type>numeric</type></entry>
<!--
       <entry>integer quotient of <parameter>y</parameter>/<parameter>x</parameter></entry>
-->
       <entry><parameter>y</parameter>/<parameter>x</parameter>の整数商</entry>
       <entry><literal>div(9,4)</literal></entry>
       <entry><literal>2</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>exp</primary>
        </indexterm>
        <literal><function>exp(<type>dp</type> or <type>numeric</type>)</function></literal>
       </entry>
<!--
       <entry>(same as input)</entry>
-->
       <entry>（入力型と同一）</entry>
<!--
       <entry>exponential</entry>
-->
       <entry>指数</entry>
       <entry><literal>exp(1.0)</literal></entry>
       <entry><literal>2.71828182845905</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>floor</primary>
        </indexterm>
        <literal><function>floor(<type>dp</type> or <type>numeric</type>)</function></literal>
       </entry>
<!--
       <entry>(same as input)</entry>
-->
       <entry>（入力型と同一）</entry>
<!--
       <entry>nearest integer less than or equal to argument</entry>
-->
       <entry>引数より小さいか等しく、引数に最も近い整数</entry>
       <entry><literal>floor(-42.8)</literal></entry>
       <entry><literal>-43</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>ln</primary>
        </indexterm>
        <literal><function>ln(<type>dp</type> or <type>numeric</type>)</function></literal>
       </entry>
<!--
       <entry>(same as input)</entry>
-->
       <entry>（入力型と同一）</entry>
<!--
       <entry>natural logarithm</entry>
-->
       <entry>自然対数</entry>
       <entry><literal>ln(2.0)</literal></entry>
       <entry><literal>0.693147180559945</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>log</primary>
        </indexterm>
        <literal><function>log(<type>dp</type> or <type>numeric</type>)</function></literal>
       </entry>
<!--
       <entry>(same as input)</entry>
-->
       <entry>（入力型と同一）</entry>
<!--
       <entry>base 10 logarithm</entry>
-->
       <entry>10を底とした対数（常用対数）</entry>
       <entry><literal>log(100.0)</literal></entry>
       <entry><literal>2</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>log10</primary>
        </indexterm>
<!--
        <literal><function>log10(<type>dp</type> or <type>numeric</type>)</function></literal>
-->
        <literal><function>log10(<type>dp</type>あるいは<type>numeric</type>)</function></literal>
       </entry>
<!--
       <entry>(same as input)</entry>
       <entry>base 10 logarithm</entry>
-->
       <entry>（入力型と同一）</entry>
       <entry>10を底とした対数（常用対数）</entry>
       <entry><literal>log10(100.0)</literal></entry>
       <entry><literal>2</literal></entry>
      </row>

      <row>
       <entry><literal><function>log(<parameter>b</parameter> <type>numeric</type>,
        <parameter>x</parameter> <type>numeric</type>)</function></literal></entry>
       <entry><type>numeric</type></entry>
<!--
       <entry>logarithm to base <parameter>b</parameter></entry>
-->
       <entry><parameter>b</parameter>を底とした対数</entry>
       <entry><literal>log(2.0, 64.0)</literal></entry>
       <entry><literal>6.0000000000</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>mod</primary>
        </indexterm>
        <literal><function>mod(<parameter>y</parameter>,
         <parameter>x</parameter>)</function></literal>
       </entry>
<!--
       <entry>(same as argument types)</entry>
-->
       <entry>（引数の型と同一）</entry>
<!--
       <entry>remainder of <parameter>y</parameter>/<parameter>x</parameter></entry>
-->
       <entry><parameter>y</parameter>/<parameter>x</parameter>の剰余</entry>
       <entry><literal>mod(9,4)</literal></entry>
       <entry><literal>1</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>pi</primary>
        </indexterm>
        <literal><function>pi()</function></literal>
       </entry>
       <entry><type>dp</type></entry>
<!--
       <entry><quote>&pi;</quote> constant</entry>
-->
       <entry><quote>円周率（π）</quote>定数</entry>
       <entry><literal>pi()</literal></entry>
       <entry><literal>3.14159265358979</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>power</primary>
        </indexterm>
        <literal><function>power(<parameter>a</parameter> <type>dp</type>,
        <parameter>b</parameter> <type>dp</type>)</function></literal>
       </entry>
       <entry><type>dp</type></entry>
<!--
       <entry><parameter>a</parameter> raised to the power of <parameter>b</parameter></entry>
-->
       <entry><parameter>a</parameter>の<parameter>b</parameter>乗</entry>
       <entry><literal>power(9.0, 3.0)</literal></entry>
       <entry><literal>729</literal></entry>
      </row>

      <row>
       <entry><literal><function>power(<parameter>a</parameter> <type>numeric</type>,
        <parameter>b</parameter> <type>numeric</type>)</function></literal></entry>
       <entry><type>numeric</type></entry>
<!--
       <entry><parameter>a</parameter> raised to the power of <parameter>b</parameter></entry>
-->
       <entry><parameter>a</parameter>の<parameter>b</parameter>乗</entry>
       <entry><literal>power(9.0, 3.0)</literal></entry>
       <entry><literal>729</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>radians</primary>
        </indexterm>
        <literal><function>radians(<type>dp</type>)</function></literal>
       </entry>
       <entry><type>dp</type></entry>
<!--
       <entry>degrees to radians</entry>
-->
       <entry>度をラジアンに変換</entry>
       <entry><literal>radians(45.0)</literal></entry>
       <entry><literal>0.785398163397448</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>round</primary>
        </indexterm>
        <literal><function>round(<type>dp</type> or <type>numeric</type>)</function></literal>
       </entry>
<!--
       <entry>(same as input)</entry>
-->
       <entry>（入力型と同一）</entry>
<!--
       <entry>round to nearest integer</entry>
-->
       <entry>最も近い整数への丸め</entry>
       <entry><literal>round(42.4)</literal></entry>
       <entry><literal>42</literal></entry>
      </row>

      <row>
       <entry><literal><function>round(<parameter>v</parameter> <type>numeric</type>, <parameter>s</parameter> <type>int</type>)</function></literal></entry>
       <entry><type>numeric</type></entry>
<!--
       <entry>round to <parameter>s</parameter> decimal places</entry>
-->
       <entry>小数点第<parameter>s</parameter>位までの丸め</entry>
       <entry><literal>round(42.4382, 2)</literal></entry>
       <entry><literal>42.44</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>scale</primary>
        </indexterm>
        <literal><function>scale(<type>numeric</type>)</function></literal>
       </entry>
       <entry><type>integer</type></entry>
<!--
       <entry>scale of the argument (the number of decimal digits in the fractional part)</entry>
-->
       <entry>引数の位取り（小数点以下の十進の桁数）</entry>
       <entry><literal>scale(8.41)</literal></entry>
       <entry><literal>2</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>sign</primary>
        </indexterm>
        <literal><function>sign(<type>dp</type> or <type>numeric</type>)</function></literal>
       </entry>
<!--
       <entry>(same as input)</entry>
-->
       <entry>（入力型と同一）</entry>
<!--
       <entry>sign of the argument (-1, 0, +1)</entry>
-->
       <entry>引数の符号（-1、0、+1）</entry>
       <entry><literal>sign(-8.4)</literal></entry>
       <entry><literal>-1</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>sqrt</primary>
        </indexterm>
        <literal><function>sqrt(<type>dp</type> or <type>numeric</type>)</function></literal>
       </entry>
<!--
       <entry>(same as input)</entry>
-->
       <entry>（入力型と同一）</entry>
<!--
       <entry>square root</entry>
-->
       <entry>平方根</entry>
       <entry><literal>sqrt(2.0)</literal></entry>
       <entry><literal>1.4142135623731</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>trunc</primary>
        </indexterm>
        <literal><function>trunc(<type>dp</type> or <type>numeric</type>)</function></literal>
       </entry>
<!--
       <entry>(same as input)</entry>
-->
       <entry>（入力型と同一）</entry>
<!--
       <entry>truncate toward zero</entry>
-->
       <entry>切り捨て</entry>
       <entry><literal>trunc(42.8)</literal></entry>
       <entry><literal>42</literal></entry>
      </row>

      <row>
       <entry><literal><function>trunc(<parameter>v</parameter> <type>numeric</type>, <parameter>s</parameter> <type>int</type>)</function></literal></entry>
       <entry><type>numeric</type></entry>
<!--
       <entry>truncate to <parameter>s</parameter> decimal places</entry>
-->
       <entry>小数点第<parameter>s</parameter>位までで切り捨て</entry>
       <entry><literal>trunc(42.4382, 2)</literal></entry>
       <entry><literal>42.43</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>width_bucket</primary>
        </indexterm>
        <literal><function>width_bucket(<parameter>operand</parameter> <type>dp</type>, <parameter>b1</parameter> <type>dp</type>, <parameter>b2</parameter> <type>dp</type>, <parameter>count</parameter> <type>int</type>)</function></literal></entry>
       <entry><type>int</type></entry>
<!--
       <entry>return the bucket number to which <parameter>operand</parameter> would
       be assigned in a histogram having <parameter>count</parameter> equal-width
       buckets spanning the range <parameter>b1</parameter> to <parameter>b2</parameter>;
       returns <literal>0</literal> or <literal><parameter>count</parameter>+1</literal> for
       an input outside the range</entry>
-->
       <entry><parameter>b1</parameter>から<parameter>b2</parameter>までの範囲に広がる等幅でバケット数<parameter>count</parameter>のヒストグラムにおいて、<parameter>operand</parameter>が割り当てられるバケット番号を返す。
範囲の外側の入力値に対しては<literal>0</literal>または<literal><parameter>count</parameter>+1</literal>を返す。</entry>
       <entry><literal>width_bucket(5.35, 0.024, 10.06, 5)</literal></entry>
       <entry><literal>3</literal></entry>
      </row>

      <row>
       <entry><literal><function>width_bucket(<parameter>operand</parameter> <type>numeric</type>, <parameter>b1</parameter> <type>numeric</type>, <parameter>b2</parameter> <type>numeric</type>, <parameter>count</parameter> <type>int</type>)</function></literal></entry>
       <entry><type>int</type></entry>
<!--
       <entry>return the bucket number to which <parameter>operand</parameter> would
       be assigned in a histogram having <parameter>count</parameter> equal-width
       buckets spanning the range <parameter>b1</parameter> to <parameter>b2</parameter>;
       returns <literal>0</literal> or <literal><parameter>count</parameter>+1</literal> for
       an input outside the range</entry>
-->
       <entry><parameter>b1</parameter>から<parameter>b2</parameter>までの範囲に広がる等幅でバケット数<parameter>count</parameter>のヒストグラムにおいて、<parameter>operand</parameter>が割り当てられるバケット番号を返す。
範囲の外側の入力値に対しては<literal>0</literal>または<literal><parameter>count</parameter>+1</literal>を返す。</entry>
       <entry><literal>width_bucket(5.35, 0.024, 10.06, 5)</literal></entry>
       <entry><literal>3</literal></entry>
      </row>

      <row>
       <entry><literal><function>width_bucket(<parameter>operand</parameter> <type>anyelement</type>, <parameter>thresholds</parameter> <type>anyarray</type>)</function></literal></entry>
       <entry><type>int</type></entry>
<!--
       <entry>return the bucket number to which <parameter>operand</parameter> would
       be assigned given an array listing the lower bounds of the buckets;
       returns <literal>0</literal> for an input less than the first lower bound;
       the <parameter>thresholds</parameter> array <emphasis>must be sorted</emphasis>,
       smallest first, or unexpected results will be obtained</entry>
-->
       <entry>バケットの下限値を列挙した配列に対し、<parameter>operand</parameter>が割り当てられるバケット番号を返す。
入力値が最初の下限値より小さいときは<literal>0</literal>を返す。
配列<parameter>thresholds</parameter>は最小のものを先頭に<emphasis>ソートされている必要があり</emphasis>、そうでなければ期待と異なる結果になる。</entry>
       <entry><literal>width_bucket(now(), array['yesterday', 'today', 'tomorrow']::timestamptz[])</literal></entry>
       <entry><literal>2</literal></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <para>
<!--
    <xref linkend="functions-math-random-table"/> shows functions for
    generating random numbers.
-->
<xref linkend="functions-math-random-table"/>に乱数を生成する関数を示します。
  </para>

   <table id="functions-math-random-table">
<!--
    <title>Random Functions</title>
-->
    <title>乱数関数</title>

    <tgroup cols="3">
     <thead>
      <row>
<!--
       <entry>Function</entry>
       <entry>Return Type</entry>
       <entry>Description</entry>
-->
       <entry>関数</entry>
       <entry>戻り値型</entry>
       <entry>説明</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>
        <indexterm>
         <primary>random</primary>
        </indexterm>
        <literal><function>random()</function></literal>
       </entry>
       <entry><type>dp</type></entry>
<!--
       <entry>random value in the range 0.0 &lt;= x &lt; 1.0</entry>
-->
       <entry>0.0 &lt;= x &lt; 1.0の範囲の乱数値</entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>setseed</primary>
        </indexterm>
        <literal><function>setseed(<type>dp</type>)</function></literal>
       </entry>
       <entry><type>void</type></entry>
<!--
       <entry>set seed for subsequent <literal>random()</literal> calls (value between -1.0 and
       1.0, inclusive)</entry>
-->
       <entry>今後の<literal>random()</literal>呼び出しで使用されるシード(種)の設定（-1.0から1.0までの境界を含む値）</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <para>
<!--
   The <function>random()</function> function uses a simple linear
   congruential algorithm.  It is fast but not suitable for cryptographic
   applications; see the <xref linkend="pgcrypto"/> module for a more
   secure alternative.
   If <function>setseed()</function> is called, the results of
   subsequent <function>random()</function> calls in the current session are
   repeatable by re-issuing <function>setseed()</function> with the same
   argument.
-->
<function>random()</function>関数は単純な線形合同法を使用しています。
高速ですが、暗号用途には適していません。より安全な代替物として<xref linkend="pgcrypto"/>モジュールを参照してください。
<function>setseed()</function>が呼び出されると、現在のセッション内での以後の<function>random()</function>の呼び出し結果は<function>setseed()</function>を同じ引数で実行することによって再現可能となります。
  </para>

  <para>
<!--
   <xref linkend="functions-math-trig-table"/> shows the
   available trigonometric functions.  All these functions
   take arguments and return values of type <type>double
   precision</type>.  Each of the trigonometric functions comes in
   two variants, one that measures angles in radians and one that
   measures angles in degrees.
-->
使用可能な三角関数を<xref linkend="functions-math-trig-table"/>に示します。
全ての三角関数は<type>double precision</type>データ型の引数と戻り値を取ります。
それぞれの三角関数には、角度の単位をラジアンにするものと度にするものの2種類があります。
  </para>

   <table id="functions-math-trig-table">
<!--
    <title>Trigonometric Functions</title>
-->
    <title>三角関数</title>

    <tgroup cols="3">
     <thead>
      <row>
<!--
       <entry>Function (radians)</entry>
       <entry>Function (degrees)</entry>
       <entry>Description</entry>
-->
       <entry>関数（ラジアン）</entry>
       <entry>関数（度）</entry>
       <entry>説明</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry>
        <indexterm>
         <primary>acos</primary>
        </indexterm><literal><function>acos(<replaceable>x</replaceable>)</function></literal>
       </entry>
       <entry>
        <indexterm>
         <primary>acosd</primary>
        </indexterm><literal><function>acosd(<replaceable>x</replaceable>)</function></literal>
       </entry>
<!--
       <entry>inverse cosine</entry>
-->
       <entry>逆余弦関数</entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>asin</primary>
        </indexterm>
        <literal><function>asin(<replaceable>x</replaceable>)</function></literal>
       </entry>
       <entry>
        <indexterm>
         <primary>asind</primary>
        </indexterm>
        <literal><function>asind(<replaceable>x</replaceable>)</function></literal>
       </entry>
<!--
       <entry>inverse sine</entry>
-->
       <entry>逆正弦関数</entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>atan</primary>
        </indexterm>
        <literal><function>atan(<replaceable>x</replaceable>)</function></literal>
       </entry>
       <entry>
        <indexterm>
         <primary>atand</primary>
        </indexterm>
        <literal><function>atand(<replaceable>x</replaceable>)</function></literal>
       </entry>
<!--
       <entry>inverse tangent</entry>
-->
       <entry>逆正接関数</entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>atan2</primary>
        </indexterm>
        <literal><function>atan2(<replaceable>y</replaceable>,
        <replaceable>x</replaceable>)</function></literal>
       </entry>
       <entry>
        <indexterm>
         <primary>atan2d</primary>
        </indexterm>
        <literal><function>atan2d(<replaceable>y</replaceable>,
        <replaceable>x</replaceable>)</function></literal>
       </entry>
<!--
       <entry>inverse tangent of
        <literal><replaceable>y</replaceable>/<replaceable>x</replaceable></literal></entry>
-->
       <entry>
        <literal><replaceable>y</replaceable>/<replaceable>x</replaceable></literal>の逆正接関数
       </entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>cos</primary>
        </indexterm>
        <literal><function>cos(<replaceable>x</replaceable>)</function></literal>
       </entry>
       <entry>
        <indexterm>
         <primary>cosd</primary>
        </indexterm>
        <literal><function>cosd(<replaceable>x</replaceable>)</function></literal>
       </entry>
<!--
       <entry>cosine</entry>
-->
       <entry>余弦関数</entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>cot</primary>
        </indexterm>
        <literal><function>cot(<replaceable>x</replaceable>)</function></literal>
       </entry>
       <entry>
        <indexterm>
         <primary>cotd</primary>
        </indexterm>
        <literal><function>cotd(<replaceable>x</replaceable>)</function></literal>
       </entry>
<!--
       <entry>cotangent</entry>
-->
       <entry>余接関数</entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>sin</primary>
        </indexterm>
        <literal><function>sin(<replaceable>x</replaceable>)</function></literal>
       </entry>
       <entry>
        <indexterm>
         <primary>sind</primary>
        </indexterm>
        <literal><function>sind(<replaceable>x</replaceable>)</function></literal>
       </entry>
<!--
       <entry>sine</entry>
-->
       <entry>正弦関数</entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>tan</primary>
        </indexterm>
        <literal><function>tan(<replaceable>x</replaceable>)</function></literal>
       </entry>
       <entry>
        <indexterm>
         <primary>tand</primary>
        </indexterm>
        <literal><function>tand(<replaceable>x</replaceable>)</function></literal>
       </entry>
<!--
       <entry>tangent</entry>
-->
       <entry>正接関数</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <note>
   <para>
<!--
    Another way to work with angles measured in degrees is to use the unit
    transformation functions <literal><function>radians()</function></literal>
    and <literal><function>degrees()</function></literal> shown earlier.
    However, using the degree-based trigonometric functions is preferred,
    as that way avoids round-off error for special cases such
    as <literal>sind(30)</literal>.
-->
度単位の角度を扱う別の方法は、前に示した単位変換関数<literal><function>radians()</function></literal>と<literal><function>degrees()</function></literal>を使うことです。
しかし、角度を使う方法の方が、<literal>sind(30)</literal>のような特別な場合の丸め誤差を避けられるため、推奨されます。
   </para>
  </note>

  <para>
<!--
   <xref linkend="functions-math-hyp-table"/> shows the
   available hyperbolic functions.  All these functions
   take arguments and return values of type <type>double
   precision</type>.
-->
利用可能な双曲線関数を<xref linkend="functions-math-hyp-table"/>に示します。
これら全ての関数は<type>double precision</type>データ型の引数と戻り値を取ります。
  </para>

  <table id="functions-math-hyp-table">
<!--
    <title>Hyperbolic Functions</title>
-->
    <title>双曲線関数</title>

    <tgroup cols="4">
     <thead>
      <row>
<!--
       <entry>Function</entry>
       <entry>Description</entry>
       <entry>Example</entry>
       <entry>Result</entry>
-->
       <entry>関数</entry>
       <entry>説明</entry>
       <entry>例</entry>
       <entry>結果</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>
        <indexterm>
         <primary>sinh</primary>
        </indexterm>
        <literal><function>sinh(<replaceable>x</replaceable>)</function></literal>
       </entry>
<!--
       <entry>hyperbolic sine</entry>
-->
       <entry>双曲線正弦</entry>
       <entry><literal>sinh(0)</literal></entry>
       <entry><literal>0</literal></entry>
      </row>
      <row>
       <entry>
        <indexterm>
         <primary>cosh</primary>
        </indexterm>
        <literal><function>cosh(<replaceable>x</replaceable>)</function></literal>
       </entry>
<!--
       <entry>hyperbolic cosine</entry>
-->
       <entry>双曲線余弦</entry>
       <entry><literal>cosh(0)</literal></entry>
       <entry><literal>1</literal></entry>
      </row>
      <row>
       <entry>
        <indexterm>
         <primary>tanh</primary>
        </indexterm>
        <literal><function>tanh(<replaceable>x</replaceable>)</function></literal>
       </entry>
<!--
       <entry>hyperbolic tangent</entry>
-->
       <entry>双曲線正接</entry>
       <entry><literal>tanh(0)</literal></entry>
       <entry><literal>0</literal></entry>
      </row>
      <row>
       <entry>
        <indexterm>
         <primary>asinh</primary>
        </indexterm>
        <literal><function>asinh(<replaceable>x</replaceable>)</function></literal>
       </entry>
<!--
       <entry>inverse hyperbolic sine</entry>
-->
       <entry>逆双曲線正弦</entry>
       <entry><literal>asinh(0)</literal></entry>
       <entry><literal>0</literal></entry>
      </row>
      <row>
       <entry>
        <indexterm>
         <primary>acosh</primary>
        </indexterm>
        <literal><function>acosh(<replaceable>x</replaceable>)</function></literal>
       </entry>
<!--
       <entry>inverse hyperbolic cosine</entry>
-->
       <entry>逆双曲線余弦</entry>
       <entry><literal>acosh(1)</literal></entry>
       <entry><literal>0</literal></entry>
      </row>
      <row>
       <entry>
        <indexterm>
         <primary>atanh</primary>
        </indexterm>
        <literal><function>atanh(<replaceable>x</replaceable>)</function></literal>
       </entry>
<!--
       <entry>inverse hyperbolic tangent</entry>
-->
       <entry>逆双曲線正接</entry>
       <entry><literal>atanh(0)</literal></entry>
       <entry><literal>0</literal></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  </sect1>


  <sect1 id="functions-string">
<!--
   <title>String Functions and Operators</title>
-->
   <title>文字列関数と演算子</title>

   <para>
<!--
    This section describes functions and operators for examining and
    manipulating string values.  Strings in this context include values
    of the types <type>character</type>, <type>character varying</type>,
    and <type>text</type>.  Unless otherwise noted, all
    of the functions listed below work on all of these types, but be
    wary of potential effects of automatic space-padding when using the
    <type>character</type> type.  Some functions also exist
    natively for the bit-string types.
-->
本節では文字列の値の調査や操作のための関数と演算子について説明します。
ここでの文字列とは<type>character</type>データ型、<type>character varying</type>データ型、および<type>text</type>データ型の値を含みます。
補足説明のない限り、下記に挙げている全ての関数はこれら全てのデータ型に対して使用できますが、<type>character</type>データ型を使用した場合、自動的に空白文字が詰め込まれるという潜在的作用がありますので注意してください。
ビット文字列データ型に対する専用の関数もいくつかあります。
   </para>

   <para>
<!--
    <acronym>SQL</acronym> defines some string functions that use
    key words, rather than commas, to separate
    arguments.  Details are in
    <xref linkend="functions-string-sql"/>.
    <productname>PostgreSQL</productname> also provides versions of these functions
    that use the regular function invocation syntax
    (see <xref linkend="functions-string-other"/>).
-->
<acronym>SQL</acronym>では引数の区切りにカンマではなくキーワードを使用する文字列関数をいくつか定義しています。
詳細については<xref linkend="functions-string-sql"/>を参照してください。
また<productname>PostgreSQL</productname>は、これらの関数に対して通常の関数呼び出し構文を使用するバージョンを提供します（<xref linkend="functions-string-other"/>を参照してください）。
   </para>

   <note>
    <para>
<!--
     Before <productname>PostgreSQL</productname> 8.3, these functions would
     silently accept values of several non-string data types as well, due to
     the presence of implicit coercions from those data types to
     <type>text</type>.  Those coercions have been removed because they frequently
     caused surprising behaviors.  However, the string concatenation operator
     (<literal>||</literal>) still accepts non-string input, so long as at least one
     input is of a string type, as shown in <xref
     linkend="functions-string-sql"/>.  For other cases, insert an explicit
     coercion to <type>text</type> if you need to duplicate the previous behavior.
-->
<productname>PostgreSQL</productname>の8.3より前において、これらの関数はいくつかの非文字列データ型の値を警告なしに受け付けたのは、それらデータ型を暗黙的に<type>text</type>型に型変換していたことによります。
この強制的な変換は、頻繁に予期しない動作の原因となったので削除されました。
しかし、文字列連結演算子（<literal>||</literal>）は<xref linkend="functions-string-sql"/>で示されるように、少なくともひとつの入力が文字列型であれば、依然として非文字列入力を受け付けます。
その他の場合、以前と同じ動作が必要なら、<type>text</type>への明示的な変換を行ってください。
    </para>
   </note>

   <table id="functions-string-sql">
<!--
    <title><acronym>SQL</acronym> String Functions and Operators</title>
-->
    <title><acronym>SQL</acronym>文字列関数と演算子</title>
    <tgroup cols="5">
     <thead>
      <row>
<!--
       <entry>Function</entry>
       <entry>Return Type</entry>
       <entry>Description</entry>
       <entry>Example</entry>
       <entry>Result</entry>
-->
       <entry>関数</entry>
       <entry>戻り値型</entry>
       <entry>説明</entry>
       <entry>例</entry>
       <entry>結果</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry><literal><parameter>string</parameter> <literal>||</literal>
        <parameter>string</parameter></literal></entry>
       <entry> <type>text</type> </entry>
       <entry>
<!--
        String concatenation
-->
        文字列結合
        <indexterm>
<!--
         <primary>character string</primary>
         <secondary>concatenation</secondary>
-->
         <primary>文字列</primary>
         <secondary>結合</secondary>
        </indexterm>
       </entry>
       <entry><literal>'Post' || 'greSQL'</literal></entry>
       <entry><literal>PostgreSQL</literal></entry>
      </row>

      <row>
       <entry>
<!--
        <literal><parameter>string</parameter> <literal>||</literal>
        <parameter>non-string</parameter></literal>
        or
        <literal><parameter>non-string</parameter> <literal>||</literal>
        <parameter>string</parameter></literal>
-->
        <literal><parameter>文字列</parameter> <literal>||</literal>
        <parameter>非文字列</parameter></literal>
        または、
        <literal><parameter>非文字列</parameter> <literal>||</literal>
        <parameter>文字列</parameter></literal>
       </entry>
       <entry> <type>text</type> </entry>
       <entry>
<!--
        String concatenation with one non-string input
-->
        ひとつの非文字列の入力がある文字列結合
       </entry>
       <entry><literal>'Value: ' || 42</literal></entry>
       <entry><literal>Value: 42</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>bit_length</primary>
        </indexterm>
        <literal><function>bit_length(<parameter>string</parameter>)</function></literal>
       </entry>
       <entry><type>int</type></entry>
<!--
       <entry>Number of bits in string</entry>
-->
       <entry>文字列中のビット数</entry>
       <entry><literal>bit_length('jose')</literal></entry>
       <entry><literal>32</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>char_length</primary>
        </indexterm>
<!--
        <literal><function>char_length(<parameter>string</parameter>)</function></literal> or <literal><function>character_length(<parameter>string</parameter>)</function></literal>
-->
        <literal><function>char_length(<parameter>string</parameter>)</function></literal> または <literal><function>character_length(<parameter>string</parameter>)</function></literal>
       </entry>
       <entry><type>int</type></entry>
       <entry>
<!--
        Number of characters in string
-->
        文字列中の文字数
        <indexterm>
<!--
         <primary>character string</primary>
         <secondary>length</secondary>
-->
         <primary>文字列</primary>
         <secondary>長さ</secondary>
        </indexterm>
        <indexterm>
<!--
         <primary>length</primary>
         <secondary sortas="character string">of a character string</secondary>
         <see>character string, length</see>
-->
         <primary>長さ</primary>
         <secondary sortas="character string">文字列の</secondary>
         <see>文字列, 長さ</see>
        </indexterm>
       </entry>
       <entry><literal>char_length('jose')</literal></entry>
       <entry><literal>4</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>lower</primary>
        </indexterm>
        <literal><function>lower(<parameter>string</parameter>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
<!--
       <entry>Convert string to lower case</entry>
-->
       <entry>文字列を小文字に変換</entry>
       <entry><literal>lower('TOM')</literal></entry>
       <entry><literal>tom</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>octet_length</primary>
        </indexterm>
        <literal><function>octet_length(<parameter>string</parameter>)</function></literal>
       </entry>
       <entry><type>int</type></entry>
<!--
       <entry>Number of bytes in string</entry>
-->
       <entry>文字列中のバイト数</entry>
       <entry><literal>octet_length('jose')</literal></entry>
       <entry><literal>4</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>overlay</primary>
        </indexterm>
        <literal><function>overlay(<parameter>string</parameter> placing <parameter>string</parameter> from <type>int</type> <optional>for <type>int</type></optional>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
<!--
        Replace substring
-->
        部分文字列の置換
       </entry>
       <entry><literal>overlay('Txxxxas' placing 'hom' from 2 for 4)</literal></entry>
       <entry><literal>Thomas</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>position</primary>
        </indexterm>
        <literal><function>position(<parameter>substring</parameter> in <parameter>string</parameter>)</function></literal>
       </entry>
       <entry><type>int</type></entry>
<!--
       <entry>Location of specified substring</entry>
-->
       <entry>指定した部分文字列の場所</entry>
       <entry><literal>position('om' in 'Thomas')</literal></entry>
       <entry><literal>3</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>substring</primary>
        </indexterm>
        <literal><function>substring(<parameter>string</parameter> <optional>from <type>int</type></optional> <optional>for <type>int</type></optional>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
<!--
        Extract substring
-->
        部分文字列の取り出し
       </entry>
       <entry><literal>substring('Thomas' from 2 for 3)</literal></entry>
       <entry><literal>hom</literal></entry>
      </row>

      <row>
       <entry><literal><function>substring(<parameter>string</parameter> from <replaceable>pattern</replaceable>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>
<!--
        Extract substring matching POSIX regular expression. See
        <xref linkend="functions-matching"/> for more information on pattern
        matching.
-->
POSIX正規表現に一致する部分文字列を取り出します。
パターンマッチに関してより詳細は、<xref linkend="functions-matching"/>を参照してください。
       </entry>
       <entry><literal>substring('Thomas' from '...$')</literal></entry>
       <entry><literal>mas</literal></entry>
      </row>

      <row>
       <entry><literal><function>substring(<parameter>string</parameter> from <replaceable>pattern</replaceable> for <replaceable>escape</replaceable>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>
<!--
        Extract substring matching <acronym>SQL</acronym> regular expression.
        See <xref linkend="functions-matching"/> for more information on
        pattern matching.
-->
<acronym>SQL</acronym>正規表現に一致する部分文字列を取り出します。
パターンマッチに関してより詳細は、<xref linkend="functions-matching"/>を参照してください。
       </entry>
       <entry><literal>substring('Thomas' from '%#"o_a#"_' for '#')</literal></entry>
       <entry><literal>oma</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>trim</primary>
        </indexterm>
        <literal><function>trim(<optional>leading | trailing | both</optional>
        <optional><parameter>characters</parameter></optional> from
        <parameter>string</parameter>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
<!--
        Remove the longest string containing only characters from
        <parameter>characters</parameter> (a space by default) from the
        start, end, or both ends (<literal>both</literal> is the default)
        of <parameter>string</parameter>
-->
<parameter>characters</parameter>（デフォルトでは空白）に含まれる文字のみを含む最も長い文字列を、<parameter>string</parameter>の先頭（start）、末尾（end）、あるいはその両方（both、デフォルトは<literal>both</literal>です）から削除します。
       </entry>
       <entry><literal>trim(both 'xyz' from 'yxTomxx')</literal></entry>
       <entry><literal>Tom</literal></entry>
      </row>

      <row>
       <entry>
        <literal><function>trim(<optional>leading | trailing
        | both</optional> <optional>from</optional>
        <parameter>string</parameter>
        <optional>, <parameter>characters</parameter></optional>
        )</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
<!--
        Non-standard syntax for <function>trim()</function>
-->
        <function>trim()</function>の標準と異なる構文
       </entry>
       <entry><literal>trim(both from 'yxTomxx', 'xyz')</literal></entry>
       <entry><literal>Tom</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>upper</primary>
        </indexterm>
        <literal><function>upper(<parameter>string</parameter>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
<!--
       <entry>Convert string to upper case</entry>
-->
       <entry>文字列を大文字に変換</entry>
       <entry><literal>upper('tom')</literal></entry>
       <entry><literal>TOM</literal></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
<!--
    Additional string manipulation functions are available and are
    listed in <xref linkend="functions-string-other"/>.  Some of them are used internally to implement the
    <acronym>SQL</acronym>-standard string functions listed in <xref linkend="functions-string-sql"/>.
-->
この他、<xref linkend="functions-string-other"/>に列挙する文字列操作関数が使えます。
そのいくつかは、<xref linkend="functions-string-sql"/>で列挙した標準<acronym>SQL</acronym>の文字列関数を実装するため、内部的に使用されます。
   </para>

   <table id="functions-string-other">
<!--
    <title>Other String Functions</title>
-->
    <title>その他の文字列関数</title>
    <tgroup cols="5">
     <thead>
      <row>
<!--
       <entry>Function</entry>
       <entry>Return Type</entry>
       <entry>Description</entry>
       <entry>Example</entry>
       <entry>Result</entry>
-->
       <entry>関数</entry>
       <entry>戻り値型</entry>
       <entry>説明</entry>
       <entry>例</entry>
       <entry>結果</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry>
        <indexterm>
         <primary>ascii</primary>
        </indexterm>
        <literal><function>ascii(<parameter>string</parameter>)</function></literal>
       </entry>
       <entry><type>int</type></entry>
       <entry>
<!--
        <acronym>ASCII</acronym> code of the first character of the
        argument.  For <acronym>UTF8</acronym> returns the Unicode code
        point of the character.  For other multibyte encodings, the
        argument must be an <acronym>ASCII</acronym> character.
-->
引数の最初の文字の<acronym>ASCII</acronym>コード。
<acronym>UTF8</acronym>に対しては文字のUnicodeコードポイントを返します。
その他のマルチバイト符号化方式の場合、引数は<acronym>ASCII</acronym>文字でなくてはなりません。
       </entry>
       <entry><literal>ascii('x')</literal></entry>
       <entry><literal>120</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>btrim</primary>
        </indexterm>
        <literal><function>btrim(<parameter>string</parameter> <type>text</type>
        <optional>, <parameter>characters</parameter> <type>text</type></optional>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
<!--
        Remove the longest string consisting only of characters
        in <parameter>characters</parameter> (a space by default)
        from the start and end of <parameter>string</parameter>
-->
<parameter>characters</parameter>（デフォルトは空白文字）で指定された文字のみを有する最長の文字列を、<parameter>string</parameter>の先頭と末尾から削除します。
       </entry>
       <entry><literal>btrim('xyxtrimyyx', 'xyz')</literal></entry>
       <entry><literal>trim</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>chr</primary>
        </indexterm>
        <literal><function>chr(<type>int</type>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
<!--
        Character with the given code. For <acronym>UTF8</acronym> the
        argument is treated as a Unicode code point. For other multibyte
        encodings the argument must designate an
        <acronym>ASCII</acronym> character.  The NULL (0) character is not
        allowed because text data types cannot store such bytes.
-->
与えられたコードの文字。<acronym>UTF8</acronym>では引数はUnicodeコードポイントとして扱われます。
その他のマルチバイト符号化方式で引数は<acronym>ASCII</acronym>文字を指定するものである必要があります。
NULL (0)文字はテキストデータ型がそのようなバイトを格納することができないので許可されません。
       </entry>
       <entry><literal>chr(65)</literal></entry>
       <entry><literal>A</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>concat</primary>
        </indexterm>
        <literal><function>concat(<parameter>str</parameter> <type>"any"</type>
         [, <parameter>str</parameter> <type>"any"</type> [, ...] ])</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
<!--
        Concatenate the text representations of all the arguments.
        NULL arguments are ignored.
-->
すべての引数のテキスト表現を結合します。NULLの引数は無視されます。
       </entry>
       <entry><literal>concat('abcde', 2, NULL, 22)</literal></entry>
       <entry><literal>abcde222</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>concat_ws</primary>
        </indexterm>
        <literal><function>concat_ws(<parameter>sep</parameter> <type>text</type>,
        <parameter>str</parameter> <type>"any"</type>
        [, <parameter>str</parameter> <type>"any"</type> [, ...] ])</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
<!--
        Concatenate all but the first argument with separators. The first
        argument is used as the separator string. NULL arguments are ignored.
-->
第一引数を除くすべての引数を、区切り文字を付けて結合します。
第一引数は区切り文字列として使用されます。
NULLの引数は無視されます。
       </entry>
       <entry><literal>concat_ws(',', 'abcde', 2, NULL, 22)</literal></entry>
       <entry><literal>abcde,2,22</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>convert</primary>
        </indexterm>
        <literal><function>convert(<parameter>string</parameter> <type>bytea</type>,
        <parameter>src_encoding</parameter> <type>name</type>,
        <parameter>dest_encoding</parameter> <type>name</type>)</function></literal>
       </entry>
       <entry><type>bytea</type></entry>
       <entry>
<!--
        Convert string to <parameter>dest_encoding</parameter>.  The
        original encoding is specified by
        <parameter>src_encoding</parameter>. The
        <parameter>string</parameter> must be valid in this encoding.
        Conversions can be defined by <command>CREATE CONVERSION</command>.
        Also there are some predefined conversions. See <xref
        linkend="conversion-names"/> for available conversions.
-->
文字列を<parameter>dest_encoding</parameter>に変換します。
元の符号化方式は<parameter>src_encoding</parameter>で指定されます。
<parameter>string</parameter>はこの符号化方式で有効でなければなりません。
変換は<command>CREATE CONVERSION</command>で定義されます。
また、あらかじめ定義された変換もあります。
利用可能な変換については<xref linkend="conversion-names"/>を参照してください。
       </entry>
       <entry><literal>convert('text_in_utf8', 'UTF8', 'LATIN1')</literal></entry>
<!--
       <entry><literal>text_in_utf8</literal> represented in Latin-1
       encoding (ISO 8859-1)</entry>
-->
       <entry>Latin-1（ISO 8859-1）符号化方式の<literal>text_in_utf8</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>convert_from</primary>
        </indexterm>
        <literal><function>convert_from(<parameter>string</parameter> <type>bytea</type>,
        <parameter>src_encoding</parameter> <type>name</type>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
<!--
        Convert string to the database encoding.  The original encoding
        is specified by <parameter>src_encoding</parameter>. The
        <parameter>string</parameter> must be valid in this encoding.
-->
データベースの符号化方式に文字列を変換します。
元の符号化方式は<parameter>src_encoding</parameter>で指定されます。
<parameter>string</parameter>はこの符号化方式で有効なものでなければなりません。
       </entry>
       <entry><literal>convert_from('text_in_utf8', 'UTF8')</literal></entry>
<!--
       <entry><literal>text_in_utf8</literal> represented in the current database encoding</entry>
-->
       <entry>現在のデータベース符号化方式の<literal>text_in_utf8</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>convert_to</primary>
        </indexterm>
        <literal><function>convert_to(<parameter>string</parameter> <type>text</type>,
        <parameter>dest_encoding</parameter> <type>name</type>)</function></literal>
       </entry>
       <entry><type>bytea</type></entry>
       <entry>
<!--
        Convert string to <parameter>dest_encoding</parameter>.
-->
        文字列を<parameter>dest_encoding</parameter>に変換します。
       </entry>
       <entry><literal>convert_to('some text', 'UTF8')</literal></entry>
<!--
       <entry><literal>some text</literal> represented in the UTF8 encoding</entry>
-->
       <entry>UTF8符号化方式の<literal>some text</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>decode</primary>
        </indexterm>
        <literal><function>decode(<parameter>string</parameter> <type>text</type>,
        <parameter>format</parameter> <type>text</type>)</function></literal>
       </entry>
       <entry><type>bytea</type></entry>
       <entry>
<!--
        Decode binary data from textual representation in <parameter>string</parameter>.
        Options for <parameter>format</parameter> are same as in <function>encode</function>.
-->
<parameter>string</parameter>のテキスト表現からバイナリデータを復号します。
<parameter>format</parameter>のオプションは<function>encode()</function>と同じです。
       </entry>
       <entry><literal>decode('MTIzAAE=', 'base64')</literal></entry>
       <entry><literal>\x3132330001</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>encode</primary>
        </indexterm>
        <literal><function>encode(<parameter>data</parameter> <type>bytea</type>,
        <parameter>format</parameter> <type>text</type>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
<!--
        Encode binary data into a textual representation.  Supported
        formats are: <literal>base64</literal>, <literal>hex</literal>, <literal>escape</literal>.
        <literal>escape</literal> converts zero bytes and high-bit-set bytes to
        octal sequences (<literal>\</literal><replaceable>nnn</replaceable>) and
        doubles backslashes.
-->
バイナリデータをテキスト表現形式に符号化します。
サポートされているformatは、<literal>base64</literal>、<literal>hex</literal>、<literal>escape</literal>です。
<literal>escape</literal>は0のバイトと最上位ビットがセットされているバイトを8進数のシーケンス(<literal>\</literal><replaceable>nnn</replaceable>)に変換し 、バックスラッシュを二重化します。
       </entry>
       <entry><literal>encode('123\000\001', 'base64')</literal></entry>
       <entry><literal>MTIzAAE=</literal></entry>
      </row>

      <row>
       <entry id="format">
        <indexterm>
         <primary>format</primary>
        </indexterm>
        <literal><function>format</function>(<parameter>formatstr</parameter> <type>text</type>
        [, <parameter>formatarg</parameter> <type>"any"</type> [, ...] ])</literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
<!--
         Format arguments according to a format string.
         This function is similar to the C function <function>sprintf</function>.
         See <xref linkend="functions-string-format"/>.
-->
引数の書式をフォーマット文字列に従って整えます。
この関数はC言語関数の<function>sprintf</function>と似ています。
<xref linkend="functions-string-format"/>を参照してください。
       </entry>
       <entry><literal>format('Hello %s, %1$s', 'World')</literal></entry>
       <entry><literal>Hello World, World</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>initcap</primary>
        </indexterm>
        <literal><function>initcap(<parameter>string</parameter>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
<!--
        Convert the first letter of each word to upper case and the
        rest to lower case. Words are sequences of alphanumeric
        characters separated by non-alphanumeric characters.
-->
それぞれの単語の第一文字を大文字に、残りは小文字に変換します。
ここで単語とは、英数字以外の文字で区切られた、英数字からなる文字の並びのことです。
       </entry>
       <entry><literal>initcap('hi THOMAS')</literal></entry>
       <entry><literal>Hi Thomas</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>left</primary>
        </indexterm>
        <literal><function>left(<parameter>str</parameter> <type>text</type>,
        <parameter>n</parameter> <type>int</type>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
<!--
        Return first <replaceable>n</replaceable> characters in the string. When <replaceable>n</replaceable>
        is negative, return all but last |<replaceable>n</replaceable>| characters.
-->
文字列の先頭から<replaceable>n</replaceable>文字を返します。
<replaceable>n</replaceable>が負数の場合、文字列の末尾から|<replaceable>n</replaceable>|文字を切り取った文字列を返します。
        </entry>
       <entry><literal>left('abcde', 2)</literal></entry>
       <entry><literal>ab</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>length</primary>
        </indexterm>
        <literal><function>length(<parameter>string</parameter>)</function></literal>
       </entry>
       <entry><type>int</type></entry>
       <entry>
<!--
        Number of characters in <parameter>string</parameter>
-->
        <parameter>string</parameter>内の文字数
       </entry>
       <entry><literal>length('jose')</literal></entry>
       <entry><literal>4</literal></entry>
      </row>

      <row>
       <entry><literal><function>length(<parameter>string</parameter> <type>bytea</type>,
        <parameter>encoding</parameter> <type>name</type> )</function></literal></entry>
       <entry><type>int</type></entry>
       <entry>
<!--
        Number of characters in <parameter>string</parameter> in the given
        <parameter>encoding</parameter>. The <parameter>string</parameter>
        must be valid in this encoding.
-->
与えられた<parameter>encoding</parameter>での<parameter>string</parameter>内の文字数。
<parameter>string</parameter>はこの符号化方式で有効でなければなりません。
       </entry>
       <entry><literal>length('jose', 'UTF8')</literal></entry>
       <entry><literal>4</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>lpad</primary>
        </indexterm>
        <literal><function>lpad(<parameter>string</parameter> <type>text</type>,
        <parameter>length</parameter> <type>int</type>
        <optional>, <parameter>fill</parameter> <type>text</type></optional>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
<!--
        Fill up the <parameter>string</parameter> to length
        <parameter>length</parameter> by prepending the characters
        <parameter>fill</parameter> (a space by default).  If the
        <parameter>string</parameter> is already longer than
        <parameter>length</parameter> then it is truncated (on the
        right).
-->
文字<parameter>fill</parameter>（デフォルトは空白文字）を文字列の前に追加して、<parameter>string</parameter>を<parameter>length</parameter>の長さにします。
<parameter>string</parameter>が既に<parameter>length</parameter>の長さを超えている場合は（右側が）切り捨てられます。
       </entry>
       <entry><literal>lpad('hi', 5, 'xy')</literal></entry>
       <entry><literal>xyxhi</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>ltrim</primary>
        </indexterm>
        <literal><function>ltrim(<parameter>string</parameter> <type>text</type>
        <optional>, <parameter>characters</parameter> <type>text</type></optional>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
<!--
        Remove the longest string containing only characters from
        <parameter>characters</parameter> (a space by default) from the start of
        <parameter>string</parameter>
-->
<parameter>string</parameter>の最初から、<parameter>characters</parameter>（デフォルトはスペース）で指定された文字だけを有する最長の文字列を削除します。
       </entry>
       <entry><literal>ltrim('zzzytest', 'xyz')</literal></entry>
       <entry><literal>test</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>md5</primary>
        </indexterm>
        <literal><function>md5(<parameter>string</parameter>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
<!--
        Calculates the MD5 hash of <parameter>string</parameter>,
        returning the result in hexadecimal
-->
<parameter>string</parameter>のMD5ハッシュを計算し、16進数で結果を返します。
       </entry>
       <entry><literal>md5('abc')</literal></entry>
       <entry><literal>900150983cd24fb0 d6963f7d28e17f72</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>parse_ident</primary>
        </indexterm>
        <literal><function>parse_ident(<parameter>qualified_identifier</parameter> <type>text</type>
           [, <parameter>strictmode</parameter> <type>boolean</type> DEFAULT true ] )</function></literal>
       </entry>
       <entry><type>text[]</type></entry>
       <entry>
<!--
        Split <parameter>qualified_identifier</parameter> into an array of
        identifiers, removing any quoting of individual identifiers.  By
        default, extra characters after the last identifier are considered an
        error; but if the second parameter is <literal>false</literal>, then such
        extra characters are ignored. (This behavior is useful for parsing
        names for objects like functions.) Note that this function does not
        truncate over-length identifiers. If you want truncation you can cast
        the result to <type>name[]</type>.
-->
<parameter>qualified_identifier</parameter>を識別子の配列に分割し、個々の識別子に引用符があればそれを削除します。
デフォルトでは、最後の識別子の後に続く余分な文字はエラーとされますが、2番目のパラメータが<literal>false</literal>の場合は、そのような余分な文字は無視されます。
（この動作は、関数のようなオブジェクトに対して名前を解析するときに便利でしょう。）
この関数は、長すぎる識別子を切り詰めないことに注意してください。
切り詰めが必要なときは、その結果を<type>name[]</type>にキャストすることができます。
       </entry>
       <entry><literal>parse_ident('"SomeSchema".someTable')</literal></entry>
       <entry><literal>{SomeSchema,sometable}</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>pg_client_encoding</primary>
        </indexterm>
        <literal><function>pg_client_encoding()</function></literal>
       </entry>
       <entry><type>name</type></entry>
       <entry>
<!--
        Current client encoding name
-->
        現在のクライアントの符号化方式の名前。
       </entry>
       <entry><literal>pg_client_encoding()</literal></entry>
       <entry><literal>SQL_ASCII</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>quote_ident</primary>
        </indexterm>
        <literal><function>quote_ident(<parameter>string</parameter> <type>text</type>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
<!--
        Return the given string suitably quoted to be used as an identifier
        in an <acronym>SQL</acronym> statement string.
        Quotes are added only if necessary (i.e., if the string contains
        non-identifier characters or would be case-folded).
        Embedded quotes are properly doubled.
        See also <xref linkend="plpgsql-quote-literal-example"/>.
-->
与えられた文字列を、<acronym>SQL</acronym>問い合わせ文字列で識別子として使用できるように、適切な引用符を付けて返します。
引用符は、必要な場合（すなわち、文字列に識別子として使用できない文字が含まれる場合や、大文字変換される場合）にのみ追加されます。埋め込まれた引用符は、適切に二重化されます。
<xref linkend="plpgsql-quote-literal-example"/>も参照してください。
       </entry>
       <entry><literal>quote_ident('Foo bar')</literal></entry>
       <entry><literal>"Foo bar"</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>quote_literal</primary>
        </indexterm>
        <literal><function>quote_literal(<parameter>string</parameter> <type>text</type>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
<!--
        Return the given string suitably quoted to be used as a string literal
        in an <acronym>SQL</acronym> statement string.
        Embedded single-quotes and backslashes are properly doubled.
        Note that <function>quote_literal</function> returns null on null
        input; if the argument might be null,
        <function>quote_nullable</function> is often more suitable.
        See also <xref linkend="plpgsql-quote-literal-example"/>.
-->
与えられた文字列を、<acronym>SQL</acronym>問い合わせ文字列で文字リテラルとして使用できるように、適切な引用符を付けて返します。
埋め込まれた単一引用符およびバックスラッシュは、適切に二重化されます。
<function>quote_literal</function>はNULL入力に対してNULLを返すことに注意してください。引数がNULLとなる可能性がある場合、より<function>quote_nullable</function>の方がしばしば適しています。
<xref linkend="plpgsql-quote-literal-example"/>も参照してください。
       </entry>
       <entry><literal>quote_literal(E'O\'Reilly')</literal></entry>
       <entry><literal>'O''Reilly'</literal></entry>
      </row>

      <row>
       <entry><literal><function>quote_literal(<parameter>value</parameter> <type>anyelement</type>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>
<!--
        Coerce the given value to text and then quote it as a literal.
        Embedded single-quotes and backslashes are properly doubled.
-->
与えられた値をテキストに変換し、そしてリテラルとして引用符付けします。
埋め込まれた単一引用符とバックスラッシュは適切に二重化されます。
       </entry>
       <entry><literal>quote_literal(42.5)</literal></entry>
       <entry><literal>'42.5'</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>quote_nullable</primary>
        </indexterm>
        <literal><function>quote_nullable(<parameter>string</parameter> <type>text</type>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
<!--
        Return the given string suitably quoted to be used as a string literal
        in an <acronym>SQL</acronym> statement string; or, if the argument
        is null, return <literal>NULL</literal>.
        Embedded single-quotes and backslashes are properly doubled.
        See also <xref linkend="plpgsql-quote-literal-example"/>.
-->
与えられた文字列を、<acronym>SQL</acronym>問い合わせ文字列で文字列リテラルとして使用できるように、適切な引用符を付けて返します。
また、引数がNULLの場合、<literal>NULL</literal>を返します。
埋め込まれた単一引用符およびバックスラッシュは適切に二重化されます。
<xref linkend="plpgsql-quote-literal-example"/>も参照してください。
       </entry>
       <entry><literal>quote_nullable(NULL)</literal></entry>
       <entry><literal>NULL</literal></entry>
      </row>

      <row>
       <entry><literal><function>quote_nullable(<parameter>value</parameter> <type>anyelement</type>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>
<!--
        Coerce the given value to text and then quote it as a literal;
        or, if the argument is null, return <literal>NULL</literal>.
        Embedded single-quotes and backslashes are properly doubled.
-->
与えられた値をテキストに変換し、そしてリテラルとして引用符付けします。引数がNULLの場合は<literal>NULL</literal>を返します。
埋め込まれた単一引用符とバックスラッシュは適切に二重化されます。
       </entry>
       <entry><literal>quote_nullable(42.5)</literal></entry>
       <entry><literal>'42.5'</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>regexp_match</primary>
        </indexterm>
        <literal><function>regexp_match(<parameter>string</parameter> <type>text</type>, <parameter>pattern</parameter> <type>text</type> [, <parameter>flags</parameter> <type>text</type>])</function></literal>
       </entry>
       <entry><type>text[]</type></entry>
       <entry>
<!--
        Return captured substring(s) resulting from the first match of a POSIX
        regular expression to the <parameter>string</parameter>. See
        <xref linkend="functions-posix-regexp"/> for more information.
-->
<parameter>string</parameter>に対してPOSIX正規表現でマッチし、捕捉された最初の部分文字列を返します。
より詳細は<xref linkend="functions-posix-regexp"/>を参照してください。
       </entry>
       <entry><literal>regexp_match('foobarbequebaz', '(bar)(beque)')</literal></entry>
       <entry><literal>{bar,beque}</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>regexp_matches</primary>
        </indexterm>
        <literal><function>regexp_matches(<parameter>string</parameter> <type>text</type>, <parameter>pattern</parameter> <type>text</type> [, <parameter>flags</parameter> <type>text</type>])</function></literal>
       </entry>
       <entry><type>setof text[]</type></entry>
       <entry>
<!--
        Return captured substring(s) resulting from matching a POSIX regular
        expression to the <parameter>string</parameter>. See
        <xref linkend="functions-posix-regexp"/> for more information.
-->
<parameter>string</parameter>に対してPOSIX正規表現でマッチし、捕捉された部分文字列を返します。
より詳細は<xref linkend="functions-posix-regexp"/>を参照してください。
       </entry>
       <entry><literal>regexp_matches('foobarbequebaz', 'ba.', 'g')</literal></entry>
       <entry><literal>{bar}</literal><para><literal>{baz}</literal></para> (2 rows)</entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>regexp_replace</primary>
        </indexterm>
        <literal><function>regexp_replace(<parameter>string</parameter> <type>text</type>, <parameter>pattern</parameter> <type>text</type>, <parameter>replacement</parameter> <type>text</type> [, <parameter>flags</parameter> <type>text</type>])</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
<!--
        Replace substring(s) matching a POSIX regular expression. See
        <xref linkend="functions-posix-regexp"/> for more information.
-->
POSIX正規表現に一致する部分文字列を置換します。
より詳細は<xref linkend="functions-posix-regexp"/>を参照してください。
       </entry>
       <entry><literal>regexp_replace('Thomas', '.[mN]a.', 'M')</literal></entry>
       <entry><literal>ThM</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>regexp_split_to_array</primary>
        </indexterm>
        <literal><function>regexp_split_to_array(<parameter>string</parameter> <type>text</type>, <parameter>pattern</parameter> <type>text</type> [, <parameter>flags</parameter> <type>text</type> ])</function></literal>
       </entry>
       <entry><type>text[]</type></entry>
       <entry>
<!--
        Split <parameter>string</parameter> using a POSIX regular expression as
        the delimiter.  See <xref linkend="functions-posix-regexp"/> for more
        information.
-->
POSIX正規表現を区切り文字に使って<parameter>string</parameter>を分割します。
詳しくは<xref linkend="functions-posix-regexp"/>を参照ください。
       </entry>
       <entry><literal>regexp_split_to_array('hello world', '\s+')</literal></entry>
       <entry><literal>{hello,world}</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>regexp_split_to_table</primary>
        </indexterm>
        <literal><function>regexp_split_to_table(<parameter>string</parameter> <type>text</type>, <parameter>pattern</parameter> <type>text</type> [, <parameter>flags</parameter> <type>text</type>])</function></literal>
       </entry>
       <entry><type>setof text</type></entry>
       <entry>
<!--
        Split <parameter>string</parameter> using a POSIX regular expression as
        the delimiter.  See <xref linkend="functions-posix-regexp"/> for more
        information.
-->
POSIX正規表現を区切り文字に使って<parameter>string</parameter>を分割します。
詳しくは<xref linkend="functions-posix-regexp"/>を参照ください。
       </entry>
       <entry><literal>regexp_split_to_table('hello world', '\s+')</literal></entry>
       <entry><literal>hello</literal><para><literal>world</literal></para> (2 rows)</entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>repeat</primary>
        </indexterm>
        <literal><function>repeat(<parameter>string</parameter> <type>text</type>, <parameter>number</parameter> <type>int</type>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
<!--
       <entry>Repeat <parameter>string</parameter> the specified
       <parameter>number</parameter> of times</entry>
-->
       <entry>指定された<parameter>number</parameter>の数だけ<parameter>string</parameter>を繰り返します。</entry>
       <entry><literal>repeat('Pg', 4)</literal></entry>
       <entry><literal>PgPgPgPg</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>replace</primary>
        </indexterm>
        <literal><function>replace(<parameter>string</parameter> <type>text</type>,
        <parameter>from</parameter> <type>text</type>,
        <parameter>to</parameter> <type>text</type>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
<!--
       <entry>Replace all occurrences in <parameter>string</parameter> of substring
        <parameter>from</parameter> with substring <parameter>to</parameter>
-->
       <entry><parameter>string</parameter>に出現する全ての<parameter>from</parameter>部分文字列を<parameter>to</parameter>部分文字列に置換します。
       </entry>
       <entry><literal>replace('abcdefabcdef', 'cd', 'XX')</literal></entry>
       <entry><literal>abXXefabXXef</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>reverse</primary>
        </indexterm>
        <literal><function>reverse(<parameter>str</parameter>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
<!--
        Return reversed string.
-->
        逆順にした文字列を返します。
       </entry>
       <entry><literal>reverse('abcde')</literal></entry>
       <entry><literal>edcba</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>right</primary>
        </indexterm>
        <literal><function>right(<parameter>str</parameter> <type>text</type>,
         <parameter>n</parameter> <type>int</type>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
<!--
        Return last <replaceable>n</replaceable> characters in the string. When <replaceable>n</replaceable>
        is negative, return all but first |<replaceable>n</replaceable>| characters.
-->
文字列の末尾から<replaceable>n</replaceable>文字を返します。
<replaceable>n</replaceable>が負数の場合は、文字列の先頭から|<replaceable>n</replaceable>|文字だけ切り取った文字列を返します。
       </entry>
       <entry><literal>right('abcde', 2)</literal></entry>
       <entry><literal>de</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>rpad</primary>
        </indexterm>
        <literal><function>rpad(<parameter>string</parameter> <type>text</type>,
        <parameter>length</parameter> <type>int</type>
        <optional>, <parameter>fill</parameter> <type>text</type></optional>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
<!--
        Fill up the <parameter>string</parameter> to length
        <parameter>length</parameter> by appending the characters
        <parameter>fill</parameter> (a space by default).  If the
        <parameter>string</parameter> is already longer than
        <parameter>length</parameter> then it is truncated.
-->
文字<parameter>fill</parameter>（デフォルトはスペース）を文字列に追加して、<parameter>string</parameter>を<parameter>length</parameter>の長さにします。
<parameter>string</parameter>が既に<parameter>length</parameter>の長さを超えている場合は切り捨てられます。
       </entry>
       <entry><literal>rpad('hi', 5, 'xy')</literal></entry>
       <entry><literal>hixyx</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>rtrim</primary>
        </indexterm>
        <literal><function>rtrim(<parameter>string</parameter> <type>text</type>
         <optional>, <parameter>characters</parameter> <type>text</type></optional>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
<!--
        Remove the longest string containing only characters from
        <parameter>characters</parameter> (a space by default) from the end of
        <parameter>string</parameter>
-->
<parameter>string</parameter>の末尾から、<parameter>characters</parameter>（デフォルトはスペース）で指定された文字のみを有する最長の文字列を削除します。
       </entry>
       <entry><literal>rtrim('testxxzx', 'xyz')</literal></entry>
       <entry><literal>test</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>split_part</primary>
        </indexterm>
        <literal><function>split_part(<parameter>string</parameter> <type>text</type>,
        <parameter>delimiter</parameter> <type>text</type>,
        <parameter>field</parameter> <type>int</type>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
<!--
       <entry>Split <parameter>string</parameter> on <parameter>delimiter</parameter>
        and return the given field (counting from one)
-->
       <entry><parameter>string</parameter>を<parameter>delimiter</parameter>で分割し、その結果から（1から始まるように数える）指定したフィールドを返します。
       </entry>
       <entry><literal>split_part('abc~@~def~@~ghi', '~@~', 2)</literal></entry>
       <entry><literal>def</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>strpos</primary>
        </indexterm>
        <literal><function>strpos(<parameter>string</parameter>, <parameter>substring</parameter>)</function></literal>
       </entry>
       <entry><type>int</type></entry>
       <entry>
<!--
        Location of specified substring (same as
        <literal>position(<parameter>substring</parameter> in
         <parameter>string</parameter>)</literal>, but note the reversed
        argument order)
-->
指定した部分文字列の位置を特定します（<literal>position(<parameter>substring</parameter> in <parameter>string</parameter>)</literal> と同じですが、引数の順序が逆になっていることに注意してください）。
       </entry>
       <entry><literal>strpos('high', 'ig')</literal></entry>
       <entry><literal>2</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>substr</primary>
        </indexterm>
        <literal><function>substr(<parameter>string</parameter>, <parameter>from</parameter> <optional>, <parameter>count</parameter></optional>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
<!--
        Extract substring (same as
        <literal>substring(<parameter>string</parameter> from <parameter>from</parameter> for <parameter>count</parameter>)</literal>)
-->
指定した部分文字列を取り出します（<literal>substring(<parameter>string</parameter> from <parameter>from</parameter> for <parameter>count</parameter>)</literal>と同じです）。
       </entry>
       <entry><literal>substr('alphabet', 3, 2)</literal></entry>
       <entry><literal>ph</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>starts_with</primary>
        </indexterm>
        <literal><function>starts_with(<parameter>string</parameter>, <parameter>prefix</parameter>)</function></literal>
       </entry>
       <entry><type>bool</type></entry>
       <entry>
<!--
        Returns true if <parameter>string</parameter> starts with <parameter>prefix</parameter>.
-->
<parameter>string</parameter>が<parameter>prefix</parameter>で始まっていれば真を返します。
       </entry>
       <entry><literal>starts_with('alphabet', 'alph')</literal></entry>
       <entry><literal>t</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>to_ascii</primary>
        </indexterm>
        <literal><function>to_ascii(<parameter>string</parameter> <type>text</type>
        <optional>, <parameter>encoding</parameter> <type>text</type></optional>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
<!--
       Convert <parameter>string</parameter> to <acronym>ASCII</acronym> from another encoding
       (only supports conversion from  <literal>LATIN1</literal>, <literal>LATIN2</literal>, <literal>LATIN9</literal>,
       and <literal>WIN1250</literal> encodings)
-->
<parameter>string</parameter>を他の符号化方式から<acronym>ASCII</acronym>に変換します（<literal>LATIN1</literal>、<literal>LATIN2</literal>、<literal>LATIN9</literal>、<literal>WIN1250</literal>符号化方式からの変換のみをサポートします。）
       </entry>
       <entry><literal>to_ascii('Karel')</literal></entry>
       <entry><literal>Karel</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>to_hex</primary>
        </indexterm>
        <literal><function>to_hex(<parameter>number</parameter> <type>int</type>
        or <type>bigint</type>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
<!--
       <entry>Convert <parameter>number</parameter> to its equivalent hexadecimal
        representation
-->
       <entry><parameter>number</parameter>を、同等の16進数表現に変換します。
       </entry>
       <entry><literal>to_hex(2147483647)</literal></entry>
       <entry><literal>7fffffff</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>translate</primary>
        </indexterm>
        <literal><function>translate(<parameter>string</parameter> <type>text</type>,
        <parameter>from</parameter> <type>text</type>,
        <parameter>to</parameter> <type>text</type>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
<!--
        Any character in <parameter>string</parameter> that matches a
        character in the <parameter>from</parameter> set is replaced by
        the corresponding character in the <parameter>to</parameter>
        set. If <parameter>from</parameter> is longer than
        <parameter>to</parameter>, occurrences of the extra characters in
        <parameter>from</parameter> are removed.
-->
<parameter>from</parameter>集合内の文字と一致する<parameter>string</parameter>にある全ての文字は、<parameter>to</parameter>集合内のそれに対応する文字に置き換えられます。
もし<parameter>from</parameter>が<parameter>to</parameter>より長い場合、<parameter>from</parameter>で指定される余分な文字に一致するものは削除されます。
       </entry>
       <entry><literal>translate('12345', '143', 'ax')</literal></entry>
       <entry><literal>a2x5</literal></entry>
      </row>

     </tbody>
    </tgroup>
   </table>

   <para>
<!--
    The <function>concat</function>, <function>concat_ws</function> and
    <function>format</function> functions are variadic, so it is possible to
    pass the values to be concatenated or formatted as an array marked with
    the <literal>VARIADIC</literal> keyword (see <xref
    linkend="xfunc-sql-variadic-functions"/>).  The array's elements are
    treated as if they were separate ordinary arguments to the function.
    If the variadic array argument is NULL, <function>concat</function>
    and <function>concat_ws</function> return NULL, but
    <function>format</function> treats a NULL as a zero-element array.
-->
<function>concat</function>、<function>concat_ws</function>および<function>format</function>関数はVariadicです。従って、キーワード<literal>VARIADIC</literal>で標しをつけられた配列のように、値を連結またはフォーマットした形で受け渡すことが可能です（<xref linkend="xfunc-sql-variadic-functions"/>を参照してください）。
配列の要素は関数に対して分割された通常の引数のように扱われます。
もしvariadic配列引数がNULLであれば、<function>concat</function>および<function>concat_ws</function>はNULLを返しますが、<function>format</function>はNULLを要素を持たない配列と扱います。
   </para>

   <para>
<!--
   See also the aggregate function <function>string_agg</function> in
   <xref linkend="functions-aggregate"/>.
-->
<xref linkend="functions-aggregate"/>内の<function>string_agg</function>集約関数も参照してください。
   </para>

   <table id="conversion-names">
<!--
    <title>Built-in Conversions</title>
-->
    <title>組み込みの変換</title>
    <tgroup cols="3">
     <thead>
      <row>
<!--
       <entry>Conversion Name
-->
       <entry>変換名
        <footnote>
         <para>
<!--
          The conversion names follow a standard naming scheme: The
          official name of the source encoding with all
          non-alphanumeric characters replaced by underscores, followed
          by <literal>_to_</literal>, followed by the similarly processed
          destination encoding name. Therefore, the names might deviate
          from the customary encoding names.
-->
変換名は、標準命名体系に従っています。変換元符号化方式の公式名の内、英数字以外の文字をアンダースコアで置き換え、その後に<literal>_to_</literal>を付け、そして変換先符号化方式名を同様に処理したものを続けたものです。
したがって、これらの名称は慣習的なコード名とは異なる可能性があります。
         </para>
        </footnote>
       </entry>
<!--
       <entry>Source Encoding</entry>
       <entry>Destination Encoding</entry>
-->
       <entry>変換前の符号化方式</entry>
       <entry>変換後の符号化方式</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry><literal>ascii_to_mic</literal></entry>
       <entry><literal>SQL_ASCII</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>ascii_to_utf8</literal></entry>
       <entry><literal>SQL_ASCII</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>big5_to_euc_tw</literal></entry>
       <entry><literal>BIG5</literal></entry>
       <entry><literal>EUC_TW</literal></entry>
      </row>

      <row>
       <entry><literal>big5_to_mic</literal></entry>
       <entry><literal>BIG5</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>big5_to_utf8</literal></entry>
       <entry><literal>BIG5</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>euc_cn_to_mic</literal></entry>
       <entry><literal>EUC_CN</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>euc_cn_to_utf8</literal></entry>
       <entry><literal>EUC_CN</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>euc_jp_to_mic</literal></entry>
       <entry><literal>EUC_JP</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>euc_jp_to_sjis</literal></entry>
       <entry><literal>EUC_JP</literal></entry>
       <entry><literal>SJIS</literal></entry>
      </row>

      <row>
       <entry><literal>euc_jp_to_utf8</literal></entry>
       <entry><literal>EUC_JP</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>euc_kr_to_mic</literal></entry>
       <entry><literal>EUC_KR</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>euc_kr_to_utf8</literal></entry>
       <entry><literal>EUC_KR</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>euc_tw_to_big5</literal></entry>
       <entry><literal>EUC_TW</literal></entry>
       <entry><literal>BIG5</literal></entry>
      </row>

      <row>
       <entry><literal>euc_tw_to_mic</literal></entry>
       <entry><literal>EUC_TW</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>euc_tw_to_utf8</literal></entry>
       <entry><literal>EUC_TW</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>gb18030_to_utf8</literal></entry>
       <entry><literal>GB18030</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>gbk_to_utf8</literal></entry>
       <entry><literal>GBK</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_10_to_utf8</literal></entry>
       <entry><literal>LATIN6</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_13_to_utf8</literal></entry>
       <entry><literal>LATIN7</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_14_to_utf8</literal></entry>
       <entry><literal>LATIN8</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_15_to_utf8</literal></entry>
       <entry><literal>LATIN9</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_16_to_utf8</literal></entry>
       <entry><literal>LATIN10</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_1_to_mic</literal></entry>
       <entry><literal>LATIN1</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_1_to_utf8</literal></entry>
       <entry><literal>LATIN1</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_2_to_mic</literal></entry>
       <entry><literal>LATIN2</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_2_to_utf8</literal></entry>
       <entry><literal>LATIN2</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_2_to_windows_1250</literal></entry>
       <entry><literal>LATIN2</literal></entry>
       <entry><literal>WIN1250</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_3_to_mic</literal></entry>
       <entry><literal>LATIN3</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_3_to_utf8</literal></entry>
       <entry><literal>LATIN3</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_4_to_mic</literal></entry>
       <entry><literal>LATIN4</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_4_to_utf8</literal></entry>
       <entry><literal>LATIN4</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_5_to_koi8_r</literal></entry>
       <entry><literal>ISO_8859_5</literal></entry>
       <entry><literal>KOI8R</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_5_to_mic</literal></entry>
       <entry><literal>ISO_8859_5</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_5_to_utf8</literal></entry>
       <entry><literal>ISO_8859_5</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_5_to_windows_1251</literal></entry>
       <entry><literal>ISO_8859_5</literal></entry>
       <entry><literal>WIN1251</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_5_to_windows_866</literal></entry>
       <entry><literal>ISO_8859_5</literal></entry>
       <entry><literal>WIN866</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_6_to_utf8</literal></entry>
       <entry><literal>ISO_8859_6</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_7_to_utf8</literal></entry>
       <entry><literal>ISO_8859_7</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_8_to_utf8</literal></entry>
       <entry><literal>ISO_8859_8</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_9_to_utf8</literal></entry>
       <entry><literal>LATIN5</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>johab_to_utf8</literal></entry>
       <entry><literal>JOHAB</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>koi8_r_to_iso_8859_5</literal></entry>
       <entry><literal>KOI8R</literal></entry>
       <entry><literal>ISO_8859_5</literal></entry>
      </row>

      <row>
       <entry><literal>koi8_r_to_mic</literal></entry>
       <entry><literal>KOI8R</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>koi8_r_to_utf8</literal></entry>
       <entry><literal>KOI8R</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>koi8_r_to_windows_1251</literal></entry>
       <entry><literal>KOI8R</literal></entry>
       <entry><literal>WIN1251</literal></entry>
      </row>

      <row>
       <entry><literal>koi8_r_to_windows_866</literal></entry>
       <entry><literal>KOI8R</literal></entry>
       <entry><literal>WIN866</literal></entry>
      </row>

      <row>
       <entry><literal>koi8_u_to_utf8</literal></entry>
       <entry><literal>KOI8U</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_ascii</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>SQL_ASCII</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_big5</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>BIG5</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_euc_cn</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>EUC_CN</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_euc_jp</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>EUC_JP</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_euc_kr</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>EUC_KR</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_euc_tw</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>EUC_TW</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_iso_8859_1</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>LATIN1</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_iso_8859_2</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>LATIN2</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_iso_8859_3</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>LATIN3</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_iso_8859_4</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>LATIN4</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_iso_8859_5</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>ISO_8859_5</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_koi8_r</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>KOI8R</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_sjis</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>SJIS</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_windows_1250</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>WIN1250</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_windows_1251</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>WIN1251</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_windows_866</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>WIN866</literal></entry>
      </row>

      <row>
       <entry><literal>sjis_to_euc_jp</literal></entry>
       <entry><literal>SJIS</literal></entry>
       <entry><literal>EUC_JP</literal></entry>
      </row>

      <row>
       <entry><literal>sjis_to_mic</literal></entry>
       <entry><literal>SJIS</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>sjis_to_utf8</literal></entry>
       <entry><literal>SJIS</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>windows_1258_to_utf8</literal></entry>
       <entry><literal>WIN1258</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>uhc_to_utf8</literal></entry>
       <entry><literal>UHC</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_ascii</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>SQL_ASCII</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_big5</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>BIG5</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_euc_cn</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>EUC_CN</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_euc_jp</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>EUC_JP</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_euc_kr</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>EUC_KR</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_euc_tw</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>EUC_TW</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_gb18030</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>GB18030</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_gbk</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>GBK</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_iso_8859_1</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>LATIN1</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_iso_8859_10</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>LATIN6</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_iso_8859_13</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>LATIN7</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_iso_8859_14</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>LATIN8</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_iso_8859_15</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>LATIN9</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_iso_8859_16</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>LATIN10</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_iso_8859_2</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>LATIN2</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_iso_8859_3</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>LATIN3</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_iso_8859_4</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>LATIN4</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_iso_8859_5</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>ISO_8859_5</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_iso_8859_6</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>ISO_8859_6</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_iso_8859_7</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>ISO_8859_7</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_iso_8859_8</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>ISO_8859_8</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_iso_8859_9</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>LATIN5</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_johab</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>JOHAB</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_koi8_r</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>KOI8R</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_koi8_u</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>KOI8U</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_sjis</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>SJIS</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_windows_1258</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>WIN1258</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_uhc</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>UHC</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_windows_1250</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>WIN1250</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_windows_1251</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>WIN1251</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_windows_1252</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>WIN1252</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_windows_1253</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>WIN1253</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_windows_1254</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>WIN1254</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_windows_1255</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>WIN1255</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_windows_1256</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>WIN1256</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_windows_1257</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>WIN1257</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_windows_866</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>WIN866</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_windows_874</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>WIN874</literal></entry>
      </row>

      <row>
       <entry><literal>windows_1250_to_iso_8859_2</literal></entry>
       <entry><literal>WIN1250</literal></entry>
       <entry><literal>LATIN2</literal></entry>
      </row>

      <row>
       <entry><literal>windows_1250_to_mic</literal></entry>
       <entry><literal>WIN1250</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>windows_1250_to_utf8</literal></entry>
       <entry><literal>WIN1250</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>windows_1251_to_iso_8859_5</literal></entry>
       <entry><literal>WIN1251</literal></entry>
       <entry><literal>ISO_8859_5</literal></entry>
      </row>

      <row>
       <entry><literal>windows_1251_to_koi8_r</literal></entry>
       <entry><literal>WIN1251</literal></entry>
       <entry><literal>KOI8R</literal></entry>
      </row>

      <row>
       <entry><literal>windows_1251_to_mic</literal></entry>
       <entry><literal>WIN1251</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>windows_1251_to_utf8</literal></entry>
       <entry><literal>WIN1251</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>windows_1251_to_windows_866</literal></entry>
       <entry><literal>WIN1251</literal></entry>
       <entry><literal>WIN866</literal></entry>
      </row>

      <row>
       <entry><literal>windows_1252_to_utf8</literal></entry>
       <entry><literal>WIN1252</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>windows_1256_to_utf8</literal></entry>
       <entry><literal>WIN1256</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>windows_866_to_iso_8859_5</literal></entry>
       <entry><literal>WIN866</literal></entry>
       <entry><literal>ISO_8859_5</literal></entry>
      </row>

      <row>
       <entry><literal>windows_866_to_koi8_r</literal></entry>
       <entry><literal>WIN866</literal></entry>
       <entry><literal>KOI8R</literal></entry>
      </row>

      <row>
       <entry><literal>windows_866_to_mic</literal></entry>
       <entry><literal>WIN866</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>windows_866_to_utf8</literal></entry>
       <entry><literal>WIN866</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>windows_866_to_windows_1251</literal></entry>
       <entry><literal>WIN866</literal></entry>
       <entry><literal>WIN</literal></entry>
      </row>

      <row>
       <entry><literal>windows_874_to_utf8</literal></entry>
       <entry><literal>WIN874</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>euc_jis_2004_to_utf8</literal></entry>
       <entry><literal>EUC_JIS_2004</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_euc_jis_2004</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>EUC_JIS_2004</literal></entry>
      </row>

      <row>
       <entry><literal>shift_jis_2004_to_utf8</literal></entry>
       <entry><literal>SHIFT_JIS_2004</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_shift_jis_2004</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>SHIFT_JIS_2004</literal></entry>
      </row>

      <row>
       <entry><literal>euc_jis_2004_to_shift_jis_2004</literal></entry>
       <entry><literal>EUC_JIS_2004</literal></entry>
       <entry><literal>SHIFT_JIS_2004</literal></entry>
      </row>

      <row>
       <entry><literal>shift_jis_2004_to_euc_jis_2004</literal></entry>
       <entry><literal>SHIFT_JIS_2004</literal></entry>
       <entry><literal>EUC_JIS_2004</literal></entry>
      </row>

     </tbody>
    </tgroup>
   </table>

   <sect2 id="functions-string-format">
    <title><function>format</function></title>

    <indexterm>
     <primary>format</primary>
    </indexterm>

    <para>
<!--
     The function <function>format</function> produces output formatted according to
     a format string, in a style similar to the C function
     <function>sprintf</function>.
-->
関数<function>format</function>は、C関数の<function>sprintf</function>同様の形式で、フォーマット文字列に従ってフォーマットされた出力を生成します。
    </para>

    <para>
<synopsis>
<function>format</function>(<parameter>formatstr</parameter> <type>text</type> [, <parameter>formatarg</parameter> <type>"any"</type> [, ...] ])
</synopsis>
<!--
     <replaceable>formatstr</replaceable> is a format string that specifies how the
     result should be formatted.  Text in the format string is copied
     directly to the result, except where <firstterm>format specifiers</firstterm> are
     used.  Format specifiers act as placeholders in the string, defining how
     subsequent function arguments should be formatted and inserted into the
     result.  Each <replaceable>formatarg</replaceable> argument is converted to text
     according to the usual output rules for its data type, and then formatted
     and inserted into the result string according to the format specifier(s).
-->
<replaceable>formatstr</replaceable>は結果がどのようにフォーマットされるかを指定するフォーマット文字列です。
<firstterm>フォーマット指示子</firstterm>が使用されている箇所を除き、フォーマット文字列のテキストは結果に直接コピーされます。
フォーマット指示子は文字列中のプレースホルダとして振舞い、その後に引き続く関数引数がどのようにフォーマットされ、どのように結果に挿入されるかを定義します。
それぞれの<replaceable>formatarg</replaceable>引数はそのデータ型に対する通常の出力規定に従ってテキストに変換され、その後フォーマット指示子に従って、結果文字列に挿入されます。
    </para>

    <para>
<!--
     Format specifiers are introduced by a <literal>%</literal> character and have
     the form
-->
フォーマット指示子は<literal>%</literal>文字で始まり、以下の形式をとります。
<synopsis>
%[<replaceable>position</replaceable>][<replaceable>flags</replaceable>][<replaceable>width</replaceable>]<replaceable>type</replaceable>
</synopsis>
<!--
     where the component fields are:
-->
ここで要素フィールドとは以下になっています。

     <variablelist>
      <varlistentry>
<!--
       <term><replaceable>position</replaceable> (optional)</term>
-->
       <term><replaceable>position</replaceable> (省略可能)</term>
       <listitem>
        <para>
<!--
         A string of the form <literal><replaceable>n</replaceable>$</literal> where
         <replaceable>n</replaceable> is the index of the argument to print.
         Index 1 means the first argument after
         <replaceable>formatstr</replaceable>.  If the <replaceable>position</replaceable> is
         omitted, the default is to use the next argument in sequence.
-->
形式<literal><replaceable>n</replaceable>$</literal>の文字列で、<replaceable>n</replaceable>は出力する引数のインデックスです。
インデックス１は<replaceable>formatstr</replaceable>の後の最初の引数です。
<replaceable>position</replaceable>が省略されると、一連の中の次の引数がデフォルトとして使用されます。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
<!--
       <term><replaceable>flags</replaceable> (optional)</term>
-->
       <term><replaceable>flags</replaceable> (省略可能)</term>
       <listitem>
        <para>
<!--
         Additional options controlling how the format specifier's output is
         formatted.  Currently the only supported flag is a minus sign
         (<literal>-</literal>) which will cause the format specifier's output to be
         left-justified.  This has no effect unless the <replaceable>width</replaceable>
         field is also specified.
-->
フォーマット指示子の出力がどのようにフォーマットされるかを制御する追加の任意の要素です。
現在、サポートされているflagはマイナス記号(<literal>-</literal>)のみで、フォーマット指示子の出力が左詰めになるようにします。
これは<replaceable>width</replaceable>フィールドが同時に指定されていない場合効果はありません。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
<!--
       <term><replaceable>width</replaceable> (optional)</term>
-->
       <term><replaceable>width</replaceable> (省略可能)</term>
       <listitem>
        <para>
<!--
         Specifies the <emphasis>minimum</emphasis> number of characters to use to
         display the format specifier's output.  The output is padded on the
         left or right (depending on the <literal>-</literal> flag) with spaces as
         needed to fill the width.  A too-small width does not cause
         truncation of the output, but is simply ignored.  The width may be
         specified using any of the following: a positive integer; an
         asterisk (<literal>*</literal>) to use the next function argument as the
         width; or a string of the form <literal>*<replaceable>n</replaceable>$</literal> to
         use the <replaceable>n</replaceable>th function argument as the width.
-->
フォーマット指示子の出力を表示する<emphasis>最小</emphasis>文字数を指定します。
出力は、幅を満たすのに必要な空白が左または右（flagの<literal>-</literal>による）に埋め込まれます。
幅が小さすぎても出力が切り詰められることはなく、単に無視されます。
幅は次のいずれかでも指定できます。それらは、正の整数、幅としての次の関数引数として使用する星印 (<literal>*</literal>)、または<replaceable>n</replaceable>番目の関数引数を幅として使用する<literal>*<replaceable>n</replaceable>$</literal>という形式の文字列です。
        </para>

        <para>
<!--
         If the width comes from a function argument, that argument is
         consumed before the argument that is used for the format specifier's
         value.  If the width argument is negative, the result is left
         aligned (as if the <literal>-</literal> flag had been specified) within a
         field of length <function>abs</function>(<replaceable>width</replaceable>).
-->
幅を関数引数から取得する場合、その引数はフォーマット指示子の値に使用される引数より先に消費されます。
幅の引数が負の場合、フィールド長<function>abs</function>(<replaceable>width</replaceable>)の範囲内で結果は（あたかもflagで<literal>-</literal>が指定されたように）左詰めになります。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
<!--
       <term><replaceable>type</replaceable> (required)</term>
-->
       <term><replaceable>type</replaceable> (必須)</term>
       <listitem>
        <para>
<!--
         The type of format conversion to use to produce the format
         specifier's output.  The following types are supported:
-->
フォーマット指示子の出力を生成するのに使用されるフォーマット変換の型。
以下の型がサポートされています。
         <itemizedlist>
          <listitem>
           <para>
<!--
            <literal>s</literal> formats the argument value as a simple
            string.  A null value is treated as an empty string.
-->
<literal>s</literal>は引数の値を単純文字列にフォーマットします。
NULL値は空文字列として扱われます。
           </para>
          </listitem>
          <listitem>
           <para>
<!--
            <literal>I</literal> treats the argument value as an SQL
            identifier, double-quoting it if necessary.
            It is an error for the value to be null (equivalent to
            <function>quote_ident</function>).
-->
<literal>I</literal>は、引数をSQLの識別子として取り扱い、必要ならそれを二重引用符で括ります。
NULL値はエラーです（<function>quote_ident</function>と同等です）。
           </para>
          </listitem>
          <listitem>
           <para>
<!--
            <literal>L</literal> quotes the argument value as an SQL literal.
            A null value is displayed as the string <literal>NULL</literal>, without
            quotes (equivalent to <function>quote_nullable</function>).
-->
<literal>L</literal>は引数値をSQLリテラルとして引用符が付けられます。
NULL値は引用符無しの文字列<literal>NULL</literal>となります（<function>quote_nullable</function>と同等です）。
           </para>
          </listitem>
         </itemizedlist>
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>

    <para>
<!--
     In addition to the format specifiers described above, the special sequence
     <literal>%%</literal> may be used to output a literal <literal>%</literal> character.
-->
上記で説明したフォーマット指示子に加え、特別の並びの<literal>%%</literal>がリテラル<literal>%</literal>文字を出力するために使用することもできます。
    </para>

    <para>
<!--
     Here are some examples of the basic format conversions:
-->
基本的なフォーマット変換の例を幾つか下記に紹介します。

<screen>
SELECT format('Hello %s', 'World');
<lineannotation>Result: </lineannotation><computeroutput>Hello World</computeroutput>

SELECT format('Testing %s, %s, %s, %%', 'one', 'two', 'three');
<lineannotation>Result: </lineannotation><computeroutput>Testing one, two, three, %</computeroutput>

SELECT format('INSERT INTO %I VALUES(%L)', 'Foo bar', E'O\'Reilly');
<lineannotation>Result: </lineannotation><computeroutput>INSERT INTO "Foo bar" VALUES('O''Reilly')</computeroutput>

SELECT format('INSERT INTO %I VALUES(%L)', 'locations', 'C:\Program Files');
<lineannotation>Result: </lineannotation><computeroutput>INSERT INTO locations VALUES('C:\Program Files')</computeroutput>
</screen>
    </para>

    <para>
<!--
     Here are examples using <replaceable>width</replaceable> fields
     and the <literal>-</literal> flag:
-->
<replaceable>width</replaceable>フィールドとflagの<literal>-</literal>を使用した例を以下に示します。

<screen>
SELECT format('|%10s|', 'foo');
<lineannotation>Result: </lineannotation><computeroutput>|       foo|</computeroutput>

SELECT format('|%-10s|', 'foo');
<lineannotation>Result: </lineannotation><computeroutput>|foo       |</computeroutput>

SELECT format('|%*s|', 10, 'foo');
<lineannotation>Result: </lineannotation><computeroutput>|       foo|</computeroutput>

SELECT format('|%*s|', -10, 'foo');
<lineannotation>Result: </lineannotation><computeroutput>|foo       |</computeroutput>

SELECT format('|%-*s|', 10, 'foo');
<lineannotation>Result: </lineannotation><computeroutput>|foo       |</computeroutput>

SELECT format('|%-*s|', -10, 'foo');
<lineannotation>Result: </lineannotation><computeroutput>|foo       |</computeroutput>
</screen>
    </para>

    <para>
<!--
     These examples show use of <replaceable>position</replaceable> fields:
-->
以下の例は<replaceable>position</replaceable>フィールドの使い方を示しています。

<screen>
SELECT format('Testing %3$s, %2$s, %1$s', 'one', 'two', 'three');
<lineannotation>Result: </lineannotation><computeroutput>Testing three, two, one</computeroutput>

SELECT format('|%*2$s|', 'foo', 10, 'bar');
<lineannotation>Result: </lineannotation><computeroutput>|       bar|</computeroutput>

SELECT format('|%1$*2$s|', 'foo', 10, 'bar');
<lineannotation>Result: </lineannotation><computeroutput>|       foo|</computeroutput>
</screen>
    </para>

    <para>
<!--
     Unlike the standard C function <function>sprintf</function>,
     <productname>PostgreSQL</productname>'s <function>format</function> function allows format
     specifiers with and without <replaceable>position</replaceable> fields to be mixed
     in the same format string.  A format specifier without a
     <replaceable>position</replaceable> field always uses the next argument after the
     last argument consumed.
     In addition, the <function>format</function> function does not require all
     function arguments to be used in the format string.
     For example:
-->
標準C関数<function>sprintf</function>とは違って、<productname>PostgreSQL</productname>の<function>format</function>関数は、同一のフォーマット文字列の中で<replaceable>position</replaceable>フィールドがあるフォーマット指示子と、それがないフォーマット指示子の混在を許容します。
<replaceable>position</replaceable>フィールドが無いフォーマット指示子は常に最終の引数が消費された後に次の引数を使用します。
さらに、<function>format</function>関数はフォーマット文字列で使用されるべき全ての関数引数を要求しません。
例を示します。

<screen>
SELECT format('Testing %3$s, %2$s, %s', 'one', 'two', 'three');
<lineannotation>Result: </lineannotation><computeroutput>Testing three, two, three</computeroutput>
</screen>
    </para>

    <para>
<!--
     The <literal>%I</literal> and <literal>%L</literal> format specifiers are particularly
     useful for safely constructing dynamic SQL statements.  See
     <xref linkend="plpgsql-quote-literal-example"/>.
-->
<literal>%I</literal> および <literal>%L</literal>のフォーマット指示子は特に動的SQL命令を安全に構築する場合に便利です。
<xref linkend="plpgsql-quote-literal-example"/>を参照してください。
    </para>
   </sect2>

  </sect1>


  <sect1 id="functions-binarystring">
<!--
   <title>Binary String Functions and Operators</title>
-->
   <title>バイナリ文字列関数と演算子</title>

   <indexterm zone="functions-binarystring">
<!--
    <primary>binary data</primary>
    <secondary>functions</secondary>
-->
    <primary>バイナリデータ</primary>
    <secondary>関数</secondary>
   </indexterm>

   <para>
<!--
    This section describes functions and operators for examining and
    manipulating values of type <type>bytea</type>.
-->
本節では<type>bytea</type>型の値を調べたり操作するための関数と演算子について説明します。
   </para>

   <para>
<!--
    <acronym>SQL</acronym> defines some string functions that use
    key words, rather than commas, to separate
    arguments.  Details are in
    <xref linkend="functions-binarystring-sql"/>.
    <productname>PostgreSQL</productname> also provides versions of these functions
    that use the regular function invocation syntax
    (see <xref linkend="functions-binarystring-other"/>).
-->
<acronym>SQL</acronym>では、引数の区切りにカンマではなくキーワードを使う文字列関数を、いくつか定義しています。
詳細は<xref linkend="functions-binarystring-sql"/>を参照してください。
また<productname>PostgreSQL</productname>は、これらの関数に対して通常の関数呼び出し構文を使用するバージョンを提供します（<xref linkend="functions-string-other"/>を参照してください）。
   </para>

   <note>
<!--
    <para>
     The sample results shown on this page assume that the server parameter
     <link linkend="guc-bytea-output"><varname>bytea_output</varname></link> is set
     to <literal>escape</literal> (the traditional PostgreSQL format).
    </para>
-->
    <para>
このページで示されるサンプル結果は、サーバパラメータである<link linkend="guc-bytea-output"><varname>bytea_output</varname></link>が<literal>escape</literal>に設定されていることを想定しています(この設定はPostgreSQLの伝統的な形式です)。
    </para>
   </note>

   <table id="functions-binarystring-sql">
<!--
    <title><acronym>SQL</acronym> Binary String Functions and Operators</title>
-->
    <title><acronym>SQL</acronym>バイナリ文字列関数と演算子</title>
    <tgroup cols="5">
     <thead>
      <row>
<!--
       <entry>Function</entry>
       <entry>Return Type</entry>
       <entry>Description</entry>
       <entry>Example</entry>
       <entry>Result</entry>
-->
       <entry>関数</entry>
       <entry>戻り値型</entry>
       <entry>説明</entry>
       <entry>例</entry>
       <entry>結果</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry><literal><parameter>string</parameter> <literal>||</literal>
        <parameter>string</parameter></literal></entry>
       <entry> <type>bytea</type> </entry>
       <entry>
<!--
        String concatenation
-->
        文字列結合
        <indexterm>
<!--
         <primary>binary string</primary>
         <secondary>concatenation</secondary>
-->
         <primary>バイナリ文字列</primary>
         <secondary>結合</secondary>
        </indexterm>
       </entry>
       <entry><literal>'\\Post'::bytea || '\047gres\000'::bytea</literal></entry>
       <entry><literal>\\Post'gres\000</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>octet_length</primary>
        </indexterm>
        <literal><function>octet_length(<parameter>string</parameter>)</function></literal>
       </entry>
       <entry><type>int</type></entry>
<!--
       <entry>Number of bytes in binary string</entry>
-->
       <entry>バイナリ文字列中のバイト数</entry>
       <entry><literal>octet_length('jo\000se'::bytea)</literal></entry>
       <entry><literal>5</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>overlay</primary>
        </indexterm>
        <literal><function>overlay(<parameter>string</parameter> placing <parameter>string</parameter> from <type>int</type> <optional>for <type>int</type></optional>)</function></literal>
       </entry>
       <entry><type>bytea</type></entry>
       <entry>
<!--
        Replace substring
-->
        部分文字列の置換
       </entry>
       <entry><literal>overlay('Th\000omas'::bytea placing '\002\003'::bytea from 2 for 3)</literal></entry>
       <entry><literal>T\\002\\003mas</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>position</primary>
        </indexterm>
        <literal><function>position(<parameter>substring</parameter> in <parameter>string</parameter>)</function></literal>
       </entry>
       <entry><type>int</type></entry>
<!--
       <entry>Location of specified substring</entry>
-->
       <entry>指定した部分文字列の位置</entry>
      <entry><literal>position('\000om'::bytea in 'Th\000omas'::bytea)</literal></entry>
       <entry><literal>3</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>substring</primary>
        </indexterm>
        <literal><function>substring(<parameter>string</parameter> <optional>from <type>int</type></optional> <optional>for <type>int</type></optional>)</function></literal>
       </entry>
       <entry><type>bytea</type></entry>
       <entry>
<!--
        Extract substring
-->
        部分文字列の抽出
       </entry>
       <entry><literal>substring('Th\000omas'::bytea from 2 for 3)</literal></entry>
       <entry><literal>h\000o</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>trim</primary>
        </indexterm>
        <literal><function>trim(<optional>both</optional>
        <parameter>bytes</parameter> from
        <parameter>string</parameter>)</function></literal>
       </entry>
       <entry><type>bytea</type></entry>
       <entry>
<!--
        Remove the longest string containing only bytes appearing in
        <parameter>bytes</parameter> from the start
        and end of <parameter>string</parameter>
-->
文字列<parameter>string</parameter>の先頭および末尾から<parameter>bytes</parameter>に含まれるバイトのみを含む最長の文字列を削除します。
       </entry>
       <entry><literal>trim('\000\001'::bytea from '\000Tom\001'::bytea)</literal></entry>
       <entry><literal>Tom</literal></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
<!--
    Additional binary string manipulation functions are available and
    are listed in <xref linkend="functions-binarystring-other"/>.  Some
    of them are used internally to implement the
    <acronym>SQL</acronym>-standard string functions listed in <xref
    linkend="functions-binarystring-sql"/>.
-->
この他、<xref linkend="functions-binarystring-other"/>に列挙するバイナリ列操作関数が使えます。
そのいくつかは、<xref linkend="functions-binarystring-sql"/>で説明した標準<acronym>SQL</acronym>の文字列関数を実装するために内部的に使用されています。
   </para>

   <table id="functions-binarystring-other">
<!--
    <title>Other Binary String Functions</title>
-->
    <title>その他のバイナリ文字列関数</title>
    <tgroup cols="5">
     <thead>
      <row>
<!--
       <entry>Function</entry>
       <entry>Return Type</entry>
       <entry>Description</entry>
       <entry>Example</entry>
       <entry>Result</entry>
-->
       <entry>関数</entry>
       <entry>戻り値型</entry>
       <entry>説明</entry>
       <entry>例</entry>
       <entry>結果</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry>
        <indexterm>
         <primary>btrim</primary>
        </indexterm>
        <literal><function>btrim(<parameter>string</parameter>
        <type>bytea</type>, <parameter>bytes</parameter> <type>bytea</type>)</function></literal>
       </entry>
       <entry><type>bytea</type></entry>
       <entry>
<!--
        Remove the longest string containing only bytes appearing in
        <parameter>bytes</parameter> from the start and end of
        <parameter>string</parameter>
-->
<parameter>bytes</parameter>に含まれるバイトのみを有する最長の文字列を<parameter>string</parameter>の先頭と末尾から削除します。
      </entry>
      <entry><literal>btrim('\000trim\001'::bytea, '\000\001'::bytea)</literal></entry>
      <entry><literal>trim</literal></entry>
     </row>

     <row>
      <entry>
        <indexterm>
         <primary>decode</primary>
        </indexterm>
       <literal><function>decode(<parameter>string</parameter> <type>text</type>,
       <parameter>format</parameter> <type>text</type>)</function></literal>
      </entry>
      <entry><type>bytea</type></entry>
      <entry>
<!--
       Decode binary data from textual representation in <parameter>string</parameter>.
       Options for <parameter>format</parameter> are same as in <function>encode</function>.
-->
<parameter>string</parameter>で表現されているテキストデータをバイナリデータに復号します。
<parameter>format</parameter>のオプションは<function>encode</function>と同じです。
      </entry>
      <entry><literal>decode('123\000456', 'escape')</literal></entry>
      <entry><literal>123\000456</literal></entry>
     </row>

     <row>
      <entry>
        <indexterm>
         <primary>encode</primary>
        </indexterm>
       <literal><function>encode(<parameter>data</parameter> <type>bytea</type>,
       <parameter>format</parameter> <type>text</type>)</function></literal>
      </entry>
      <entry><type>text</type></entry>
      <entry>
<!--
       Encode binary data into a textual representation.  Supported
       formats are: <literal>base64</literal>, <literal>hex</literal>, <literal>escape</literal>.
       <literal>escape</literal> converts zero bytes and high-bit-set bytes to
       octal sequences (<literal>\</literal><replaceable>nnn</replaceable>) and
       doubles backslashes.
-->
バイナリデータをテキスト表現形式に符号化します。
サポートされている形式は、<literal>base64</literal>、<literal>hex</literal>、<literal>escape</literal>です。
<literal>escape</literal>は0のバイトと最上位ビットがセットされているバイトを8進数のシーケンス(<literal>\</literal><replaceable>nnn</replaceable>)に変換し 、バックスラッシュを二重化します。
      </entry>
      <entry><literal>encode('123\000456'::bytea, 'escape')</literal></entry>
      <entry><literal>123\000456</literal></entry>
     </row>

      <row>
       <entry>
        <indexterm>
         <primary>get_bit</primary>
        </indexterm>
        <literal><function>get_bit(<parameter>string</parameter>, <parameter>offset</parameter>)</function></literal>
       </entry>
       <entry><type>int</type></entry>
       <entry>
<!--
        Extract bit from string
-->
        文字列から1ビット抽出します。
       </entry>
       <entry><literal>get_bit('Th\000omas'::bytea, 45)</literal></entry>
       <entry><literal>1</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>get_byte</primary>
        </indexterm>
        <literal><function>get_byte(<parameter>string</parameter>, <parameter>offset</parameter>)</function></literal>
       </entry>
       <entry><type>int</type></entry>
       <entry>
<!--
        Extract byte from string
-->
        文字列から1バイト抽出します。
       </entry>
       <entry><literal>get_byte('Th\000omas'::bytea, 4)</literal></entry>
       <entry><literal>109</literal></entry>
      </row>

     <row>
      <entry>
       <indexterm>
        <primary>length</primary>
       </indexterm>
       <literal><function>length(<parameter>string</parameter>)</function></literal>
      </entry>
      <entry><type>int</type></entry>
      <entry>
<!--
       Length of binary string
-->
       バイナリ文字列の長さ
       <indexterm>
<!--
        <primary>binary string</primary>
        <secondary>length</secondary>
-->
        <primary>バイナリ文字列</primary>
        <secondary>長さ</secondary>
       </indexterm>
       <indexterm>
<!--
        <primary>length</primary>
        <secondary sortas="binary string">of a binary string</secondary>
        <see>binary strings, length</see>
-->
        <primary>長さ</primary>
        <secondary sortas="binary string">バイナリ文字列の</secondary>
        <see>バイナリ文字列, 長さ</see>
       </indexterm>
      </entry>
      <entry><literal>length('jo\000se'::bytea)</literal></entry>
      <entry><literal>5</literal></entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>md5</primary>
       </indexterm>
       <literal><function>md5(<parameter>string</parameter>)</function></literal>
      </entry>
      <entry><type>text</type></entry>
      <entry>
<!--
       Calculates the MD5 hash of <parameter>string</parameter>,
       returning the result in hexadecimal
-->
       <parameter>string</parameter>のMD5のハッシュを計算し、結果を16進数で返します。
      </entry>
      <entry><literal>md5('Th\000omas'::bytea)</literal></entry>
      <entry><literal>8ab2d3c9689aaf18&#x200B;b4958c334c82d8b1</literal></entry>
     </row>

      <row>
       <entry>
        <indexterm>
         <primary>set_bit</primary>
        </indexterm>
        <literal><function>set_bit(<parameter>string</parameter>,
        <parameter>offset</parameter>, <parameter>newvalue</parameter>)</function></literal>
       </entry>
       <entry><type>bytea</type></entry>
       <entry>
<!--
        Set bit in string
-->
        文字列内のビットを設定します。
       </entry>
       <entry><literal>set_bit('Th\000omas'::bytea, 45, 0)</literal></entry>
       <entry><literal>Th\000omAs</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>set_byte</primary>
        </indexterm>
        <literal><function>set_byte(<parameter>string</parameter>,
        <parameter>offset</parameter>, <parameter>newvalue</parameter>)</function></literal>
       </entry>
       <entry><type>bytea</type></entry>
       <entry>
<!--
        Set byte in string
-->
        文字列内の1バイトを設定します。
       </entry>
       <entry><literal>set_byte('Th\000omas'::bytea, 4, 64)</literal></entry>
       <entry><literal>Th\000o@as</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>sha224</primary>
        </indexterm>
        <literal><function>sha224(<type>bytea</type>)</function></literal>
       </entry>
       <entry><type>bytea</type></entry>
       <entry>
<!--
        SHA-224 hash
-->
SHA-224ハッシュ
       </entry>
       <entry><literal>sha224('abc')</literal></entry>
       <entry><literal>\x23097d223405d8228642a477bda2&#x200B;55b32aadbce4bda0b3f7e36c9da7</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>sha256</primary>
        </indexterm>
        <literal><function>sha256(<type>bytea</type>)</function></literal>
       </entry>
       <entry><type>bytea</type></entry>
       <entry>
<!--
        SHA-256 hash
-->
SHA-256ハッシュ
       </entry>
       <entry><literal>sha256('abc')</literal></entry>
       <entry><literal>\xba7816bf8f01cfea414140de5dae2223&#x200B;b00361a396177a9cb410ff61f20015ad</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>sha384</primary>
        </indexterm>
        <literal><function>sha384(<type>bytea</type>)</function></literal>
       </entry>
       <entry><type>bytea</type></entry>
       <entry>
<!--
        SHA-384 hash
-->
SHA-384ハッシュ
       </entry>
       <entry><literal>sha384('abc')</literal></entry>
       <entry><literal>\xcb00753f45a35e8bb5a03d699ac65007&#x200B;272c32ab0eded1631a8b605a43ff5bed&#x200B;8086072ba1e7cc2358baeca134c825a7</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>sha512</primary>
        </indexterm>
        <literal><function>sha512(<type>bytea</type>)</function></literal>
       </entry>
       <entry><type>bytea</type></entry>
       <entry>
<!--
        SHA-512 hash
-->
SHA-512ハッシュ
       </entry>
       <entry><literal>sha512('abc')</literal></entry>
       <entry><literal>\xddaf35a193617abacc417349ae204131&#x200B;12e6fa4e89a97ea20a9eeee64b55d39a&#x200B;2192992a274fc1a836ba3c23a3feebbd&#x200B;454d4423643ce80e2a9ac94fa54ca49f</literal></entry>
      </row>
    </tbody>
   </tgroup>
  </table>

  <para>
<!--
   <function>get_byte</function> and <function>set_byte</function> number the first byte
   of a binary string as byte 0.
   <function>get_bit</function> and <function>set_bit</function> number bits from the
   right within each byte; for example bit 0 is the least significant bit of
   the first byte, and bit 15 is the most significant bit of the second byte.
-->
<function>get_byte</function>と<function>set_byte</function>はバイナリ列の先頭バイトを0バイトとして数えます。
<function>get_bit</function>と<function>set_bit</function>は各バイト内を右からビットを数えます。例えばビット0は先頭バイトの最下位ビットとなり、ビット15は第二バイトの最上位ビットとなります。
  </para>

  <para>
<!--
   Note that for historic reasons, the function <function>md5</function>
   returns a hex-encoded value of type <type>text</type> whereas the SHA-2
   functions return type <type>bytea</type>.  Use the functions
   <function>encode</function> and <function>decode</function> to convert
   between the two, for example <literal>encode(sha256('abc'),
   'hex')</literal> to get a hex-encoded text representation.
-->
歴史的な理由により、<function>md5</function>は16進のエンコード値を返すのに対し、SHA-2関数は<type>bytea</type>を返すことに注意してください。
両者の間の変換を行うには、関数<function>encode</function>と<function>decode</function>を使ってください。たとえば、16進のエンコードのテキスト表現を得るには、<literal>encode(sha256('abc'),'hex')</literal>としてください。
  </para>

  <para>
<!--
   See also the aggregate function <function>string_agg</function> in
   <xref linkend="functions-aggregate"/> and the large object functions
   in <xref linkend="lo-funcs"/>.
-->
<xref linkend="functions-aggregate"/>における<function>string_agg</function>集約関数や<xref linkend="lo-funcs"/>のラージオブジェクト関数も参照してください。
  </para>
 </sect1>


  <sect1 id="functions-bitstring">
<!--
   <title>Bit String Functions and Operators</title>
-->
   <title>ビット文字列関数と演算子</title>

   <indexterm zone="functions-bitstring">
<!--
    <primary>bit strings</primary>
    <secondary>functions</secondary>
-->
    <primary>ビット文字列</primary>
    <secondary>関数</secondary>
   </indexterm>

   <para>
<!--
    This section describes functions and operators for examining and
    manipulating bit strings, that is values of the types
    <type>bit</type> and <type>bit varying</type>.  Aside from the
    usual comparison operators, the operators
    shown in <xref linkend="functions-bit-string-op-table"/> can be used.
    Bit string operands of <literal>&amp;</literal>, <literal>|</literal>,
    and <literal>#</literal> must be of equal length.  When bit
    shifting, the original length of the string is preserved, as shown
    in the examples.
-->
本節では、ビット文字列の検査と操作を行う関数と演算子について説明します。ビット文字列とは、<type>bit</type>型と<type>bit varying</type>型の値のことです。
通常の比較演算子に加え、<xref linkend="functions-bit-string-op-table"/>に示す演算子も使用可能です。
<literal>&amp;</literal>、<literal>|</literal>、<literal>#</literal>のビット文字列オペランドは同一長でなければなりません。
ビットシフト処理の際、例に示す通り元の長さは保持されます。
   </para>

   <table id="functions-bit-string-op-table">
<!--
    <title>Bit String Operators</title>
-->
    <title>ビット文字列演算子</title>

    <tgroup cols="4">
     <thead>
      <row>
<!--
       <entry>Operator</entry>
       <entry>Description</entry>
       <entry>Example</entry>
       <entry>Result</entry>
-->
       <entry>演算子</entry>
       <entry>説明</entry>
       <entry>例</entry>
       <entry>結果</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry> <literal>||</literal> </entry>
<!--
       <entry>concatenation</entry>
-->
       <entry>結合</entry>
       <entry><literal>B'10001' || B'011'</literal></entry>
       <entry><literal>10001011</literal></entry>
      </row>

      <row>
       <entry> <literal>&amp;</literal> </entry>
<!--
       <entry>bitwise AND</entry>
-->
       <entry>ビットのAND</entry>
       <entry><literal>B'10001' &amp; B'01101'</literal></entry>
       <entry><literal>00001</literal></entry>
      </row>

      <row>
       <entry> <literal>|</literal> </entry>
<!--
       <entry>bitwise OR</entry>
-->
       <entry>ビットのOR</entry>
       <entry><literal>B'10001' | B'01101'</literal></entry>
       <entry><literal>11101</literal></entry>
      </row>

      <row>
       <entry> <literal>#</literal> </entry>
<!--
       <entry>bitwise XOR</entry>
-->
       <entry>ビットのXOR</entry>
       <entry><literal>B'10001' # B'01101'</literal></entry>
       <entry><literal>11100</literal></entry>
      </row>

      <row>
       <entry> <literal>~</literal> </entry>
<!--
       <entry>bitwise NOT</entry>
-->
       <entry>ビットのNOT</entry>
       <entry><literal>~ B'10001'</literal></entry>
       <entry><literal>01110</literal></entry>
      </row>

      <row>
       <entry> <literal>&lt;&lt;</literal> </entry>
<!--
       <entry>bitwise shift left</entry>
-->
       <entry>ビットの左シフト</entry>
       <entry><literal>B'10001' &lt;&lt; 3</literal></entry>
       <entry><literal>01000</literal></entry>
      </row>

      <row>
       <entry> <literal>&gt;&gt;</literal> </entry>
<!--
       <entry>bitwise shift right</entry>
-->
       <entry>ビットの右シフト</entry>
       <entry><literal>B'10001' &gt;&gt; 2</literal></entry>
       <entry><literal>00100</literal></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
<!--
    The following <acronym>SQL</acronym>-standard functions work on bit
    strings as well as character strings:
    <literal><function>length</function></literal>,
    <literal><function>bit_length</function></literal>,
    <literal><function>octet_length</function></literal>,
    <literal><function>position</function></literal>,
    <literal><function>substring</function></literal>,
    <literal><function>overlay</function></literal>.
-->
次の標準<acronym>SQL</acronym>関数は文字列同様にビット文字列で動作します。
    <literal><function>length</function></literal>、
    <literal><function>bit_length</function></literal>、
    <literal><function>octet_length</function></literal>、
    <literal><function>position</function></literal>、
    <literal><function>substring</function></literal>、
    <literal><function>overlay</function></literal>。
   </para>

   <para>
<!--
    The following functions work on bit strings as well as binary
    strings:
    <literal><function>get_bit</function></literal>,
    <literal><function>set_bit</function></literal>.
-->
次の関数はバイナリ同様にビット文字列で動作します。
    <literal><function>get_bit</function></literal>、
    <literal><function>set_bit</function></literal>。
<!--
    When working with a bit string, these functions number the first
    (leftmost) bit of the string as bit 0.
-->
ビット文字列に処理を行った場合、これらの関数は文字列の最初(一番左)のビットを0として数えます。
   </para>

   <para>
<!--
    In addition, it is possible to cast integral values to and from type
    <type>bit</type>.
    Some examples:
-->
さらに、<type>bit</type>型から整数値にキャストすることも整数から<type>bit</type>型にキャストすることも可能です。
以下に例を示します。
<programlisting>
44::bit(10)                    <lineannotation>0000101100</lineannotation>
44::bit(3)                     <lineannotation>100</lineannotation>
cast(-44 as bit(12))           <lineannotation>111111010100</lineannotation>
'1110'::bit(4)::integer        <lineannotation>14</lineannotation>
</programlisting>
<!--
    Note that casting to just <quote>bit</quote> means casting to
    <literal>bit(1)</literal>, and so will deliver only the least significant
    bit of the integer.
-->
単に<quote>bit</quote>にキャストすることは<literal>bit(1)</literal>にキャストすることを意味することに注意してください。つまり、単に整数の最下位ビットのみが渡されることになります。
   </para>

    <note>
     <para>
<!--
      Casting an integer to <type>bit(n)</type> copies the rightmost
      <literal>n</literal> bits.  Casting an integer to a bit string width wider
      than the integer itself will sign-extend on the left.
-->
整数を<type>bit(n)</type>にキャストすると、整数の最下位ビットから<literal>n</literal>ビット分複写されます。
整数からビット数が元の整数より多いビット文字列にキャストする際、符号ビットでその左部分を拡張します。
     </para>
    </note>

  </sect1>


 <sect1 id="functions-matching">
<!--
  <title>Pattern Matching</title>
-->
  <title>パターンマッチ</title>

  <indexterm zone="functions-matching">
<!--
   <primary>pattern matching</primary>
-->
   <primary>パターンマッチ</primary>
  </indexterm>

   <para>
<!--
    There are three separate approaches to pattern matching provided
    by <productname>PostgreSQL</productname>: the traditional
    <acronym>SQL</acronym> <function>LIKE</function> operator, the
    more recent <function>SIMILAR TO</function> operator (added in
    SQL:1999), and <acronym>POSIX</acronym>-style regular
    expressions.  Aside from the basic <quote>does this string match
    this pattern?</quote> operators, functions are available to extract
    or replace matching substrings and to split a string at matching
    locations.
-->
<productname>PostgreSQL</productname>には、パターンマッチを行うに際して3つの異なった手法があります。伝統的な<acronym>SQL</acronym>の<function>LIKE</function>演算子、これより新しい<function>SIMILAR TO</function>演算子（SQL:1999で追加されました）、および<acronym>POSIX</acronym>様式の正規表現です。
基本の<quote>この文字列はこのパターンに一致するか？</quote>を別としても、一致した部分文字列を取り出したり置換したり、そして一致部分で文字列を分割する関数が用意されています。
   </para>

   <tip>
    <para>
<!--
     If you have pattern matching needs that go beyond this,
     consider writing a user-defined function in Perl or Tcl.
-->
上記の手法では検索できないようなパターンマッチが必要な場合は、PerlもしくはTclでユーザ定義関数を作成することを検討してください。
    </para>
   </tip>

   <caution>
    <para>
<!--
     While most regular-expression searches can be executed very quickly,
     regular expressions can be contrived that take arbitrary amounts of
     time and memory to process.  Be wary of accepting regular-expression
     search patterns from hostile sources.  If you must do so, it is
     advisable to impose a statement timeout.
-->
ほとんどの正規表現検索はとても速く実行されますが、正規表現は処理するのに任意の時間とメモリを使う可能性があります。
悪意のあるソースから正規表現検索パターンを受け取ることに用心してください。
そうしなければならないのであれば、文のタイムアウトを強制するのが賢明です。
    </para>

    <para>
<!--
     Searches using <function>SIMILAR TO</function> patterns have the same
     security hazards, since <function>SIMILAR TO</function> provides many
     of the same capabilities as <acronym>POSIX</acronym>-style regular
     expressions.
-->
<function>SIMILAR TO</function>が<acronym>POSIX</acronym>書式の正規表現と同じ多くの機能を提供するので、<function>SIMILAR TO</function>パターンを使う検索は同様のセキュリティ問題を抱えています。
    </para>

    <para>
<!--
     <function>LIKE</function> searches, being much simpler than the other
     two options, are safer to use with possibly-hostile pattern sources.
-->
<function>LIKE</function>検索は、他の2つの方法よりずっと単純ですので、悪意があるかもしれないパターンのソースで使うのにはより安全です。
    </para>
   </caution>

   <para>
<!--
    The pattern matching operators of all three kinds do not support
    nondeterministic collations.  If required, apply a different collation to
    the expression to work around this limitation.
-->
この3種類のパターンマッチング演算子はどれも非決定的照合順序をサポートしていません。
必要なら、この制限事項に対応するために別の照合順序を式に適用してください。
   </para>

  <sect2 id="functions-like">
   <title><function>LIKE</function></title>

   <indexterm>
    <primary>LIKE</primary>
   </indexterm>

<synopsis>
<replaceable>string</replaceable> LIKE <replaceable>pattern</replaceable> <optional>ESCAPE <replaceable>escape-character</replaceable></optional>
<replaceable>string</replaceable> NOT LIKE <replaceable>pattern</replaceable> <optional>ESCAPE <replaceable>escape-character</replaceable></optional>
</synopsis>

    <para>
<!--
     The <function>LIKE</function> expression returns true if the
     <replaceable>string</replaceable> matches the supplied
     <replaceable>pattern</replaceable>.  (As
     expected, the <function>NOT LIKE</function> expression returns
     false if <function>LIKE</function> returns true, and vice versa.
     An equivalent expression is
     <literal>NOT (<replaceable>string</replaceable> LIKE
      <replaceable>pattern</replaceable>)</literal>.)
-->
<function>LIKE</function>式は供給された<replaceable>pattern</replaceable>に<replaceable>string</replaceable>が一致すれば真を返します。
（想像される通り、<function>NOT LIKE</function>式は<function>LIKE</function>式が真を返す場合には偽を返し、その逆もまた同じです。
同等の式として<literal>NOT (<replaceable>string</replaceable> LIKE <replaceable>pattern</replaceable>)</literal>とも表現できます。）
    </para>

    <para>
<!--
     If <replaceable>pattern</replaceable> does not contain percent
     signs or underscores, then the pattern only represents the string
     itself; in that case <function>LIKE</function> acts like the
     equals operator.  An underscore (<literal>_</literal>) in
     <replaceable>pattern</replaceable> stands for (matches) any single
     character; a percent sign (<literal>%</literal>) matches any sequence
     of zero or more characters.
-->
<replaceable>pattern</replaceable>がパーセント記号もしくはアンダースコアを含んでいない場合patternは自身の文字列そのものです。この場合<function>LIKE</function>式は等号演算子のように振舞います。
<replaceable>pattern</replaceable>の中にあるアンダースコア（<literal>_</literal>）は任意の一文字との一致を意味し、パーセント記号（<literal>%</literal>）は0文字以上の並びとの一致を意味します。
    </para>

   <para>
<!--
    Some examples:
-->
例：
<programlisting>
'abc' LIKE 'abc'    <lineannotation>true</lineannotation>
'abc' LIKE 'a%'     <lineannotation>true</lineannotation>
'abc' LIKE '_b_'    <lineannotation>true</lineannotation>
'abc' LIKE 'c'      <lineannotation>false</lineannotation>
</programlisting>
   </para>

   <para>
<!--
    <function>LIKE</function> pattern matching always covers the entire
    string.  Therefore, if it's desired to match a sequence anywhere within
    a string, the pattern must start and end with a percent sign.
-->
<function>LIKE</function>によるパターン一致は常に文字列全体に対して行われます。
従って、文字列内の任意位置における並びと一致させたい場合には、パーセント記号を先頭と末尾に付ける必要があります。
   </para>

   <para>
<!--
    To match a literal underscore or percent sign without matching
    other characters, the respective character in
    <replaceable>pattern</replaceable> must be
    preceded by the escape character.  The default escape
    character is the backslash but a different one can be selected by
    using the <literal>ESCAPE</literal> clause.  To match the escape
    character itself, write two escape characters.
-->
他の文字の一致に使用するのではなく、アンダースコアやパーセント記号そのものを一致させたい場合には、<replaceable>pattern</replaceable>の中のそれぞれのアンダースコアとパーセント記号の前にエスケープ文字を付けなければなりません。
デフォルトのエスケープ文字はバックスラッシュですが、<literal>ESCAPE</literal>句で他の文字を指定することができます。エスケープ文字そのものを一致させるにはエスケープ文字を2つ書きます。
   </para>

   <note>
    <para>
<!--
     If you have <xref linkend="guc-standard-conforming-strings"/> turned off,
     any backslashes you write in literal string constants will need to be
     doubled.  See <xref linkend="sql-syntax-strings"/> for more information.
-->
<xref linkend="guc-standard-conforming-strings"/>パラメータをoffにしている場合、リテラル文字列定数に記述するバックスラッシュを二重にする必要があります。
詳細は<xref linkend="sql-syntax-strings"/>を参照してください。
    </para>
   </note>

   <para>
<!--
    It's also possible to select no escape character by writing
    <literal>ESCAPE ''</literal>.  This effectively disables the
    escape mechanism, which makes it impossible to turn off the
    special meaning of underscore and percent signs in the pattern.
-->
同時に<literal>ESCAPE ''</literal>と記述することでエスケープ文字を選択しないことも可能です。
これにより、事実上エスケープ機構が働かなくなります。つまり、パターン内のアンダースコアおよびパーセント記号の特別な意味を解除することはできなくなります。
   </para>

   <para>
<!--
    The key word <token>ILIKE</token> can be used instead of
    <token>LIKE</token> to make the match case-insensitive according
    to the active locale.  This is not in the <acronym>SQL</acronym> standard but is a
    <productname>PostgreSQL</productname> extension.
-->
現在のロケールに従って大文字小文字を区別しない一致を行うのであれば、<token>LIKE</token>の代わりに<token>ILIKE</token>キーワードを使うことができます。
これは標準<acronym>SQL</acronym>ではなく、<productname>PostgreSQL</productname>の拡張です。
   </para>

   <para>
<!--
    The operator <literal>~~</literal> is equivalent to
    <function>LIKE</function>, and <literal>~~*</literal> corresponds to
    <function>ILIKE</function>.  There are also
    <literal>!~~</literal> and <literal>!~~*</literal> operators that
    represent <function>NOT LIKE</function> and <function>NOT
    ILIKE</function>, respectively.  All of these operators are
    <productname>PostgreSQL</productname>-specific.
-->
<literal>~~</literal>演算子は<function>LIKE</function>式と等価で、<literal>~~*</literal>は<function>ILIKE</function>に対応します。
また<function>NOT LIKE</function>および<function>NOT ILIKE</function>を表す<literal>!~~</literal>および<literal>!~~*</literal>演算子があります。
これら全ての演算子は<productname>PostgreSQL</productname>固有のものです。
   </para>

   <para>
<!--
    There is also the prefix operator <literal>^@</literal> and corresponding
    <function>starts_with</function> function which covers cases when only
    searching by beginning of the string is needed.
-->
単に文字列の先頭からの開始が必要なだけのケースであれば、接頭辞演算子<literal>^@</literal>とそれに対応する<function>starts_with</function>関数もあります。
   </para>
  </sect2>


  <sect2 id="functions-similarto-regexp">
<!--
   <title><function>SIMILAR TO</function> Regular Expressions</title>
-->
   <title><function>SIMILAR TO</function>正規表現</title>

   <indexterm>
<!--
    <primary>regular expression</primary>
-->
    <primary>正規表現</primary>
    <!-- 原文コメント <seealso>pattern matching</seealso> breaks index build -->
   </indexterm>

   <indexterm>
    <primary>SIMILAR TO</primary>
   </indexterm>
   <indexterm>
    <primary>substring</primary>
   </indexterm>

<synopsis>
<replaceable>string</replaceable> SIMILAR TO <replaceable>pattern</replaceable> <optional>ESCAPE <replaceable>escape-character</replaceable></optional>
<replaceable>string</replaceable> NOT SIMILAR TO <replaceable>pattern</replaceable> <optional>ESCAPE <replaceable>escape-character</replaceable></optional>
</synopsis>

   <para>
<!--
    The <function>SIMILAR TO</function> operator returns true or
    false depending on whether its pattern matches the given string.
    It is similar to <function>LIKE</function>, except that it
    interprets the pattern using the SQL standard's definition of a
    regular expression.  SQL regular expressions are a curious cross
    between <function>LIKE</function> notation and common regular
    expression notation.
-->
<function>SIMILAR TO</function>演算子は、そのパターンが与えられた文字列に一致するかどうかにより、真もしくは偽を返します。
これは、標準SQLの正規表現定義を使用してパターンを解釈するという点以外は、<function>LIKE</function>に類似しています。
SQLの正規表現は、<function>LIKE</function>表記と一般的な正規表現の表記とを混ぜ合わせたようなものになっています。
   </para>

   <para>
<!--
    Like <function>LIKE</function>, the <function>SIMILAR TO</function>
    operator succeeds only if its pattern matches the entire string;
    this is unlike common regular expression behavior where the pattern
    can match any part of the string.
    Also like
    <function>LIKE</function>, <function>SIMILAR TO</function> uses
    <literal>_</literal> and <literal>%</literal> as wildcard characters denoting
    any single character and any string, respectively (these are
    comparable to <literal>.</literal> and <literal>.*</literal> in POSIX regular
    expressions).
-->
<function>LIKE</function>と同様、<function>SIMILAR TO</function>演算子は、そのパターンが文字列全体に一致した場合のみ真を返します。これは、パターンが文字列の一部分であっても一致する、一般的な正規表現の動作とは異なっています。
また、<function>LIKE</function>と同様、<function>SIMILAR TO</function>では、<literal>%</literal>および<literal>_</literal>を、それぞれ任意の文字列および任意の単一文字を意味するワイルドカード文字として使用します（これらは、POSIX正規表現での<literal>.*</literal>および<literal>.</literal>に相当します）。
   </para>

   <para>
<!--
    In addition to these facilities borrowed from <function>LIKE</function>,
    <function>SIMILAR TO</function> supports these pattern-matching
    metacharacters borrowed from POSIX regular expressions:
-->
<function>LIKE</function>から取り入れた上記の機能に加え、<function>SIMILAR TO</function>では、以下のようにPOSIX正規表現から取り入れたパターンマッチメタ文字もサポートしています。

   <itemizedlist>
    <listitem>
     <para>
<!--
      <literal>|</literal> denotes alternation (either of two alternatives).
-->
<literal>|</literal>は、二者択一（2つの選択肢のうちいずれか）を意味します。
     </para>
    </listitem>
    <listitem>
     <para>
<!--
      <literal>*</literal> denotes repetition of the previous item zero
      or more times.
-->
<literal>*</literal>は、直前の項目の0回以上の繰り返しを意味します。
     </para>
    </listitem>
    <listitem>
     <para>
<!--
      <literal>+</literal> denotes repetition of the previous item one
      or more times.
-->
<literal>+</literal>は、直前の項目の1回以上の繰り返しを意味します。
     </para>
    </listitem>
    <listitem>
     <para>
<!--
      <literal>?</literal> denotes repetition of the previous item zero
      or one time.
-->
<literal>?</literal>は、直前の項目の0回もしくは1回の繰り返しを意味します。
     </para>
    </listitem>
    <listitem>
     <para>
<!--
      <literal>{</literal><replaceable>m</replaceable><literal>}</literal> denotes repetition
      of the previous item exactly <replaceable>m</replaceable> times.
-->
<literal>{</literal><replaceable>m</replaceable><literal>}</literal>は、直前の項目の正確な<replaceable>m</replaceable>回の繰り返しを意味します。
     </para>
    </listitem>
    <listitem>
     <para>
<!--
      <literal>{</literal><replaceable>m</replaceable><literal>,}</literal> denotes repetition
      of the previous item <replaceable>m</replaceable> or more times.
-->
      <literal>{</literal><replaceable>m</replaceable><literal>,}</literal>は、直前の項目の<replaceable>m</replaceable>回以上の繰り返しを意味します。
     </para>
    </listitem>
    <listitem>
     <para>
<!--
      <literal>{</literal><replaceable>m</replaceable><literal>,</literal><replaceable>n</replaceable><literal>}</literal>
      denotes repetition of the previous item at least <replaceable>m</replaceable> and
      not more than <replaceable>n</replaceable> times.
-->
<literal>{</literal><replaceable>m</replaceable><literal>,</literal><replaceable>n</replaceable><literal>}</literal>は、直前の項目の<replaceable>m</replaceable>回以上かつ<replaceable>n</replaceable>回以下の繰り返しを意味します。
     </para>
    </listitem>
    <listitem>
     <para>
<!--
      Parentheses <literal>()</literal> can be used to group items into
      a single logical item.
-->
丸括弧<literal>()</literal>は、項目を1つの論理項目にグループ化することができます。
     </para>
    </listitem>
    <listitem>
     <para>
<!--
      A bracket expression <literal>[...]</literal> specifies a character
      class, just as in POSIX regular expressions.
-->
大括弧式<literal>[...]</literal>は、POSIX正規表現と同様に文字クラスを指定します。
     </para>
    </listitem>
   </itemizedlist>

<!--
    Notice that the period (<literal>.</literal>) is not a metacharacter
    for <function>SIMILAR TO</function>.
-->
<function>SIMILAR TO</function>ではピリオド（<literal>.</literal>）はメタ文字ではないことに注意してください。
   </para>

   <para>
<!--
    As with <function>LIKE</function>, a backslash disables the special meaning
    of any of these metacharacters; or a different escape character can
    be specified with <literal>ESCAPE</literal>.
-->
<function>LIKE</function>と同様、バックスラッシュは全てのメタ文字の特殊な意味を無効にします。
また、異なるエスケープ文字を<literal>ESCAPE</literal>で指定することが可能です。
   </para>

   <para>
<!--
    Some examples:
-->
例：
<programlisting>
'abc' SIMILAR TO 'abc'      <lineannotation>true</lineannotation>
'abc' SIMILAR TO 'a'        <lineannotation>false</lineannotation>
'abc' SIMILAR TO '%(b|d)%'  <lineannotation>true</lineannotation>
'abc' SIMILAR TO '(b|c)%'   <lineannotation>false</lineannotation>
</programlisting>
   </para>

   <para>
<!--
    The <function>substring</function> function with three parameters
    provides extraction of a substring that matches an SQL
    regular expression pattern.  The function can be written according
    to SQL99 syntax:
-->
3つのパラメータを持つ<function>substring</function>関数を使用して、SQL正規表現パターンに一致する部分文字列を取り出すことができます。
SQL99の構文にしたがって、この関数は次のように書くことができます。
<synopsis>
substring(<replaceable>string</replaceable> from <replaceable>pattern</replaceable> for <replaceable>escape-character</replaceable>)
</synopsis>
<!--
    or as a plain three-argument function:
-->
あるいは単なる3引数関数として次のように書くこともできます。
<synopsis>
substring(<replaceable>string</replaceable>, <replaceable>pattern</replaceable>, <replaceable>escape-character</replaceable>)
</synopsis>
<!--
    As with <literal>SIMILAR TO</literal>, the
    specified pattern must match the entire data string, or else the
    function fails and returns null.  To indicate the part of the
    pattern for which the matching data sub-string is of interest,
    the pattern should contain
    two occurrences of the escape character followed by a double quote
    (<literal>"</literal>). <!&#045;- 原文コメント " font-lock sanity &#045;->
    The text matching the portion of the pattern
    between these separators is returned when the match is successful.
-->
<literal>SIMILAR TO</literal>と同様、指定したパターンがデータ文字列全体に一致する必要があります。一致しない場合、関数は失敗し、NULLを返します。
マッチするデータのうちの対象とする部分文字列に対応するパターンの部分を示すために、エスケープ文字の後に二重引用符（<literal>"</literal>）を繋げたものを2つパターンに含める必要があります。<!-- " font-lock sanity -->
マッチが成功すると、これらの印で括られたパターンの一部に一致するテキストが返されます。
   </para>

   <para>
<!--
    The escape-double-quote separators actually
    divide <function>substring</function>'s pattern into three independent
    regular expressions; for example, a vertical bar (<literal>|</literal>)
    in any of the three sections affects only that section.  Also, the first
    and third of these regular expressions are defined to match the smallest
    possible amount of text, not the largest, when there is any ambiguity
    about how much of the data string matches which pattern.  (In POSIX
    parlance, the first and third regular expressions are forced to be
    non-greedy.)
-->
エスケープ文字と二重引用符による区切りは実際には<function>substring</function>のパターン引数を3つの独立した正規表現に分割します。
たとえば3つのセクションのどこかに置いた垂直線（<literal>|</literal>）はそのセクションにしか影響を及ぼしません。
また、どのパターンにデータ文字列がマッチするかについて曖昧さがある場合は、最初と3番目の正規表現は、可能な最大のテキストではなく、最小のテキストにマッチするものとして定義されます。
（POSIX用語では、最初と3番目の正規表現は非貪欲（non-greedy）に強制されます。）
   </para>

   <para>
<!--
    As an extension to the SQL standard, <productname>PostgreSQL</productname>
    allows there to be just one escape-double-quote separator, in which case
    the third regular expression is taken as empty; or no separators, in which
    case the first and third regular expressions are taken as empty.
-->
SQL標準への拡張として、<productname>PostgreSQL</productname>は、二重引用符による区切りが一個だけ存在することを許容し、その場合は3番目の正規表現が空として扱われます。
あるいは、二重引用符による区切りがないことも許容し、その場合は最初と3番目の正規表現は空として扱われます。
   </para>

   <para>
<!--
    Some examples, with <literal>#&quot;</literal> delimiting the return string:
-->
例：<literal>#&quot;</literal>を使用して返される文字列を区切ります。
<programlisting>
substring('foobar' from '%#"o_b#"%' for '#')   <lineannotation>oob</lineannotation>
substring('foobar' from '#"o_b#"%' for '#')    <lineannotation>NULL</lineannotation>
</programlisting>
   </para>
  </sect2>

  <sect2 id="functions-posix-regexp">
<!--
   <title><acronym>POSIX</acronym> Regular Expressions</title>
-->
   <title><acronym>POSIX</acronym>正規表現</title>

   <indexterm zone="functions-posix-regexp">
<!--
    <primary>regular expression</primary>
    <seealso>pattern matching</seealso>
-->
    <primary>正規表現</primary>
    <seealso>パターンマッチ</seealso>
   </indexterm>
   <indexterm>
    <primary>substring</primary>
   </indexterm>
   <indexterm>
    <primary>regexp_replace</primary>
   </indexterm>
   <indexterm>
    <primary>regexp_match</primary>
   </indexterm>
   <indexterm>
    <primary>regexp_matches</primary>
   </indexterm>
   <indexterm>
    <primary>regexp_split_to_table</primary>
   </indexterm>
   <indexterm>
    <primary>regexp_split_to_array</primary>
   </indexterm>

   <para>
<!--
    <xref linkend="functions-posix-table"/> lists the available
    operators for pattern matching using POSIX regular expressions.
-->
<xref linkend="functions-posix-table"/>に、POSIX正規表現を使ったパターンマッチに使用可能な演算子を列挙します。
   </para>

   <table id="functions-posix-table">
<!--
    <title>Regular Expression Match Operators</title>
-->
    <title>正規表現マッチ演算子</title>

    <tgroup cols="3">
     <thead>
      <row>
<!--
       <entry>Operator</entry>
       <entry>Description</entry>
       <entry>Example</entry>
-->
       <entry>演算子</entry>
       <entry>説明</entry>
       <entry>例</entry>
      </row>
     </thead>

      <tbody>
       <row>
        <entry> <literal>~</literal> </entry>
<!--
        <entry>Matches regular expression, case sensitive</entry>
-->
        <entry>正規表現にマッチ、大文字小文字の区別あり</entry>
        <entry><literal>'thomas' ~ '.*thomas.*'</literal></entry>
       </row>

       <row>
        <entry> <literal>~*</literal> </entry>
<!--
        <entry>Matches regular expression, case insensitive</entry>
-->
        <entry>正規表現にマッチ、大文字小文字の区別なし</entry>
        <entry><literal>'thomas' ~* '.*Thomas.*'</literal></entry>
       </row>

       <row>
        <entry> <literal>!~</literal> </entry>
<!--
        <entry>Does not match regular expression, case sensitive</entry>
-->
        <entry>正規表現にマッチしない、大文字小文字の区別あり</entry>
        <entry><literal>'thomas' !~ '.*Thomas.*'</literal></entry>
       </row>

       <row>
        <entry> <literal>!~*</literal> </entry>
<!--
        <entry>Does not match regular expression, case insensitive</entry>
-->
        <entry>正規表現にマッチしない、大文字小文字の区別なし</entry>
        <entry><literal>'thomas' !~* '.*vadim.*'</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

    <para>
<!--
     <acronym>POSIX</acronym> regular expressions provide a more
     powerful means for pattern matching than the <function>LIKE</function> and
     <function>SIMILAR TO</function> operators.
     Many Unix tools such as <command>egrep</command>,
     <command>sed</command>, or <command>awk</command> use a pattern
     matching language that is similar to the one described here.
-->
<acronym>POSIX</acronym>正規表現は、パターンマッチという意味合いでは、<function>LIKE</function>および<function>SIMILAR TO</function>演算子よりもさらに強力です。
<command>egrep</command>、<command>sed</command>、あるいは<command>awk</command>のような多くのUnixツールはここで解説しているのと類似したパターンマッチ言語を使用しています。
    </para>

    <para>
<!--
     A regular expression is a character sequence that is an
     abbreviated definition of a set of strings (a <firstterm>regular
     set</firstterm>).  A string is said to match a regular expression
     if it is a member of the regular set described by the regular
     expression.  As with <function>LIKE</function>, pattern characters
     match string characters exactly unless they are special characters
     in the regular expression language &mdash; but regular expressions use
     different special characters than <function>LIKE</function> does.
     Unlike <function>LIKE</function> patterns, a
     regular expression is allowed to match anywhere within a string, unless
     the regular expression is explicitly anchored to the beginning or
     end of the string.
-->
正規表現とは文字列の集合（<firstterm>正規集合</firstterm>）の簡略された定義である文字が連なっているものです。
ある文字列が正規表現で記述された正規集合の要素になっていれば、その文字列は正規表現にマッチしていると呼ばれます。
<function>LIKE</function>と同様、正規表現言語で特殊文字とされているもの以外、パターン文字は文字列と完全にマッチされます。とは言っても、正規表現は<function>LIKE</function>関数が使用するのとは異なる特殊文字を使用します。
<function>LIKE</function>関数のパターンと違って正規表現は、明示的に正規表現が文字列の最初または最後からと位置指定されていない限り文字列内のどの位置でもマッチを行えます。
    </para>

    <para>
<!--
     Some examples:
-->
例：
<programlisting>
'abc' ~ 'abc'    <lineannotation>true</lineannotation>
'abc' ~ '^a'     <lineannotation>true</lineannotation>
'abc' ~ '(b|d)'  <lineannotation>true</lineannotation>
'abc' ~ '^(b|c)' <lineannotation>false</lineannotation>
</programlisting>
    </para>

    <para>
<!--
     The <acronym>POSIX</acronym> pattern language is described in much
     greater detail below.
-->
<acronym>POSIX</acronym>パターン言語について以下により詳しく説明します。
    </para>

    <para>
<!--
     The <function>substring</function> function with two parameters,
     <function>substring(<replaceable>string</replaceable> from
     <replaceable>pattern</replaceable>)</function>, provides extraction of a
     substring
     that matches a POSIX regular expression pattern.  It returns null if
     there is no match, otherwise the portion of the text that matched the
     pattern.  But if the pattern contains any parentheses, the portion
     of the text that matched the first parenthesized subexpression (the
     one whose left parenthesis comes first) is
     returned.  You can put parentheses around the whole expression
     if you want to use parentheses within it without triggering this
     exception.  If you need parentheses in the pattern before the
     subexpression you want to extract, see the non-capturing parentheses
     described below.
-->
2つのパラメータを持つ<function>substring</function>関数、<function>substring(<parameter>string</parameter> from <replaceable>pattern</replaceable>)</function>を使用して、POSIX正規表現パターンにマッチする部分文字列を取り出すことができます。
この関数は、マッチするものがない場合にはNULLを返し、ある場合はパターンにマッチしたテキストの一部を返します。
しかし、丸括弧を持つパターンの場合、最初の丸括弧内部分正規表現（左丸括弧が最初に来るもの）にマッチするテキストの一部が返されます。
この例外を起こさずにパターン中に丸括弧を使用したいのであれば、常に正規表現全体を丸括弧で囲むことができます。
パターン内の抽出対象の部分文字列より前に丸括弧が必要な場合、後述の捕捉されない丸括弧を参照してください。
    </para>

   <para>
<!--
    Some examples:
-->
例：
<programlisting>
substring('foobar' from 'o.b')     <lineannotation>oob</lineannotation>
substring('foobar' from 'o(.)b')   <lineannotation>o</lineannotation>
</programlisting>
   </para>

    <para>
<!--
     The <function>regexp_replace</function> function provides substitution of
     new text for substrings that match POSIX regular expression patterns.
     It has the syntax
     <function>regexp_replace</function>(<replaceable>source</replaceable>,
     <replaceable>pattern</replaceable>, <replaceable>replacement</replaceable>
     <optional>, <replaceable>flags</replaceable> </optional>).
     The <replaceable>source</replaceable> string is returned unchanged if
     there is no match to the <replaceable>pattern</replaceable>.  If there is a
     match, the <replaceable>source</replaceable> string is returned with the
     <replaceable>replacement</replaceable> string substituted for the matching
     substring.  The <replaceable>replacement</replaceable> string can contain
     <literal>\</literal><replaceable>n</replaceable>, where <replaceable>n</replaceable> is 1
     through 9, to indicate that the source substring matching the
     <replaceable>n</replaceable>'th parenthesized subexpression of the pattern should be
     inserted, and it can contain <literal>\&amp;</literal> to indicate that the
     substring matching the entire pattern should be inserted.  Write
     <literal>\\</literal> if you need to put a literal backslash in the replacement
     text.
     The <replaceable>flags</replaceable> parameter is an optional text
     string containing zero or more single-letter flags that change the
     function's behavior.  Flag <literal>i</literal> specifies case-insensitive
     matching, while flag <literal>g</literal> specifies replacement of each matching
     substring rather than only the first one.  Supported flags (though
     not <literal>g</literal>) are
     described in <xref linkend="posix-embedded-options-table"/>.
-->
<function>regexp_replace</function>関数は、POSIX正規表現パターンにマッチする部分文字列を新規テキストと置換します。
構文は、<function>regexp_replace</function>(<replaceable>source</replaceable>, <replaceable>pattern</replaceable>, <replaceable>replacement</replaceable> <optional>, <replaceable>flags</replaceable> </optional>)です。
<replaceable>pattern</replaceable>にマッチしない場合は、<replaceable>source</replaceable>文字列がそのまま返されます。
マッチすると、マッチ部分文字列を<replaceable>replacement</replaceable>文字列で置換した<replaceable>source</replaceable>文字列が返されます。
<replaceable>replacement</replaceable>文字列に<literal>\</literal><replaceable>n</replaceable>（<replaceable>n</replaceable>は1から9までの数字）を入れて、パターン内の<replaceable>n</replaceable>番目の丸括弧つき部分表現にマッチする元の部分文字列を挿入することができます。
また、<literal>\&amp;</literal>を入れて、パターン全体とマッチする部分文字列を挿入することもできます。
置換テキスト内にバックスラッシュそのものを挿入する必要がある時は<literal>\\</literal>と記述します。
<replaceable>flags</replaceable>パラメータは、関数の動作を変更するゼロもしくはそれ以上の1文字フラグを含むオプションのテキスト文字列です。フラグ<literal>i</literal>は大文字小文字を区別しないマッチを指定する一方、フラグ<literal>g</literal>は、最初にマッチしたもののみではなく、それぞれマッチした部分文字列の置換を指定します。
有効なフラグは(<literal>g</literal>を除く)<xref linkend="posix-embedded-options-table"/>に記述されています。
    </para>

   <para>
<!--
    Some examples:
-->
    例：
<programlisting>
regexp_replace('foobarbaz', 'b..', 'X')
                                   <lineannotation>fooXbaz</lineannotation>
regexp_replace('foobarbaz', 'b..', 'X', 'g')
                                   <lineannotation>fooXX</lineannotation>
regexp_replace('foobarbaz', 'b(..)', 'X\1Y', 'g')
                                   <lineannotation>fooXarYXazY</lineannotation>
</programlisting>
   </para>

    <para>
<!--
     The <function>regexp_match</function> function returns a text array of
     captured substring(s) resulting from the first match of a POSIX
     regular expression pattern to a string.  It has the syntax
     <function>regexp_match</function>(<replaceable>string</replaceable>,
     <replaceable>pattern</replaceable> <optional>, <replaceable>flags</replaceable> </optional>).
     If there is no match, the result is <literal>NULL</literal>.
     If a match is found, and the <replaceable>pattern</replaceable> contains no
     parenthesized subexpressions, then the result is a single-element text
     array containing the substring matching the whole pattern.
     If a match is found, and the <replaceable>pattern</replaceable> contains
     parenthesized subexpressions, then the result is a text array
     whose <replaceable>n</replaceable>'th element is the substring matching
     the <replaceable>n</replaceable>'th parenthesized subexpression of
     the <replaceable>pattern</replaceable> (not counting <quote>non-capturing</quote>
     parentheses; see below for details).
     The <replaceable>flags</replaceable> parameter is an optional text string
     containing zero or more single-letter flags that change the function's
     behavior.  Supported flags are described
     in <xref linkend="posix-embedded-options-table"/>.
-->
<function>regexp_match</function>関数はPOSIX正規表現パターンを文字列にマッチさせた結果、捕捉された最初の部分文字列のテキスト配列を返します。
<function>regexp_match</function>(<replaceable>string</replaceable>, <replaceable>pattern</replaceable> <optional>, <replaceable>flags</replaceable> </optional>)の構文になります。
マッチするものがなければ、結果は<literal>NULL</literal>となります。
マッチする部分があり、かつ<replaceable>pattern</replaceable>が丸括弧で括られた部分文字列を含まない場合、結果はパターン全体にマッチする部分文字列を含む単一要素のテキスト配列となります。
マッチする部分があり、かつ<replaceable>pattern</replaceable>が丸括弧で括られた部分文字列を含む場合、結果はテキスト配列で、その<replaceable>n</replaceable>番目の要素は<replaceable>pattern</replaceable>の<replaceable>n</replaceable>番目に丸括弧で括られた部分文字列にマッチする部分文字列となります（<quote>捕捉されない</quote>丸括弧は数えません。詳細は以下を参照してください）。
<replaceable>flags</replaceable>パラメータは、関数の動作を変更するゼロもしくは複数の単一文字フラグを含むオプションのテキスト文字列です。
有効なフラグは<xref linkend="posix-embedded-options-table"/>に記載されています。
    </para>

   <para>
<!--
    Some examples:
-->
例を示します。
<programlisting>
SELECT regexp_match('foobarbequebaz', 'bar.*que');
 regexp_match
--------------
 {barbeque}
(1 row)

SELECT regexp_match('foobarbequebaz', '(bar)(beque)');
 regexp_match
--------------
 {bar,beque}
(1 row)
</programlisting>
<!--
    In the common case where you just want the whole matching substring
    or <literal>NULL</literal> for no match, write something like
-->
マッチするときはマッチする部分文字列全体、マッチしないときは<literal>NULL</literal>を返したいというよくあるケースは、以下のように書くことができます。
<programlisting>
SELECT (regexp_match('foobarbequebaz', 'bar.*que'))[1];
 regexp_match
--------------
 barbeque
(1 row)
</programlisting>
   </para>

    <para>
<!--
     The <function>regexp_matches</function> function returns a set of text arrays
     of captured substring(s) resulting from matching a POSIX regular
     expression pattern to a string.  It has the same syntax as
     <function>regexp_match</function>.
     This function returns no rows if there is no match, one row if there is
     a match and the <literal>g</literal> flag is not given, or <replaceable>N</replaceable>
     rows if there are <replaceable>N</replaceable> matches and the <literal>g</literal> flag
     is given.  Each returned row is a text array containing the whole
     matched substring or the substrings matching parenthesized
     subexpressions of the <replaceable>pattern</replaceable>, just as described above
     for <function>regexp_match</function>.
     <function>regexp_matches</function> accepts all the flags shown
     in <xref linkend="posix-embedded-options-table"/>, plus
     the <literal>g</literal> flag which commands it to return all matches, not
     just the first one.
-->
<function>regexp_matches</function>関数はPOSIX正規表現パターンを文字列にマッチさせた結果、捕捉された部分文字列のテキスト配列の集合を返します。
構文は<function>regexp_match</function>と同じです。
この関数は、マッチするものがないときは行を返しませんが、マッチするものがあり、<literal>g</literal>フラグが指定されていないときは1行だけ、マッチするものが<replaceable>N</replaceable>個あり、<literal>g</literal>フラグが指定されているときは<replaceable>N</replaceable>行を返します。
返される各行は上で<function>regexp_match</function>について説明したのと全く同じで、マッチする部分文字列全体、または丸括弧で括られた部分文字列にマッチする部分文字列を含むテキスト配列です。
<function>regexp_matches</function>は<xref linkend="posix-embedded-options-table"/>に示すすべてのフラグに加え、最初のマッチだけでなくすべてのマッチを返す<literal>g</literal>を受け付けます。
    </para>

   <para>
<!--
    Some examples:
-->
例を示します。
<programlisting>
SELECT regexp_matches('foo', 'not there');
 regexp_matches
----------------
(0 rows)

SELECT regexp_matches('foobarbequebazilbarfbonk', '(b[^b]+)(b[^b]+)', 'g');
 regexp_matches
----------------
 {bar,beque}
 {bazil,barf}
(2 rows)
</programlisting>
   </para>

   <tip>
    <para>
<!--
     In most cases <function>regexp_matches()</function> should be used with
     the <literal>g</literal> flag, since if you only want the first match, it's
     easier and more efficient to use <function>regexp_match()</function>.
     However, <function>regexp_match()</function> only exists
     in <productname>PostgreSQL</productname> version 10 and up.  When working in older
     versions, a common trick is to place a <function>regexp_matches()</function>
     call in a sub-select, for example:
-->
最初にマッチするものだけが必要なときは<function>regexp_match()</function>を使う方がより簡単で効率的ですから、<function>regexp_matches()</function>はほとんどの場合<literal>g</literal>フラグを指定して使われるでしょう。
しかし、<function>regexp_match()</function>は<productname>PostgreSQL</productname>のバージョン10以上でのみ利用できます。
古いバージョンを使う時によくある手法は、以下の例のように、副SELECTの中に<function>regexp_matches()</function>の呼び出しを入れることです。
<programlisting>
SELECT col1, (SELECT regexp_matches(col2, '(bar)(beque)')) FROM tab;
</programlisting>
<!--
     This produces a text array if there's a match, or <literal>NULL</literal> if
     not, the same as <function>regexp_match()</function> would do.  Without the
     sub-select, this query would produce no output at all for table rows
     without a match, which is typically not the desired behavior.
-->
これは<function>regexp_match()</function>と同じく、マッチするものがあればテキスト配列を生成し、マッチしなければ<literal>NULL</literal>となります。
副SELECTを使わなければ、マッチするものがないテーブル行については問い合わせの出力が生成されず、多くの場合に期待される動作と異なります。
    </para>
   </tip>

    <para>
<!--
     The <function>regexp_split_to_table</function> function splits a string using a POSIX
     regular expression pattern as a delimiter.  It has the syntax
     <function>regexp_split_to_table</function>(<replaceable>string</replaceable>, <replaceable>pattern</replaceable>
     <optional>, <replaceable>flags</replaceable> </optional>).
     If there is no match to the <replaceable>pattern</replaceable>, the function returns the
     <replaceable>string</replaceable>.  If there is at least one match, for each match it returns
     the text from the end of the last match (or the beginning of the string)
     to the beginning of the match.  When there are no more matches, it
     returns the text from the end of the last match to the end of the string.
     The <replaceable>flags</replaceable> parameter is an optional text string containing
     zero or more single-letter flags that change the function's behavior.
     <function>regexp_split_to_table</function> supports the flags described in
     <xref linkend="posix-embedded-options-table"/>.
-->
<function>regexp_split_to_table</function>関数はPOSIX正規表現パターンを区切り文字として使用し、文字列を分割します。<function>regexp_split_to_table</function>(<replaceable>string</replaceable>, <replaceable>pattern</replaceable> <optional>, <replaceable>flags</replaceable> </optional>)の構文になります。
<replaceable>pattern</replaceable>にマッチしない場合、関数は<replaceable>string</replaceable>を返します。
少なくともひとつのマッチがあれば、それぞれのマッチに対して関数は最後のマッチの終わり（あるいは文字列の始め）から最初のマッチまでのテキストを返します。
もはやマッチしなくなると最後のマッチの終わりから文字列の最後までテキストを返します。
<replaceable>flags</replaceable>パラメータは、関数の動作を変更するゼロもしくは複数の単一文字フラグを含むオプションのテキスト文字列です。
<function>regexp_split_to_table</function>は<xref linkend="posix-embedded-options-table"/>で記載されているフラグをサポートします。
    </para>

    <para>
<!--
     The <function>regexp_split_to_array</function> function behaves the same as
     <function>regexp_split_to_table</function>, except that <function>regexp_split_to_array</function>
     returns its result as an array of <type>text</type>.  It has the syntax
     <function>regexp_split_to_array</function>(<replaceable>string</replaceable>, <replaceable>pattern</replaceable>
     <optional>, <replaceable>flags</replaceable> </optional>).
     The parameters are the same as for <function>regexp_split_to_table</function>.
-->
<function>regexp_split_to_array</function>関数は、<function>regexp_split_to_array</function>がその結果を<type>text</type>配列で返すことを除いて、<function>regexp_split_to_table</function>と同じ動作をします。
<function>regexp_split_to_array</function>(<replaceable>string</replaceable>, <replaceable>pattern</replaceable> <optional>, <replaceable>flags</replaceable> </optional>)の構文になります。
パラメータは<function>regexp_split_to_table</function>のものと同じです。
    </para>

   <para>
<!--
    Some examples:
-->
例：
<programlisting>

SELECT foo FROM regexp_split_to_table('the quick brown fox jumps over the lazy dog', '\s+') AS foo;
  foo   
-------
 the    
 quick  
 brown  
 fox    
 jumps 
 over   
 the    
 lazy   
 dog    
(9 rows)

SELECT regexp_split_to_array('the quick brown fox jumps over the lazy dog', '\s+');
              regexp_split_to_array             
-----------------------------------------------
 {the,quick,brown,fox,jumps,over,the,lazy,dog}
(1 row)

SELECT foo FROM regexp_split_to_table('the quick brown fox', '\s*') AS foo;
 foo 
-----
 t         
 h         
 e         
 q         
 u         
 i         
 c         
 k         
 b         
 r         
 o         
 w         
 n         
 f         
 o         
 x         
(16 rows)
</programlisting>
   </para>

   <para>
<!--
    As the last example demonstrates, the regexp split functions ignore
    zero-length matches that occur at the start or end of the string
    or immediately after a previous match.  This is contrary to the strict
    definition of regexp matching that is implemented by
    <function>regexp_match</function> and
    <function>regexp_matches</function>, but is usually the most convenient behavior
    in practice.  Other software systems such as Perl use similar definitions.
-->
最後の例が明らかにしているように、regexp分割関数は文字列の最初あるいは終わり、もしくは前のマッチの直後に発生する長さを持たないマッチを無視します。
<function>regexp_match</function>および<function>regexp_matches</function>で実装されたregexpマッチの厳格な定義にこれは相容れませんが、実務上は最も使い勝手の良い動作です。
Perlのような他のソフトウェアシステムも似たような定義を使用します。
   </para>

<!-- derived from the re_syntax.n man page -->

   <sect3 id="posix-syntax-details">
<!--
    <title>Regular Expression Details</title>
-->
    <title>正規表現の詳細</title>

   <para>
<!--
    <productname>PostgreSQL</productname>'s regular expressions are implemented
    using a software package written by Henry Spencer.  Much of
    the description of regular expressions below is copied verbatim from his
    manual.
-->
<productname>PostgreSQL</productname>の正規表現はHenry Spencerにより書かれたソフトウェアパッケージを使用して実装されています。
以下に説明する正規表現の多くの部分は同氏のマニュアルから一字一句複製したものです。
   </para>

   <para>
<!--
    Regular expressions (<acronym>RE</acronym>s), as defined in
    <acronym>POSIX</acronym> 1003.2, come in two forms:
    <firstterm>extended</firstterm> <acronym>RE</acronym>s or <acronym>ERE</acronym>s
    (roughly those of <command>egrep</command>), and
    <firstterm>basic</firstterm> <acronym>RE</acronym>s or <acronym>BRE</acronym>s
    (roughly those of <command>ed</command>).
    <productname>PostgreSQL</productname> supports both forms, and
    also implements some extensions
    that are not in the POSIX standard, but have become widely used
    due to their availability in programming languages such as Perl and Tcl.
    <acronym>RE</acronym>s using these non-POSIX extensions are called
    <firstterm>advanced</firstterm> <acronym>RE</acronym>s or <acronym>ARE</acronym>s
    in this documentation.  AREs are almost an exact superset of EREs,
    but BREs have several notational incompatibilities (as well as being
    much more limited).
    We first describe the ARE and ERE forms, noting features that apply
    only to AREs, and then describe how BREs differ.
-->
<acronym>POSIX</acronym> 1003.2の定義によると、正規表現（<acronym>RE</acronym>）には2つの形式があるとされます。<firstterm>拡張</firstterm><acronym>RE</acronym>もしくは<acronym>ERE</acronym>（大まかにいって<command>egrep</command>に代表されるもの）、および<firstterm>基本</firstterm><acronym>RE</acronym>もしくは<acronym>BRE</acronym>（大まかにいって<command>ed</command>に代表されるもの）です。
<productname>PostgreSQL</productname>は両方の形式をサポートし、さらに、POSIX標準にはないけれどもPerlやTclなどのプログラミング言語で利用できることから広く使用されるようになった、いくつかの拡張もサポートしています。
本書では、非POSIX拡張を使用した<acronym>RE</acronym>を<firstterm>高度な</firstterm><acronym>RE</acronym>もしくは<acronym>ARE</acronym>と呼びます。AREはEREの正確な上位セットですが、BREとは複数の記法上の非互換な点があります（さらに非常に多くの制限が課されています）。
まず、AREとERE形式について説明し、そして、AREにのみ適用される機能の注意を、さらにBREとの違いについて説明します。
   </para>

   <note>
    <para>
<!--
     <productname>PostgreSQL</productname> always initially presumes that a regular
     expression follows the ARE rules.  However, the more limited ERE or
     BRE rules can be chosen by prepending an <firstterm>embedded option</firstterm>
     to the RE pattern, as described in <xref linkend="posix-metasyntax"/>.
     This can be useful for compatibility with applications that expect
     exactly the <acronym>POSIX</acronym> 1003.2 rules.
-->
<productname>PostgreSQL</productname>は常に、まず正規表現はARE規則に従うと推測します。
しかし、REパターンの前に、<xref linkend="posix-metasyntax"/>に記載されているような<firstterm>埋め込みオプション</firstterm>を追加することにより、より限られたERE、あるいはBRE規則を選択することができます。
これは、<acronym>POSIX</acronym>1003.2の規則を正確に期待しているアプリケーションとの互換性に関して有用です。
    </para>
   </note>

   <para>
<!--
    A regular expression is defined as one or more
    <firstterm>branches</firstterm>, separated by
    <literal>|</literal>.  It matches anything that matches one of the
    branches.
-->
正規表現は<literal>|</literal>で区切られた、1つまたは複数の<firstterm>ブランチ</firstterm>として定義されます。
ブランチのいずれか1つにマッチすればマッチしたことになります。
   </para>

   <para>
<!--
    A branch is zero or more <firstterm>quantified atoms</firstterm> or
    <firstterm>constraints</firstterm>, concatenated.
    It matches a match for the first, followed by a match for the second, etc;
    an empty branch matches the empty string.
-->
ブランチはゼロ個以上の<firstterm>量化アトム</firstterm>もしくは<firstterm>制約</firstterm>の連結です。
最初のものにマッチに、次に第２番目のものにマッチを、というふうにマッチします。なお、空のブランチは空文字列にマッチします。
   </para>

   <para>
<!--
    A quantified atom is an <firstterm>atom</firstterm> possibly followed
    by a single <firstterm>quantifier</firstterm>.
    Without a quantifier, it matches a match for the atom.
    With a quantifier, it can match some number of matches of the atom.
    An <firstterm>atom</firstterm> can be any of the possibilities
    shown in <xref linkend="posix-atoms-table"/>.
    The possible quantifiers and their meanings are shown in
    <xref linkend="posix-quantifiers-table"/>.
-->
量化アトムとは、単一の<firstterm>量指定子</firstterm>が後ろに付く<firstterm>アトム</firstterm>のことです。
量指定子がないと、アトムにマッチするものがマッチしたことになります。
量指定子がある場合、アトムとのマッチが何回あるかでマッチしたことになります。
<firstterm>アトム</firstterm>は、<xref linkend="posix-atoms-table"/>に示したもののいずれかを取ることができます。
  <xref linkend="posix-quantifiers-table"/>に設定可能な量指定子とその意味を示します。
   </para>

   <para>
<!--
    A <firstterm>constraint</firstterm> matches an empty string, but matches only when
    specific conditions are met.  A constraint can be used where an atom
    could be used, except it cannot be followed by a quantifier.
    The simple constraints are shown in
    <xref linkend="posix-constraints-table"/>;
    some more constraints are described later.
-->
<firstterm>制約</firstterm>は空文字に、特定の条件に合う場合のみにマッチします。
アトムを使用できるところには制約を使用することができます。ただしその後に量指定子を付けることはできません。
単純な制約を<xref linkend="posix-constraints-table"/>に示します。後で他のいくつかの制約を説明します。
   </para>


   <table id="posix-atoms-table">
<!--
    <title>Regular Expression Atoms</title>
-->
    <title>正規表現のアトム</title>

    <tgroup cols="2">
     <thead>
      <row>
<!--
       <entry>Atom</entry>
       <entry>Description</entry>
-->
       <entry>アトム</entry>
       <entry>説明</entry>
      </row>
     </thead>

      <tbody>
       <row>
       <entry> <literal>(</literal><replaceable>re</replaceable><literal>)</literal> </entry>
<!--
       <entry> (where <replaceable>re</replaceable> is any regular expression)
       matches a match for
       <replaceable>re</replaceable>, with the match noted for possible reporting </entry>
-->
       <entry>（ここで<replaceable>re</replaceable> は任意の正規表現で、）<replaceable>re</replaceable>とのマッチに適合するもです。 マッチは可能である報告用と意味づけられます。</entry>
       </row>

       <row>
       <entry> <literal>(?:</literal><replaceable>re</replaceable><literal>)</literal> </entry>
<!--
       <entry> as above, but the match is not noted for reporting
       (a <quote>non-capturing</quote> set of parentheses)
       (AREs only) </entry>
-->
       <entry>上と同じ。ただし、マッチは報告用と意味づけられません。（<quote>捕捉されない</quote>括弧の集合）（AREのみ）</entry>
       </row>

       <row>
       <entry> <literal>.</literal> </entry>
<!--
       <entry> matches any single character </entry>
-->
       <entry>任意の1文字にマッチします。</entry>
       </row>

       <row>
       <entry> <literal>[</literal><replaceable>chars</replaceable><literal>]</literal> </entry>
<!--
       <entry> a <firstterm>bracket expression</firstterm>,
       matching any one of the <replaceable>chars</replaceable> (see
       <xref linkend="posix-bracket-expressions"/> for more detail) </entry>
-->
       <entry>
        <firstterm>ブラケット式</firstterm>。
        <replaceable>chars</replaceable>のいずれか1つにマッチします
       （詳細は<xref linkend="posix-bracket-expressions"/>を参照してください）。
       </entry>
       </row>

       <row>
       <entry> <literal>\</literal><replaceable>k</replaceable> </entry>
<!--
       <entry> (where <replaceable>k</replaceable> is a non-alphanumeric character)
       matches that character taken as an ordinary character,
       e.g., <literal>\\</literal> matches a backslash character </entry>
-->
       <entry>（ここで<replaceable>k</replaceable>は英数字以外です。）普通の文字として指定した文字にマッチします。例えば、<literal>\\</literal>はバックスラッシュ文字です。</entry>
       </row>

       <row>
       <entry> <literal>\</literal><replaceable>c</replaceable> </entry>
<!--
       <entry> where <replaceable>c</replaceable> is alphanumeric
       (possibly followed by other characters)
       is an <firstterm>escape</firstterm>, see <xref linkend="posix-escape-sequences"/>
       (AREs only; in EREs and BREs, this matches <replaceable>c</replaceable>) </entry>
-->
       <entry>ここで<replaceable>c</replaceable>は英数字です
       （おそらく他の文字が後に続きます）。
       <firstterm>エスケープ</firstterm>です。
       <xref linkend="posix-escape-sequences"/>を参照してください
       （AREのみ、EREとBREではこれは<replaceable>c</replaceable>にマッチします）。
       </entry>
       </row>

       <row>
       <entry> <literal>{</literal> </entry>
<!--
       <entry> when followed by a character other than a digit,
       matches the left-brace character <literal>{</literal>;
       when followed by a digit, it is the beginning of a
       <replaceable>bound</replaceable> (see below) </entry>
-->
       <entry>直後に数字以外がある場合、左中括弧<literal>{</literal>にマッチします。
直後に数字が続く場合、<replaceable>bound</replaceable>（後述）の始まりです。</entry>
       </row>

       <row>
       <entry> <replaceable>x</replaceable> </entry>
<!--
       <entry> where <replaceable>x</replaceable> is a single character with no other
       significance, matches that character </entry>
-->
       <entry>ここで<replaceable>x</replaceable>は他に意味を持たない1文字です。
<replaceable>x</replaceable>にマッチします。</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
<!--
    An RE cannot end with a backslash (<literal>\</literal>).
-->
REはバックスラッシュ<literal>\</literal>を終端とすることはできません。
   </para>

   <note>
    <para>
<!--
     If you have <xref linkend="guc-standard-conforming-strings"/> turned off,
     any backslashes you write in literal string constants will need to be
     doubled.  See <xref linkend="sql-syntax-strings"/> for more information.
-->
もし<xref linkend="guc-standard-conforming-strings"/>パラメータをoffにしていた場合、リテラル文字列定数に記述するバックスラッシュは2倍必要となります。
  詳細は<xref linkend="sql-syntax-strings"/>を参照してください。
    </para>
   </note>

   <table id="posix-quantifiers-table">
<!--
    <title>Regular Expression Quantifiers</title>
-->
    <title>正規表現量指定子</title>

    <tgroup cols="2">
     <thead>
      <row>
<!--
       <entry>Quantifier</entry>
       <entry>Matches</entry>
-->
       <entry>量指定子</entry>
       <entry>マッチ</entry>
      </row>
     </thead>

      <tbody>
       <row>
       <entry> <literal>*</literal> </entry>
<!--
       <entry> a sequence of 0 or more matches of the atom </entry>
-->
       <entry>アトムの0個以上複数の並びにマッチ</entry>
       </row>

       <row>
       <entry> <literal>+</literal> </entry>
<!--
       <entry> a sequence of 1 or more matches of the atom </entry>
-->
       <entry>アトムの1個以上複数の並びにマッチ</entry>
       </row>

       <row>
       <entry> <literal>?</literal> </entry>
<!--
       <entry> a sequence of 0 or 1 matches of the atom </entry>
-->
       <entry>アトムの0個または1個の並びにマッチ</entry>
       </row>

       <row>
       <entry> <literal>{</literal><replaceable>m</replaceable><literal>}</literal> </entry>
<!--
       <entry> a sequence of exactly <replaceable>m</replaceable> matches of the atom </entry>
-->
       <entry>アトムの正確に<replaceable>m</replaceable>個の並びにマッチ</entry>
       </row>

       <row>
       <entry> <literal>{</literal><replaceable>m</replaceable><literal>,}</literal> </entry>
<!--
       <entry> a sequence of <replaceable>m</replaceable> or more matches of the atom </entry>
-->
       <entry>アトムの<replaceable>m</replaceable>個以上の並びにマッチ</entry>
       </row>

       <row>
       <entry>
       <literal>{</literal><replaceable>m</replaceable><literal>,</literal><replaceable>n</replaceable><literal>}</literal> </entry>
<!--
       <entry> a sequence of <replaceable>m</replaceable> through <replaceable>n</replaceable>
       (inclusive) matches of the atom; <replaceable>m</replaceable> cannot exceed
       <replaceable>n</replaceable> </entry>
-->
       <entry> アトムの<replaceable>m</replaceable>個以上<replaceable>n</replaceable>以下の並びにマッチ。
<replaceable>m</replaceable>は<replaceable>n</replaceable>を超えることはできません。</entry>
       </row>

       <row>
       <entry> <literal>*?</literal> </entry>
<!--
       <entry> non-greedy version of <literal>*</literal> </entry>
-->
       <entry><literal>*</literal>の最短マッチを行うバージョン</entry>
       </row>

       <row>
       <entry> <literal>+?</literal> </entry>
<!--
       <entry> non-greedy version of <literal>+</literal> </entry>
-->
       <entry><literal>+</literal>の最短マッチを行うバージョン</entry>
       </row>

       <row>
       <entry> <literal>??</literal> </entry>
<!--
       <entry> non-greedy version of <literal>?</literal> </entry>
-->
       <entry><literal>?</literal>の最短マッチを行うバージョン</entry>
       </row>

       <row>
       <entry> <literal>{</literal><replaceable>m</replaceable><literal>}?</literal> </entry>
<!--
       <entry> non-greedy version of <literal>{</literal><replaceable>m</replaceable><literal>}</literal> </entry>
-->
       <entry><literal>{</literal><replaceable>m</replaceable><literal>}</literal>の最短マッチを行うバージョン</entry>
       </row>

       <row>
       <entry> <literal>{</literal><replaceable>m</replaceable><literal>,}?</literal> </entry>
<!--
       <entry> non-greedy version of <literal>{</literal><replaceable>m</replaceable><literal>,}</literal> </entry>
-->
       <entry><literal>{</literal><replaceable>m</replaceable><literal>,}</literal>の最短マッチを行うバージョン</entry>
       </row>

       <row>
       <entry>
       <literal>{</literal><replaceable>m</replaceable><literal>,</literal><replaceable>n</replaceable><literal>}?</literal> </entry>
<!--
       <entry> non-greedy version of <literal>{</literal><replaceable>m</replaceable><literal>,</literal><replaceable>n</replaceable><literal>}</literal> </entry>
-->
       <entry><literal>{</literal><replaceable>m</replaceable><literal>,</literal><replaceable>n</replaceable><literal>}</literal>の最短マッチを行うバージョン</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
<!--
    The forms using <literal>{</literal><replaceable>...</replaceable><literal>}</literal>
    are known as <firstterm>bounds</firstterm>.
    The numbers <replaceable>m</replaceable> and <replaceable>n</replaceable> within a bound are
    unsigned decimal integers with permissible values from 0 to 255 inclusive.
-->
<literal>{</literal><replaceable>...</replaceable><literal>}</literal>を使用する形式は<firstterm>バウンド</firstterm>として知られています。
バウンド内の<replaceable>m</replaceable>と<replaceable>n</replaceable>という数は符号なし10進整数であり、0以上255以下の値を取ることができます。
   </para>

    <para>
<!--
     <firstterm>Non-greedy</firstterm> quantifiers (available in AREs only) match the
     same possibilities as their corresponding normal (<firstterm>greedy</firstterm>)
     counterparts, but prefer the smallest number rather than the largest
     number of matches.
     See <xref linkend="posix-matching-rules"/> for more detail.
-->
<firstterm>最短マッチを行う</firstterm>量指定子（AREのみで使用可能）は、対応する通常の（<firstterm>欲張りの</firstterm>）ものと同じものにマッチしますが、最大のマッチではなく最小のマッチを取ります。
詳細は<xref linkend="posix-matching-rules"/>を参照してください。
   </para>

   <note>
    <para>
<!--
     A quantifier cannot immediately follow another quantifier, e.g.,
     <literal>**</literal> is invalid.
     A quantifier cannot
     begin an expression or subexpression or follow
     <literal>^</literal> or <literal>|</literal>.
-->
量指定子の直後に量指定子を続けることはできません。例えば<literal>**</literal>は無効です。
量指定子から式や副式を始めることはできず、また、<literal>^</literal>や<literal>|</literal>の直後に付けることもできません。
    </para>
   </note>

   <table id="posix-constraints-table">
<!--
    <title>Regular Expression Constraints</title>
-->
    <title>正規表現制約</title>

    <tgroup cols="2">
     <thead>
      <row>
<!--
       <entry>Constraint</entry>
       <entry>Description</entry>
-->
       <entry>制約</entry>
       <entry>説明</entry>
      </row>
     </thead>

      <tbody>
       <row>
       <entry> <literal>^</literal> </entry>
<!--
       <entry> matches at the beginning of the string </entry>
-->
       <entry>文字列の先頭にマッチ</entry>
       </row>

       <row>
       <entry> <literal>$</literal> </entry>
<!--
       <entry> matches at the end of the string </entry>
-->
       <entry>文字列の末尾にマッチ</entry>
       </row>

       <row>
       <entry> <literal>(?=</literal><replaceable>re</replaceable><literal>)</literal> </entry>
<!--
       <entry> <firstterm>positive lookahead</firstterm> matches at any point
       where a substring matching <replaceable>re</replaceable> begins
       (AREs only) </entry>
-->
       <entry><firstterm>先行肯定検索</firstterm>は、<replaceable>re</replaceable>にマッチする部分文字列が始まる任意の場所にマッチします（AREのみ）。</entry>
       </row>

       <row>
       <entry> <literal>(?!</literal><replaceable>re</replaceable><literal>)</literal> </entry>
<!--
       <entry> <firstterm>negative lookahead</firstterm> matches at any point
       where no substring matching <replaceable>re</replaceable> begins
       (AREs only) </entry>
-->
       <entry><firstterm>先行否定検索</firstterm>は、<replaceable>re</replaceable>にマッチしない部分文字列が始まる任意の場所にマッチします（AREのみ）。</entry>
       </row>

       <row>
       <entry> <literal>(?&lt;=</literal><replaceable>re</replaceable><literal>)</literal> </entry>
<!--
       <entry> <firstterm>positive lookbehind</firstterm> matches at any point
       where a substring matching <replaceable>re</replaceable> ends
       (AREs only) </entry>
-->
       <entry> <firstterm>後方肯定検索</firstterm>は<replaceable>re</replaceable>にマッチする部分文字列が終わる任意の場所にマッチします（AREのみ）。</entry>
       </row>

       <row>
       <entry> <literal>(?&lt;!</literal><replaceable>re</replaceable><literal>)</literal> </entry>
<!--
       <entry> <firstterm>negative lookbehind</firstterm> matches at any point
       where no substring matching <replaceable>re</replaceable> ends
       (AREs only) </entry>
-->
       <entry> <firstterm>後方否定検索</firstterm><replaceable>re</replaceable>にマッチしない部分文字列が終わる任意の場所にマッチします（AREのみ）。</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
<!--
    Lookahead and lookbehind constraints cannot contain <firstterm>back
    references</firstterm> (see <xref linkend="posix-escape-sequences"/>),
    and all parentheses within them are considered non-capturing.
-->
先行検索制約および後方検索制約には<firstterm>後方参照</firstterm>（<xref linkend="posix-escape-sequences"/>を参照）を含めることはできません。また、その中の括弧は全て取り込むものではないとみなされます。
   </para>
   </sect3>

   <sect3 id="posix-bracket-expressions">
<!--
    <title>Bracket Expressions</title>
-->
    <title>ブラケット式</title>

   <para>
<!--
    A <firstterm>bracket expression</firstterm> is a list of
    characters enclosed in <literal>[]</literal>.  It normally matches
    any single character from the list (but see below).  If the list
    begins with <literal>^</literal>, it matches any single character
    <emphasis>not</emphasis> from the rest of the list.
    If two characters
    in the list are separated by <literal>-</literal>, this is
    shorthand for the full range of characters between those two
    (inclusive) in the collating sequence,
    e.g., <literal>[0-9]</literal> in <acronym>ASCII</acronym> matches
    any decimal digit.  It is illegal for two ranges to share an
    endpoint, e.g.,  <literal>a-c-e</literal>.  Ranges are very
    collating-sequence-dependent, so portable programs should avoid
    relying on them.
-->
<firstterm>ブラケット式</firstterm>とは、<literal>[]</literal>内の文字のリストです。
通常これはそのリスト内の任意の1文字にマッチします（しかし、以降を参照してください）。
リストが<literal>^</literal>から始まる場合、そのリストの残りには<emphasis>ない</emphasis>任意の1文字にマッチします。
リスト内の2文字が<literal>-</literal>で区切られていた場合、これは2つ（を含む）の間にある文字範囲全体を表す省略形となります。例えば、<acronym>ASCII</acronym>における<literal>[0-9]</literal>は全ての数字にマッチします。
例えば<literal>a-c-e</literal>といった、終端を共有する2つの範囲は不正です。
範囲は並びの照合順に非常に依存しています。ですので、移植予定のプログラムではこれに依存してはなりません。
   </para>

   <para>
<!--
    To include a literal <literal>]</literal> in the list, make it the
    first character (after <literal>^</literal>, if that is used).  To
    include a literal <literal>-</literal>, make it the first or last
    character, or the second endpoint of a range.  To use a literal
    <literal>-</literal> as the first endpoint of a range, enclose it
    in <literal>[.</literal> and <literal>.]</literal> to make it a
    collating element (see below).  With the exception of these characters,
    some combinations using <literal>[</literal>
    (see next paragraphs), and escapes (AREs only), all other special
    characters lose their special significance within a bracket expression.
    In particular, <literal>\</literal> is not special when following
    ERE or BRE rules, though it is special (as introducing an escape)
    in AREs.
-->
このリストに<literal>]</literal>そのものを含めるには、それを先頭文字（もしそれが使用されれば<literal>^</literal>の後）にしてください。
<literal>-</literal>そのものを含めるには、それを先頭もしくは末尾の文字とするか、範囲の2番目の終端としてください。
<literal>-</literal>を範囲の最初の終端で使用するには、<literal>[.</literal>と<literal>.]</literal>でそれを囲み、照合要素（後述）にしてください。
これら文字と、<literal>[</literal>（次段落を参照）のなんらかの組み合わせ、およびエスケープ（AREのみ）を例外として、他の全ての特殊文字はブラケット式内では特殊な意味を持ちません。
特に、<literal>\</literal>はEREとBRE規則に従う場合は特別でなくなります。しかし、AREでは（エスケープの始まりとして）特別な意味を持ちます。
   </para>

   <para>
<!--
    Within a bracket expression, a collating element (a character, a
    multiple-character sequence that collates as if it were a single
    character, or a collating-sequence name for either) enclosed in
    <literal>[.</literal> and <literal>.]</literal> stands for the
    sequence of characters of that collating element.  The sequence is
    treated as a single element of the bracket expression's list.  This
    allows a bracket
    expression containing a multiple-character collating element to
    match more than one character, e.g., if the collating sequence
    includes a <literal>ch</literal> collating element, then the RE
    <literal>[[.ch.]]*c</literal> matches the first five characters of
    <literal>chchcc</literal>.
-->
ブラケット式内に、照合要素（文字、単一文字であるかのように照合する複数文字の並び、もしくはそれぞれの照合並びの名前）が<literal>[.</literal>と<literal>.]</literal>の間にあると、その照合要素の文字の並びを意味します。
この並びはブラケット式のリストの一要素として取り扱われます。
このことにより、ブラケット式は要素を照合する複数文字を含むブラケット式を1文字以上にマッチさせることができます。例えば、照合並びが<literal>ch</literal>照合要素を含む場合、正規表現<literal>[[.ch.]]*c</literal>は<literal>chchcc</literal>という文字の最初の5文字にマッチします。
   </para>

   <note>
    <para>
<!--
     <productname>PostgreSQL</productname> currently does not support multi-character collating
     elements. This information describes possible future behavior.
-->
今のところ、<productname>PostgreSQL</productname>は複数文字照合要素をサポートしません。
この情報は将来の振舞いの可能性を説明したものです。
    </para>
   </note>

   <para>
<!--
    Within a bracket expression, a collating element enclosed in
    <literal>[=</literal> and <literal>=]</literal> is an <firstterm>equivalence
    class</firstterm>, standing for the sequences of characters of all collating
    elements equivalent to that one, including itself.  (If there are
    no other equivalent collating elements, the treatment is as if the
    enclosing delimiters were <literal>[.</literal> and
    <literal>.]</literal>.)  For example, if <literal>o</literal> and
    <literal>^</literal> are the members of an equivalence class, then
    <literal>[[=o=]]</literal>, <literal>[[=^=]]</literal>, and
    <literal>[o^]</literal> are all synonymous.  An equivalence class
    cannot be an endpoint of a range.
-->
ブラケット式内の<literal>[=</literal>と<literal>=]</literal>の間に照合要素は<firstterm>同値クラス</firstterm>です。全ての照合要素の文字の並びが自身を含むものと等価であることを示します。
（他に等価な照合要素がある場合、<literal>[.</literal>と<literal>.]</literal>で囲まれたかのように扱われます。）
例えば、<literal>[[=o=]]</literal>、<literal>[[=^=]]</literal>および<literal>[o^]</literal>が全て同意語であれば、<literal>o</literal>と<literal>^</literal>は同値クラスのメンバです。
同値クラスは範囲の終端にはなりません。
   </para>

   <para>
<!--
    Within a bracket expression, the name of a character class
    enclosed in <literal>[:</literal> and <literal>:]</literal> stands
    for the list of all characters belonging to that class.  A character
    class cannot be used as an endpoint of a range.
    The <acronym>POSIX</acronym> standard defines these character class
    names:
    <literal>alnum</literal> (letters and numeric digits),
    <literal>alpha</literal> (letters),
    <literal>blank</literal> (space and tab),
    <literal>cntrl</literal> (control characters),
    <literal>digit</literal> (numeric digits),
    <literal>graph</literal> (printable characters except space),
    <literal>lower</literal> (lower-case letters),
    <literal>print</literal> (printable characters including space),
    <literal>punct</literal> (punctuation),
    <literal>space</literal> (any white space),
    <literal>upper</literal> (upper-case letters),
    and <literal>xdigit</literal> (hexadecimal digits).
    The behavior of these standard character classes is generally
    consistent across platforms for characters in the 7-bit ASCII set.
    Whether a given non-ASCII character is considered to belong to one
    of these classes depends on the <firstterm>collation</firstterm>
    that is used for the regular-expression function or operator
    (see <xref linkend="collation"/>), or by default on the
    database's <envar>LC_CTYPE</envar> locale setting (see
    <xref linkend="locale"/>).  The classification of non-ASCII
    characters can vary across platforms even in similarly-named
    locales.  (But the <literal>C</literal> locale never considers any
    non-ASCII characters to belong to any of these classes.)
    In addition to these standard character
    classes, <productname>PostgreSQL</productname> defines
    the <literal>ascii</literal> character class, which contains exactly
    the 7-bit ASCII set.
-->
ブラケット式内では、<literal>[:</literal>と<literal>:]</literal>の間にある文字クラスの名称は、そのクラスに属する全ての文字のリストを意味します。
文字クラスは範囲の終端位置としては使用できません。
<acronym>POSIX</acronym>標準は以下の文字クラス名を定義しています。
<literal>alnum</literal>（文字と数字）、<literal>alpha</literal>（文字）、<literal>blank</literal>（空白とタブ）、<literal>cntrl</literal>（制御文字）、<literal>digit</literal>（数字）、<literal>graph</literal>（空白以外の印字可能文字）、<literal>lower</literal>（小文字）、<literal>print</literal>（空白を含む印字可能文字）、<literal>punct</literal>（句読点）、<literal>space</literal>（空白）、<literal>upper</literal>（大文字）、<literal>xdigit</literal>（16進数）です。
これらの標準文字クラスの振る舞いは7-bit ASCII集合の範囲であれば一般にどのプラットフォームでも同じです。
与えられた非ASCII文字がこれらの文字クラスに属すると考えられるかどうかは、正規表現関数または演算子（<xref linkend="collation"/>参照）で使用される<firstterm>照合順</firstterm>、あるいはデフォルトとしてはデータベースの<envar>LC_CTYPE</envar>ロケール（<xref linkend="locale"/>)の設定によります。
非ASCII文字の分類は、たとえ似たような名前のロケールであってもプラットフォームによって異なることがありえます。
（ただし<literal>C</literal>ロケールでは、すべての非ASCII文字はこれらのクラスのどれにも所属しないものとされます。）
これらの標準クラスに加え、<productname>PostgreSQL</productname>では7-bit ASCII集合を正確に含む<literal>ascii</literal>文字クラスが定義されています。
   </para>

   <para>
<!--
    There are two special cases of bracket expressions:  the bracket
    expressions <literal>[[:&lt;:]]</literal> and
    <literal>[[:&gt;:]]</literal> are constraints,
    matching empty strings at the beginning
    and end of a word respectively.  A word is defined as a sequence
    of word characters that is neither preceded nor followed by word
    characters.  A word character is an <literal>alnum</literal> character (as
    defined by the <acronym>POSIX</acronym> character class described above)
    or an underscore.  This is an extension, compatible with but not
    specified by <acronym>POSIX</acronym> 1003.2, and should be used with
    caution in software intended to be portable to other systems.
    The constraint escapes described below are usually preferable; they
    are no more standard, but are easier to type.
-->
ブラケット式には2つの特殊な場合があります。<literal>[[:&lt;:]]</literal>と<literal>[[:&gt;:]]</literal>というブラケット式は、先頭と終端の単語がそれぞれ空文字であることにマッチする制約です。
単語は、単語文字が前後に付かない単語文字の並びとして定義されます。
単語文字とは（上述の<acronym>POSIX</acronym>文字クラスで定義されているように）1つの<literal>alnum</literal>文字またはアンダースコアです。
これは、<acronym>POSIX</acronym> 1003.2との互換性はありますが、そこでは定義されていない式です。ですので、他システムへ移植予定のソフトウェアでの使用には注意が必要です。
通常後述の制約エスケープの方がよく使われます。これはもはや標準ではありませんが、入力しやすいものです。
   </para>
   </sect3>

   <sect3 id="posix-escape-sequences">
<!--
    <title>Regular Expression Escapes</title>
-->
    <title>正規表現エスケープ</title>

   <para>
<!--
    <firstterm>Escapes</firstterm> are special sequences beginning with <literal>\</literal>
    followed by an alphanumeric character. Escapes come in several varieties:
    character entry, class shorthands, constraint escapes, and back references.
    A <literal>\</literal> followed by an alphanumeric character but not constituting
    a valid escape is illegal in AREs.
    In EREs, there are no escapes: outside a bracket expression,
    a <literal>\</literal> followed by an alphanumeric character merely stands for
    that character as an ordinary character, and inside a bracket expression,
    <literal>\</literal> is an ordinary character.
    (The latter is the one actual incompatibility between EREs and AREs.)
-->
<firstterm>エスケープ</firstterm>とは、<literal>\</literal>から始まり英数字がその後に続く特殊な並びです。
エスケープには、文字エントリ、クラス省略、制約エスケープ、後方参照といった様々な変種があります。
<literal>\</literal>の後に英数字が続くけれども、有効なエスケープを構成しない並びはAREでは不正です。
EREにはエスケープはありません。ブラケット式の外側では、<literal>\</literal>の後に英数字が続く並びは単に普通の文字としてその文字を意味します。ブラケット式の内側では、<literal>\</literal>は普通の文字です。
（後者はEREとARE間の非互換性の1つです。）
   </para>

   <para>
<!--
    <firstterm>Character-entry escapes</firstterm> exist to make it easier to specify
    non-printing and other inconvenient characters in REs.  They are
    shown in <xref linkend="posix-character-entry-escapes-table"/>.
-->
<firstterm>文字エントリエスケープ</firstterm>は非印字文字やRE内でその他の不便な文字の指定を簡略化するために存在します。
これらを<xref linkend="posix-character-entry-escapes-table"/>に示します。
   </para>

   <para>
<!--
    <firstterm>Class-shorthand escapes</firstterm> provide shorthands for certain
    commonly-used character classes.  They are
    shown in <xref linkend="posix-class-shorthand-escapes-table"/>.
-->
<firstterm>クラス省略エスケープ</firstterm>は、あるよく使用される文字クラスの省略形を提供します。
これらを<xref linkend="posix-class-shorthand-escapes-table"/>に示します。
   </para>

   <para>
<!--
    A <firstterm>constraint escape</firstterm> is a constraint,
    matching the empty string if specific conditions are met,
    written as an escape.  They are
    shown in <xref linkend="posix-constraint-escapes-table"/>.
-->
<firstterm>制約エスケープ</firstterm>は、指定した条件に合う場合に空文字にマッチする制約をエスケープとして表したものです。
これらを<xref linkend="posix-constraint-escapes-table"/>に示します。
   </para>

   <para>
<!--
    A <firstterm>back reference</firstterm> (<literal>\</literal><replaceable>n</replaceable>) matches the
    same string matched by the previous parenthesized subexpression specified
    by the number <replaceable>n</replaceable>
    (see <xref linkend="posix-constraint-backref-table"/>).  For example,
    <literal>([bc])\1</literal> matches <literal>bb</literal> or <literal>cc</literal>
    but not <literal>bc</literal> or <literal>cb</literal>.
    The subexpression must entirely precede the back reference in the RE.
    Subexpressions are numbered in the order of their leading parentheses.
    Non-capturing parentheses do not define subexpressions.
-->
<firstterm>後方参照</firstterm>（<literal>\</literal><replaceable>n</replaceable>）は、直前に括弧で囲まれた副式によってマッチされた、<replaceable>n</replaceable>番目の同一文字列にマッチします（<xref linkend="posix-constraint-backref-table"/>を参照してください）。
  例えば、<literal>([bc])\1</literal>は<literal>bb</literal>もしくは<literal>cc</literal>にマッチしますが、<literal>bc</literal>や<literal>cb</literal>にはマッチしません。REでは副式全体は後方参照の前になければなりません。
副式は開括弧の順番で番号付けされます。
取り込まない括弧は副式を定義しません。
   </para>

   <table id="posix-character-entry-escapes-table">
<!--
    <title>Regular Expression Character-Entry Escapes</title>
-->
    <title>正規表現文字エントリエスケープ</title>

    <tgroup cols="2">
     <thead>
      <row>
<!--
       <entry>Escape</entry>
       <entry>Description</entry>
-->
       <entry>エスケープ</entry>
       <entry>説明</entry>
      </row>
     </thead>

      <tbody>
       <row>
       <entry> <literal>\a</literal> </entry>
<!--
       <entry> alert (bell) character, as in C </entry>
-->
       <entry>C言語と同じ警報（ベル）文字</entry>
       </row>

       <row>
       <entry> <literal>\b</literal> </entry>
<!--
       <entry> backspace, as in C </entry>
-->
       <entry>C言語と同じバックスペース</entry>
       </row>

       <row>
       <entry> <literal>\B</literal> </entry>
<!--
       <entry> synonym for backslash (<literal>\</literal>) to help reduce the need for backslash
       doubling </entry>
-->
       <entry> バックスラッシュの必要な二重化回数を減らすためのバックスラッシュ（<literal>\</literal>）の同義語</entry>
       </row>

       <row>
       <entry> <literal>\c</literal><replaceable>X</replaceable> </entry>
<!--
       <entry> (where <replaceable>X</replaceable> is any character) the character whose
       low-order 5 bits are the same as those of
       <replaceable>X</replaceable>, and whose other bits are all zero </entry>
-->
       <entry>（ここで<replaceable>X</replaceable>は任意の文字で）その下位5ビットが<replaceable>X</replaceable>と同一、その他のビットが0となる文字 </entry>
       </row>

       <row>
       <entry> <literal>\e</literal> </entry>
<!--
       <entry> the character whose collating-sequence name
       is <literal>ESC</literal>,
       or failing that, the character with octal value <literal>033</literal> </entry>
-->
       <entry>照合順名が<literal>ESC</literal>となる文字、それに失敗したら、<literal>033</literal>という8進数値を持つ文字。</entry>
       </row>

       <row>
       <entry> <literal>\f</literal> </entry>
<!--
       <entry> form feed, as in C </entry>
-->
       <entry>C言語と同じ改ページ</entry>
       </row>

       <row>
       <entry> <literal>\n</literal> </entry>
<!--
       <entry> newline, as in C </entry>
-->
       <entry>C言語と同じ改行</entry>
       </row>

       <row>
       <entry> <literal>\r</literal> </entry>
<!--
       <entry> carriage return, as in C </entry>
-->
       <entry>C言語と同じ復帰</entry>
       </row>

       <row>
       <entry> <literal>\t</literal> </entry>
<!--
       <entry> horizontal tab, as in C </entry>
-->
       <entry>C言語と同じ水平タブ</entry>
       </row>

       <row>
       <entry> <literal>\u</literal><replaceable>wxyz</replaceable> </entry>
<!--
       <entry> (where <replaceable>wxyz</replaceable> is exactly four hexadecimal digits)
       the character whose hexadecimal value is
       <literal>0x</literal><replaceable>wxyz</replaceable>
-->
       <entry>（ここで<replaceable>wxyz</replaceable>は正確に4桁の16進数で）その16進数での値が<literal>0x</literal><replaceable>wxyz</replaceable>という文字
       </entry>
       </row>

       <row>
       <entry> <literal>\U</literal><replaceable>stuvwxyz</replaceable> </entry>
<!--
       <entry> (where <replaceable>stuvwxyz</replaceable> is exactly eight hexadecimal
       digits)
       the character whose hexadecimal value is
       <literal>0x</literal><replaceable>stuvwxyz</replaceable>
-->
       <entry>（ここで<replaceable>stuvwxyz</replaceable>は正確に8桁の16進数で）その16進数での値が<literal>0x</literal><replaceable>stuvwxyz</replaceable>という文字
       </entry>
       </row>

       <row>
       <entry> <literal>\v</literal> </entry>
<!--
       <entry> vertical tab, as in C </entry>
-->
       <entry>C言語と同じ垂直タブ</entry>
       </row>

       <row>
       <entry> <literal>\x</literal><replaceable>hhh</replaceable> </entry>
<!--
       <entry> (where <replaceable>hhh</replaceable> is any sequence of hexadecimal
       digits)
       the character whose hexadecimal value is
       <literal>0x</literal><replaceable>hhh</replaceable>
       (a single character no matter how many hexadecimal digits are used)
-->
       <entry>（ここで<replaceable>hhh</replaceable>は任意の16進数の並びで）その文字の16進数値が<literal>0x</literal><replaceable>hhh</replaceable>となる文字（使用される16進数の桁数にかかわらず単一の文字）
       </entry>
       </row>

       <row>
       <entry> <literal>\0</literal> </entry>
<!--
       <entry> the character whose value is <literal>0</literal> (the null byte)</entry>
-->
       <entry>その値が<literal>0</literal>（NULLバイト）となる文字</entry>
       </row>

       <row>
       <entry> <literal>\</literal><replaceable>xy</replaceable> </entry>
<!--
       <entry> (where <replaceable>xy</replaceable> is exactly two octal digits,
       and is not a <firstterm>back reference</firstterm>)
       the character whose octal value is
       <literal>0</literal><replaceable>xy</replaceable> </entry>
-->
       <entry>（ここで<replaceable>xy</replaceable>は正確に2桁の8進数で、<firstterm>後方参照</firstterm>ではない）その値が<literal>0</literal><replaceable>xy</replaceable>となる文字</entry>
       </row>

       <row>
       <entry> <literal>\</literal><replaceable>xyz</replaceable> </entry>
<!--
       <entry> (where <replaceable>xyz</replaceable> is exactly three octal digits,
       and is not a <firstterm>back reference</firstterm>)
       the character whose octal value is
       <literal>0</literal><replaceable>xyz</replaceable> </entry>
-->
       <entry>（ここで<replaceable>xyz</replaceable>は正確に3桁の8進数で、<firstterm>後方参照</firstterm>ではない）その値が<literal>0</literal><replaceable>xyz</replaceable>となる文字</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
<!--
    Hexadecimal digits are <literal>0</literal>-<literal>9</literal>,
    <literal>a</literal>-<literal>f</literal>, and <literal>A</literal>-<literal>F</literal>.
    Octal digits are <literal>0</literal>-<literal>7</literal>.
-->
16進数の桁とは<literal>0</literal>-<literal>9</literal>、<literal>a</literal>-<literal>f</literal>、<literal>A</literal>-<literal>F</literal>です。
8進数の桁とは<literal>0</literal>-<literal>7</literal>です。
   </para>

   <para>
<!--
    Numeric character-entry escapes specifying values outside the ASCII range
    (0-127) have meanings dependent on the database encoding.  When the
    encoding is UTF-8, escape values are equivalent to Unicode code points,
    for example <literal>\u1234</literal> means the character <literal>U+1234</literal>.
    For other multibyte encodings, character-entry escapes usually just
    specify the concatenation of the byte values for the character.  If the
    escape value does not correspond to any legal character in the database
    encoding, no error will be raised, but it will never match any data.
-->
ASCIIの範囲(0-127)外の値を指定した数字のエントリエスケープは、その意味がデータベースエンコーディングに依存します。
エンコーディングがUTF-8の場合、エスケープ値はユニコード符号位置に相当します。例えば、<literal>\u1234</literal>は文字<literal>U+1234</literal>を意味します。
その他のマルチバイトエンコーディングでは、文字エントリエスケープはたいてい文字のバイト値の連結を指定します。
エスケープ値がデータベースエンコーディングでのいかなる正当な文字にも対応しない場合、エラーは起こりませんが、いかなるデータにもマッチしません。
   </para>

   <para>
<!--
    The character-entry escapes are always taken as ordinary characters.
    For example, <literal>\135</literal> is <literal>]</literal> in ASCII, but
    <literal>\135</literal> does not terminate a bracket expression.
-->
この文字エントリエスケープは常に普通の文字と解釈されます。
例えば、<literal>\135</literal>はASCIIの<literal>]</literal>となり、<literal>\135</literal>はブラケット式の終端にはなりません。
   </para>

   <table id="posix-class-shorthand-escapes-table">
<!--
    <title>Regular Expression Class-Shorthand Escapes</title>
-->
    <title>正規表現クラス省略エスケープ</title>

    <tgroup cols="2">
     <thead>
      <row>
<!--
       <entry>Escape</entry>
       <entry>Description</entry>
-->
       <entry>エスケープ</entry>
       <entry>説明</entry>
      </row>
     </thead>

      <tbody>
       <row>
       <entry> <literal>\d</literal> </entry>
       <entry> <literal>[[:digit:]]</literal> </entry>
       </row>

       <row>
       <entry> <literal>\s</literal> </entry>
       <entry> <literal>[[:space:]]</literal> </entry>
       </row>

       <row>
       <entry> <literal>\w</literal> </entry>
       <entry> <literal>[[:alnum:]_]</literal>
<!--
       (note underscore is included) </entry>
-->
       （アンダースコアが含まれることに注意）</entry>
       </row>

       <row>
       <entry> <literal>\D</literal> </entry>
       <entry> <literal>[^[:digit:]]</literal> </entry>
       </row>

       <row>
       <entry> <literal>\S</literal> </entry>
       <entry> <literal>[^[:space:]]</literal> </entry>
       </row>

       <row>
       <entry> <literal>\W</literal> </entry>
       <entry> <literal>[^[:alnum:]_]</literal>
<!--
       (note underscore is included) </entry>
-->
       （アンダースコアが含まれることに注意）</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
<!--
    Within bracket expressions, <literal>\d</literal>, <literal>\s</literal>,
    and <literal>\w</literal> lose their outer brackets,
    and <literal>\D</literal>, <literal>\S</literal>, and <literal>\W</literal> are illegal.
    (So, for example, <literal>[a-c\d]</literal> is equivalent to
    <literal>[a-c[:digit:]]</literal>.
    Also, <literal>[a-c\D]</literal>, which is equivalent to
    <literal>[a-c^[:digit:]]</literal>, is illegal.)
-->
ブラケット式内では、<literal>\d</literal>、<literal>\s</literal>、および<literal>\w</literal>はその外側の大括弧を失い、<literal>\D</literal>、<literal>\S</literal>および<literal>\W</literal>は不正です。
（ですから、例えば<literal>[a-c\d]</literal>は<literal>[a-c[:digit:]]</literal>と同じになります。また、<literal>[a-c\D]</literal>は<literal>[a-c^[:digit:]]</literal>と同じになり、不正です。）
   </para>

   <table id="posix-constraint-escapes-table">
<!--
    <title>Regular Expression Constraint Escapes</title>
-->
    <title>正規表現制約エスケープ</title>

    <tgroup cols="2">
     <thead>
      <row>
<!--
       <entry>Escape</entry>
       <entry>Description</entry>
-->
       <entry>エスケープ</entry>
       <entry>説明</entry>
      </row>
     </thead>

      <tbody>
       <row>
       <entry> <literal>\A</literal> </entry>
<!--
       <entry> matches only at the beginning of the string
       (see <xref linkend="posix-matching-rules"/> for how this differs from
       <literal>^</literal>) </entry>
-->
       <entry>文字列の先頭にのみマッチします（<literal>^</literal>との違いについては<xref linkend="posix-matching-rules"/>を参照してください）。</entry>
       </row>

       <row>
       <entry> <literal>\m</literal> </entry>
<!--
       <entry> matches only at the beginning of a word </entry>
-->
       <entry> 単語の先頭にのみマッチします。 </entry>
       </row>

       <row>
       <entry> <literal>\M</literal> </entry>
<!--
       <entry> matches only at the end of a word </entry>
-->
       <entry> 単語の末尾にのみマッチします。 </entry>
       </row>

       <row>
       <entry> <literal>\y</literal> </entry>
<!--
       <entry> matches only at the beginning or end of a word </entry>
-->
       <entry> 単語の先頭もしくは末尾にのみマッチします。</entry>
       </row>

       <row>
       <entry> <literal>\Y</literal> </entry>
<!--
       <entry> matches only at a point that is not the beginning or end of a
       word </entry>
-->
       <entry>単語の先頭もしくは末尾以外の場所にのみマッチします。</entry>
       </row>

       <row>
       <entry> <literal>\Z</literal> </entry>
<!--
       <entry> matches only at the end of the string
       (see <xref linkend="posix-matching-rules"/> for how this differs from
       <literal>$</literal>) </entry>
-->
       <entry>文字列の末尾にのみマッチします（<literal>$</literal>との違いについては<xref linkend="posix-matching-rules"/>を参照してください）。</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
<!--
    A word is defined as in the specification of
    <literal>[[:&lt;:]]</literal> and <literal>[[:&gt;:]]</literal> above.
    Constraint escapes are illegal within bracket expressions.
-->
    単語は前述の<literal>[[:&lt;:]]</literal>と<literal>[[:&gt;:]]</literal>の規定通りに定義されます。ブラケット式内では制約エスケープは不正です。
   </para>

   <table id="posix-constraint-backref-table">
<!--
    <title>Regular Expression Back References</title>
-->
    <title>正規表現後方参照</title>

    <tgroup cols="2">
     <thead>
      <row>
<!--
       <entry>Escape</entry>
       <entry>Description</entry>
-->
       <entry>エスケープ</entry>
       <entry>説明</entry>
      </row>
     </thead>

      <tbody>
       <row>
       <entry> <literal>\</literal><replaceable>m</replaceable> </entry>
<!--
       <entry> (where <replaceable>m</replaceable> is a nonzero digit)
       a back reference to the <replaceable>m</replaceable>'th subexpression </entry>
-->
       <entry>（ここで<replaceable>m</replaceable>は非ゼロの数です。）副式の<replaceable>m</replaceable>番目への後方参照</entry>
       </row>

       <row>
       <entry> <literal>\</literal><replaceable>mnn</replaceable> </entry>
<!--
       <entry> (where <replaceable>m</replaceable> is a nonzero digit, and
       <replaceable>nn</replaceable> is some more digits, and the decimal value
       <replaceable>mnn</replaceable> is not greater than the number of closing capturing
       parentheses seen so far)
       a back reference to the <replaceable>mnn</replaceable>'th subexpression </entry>
-->
       <entry>（ここで<replaceable>m</replaceable>は非ゼロの数です。<replaceable>nn</replaceable>でさらに桁を指定します。<replaceable>mnn</replaceable>10進数値は取り込み括弧の数よりも多くてはなりません。）副式の<replaceable>mnn</replaceable>番目への後方参照</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <note>
    <para>
<!--
     There is an inherent ambiguity between octal character-entry
     escapes and back references, which is resolved by the following heuristics,
     as hinted at above.
     A leading zero always indicates an octal escape.
     A single non-zero digit, not followed by another digit,
     is always taken as a back reference.
     A multi-digit sequence not starting with a zero is taken as a back
     reference if it comes after a suitable subexpression
     (i.e., the number is in the legal range for a back reference),
     and otherwise is taken as octal.
-->
8進数の文字エントリエスケープと後方参照の間には曖昧性があります。上でヒントとして示したようにこれは以下の発見的手法で解決されます。
先頭の0は常に8進数エスケープを示します。
その後に数字が続かない単一の非ゼロ数字は常に後方参照として解釈されます。
ゼロから始まらない複数数字の並びは、適切な副式の後にあれば（つまり、その番号が後方参照用の範囲内にあれば）後方参照として解釈されます。さもなくば、8進数として解釈されます。
    </para>
   </note>
   </sect3>

   <sect3 id="posix-metasyntax">
<!--
    <title>Regular Expression Metasyntax</title>
-->
    <title>正規表現メタ構文</title>

   <para>
<!--
    In addition to the main syntax described above, there are some special
    forms and miscellaneous syntactic facilities available.
-->
上述の主構文の他に、特殊な形式や雑多な構文的な機能が使用可能です。
   </para>

   <para>
<!--
    An RE can begin with one of two special <firstterm>director</firstterm> prefixes.
    If an RE begins with <literal>***:</literal>,
    the rest of the RE is taken as an ARE.  (This normally has no effect in
    <productname>PostgreSQL</productname>, since REs are assumed to be AREs;
    but it does have an effect if ERE or BRE mode had been specified by
    the <replaceable>flags</replaceable> parameter to a regex function.)
    If an RE begins with <literal>***=</literal>,
    the rest of the RE is taken to be a literal string,
    with all characters considered ordinary characters.
-->
REは、2つの特殊な<firstterm>決定子</firstterm>前置詞のどちらかから始まります。
REが<literal>***:</literal>から始まるものであれば、REの残りはAREと解釈されます。
(<productname>PostgreSQL</productname>はREをAREとして推測するため、通常は影響を受けません。ただし、正規表現関数に対して<replaceable>flags</replaceable>パラメータを指定されたEREやBREモードでは影響を受けます。)
REが<literal>***=</literal>から始まるものであれば、REの残りは、全ての文字を普通の文字とみなしたリテラル文字列と解釈されます。
   </para>

   <para>
<!--
    An ARE can begin with <firstterm>embedded options</firstterm>:
    a sequence <literal>(?</literal><replaceable>xyz</replaceable><literal>)</literal>
    (where <replaceable>xyz</replaceable> is one or more alphabetic characters)
    specifies options affecting the rest of the RE.
    These options override any previously determined options &mdash;
    in particular, they can override the case-sensitivity behavior implied by
    a regex operator, or the <replaceable>flags</replaceable> parameter to a regex
    function.
    The available option letters are
    shown in <xref linkend="posix-embedded-options-table"/>.
    Note that these same option letters are used in the <replaceable>flags</replaceable>
    parameters of regex functions.
-->
AREは<firstterm>埋め込みオプション</firstterm>から始められます。<literal>(?</literal><replaceable>xyz</replaceable><literal>)</literal>という並びで残りのREに影響するオプションを指定します（ここで<replaceable>xyz</replaceable>は1つ以上の英字です）。
このオプションは、事前に決定されたオプションを上書きします。&mdash; 特に、正規表現演算子、もしくは正規表現関数に与えられた<replaceable>flags</replaceable>パラメータにより示される大文字小文字の区別を上書きします。
使用可能なオプション文字を<xref linkend="posix-embedded-options-table"/>に示します。
これらの同じオプション文字が、正規表現関数の<replaceable>flags</replaceable>パラメータで使用されることに注意して下さい。
   </para>

   <table id="posix-embedded-options-table">
<!--
    <title>ARE Embedded-Option Letters</title>
-->
    <title>ARE埋め込みオプション文字</title>

    <tgroup cols="2">
     <thead>
      <row>
<!--
       <entry>Option</entry>
       <entry>Description</entry>
-->
       <entry>オプション</entry>
       <entry>説明</entry>
      </row>
     </thead>

      <tbody>
       <row>
       <entry> <literal>b</literal> </entry>
<!--
       <entry> rest of RE is a BRE </entry>
-->
       <entry> 残りのREはBRE </entry>
       </row>

       <row>
       <entry> <literal>c</literal> </entry>
<!--
       <entry> case-sensitive matching (overrides operator type) </entry>
-->
       <entry> 大文字小文字を区別するマッチ（演算子で規定される大文字小文字の区別よりこの指定が優先されます）。 </entry>
       </row>

       <row>
       <entry> <literal>e</literal> </entry>
<!--
       <entry> rest of RE is an ERE </entry>
-->
       <entry> 残りのREはERE </entry>
       </row>

       <row>
       <entry> <literal>i</literal> </entry>
<!--
       <entry> case-insensitive matching (see
       <xref linkend="posix-matching-rules"/>) (overrides operator type) </entry>
-->
       <entry> 大文字小文字を区別しないマッチ（<xref linkend="posix-matching-rules"/>を参照）（演算子で規定される大文字小文字の区別よりこの指定が優先されます）。 </entry>
       </row>

       <row>
       <entry> <literal>m</literal> </entry>
<!--
       <entry> historical synonym for <literal>n</literal> </entry>
-->
       <entry> <literal>n</literal>の歴史的な同義語 </entry>
       </row>

       <row>
       <entry> <literal>n</literal> </entry>
<!--
       <entry> newline-sensitive matching (see
       <xref linkend="posix-matching-rules"/>) </entry>
-->
       <entry> 改行を区別するマッチ（<xref linkend="posix-matching-rules"/>を参照）</entry>
       </row>

       <row>
       <entry> <literal>p</literal> </entry>
<!--
       <entry> partial newline-sensitive matching (see
       <xref linkend="posix-matching-rules"/>) </entry>
-->
       <entry> 部分的な改行を区別するマッチ（<xref linkend="posix-matching-rules"/>を参照）</entry>
       </row>

       <row>
       <entry> <literal>q</literal> </entry>
<!--
       <entry> rest of RE is a literal (<quote>quoted</quote>) string, all ordinary
       characters </entry>
-->
       <entry> 残りのREはリテラル（<quote>引用符付けされた</quote>）文字列、全て普通の文字</entry>
       </row>

       <row>
       <entry> <literal>s</literal> </entry>
<!--
       <entry> non-newline-sensitive matching (default) </entry>
-->
       <entry> 改行を区別しないマッチ（デフォルト）</entry>
       </row>

       <row>
       <entry> <literal>t</literal> </entry>
<!--
       <entry> tight syntax (default; see below) </entry>
-->
       <entry> 厳しめの構文（デフォルト、後述） </entry>
       </row>

       <row>
       <entry> <literal>w</literal> </entry>
<!--
       <entry> inverse partial newline-sensitive (<quote>weird</quote>) matching
       (see <xref linkend="posix-matching-rules"/>) </entry>
-->
       <entry> 部分的な改行区別の逆（<quote>ワイアード</quote>）マッチ（<xref linkend="posix-matching-rules"/>を参照）</entry>
       </row>

       <row>
       <entry> <literal>x</literal> </entry>
<!--
       <entry> expanded syntax (see below) </entry>
-->
       <entry> 拡張構文（後述） </entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
<!--
    Embedded options take effect at the <literal>)</literal> terminating the sequence.
    They can appear only at the start of an ARE (after the
    <literal>***:</literal> director if any).
-->
埋め込みオプションはその並びの終端<literal>)</literal>で有効になります。
AREの先頭（もし<literal>***:</literal>決定子があればその後）でのみ利用可能です。
   </para>

   <para>
<!--
    In addition to the usual (<firstterm>tight</firstterm>) RE syntax, in which all
    characters are significant, there is an <firstterm>expanded</firstterm> syntax,
    available by specifying the embedded <literal>x</literal> option.
    In the expanded syntax,
    white-space characters in the RE are ignored, as are
    all characters between a <literal>#</literal>
    and the following newline (or the end of the RE).  This
    permits paragraphing and commenting a complex RE.
    There are three exceptions to that basic rule:
-->
全ての文字が意味を持つ、通常の（<firstterm>厳しめの</firstterm>）RE構文に加え、<literal>x</literal>埋め込みオプションを指定することで利用できる<firstterm>拡張</firstterm>構文があります。
拡張構文では、RE内の空白文字は無視され、<literal>#</literal>とその後の改行（もしくはREの終端）の間の全ての文字も同様です。
これにより、段落付けや複雑なREのコメント付けが可能になります。
基本規則に対して3つの例外があります。

    <itemizedlist>
     <listitem>
      <para>
<!--
       a white-space character or <literal>#</literal> preceded by <literal>\</literal> is
       retained
-->
直前に<literal>\</literal>が付いた空白文字もしくは<literal>#</literal>は保持されます。
      </para>
     </listitem>
     <listitem>
      <para>
<!--
       white space or <literal>#</literal> within a bracket expression is retained
-->
ブラケット式内の空白文字もしくは<literal>#</literal>は保持されます。
      </para>
     </listitem>
     <listitem>
      <para>
<!--
       white space and comments cannot appear within multi-character symbols,
       such as <literal>(?:</literal>
-->
<literal>(?:</literal>などの複数文字シンボルでは、空白文字とコメントは不正です。
      </para>
     </listitem>
    </itemizedlist>

<!--
    For this purpose, white-space characters are blank, tab, newline, and
    any character that belongs to the <replaceable>space</replaceable> character class.
-->
ここでの空白文字とは、空白、タブ、改行、<replaceable>スペース</replaceable>文字クラスに属する文字です。
   </para>

   <para>
<!--
    Finally, in an ARE, outside bracket expressions, the sequence
    <literal>(?#</literal><replaceable>ttt</replaceable><literal>)</literal>
    (where <replaceable>ttt</replaceable> is any text not containing a <literal>)</literal>)
    is a comment, completely ignored.
    Again, this is not allowed between the characters of
    multi-character symbols, like <literal>(?:</literal>.
    Such comments are more a historical artifact than a useful facility,
    and their use is deprecated; use the expanded syntax instead.
-->
最後に、AREのブラケット式の外側では、<literal>(?#</literal><replaceable>ttt</replaceable><literal>)</literal>という並びはコメントになります（ここで<replaceable>ttt</replaceable>は<literal>)</literal>を含まない任意のテキストです）。
繰り返しになりますが、これは<literal>(?:</literal>などの複数文字シンボルの文字間では使用できません。
こうしたコメントは実用性というより歴史的所産です。そのため、この使用は勧めません。代わりに拡張構文を使用してください。
   </para>

   <para>
<!--
    <emphasis>None</emphasis> of these metasyntax extensions is available if
    an initial <literal>***=</literal> director
    has specified that the user's input be treated as a literal string
    rather than as an RE.
-->
初めに<literal>***=</literal>決定子が指定され、ユーザの入力がREではなくリテラルとして扱われる場合、これらのメタ構文拡張は使用<emphasis>できません</emphasis>。
   </para>
   </sect3>

   <sect3 id="posix-matching-rules">
<!--
    <title>Regular Expression Matching Rules</title>
-->
    <title>正規表現マッチ規則</title>

   <para>
<!--
    In the event that an RE could match more than one substring of a given
    string, the RE matches the one starting earliest in the string.
    If the RE could match more than one substring starting at that point,
    either the longest possible match or the shortest possible match will
    be taken, depending on whether the RE is <firstterm>greedy</firstterm> or
    <firstterm>non-greedy</firstterm>.
-->
REが文字列の中の1つ以上の部分文字列とマッチする場合において、REは最初にマッチが始まった部分文字列とマッチします。
その位置からまた1つ以上の部分文字列とマッチした際は、正規表現は<firstterm>最短マッチを行わない（欲張り型）</firstterm>か<firstterm>最短マッチを行う（非欲張り型）</firstterm>かによって、最長マッチもしくは最短マッチの文字列のどちらかにマッチします
   </para>

   <para>
<!--
    Whether an RE is greedy or not is determined by the following rules:
-->
REが最長マッチかどうかは以下の規則によって決まります。
    <itemizedlist>
     <listitem>
      <para>
<!--
       Most atoms, and all constraints, have no greediness attribute (because
       they cannot match variable amounts of text anyway).
-->
ほとんどのアトムおよび全ての式は欲張り属性を持ちません（これらは変動する量のテキストにまったくマッチしないからです）。
      </para>
     </listitem>
     <listitem>
      <para>
<!--
       Adding parentheses around an RE does not change its greediness.
-->
REを括弧で括ることは欲張りかどうかを変更しません。
      </para>
     </listitem>
     <listitem>
      <para>
<!--
       A quantified atom with a fixed-repetition quantifier
       (<literal>{</literal><replaceable>m</replaceable><literal>}</literal>
       or
       <literal>{</literal><replaceable>m</replaceable><literal>}?</literal>)
       has the same greediness (possibly none) as the atom itself.
-->
<literal>{</literal><replaceable>m</replaceable><literal>}</literal>もしくは<literal>{</literal><replaceable>m</replaceable><literal>}?</literal>といった固定繰り返し数の量指定子を持つ量指定付きアトムは、アトム自身と同一の欲張りさを持ちます（まったく持たない可能性もあります）。
      </para>
     </listitem>
     <listitem>
      <para>
<!--
       A quantified atom with other normal quantifiers (including
       <literal>{</literal><replaceable>m</replaceable><literal>,</literal><replaceable>n</replaceable><literal>}</literal>
       with <replaceable>m</replaceable> equal to <replaceable>n</replaceable>)
       is greedy (prefers longest match).
-->
他の通常の量指定子（<literal>{</literal><replaceable>m</replaceable><literal>,</literal><replaceable>n</replaceable><literal>}</literal>、<replaceable>m</replaceable>と<replaceable>n</replaceable>が等しい場合も含みます）を持つ量指定付きアトムは欲張り型です（最長マッチを使用します）。
      </para>
     </listitem>
     <listitem>
      <para>
<!--
       A quantified atom with a non-greedy quantifier (including
       <literal>{</literal><replaceable>m</replaceable><literal>,</literal><replaceable>n</replaceable><literal>}?</literal>
       with <replaceable>m</replaceable> equal to <replaceable>n</replaceable>)
       is non-greedy (prefers shortest match).
-->
他の非欲張り型量指定子（<literal>{</literal><replaceable>m</replaceable><literal>,</literal><replaceable>n</replaceable><literal>}?</literal>、<replaceable>m</replaceable>と<replaceable>n</replaceable>が等しい場合も含みます）を持つ量指定付きアトムは非欲張り型です（最短マッチを使用します）。
      </para>
     </listitem>
     <listitem>
      <para>
<!--
       A branch &mdash; that is, an RE that has no top-level
       <literal>|</literal> operator &mdash; has the same greediness as the first
       quantified atom in it that has a greediness attribute.
-->
最上位レベルの<literal>|</literal>演算子を持たないREであるブランチは、最初の欲張り属性を持つ量指定付きアトムと同一の欲張り属性を持ちます。
      </para>
     </listitem>
     <listitem>
      <para>
<!--
       An RE consisting of two or more branches connected by the
       <literal>|</literal> operator is always greedy.
-->
<literal>|</literal>演算子で接続された2つ以上のブランチからなるREは常に欲張り型です。
      </para>
     </listitem>
    </itemizedlist>
   </para>

   <para>
<!--
    The above rules associate greediness attributes not only with individual
    quantified atoms, but with branches and entire REs that contain quantified
    atoms.  What that means is that the matching is done in such a way that
    the branch, or whole RE, matches the longest or shortest possible
    substring <emphasis>as a whole</emphasis>.  Once the length of the entire match
    is determined, the part of it that matches any particular subexpression
    is determined on the basis of the greediness attribute of that
    subexpression, with subexpressions starting earlier in the RE taking
    priority over ones starting later.
-->
上の規則は、個々の量指定付きアトムだけではなく、量指定付きアトムを複数含むブランチやRE全体の欲張り属性に関連します。
つまり、ブランチやRE全体が<emphasis>全体として</emphasis>最長または最短の部分文字列にマッチするという方法でマッチ処理が行われます。
全体のマッチの長さが決まると、特定の部分式にマッチする部分がその部分式の欲張り属性によって決まります。この時、RE内でより前にある部分式が後にある部分式よりも高い優先度を持ちます。
   </para>

   <para>
<!--
    An example of what this means:
-->
この意味の例を示します。
<screen>
SELECT SUBSTRING('XY1234Z', 'Y*([0-9]{1,3})');
<lineannotation>Result: </lineannotation><computeroutput>123</computeroutput>
SELECT SUBSTRING('XY1234Z', 'Y*?([0-9]{1,3})');
<lineannotation>Result: </lineannotation><computeroutput>1</computeroutput>
</screen>
<!--
    In the first case, the RE as a whole is greedy because <literal>Y*</literal>
    is greedy.  It can match beginning at the <literal>Y</literal>, and it matches
    the longest possible string starting there, i.e., <literal>Y123</literal>.
    The output is the parenthesized part of that, or <literal>123</literal>.
    In the second case, the RE as a whole is non-greedy because <literal>Y*?</literal>
    is non-greedy.  It can match beginning at the <literal>Y</literal>, and it matches
    the shortest possible string starting there, i.e., <literal>Y1</literal>.
    The subexpression <literal>[0-9]{1,3}</literal> is greedy but it cannot change
    the decision as to the overall match length; so it is forced to match
    just <literal>1</literal>.
-->
最初の例では、<literal>Y*</literal>が欲張り型であるため、REは全体として欲張り型です。
マッチは<literal>Y</literal>の位置から始まり、そこから可能な限り最長の文字列にマッチします。つまり<literal>Y123</literal>となります。
出力は括弧で括られた部分、つまり<literal>123</literal>となります。
2番目の例では、<literal>Y*?</literal>が非欲張り型のため、REは全体として非欲張り型です。
マッチは<literal>Y</literal>の位置から始まり、そこから可能な限り最短の文字列にマッチします。つまり<literal>Y1</literal>となります。
部分式<literal>[0-9]{1,3}</literal>は欲張り型ですが、決定されたマッチする全体の長さを変更することはできません。したがって、強制的に<literal>1</literal>にマッチすることになります。
   </para>

   <para>
<!--
    In short, when an RE contains both greedy and non-greedy subexpressions,
    the total match length is either as long as possible or as short as
    possible, according to the attribute assigned to the whole RE.  The
    attributes assigned to the subexpressions only affect how much of that
    match they are allowed to <quote>eat</quote> relative to each other.
-->
まとめると、REが欲張り型部分式と非欲張り型部分式の両方を持つ場合、全体のマッチ長はRE全体に割り当てられる属性に応じて、最長マッチ長か最短マッチ長のどちらかになります。
部分式に割り当てられた属性は、部分式の中でどれだけの量をその部分式の中で<quote>消費</quote>できるかのみに影響します。
   </para>

   <para>
<!--
    The quantifiers <literal>{1,1}</literal> and <literal>{1,1}?</literal>
    can be used to force greediness or non-greediness, respectively,
    on a subexpression or a whole RE.
    This is useful when you need the whole RE to have a greediness attribute
    different from what's deduced from its elements.  As an example,
    suppose that we are trying to separate a string containing some digits
    into the digits and the parts before and after them.  We might try to
    do that like this:
-->
<literal>{1,1}</literal>および<literal>{1,1}?</literal>量指定子を副式もしくはRE全体に使用して、それぞれ、欲張りか欲張りでないかを強制することが可能です。
RE全体に対してはその要素から推論されるものと異なる欲張りさの属性が必要な場合に、これは便利です。
例として、数字をいくつか含む文字列を数字とその前後の部分に分けようとしているとします。
次のようにしてみるかもしれません。
<screen>
SELECT regexp_match('abc01234xyz', '(.*)(\d+)(.*)');
<lineannotation>Result: </lineannotation><computeroutput>{abc0123,4,xyz}</computeroutput>
</screen>
<!--
    That didn't work: the first <literal>.*</literal> is greedy so
    it <quote>eats</quote> as much as it can, leaving the <literal>\d+</literal> to
    match at the last possible place, the last digit.  We might try to fix
    that by making it non-greedy:
-->
上手くいきませんでした。最初の<literal>.*</literal>が欲張りで、可能なだけ<quote>消費</quote>してしまい、<literal>\d+</literal>は最後の可能な場所で最後の数字にマッチします。
欲張りでなくすることで直そうとするかもしれません。
<screen>
SELECT regexp_match('abc01234xyz', '(.*?)(\d+)(.*)');
<lineannotation>Result: </lineannotation><computeroutput>{abc,0,""}</computeroutput>
</screen>
<!--
    That didn't work either, because now the RE as a whole is non-greedy
    and so it ends the overall match as soon as possible.  We can get what
    we want by forcing the RE as a whole to be greedy:
-->
またもや上手くいきませんでした。今度は、REが全体として欲張りでなくなってしまい、できる限り早く全体に渡るマッチを終わらせてしまうからです。
RE全体として欲張りにすることで欲しいものが得られます。
<screen>
SELECT regexp_match('abc01234xyz', '(?:(.*?)(\d+)(.*)){1,1}');
<lineannotation>Result: </lineannotation><computeroutput>{abc,01234,xyz}</computeroutput>
</screen>
<!--
    Controlling the RE's overall greediness separately from its components'
    greediness allows great flexibility in handling variable-length patterns.
-->
REの全体に渡る欲張りさをその要素の欲張りさと別に制御すれば、可変長のパターンを非常に柔軟に扱えます。
   </para>

   <para>
<!--
    When deciding what is a longer or shorter match,
    match lengths are measured in characters, not collating elements.
    An empty string is considered longer than no match at all.
    For example:
    <literal>bb*</literal>
    matches the three middle characters of <literal>abbbc</literal>;
    <literal>(week|wee)(night|knights)</literal>
    matches all ten characters of <literal>weeknights</literal>;
    when <literal>(.*).*</literal>
    is matched against <literal>abc</literal> the parenthesized subexpression
    matches all three characters; and when
    <literal>(a*)*</literal> is matched against <literal>bc</literal>
    both the whole RE and the parenthesized
    subexpression match an empty string.
-->
マッチが長いか短いかを判断する時には、マッチの長さは照合要素ではなく文字列で測られます。
空文字列はまったくマッチする要素がない文字列よりも長いと考えられます。
例えば、<literal>bb*</literal>は<literal>abbbc</literal>の真中の3文字とマッチし、<literal>(week|wee)(night|knights)</literal>は<literal>weeknights</literal>の全ての10文字とマッチし、<literal>abc</literal>に対して<literal>(.*).*</literal>がマッチされると、括弧内の部分正規表現は3つの文字全てにマッチし、<literal>bc</literal>に対して<literal>(a*)*</literal>がマッチされると、全体のREと括弧内の正規表現は空文字列にマッチします。
   </para>

   <para>
<!--
    If case-independent matching is specified,
    the effect is much as if all case distinctions had vanished from the
    alphabet.
    When an alphabetic that exists in multiple cases appears as an
    ordinary character outside a bracket expression, it is effectively
    transformed into a bracket expression containing both cases,
    e.g., <literal>x</literal> becomes <literal>[xX]</literal>.
    When it appears inside a bracket expression, all case counterparts
    of it are added to the bracket expression, e.g.,
    <literal>[x]</literal> becomes <literal>[xX]</literal>
    and <literal>[^x]</literal> becomes <literal>[^xX]</literal>.
-->
もし大文字小文字を区別しないマッチが指定されると、アルファベット文字の大文字小文字の区別がまったくなくなったのと同じ効果を与えます。
ブラケット式の外側にアルファベットの大文字小文字が混ざった通常の文字が出てきた場合、例えば、<literal>x</literal>が<literal>[xX]</literal>となるように大文字小文字ともにブラケット式に実質的に転換されます。
ブラケット式の中に現れた時は、（例えば）<literal>[x]</literal>が<literal>[xX]</literal>となり、また<literal>[^x]</literal>が<literal>[^xX]</literal>となるように、全ての大文字小文字それぞれの対がブラケット式に追加されます。
   </para>

   <para>
<!--
    If newline-sensitive matching is specified, <literal>.</literal>
    and bracket expressions using <literal>^</literal>
    will never match the newline character
    (so that matches will never cross newlines unless the RE
    explicitly arranges it)
    and <literal>^</literal> and <literal>$</literal>
    will match the empty string after and before a newline
    respectively, in addition to matching at beginning and end of string
    respectively.
    But the ARE escapes <literal>\A</literal> and <literal>\Z</literal>
    continue to match beginning or end of string <emphasis>only</emphasis>.
-->
改行を区別するマッチが指定されると、<literal>.</literal>と<literal>^</literal>を使用するブラケット式は（REが明示的に調整されていたとしてもマッチが改行をまたがらないようにするために）改行文字にマッチしなくなります。また、<literal>^</literal>と<literal>$</literal>はそれぞれ改行直後と直前の空文字列にマッチし、さらに、それぞれ文字列の先頭と末尾にマッチします。
しかし、AREエスケープの<literal>\A</literal>と<literal>\Z</literal>は、継続して、文字列の先頭と末尾<emphasis>のみ</emphasis>にマッチします。
   </para>

   <para>
<!--
    If partial newline-sensitive matching is specified,
    this affects <literal>.</literal> and bracket expressions
    as with newline-sensitive matching, but not <literal>^</literal>
    and <literal>$</literal>.
-->
部分的に改行を区別するマッチが指定されると、<literal>.</literal>とブラケット式は改行を区別するマッチを行うようになりますが、<literal>^</literal>と<literal>$</literal>は変更されません。
   </para>

   <para>
<!--
    If inverse partial newline-sensitive matching is specified,
    this affects <literal>^</literal> and <literal>$</literal>
    as with newline-sensitive matching, but not <literal>.</literal>
    and bracket expressions.
    This isn't very useful but is provided for symmetry.
-->
部分的に改行を区別する逆マッチが指定されると、<literal>^</literal>と<literal>$</literal>は改行を区別するマッチを行うようになりますが、<literal>.</literal>とブラケット式は変更されません。
これはあまり有用ではありません。対称性のために提供されています。
   </para>
   </sect3>

   <sect3 id="posix-limits-compatibility">
<!--
    <title>Limits and Compatibility</title>
-->
    <title>制限と互換性</title>

   <para>
<!--
    No particular limit is imposed on the length of REs in this
    implementation.  However,
    programs intended to be highly portable should not employ REs longer
    than 256 bytes,
    as a POSIX-compliant implementation can refuse to accept such REs.
-->
本実装ではREの長さに関する制限はありません。
しかし、移植性を高めたいプログラムでは、256バイトを超えるREを使用すべきではありません。POSIX互換の実装ではそうしたREでは混乱する可能性があります。
   </para>

   <para>
<!--
    The only feature of AREs that is actually incompatible with
    POSIX EREs is that <literal>\</literal> does not lose its special
    significance inside bracket expressions.
    All other ARE features use syntax which is illegal or has
    undefined or unspecified effects in POSIX EREs;
    the <literal>***</literal> syntax of directors likewise is outside the POSIX
    syntax for both BREs and EREs.
-->
AREの機能のうち、POSIX EREと実質的な非互換性があるのは、<literal>\</literal>がブラケット式の内側で特殊な意味を失わないという点のみです。
他の全てのARE機能は、POSIX EREでは不正、未定義、未指定な効果となる構文を使用しています。決定子の<literal>***</literal>構文などはBREおよびEREのPOSIX構文にはありません。
   </para>

   <para>
<!--
    Many of the ARE extensions are borrowed from Perl, but some have
    been changed to clean them up, and a few Perl extensions are not present.
    Incompatibilities of note include <literal>\b</literal>, <literal>\B</literal>,
    the lack of special treatment for a trailing newline,
    the addition of complemented bracket expressions to the things
    affected by newline-sensitive matching,
    the restrictions on parentheses and back references in lookahead/lookbehind
    constraints, and the longest/shortest-match (rather than first-match)
    matching semantics.
-->
多くのARE拡張はPerlから拝借したものです。
しかし、いくつかは整理され、Perlの拡張のいくつかは存在しません。
注意すべき非互換性には、<literal>\b</literal>、<literal>\B</literal>、改行の取り扱いに関する特殊な措置の欠落、改行を区別するマッチに影響する点について補足したブラケット式の追加、括弧と先行・後方検索制約内の後方参照についての制限、最長/最短（最初にマッチするではなく）マッチのセマンティクスがあります。
   </para>

   <para>
<!--
    Two significant incompatibilities exist between AREs and the ERE syntax
    recognized by pre-7.4 releases of <productname>PostgreSQL</productname>:
-->
<productname>PostgreSQL</productname>リリース7.4より前で認知された、AREとERE構文間で大きな非互換が2つあります。

    <itemizedlist>
     <listitem>
      <para>
<!--
       In AREs, <literal>\</literal> followed by an alphanumeric character is either
       an escape or an error, while in previous releases, it was just another
       way of writing the alphanumeric.
       This should not be much of a problem because there was no reason to
       write such a sequence in earlier releases.
-->
AREでは、<literal>\</literal>の後に英数字が続くものはエスケープもしくはエラーとなります。以前のリリースでは、これは単に、英数字を記述する他の方法でした。
これは、大きな問題にはならないはずです。以前のリリースではこうした並びを記述する理由がないからです。
      </para>
     </listitem>
     <listitem>
      <para>
<!--
       In AREs, <literal>\</literal> remains a special character within
       <literal>[]</literal>, so a literal <literal>\</literal> within a bracket
       expression must be written <literal>\\</literal>.
-->
AREでは、<literal>\</literal>は<literal>[]</literal>内でも特別な文字です。したがって、ブラケット式では<literal>\</literal>を<literal>\\</literal>と記述しなければなりません。
      </para>
     </listitem>
    </itemizedlist>
   </para>
   </sect3>

   <sect3 id="posix-basic-regexes">
<!--
    <title>Basic Regular Expressions</title>
-->
    <title>基本正規表現</title>

   <para>
<!--
    BREs differ from EREs in several respects.
    In BREs, <literal>|</literal>, <literal>+</literal>, and <literal>?</literal>
    are ordinary characters and there is no equivalent
    for their functionality.
    The delimiters for bounds are
    <literal>\{</literal> and <literal>\}</literal>,
    with <literal>{</literal> and <literal>}</literal>
    by themselves ordinary characters.
    The parentheses for nested subexpressions are
    <literal>\(</literal> and <literal>\)</literal>,
    with <literal>(</literal> and <literal>)</literal> by themselves ordinary characters.
    <literal>^</literal> is an ordinary character except at the beginning of the
    RE or the beginning of a parenthesized subexpression,
    <literal>$</literal> is an ordinary character except at the end of the
    RE or the end of a parenthesized subexpression,
    and <literal>*</literal> is an ordinary character if it appears at the beginning
    of the RE or the beginning of a parenthesized subexpression
    (after a possible leading <literal>^</literal>).
    Finally, single-digit back references are available, and
    <literal>\&lt;</literal> and <literal>\&gt;</literal>
    are synonyms for
    <literal>[[:&lt;:]]</literal> and <literal>[[:&gt;:]]</literal>
    respectively; no other escapes are available in BREs.
-->
BREはEREといくつかの面において異なります。
BREにおいては、<literal>|</literal>、<literal>+</literal>、<literal>?</literal>は普通の文字であり、それらの機能と等価なものはありません。
バウンドの区切りは<literal>\{</literal>と<literal>\}</literal>であり、<literal>{</literal>と<literal>}</literal>自身は普通の文字です。
副式を入れ子にするための括弧は<literal>\(</literal>と<literal>\)</literal>であり、<literal>(</literal>と<literal>)</literal>自身は普通の文字です。
<literal>^</literal>は、REの先頭にある場合や括弧内の副式の先頭の場合を除き、普通の文字です。
<literal>$</literal>は、REの末尾にある場合や括弧内の副式の末尾の場合を除き、普通の文字です。
また、<literal>*</literal>はREの先頭にある場合や括弧内の副式の先頭にある場合には普通の文字になります（その前に<literal>^</literal>が付いている可能性もあります）。
最後に、1桁の後方参照を使用することができ、また、BREにおいては、<literal>\&lt;</literal>と<literal>\&gt;</literal>はそれぞれ<literal>[[:&lt;:]]</literal>と<literal>[[:&gt;:]]</literal>と同義です。
   </para>
   </sect3>

<!-- end re_syntax.n man page -->

   <sect3 id="posix-vs-xquery">
<!--
   <title>Differences From XQuery (<literal>LIKE_REGEX</literal>)</title>
-->
   <title>XQueryとの違い(<literal>LIKE_REGEX</literal>)</title>

   <indexterm zone="posix-vs-xquery">
    <primary><literal>LIKE_REGEX</literal></primary>
   </indexterm>

   <indexterm zone="posix-vs-xquery">
<!--
    <primary>XQuery regular expressions</primary>
-->
    <primary>XQuery正規表現</primary>
   </indexterm>

    <para>
<!--
     Since SQL:2008, the SQL standard includes
     a <literal>LIKE_REGEX</literal> operator that performs pattern
     matching according to the XQuery regular expression
     standard.  <productname>PostgreSQL</productname> does not yet
     implement this operator, but you can get very similar behavior using
     the <function>regexp_match()</function> function, since XQuery
     regular expressions are quite close to the ARE syntax described above.
-->
SQL:2008以降、SQL標準にはXQuery正規表現標準によるパターンマッチングを行う<literal>LIKE_REGEX</literal>演算子が含まれています。
<productname>PostgreSQL</productname>は今の所この演算子を実装していませんが、<function>regexp_match()</function>を使ってよく似た振る舞いを得ることができます。
XQueryの正規表現は上で述べたARE構文に非常に近いからです。
    </para>

    <para>
<!--
     Notable differences between the existing POSIX-based
     regular-expression feature and XQuery regular expressions include:
-->
既存のPOSIXベースの正規表現機能とXQueryの正規表現の主な違いには以下のものが含まれます。

     <itemizedlist>
      <listitem>
       <para>
<!--
        XQuery character class subtraction is not supported.  An example of
        this feature is using the following to match only English
        consonants: <literal>[a-z-[aeiou]]</literal>.
-->
XQueryの文字クラス減算はサポートされていません。
この機能の例としては、<literal>[a-z-[aeiou]]</literal>のようにして英語の子音のみにマッチさせるというのがあります。
       </para>
      </listitem>
      <listitem>
       <para>
<!--
        XQuery character class shorthands <literal>\c</literal>,
        <literal>\C</literal>, <literal>\i</literal>,
        and <literal>\I</literal> are not supported.
-->
XQueryの文字クラス短縮形<literal>\c</literal>、<literal>\C</literal>、<literal>\i</literal>、<literal>\I</literal>はサポートされていません。
       </para>
      </listitem>
      <listitem>
       <para>
<!--
        XQuery character class elements
        using <literal>\p{UnicodeProperty}</literal> or the
        inverse <literal>\P{UnicodeProperty}</literal> are not supported.
-->
<literal>\p{UnicodeProperty}</literal>あるいはその逆である<literal>\P{UnicodeProperty}</literal>を使ったXQueryの文字クラス要素はサポートされていません。
       </para>
      </listitem>
      <listitem>
       <para>
<!--
        POSIX interprets character classes such as <literal>\w</literal>
        (see <xref linkend="posix-class-shorthand-escapes-table"/>)
        according to the prevailing locale (which you can control by
        attaching a <literal>COLLATE</literal> clause to the operator or
        function).  XQuery specifies these classes by reference to Unicode
        character properties, so equivalent behavior is obtained only with
        a locale that follows the Unicode rules.
-->
POSIXは有効なロケール（演算子あるいは関数の<literal>COLLATE</literal>節で制御できます）にしたがい、<literal>\w</literal>（<xref linkend="posix-class-shorthand-escapes-table"/>参照）のような文字クラスを解釈します。
XQueryはこれらのクラスをUnicodeの文字属性を参照してこれらのクラスを決定します。
ですからUnicodeルールに従うロケールを使用してのみ同等の振る舞いを得ることができます。
       </para>
      </listitem>
      <listitem>
       <para>
<!--
        The SQL standard (not XQuery itself) attempts to cater for more
        variants of <quote>newline</quote> than POSIX does.  The
        newline-sensitive matching options described above consider only
        ASCII NL (<literal>\n</literal>) to be a newline, but SQL would have
        us treat CR (<literal>\r</literal>), CRLF (<literal>\r\n</literal>)
        (a Windows-style newline), and some Unicode-only characters like
        LINE SEPARATOR (U+2028) as newlines as well.
        Notably, <literal>.</literal> and <literal>\s</literal> should
        count <literal>\r\n</literal> as one character not two according to
        SQL.
-->
SQL標準（XQuery自身ではなく）はPOSIXが提供するより多様な<quote>newline</quote>の亜種を提供しようとしています。
上で述べた改行に敏感なマッチオプションはASCII NL（<literal>\n</literal>）だけを改行として考慮します。
しかしSQLはCR （<literal>\r</literal>）、CRLF （<literal>\r\n</literal>）(Windowsスタイルの改行）、LINE SEPARATOR (U+2028)のようなUnicodeのみの文字も改行として扱うことを求めています。
とりわけ、SQLにおいては、<literal>.</literal>と<literal>\s</literal>は<literal>\r\n</literal>を2文字ではなく、1文字として数える必要があります。
       </para>
      </listitem>
      <listitem>
       <para>
<!--
        Of the character-entry escapes described in
        <xref linkend="posix-character-entry-escapes-table"/>,
        XQuery supports only <literal>\n</literal>, <literal>\r</literal>,
        and <literal>\t</literal>.
-->
<xref linkend="posix-character-entry-escapes-table"/>で示す文字エントリエスケープのうち、XQueryは<literal>\n</literal>、<literal>\r</literal>、<literal>\t</literal>だけをサポートしています。
       </para>
      </listitem>
      <listitem>
       <para>
<!--
        XQuery does not support
        the <literal>[:<replaceable>name</replaceable>:]</literal> syntax
        for character classes within bracket expressions.
-->
XQueryはブラケット式内の文字クラスとして<literal>[:<replaceable>name</replaceable>:]</literal>構文をサポートしていません。
       </para>
      </listitem>
      <listitem>
       <para>
<!--
        XQuery does not have lookahead or lookbehind constraints,
        nor any of the constraint escapes described in
        <xref linkend="posix-constraint-escapes-table"/>.
-->
XQueryには先行検索制約および後方検索制約がありませんし、<xref linkend="posix-constraint-escapes-table"/>に記述された制約エスケープもありません。
       </para>
      </listitem>
      <listitem>
       <para>
<!--
        The metasyntax forms described in <xref linkend="posix-metasyntax"/>
        do not exist in XQuery.
-->
<xref linkend="posix-metasyntax"/>に記述されたメタ構文形式はXQueryには存在しません。
       </para>
      </listitem>
      <listitem>
       <para>
<!--
        The regular expression flag letters defined by XQuery are
        related to but not the same as the option letters for POSIX
        (<xref linkend="posix-embedded-options-table"/>).  While the
        <literal>i</literal> and <literal>q</literal> options behave the
        same, others do not:
-->
XQueryで定義された正規表現フラグ文字はPOSIX（<xref linkend="posix-embedded-options-table"/>）のオプション文字に関連していますが、同じではありません。
<literal>i</literal>と<literal>q</literal>オプションは同じように振る舞いますが、その他は違います。
        <itemizedlist>
         <listitem>
          <para>
<!--
           XQuery's <literal>s</literal> (allow dot to match newline)
           and <literal>m</literal> (allow <literal>^</literal>
           and <literal>$</literal> to match at newlines) flags provide
           access to the same behaviors as
           POSIX's <literal>n</literal>, <literal>p</literal>
           and <literal>w</literal> flags, but they
           do <emphasis>not</emphasis> match the behavior of
           POSIX's <literal>s</literal> and <literal>m</literal> flags.
           Note in particular that dot-matches-newline is the default
           behavior in POSIX but not XQuery.
-->
XQueryの<literal>s</literal>（ピリオドが改行にマッチすることを許容する）と<literal>m</literal>（<literal>^</literal>と<literal>$</literal>が改行位置でマッチすることを許容する）フラグは、POSIXの<literal>n</literal>、<literal>p</literal>、<literal>w</literal>フラグと同じ挙動を提供しますが、POSIXの<literal>s</literal>と<literal>m</literal>フラグの挙動とは一致<emphasis>しません</emphasis>。
ピリオドが改行にマッチするのはPOSIXではデフォルトの挙動ですが、XQueryではそうでないことに留意してください。
          </para>
         </listitem>
         <listitem>
          <para>
<!--
           XQuery's <literal>x</literal> (ignore whitespace in pattern) flag
           is noticeably different from POSIX's expanded-mode flag.
           POSIX's <literal>x</literal> flag also
           allows <literal>#</literal> to begin a comment in the pattern,
           and POSIX will not ignore a whitespace character after a
           backslash.
-->
XQueryの<literal>x</literal>（パターン中の空白を無視する）フラグはPOSIXの拡張モードフラグとは著しく異なります。
POSIXの<literal>x</literal>フラグは<literal>#</literal>でパターン中のコメントを始めることもできます。
POSIXはバックスラッシュ以降の空白文字を無視しません。
          </para>
         </listitem>
        </itemizedlist>
       </para>
      </listitem>
     </itemizedlist>
    </para>

   </sect3>
  </sect2>
 </sect1>

<!-- split-func1-end -->
<!-- split-func2-start -->

  <sect1 id="functions-formatting">
<!--
   <title>Data Type Formatting Functions</title>
-->
   <title>データ型書式設定関数</title>

   <indexterm>
<!--
    <primary>formatting</primary>
-->
    <primary>書式設定</primary>
   </indexterm>

   <para>
<!--
    The <productname>PostgreSQL</productname> formatting functions
    provide a powerful set of tools for converting various data types
    (date/time, integer, floating point, numeric) to formatted strings
    and for converting from formatted strings to specific data types.
    <xref linkend="functions-formatting-table"/> lists them.
    These functions all follow a common calling convention: the first
    argument is the value to be formatted and the second argument is a
    template that defines the output or input format.
-->
<productname>PostgreSQL</productname>の書式設定関数は多彩なデータ型（日付/時刻データ型、整数データ型、浮動小数点数データ型、数値データ型）を整形された文字列に変換したり、整形された文字列を特定のデータ型に変換する強力なツールの一式を提供しています。
<xref linkend="functions-formatting-table"/>にこれらを列挙しています。
これら関数は共通の呼び出し規約を踏襲しています。最初の引数は整形される値で2番目の引数は入力書式または出力書式を定義するテンプレートです。
   </para>

    <table id="functions-formatting-table">
<!--
     <title>Formatting Functions</title>
-->
     <title>書式設定関数</title>
     <tgroup cols="4">
      <thead>
       <row>
<!--
        <entry>Function</entry>
        <entry>Return Type</entry>
        <entry>Description</entry>
        <entry>Example</entry>
-->
        <entry>関数</entry>
        <entry>戻り値</entry>
        <entry>説明</entry>
        <entry>例</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>
         <indexterm>
          <primary>to_char</primary>
         </indexterm>
         <literal><function>to_char(<type>timestamp</type>, <type>text</type>)</function></literal>
        </entry>
        <entry><type>text</type></entry>
<!--
        <entry>convert time stamp to string</entry>
-->
        <entry>タイムスタンプを文字列に変換</entry>
        <entry><literal>to_char(current_timestamp, 'HH12:MI:SS')</literal></entry>
       </row>
       <row>
        <entry><literal><function>to_char(<type>interval</type>, <type>text</type>)</function></literal></entry>
        <entry><type>text</type></entry>
<!--
        <entry>convert interval to string</entry>
-->
        <entry>時間間隔を文字列に変換</entry>
        <entry><literal>to_char(interval '15h&nbsp;2m&nbsp;12s', 'HH24:MI:SS')</literal></entry>
       </row>
       <row>
        <entry><literal><function>to_char(<type>int</type>, <type>text</type>)</function></literal></entry>
        <entry><type>text</type></entry>
<!--
        <entry>convert integer to string</entry>
-->
        <entry>整数を文字列に変換</entry>
        <entry><literal>to_char(125, '999')</literal></entry>
       </row>
       <row>
        <entry><literal><function>to_char</function>(<type>double precision</type>,
        <type>text</type>)</literal></entry>
        <entry><type>text</type></entry>
<!--
        <entry>convert real/double precision to string</entry>
-->
        <entry>実数、倍精度数を文字列に変換</entry>
        <entry><literal>to_char(125.8::real, '999D9')</literal></entry>
       </row>
       <row>
        <entry><literal><function>to_char(<type>numeric</type>, <type>text</type>)</function></literal></entry>
        <entry><type>text</type></entry>
<!--
        <entry>convert numeric to string</entry>
-->
        <entry>数値を文字列に変換</entry>
        <entry><literal>to_char(-125.8, '999D99S')</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>to_date</primary>
         </indexterm>
         <literal><function>to_date(<type>text</type>, <type>text</type>)</function></literal>
        </entry>
        <entry><type>date</type></entry>
<!--
        <entry>convert string to date</entry>
-->
        <entry>文字列を日付に変換</entry>
        <entry><literal>to_date('05&nbsp;Dec&nbsp;2000', 'DD&nbsp;Mon&nbsp;YYYY')</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>to_number</primary>
         </indexterm>
         <literal><function>to_number(<type>text</type>, <type>text</type>)</function></literal>
        </entry>
        <entry><type>numeric</type></entry>
<!--
        <entry>convert string to numeric</entry>
-->
        <entry>文字列を数値に変換</entry>
        <entry><literal>to_number('12,454.8-', '99G999D9S')</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>to_timestamp</primary>
         </indexterm>
         <literal><function>to_timestamp(<type>text</type>, <type>text</type>)</function></literal>
        </entry>
        <entry><type>timestamp with time zone</type></entry>
<!--
        <entry>convert string to time stamp</entry>
-->
        <entry>文字列をタイムスタンプに変換</entry>
        <entry><literal>to_timestamp('05&nbsp;Dec&nbsp;2000', 'DD&nbsp;Mon&nbsp;YYYY')</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <note>
    <para>
<!--
     There is also a single-argument <function>to_timestamp</function>
     function; see <xref linkend="functions-datetime-table"/>.
-->
引数が１つの<function>to_timestamp</function>関数もあります。
<xref linkend="functions-datetime-table"/>を参照して下さい。
    </para>
   </note>

   <tip>
    <para>
<!--
     <function>to_timestamp</function> and <function>to_date</function>
     exist to handle input formats that cannot be converted by
     simple casting.  For most standard date/time formats, simply casting the
     source string to the required data type works, and is much easier.
     Similarly, <function>to_number</function> is unnecessary for standard numeric
     representations.
-->
<function>to_timestamp</function>と<function>to_date</function>は、単純なキャストでは変換できない入力フォーマットを処理するために存在します。
ほとんどの標準的日付および時刻のフォーマットに対しては、入力文字列を必要なデータ型に単純にキャストすれば動作し、その方がずっと簡単です。
同様に、<function>to_number</function>も標準的な数値表現に対しては不要です。
    </para>
   </tip>

   <para>
<!--
    In a <function>to_char</function> output template string, there are certain
    patterns that are recognized and replaced with appropriately-formatted
    data based on the given value.  Any text that is not a template pattern is
    simply copied verbatim.  Similarly, in an input template string (for the
    other functions), template patterns identify the values to be supplied by
    the input data string.  If there are characters in the template string
    that are not template patterns, the corresponding characters in the input
    data string are simply skipped over (whether or not they are equal to the
    template string characters).
-->
<function>to_char</function>用の出力テンプレート文字列には、値に基づいて認識され、適切に整形されたデータで置き換えられるパターンがあります。
テンプレートパターンではない全てのテキストは単にそのままコピーされます。
同様に、（その他の関数用の）入力テンプレート文字列では、テンプレートパターンは入力されたデータ文字列で供給される値を特定します。
テンプレート文字列中にテンプレートパターンではない文字があれば、（テンプレート文字列の文字と同じかどうかにかかわらず）入力文字列データ中の該当文字は単にスキップされます。
   </para>

  <para>
<!--
   <xref linkend="functions-formatting-datetime-table"/> shows the
   template patterns available for formatting date and time values.
-->
<xref linkend="functions-formatting-datetime-table"/>に、日付/時刻型の値の書式に使用可能なテンプレートパターンを示します。
  </para>

    <table id="functions-formatting-datetime-table">
<!--
     <title>Template Patterns for Date/Time Formatting</title>
-->
     <title>日付/時刻型の書式テンプレートパターン</title>
     <tgroup cols="2">
      <thead>
       <row>
<!--
        <entry>Pattern</entry>
        <entry>Description</entry>
-->
        <entry>パターン</entry>
        <entry>説明</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><literal>HH</literal></entry>
<!--
        <entry>hour of day (01-12)</entry>
-->
        <entry>時（01〜12）</entry>
       </row>
       <row>
        <entry><literal>HH12</literal></entry>
<!--
        <entry>hour of day (01-12)</entry>
-->
        <entry>時（01〜12）</entry>
       </row>
       <row>
        <entry><literal>HH24</literal></entry>
<!--
        <entry>hour of day (00-23)</entry>
-->
        <entry>時（00〜23）</entry>
       </row>
       <row>
        <entry><literal>MI</literal></entry>
<!--
        <entry>minute (00-59)</entry>
-->
        <entry>分（00〜59）</entry>
       </row>
       <row>
        <entry><literal>SS</literal></entry>
<!--
        <entry>second (00-59)</entry>
-->
        <entry>秒（00〜59）</entry>
       </row>
       <row>
        <entry><literal>MS</literal></entry>
<!--
        <entry>millisecond (000-999)</entry>
-->
        <entry>ミリ秒（000〜999）</entry>
       </row>
       <row>
        <entry><literal>US</literal></entry>
<!--
        <entry>microsecond (000000-999999)</entry>
-->
        <entry>マイクロ秒（000000〜999999）</entry>
       </row>
       <row>
        <entry><literal>SSSS</literal></entry>
<!--
        <entry>seconds past midnight (0-86399)</entry>
-->
        <entry>深夜0時からの秒数（0〜86399）</entry>
       </row>
       <row>
<!--
        <entry><literal>AM</literal>, <literal>am</literal>,
        <literal>PM</literal> or <literal>pm</literal></entry>
-->
        <entry><literal>AM</literal>、<literal>am</literal>、
        <literal>PM</literal>、または<literal>pm</literal></entry>
<!--
        <entry>meridiem indicator (without periods)</entry>
-->
        <entry>午前/午後の指定（ピリオドなし）</entry>
       </row>
       <row>
<!--
        <entry><literal>A.M.</literal>, <literal>a.m.</literal>,
        <literal>P.M.</literal> or <literal>p.m.</literal></entry>
-->
        <entry><literal>A.M.</literal>、<literal>a.m.</literal>、
        <literal>P.M.</literal>、または<literal>p.m.</literal></entry>
<!--
        <entry>meridiem indicator (with periods)</entry>
-->
        <entry>午前/午後の指定（ピリオド付き）</entry>
       </row>
       <row>
        <entry><literal>Y,YYY</literal></entry>
<!--
        <entry>year (4 or more digits) with comma</entry>
-->
        <entry>コンマ付き年（4桁以上）</entry>
       </row>
       <row>
        <entry><literal>YYYY</literal></entry>
<!--
        <entry>year (4 or more digits)</entry>
-->
        <entry>年（4桁以上）</entry>
       </row>
       <row>
        <entry><literal>YYY</literal></entry>
<!--
        <entry>last 3 digits of year</entry>
-->
        <entry>年の下3桁</entry>
       </row>
       <row>
        <entry><literal>YY</literal></entry>
<!--
        <entry>last 2 digits of year</entry>
-->
        <entry>年の下2桁</entry>
       </row>
       <row>
        <entry><literal>Y</literal></entry>
<!--
        <entry>last digit of year</entry>
-->
        <entry>年の下1桁</entry>
       </row>
       <row>
        <entry><literal>IYYY</literal></entry>
<!--
        <entry>ISO 8601 week-numbering year (4 or more digits)</entry>
-->
        <entry>ISO 8601週番号年（4桁以上）</entry>
       </row>
       <row>
        <entry><literal>IYY</literal></entry>
<!--
        <entry>last 3 digits of ISO 8601 week-numbering year</entry>
-->
        <entry>ISO 8601週番号年の下3桁</entry>
       </row>
       <row>
        <entry><literal>IY</literal></entry>
<!--
        <entry>last 2 digits of ISO 8601 week-numbering year</entry>
-->
        <entry>ISO 8601週番号年の下2桁</entry>
       </row>
       <row>
        <entry><literal>I</literal></entry>
<!--
        <entry>last digit of ISO 8601 week-numbering year</entry>
-->
        <entry>ISO 8601週番号年の下1桁</entry>
       </row>
       <row>
<!--
        <entry><literal>BC</literal>, <literal>bc</literal>,
        <literal>AD</literal> or <literal>ad</literal></entry>
-->
        <entry><literal>BC</literal>、<literal>bc</literal>、
        <literal>AD</literal>、または<literal>ad</literal></entry>
<!--
        <entry>era indicator (without periods)</entry>
-->
        <entry>紀元前後の指定（ピリオドなし）</entry>
       </row>
       <row>
<!--
        <entry><literal>B.C.</literal>, <literal>b.c.</literal>,
        <literal>A.D.</literal> or <literal>a.d.</literal></entry>
-->
        <entry><literal>B.C.</literal>、<literal>b.c.</literal>、
        <literal>A.D.</literal>、または<literal>a.d.</literal></entry>
<!--
        <entry>era indicator (with periods)</entry>
-->
        <entry>紀元前後の指定（ピリオド付き）</entry>
       </row>
       <row>
        <entry><literal>MONTH</literal></entry>
<!--
        <entry>full upper case month name (blank-padded to 9 chars)</entry>
-->
        <entry>大文字での完全な月名（9文字になるように空白文字を埋める）</entry>
       </row>
       <row>
        <entry><literal>Month</literal></entry>
<!--
        <entry>full capitalized month name (blank-padded to 9 chars)</entry>
-->
        <entry>大文字で書き始める完全な月名（9文字になるように空白文字を埋める）</entry>
       </row>
       <row>
        <entry><literal>month</literal></entry>
<!--
        <entry>full lower case month name (blank-padded to 9 chars)</entry>
-->
        <entry>小文字での完全な月名（9文字になるように空白文字を埋める）</entry>
       </row>
       <row>
        <entry><literal>MON</literal></entry>
<!--
        <entry>abbreviated upper case month name (3 chars in English, localized lengths vary)</entry>
-->
        <entry>大文字での短縮形の月名（英語では3文字、現地語化された場合は可変長）</entry>
       </row>
       <row>
        <entry><literal>Mon</literal></entry>
<!--
        <entry>abbreviated capitalized month name (3 chars in English, localized lengths vary)</entry>
-->
        <entry>大文字で書き始める短縮形の月名（英語では3文字。現地語化された場合は可変長）</entry>
       </row>
       <row>
        <entry><literal>mon</literal></entry>
<!--
        <entry>abbreviated lower case month name (3 chars in English, localized lengths vary)</entry>
-->
        <entry>小文字での短縮形の月名（英語では3文字。現地語化された場合は可変長）</entry>
       </row>
       <row>
        <entry><literal>MM</literal></entry>
<!--
        <entry>month number (01-12)</entry>
-->
        <entry>月番号（01〜12）</entry>
       </row>
       <row>
        <entry><literal>DAY</literal></entry>
<!--
        <entry>full upper case day name (blank-padded to 9 chars)</entry>
-->
        <entry>大文字での完全な曜日名（9文字になるように空白文字を埋める）</entry>
       </row>
       <row>
        <entry><literal>Day</literal></entry>
<!--
        <entry>full capitalized day name (blank-padded to 9 chars)</entry>
-->
        <entry>大文字で書き始める完全な曜日名（9文字になるように空白文字を埋める）</entry>
       </row>
       <row>
        <entry><literal>day</literal></entry>
<!--
        <entry>full lower case day name (blank-padded to 9 chars)</entry>
-->
        <entry>小文字での完全な曜日名（9文字になるように空白文字を埋める）</entry>
       </row>
       <row>
        <entry><literal>DY</literal></entry>
<!--
        <entry>abbreviated upper case day name (3 chars in English, localized lengths vary)</entry>
-->
        <entry>短縮形の大文字での短縮形の曜日名（英語では3文字。現地語化された場合は可変長）</entry>
       </row>
       <row>
        <entry><literal>Dy</literal></entry>
<!--
        <entry>abbreviated capitalized day name (3 chars in English, localized lengths vary)</entry>
-->
        <entry>大文字で書き始める短縮形の曜日名（英語では3文字。現地語化された場合は可変長）</entry>
       </row>
       <row>
        <entry><literal>dy</literal></entry>
<!--
        <entry>abbreviated lower case day name (3 chars in English, localized lengths vary)</entry>
-->
        <entry>小文字での短縮形の曜日名（英語では3文字。現地語化された場合は可変長）</entry>
       </row>
       <row>
        <entry><literal>DDD</literal></entry>
<!--
        <entry>day of year (001-366)</entry>
-->
        <entry>通年の日にち番号（001〜366）</entry>
       </row>
       <row>
        <entry><literal>IDDD</literal></entry>
<!--
        <entry>day of ISO 8601 week-numbering year (001-371; day 1 of the year is Monday of the first ISO week)</entry>
-->
        <entry>ISO 8601週番号年の日にち番号（001-371：通年 第１日は最初のISO週の月曜日）</entry>
       </row>
       <row>
        <entry><literal>DD</literal></entry>
<!--
        <entry>day of month (01-31)</entry>
-->
        <entry>月内の日にち番号（01〜31）</entry>
       </row>
       <row>
        <entry><literal>D</literal></entry>
<!--
        <entry>day of the week, Sunday (<literal>1</literal>) to Saturday (<literal>7</literal>)</entry>
-->
        <entry>曜日番号、日曜日（<literal>1</literal>）から土曜日（<literal>7</literal>）まで</entry>
       </row>
       <row>
        <entry><literal>ID</literal></entry>
<!--
        <entry>ISO 8601 day of the week, Monday (<literal>1</literal>) to Sunday (<literal>7</literal>)</entry>
-->
        <entry>ISO 8601の曜日番号、月曜日（<literal>1</literal>）から日曜日（<literal>7</literal>）まで</entry>
       </row>
       <row>
        <entry><literal>W</literal></entry>
<!--
        <entry>week of month (1-5) (the first week starts on the first day of the month)</entry>
-->
        <entry>月中の週番号（1〜5）（その月の初日がある週が第1週）</entry>
       </row>
       <row>
        <entry><literal>WW</literal></entry>
<!--
        <entry>week number of year (1-53) (the first week starts on the first day of the year)</entry>
-->
        <entry>年間を通じた週番号（1〜53）（元日のある週が第1週）</entry>
       </row>
       <row>
        <entry><literal>IW</literal></entry>
<!--
        <entry>week number of ISO 8601 week-numbering year (01-53; the first Thursday of the year is in week 1)</entry>
-->
        <entry>ISO 8601週番号年の年間を通じた週番号（01 - 53：新年の最初の木曜日がある週が第1週）</entry>
       </row>
       <row>
        <entry><literal>CC</literal></entry>
<!--
        <entry>century (2 digits) (the twenty-first century starts on 2001-01-01)</entry>
-->
        <entry>世紀（2桁。21世紀は2001-01-01から開始）</entry>
       </row>
       <row>
        <entry><literal>J</literal></entry>
<!--
        <entry>Julian Day (integer days since November 24, 4714 BC at midnight UTC)</entry>
-->
        <entry>ユリウス日（UTC紀元前4714年11月24日午前零時からの整数による通算経過日）</entry>
       </row>
       <row>
        <entry><literal>Q</literal></entry>
<!--
        <entry>quarter</entry>
-->
        <entry>四半期</entry>
       </row>
       <row>
        <entry><literal>RM</literal></entry>
<!--
        <entry>month in upper case Roman numerals (I-XII; I=January)</entry>
-->
        <entry>大文字ローマ数字による月（I〜XII、Iは1月）</entry>
       </row>
       <row>
        <entry><literal>rm</literal></entry>
<!--
        <entry>month in lower case Roman numerals (i-xii; i=January)</entry>
-->
        <entry>小文字ローマ数字による月（i〜xii、iは1月）</entry>
       </row>
       <row>
        <entry><literal>TZ</literal></entry>
<!--
        <entry>upper case time-zone abbreviation
         (only supported in <function>to_char</function>)</entry>
-->
        <entry>大文字による時間帯省略名（<function>to_char</function>内でのみサポートされる）</entry>
       </row>
       <row>
        <entry><literal>tz</literal></entry>
<!--
        <entry>lower case time-zone abbreviation
         (only supported in <function>to_char</function>)</entry>
-->
        <entry>小文字による時間帯省略名（<function>to_char</function>内でのみサポートされる）</entry>
       </row>
       <row>
       <entry><literal>TZH</literal></entry>
<!--
        <entry>time-zone hours</entry>
-->
        <entry>time-zoneの時間</entry>
       </row>
       <row>
       <entry><literal>TZM</literal></entry>
<!--
        <entry>time-zone minutes</entry>
-->
        <entry>time-zoneの分</entry>
       </row>
       <row>
        <entry><literal>OF</literal></entry>
<!--
        <entry>time-zone offset from UTC
         (only supported in <function>to_char</function>)</entry>
-->
        <entry>UTCからの時間帯オフセット（<function>to_char</function>内でのみサポートされる）</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
<!--
    Modifiers can be applied to any template pattern to alter its
    behavior.  For example, <literal>FMMonth</literal>
    is the <literal>Month</literal> pattern with the
    <literal>FM</literal> modifier.
    <xref linkend="functions-formatting-datetimemod-table"/> shows the
    modifier patterns for date/time formatting.
-->
どのようなテンプレートパターンに対しても、その振舞いを変更するために修飾子を適用できます。
例えば、<literal>FMMonth</literal>は<literal>FM</literal>修飾子の付いた<literal>Month</literal>パターンです。
<xref linkend="functions-formatting-datetimemod-table"/>に、日付/時刻書式の修飾子パターンを示します。
   </para>

    <table id="functions-formatting-datetimemod-table">
<!--
     <title>Template Pattern Modifiers for Date/Time Formatting</title>
-->
     <title>日付/時刻書式用のテンプレートパターン修飾子</title>
     <tgroup cols="3">
      <thead>
       <row>
<!--
        <entry>Modifier</entry>
        <entry>Description</entry>
        <entry>Example</entry>
-->
        <entry>修飾子</entry>
        <entry>説明</entry>
        <entry>例</entry>
       </row>
      </thead>
      <tbody>
       <row>
<!--
        <entry><literal>FM</literal> prefix</entry>
-->
        <entry><literal>FM</literal>接頭辞</entry>
<!--
        <entry>fill mode (suppress leading zeroes and padding blanks)</entry>
-->
        <entry>字詰めモード（先頭の0、およびを空白のパディングを無効）</entry>
        <entry><literal>FMMonth</literal></entry>
       </row>
       <row>
<!--
        <entry><literal>TH</literal> suffix</entry>
-->
        <entry><literal>TH</literal>接尾辞</entry>
<!--
        <entry>upper case ordinal number suffix</entry>
        <entry><literal>DDTH</literal>, e.g., <literal>12TH</literal></entry>
-->
        <entry><literal>DDTH</literal>、例えば<literal>12TH</literal></entry>
       </row>
       <row>
<!--
        <entry><literal>th</literal> suffix</entry>
-->
        <entry><literal>th</literal>接尾辞</entry>
<!--
        <entry>lower case ordinal number suffix</entry>
        <entry><literal>DDth</literal>, e.g., <literal>12th</literal></entry>
-->
        <entry><literal>DDth</literal>、例えば<literal>12th</literal></entry>
       </row>
       <row>
<!--
        <entry><literal>FX</literal> prefix</entry>
-->
        <entry><literal>FX</literal>接頭辞</entry>
<!--
        <entry>fixed format global option (see usage notes)</entry>
-->
        <entry>固定書式のグローバルオプション（使用上の注意事項を参照）</entry>
        <entry><literal>FX&nbsp;Month&nbsp;DD&nbsp;Day</literal></entry>
       </row>
       <row>
<!--
        <entry><literal>TM</literal> prefix</entry>
-->
        <entry><literal>TM</literal>接頭辞</entry>
<!--
        <entry>translation mode (print localized day and month names based on
         <xref linkend="guc-lc-time"/>)</entry>
-->
        <entry>翻訳モード（<xref linkend="guc-lc-time"/>に基づき、現地語化された曜日、月名を表示します)</entry>
        <entry><literal>TMMonth</literal></entry>
       </row>
       <row>
<!--
        <entry><literal>SP</literal> suffix</entry>
-->
        <entry><literal>SP</literal>接尾辞</entry>
<!--
        <entry>spell mode (not implemented)</entry>
-->
        <entry>スペルモード（未実装）</entry>
        <entry><literal>DDSP</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
<!--
    Usage notes for date/time formatting:
-->
日付/時刻型書式の使用上の注意事項は次のとおりです。

    <itemizedlist>
     <listitem>
      <para>
<!--
       <literal>FM</literal> suppresses leading zeroes and trailing blanks
       that would otherwise be added to make the output of a pattern be
       fixed-width.  In <productname>PostgreSQL</productname>,
       <literal>FM</literal> modifies only the next specification, while in
       Oracle <literal>FM</literal> affects all subsequent
       specifications, and repeated <literal>FM</literal> modifiers
       toggle fill mode on and off.
-->
<literal>FM</literal>は、先頭にはゼロ、末尾には空白を追加してパターンを固定長にする機能を無効にします。
<productname>PostgreSQL</productname>では、<literal>FM</literal>はその次に記述されたものだけを変更します。一方Oracleでは、<literal>FM</literal>はそれに続く全ての記述に対して影響し、<literal>FM</literal>修飾詞を繰り返すと、ゼロや空白を埋めるモードのオンとオフが切り替わります。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       <literal>TM</literal> does not include trailing blanks.
       <function>to_timestamp</function> and <function>to_date</function> ignore
       the <literal>TM</literal> modifier.
-->
<literal>TM</literal>には末尾の空白は含まれません。
<function>to_timestamp</function>と<function>to_date</function>は<literal>TM</literal>修飾詞を無視します。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       <function>to_timestamp</function> and <function>to_date</function>
       skip multiple blank spaces at the beginning of the input string and
       around date and time values unless the <literal>FX</literal> option is used.  For example,
       <literal>to_timestamp('&nbsp;2000&nbsp;&nbsp;&nbsp;&nbsp;JUN', 'YYYY MON')</literal> and
       <literal>to_timestamp('2000 - JUN', 'YYYY-MON')</literal> work, but
       <literal>to_timestamp('2000&nbsp;&nbsp;&nbsp;&nbsp;JUN', 'FXYYYY MON')</literal> returns an error
       because <function>to_timestamp</function> expects only a single space.
       <literal>FX</literal> must be specified as the first item in
       the template.
-->
<literal>FX</literal>オプションが使用されていない限り、<function>to_timestamp</function>と<function>to_date</function>は入力文字列内最初の連続した空白と、日付と時間の値の周辺の複数の空白を無視します。
例えば、<literal>to_timestamp('2000&nbsp;&nbsp;&nbsp;&nbsp;JUN', 'YYYY MON')</literal>と<literal>to_timestamp('2000 - JUN', 'YYYY-MON')</literal>は動作しますが、<literal>to_timestamp('2000&nbsp;&nbsp;&nbsp;&nbsp;JUN','FXYYYY MON')</literal>はエラーを返します。
後者の<function>to_timestamp</function>は単一のスペースだけがあることを期待するからです。
<literal>FX</literal>はテンプレートの第1項目として指定される必要があります。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       A separator (a space or non-letter/non-digit character) in the template string of
       <function>to_timestamp</function> and <function>to_date</function>
       matches any single separator in the input string or is skipped,
       unless the <literal>FX</literal> option is used.
       For example, <literal>to_timestamp('2000JUN', 'YYYY///MON')</literal> and
       <literal>to_timestamp('2000/JUN', 'YYYY MON')</literal> work, but
       <literal>to_timestamp('2000//JUN', 'YYYY/MON')</literal>
       returns an error because the number of separators in the input string
       exceeds the number of separators in the template.
-->
<literal>FX</literal>オプションが使用されていない限り、<function>to_timestamp</function>と<function>to_date</function>のテンプレート文字列中の区切り文字（空白あるいは記号文字(訳注：原文は"non-letter/non-digit character"））は入力文字中のすべての単一の区切り文字とマッチするか、あるいはマッチしない場合はスキップします。
たとえば、<literal>to_timestamp('2000JUN', 'YYYY///MON')</literal>と<literal>to_timestamp('2000/JUN', 'YYYY MON')</literal>は動作しますが、<literal>to_timestamp('2000//JUN', 'YYYY/MON')</literal>は入力文字列中の区切り文字の数がテンプレート中の区切り文字の数を上回っているため、エラーを返します。
      </para>
      <para>
<!--
       If <literal>FX</literal> is specified, a separator in the template string
       matches exactly one character in the input string.  But note that the
       input string character is not required to be the same as the separator from the template string.
       For example, <literal>to_timestamp('2000/JUN', 'FXYYYY MON')</literal>
       works, but <literal>to_timestamp('2000/JUN', 'FXYYYY&nbsp;&nbsp;MON')</literal>
       returns an error because the second space in the template string consumes
       the letter <literal>J</literal> from the input string.
-->
<literal>FX</literal>が指定されていると、テンプレート文字列中の区切り文字は正確に入力文字列中の一文字とマッチします。
しかし、入力文字列の文字はテンプレート文字列中の区切り文字と一致する必要はないことに注意してください。
たとえば、<literal>to_timestamp('2000/JUN', 'FXYYYY MON')</literal>は動作しますが、<literal>to_timestamp('2000/JUN', 'FXYYYY&nbsp;&nbsp;MON')</literal>はテンプレート文字列中の二番目の空白が入力文字列中の文字<literal>J</literal>を消費するため、エラーを返します。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       A <literal>TZH</literal> template pattern can match a signed number.
       Without the <literal>FX</literal> option, minus signs may be ambiguous,
       and could be interpreted as a separator.
       This ambiguity is resolved as follows:  If the number of separators before
       <literal>TZH</literal> in the template string is less than the number of
       separators before the minus sign in the input string, the minus sign
       is interpreted as part of <literal>TZH</literal>.
       Otherwise, the minus sign is considered to be a separator between values.
       For example, <literal>to_timestamp('2000 -10', 'YYYY TZH')</literal> matches
       <literal>-10</literal> to <literal>TZH</literal>, but
       <literal>to_timestamp('2000 -10', 'YYYY&nbsp;&nbsp;TZH')</literal>
       matches <literal>10</literal> to <literal>TZH</literal>.
-->
<literal>TZH</literal>テンプレートパターンは符号付きの数字とマッチします。
<literal>FX</literal>オプションが無い場合、マイナス符号は曖昧で、区切り文字として解釈されるかも知れません。
この曖昧さは次のようにして解消されます。
テンプレート文字列中の<literal>TZH</literal>の前の区切り文字の数が入力文字列中のマイナス符号の前の区切り文字の数よりも少なければ、そのマイナス符号は<literal>TZH</literal>の一部として解釈されます。
そうでない場合、マイナス記号が値の区切り記号と見なされます。
たとえば、<literal>to_timestamp('2000 -10', 'YYYY TZH')</literal>では<literal>-10</literal>が<literal>TZH</literal>にマッチしますが、<literal>to_timestamp('2000 -10', 'YYYY&nbsp;&nbsp;TZH')</literal>では<literal>10</literal>が<literal>TZH</literal>にマッチします。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       Ordinary text is allowed in <function>to_char</function>
       templates and will be output literally.  You can put a substring
       in double quotes to force it to be interpreted as literal text
       even if it contains template patterns.  For example, in
       <literal>'"Hello Year "YYYY'</literal>, the <literal>YYYY</literal>
       will be replaced by the year data, but the single <literal>Y</literal> in <literal>Year</literal>
       will not be.
       In <function>to_date</function>, <function>to_number</function>,
       and <function>to_timestamp</function>, literal text and double-quoted
       strings result in skipping the number of characters contained in the
       string; for example <literal>"XX"</literal> skips two input characters
       (whether or not they are <literal>XX</literal>).
-->
<function>to_char</function>テンプレートには、通常のテキストを入れることができ、それはそのまま出力されます。
部分文字列を二重引用符で括ることで、部分文字列にテンプレートパターンがあったとしても、強制的にリテラルテキストとして解釈させることができます。
例えば、<literal>'"Hello Year "YYYY'</literal>では<literal>YYYY</literal>は年データに置換されてしまいますが、<literal>Year</literal>内の<literal>Y</literal>は置換されません。
<function>to_date</function>、<function>to_number</function>、<function>to_timestamp</function>では、二重引用符で括られた文字の数だけ入力された文字をスキップします。例えば<literal>"XX"</literal>は2文字の入力文字（それが<literal>XX</literal>であるかどうかにかかわらず)をスキップします。
      </para>
      <tip>
        <para>
<!--
          Prior to <productname>PostgreSQL</productname> 12, it was possible to
          skip arbitrary text in the input string using non-letter or non-digit
          characters. For example,
          <literal>to_timestamp('2000y6m1d', 'yyyy-MM-DD')</literal> used to
          work.  Now you can only use letter characters for this purpose.  For example,
          <literal>to_timestamp('2000y6m1d', 'yyyytMMtDDt')</literal> and
          <literal>to_timestamp('2000y6m1d', 'yyyy"y"MM"m"DD"d"')</literal>
          skip <literal>y</literal>, <literal>m</literal>, and
          <literal>d</literal>.
-->
<productname>PostgreSQL</productname> 12より前では、記号文字（訳注：原文は"non-letter or non-digit"）を使って入力文字列中の任意のテキストをスキップすることが可能でした。
たとえば、<literal>to_timestamp('2000y6m1d', 'yyyy-MM-DD')</literal>は動作しました。
現在は、この目的のために非記号文字（訳注：原文は"letter characters"）だけを使うことができます。
たとえば、<literal>to_timestamp('2000y6m1d', 'yyyytMMtDDt')</literal>と<literal>to_timestamp('2000y6m1d', 'yyyy"y"MM"m"DD"d"')</literal>は、<literal>y</literal>、<literal>m</literal>、<literal>d</literal>をスキップします。
        </para>
      </tip>
     </listitem>

     <listitem>
      <para>
<!--
       If you want to have a double quote in the output you must
       precede it with a backslash, for example <literal>'\"YYYY
       Month\"'</literal>. <!&#045;&#045; 原文コメント "" font-lock sanity :-) &#045;&#045;>
       Backslashes are not otherwise special outside of double-quoted
       strings.  Within a double-quoted string, a backslash causes the
       next character to be taken literally, whatever it is (but this
       has no special effect unless the next character is a double quote
       or another backslash).
-->
出力に二重引用符を付けたい場合、<literal>'\"YYYY Month\"'</literal>のようにその前にバックスラッシュを付けなければなりません。
バックスラッシュは、二重引用符の外側では特別扱いされません。
二重引用符の内側では、バックスラッシュによって次の文字が何であれ文字通りに扱われるようになります。
（しかし、次の文字が二重引用符であるか、あるいは別のバックスラッシュでない限り、これは特別な効果をもたらしません。）
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       In <function>to_timestamp</function> and <function>to_date</function>,
       if the year format specification is less than four digits, e.g.
       <literal>YYY</literal>, and the supplied year is less than four digits,
       the year will be adjusted to be nearest to the year 2020, e.g.
       <literal>95</literal> becomes 1995.
-->
<function>to_timestamp</function>において<function>to_date</function>、<literal>YYY</literal>の様に4桁未満の年書式が指定され、かつ与えられる年が4桁未満だった場合、年は2020年に最も近くなるよう調整されます。例えば、<literal>95</literal>の場合は1995年になります。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       In <function>to_timestamp</function> and <function>to_date</function>,
       the <literal>YYYY</literal> conversion has a restriction when
       processing years with more than 4 digits. You must
       use some non-digit character or template after <literal>YYYY</literal>,
       otherwise the year is always interpreted as 4 digits. For example
       (with the year 20000):
       <literal>to_date('200001131', 'YYYYMMDD')</literal> will be
       interpreted as a 4-digit year; instead use a non-digit
       separator after the year, like
       <literal>to_date('20000-1131', 'YYYY-MMDD')</literal> or
       <literal>to_date('20000Nov31', 'YYYYMonDD')</literal>.
-->
<function>to_timestamp</function>および<function>to_date</function>において<literal>YYYY</literal>変換は、5桁以上の年数値を処理するときに制限事項があります。
このような場合、<literal>YYYY</literal>の後に数字以外の文字またはテンプレートを使わなければなりません。 そうしないと年は常に4桁と解釈されます。
例えば（20000年として）、<literal>to_date('200001131', 'YYYYMMDD')</literal>は4桁の年と解釈されるので、代わりに<literal>to_date('20000-1131', 'YYYY-MMDD')</literal>または<literal>to_date('20000Nov31', 'YYYYMonDD')</literal>のように数字でない区切り文字を使用してください。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       In <function>to_timestamp</function> and <function>to_date</function>,
       the <literal>CC</literal> (century) field is accepted but ignored
       if there is a <literal>YYY</literal>, <literal>YYYY</literal> or
       <literal>Y,YYY</literal> field. If <literal>CC</literal> is used with
       <literal>YY</literal> or <literal>Y</literal> then the result is
       computed as that year in the specified century.  If the century is
       specified but the year is not, the first year of the century
       is assumed.
-->
<function>to_timestamp</function>および<function>to_date</function>において<literal>YYY</literal>、<literal>YYYY</literal>、もしくは<literal>Y,YYY</literal>フィールドが存在すると<literal>CC</literal>（世紀）フィールドは受け入れられますが、無視されます。
<literal>CC</literal>が<literal>YY</literal>もしくは<literal>Y</literal>と共に使用されると、結果は指定された世紀のその年として計算されます。
世紀が指定され、年が指定されないときは、その世紀の最初の年と想定されます。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       In <function>to_timestamp</function> and <function>to_date</function>,
       weekday names or numbers (<literal>DAY</literal>, <literal>D</literal>,
       and related field types) are accepted but are ignored for purposes of
       computing the result.  The same is true for quarter
       (<literal>Q</literal>) fields.
-->
<function>to_timestamp</function>および<function>to_date</function>において、曜日の名前や数字（<literal>DAY</literal>、<literal>D</literal>および関連したフィールドの型）は受け付けられますが、結果を計算するという目的においては無視されます。
同じことは四半期（<literal>Q</literal>）フィールドにも当てはまります。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       In <function>to_timestamp</function> and <function>to_date</function>,
       an ISO 8601 week-numbering date (as distinct from a Gregorian date)
       can be specified in one of two ways:
-->
<function>to_timestamp</function>および<function>to_date</function>において、
ISO 8601週番号日は（グレゴリオ暦の日付とは異なって）以下の２つの方法のうちのひとつで指定できます。
       <itemizedlist>
        <listitem>
         <para>
<!--
          Year, week number, and weekday:  for
          example <literal>to_date('2006-42-4', 'IYYY-IW-ID')</literal>
          returns the date <literal>2006-10-19</literal>.
          If you omit the weekday it is assumed to be 1 (Monday).
-->
年、通年の週番号、曜日番号。
例えば、<literal>to_date('2006-42-4', 'IYYY-IW-ID')</literal>は、日付<literal>2006-10-19</literal>を返します。
曜日番号を省略した場合、1（月曜日）と想定されます。
         </para>
        </listitem>
        <listitem>
         <para>
<!--
          Year and day of year:  for example <literal>to_date('2006-291',
          'IYYY-IDDD')</literal> also returns <literal>2006-10-19</literal>.
-->
年と通年の日付番号。例えば、<literal>to_date('2006-291', 'IYYY-IDDD')</literal>も<literal>2006-10-19</literal>を返します。
         </para>
        </listitem>
       </itemizedlist>
      </para>
      <para>
<!--
       Attempting to enter a date using a mixture of ISO 8601 week-numbering
       fields and Gregorian date fields is nonsensical, and will cause an
       error.  In the context of an ISO 8601 week-numbering year, the
       concept of a <quote>month</quote> or <quote>day of month</quote> has no
       meaning.  In the context of a Gregorian year, the ISO week has no
       meaning.
-->
ISO 8601週番号とグレゴリオ暦日のフィールドを混在して使用して日付を構築する試みは無意味なことで、エラーの原因になります。
ISO 8601週番号年の文脈では、<quote>月</quote>、あるいは<quote>月内の日付番号</quote>は意味を持ちません。
グレゴリオ暦の年の文脈では、ISO週番号は意味を持ちません。
      </para>
      <caution>
       <para>
<!--
        While <function>to_date</function> will reject a mixture of
        Gregorian and ISO week-numbering date
        fields, <function>to_char</function> will not, since output format
        specifications like <literal>YYYY-MM-DD (IYYY-IDDD)</literal> can be
        useful.  But avoid writing something like <literal>IYYY-MM-DD</literal>;
        that would yield surprising results near the start of the year.
        (See <xref linkend="functions-datetime-extract"/> for more
        information.)
-->
<function>to_date</function>はグレゴリオとISO週番号日のフィールドの混在を拒否しますが、<function>to_char</function>はそうではありません。<literal>YYYY-MM-DD (IYYY-IDDD)</literal>のような出力書式指定が有用な場合があるからです。
しかし、<literal>IYYY-MM-DD</literal>のような書き方は避けてください。年の初めの近くで驚くべき結果になるでしょう。
(より詳細な情報は<xref linkend="functions-datetime-extract"/>を参照してください。)
       </para>
      </caution>
     </listitem>

     <listitem>
      <para>
<!--
       In <function>to_timestamp</function>, millisecond
       (<literal>MS</literal>) or microsecond (<literal>US</literal>)
       fields are used as the
       seconds digits after the decimal point. For example
       <literal>to_timestamp('12.3', 'SS.MS')</literal> is not 3 milliseconds,
       but 300, because the conversion treats it as 12 + 0.3 seconds.
       So, for the format <literal>SS.MS</literal>, the input values
       <literal>12.3</literal>, <literal>12.30</literal>,
       and <literal>12.300</literal> specify the
       same number of milliseconds. To get three milliseconds, one must write
       <literal>12.003</literal>, which the conversion treats as
       12 + 0.003 = 12.003 seconds.
-->
<function>to_timestamp</function>において、ミリ秒（<literal>MS</literal>）およびマイクロ秒（<literal>US</literal>）フィールドは小数点の後の秒の桁として使用されます。
例えば、<literal>to_timestamp('12.3', 'SS.MS')</literal>は3ミリ秒ではなく300ミリ秒です。なぜなら変換においてこれは12 + 0.3秒と計算されるからです。
従って<literal>SS.MS</literal>書式に対して入力値<literal>12.3</literal>、<literal>12.30</literal>、<literal>12.300</literal>は同じミリ秒数を指定することになります。
3ミリ秒が必要な場合には<literal>12:003</literal>のようにしなければなりません。この時、変換において12 + 0.003 = 12.003秒と計算します。
      </para>

      <para>
<!--
       Here is a more
       complex example:
       <literal>to_timestamp('15:12:02.020.001230', 'HH24:MI:SS.MS.US')</literal>
       is 15 hours, 12 minutes, and 2 seconds + 20 milliseconds +
       1230 microseconds = 2.021230 seconds.
-->
もう少し複雑な例を挙げます。
<literal>to_timestamp('15:12:02.020.001230','HH:MI:SS.MS.US')</literal>は15時間12分と2秒+20ミリ秒+1230マイクロ秒 = 2.021230秒です。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
        <function>to_char(..., 'ID')</function>'s day of the week numbering
        matches the <function>extract(isodow from ...)</function> function, but
        <function>to_char(..., 'D')</function>'s does not match
        <function>extract(dow from ...)</function>'s day numbering.
-->
<function>to_char(..., 'ID')</function>の曜日番号付けは<function>extract(isodow from ...)</function>関数に一致しますが、<function>to_char(..., 'D')</function>の曜日番号付けは<function>extract(dow from ...)</function>の曜日番号付けに一致しません。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
        <function>to_char(interval)</function> formats <literal>HH</literal> and
        <literal>HH12</literal> as shown on a 12-hour clock, for example zero hours
        and 36 hours both output as <literal>12</literal>, while <literal>HH24</literal>
        outputs the full hour value, which can exceed 23 in
        an <type>interval</type> value.
-->
<function>to_char(interval)</function>関数は、<literal>HH</literal>と<literal>HH12</literal>を12時間の時計に表示されるように整形します。
例えば0時間と36時間はいずれも<literal>12</literal>として出力します。
一方<literal>HH24</literal>は時間の値をそのまま出力し、<type>interval</type>の値であれば23を超えることも可能です。
      </para>
     </listitem>

    </itemizedlist>
   </para>

  <para>
<!--
   <xref linkend="functions-formatting-numeric-table"/> shows the
   template patterns available for formatting numeric values.
-->
<xref linkend="functions-formatting-numeric-table"/>に、数値の書式設定に使用可能なテンプレートパターンを示します。
  </para>

    <table id="functions-formatting-numeric-table">
<!--
     <title>Template Patterns for Numeric Formatting</title>
-->
     <title>数値書式用のテンプレートパターン</title>
     <tgroup cols="2">
      <thead>
       <row>
<!--
        <entry>Pattern</entry>
        <entry>Description</entry>
-->
        <entry>パターン</entry>
        <entry>説明</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><literal>9</literal></entry>
<!--
        <entry>digit position (can be dropped if insignificant)</entry>
-->
        <entry>数字の位置（必要ないときは表示しない）</entry>
       </row>
       <row>
        <entry><literal>0</literal></entry>
<!--
        <entry>digit position (will not be dropped, even if insignificant)</entry>
-->
        <entry>数字の位置（必要ないときでも表示する）</entry>
       </row>
       <row>
<!--
        <entry><literal>.</literal> (period)</entry>
        <entry>decimal point</entry>
-->
        <entry><literal>.</literal>（ピリオド）</entry>
        <entry>小数点</entry>
       </row>
       <row>
<!--
        <entry><literal>,</literal> (comma)</entry>
        <entry>group (thousands) separator</entry>
-->
        <entry><literal>,</literal> (コンマ)</entry>
        <entry>千単位で区切る符号</entry>
       </row>
       <row>
        <entry><literal>PR</literal></entry>
<!--
        <entry>negative value in angle brackets</entry>
-->
        <entry>負の値の角括弧表示</entry>
       </row>
       <row>
        <entry><literal>S</literal></entry>
<!--
        <entry>sign anchored to number (uses locale)</entry>
-->
        <entry>符号付き値（ロケールを使用）</entry>
       </row>
       <row>
        <entry><literal>L</literal></entry>
<!--
        <entry>currency symbol (uses locale)</entry>
-->
        <entry>通貨記号（ロケールを使用）</entry>
       </row>
       <row>
        <entry><literal>D</literal></entry>
<!--
        <entry>decimal point (uses locale)</entry>
-->
        <entry>小数点（ロケールを使用）</entry>
       </row>
       <row>
        <entry><literal>G</literal></entry>
<!--
        <entry>group separator (uses locale)</entry>
-->
        <entry>グループ区切り文字（ロケールを使用）</entry>
       </row>
       <row>
        <entry><literal>MI</literal></entry>
<!--
        <entry>minus sign in specified position (if number &lt; 0)</entry>
-->
        <entry>（数値 &lt; 0であれば）指定位置にマイナス記号</entry>
       </row>
       <row>
        <entry><literal>PL</literal></entry>
<!--
        <entry>plus sign in specified position (if number &gt; 0)</entry>
-->
        <entry>（数値 &gt; 0であれば）指定位置にプラス記号</entry>
       </row>
       <row>
        <entry><literal>SG</literal></entry>
<!--
        <entry>plus/minus sign in specified position</entry>
-->
        <entry>指定された位置にプラス/マイナス記号</entry>
       </row>
       <row>
        <entry><literal>RN</literal></entry>
<!--
        <entry>Roman numeral (input between 1 and 3999)</entry>
-->
        <entry>ローマ数字（入力は1～3999）</entry>
       </row>
       <row>
<!--
        <entry><literal>TH</literal> or <literal>th</literal></entry>
        <entry>ordinal number suffix</entry>
-->
        <entry><literal>TH</literal>または<literal>th</literal></entry>
        <entry>序数接尾辞</entry>
       </row>
       <row>
        <entry><literal>V</literal></entry>
<!--
        <entry>shift specified number of digits (see notes)</entry>
-->
        <entry><replaceable>n</replaceable> 桁シフト（注意事項を参照）</entry>
       </row>
       <row>
        <entry><literal>EEEE</literal></entry>
<!--
        <entry>exponent for scientific notation</entry>
-->
        <entry>科学技術表記法用の指数</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
<!--
    Usage notes for numeric formatting:
-->
数値型書式の使用上の注意事項は次のとおりです。

    <itemizedlist>
     <listitem>
      <para>
<!--
       <literal>0</literal> specifies a digit position that will always be printed,
       even if it contains a leading/trailing zero.  <literal>9</literal> also
       specifies a digit position, but if it is a leading zero then it will
       be replaced by a space, while if it is a trailing zero and fill mode
       is specified then it will be deleted.  (For <function>to_number()</function>,
       these two pattern characters are equivalent.)
-->
<literal>0</literal>は、それが先頭あるいは末尾のゼロであっても必ず表示する数字の位置を指定します。
<literal>9</literal>も数字の位置を指定しますが、先頭のゼロであればそれは空白で置換され、また末尾のゼロで字詰めモードが指定されているときは削除されます。
（<function>to_number()</function>では、これら2つのパターン文字は同じ意味になります。）
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       The pattern characters <literal>S</literal>, <literal>L</literal>, <literal>D</literal>,
       and <literal>G</literal> represent the sign, currency symbol, decimal point,
       and thousands separator characters defined by the current locale
       (see <xref linkend="guc-lc-monetary"/>
       and <xref linkend="guc-lc-numeric"/>).  The pattern characters period
       and comma represent those exact characters, with the meanings of
       decimal point and thousands separator, regardless of locale.
-->
パターン文字<literal>S</literal>、<literal>L</literal>、<literal>D</literal>、<literal>G</literal>はそれぞれ現在のロケールで定義された符号、通貨記号、小数点、3桁区切り文字を表します（<xref linkend="guc-lc-monetary"/>および<xref linkend="guc-lc-numeric"/>を参照）。
パターン文字のピリオドとカンマはいずれもその文字そのものを表し、ロケールとは関係なく小数点と3桁区切り文字の意味を持ちます。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       If no explicit provision is made for a sign
       in <function>to_char()</function>'s pattern, one column will be reserved for
       the sign, and it will be anchored to (appear just left of) the
       number.  If <literal>S</literal> appears just left of some <literal>9</literal>'s,
       it will likewise be anchored to the number.
-->
<function>to_char()</function>のパターンで符号について明示的な条件付けがない場合、符号のために一桁が予約され、それは数に繋げられます（すぐ左側に置かれます）。
<literal>S</literal>がいくつかの<literal>9</literal>のすぐ左に置かれた場合、同様に数に繋げられます。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       A sign formatted using <literal>SG</literal>, <literal>PL</literal>, or
       <literal>MI</literal> is not anchored to
       the number; for example,
       <literal>to_char(-12, 'MI9999')</literal> produces <literal>'-&nbsp;&nbsp;12'</literal>
       but <literal>to_char(-12, 'S9999')</literal> produces <literal>'&nbsp;&nbsp;-12'</literal>.
       (The Oracle implementation does not allow the use of
       <literal>MI</literal> before <literal>9</literal>, but rather
       requires that <literal>9</literal> precede
       <literal>MI</literal>.)
-->
<literal>SG</literal>、<literal>PL</literal>、または<literal>MI</literal>で整形された符号は、数値と関連付けられません。
例えば、<literal>to_char(-12, 'MI9999')</literal>は<literal>'-&nbsp;&nbsp;12'</literal>となる一方、<literal>to_char(-12, 'S9999')</literal>は<literal>'&nbsp;&nbsp;-12'</literal>となります。
（Oracleの実装では<literal>9</literal>の前に<literal>MI</literal>が置かれてはならず、<literal>9</literal>の後に<literal>MI</literal>が置かれることを要求しています。）
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       <literal>TH</literal> does not convert values less than zero
       and does not convert fractional numbers.
-->
<literal>TH</literal>はゼロ未満の値と小数は変換しません
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       <literal>PL</literal>, <literal>SG</literal>, and
       <literal>TH</literal> are <productname>PostgreSQL</productname>
       extensions.
-->
<literal>PL</literal>、<literal>SG</literal>、および<literal>TH</literal>は<productname>PostgreSQL</productname>の拡張です。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       In <function>to_number</function>, if non-data template patterns such
       as <literal>L</literal> or <literal>TH</literal> are used, the
       corresponding number of input characters are skipped, whether or not
       they match the template pattern, unless they are data characters
       (that is, digits, sign, decimal point, or comma).  For
       example, <literal>TH</literal> would skip two non-data characters.
-->
<function>to_number</function>において、<literal>L</literal>あるいは<literal>TH</literal>のように非データテンプレートが使われた場合には、それがデータ文字（すなわち、数字、符号、10進小数点あるいはカンマ）でない限りテンプレートパターンにマッチするかどうかにかかわらず、該当する数分だけの入力文字がスキップされます。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       <literal>V</literal> with <function>to_char</function>
       multiplies the input values by
       <literal>10^<replaceable>n</replaceable></literal>, where
       <replaceable>n</replaceable> is the number of digits following
       <literal>V</literal>.  <literal>V</literal> with
       <function>to_number</function> divides in a similar manner.
       <function>to_char</function> and <function>to_number</function>
       do not support the use of
       <literal>V</literal> combined with a decimal point
       (e.g., <literal>99.9V99</literal> is not allowed).
-->
<literal>V</literal>を<function>to_char</function>につけると、入力値を<literal>10^<replaceable>n</replaceable></literal>倍します。
ここで<replaceable>n</replaceable>は<literal>V</literal>に続く桁数です。
<literal>V</literal>を<function>to_number</function>につけると、同じように割り算をします。
<function>to_char</function>および<function>to_number</function>は、小数点と<literal>V</literal>との混在をサポートしません（例えば、<literal>99.9V99</literal> とはできません）。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       <literal>EEEE</literal> (scientific notation) cannot be used in
       combination with any of the other formatting patterns or
       modifiers other than digit and decimal point patterns, and must be at the end of the format string
       (e.g., <literal>9.99EEEE</literal> is a valid pattern).
-->
<literal>EEEE</literal>(科学技術表記)は、桁と小数点のパターンを除き、他の書式パターンや修飾子と組み合わせて使うことはできず、また必ず書式文字列の最後に位置しなければなりません(例えば、<literal>9.99EEEE</literal>は正しい表記となります)。
      </para>
     </listitem>
    </itemizedlist>
   </para>

   <para>
<!--
    Certain modifiers can be applied to any template pattern to alter its
    behavior.  For example, <literal>FM99.99</literal>
    is the <literal>99.99</literal> pattern with the
    <literal>FM</literal> modifier.
    <xref linkend="functions-formatting-numericmod-table"/> shows the
    modifier patterns for numeric formatting.
-->
すべてのテンプレートについて、その動作を変えるために、いくつかの修飾子を適用できます。
例えば、<literal>FM99.99</literal>は<literal>FM</literal>修飾子が付いた<literal>99.99</literal>パターンです。
<xref linkend="functions-formatting-numericmod-table"/>に、数値の書式用の修飾子パターンを示します。
   </para>

    <table id="functions-formatting-numericmod-table">
<!--
     <title>Template Pattern Modifiers for Numeric Formatting</title>
-->
     <title>数値の書式用テンプレートパターン修飾子</title>
     <tgroup cols="3">
      <thead>
       <row>
<!--
        <entry>Modifier</entry>
        <entry>Description</entry>
        <entry>Example</entry>
-->
        <entry>修飾子</entry>
        <entry>説明</entry>
        <entry>例</entry>
       </row>
      </thead>
      <tbody>
       <row>
<!--
        <entry><literal>FM</literal> prefix</entry>
-->
        <entry><literal>FM</literal>添え字</entry>
<!--
        <entry>fill mode (suppress trailing zeroes and padding blanks)</entry>
        <entry><literal>FM99.99</literal></entry>
-->
        <entry>字詰めモード（末尾の0と空白の埋め字を無効にする）</entry>
        <entry><literal>FM99.99</literal></entry>
       </row>
       <row>
<!--
        <entry><literal>TH</literal> suffix</entry>
-->
        <entry><literal>TH</literal>添え字</entry>
<!--
        <entry>upper case ordinal number suffix</entry>
-->
        <entry>大文字による序数添え字</entry>
        <entry><literal>999TH</literal></entry>
       </row>
       <row>
<!--
        <entry><literal>th</literal> suffix</entry>
-->
        <entry><literal>th</literal>添え字</entry>
<!--
        <entry>lower case ordinal number suffix</entry>
-->
        <entry>子文字による序数添え字</entry>
        <entry><literal>999th</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

  <para>
<!--
   <xref linkend="functions-formatting-examples-table"/> shows some
   examples of the use of the <function>to_char</function> function.
-->
<xref linkend="functions-formatting-examples-table"/>に、<function>to_char</function>関数を使用した例をいくつか示します。
  </para>

    <table id="functions-formatting-examples-table">
<!--
     <title><function>to_char</function> Examples</title>
-->
     <title><function>to_char</function>の例</title>
     <tgroup cols="2">
      <thead>
       <row>
<!--
        <entry>Expression</entry>
        <entry>Result</entry>
-->
        <entry>式</entry>
        <entry>結果</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><literal>to_char(current_timestamp, 'Day,&nbsp;DD&nbsp;&nbsp;HH12:MI:SS')</literal></entry>
        <entry><literal>'Tuesday&nbsp;&nbsp;,&nbsp;06&nbsp;&nbsp;05:39:18'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(current_timestamp, 'FMDay,&nbsp;FMDD&nbsp;&nbsp;HH12:MI:SS')</literal></entry>
        <entry><literal>'Tuesday,&nbsp;6&nbsp;&nbsp;05:39:18'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(-0.1, '99.99')</literal></entry>
        <entry><literal>'&nbsp;&nbsp;-.10'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(-0.1, 'FM9.99')</literal></entry>
        <entry><literal>'-.1'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(-0.1, 'FM90.99')</literal></entry>
        <entry><literal>'-0.1'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(0.1, '0.9')</literal></entry>
        <entry><literal>'&nbsp;0.1'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(12, '9990999.9')</literal></entry>
        <entry><literal>'&nbsp;&nbsp;&nbsp;&nbsp;0012.0'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(12, 'FM9990999.9')</literal></entry>
        <entry><literal>'0012.'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485, '999')</literal></entry>
        <entry><literal>'&nbsp;485'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(-485, '999')</literal></entry>
        <entry><literal>'-485'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485, '9&nbsp;9&nbsp;9')</literal></entry>
        <entry><literal>'&nbsp;4&nbsp;8&nbsp;5'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(1485, '9,999')</literal></entry>
        <entry><literal>'&nbsp;1,485'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(1485, '9G999')</literal></entry>
        <entry><literal>'&nbsp;1&nbsp;485'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(148.5, '999.999')</literal></entry>
        <entry><literal>'&nbsp;148.500'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(148.5, 'FM999.999')</literal></entry>
        <entry><literal>'148.5'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(148.5, 'FM999.990')</literal></entry>
        <entry><literal>'148.500'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(148.5, '999D999')</literal></entry>
        <entry><literal>'&nbsp;148,500'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(3148.5, '9G999D999')</literal></entry>
        <entry><literal>'&nbsp;3&nbsp;148,500'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(-485, '999S')</literal></entry>
        <entry><literal>'485-'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(-485, '999MI')</literal></entry>
        <entry><literal>'485-'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485, '999MI')</literal></entry>
        <entry><literal>'485&nbsp;'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485, 'FM999MI')</literal></entry>
        <entry><literal>'485'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485, 'PL999')</literal></entry>
        <entry><literal>'+485'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485, 'SG999')</literal></entry>
        <entry><literal>'+485'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(-485, 'SG999')</literal></entry>
        <entry><literal>'-485'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(-485, '9SG99')</literal></entry>
        <entry><literal>'4-85'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(-485, '999PR')</literal></entry>
        <entry><literal>'&lt;485&gt;'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485, 'L999')</literal></entry>
        <entry><literal>'DM&nbsp;485'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485, 'RN')</literal></entry>
        <entry><literal>'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CDLXXXV'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485, 'FMRN')</literal></entry>
        <entry><literal>'CDLXXXV'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(5.2, 'FMRN')</literal></entry>
        <entry><literal>'V'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(482, '999th')</literal></entry>
        <entry><literal>'&nbsp;482nd'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485, '"Good&nbsp;number:"999')</literal></entry>
        <entry><literal>'Good&nbsp;number:&nbsp;485'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485.8, '"Pre:"999"&nbsp;Post:"&nbsp;.999')</literal></entry>
        <entry><literal>'Pre:&nbsp;485&nbsp;Post:&nbsp;.800'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(12, '99V999')</literal></entry>
        <entry><literal>'&nbsp;12000'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(12.4, '99V999')</literal></entry>
        <entry><literal>'&nbsp;12400'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(12.45, '99V9')</literal></entry>
        <entry><literal>'&nbsp;125'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(0.0004859, '9.99EEEE')</literal></entry>
        <entry><literal>' 4.86e-04'</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

  </sect1>


  <sect1 id="functions-datetime">
<!--
   <title>Date/Time Functions and Operators</title>
-->
   <title>日付/時刻関数と演算子</title>

  <para>
<!--
   <xref linkend="functions-datetime-table"/> shows the available
   functions for date/time value processing, with details appearing in
   the following subsections.  <xref
   linkend="operators-datetime-table"/> illustrates the behaviors of
   the basic arithmetic operators (<literal>+</literal>,
   <literal>*</literal>, etc.).  For formatting functions, refer to
   <xref linkend="functions-formatting"/>.  You should be familiar with
   the background information on date/time data types from <xref
   linkend="datatype-datetime"/>.
-->
<xref linkend="functions-datetime-table"/>は、日付/時刻型の値の処理で使用可能な関数を示しています。詳細は、以下の副節で説明します。
<xref linkend="operators-datetime-table"/>は、（<literal>+</literal>、<literal>*</literal>等の）基本的な算術演算子の振舞いを説明しています。
書式設定関数については<xref linkend="functions-formatting"/>を参照してください。
<xref linkend="datatype-datetime"/>を参照して、日付/時刻データ型についての背景となっている情報に精通していなければなりません。
  </para>

  <para>
<!--
   All the functions and operators described below that take <type>time</type> or <type>timestamp</type>
   inputs actually come in two variants: one that takes <type>time with time zone</type> or <type>timestamp
   with time zone</type>, and one that takes <type>time without time zone</type> or <type>timestamp without time zone</type>.
   For brevity, these variants are not shown separately.  Also, the
   <literal>+</literal> and <literal>*</literal> operators come in commutative pairs (for
   example both date + integer and integer + date); we show only one of each
   such pair.
-->
以下の<type>time</type>もしくは<type>timestamp</type>型の入力を受け取る関数および演算子は全て、実際には2つの種類があります。1つは<type>time with time zone</type>型または<type>timestamp with time zone</type>型を取るもので、もう1つは<type>time without time zone</type>型もしくは<type>timestamp without time zone</type>型を取るものです。
簡略化のため、これらの種類の違いは個別に示していません。
また、<literal>+</literal>と<literal>*</literal>演算子は可換な2項をとります（例えばdate + integerとinteger + date）。こうした組み合わせは片方のみ示します。
  </para>

    <table id="operators-datetime-table">
<!--
     <title>Date/Time Operators</title>
-->
     <title>日付/時刻演算子</title>

     <tgroup cols="3">
      <thead>
       <row>
<!--
        <entry>Operator</entry>
        <entry>Example</entry>
        <entry>Result</entry>
-->
        <entry>演算子名</entry>
        <entry>例</entry>
        <entry>結果</entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry> <literal>+</literal> </entry>
        <entry><literal>date '2001-09-28' + integer '7'</literal></entry>
        <entry><literal>date '2001-10-05'</literal></entry>
       </row>

       <row>
        <entry> <literal>+</literal> </entry>
        <entry><literal>date '2001-09-28' + interval '1 hour'</literal></entry>
        <entry><literal>timestamp '2001-09-28 01:00:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>+</literal> </entry>
        <entry><literal>date '2001-09-28' + time '03:00'</literal></entry>
        <entry><literal>timestamp '2001-09-28 03:00:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>+</literal> </entry>
        <entry><literal>interval '1 day' + interval '1 hour'</literal></entry>
        <entry><literal>interval '1 day 01:00:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>+</literal> </entry>
        <entry><literal>timestamp '2001-09-28 01:00' + interval '23 hours'</literal></entry>
        <entry><literal>timestamp '2001-09-29 00:00:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>+</literal> </entry>
        <entry><literal>time '01:00' + interval '3 hours'</literal></entry>
        <entry><literal>time '04:00:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>-</literal> </entry>
        <entry><literal>- interval '23 hours'</literal></entry>
        <entry><literal>interval '-23:00:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>-</literal> </entry>
        <entry><literal>date '2001-10-01' - date '2001-09-28'</literal></entry>
<!--
        <entry><literal>integer '3'</literal> (days)</entry>
-->
        <entry><literal>integer '3'</literal>（日付）</entry>
       </row>

       <row>
        <entry> <literal>-</literal> </entry>
        <entry><literal>date '2001-10-01' - integer '7'</literal></entry>
        <entry><literal>date '2001-09-24'</literal></entry>
       </row>

       <row>
        <entry> <literal>-</literal> </entry>
        <entry><literal>date '2001-09-28' - interval '1 hour'</literal></entry>
        <entry><literal>timestamp '2001-09-27 23:00:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>-</literal> </entry>
        <entry><literal>time '05:00' - time '03:00'</literal></entry>
        <entry><literal>interval '02:00:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>-</literal> </entry>
        <entry><literal>time '05:00' - interval '2 hours'</literal></entry>
        <entry><literal>time '03:00:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>-</literal> </entry>
        <entry><literal>timestamp '2001-09-28 23:00' - interval '23 hours'</literal></entry>
        <entry><literal>timestamp '2001-09-28 00:00:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>-</literal> </entry>
        <entry><literal>interval '1 day' - interval '1 hour'</literal></entry>
        <entry><literal>interval '1 day -01:00:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>-</literal> </entry>
        <entry><literal>timestamp '2001-09-29 03:00' - timestamp '2001-09-27 12:00'</literal></entry>
        <entry><literal>interval '1 day 15:00:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>*</literal> </entry>
        <entry><literal>900 * interval '1 second'</literal></entry>
        <entry><literal>interval '00:15:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>*</literal> </entry>
        <entry><literal>21 * interval '1 day'</literal></entry>
        <entry><literal>interval '21 days'</literal></entry>
       </row>

       <row>
        <entry> <literal>*</literal> </entry>
        <entry><literal>double precision '3.5' * interval '1 hour'</literal></entry>
        <entry><literal>interval '03:30:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>/</literal> </entry>
        <entry><literal>interval '1 hour' / double precision '1.5'</literal></entry>
        <entry><literal>interval '00:40:00'</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

    <table id="functions-datetime-table">
<!--
     <title>Date/Time Functions</title>
-->
     <title>日付/時刻関数</title>
     <tgroup cols="5">
      <thead>
       <row>
<!--
        <entry>Function</entry>
        <entry>Return Type</entry>
        <entry>Description</entry>
        <entry>Example</entry>
        <entry>Result</entry>
-->
        <entry>関数名</entry>
        <entry>戻り値型</entry>
        <entry>説明</entry>
        <entry>例</entry>
        <entry>結果</entry>
    
       </row>
      </thead>

      <tbody>
       <row>
        <entry>
         <indexterm>
          <primary>age</primary>
         </indexterm>
         <literal><function>age(<type>timestamp</type>, <type>timestamp</type>)</function></literal>
        </entry>
        <entry><type>interval</type></entry>
<!--
        <entry>Subtract arguments, producing a <quote>symbolic</quote> result that
        uses years and months, rather than just days</entry>
-->
        <entry>引数間の減算。日数だけでなく年と月を使用した<quote>言葉による</quote>結果を生成</entry>
        <entry><literal>age(timestamp '2001-04-10', timestamp '1957-06-13')</literal></entry>
        <entry><literal>43 years 9 mons 27 days</literal></entry>
       </row>

       <row>
        <entry><literal><function>age(<type>timestamp</type>)</function></literal></entry>
        <entry><type>interval</type></entry>
<!--
        <entry>Subtract from <function>current_date</function> (at midnight)</entry>
-->
        <entry><function>current_date</function>（午前零時）から減算</entry>
        <entry><literal>age(timestamp '1957-06-13')</literal></entry>
        <entry><literal>43 years 8 mons 3 days</literal></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>clock_timestamp</primary>
         </indexterm>
         <literal><function>clock_timestamp()</function></literal>
        </entry>
        <entry><type>timestamp with time zone</type></entry>
<!--
        <entry>Current date and time (changes during statement execution);
         see <xref linkend="functions-datetime-current"/>
-->
        <entry>現在の日付と時刻（文実行中に変化する）。<xref linkend="functions-datetime-current"/>を参照。
        </entry>
        <entry></entry>
        <entry></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>current_date</primary>
         </indexterm>
         <literal><function>current_date</function></literal>
        </entry>
        <entry><type>date</type></entry>
<!--
        <entry>Current date;
         see <xref linkend="functions-datetime-current"/>
-->
        <entry>現在の日付。<xref linkend="functions-datetime-current"/>を参照
        </entry>
        <entry></entry>
        <entry></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>current_time</primary>
         </indexterm>
         <literal><function>current_time</function></literal>
        </entry>
        <entry><type>time with time zone</type></entry>
<!--
        <entry>Current time of day;
         see <xref linkend="functions-datetime-current"/>
-->
        <entry>現在の時刻。<xref linkend="functions-datetime-current"/>を参照。
        </entry>
        <entry></entry>
        <entry></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>current_timestamp</primary>
         </indexterm>
         <literal><function>current_timestamp</function></literal>
        </entry>
        <entry><type>timestamp with time zone</type></entry>
<!--
        <entry>Current date and time (start of current transaction);
         see <xref linkend="functions-datetime-current"/>
-->
        <entry>現在の日付と時刻（現在のトランザクションの開始時）。<xref linkend="functions-datetime-current"/>を参照。
        </entry>
        <entry></entry>
        <entry></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>date_part</primary>
         </indexterm>
         <literal><function>date_part(<type>text</type>, <type>timestamp</type>)</function></literal>
        </entry>
        <entry><type>double precision</type></entry>
<!--
        <entry>Get subfield (equivalent to <function>extract</function>);
         see <xref linkend="functions-datetime-extract"/>
-->
        <entry>部分フィールドの取得（<function>extract</function>と同じ）。<xref linkend="functions-datetime-extract"/>を参照。
        </entry>
        <entry><literal>date_part('hour', timestamp '2001-02-16 20:38:40')</literal></entry>
        <entry><literal>20</literal></entry>
       </row>

       <row>
        <entry><literal><function>date_part(<type>text</type>, <type>interval</type>)</function></literal></entry>
        <entry><type>double precision</type></entry>
<!--
        <entry>Get subfield (equivalent to
         <function>extract</function>); see <xref linkend="functions-datetime-extract"/>
-->
        <entry>部分フィールドの取得（<function>extract</function>と同じ）。<xref linkend="functions-datetime-extract"/>を参照。
        </entry>
        <entry><literal>date_part('month', interval '2 years 3 months')</literal></entry>
        <entry><literal>3</literal></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>date_trunc</primary>
         </indexterm>
         <literal><function>date_trunc(<type>text</type>, <type>timestamp</type>)</function></literal>
        </entry>
        <entry><type>timestamp</type></entry>
<!--
        <entry>Truncate to specified precision; see <xref linkend="functions-datetime-trunc"/>
-->
        <entry>指定された精度で切り捨て。<xref linkend="functions-datetime-trunc"/>参照。
        </entry>
        <entry><literal>date_trunc('hour', timestamp '2001-02-16 20:38:40')</literal></entry>
        <entry><literal>2001-02-16 20:00:00</literal></entry>
       </row>

       <row>
        <entry><literal><function>date_trunc(<type>text</type>, <type>timestamp with time zone</type>, <type>text</type>)</function></literal></entry>
        <entry><type>timestamp with time zone</type></entry>
<!--
        <entry>Truncate to specified precision in the specified time zone; see <xref linkend="functions-datetime-trunc"/>
-->
        <entry>指定された時間帯において指定された精度で切り捨て。<xref linkend="functions-datetime-trunc"/>参照
        </entry>
        <entry><literal>date_trunc('day', timestamptz '2001-02-16 20:38:40+00', 'Australia/Sydney')</literal></entry>
        <entry><literal>2001-02-16 13:00:00+00</literal></entry>
       </row>

       <row>
        <entry><literal><function>date_trunc(<type>text</type>, <type>interval</type>)</function></literal></entry>
        <entry><type>interval</type></entry>
<!--
        <entry>Truncate to specified precision; see <xref linkend="functions-datetime-trunc"/>
-->
        <entry>指定された精度で切り捨て。<xref linkend="functions-datetime-trunc"/>参照。
        </entry>
        <entry><literal>date_trunc('hour', interval '2 days 3 hours 40 minutes')</literal></entry>
        <entry><literal>2 days 03:00:00</literal></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>extract</primary>
         </indexterm>
         <literal><function>extract</function>(<parameter>field</parameter> from
         <type>timestamp</type>)</literal>
        </entry>
        <entry><type>double precision</type></entry>
<!--
        <entry>Get subfield; see <xref linkend="functions-datetime-extract"/>
-->
        <entry>部分フィールドの取得。<xref linkend="functions-datetime-extract"/>を参照。
        </entry>
        <entry><literal>extract(hour from timestamp '2001-02-16 20:38:40')</literal></entry>
        <entry><literal>20</literal></entry>
       </row>

       <row>
        <entry><literal><function>extract</function>(<parameter>field</parameter> from
         <type>interval</type>)</literal></entry>
        <entry><type>double precision</type></entry>
<!--
        <entry>Get subfield; see <xref linkend="functions-datetime-extract"/>
-->
        <entry>部分フィールドの取得。<xref linkend="functions-datetime-extract"/>を参照。
        </entry>
        <entry><literal>extract(month from interval '2 years 3 months')</literal></entry>
        <entry><literal>3</literal></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>isfinite</primary>
         </indexterm>
         <literal><function>isfinite(<type>date</type>)</function></literal>
        </entry>
        <entry><type>boolean</type></entry>
<!--
        <entry>Test for finite date (not +/-infinity)</entry>
-->
        <entry>日付が有限（+/-無限でない）かどうかの検査</entry>
        <entry><literal>isfinite(date '2001-02-16')</literal></entry>
        <entry><literal>true</literal></entry>
       </row>

       <row>
        <entry><literal><function>isfinite(<type>timestamp</type>)</function></literal></entry>
        <entry><type>boolean</type></entry>
<!--
        <entry>Test for finite time stamp (not +/-infinity)</entry>
-->
        <entry>タイムスタンプが有限（+/-無限でない）かどうかの検査</entry>
        <entry><literal>isfinite(timestamp '2001-02-16 21:28:30')</literal></entry>
        <entry><literal>true</literal></entry>
       </row>

       <row>
        <entry><literal><function>isfinite(<type>interval</type>)</function></literal></entry>
        <entry><type>boolean</type></entry>
<!--
        <entry>Test for finite interval</entry>
-->
        <entry>時間間隔が有限かどうかの検査</entry>
        <entry><literal>isfinite(interval '4 hours')</literal></entry>
        <entry><literal>true</literal></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>justify_days</primary>
         </indexterm>
         <literal><function>justify_days(<type>interval</type>)</function></literal>
        </entry>
        <entry><type>interval</type></entry>
<!--
        <entry>Adjust interval so 30-day time periods are represented as months</entry>
-->
        <entry>30日周期が1月を表すように時間間隔を調整</entry>
        <entry><literal>justify_days(interval '35 days')</literal></entry>
        <entry><literal>1 mon 5 days</literal></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>justify_hours</primary>
         </indexterm>
         <literal><function>justify_hours(<type>interval</type>)</function></literal>
        </entry>
        <entry><type>interval</type></entry>
<!--
        <entry>Adjust interval so 24-hour time periods are represented as days</entry>
-->
        <entry>24時間を1日とする時間間隔の調整</entry>
        <entry><literal>justify_hours(interval '27 hours')</literal></entry>
        <entry><literal>1 day 03:00:00</literal></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>justify_interval</primary>
         </indexterm>
         <literal><function>justify_interval(<type>interval</type>)</function></literal>
        </entry>
        <entry><type>interval</type></entry>
<!--
        <entry>Adjust interval using <function>justify_days</function> and <function>justify_hours</function>, with additional sign adjustments</entry>
-->
        <entry><function>justify_days</function>および<function>justify_hours</function>を使用し、さらに符号による調整を行っての時間間隔の調整</entry>
        <entry><literal>justify_interval(interval '1 mon -1 hour')</literal></entry>
        <entry><literal>29 days 23:00:00</literal></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>localtime</primary>
         </indexterm>
         <literal><function>localtime</function></literal>
        </entry>
        <entry><type>time</type></entry>
<!--
        <entry>Current time of day;
         see <xref linkend="functions-datetime-current"/>
-->
        <entry>現在の時刻。<xref linkend="functions-datetime-current"/>を参照。
        </entry>
        <entry></entry>
        <entry></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>localtimestamp</primary>
         </indexterm>
         <literal><function>localtimestamp</function></literal>
        </entry>
        <entry><type>timestamp</type></entry>
<!--
        <entry>Current date and time (start of current transaction);
         see <xref linkend="functions-datetime-current"/>
-->
        <entry>現在の日付と時刻（現在のトランザクションの開始時）。<xref linkend="functions-datetime-current"/>を参照。
        </entry>
        <entry></entry>
        <entry></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>make_date</primary>
         </indexterm>
         <literal>
            <function>
             make_date(<parameter>year</parameter> <type>int</type>,
             <parameter>month</parameter> <type>int</type>,
             <parameter>day</parameter> <type>int</type>)
            </function>
         </literal>
        </entry>
        <entry><type>date</type></entry>
        <entry>
<!--
         Create date from year, month and day fields
-->
         年、月、日フィールドから日付を作成
        </entry>
        <entry><literal>make_date(2013, 7, 15)</literal></entry>
        <entry><literal>2013-07-15</literal></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>make_interval</primary>
         </indexterm>
         <literal>
          <function>
           make_interval(<parameter>years</parameter> <type>int</type> DEFAULT 0,
           <parameter>months</parameter> <type>int</type> DEFAULT 0,
           <parameter>weeks</parameter> <type>int</type> DEFAULT 0,
           <parameter>days</parameter> <type>int</type> DEFAULT 0,
           <parameter>hours</parameter> <type>int</type> DEFAULT 0,
           <parameter>mins</parameter> <type>int</type> DEFAULT 0,
           <parameter>secs</parameter> <type>double precision</type> DEFAULT 0.0)
          </function>
         </literal>
        </entry>
        <entry><type>interval</type></entry>
        <entry>
<!--
         Create interval from years, months, weeks, days, hours, minutes and
         seconds fields
-->
         年、月、週、日、時間、分、秒フィールドから時間間隔を作成
        </entry>
        <entry><literal>make_interval(days =&gt; 10)</literal></entry>
        <entry><literal>10 days</literal></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>make_time</primary>
         </indexterm>
         <literal>
          <function>
           make_time(<parameter>hour</parameter> <type>int</type>,
           <parameter>min</parameter> <type>int</type>,
           <parameter>sec</parameter> <type>double precision</type>)
          </function>
         </literal>
        </entry>
        <entry><type>time</type></entry>
        <entry>
<!--
         Create time from hour, minute and seconds fields
-->
         時、分、秒フィールドから時刻を作成
        </entry>
        <entry><literal>make_time(8, 15, 23.5)</literal></entry>
        <entry><literal>08:15:23.5</literal></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>make_timestamp</primary>
         </indexterm>
         <literal>
          <function>
           make_timestamp(<parameter>year</parameter> <type>int</type>,
           <parameter>month</parameter> <type>int</type>,
           <parameter>day</parameter> <type>int</type>,
           <parameter>hour</parameter> <type>int</type>,
           <parameter>min</parameter> <type>int</type>,
           <parameter>sec</parameter> <type>double precision</type>)
          </function>
         </literal>
        </entry>
        <entry><type>timestamp</type></entry>
        <entry>
<!--
         Create timestamp from year, month, day, hour, minute and seconds fields
-->
         年、月、日、時、分、秒フィールドから時刻を作成
        </entry>
        <entry><literal>make_timestamp(2013, 7, 15, 8, 15, 23.5)</literal></entry>
        <entry><literal>2013-07-15 08:15:23.5</literal></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>make_timestamptz</primary>
         </indexterm>
         <literal>
          <function>
           make_timestamptz(<parameter>year</parameter> <type>int</type>,
           <parameter>month</parameter> <type>int</type>,
           <parameter>day</parameter> <type>int</type>,
           <parameter>hour</parameter> <type>int</type>,
           <parameter>min</parameter> <type>int</type>,
           <parameter>sec</parameter> <type>double precision</type>,
           <optional> <parameter>timezone</parameter> <type>text</type> </optional>)
          </function>
         </literal>
        </entry>
        <entry><type>timestamp with time zone</type></entry>
        <entry>
<!--
         Create timestamp with time zone from year, month, day, hour, minute
         and seconds fields; if <parameter>timezone</parameter> is not
         specified, the current time zone is used
-->
         年、月、日、時、分、秒フィールドから時間帯付きの時刻を作成。<parameter>timezone</parameter>が指定されていなければ、現在の時間帯が使われる。
        </entry>
        <entry><literal>make_timestamptz(2013, 7, 15, 8, 15, 23.5)</literal></entry>
        <entry><literal>2013-07-15 08:15:23.5+01</literal></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>now</primary>
         </indexterm>
         <literal><function>now()</function></literal>
        </entry>
        <entry><type>timestamp with time zone</type></entry>
<!--
        <entry>Current date and time (start of current transaction);
         see <xref linkend="functions-datetime-current"/>
-->
        <entry>現在の日付と時刻（現在のトランザクションの開始時）。
<xref linkend="functions-datetime-current"/>を参照。
        </entry>
        <entry></entry>
        <entry></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>statement_timestamp</primary>
         </indexterm>
         <literal><function>statement_timestamp()</function></literal>
        </entry>
        <entry><type>timestamp with time zone</type></entry>
<!--
        <entry>Current date and time (start of current statement);
         see <xref linkend="functions-datetime-current"/>
-->
        <entry>現在の日付と時刻（現在の文の開始時）。
<xref linkend="functions-datetime-current"/>を参照。
        </entry>
        <entry></entry>
        <entry></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>timeofday</primary>
         </indexterm>
         <literal><function>timeofday()</function></literal>
        </entry>
        <entry><type>text</type></entry>
<!--
        <entry>Current date and time
         (like <function>clock_timestamp</function>, but as a <type>text</type> string);
         see <xref linkend="functions-datetime-current"/>
-->
        <entry>現在の日付と時刻（<function>clock_timestamp</function>と似ているが、<type>text</type>型文字列として返す）。<xref linkend="functions-datetime-current"/>を参照。
        </entry>
        <entry></entry>
        <entry></entry>
       </row>

       <row>
        <entry>
         <indexterm>
          <primary>transaction_timestamp</primary>
         </indexterm>
         <literal><function>transaction_timestamp()</function></literal>
        </entry>
        <entry><type>timestamp with time zone</type></entry>
<!--
        <entry>Current date and time (start of current transaction);
         see <xref linkend="functions-datetime-current"/>
-->
        <entry>現在の日付と時刻（現在のトランザクションの開始時）。
<xref linkend="functions-datetime-current"/>を参照。
        </entry>
        <entry></entry>
        <entry></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>to_timestamp</primary>
         </indexterm>
         <literal><function>to_timestamp(<type>double precision</type>)</function></literal>
        </entry>
        <entry><type>timestamp with time zone</type></entry>
<!--
        <entry>Convert Unix epoch (seconds since 1970-01-01 00:00:00+00) to
         timestamp</entry>
-->
        <entry>Unixエポック時間（1970-01-01 00:00:00+00からの経過秒数）をタイムスタンプに変換</entry>
        <entry><literal>to_timestamp(1284352323)</literal></entry>
        <entry><literal>2010-09-13 04:32:03+00</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
    <indexterm>
      <primary>OVERLAPS</primary>
    </indexterm>
<!--
    In addition to these functions, the SQL <literal>OVERLAPS</literal> operator is
    supported:
-->
これらの関数に加え、<literal>OVERLAPS</literal> SQL演算子がサポートされています。
<synopsis>
(<replaceable>start1</replaceable>, <replaceable>end1</replaceable>) OVERLAPS (<replaceable>start2</replaceable>, <replaceable>end2</replaceable>)
(<replaceable>start1</replaceable>, <replaceable>length1</replaceable>) OVERLAPS (<replaceable>start2</replaceable>, <replaceable>length2</replaceable>)
</synopsis>
<!--
    This expression yields true when two time periods (defined by their
    endpoints) overlap, false when they do not overlap.  The endpoints
    can be specified as pairs of dates, times, or time stamps; or as
    a date, time, or time stamp followed by an interval.  When a pair
    of values is provided, either the start or the end can be written
    first; <literal>OVERLAPS</literal> automatically takes the earlier value
    of the pair as the start.  Each time period is considered to
    represent the half-open interval <replaceable>start</replaceable> <literal>&lt;=</literal>
    <replaceable>time</replaceable> <literal>&lt;</literal> <replaceable>end</replaceable>, unless
    <replaceable>start</replaceable> and <replaceable>end</replaceable> are equal in which case it
    represents that single time instant.  This means for instance that two
    time periods with only an endpoint in common do not overlap.
-->
この式は、2つの時間間隔（その両端で定義されます）が重なる時に真を返します。重ならない場合は偽を返します。
両端は2つの日付、時刻、タイムスタンプとして、もしくは、日付/時刻/タイムスタンプとそれに続く時間間隔として指定できます。
値の組み合わせで指定する場合、開始と終了のいずれを先に記述しても構いません。<literal>OVERLAPS</literal>は与えられた値のうち、早い方を開始として扱います。
各時間間隔は、<replaceable>start</replaceable> <literal>&lt;=</literal> <replaceable>time</replaceable> <literal>&lt;</literal> <replaceable>end</replaceable>という半開区間として見なされます。ただし、<replaceable>start</replaceable>と<replaceable>end</replaceable>が同じ値の場合には単一の時間点となります。
これは、例えば端点のみが共通である2つの時間間隔は、重ならないということを意味します。
   </para>

<screen>
SELECT (DATE '2001-02-16', DATE '2001-12-21') OVERLAPS
       (DATE '2001-10-30', DATE '2002-10-30');
<lineannotation>Result: </lineannotation><computeroutput>true</computeroutput>
SELECT (DATE '2001-02-16', INTERVAL '100 days') OVERLAPS
       (DATE '2001-10-30', DATE '2002-10-30');
<lineannotation>Result: </lineannotation><computeroutput>false</computeroutput>
SELECT (DATE '2001-10-29', DATE '2001-10-30') OVERLAPS
       (DATE '2001-10-30', DATE '2001-10-31');
<lineannotation>Result: </lineannotation><computeroutput>false</computeroutput>
SELECT (DATE '2001-10-30', DATE '2001-10-30') OVERLAPS
       (DATE '2001-10-30', DATE '2001-10-31');
<lineannotation>Result: </lineannotation><computeroutput>true</computeroutput>
</screen>

  <para>
<!--
   When adding an <type>interval</type> value to (or subtracting an
   <type>interval</type> value from) a <type>timestamp with time zone</type>
   value, the days component advances or decrements the date of the
   <type>timestamp with time zone</type> by the indicated number of days.
   Across daylight saving time changes (when the session time zone is set to a
   time zone that recognizes DST), this means <literal>interval '1 day'</literal>
   does not necessarily equal <literal>interval '24 hours'</literal>.
   For example, with the session time zone set to <literal>CST7CDT</literal>,
   <literal>timestamp with time zone '2005-04-02 12:00-07' + interval '1 day'</literal>
   will produce <literal>timestamp with time zone '2005-04-03 12:00-06'</literal>,
   while adding <literal>interval '24 hours'</literal> to the same initial
   <type>timestamp with time zone</type> produces
   <literal>timestamp with time zone '2005-04-03 13:00-06'</literal>, as there is
   a change in daylight saving time at <literal>2005-04-03 02:00</literal> in time zone
   <literal>CST7CDT</literal>.
-->
<type>timestamp with time zone</type>の値に<type>interval</type>の値を加える時（または<type>interval</type>の値を引く時）、日にちの部分は、<type>timestamp with time zone</type>の日付を指定された日数だけ先に進める、もしくは後に戻します。
（セッションの時間帯がDSTを認識する設定の場合）夏時間の移行に跨っての変化に関しては、<literal>interval '1 day'</literal>が<literal>interval '24 hours'</literal>に等しいとは限りません。
例えば、セッションの時間帯が <literal>CST7CDT</literal>に設定されている時に、 <literal>timestamp with time zone '2005-04-02 12:00-07' + interval '1 day' </literal>は、<literal>timestamp with time zone '2005-04-03 12:00-06'</literal>となります。一方、元の同じ<type>timestamp with time zone</type>に<literal>interval '24 hours'</literal>を加えると、<literal>timestamp with time zone '2005-04-03 13:00-06'</literal>という結果になります。その理由は<literal>CST7CDT</literal>時間帯で<literal>2005-04-03 02:00</literal>に夏時間への変更があるからです。
  </para>

  <para>
<!--
   Note there can be ambiguity in the <literal>months</literal> field returned by
   <function>age</function> because different months have different numbers of
   days.  <productname>PostgreSQL</productname>'s approach uses the month from the
   earlier of the two dates when calculating partial months.  For example,
   <literal>age('2004-06-01', '2004-04-30')</literal> uses April to yield
   <literal>1 mon 1 day</literal>, while using May would yield <literal>1 mon 2
   days</literal> because May has 31 days, while April has only 30.
-->
異なる月では日数が異なりますので<function>age</function>で返される<literal>months</literal>フィールドにはあいまいさがあります。
<productname>PostgreSQL</productname>のやり方は月をまたがる２つの日付の計算において、日付の早いほうの月を使用します。
例えば、<literal>age('2004-06-01', '2004-04-30')</literal>は4月を使用して<literal>1 mon 1 day</literal>を得ます。5月は31日あり、4月は30日のため、もし5月を使用するなら結果は<literal>1 mon 2 days</literal>となるでしょう。
  </para>

  <para>
<!--
   Subtraction of dates and timestamps can also be complex.  One conceptually
   simple way to perform subtraction is to convert each value to a number
   of seconds using <literal>EXTRACT(EPOCH FROM ...)</literal>, then subtract the
   results; this produces the
   number of <emphasis>seconds</emphasis> between the two values.  This will adjust
   for the number of days in each month, timezone changes, and daylight
   saving time adjustments.  Subtraction of date or timestamp
   values with the <quote><literal>-</literal></quote> operator
   returns the number of days (24-hours) and hours/minutes/seconds
   between the values, making the same adjustments.  The <function>age</function>
   function returns years, months, days, and hours/minutes/seconds,
   performing field-by-field subtraction and then adjusting for negative
   field values.  The following queries illustrate the differences in these
   approaches.  The sample results were produced with <literal>timezone
   = 'US/Eastern'</literal>; there is a daylight saving time change between the
   two dates used:
-->
日付とタイムスタンプの引き算は複雑になることがあります。
引き算をする概念的に単純な方法は、それぞれの値を秒数に<literal>EXTRACT(EPOCH FROM ...)</literal>で変換してから、結果を引き算する方法です。この結果は2つの値の間の<emphasis>秒</emphasis>数になります。
これは各月の日数、時間帯の変更、夏時間の調整に対して調整されるでしょう。
<quote><literal>-</literal></quote>演算子での日付やタイムスタンプの引き算は値の間の(24時間の)日数と時間/分/秒を、同様に調整して返します。
<function>age</function>関数は年、月、日、時間/分/秒をフィールド毎に引き算し、負のフィールドの値を調整します。
以下の問い合わせは上の各方法の違いを説明する例です。
例の結果は<literal>timezone = 'US/Eastern'</literal>で生成されました。2つの日付の間には夏時間の変更があります。
  </para>

<screen>
SELECT EXTRACT(EPOCH FROM timestamptz '2013-07-01 12:00:00') -
       EXTRACT(EPOCH FROM timestamptz '2013-03-01 12:00:00');
<!--
<lineannotation>Result: </lineannotation><computeroutput>10537200</computeroutput>
-->
<lineannotation>結果: </lineannotation><computeroutput>10537200</computeroutput>
SELECT (EXTRACT(EPOCH FROM timestamptz '2013-07-01 12:00:00') -
        EXTRACT(EPOCH FROM timestamptz '2013-03-01 12:00:00'))
        / 60 / 60 / 24;
<!--
<lineannotation>Result: </lineannotation><computeroutput>121.958333333333</computeroutput>
-->
<lineannotation>結果: </lineannotation><computeroutput>121.958333333333</computeroutput>
SELECT timestamptz '2013-07-01 12:00:00' - timestamptz '2013-03-01 12:00:00';
<!--
<lineannotation>Result: </lineannotation><computeroutput>121 days 23:00:00</computeroutput>
-->
<lineannotation>結果: </lineannotation><computeroutput>121 days 23:00:00</computeroutput>
SELECT age(timestamptz '2013-07-01 12:00:00', timestamptz '2013-03-01 12:00:00');
<!--
<lineannotation>Result: </lineannotation><computeroutput>4 mons</computeroutput>
-->
<lineannotation>結果: </lineannotation><computeroutput>4 mons</computeroutput>
</screen>

  <sect2 id="functions-datetime-extract">
   <title><function>EXTRACT</function>, <function>date_part</function></title>

   <indexterm>
    <primary>date_part</primary>
   </indexterm>
   <indexterm>
    <primary>extract</primary>
   </indexterm>

<synopsis>
EXTRACT(<replaceable>field</replaceable> FROM <replaceable>source</replaceable>)
</synopsis>

   <para>
<!--
    The <function>extract</function> function retrieves subfields
    such as year or hour from date/time values.
    <replaceable>source</replaceable> must be a value expression of
    type <type>timestamp</type>, <type>time</type>, or <type>interval</type>.
    (Expressions of type <type>date</type> are
    cast to <type>timestamp</type> and can therefore be used as
    well.)  <replaceable>field</replaceable> is an identifier or
    string that selects what field to extract from the source value.
    The <function>extract</function> function returns values of type
    <type>double precision</type>.
    The following are valid field names:
-->
<function>extract</function>関数は、日付/時刻の値から年や時などの部分フィールドを抽出します。
<replaceable>source</replaceable>は<type>timestamp</type>型、<type>time</type>型、または<type>interval</type>型の評価式でなければなりません（<type>date</type>型の式は<type>timestamp</type>型にキャストされますので、同様に使用可能です）。
<replaceable>field</replaceable>はsourceの値からどのフィールドを抽出するかを選択する識別子もしくは文字列です。
<function>extract</function>関数は<type>double precision</type>型の値を返します。以下に有効なフィールド名を示します。

    <!-- alphabetical -->
    <variablelist>
     <varlistentry>
      <term><literal>century</literal></term>
      <listitem>
       <para>
<!--
        The century
-->
世紀
       </para>

<screen>
SELECT EXTRACT(CENTURY FROM TIMESTAMP '2000-12-16 12:21:13');
<lineannotation>Result: </lineannotation><computeroutput>20</computeroutput>
SELECT EXTRACT(CENTURY FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>21</computeroutput>
</screen>

       <para>
<!--
        The first century starts at 0001-01-01 00:00:00 AD, although
        they did not know it at the time. This definition applies to all
        Gregorian calendar countries. There is no century number 0,
        you go from -1 century to 1 century.

        If you disagree with this, please write your complaint to:
        Pope, Cathedral Saint-Peter of Roma, Vatican.
-->
当時の人々にはそのような意識はありませんでしたが、最初の世紀は0001-01-01 00:00:00 ADから始まります。
この定義は全てのグレゴリオ暦を使用する国で適用されています。
0という値の世紀はありません。-1世紀の次は1世紀です。

この定義に納得できなければ、苦情をバチカンローマ聖パウロ大聖堂のローマ法王に伝えてください。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>day</literal></term>
      <listitem>
       <para>
<!--
        For <type>timestamp</type> values, the day (of the month) field
        (1 - 31) ; for <type>interval</type> values, the number of days
-->
<type>timestamp</type>値については、(月内の)日付フィールド(1〜31)。<type>interval</type>値については日数。
       </para>

<screen>
SELECT EXTRACT(DAY FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>16</computeroutput>

SELECT EXTRACT(DAY FROM INTERVAL '40 days 1 minute');
<lineannotation>Result: </lineannotation><computeroutput>40</computeroutput>
</screen>



      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>decade</literal></term>
      <listitem>
       <para>
<!--
        The year field divided by 10
-->
年フィールドを10で割ったもの
       </para>

<screen>
SELECT EXTRACT(DECADE FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>200</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>dow</literal></term>
      <listitem>
       <para>
<!--
        The day of the week as Sunday (<literal>0</literal>) to
        Saturday (<literal>6</literal>)
-->
日曜日（<literal>0</literal>）から土曜日（<literal>6</literal>）までの曜日
       </para>

<screen>
SELECT EXTRACT(DOW FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>5</computeroutput>
</screen>
       <para>
<!--
        Note that <function>extract</function>'s day of the week numbering
        differs from that of the <function>to_char(...,
        'D')</function> function.
-->
<function>extract</function>関数の曜日番号は<function>to_char(...,'D')</function>関数のそれとは異なる点に注意してください。
       </para>

      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>doy</literal></term>
      <listitem>
       <para>
<!--
        The day of the year (1 - 365/366)
-->
年内での通算日数（1〜365/366）
       </para>

<screen>
SELECT EXTRACT(DOY FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>47</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>epoch</literal></term>
      <listitem>
       <para>
<!--
        For <type>timestamp with time zone</type> values, the
        number of seconds since 1970-01-01 00:00:00 UTC (can be negative);
        for <type>date</type> and <type>timestamp</type> values, the
        number of seconds since 1970-01-01 00:00:00 local time;
        for <type>interval</type> values, the total number
        of seconds in the interval
-->
<type>timestamp with time zone</type>型の値において、1970-01-01 00:00:00 UTCからの秒数（負の数の場合もあり）。<type>date</type>と<type>timestamp</type>型の値において、ローカルタイムの1970-01-01 00:00:00からの秒数。<type>interval</type>型の値ではその時間間隔における全体の秒数。
       </para>

<screen>
SELECT EXTRACT(EPOCH FROM TIMESTAMP WITH TIME ZONE '2001-02-16 20:38:40.12-08');
<lineannotation>Result: </lineannotation><computeroutput>982384720.12</computeroutput>

SELECT EXTRACT(EPOCH FROM INTERVAL '5 days 3 hours');
<lineannotation>Result: </lineannotation><computeroutput>442800</computeroutput>
</screen>

       <para>
<!--
        You can convert an epoch value back to a time stamp
        with <function>to_timestamp</function>:
-->
<function>to_timestamp</function>で経過秒数をタイムスタンプ値に変換することができます。
       </para>
<screen>
SELECT to_timestamp(982384720.12);
<lineannotation>Result: </lineannotation><computeroutput>2001-02-17 04:38:40.12+00</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>hour</literal></term>
      <listitem>
       <para>
<!--
        The hour field (0 - 23)
-->
時のフィールド（0〜23）
       </para>

<screen>
SELECT EXTRACT(HOUR FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>20</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>isodow</literal></term>
      <listitem>
       <para>
<!--
        The day of the week as Monday (<literal>1</literal>) to
        Sunday (<literal>7</literal>)
-->
月曜日（<literal>1</literal>）から日曜日（<literal>7</literal>）までの曜日
       </para>

<screen>
SELECT EXTRACT(ISODOW FROM TIMESTAMP '2001-02-18 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>7</computeroutput>
</screen>
       <para>
<!--
        This is identical to <literal>dow</literal> except for Sunday.  This
        matches the <acronym>ISO</acronym> 8601 day of the week numbering.
-->
日曜日を除き<literal>dow</literal>と同一です。
これは<acronym>ISO</acronym> 8601曜日番号付けに一致します。
       </para>

      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>isoyear</literal></term>
      <listitem>
       <para>
<!--
        The <acronym>ISO</acronym> 8601 week-numbering year that the date
        falls in (not applicable to intervals)
-->
日付に当てはまる<acronym>ISO</acronym> 8601週番号年（intervalには適用できない）。
       </para>

<screen>
SELECT EXTRACT(ISOYEAR FROM DATE '2006-01-01');
<lineannotation>Result: </lineannotation><computeroutput>2005</computeroutput>
SELECT EXTRACT(ISOYEAR FROM DATE '2006-01-02');
<lineannotation>Result: </lineannotation><computeroutput>2006</computeroutput>
</screen>

       <para>
<!--
        Each <acronym>ISO</acronym> 8601 week-numbering year begins with the
        Monday of the week containing the 4th of January, so in early
        January or late December the <acronym>ISO</acronym> year may be
        different from the Gregorian year.  See the <literal>week</literal>
        field for more information.
-->
すべての<acronym>ISO</acronym> 8601週番号年は1月4日を含む週の月曜日から開始されます。従って、1月上旬、または12月下旬で<acronym>ISO</acronym>年がグレゴリオ年と異なる可能性があります。
より詳細は<literal>week</literal>フィールドを参照してください。
       </para>
       <para>
<!--
        This field is not available in PostgreSQL releases prior to 8.3.
-->
このフィールドは8.3より前のPostgreSQLリリースでは有効でありません。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>microseconds</literal></term>
      <listitem>
       <para>
<!--
        The seconds field, including fractional parts, multiplied by 1
        000 000;  note that this includes full seconds
-->
端数部分も含む秒フィールドに、1,000,000を乗じた値。秒の整数部を含むことに注意。
       </para>

<screen>
SELECT EXTRACT(MICROSECONDS FROM TIME '17:12:28.5');
<lineannotation>Result: </lineannotation><computeroutput>28500000</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>millennium</literal></term>
      <listitem>
       <para>
<!--
        The millennium
-->
ミレニアム（千年期）
       </para>

<screen>
SELECT EXTRACT(MILLENNIUM FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>3</computeroutput>
</screen>

       <para>
<!--
        Years in the 1900s are in the second millennium.
        The third millennium started January 1, 2001.
-->
1900年代の年は第2ミレニアムです。第3ミレニアムは2001年1月1日から始まりました。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>milliseconds</literal></term>
      <listitem>
       <para>
<!--
        The seconds field, including fractional parts, multiplied by
        1000.  Note that this includes full seconds.
-->
端数部分も含む秒フィールドに、1000を乗た値。秒の整数部を含むことに注意してください。
       </para>

<screen>
SELECT EXTRACT(MILLISECONDS FROM TIME '17:12:28.5');
<lineannotation>Result: </lineannotation><computeroutput>28500</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>minute</literal></term>
      <listitem>
       <para>
<!--
        The minutes field (0 - 59)
-->
分フィールド（0〜59）
       </para>

<screen>
SELECT EXTRACT(MINUTE FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>38</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>month</literal></term>
      <listitem>
       <para>
<!--
        For <type>timestamp</type> values, the number of the month
        within the year (1 - 12) ; for <type>interval</type> values,
        the number of months, modulo 12 (0 - 11)
-->
<type>timestamp</type>型の値に対しては年内の月番号（1〜12）。<type>interval</type>型の値に対しては月数を12で割った余り（0〜11）。
       </para>

<screen>
SELECT EXTRACT(MONTH FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>2</computeroutput>

SELECT EXTRACT(MONTH FROM INTERVAL '2 years 3 months');
<lineannotation>Result: </lineannotation><computeroutput>3</computeroutput>

SELECT EXTRACT(MONTH FROM INTERVAL '2 years 13 months');
<lineannotation>Result: </lineannotation><computeroutput>1</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>quarter</literal></term>
      <listitem>
       <para>
<!--
        The quarter of the year (1 - 4) that the date is in
-->
その日付が含まれる年の四半期（1〜4）。
       </para>

<screen>
SELECT EXTRACT(QUARTER FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>1</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>second</literal></term>
      <listitem>
       <para>
<!--
        The seconds field, including fractional parts (0 -
        59<footnote><simpara>60 if leap seconds are
        implemented by the operating system</simpara></footnote>)
-->
端数を含んだ秒フィールド（0〜59<footnote><simpara>オペレーティングシステムでうるう秒が実装されている場合は60まで。</simpara></footnote>）。
       </para>

<screen>
SELECT EXTRACT(SECOND FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>40</computeroutput>

SELECT EXTRACT(SECOND FROM TIME '17:12:28.5');
<lineannotation>Result: </lineannotation><computeroutput>28.5</computeroutput>
</screen>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>timezone</literal></term>
      <listitem>
       <para>
<!--
        The time zone offset from UTC, measured in seconds.  Positive values
        correspond to time zones east of UTC, negative values to
        zones west of UTC.  (Technically,
        <productname>PostgreSQL</productname> does not use UTC because
        leap seconds are not handled.)
-->
秒単位のUTCからの時間帯オフセット。正の値はUTCより東の時間帯に対応し、負の値はUTCより西の時間帯に対応。
(技術的に言えば、<productname>PostgreSQL</productname>はうるう秒を制御しないためUTCを使用していない。)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>timezone_hour</literal></term>
      <listitem>
       <para>
<!--
        The hour component of the time zone offset
-->
時間帯オフセットの時の成分。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>timezone_minute</literal></term>
      <listitem>
       <para>
<!--
        The minute component of the time zone offset
-->
時間帯オフセットの分の成分。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>week</literal></term>
      <listitem>
       <para>
<!--
        The number of the <acronym>ISO</acronym> 8601 week-numbering week of
        the year.  By definition, ISO weeks start on Mondays and the first
        week of a year contains January 4 of that year.  In other words, the
        first Thursday of a year is in week 1 of that year.
-->
<acronym>ISO</acronym> 8601週番号。
定義ではISO週は月曜日から始まり、その年の1月4日を含む週をその年の第1週としています。
つまり、年の最初の木曜日がある週がその年の第1週となります。
       </para>
       <para>
<!--
        In the ISO week-numbering system, it is possible for early-January
        dates to be part of the 52nd or 53rd week of the previous year, and for
        late-December dates to be part of the first week of the next year.
        For example, <literal>2005-01-01</literal> is part of the 53rd week of year
        2004, and <literal>2006-01-01</literal> is part of the 52nd week of year
        2005, while <literal>2012-12-31</literal> is part of the first week of 2013.
        It's recommended to use the <literal>isoyear</literal> field together with
        <literal>week</literal> to get consistent results.
-->
ISO週番号システムでは、1月の早い日にちは前年の第52週もしくは第53週となることがあり、12月の遅い日にちには次年の最初の週の一部となることがあります。
例えば、<literal>2005-01-01</literal>は2004年の第53週であり、<literal>2006-01-01</literal>は2005年の第52週の一部です、一方<literal>2012-12-31</literal>は2013年の第1週の一部となります。
整合性のある結果を得るため、<literal>isoyear</literal>フィールドと<literal>week</literal>を併用することを推奨します。
       </para>

<screen>
SELECT EXTRACT(WEEK FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>7</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>year</literal></term>
      <listitem>
       <para>
<!--
        The year field.  Keep in mind there is no <literal>0 AD</literal>, so subtracting
        <literal>BC</literal> years from <literal>AD</literal> years should be done with care.
-->
年フィールド。<literal>AD零年</literal>が存在しないことは忘れないでください。このため<literal>AD</literal>の年から<literal>BC</literal>の年を減ずる時には注意が必要です。
       </para>

<screen>
SELECT EXTRACT(YEAR FROM TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>2001</computeroutput>
</screen>
      </listitem>
     </varlistentry>

    </variablelist>
   </para>

   <note>
    <para>
<!--
     When the input value is +/-Infinity, <function>extract</function> returns
     +/-Infinity for monotonically-increasing fields (<literal>epoch</literal>,
     <literal>julian</literal>, <literal>year</literal>, <literal>isoyear</literal>,
     <literal>decade</literal>, <literal>century</literal>, and <literal>millennium</literal>).
     For other fields, NULL is returned.  <productname>PostgreSQL</productname>
     versions before 9.6 returned zero for all cases of infinite input.
-->
入力値が+/-無限大の場合、<function>extract</function>は単調増加するフィールド（<literal>epoch</literal>、<literal>julian</literal>、<literal>year</literal>、<literal>isoyear</literal>、<literal>decade</literal>、<literal>century</literal>、<literal>millennium</literal>）に対し、+/-無限大を返します。
その他のフィールドに対してはNULLが返されます。
<productname>PostgreSQL</productname>の9.6より前のバージョンでは、入力が無限大のすべての場合に対してゼロを返していました。
    </para>
   </note>

   <para>
<!--
    The <function>extract</function> function is primarily intended
    for computational processing.  For formatting date/time values for
    display, see <xref linkend="functions-formatting"/>.
-->
<function>extract</function>関数は主に演算処理を意図しています。
日付/時刻の値を表示する目的での書式については<xref linkend="functions-formatting"/>を参照してください。
   </para>

   <para>
<!--
    The <function>date_part</function> function is modeled on the traditional
    <productname>Ingres</productname> equivalent to the
    <acronym>SQL</acronym>-standard function <function>extract</function>:
-->
<function>date_part</function>関数は伝統的な<productname>Ingres</productname>上で設計されたもので、標準<acronym>SQL</acronym>の<function>extract</function>関数と等価です。
<synopsis>
date_part('<replaceable>field</replaceable>', <replaceable>source</replaceable>)
</synopsis>
<!--
    Note that here the <replaceable>field</replaceable> parameter needs to
    be a string value, not a name.  The valid field names for
    <function>date_part</function> are the same as for
    <function>extract</function>.
-->
ここで<replaceable>field</replaceable>パラメータが名前ではなく文字列値である必要があることに注意してください。
<function>date_part</function>で有効なフィールド名は<function>extract</function>と同じです。
   </para>

<screen>
SELECT date_part('day', TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>16</computeroutput>

SELECT date_part('hour', INTERVAL '4 hours 3 minutes');
<lineannotation>Result: </lineannotation><computeroutput>4</computeroutput>
</screen>

  </sect2>

  <sect2 id="functions-datetime-trunc">
   <title><function>date_trunc</function></title>

   <indexterm>
    <primary>date_trunc</primary>
   </indexterm>

   <para>
<!--
    The function <function>date_trunc</function> is conceptually
    similar to the <function>trunc</function> function for numbers.
-->
<function>date_trunc</function>関数は概念的に数値に対する<function>trunc</function>関数と類似しています。
   </para>

   <para>
<synopsis>
date_trunc(<replaceable>field</replaceable>, <replaceable>source</replaceable> [, <replaceable>time_zone</replaceable> ])
</synopsis>
<!--
    <replaceable>source</replaceable> is a value expression of type
    <type>timestamp</type>, <type>timestamp with time zone</type>,
    or <type>interval</type>.
    (Values of type <type>date</type> and
    <type>time</type> are cast automatically to <type>timestamp</type> or
    <type>interval</type>, respectively.)
    <replaceable>field</replaceable> selects to which precision to
    truncate the input value.  The return value is likewise of type
    <type>timestamp</type>, <type>timestamp with time zone</type>,
    or <type>interval</type>,
    and it has all fields that are less significant than the
    selected one set to zero (or one, for day and month).
-->
<replaceable>source</replaceable>は、データ型<type>timestamp</type>、<type>timestamp with time zone</type>もしくは<type>interval</type>の評価式です。
（<type>date</type>型と<type>time</type>型の値はそれぞれ自動的に<type>timestamp</type>もしくは<type>interval</type>にキャストされます。）
<replaceable>field</replaceable>は、入力値の値をどの精度で切り捨てるかを選択します。
同様に戻り値は<type>timestamp</type>、<type>timestamp with time zone</type>もしくは<type>interval</type>型で、指定した精度より下のすべてのフィールドがゼロに設定（日と月については1に設定）されます。
   </para>

   <para>
<!--
    Valid values for <replaceable>field</replaceable> are:
-->
<replaceable>field</replaceable>の有効値には次のものがあります。
    <simplelist>
     <member><literal>microseconds</literal></member>
     <member><literal>milliseconds</literal></member>
     <member><literal>second</literal></member>
     <member><literal>minute</literal></member>
     <member><literal>hour</literal></member>
     <member><literal>day</literal></member>
     <member><literal>week</literal></member>
     <member><literal>month</literal></member>
     <member><literal>quarter</literal></member>
     <member><literal>year</literal></member>
     <member><literal>decade</literal></member>
     <member><literal>century</literal></member>
     <member><literal>millennium</literal></member>
    </simplelist>
   </para>

   <para>
<!--
    When the input value is of type <type>timestamp with time zone</type>,
    the truncation is performed with respect to a particular time zone;
    for example, truncation to <literal>day</literal> produces a value that
    is midnight in that zone.  By default, truncation is done with respect
    to the current <xref linkend="guc-timezone"/> setting, but the
    optional <replaceable>time_zone</replaceable> argument can be provided
    to specify a different time zone.  The time zone name can be specified
    in any of the ways described in <xref linkend="datatype-timezones"/>.
-->
入力値が<type>timestamp with time zone</type>型の値なら、特定の時間帯を考慮して切り捨てが行われます。たとえば、<literal>日</literal>を切り捨てると値はその時間帯での真夜中になります。
デフォルトでは切り捨ては現在の<xref linkend="guc-timezone"/>の設定に従いますが、別の時間帯を指定することができるようにオプションの<replaceable>time_zone</replaceable>引数が提供されています。
時間帯名は<xref linkend="datatype-timezones"/>に記述されている方法で指定できます。
   </para>

   <para>
<!--
    A time zone cannot be specified when processing <type>timestamp without
    time zone</type> or <type>interval</type> inputs.  These are always
    taken at face value.
-->
<type>timestamp without time zone</type>あるいは<type>interval</type>の入力を処理している間は時間帯は指定できません。
これらは額面通りの値で扱われます。
   </para>

   <para>
<!--
    Examples (assuming the local time zone is <literal>America/New_York</literal>):
-->
例（現地タイムゾーンは<literal>America/New_York</literal>と仮定します）：
<screen>
SELECT date_trunc('hour', TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>2001-02-16 20:00:00</computeroutput>

SELECT date_trunc('year', TIMESTAMP '2001-02-16 20:38:40');
<lineannotation>Result: </lineannotation><computeroutput>2001-01-01 00:00:00</computeroutput>

SELECT date_trunc('day', TIMESTAMP WITH TIME ZONE '2001-02-16 20:38:40+00');
<lineannotation>Result: </lineannotation><computeroutput>2001-02-16 00:00:00-05</computeroutput>

SELECT date_trunc('day', TIMESTAMP WITH TIME ZONE '2001-02-16 20:38:40+00', 'Australia/Sydney');
<lineannotation>Result: </lineannotation><computeroutput>2001-02-16 08:00:00-05</computeroutput>

SELECT date_trunc('hour', INTERVAL '3 days 02:47:33');
<lineannotation>Result: </lineannotation><computeroutput>3 days 02:00:00</computeroutput>
</screen>
   </para>
  </sect2>

  <sect2 id="functions-datetime-zoneconvert">
   <title><literal>AT TIME ZONE</literal></title>

   <indexterm>
<!--
    <primary>time zone</primary>
    <secondary>conversion</secondary>
-->
    <primary>時間帯</primary>
    <secondary>変換</secondary>
   </indexterm>

   <indexterm>
    <primary>AT TIME ZONE</primary>
   </indexterm>

   <para>
<!--
    The <literal>AT TIME ZONE</literal> converts time
    stamp <emphasis>without time zone</emphasis> to/from
    time stamp <emphasis>with time zone</emphasis>, and
    <emphasis>time</emphasis> values to different time zones. <xref
    linkend="functions-datetime-zoneconvert-table"/> shows its variants.
-->
<function>AT TIME ZONE</function>構文を使用することにより、time stamp <emphasis>without time zone</emphasis>からtime stamp <emphasis>with time zone</emphasis>へ、あるいはtime stamp <emphasis>with time zone</emphasis>からtime stamp <emphasis>without time zone</emphasis>へ変換でき、また<emphasis>時刻</emphasis>値を異なる時間帯に変換することができます。
<xref linkend="functions-datetime-zoneconvert-table"/>にその種類を示します。
   </para>

    <table id="functions-datetime-zoneconvert-table">
<!--
     <title><literal>AT TIME ZONE</literal> Variants</title>
-->
     <title><literal>AT TIME ZONE</literal>の種類</title>
     <tgroup cols="3">
      <thead>
       <row>
<!--
        <entry>Expression</entry>
        <entry>Return Type</entry>
        <entry>Description</entry>
-->
        <entry>式</entry>
        <entry>戻り値</entry>
        <entry>説明</entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry>
         <literal><type>timestamp without time zone</type> AT TIME ZONE <replaceable>zone</replaceable></literal>
        </entry>
        <entry><type>timestamp with time zone</type></entry>
<!--
        <entry>Treat given time stamp <emphasis>without time zone</emphasis> as located in the specified time zone</entry>
-->
        <entry>与えられた<emphasis>時間帯なし</emphasis>タイムスタンプを指定された時間帯にあるとして取り扱います。</entry>
       </row>

       <row>
        <entry>
         <literal><type>timestamp with time zone</type> AT TIME ZONE <replaceable>zone</replaceable></literal>
        </entry>
        <entry><type>timestamp without time zone</type></entry>
<!--
        <entry>Convert given time stamp <emphasis>with time zone</emphasis> to the new time
        zone, with no time zone designation</entry>
-->
        <entry>与えられた<emphasis>時間帯付き</emphasis>タイムスタンプを新規の時間帯に、時間帯の指定なく変換します。</entry>
       </row>

       <row>
        <entry>
         <literal><type>time with time zone</type> AT TIME ZONE <replaceable>zone</replaceable></literal>
        </entry>
        <entry><type>time with time zone</type></entry>
<!--
        <entry>Convert given time <emphasis>with time zone</emphasis> to the new time zone</entry>
-->
        <entry>与えられた時刻<emphasis>with time zone</emphasis>を新しい時間帯に変換します。</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
<!--
    In these expressions, the desired time zone <replaceable>zone</replaceable> can be
    specified either as a text string (e.g., <literal>'America/Los_Angeles'</literal>)
    or as an interval (e.g., <literal>INTERVAL '-08:00'</literal>).
    In the text case, a time zone name can be specified in any of the ways
    described in <xref linkend="datatype-timezones"/>.
-->
これらの式では、設定する時間帯<replaceable>zone</replaceable>は、（<literal>'America/Los_Angeles'</literal>のような）テキスト文字列、または（<literal>INTERVAL '-08:00'</literal>のような）時間間隔で指定することができます。
テキストの場合、<xref linkend="datatype-timezones"/>に示した方法で時間帯名称を指定することができます。
   </para>

   <para>
<!--
    Examples (assuming the local time zone is <literal>America/Los_Angeles</literal>):
-->
以下に例を示します（ローカル時間帯を<literal>America/Los_Angeles</literal>と想定しています）。
<screen>
SELECT TIMESTAMP '2001-02-16 20:38:40' AT TIME ZONE 'America/Denver';
<lineannotation>Result: </lineannotation><computeroutput>2001-02-16 19:38:40-08</computeroutput>

SELECT TIMESTAMP WITH TIME ZONE '2001-02-16 20:38:40-05' AT TIME ZONE 'America/Denver';
<lineannotation>Result: </lineannotation><computeroutput>2001-02-16 18:38:40</computeroutput>

SELECT TIMESTAMP '2001-02-16 20:38:40-05' AT TIME ZONE 'Asia/Tokyo' AT TIME ZONE 'America/Chicago';
<lineannotation>Result: </lineannotation><computeroutput>2001-02-16 05:38:40</computeroutput>
</screen>
<!--
    The first example adds a time zone to a value that lacks it, and
    displays the value using the current <varname>TimeZone</varname>
    setting.  The second example shifts the time stamp with time zone value
    to the specified time zone, and returns the value without a time zone.
    This allows storage and display of values different from the current
    <varname>TimeZone</varname> setting.  The third example converts
    Tokyo time to Chicago time.   Converting <emphasis>time</emphasis>
    values to other time zones uses the currently active time zone rules
    since no date is supplied.
-->
最初の例は、時間帯のない値に時間帯を追加し、現在の<varname>TimeZone</varname>設定を使ってその値を表示します。
2番目の例は、time stamp with time zone値を指定したタイムゾーンに変換し、その値をwithout a time zoneで返しています。
これは、<varname>TimeZone</varname>設定とは異なる値の格納と表示を可能にします。
3番目の例は、東京時間をシカゴ時間に変換します。
データが与えられていないので、現在有効なタイムゾーンルールを使って、<emphasis>時刻</emphasis>値を変換しています。
   </para>

   <para>
<!--
    The function <literal><function>timezone</function>(<replaceable>zone</replaceable>,
    <replaceable>timestamp</replaceable>)</literal> is equivalent to the SQL-conforming construct
    <literal><replaceable>timestamp</replaceable> AT TIME ZONE
    <replaceable>zone</replaceable></literal>.
-->
関数<function>timezone</function>(<replaceable>zone</replaceable>, <replaceable>timestamp</replaceable>)は、SQL準拠の構文<literal><replaceable>timestamp</replaceable> AT TIME ZONE <replaceable>zone</replaceable></literal>と等価です。
   </para>
  </sect2>

  <sect2 id="functions-datetime-current">
<!--
   <title>Current Date/Time</title>
-->
   <title>現在の日付/時刻</title>

   <indexterm>
<!--
    <primary>date</primary>
    <secondary>current</secondary>
-->
    <primary>日付</primary>
    <secondary>現在</secondary>
   </indexterm>

   <indexterm>
<!--
    <primary>time</primary>
    <secondary>current</secondary>
-->
    <primary>時刻</primary>
    <secondary>現在</secondary>
   </indexterm>

   <para>
<!--
    <productname>PostgreSQL</productname> provides a number of functions
    that return values related to the current date and time.  These
    SQL-standard functions all return values based on the start time of
    the current transaction:
-->
<productname>PostgreSQL</productname>は、現在の日付時刻に関した値を返す多くの関数を提供します。
これらの標準SQL関数はすべて、現在のトランザクションの開始時刻に基づいた値を返します。
<synopsis>
CURRENT_DATE
CURRENT_TIME
CURRENT_TIMESTAMP
CURRENT_TIME(<replaceable>precision</replaceable>)
CURRENT_TIMESTAMP(<replaceable>precision</replaceable>)
LOCALTIME
LOCALTIMESTAMP
LOCALTIME(<replaceable>precision</replaceable>)
LOCALTIMESTAMP(<replaceable>precision</replaceable>)
</synopsis>
    </para>

    <para>
<!--
     <function>CURRENT_TIME</function> and
     <function>CURRENT_TIMESTAMP</function> deliver values with time zone;
     <function>LOCALTIME</function> and
     <function>LOCALTIMESTAMP</function> deliver values without time zone.
-->
<function>CURRENT_TIME</function>および<function>CURRENT_TIMESTAMP</function>関数では、時間帯を伴う値を扱います。一方、<function>LOCALTIME</function>および<function>LOCALTIMESTAMP</function>関数では、時間帯を伴わない値を扱います。
    </para>

    <para>
<!--
     <function>CURRENT_TIME</function>,
     <function>CURRENT_TIMESTAMP</function>,
     <function>LOCALTIME</function>, and
     <function>LOCALTIMESTAMP</function>
     can optionally take
     a precision parameter, which causes the result to be rounded
     to that many fractional digits in the seconds field.  Without a precision parameter,
     the result is given to the full available precision.
-->
<function>CURRENT_TIME</function>、<function>CURRENT_TIMESTAMP</function>、<function>LOCALTIME</function>、および<function>LOCALTIMESTAMP</function>関数では、精度のパラメータをオプションで取ることができ、それに合わせて秒フィールドの端数桁を丸める結果をもたらします。
精度のパラメータがない場合、結果は使用可能な最大精度で出力されます。
    </para>

   <para>
<!--
    Some examples:
-->
例：
<screen>
SELECT CURRENT_TIME;
<lineannotation>Result: </lineannotation><computeroutput>14:39:53.662522-05</computeroutput>

SELECT CURRENT_DATE;
<lineannotation>Result: </lineannotation><computeroutput>2001-12-23</computeroutput>

SELECT CURRENT_TIMESTAMP;
<lineannotation>Result: </lineannotation><computeroutput>2001-12-23 14:39:53.662522-05</computeroutput>

SELECT CURRENT_TIMESTAMP(2);
<lineannotation>Result: </lineannotation><computeroutput>2001-12-23 14:39:53.66-05</computeroutput>

SELECT LOCALTIMESTAMP;
<lineannotation>Result: </lineannotation><computeroutput>2001-12-23 14:39:53.662522</computeroutput>
</screen>
   </para>

   <para>
<!--
    Since these functions return
    the start time of the current transaction, their values do not
    change during the transaction. This is considered a feature:
    the intent is to allow a single transaction to have a consistent
    notion of the <quote>current</quote> time, so that multiple
    modifications within the same transaction bear the same
    time stamp.
-->
これらの関数は現在のトランザクションの開始時刻を返すため、その値はトランザクションが実行されている間は変化しません。
これは仕様であると考えられており、その意図は、単一のトランザクションが一貫性のある<quote>現在</quote>時刻の概念を持ち、同一トランザクション内の複数の変更が同一のタイムスタンプを持つようにすることにあります。
   </para>

   <note>
    <para>
<!--
     Other database systems might advance these values more
     frequently.
-->
他のデータベースシステムでは、これらの値をより頻繁に増加させることがあります。
    </para>
   </note>

   <para>
<!--
    <productname>PostgreSQL</productname> also provides functions that
    return the start time of the current statement, as well as the actual
    current time at the instant the function is called.  The complete list
    of non-SQL-standard time functions is:
-->
<productname>PostgreSQL</productname>はまた、関数を呼び出した時の実際の現在時刻や現在の文の開始時刻を返す関数も提供します。
非標準SQLの時間関数の全一覧を以下に示します。
<synopsis>
transaction_timestamp()
statement_timestamp()
clock_timestamp()
timeofday()
now()
</synopsis>
   </para>

   <para>
<!--
    <function>transaction_timestamp()</function> is equivalent to
    <function>CURRENT_TIMESTAMP</function>, but is named to clearly reflect
    what it returns.
    <function>statement_timestamp()</function> returns the start time of the current
    statement (more specifically, the time of receipt of the latest command
    message from the client).
    <function>statement_timestamp()</function> and <function>transaction_timestamp()</function>
    return the same value during the first command of a transaction, but might
    differ during subsequent commands.
    <function>clock_timestamp()</function> returns the actual current time, and
    therefore its value changes even within a single SQL command.
    <function>timeofday()</function> is a historical
    <productname>PostgreSQL</productname> function.  Like
    <function>clock_timestamp()</function>, it returns the actual current time,
    but as a formatted <type>text</type> string rather than a <type>timestamp
    with time zone</type> value.
    <function>now()</function> is a traditional <productname>PostgreSQL</productname>
    equivalent to <function>transaction_timestamp()</function>.
-->
<function>transaction_timestamp()</function>は<function>CURRENT_TIMESTAMP</function>と等価ですが、明確に何を返すかを反映する名前になっています。
<function>statement_timestamp()</function>は現在の文の実行開始時刻を返すものです（より具体的にいうと、直前のコマンドメッセージをクライアントから受け取った時刻です）。
<function>statement_timestamp()</function>および<function>transaction_timestamp()</function>はトランザクションの最初のコマンドでは同じ値を返しますが、その後に引き続くコマンドでは異なる可能性があります。
<function>clock_timestamp()</function>は実際の現在時刻を返しますので、その値は単一のSQLコマンドであっても異なります。
<function>timeofday()</function>は<productname>PostgreSQL</productname>の歴史的な関数です。
<function>clock_timestamp()</function>同様、実際の現在時刻を返しますが、<type>timestamp with time zone</type>型の値ではなく、整形された<type>text</type>文字列を返します。<function>now()</function>は<function>transaction_timestamp()</function>と同じもので、伝統的な<productname>PostgreSQL</productname>関数です。
   </para>

   <para>
<!--
    All the date/time data types also accept the special literal value
    <literal>now</literal> to specify the current date and time (again,
    interpreted as the transaction start time).  Thus,
    the following three all return the same result:
-->
すべての日付/時刻型はまた、特殊なリテラル値 <literal>now</literal>を受け付け、これは現在の日付と時刻（ここでも、トランザクションの開始時刻として解釈されます）を表します。
したがって、下記の３つの実行結果は全て同じものとなります。
<programlisting>
SELECT CURRENT_TIMESTAMP;
SELECT now();
<!--
SELECT TIMESTAMP 'now';  &#045;- incorrect for use with DEFAULT
-->
SELECT TIMESTAMP 'now';  -- DEFAULTで使用するのは正しくない
</programlisting>
   </para>

    <tip>
     <para>
<!--
      You do not want to use the third form when specifying a <literal>DEFAULT</literal>
      clause while creating a table.  The system will convert <literal>now</literal>
      to a <type>timestamp</type> as soon as the constant is parsed, so that when
      the default value is needed,
      the time of the table creation would be used!  The first two
      forms will not be evaluated until the default value is used,
      because they are function calls.  Thus they will give the desired
      behavior of defaulting to the time of row insertion.
-->
テーブルを作成する時、<literal>DEFAULT</literal>句を指定するのに3番目の形式を使おうとは思わないでしょう。
システムは<literal>now</literal>という定数を解析すると、すぐにそれを<type>timestamp</type>に変換するので、デフォルト値が必要が時には、テーブルが作成された時刻が使われます。最初の2つの形式は関数呼び出しなので、デフォルト値が使用されるまで評価されません。ですから、これらの関数は列の挿入時間をデフォルトとする、望ましい振舞いをします。
     </para>
    </tip>
  </sect2>

  <sect2 id="functions-datetime-delay">
<!--
   <title>Delaying Execution</title>
-->
   <title>遅延実行</title>

   <indexterm>
    <primary>pg_sleep</primary>
   </indexterm>
   <indexterm>
    <primary>pg_sleep_for</primary>
   </indexterm>
   <indexterm>
    <primary>pg_sleep_until</primary>
   </indexterm>
   <indexterm>
<!--
    <primary>sleep</primary>
-->
    <primary>休止</primary>
   </indexterm>
   <indexterm>
<!--
    <primary>delay</primary>
-->
    <primary>遅延</primary>
   </indexterm>

   <para>
<!--
    The following functions are available to delay execution of the server
    process:
-->
以下の関数は、サーバプロセスの実行を遅延させるために使用可能です。
<synopsis>
pg_sleep(<replaceable>seconds</replaceable>)
pg_sleep_for(<type>interval</type>)
pg_sleep_until(<type>timestamp with time zone</type>)
</synopsis>

<!--
    <function>pg_sleep</function> makes the current session's process
    sleep until <replaceable>seconds</replaceable> seconds have
    elapsed.  <replaceable>seconds</replaceable> is a value of type
    <type>double precision</type>, so fractional-second delays can be specified.
    <function>pg_sleep_for</function> is a convenience function for larger
    sleep times specified as an <type>interval</type>.
    <function>pg_sleep_until</function> is a convenience function for when
    a specific wake-up time is desired.
    For example:
-->
<function>pg_sleep</function>は、<replaceable>seconds</replaceable>秒経過するまで、現在のセッションのプロセスを休止させます。
<replaceable>seconds</replaceable>は<type>double precision</type>型の値です。そのため、小数単位で休止秒数を指定することができます。
<function>pg_sleep_for</function>は<type>interval</type>でより長い休止時間を指定する便利な関数です。
<function>pg_sleep_until</function>は特定の起床時刻が望まれる場合に便利な関数です。
以下に例を示します。

<programlisting>
SELECT pg_sleep(1.5);
SELECT pg_sleep_for('5 minutes');
SELECT pg_sleep_until('tomorrow 03:00');
</programlisting>
   </para>

   <note>
     <para>
<!--
      The effective resolution of the sleep interval is platform-specific;
      0.01 seconds is a common value.  The sleep delay will be at least as long
      as specified. It might be longer depending on factors such as server load.
      In particular, <function>pg_sleep_until</function> is not guaranteed to
      wake up exactly at the specified time, but it will not wake up any earlier.
-->
休止時間の有効な分解能はプラットフォームに依存します。0.01秒が一般的な値です。
休止による遅延は最短で指定した時間と同じになります。
サーバの負荷などが要因となり、より長くなる可能性があります。
特に、<function>pg_sleep_until</function>は指定した時刻ちょうどに起床する保証はありませんが、それより早く起床することはありません。
     </para>
   </note>

   <warning>
     <para>
<!--
      Make sure that your session does not hold more locks than necessary
      when calling <function>pg_sleep</function> or its variants.  Otherwise
      other sessions might have to wait for your sleeping process, slowing down
      the entire system.
-->
<function>pg_sleep</function>またはその亜種を呼び出す時、セッションが必要以上のロックを保持していないことを確実にしてください。
さもないと、他のセッションが休止中のプロセスを待機しなければならないかもしれません。そのためシステム全体の速度が低下することになるかもしれません。
     </para>
   </warning>
  </sect2>

 </sect1>


 <sect1 id="functions-enum">
<!--
  <title>Enum Support Functions</title>
-->
  <title>列挙型サポート関数</title>

  <para>
<!--
   For enum types (described in <xref linkend="datatype-enum"/>),
   there are several functions that allow cleaner programming without
   hard-coding particular values of an enum type.
   These are listed in <xref linkend="functions-enum-table"/>. The examples
   assume an enum type created as:
-->
列挙型（<xref linkend="datatype-enum"/>で解説）に対し、特に列挙型の値をハードコーディングせず簡潔なプログラミングを可能にするいくつかの関数があります。
それらの関数は<xref linkend="functions-enum-table"/>で一覧されています。
例は以下のようにして列挙型が作成されていることを想定しています。

<programlisting>
CREATE TYPE rainbow AS ENUM ('red', 'orange', 'yellow', 'green', 'blue', 'purple');
</programlisting>

  </para>

  <table id="functions-enum-table">
<!--
    <title>Enum Support Functions</title>
-->
    <title>列挙型サポート関数</title>
    <tgroup cols="4">
     <thead>
      <row>
<!--
       <entry>Function</entry>
       <entry>Description</entry>
       <entry>Example</entry>
       <entry>Example Result</entry>
-->
       <entry>関数</entry>
       <entry>説明</entry>
       <entry>例</entry>
       <entry>例の結果</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>
         <indexterm>
          <primary>enum_first</primary>
         </indexterm>
         <literal>enum_first(anyenum)</literal>
       </entry>
<!--
       <entry>Returns the first value of the input enum type</entry>
-->
       <entry>入力列挙型の最初の値を返す</entry>
       <entry><literal>enum_first(null::rainbow)</literal></entry>
       <entry><literal>red</literal></entry>
      </row>
      <row>
       <entry>
         <indexterm>
          <primary>enum_last</primary>
         </indexterm>
         <literal>enum_last(anyenum)</literal>
       </entry>
<!--
       <entry>Returns the last value of the input enum type</entry>
-->
       <entry>入力列挙型の最後の値を返す</entry>
       <entry><literal>enum_last(null::rainbow)</literal></entry>
       <entry><literal>purple</literal></entry>
      </row>
      <row>
       <entry>
         <indexterm>
          <primary>enum_range</primary>
         </indexterm>
         <literal>enum_range(anyenum)</literal>
       </entry>
<!--
       <entry>Returns all values of the input enum type in an ordered array</entry>
-->
       <entry>入力列挙型の全ての値を順序配列として返す</entry>
       <entry><literal>enum_range(null::rainbow)</literal></entry>
       <entry><literal>{red,orange,yellow,green,blue,purple}</literal></entry>
      </row>
      <row>
       <entry morerows="2"><literal>enum_range(anyenum, anyenum)</literal></entry>
       <entry morerows="2">
<!--
        Returns the range between the two given enum values, as an ordered
        array. The values must be from the same enum type. If the first
        parameter is null, the result will start with the first value of
        the enum type.
        If the second parameter is null, the result will end with the last
        value of the enum type.
-->
与えられた２つの列挙型値の範囲を、順序配列として返す。
値は同一の列挙型に拠らなければならない。
１番目のパラメータがNULLの場合、結果は列挙型の最初の値から始まる。
２番目のパラメータがNULLの場合、結果は列挙型の最後の値で終わる。
       </entry>
       <entry><literal>enum_range('orange'::rainbow, 'green'::rainbow)</literal></entry>
       <entry><literal>{orange,yellow,green}</literal></entry>
      </row>
      <row>
       <entry><literal>enum_range(NULL, 'green'::rainbow)</literal></entry>
       <entry><literal>{red,orange,yellow,green}</literal></entry>
      </row>
      <row>
       <entry><literal>enum_range('orange'::rainbow, NULL)</literal></entry>
       <entry><literal>{orange,yellow,green,blue,purple}</literal></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
<!--
    Notice that except for the two-argument form of <function>enum_range</function>,
    these functions disregard the specific value passed to them; they care
    only about its declared data type.  Either null or a specific value of
    the type can be passed, with the same result.  It is more common to
    apply these functions to a table column or function argument than to
    a hardwired type name as suggested by the examples.
-->
<function>enum_range</function>の２引数の形式を除き、これらの関数は、渡された特定の値を無視することに注意してください。関数は宣言されたデータ型のみ配慮します。
その型のNULLまたは特定の値を渡すことができ、同一の結果が得られます。
例で示したような直書きした型名に対してではなく、テーブル列もしくは関数引数にこれらの関数を適用することがより一般的です。
   </para>
 </sect1>

 <sect1 id="functions-geometry">
<!--
  <title>Geometric Functions and Operators</title>
-->
  <title>幾何関数と演算子</title>

   <para>
<!--
    The geometric types <type>point</type>, <type>box</type>,
    <type>lseg</type>, <type>line</type>, <type>path</type>,
    <type>polygon</type>, and <type>circle</type> have a large set of
    native support functions and operators, shown in <xref
    linkend="functions-geometry-op-table"/>, <xref
    linkend="functions-geometry-func-table"/>, and <xref
    linkend="functions-geometry-conv-table"/>.
-->
<type>point</type>、<type>box</type>、<type>lseg</type>、<type>line</type>、<type>path</type>、<type>polygon</type>、および<type>circle</type>幾何データ型には、PostgreSQLが元々サポートしている関数と演算子が豊富に揃っています（<xref linkend="functions-geometry-op-table"/>、<xref linkend="functions-geometry-func-table"/>、および<xref linkend="functions-geometry-conv-table"/>を参照してください）。
   </para>

   <caution>
    <para>
<!--
     Note that the <quote>same as</quote> operator, <literal>~=</literal>, represents
     the usual notion of equality for the <type>point</type>,
     <type>box</type>, <type>polygon</type>, and <type>circle</type> types.
     Some of these types also have an <literal>=</literal> operator, but
     <literal>=</literal> compares
     for equal <emphasis>areas</emphasis> only.  The other scalar comparison operators
     (<literal>&lt;=</literal> and so on) likewise compare areas for these types.
-->
<quote>同じを示す</quote><literal>~=</literal>演算子は<type>point</type>、<type>box</type>、<type>polygon</type>、および<type>circle</type>型に対し通常の等価概念を示すことに注意してください。これらのいくつかの型は<literal>=</literal>演算子を持ちますが、<literal>=</literal>は<emphasis>面積</emphasis>の等しさのみを比較します。その他のスカラー比較演算子（<literal>&lt;=</literal>など）は同様にこれらの型の面積を比較します。
    </para>
   </caution>

   <table id="functions-geometry-op-table">
<!--
     <title>Geometric Operators</title>
-->
     <title>幾何データ演算子</title>
     <tgroup cols="3">
      <thead>
       <row>
<!--
        <entry>Operator</entry>
        <entry>Description</entry>
        <entry>Example</entry>
-->
        <entry>演算子</entry>
        <entry>説明</entry>
        <entry>例</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry> <literal>+</literal> </entry>
<!--
        <entry>Translation</entry>
-->
        <entry>平行移動</entry>
        <entry><literal>box '((0,0),(1,1))' + point '(2.0,0)'</literal></entry>
       </row>
       <row>
        <entry> <literal>-</literal> </entry>
<!--
        <entry>Translation</entry>
-->
        <entry>平行移動</entry>
        <entry><literal>box '((0,0),(1,1))' - point '(2.0,0)'</literal></entry>
       </row>
       <row>
        <entry> <literal>*</literal> </entry>
<!--
        <entry>Scaling/rotation</entry>
-->
        <entry>拡大縮小/回転</entry>
        <entry><literal>box '((0,0),(1,1))' * point '(2.0,0)'</literal></entry>
       </row>
       <row>
        <entry> <literal>/</literal> </entry>
<!--
        <entry>Scaling/rotation</entry>
-->
        <entry>拡大縮小/回転</entry>
        <entry><literal>box '((0,0),(2,2))' / point '(2.0,0)'</literal></entry>
       </row>
       <row>
        <entry> <literal>#</literal> </entry>
<!--
        <entry>Point or box of intersection</entry>
-->
        <entry>交差点、交差矩形</entry>
        <entry><literal>box '((1,-1),(-1,1))' # box '((1,1),(-2,-2))'</literal></entry>
       </row>
       <row>
        <entry> <literal>#</literal> </entry>
<!--
        <entry>Number of points in path or polygon</entry>
-->
        <entry>経路もしくは多角形の点の数</entry>
        <entry><literal># path '((1,0),(0,1),(-1,0))'</literal></entry>
       </row>
       <row>
        <entry> <literal>@-@</literal> </entry>
<!--
        <entry>Length or circumference</entry>
-->
        <entry>長さもしくは円周</entry>
        <entry><literal>@-@ path '((0,0),(1,0))'</literal></entry>
       </row>
       <row>
        <entry> <literal>@@</literal> </entry>
<!--
        <entry>Center</entry>
-->
        <entry>中心</entry>
        <entry><literal>@@ circle '((0,0),10)'</literal></entry>
       </row>
       <row>
        <entry> <literal>##</literal> </entry>
<!--
        <entry>Closest point to first operand on second operand</entry>
-->
        <entry>第2オペランド上の第1オペランドへの近接点</entry>
        <entry><literal>point '(0,0)' ## lseg '((2,0),(0,2))'</literal></entry>
       </row>
       <row>
        <entry> <literal>&lt;-&gt;</literal> </entry>
<!--
        <entry>Distance between</entry>
-->
        <entry>距離</entry>
        <entry><literal>circle '((0,0),1)' &lt;-&gt; circle '((5,0),1)'</literal></entry>
       </row>
       <row>
        <entry> <literal>&amp;&amp;</literal> </entry>
<!--
        <entry>Overlaps?  (One point in common makes this true.)</entry>
-->
        <entry>重なっているかどうか？(一つでも共通する点があれば真となります)</entry>
        <entry><literal>box '((0,0),(1,1))' &amp;&amp; box '((0,0),(2,2))'</literal></entry>
       </row>
       <row>
        <entry> <literal>&lt;&lt;</literal> </entry>
<!--
        <entry>Is strictly left of?</entry>
-->
        <entry>厳密に左側にあるか？</entry>
        <entry><literal>circle '((0,0),1)' &lt;&lt; circle '((5,0),1)'</literal></entry>
       </row>
       <row>
        <entry> <literal>&gt;&gt;</literal> </entry>
<!--
        <entry>Is strictly right of?</entry>
-->
        <entry>厳密に右側にあるか？</entry>
        <entry><literal>circle '((5,0),1)' &gt;&gt; circle '((0,0),1)'</literal></entry>
       </row>
       <row>
        <entry> <literal>&amp;&lt;</literal> </entry>
<!--
        <entry>Does not extend to the right of?</entry>
-->
        <entry>右側にはみ出さないか？</entry>
        <entry><literal>box '((0,0),(1,1))' &amp;&lt; box '((0,0),(2,2))'</literal></entry>
       </row>
       <row>
        <entry> <literal>&amp;&gt;</literal> </entry>
<!--
        <entry>Does not extend to the left of?</entry>
-->
        <entry>左側にはみ出さないか？</entry>
        <entry><literal>box '((0,0),(3,3))' &amp;&gt; box '((0,0),(2,2))'</literal></entry>
       </row>
       <row>
        <entry> <literal>&lt;&lt;|</literal> </entry>
<!--
        <entry>Is strictly below?</entry>
-->
        <entry>厳密に下側にあるか？</entry>
        <entry><literal>box '((0,0),(3,3))' &lt;&lt;| box '((3,4),(5,5))'</literal></entry>
       </row>
       <row>
        <entry> <literal>|&gt;&gt;</literal> </entry>
<!--
        <entry>Is strictly above?</entry>
-->
        <entry>厳密に上側にあるか？</entry>
        <entry><literal>box '((3,4),(5,5))' |&gt;&gt; box '((0,0),(3,3))'</literal></entry>
       </row>
       <row>
        <entry> <literal>&amp;&lt;|</literal> </entry>
<!--
        <entry>Does not extend above?</entry>
-->
        <entry>上側に出ていないか？</entry>
        <entry><literal>box '((0,0),(1,1))' &amp;&lt;| box '((0,0),(2,2))'</literal></entry>
       </row>
       <row>
        <entry> <literal>|&amp;&gt;</literal> </entry>
<!--
        <entry>Does not extend below?</entry>
-->
        <entry>下側に出ていないか？</entry>
        <entry><literal>box '((0,0),(3,3))' |&amp;&gt; box '((0,0),(2,2))'</literal></entry>
       </row>
       <row>
        <entry> <literal>&lt;^</literal> </entry>
<!--
        <entry>Is below (allows touching)?</entry>
-->
        <entry>（接触を許可し）下側にあるか？</entry>
        <entry><literal>circle '((0,0),1)' &lt;^ circle '((0,5),1)'</literal></entry>
       </row>
       <row>
        <entry> <literal>&gt;^</literal> </entry>
<!--
        <entry>Is above (allows touching)?</entry>
-->
        <entry>（接触を許可し）上側にあるか？</entry>
        <entry><literal>circle '((0,5),1)' &gt;^ circle '((0,0),1)'</literal></entry>
       </row>
       <row>
        <entry> <literal>?#</literal> </entry>
<!--
        <entry>Intersects?</entry>
-->
        <entry>交わるか？</entry>
        <entry><literal>lseg '((-1,0),(1,0))' ?# box '((-2,-2),(2,2))'</literal></entry>
       </row>
       <row>
        <entry> <literal>?-</literal> </entry>
<!--
        <entry>Is horizontal?</entry>
-->
        <entry>水平か？</entry>
        <entry><literal>?- lseg '((-1,0),(1,0))'</literal></entry>
       </row>
       <row>
        <entry> <literal>?-</literal> </entry>
<!--
        <entry>Are horizontally aligned?</entry>
-->
        <entry>水平方向に揃っているか？</entry>
        <entry><literal>point '(1,0)' ?- point '(0,0)'</literal></entry>
       </row>
       <row>
        <entry> <literal>?|</literal> </entry>
<!--
        <entry>Is vertical?</entry>
-->
        <entry>垂直か？</entry>
        <entry><literal>?| lseg '((-1,0),(1,0))'</literal></entry>
       </row>
       <row>
        <entry> <literal>?|</literal> </entry>
<!--
        <entry>Are vertically aligned?</entry>
-->
        <entry>垂直方向に揃っているか？</entry>
        <entry><literal>point '(0,1)' ?| point '(0,0)'</literal></entry>
       </row>
       <row>
        <entry> <literal>?-|</literal> </entry>
<!--
        <entry>Is perpendicular?</entry>
-->
        <entry>直角をなしているか？</entry>
        <entry><literal>lseg '((0,0),(0,1))' ?-| lseg '((0,0),(1,0))'</literal></entry>
       </row>
       <row>
        <entry> <literal>?||</literal> </entry>
<!--
        <entry>Are parallel?</entry>
-->
        <entry>平行か？</entry>
        <entry><literal>lseg '((-1,0),(1,0))' ?|| lseg '((-1,2),(1,2))'</literal></entry>
       </row>
       <row>
        <entry> <literal>@&gt;</literal> </entry>
<!--
        <entry>Contains?</entry>
-->
        <entry>包含しているか？</entry>
        <entry><literal>circle '((0,0),2)' @&gt; point '(1,1)'</literal></entry>
       </row>
       <row>
        <entry> <literal>&lt;@</literal> </entry>
<!--
        <entry>Contained in or on?</entry>
-->
        <entry>包含されているかもしくは境界上か？</entry>
        <entry><literal>point '(1,1)' &lt;@ circle '((0,0),2)'</literal></entry>
       </row>
       <row>
        <entry> <literal>~=</literal> </entry>
<!--
        <entry>Same as?</entry>
-->
        <entry>同等か？</entry>
        <entry><literal>polygon '((0,0),(1,1))' ~= polygon '((1,1),(0,0))'</literal></entry>
       </row>
      </tbody>
     </tgroup>
   </table>

   <note>
    <para>
<!--
     Before <productname>PostgreSQL</productname> 8.2, the containment
     operators <literal>@&gt;</literal> and <literal>&lt;@</literal> were respectively
     called <literal>~</literal> and <literal>@</literal>.  These names are still
     available, but are deprecated and will eventually be removed.
-->
<productname>PostgreSQL</productname>の8.2より前では、包含演算子<literal>@&gt;</literal>および<literal>&lt;@</literal>はそれぞれ<literal>~</literal>および<literal>@</literal>という名前でした。
これらの名前はまだ利用できますが、削除予定であり最終的にはなくなるでしょう。
    </para>
   </note>

   <indexterm>
    <primary>area</primary>
   </indexterm>
   <indexterm>
    <primary>center</primary>
   </indexterm>
   <indexterm>
    <primary>diameter</primary>
   </indexterm>
   <indexterm>
    <primary>height</primary>
   </indexterm>
   <indexterm>
    <primary>isclosed</primary>
   </indexterm>
   <indexterm>
    <primary>isopen</primary>
   </indexterm>
   <indexterm>
    <primary>length</primary>
   </indexterm>
   <indexterm>
    <primary>npoints</primary>
   </indexterm>
   <indexterm>
    <primary>pclose</primary>
   </indexterm>
   <indexterm>
    <primary>popen</primary>
   </indexterm>
   <indexterm>
    <primary>radius</primary>
   </indexterm>
   <indexterm>
    <primary>width</primary>
   </indexterm>

   <table id="functions-geometry-func-table">
<!--
     <title>Geometric Functions</title>
-->
     <title>幾何データ型関数</title>
     <tgroup cols="4">
      <thead>
       <row>
<!--
        <entry>Function</entry>
        <entry>Return Type</entry>
        <entry>Description</entry>
        <entry>Example</entry>
-->
        <entry>関数</entry>
        <entry>戻り値</entry>
        <entry>説明</entry>
        <entry>例</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><literal><function>area(<replaceable>object</replaceable>)</function></literal></entry>
        <entry><type>double precision</type></entry>
<!--
        <entry>area</entry>
-->
        <entry>面積</entry>
        <entry><literal>area(box '((0,0),(1,1))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>center(<replaceable>object</replaceable>)</function></literal></entry>
        <entry><type>point</type></entry>
<!--
        <entry>center</entry>
-->
        <entry>中心</entry>
        <entry><literal>center(box '((0,0),(1,2))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>diameter(<type>circle</type>)</function></literal></entry>
        <entry><type>double precision</type></entry>
<!--
        <entry>diameter of circle</entry>
-->
        <entry>円の直径</entry>
        <entry><literal>diameter(circle '((0,0),2.0)')</literal></entry>
       </row>
       <row>
        <entry><literal><function>height(<type>box</type>)</function></literal></entry>
        <entry><type>double precision</type></entry>
<!--
        <entry>vertical size of box</entry>
-->
        <entry>矩形の高さ</entry>
        <entry><literal>height(box '((0,0),(1,1))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>isclosed(<type>path</type>)</function></literal></entry>
        <entry><type>boolean</type></entry>
<!--
        <entry>a closed path?</entry>
-->
        <entry>閉経路か？</entry>
        <entry><literal>isclosed(path '((0,0),(1,1),(2,0))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>isopen(<type>path</type>)</function></literal></entry>
        <entry><type>boolean</type></entry>
<!--
        <entry>an open path?</entry>
-->
        <entry>開経路か？</entry>
        <entry><literal>isopen(path '[(0,0),(1,1),(2,0)]')</literal></entry>
       </row>
       <row>
        <entry><literal><function>length(<replaceable>object</replaceable>)</function></literal></entry>
        <entry><type>double precision</type></entry>
<!--
        <entry>length</entry>
-->
        <entry>長さ</entry>
        <entry><literal>length(path '((-1,0),(1,0))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>npoints(<type>path</type>)</function></literal></entry>
        <entry><type>int</type></entry>
<!--
        <entry>number of points</entry>
-->
        <entry>点の数</entry>
        <entry><literal>npoints(path '[(0,0),(1,1),(2,0)]')</literal></entry>
       </row>
       <row>
        <entry><literal><function>npoints(<type>polygon</type>)</function></literal></entry>
        <entry><type>int</type></entry>
<!--
        <entry>number of points</entry>
-->
        <entry>点の数</entry>
        <entry><literal>npoints(polygon '((1,1),(0,0))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>pclose(<type>path</type>)</function></literal></entry>
        <entry><type>path</type></entry>
<!--
        <entry>convert path to closed</entry>
-->
        <entry>閉経路に変換</entry>
        <entry><literal>pclose(path '[(0,0),(1,1),(2,0)]')</literal></entry>
       </row>
       <row>
        <entry><literal><function>popen(<type>path</type>)</function></literal></entry>
        <entry><type>path</type></entry>
<!--
        <entry>convert path to open</entry>
-->
        <entry>開経路に変換</entry>
        <entry><literal>popen(path '((0,0),(1,1),(2,0))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>radius(<type>circle</type>)</function></literal></entry>
        <entry><type>double precision</type></entry>
<!--
        <entry>radius of circle</entry>
-->
        <entry>円の半径</entry>
        <entry><literal>radius(circle '((0,0),2.0)')</literal></entry>
       </row>
       <row>
        <entry><literal><function>width(<type>box</type>)</function></literal></entry>
        <entry><type>double precision</type></entry>
<!--
        <entry>horizontal size of box</entry>
-->
        <entry>矩形の幅</entry>
        <entry><literal>width(box '((0,0),(1,1))')</literal></entry>
       </row>
      </tbody>
     </tgroup>
   </table>

   <table id="functions-geometry-conv-table">
<!--
     <title>Geometric Type Conversion Functions</title>
-->
     <title>幾何型変換関数</title>
     <tgroup cols="4">
      <thead>
       <row>
<!--
        <entry>Function</entry>
        <entry>Return Type</entry>
        <entry>Description</entry>
        <entry>Example</entry>
-->
        <entry>関数</entry>
        <entry>戻り値</entry>
        <entry>説明</entry>
        <entry>例</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>
         <indexterm>
          <primary>box</primary>
         </indexterm>
         <literal><function>box(<type>circle</type>)</function></literal>
        </entry>
        <entry><type>box</type></entry>
<!--
        <entry>circle to box</entry>
-->
        <entry>円を矩形に変換</entry>
        <entry><literal>box(circle '((0,0),2.0)')</literal></entry>
       </row>
       <row>
        <entry><literal><function>box(<type>point</type>)</function></literal></entry>
        <entry><type>box</type></entry>
<!--
        <entry>point to empty box</entry>
-->
        <entry>点を空の矩形に変換</entry>
        <entry><literal>box(point '(0,0)')</literal></entry>
       </row>
       <row>
        <entry><literal><function>box(<type>point</type>, <type>point</type>)</function></literal></entry>
        <entry><type>box</type></entry>
<!--
        <entry>points to box</entry>
-->
        <entry>座標点を矩形に変換</entry>
        <entry><literal>box(point '(0,0)', point '(1,1)')</literal></entry>
       </row>
       <row>
        <entry><literal><function>box(<type>polygon</type>)</function></literal></entry>
        <entry><type>box</type></entry>
<!--
        <entry>polygon to box</entry>
-->
        <entry>多角形を矩形に変換</entry>
        <entry><literal>box(polygon '((0,0),(1,1),(2,0))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>bound_box(<type>box</type>, <type>box</type>)</function></literal></entry>
        <entry><type>box</type></entry>
<!--
        <entry>boxes to bounding box</entry>
-->
        <entry>矩形を外接矩形に変換</entry>
        <entry><literal>bound_box(box '((0,0),(1,1))', box '((3,3),(4,4))')</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>circle</primary>
         </indexterm>
         <literal><function>circle(<type>box</type>)</function></literal>
        </entry>
        <entry><type>circle</type></entry>
<!--
        <entry>box to circle</entry>
-->
        <entry>矩形を円に変換</entry>
        <entry><literal>circle(box '((0,0),(1,1))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>circle(<type>point</type>, <type>double precision</type>)</function></literal></entry>
        <entry><type>circle</type></entry>
<!--
        <entry>center and radius to circle</entry>
-->
        <entry>中心と半径から円に変換</entry>
        <entry><literal>circle(point '(0,0)', 2.0)</literal></entry>
       </row>
       <row>
        <entry><literal><function>circle(<type>polygon</type>)</function></literal></entry>
        <entry><type>circle</type></entry>
<!--
        <entry>polygon to circle</entry>
-->
        <entry>多角形を円に変換</entry>
        <entry><literal>circle(polygon '((0,0),(1,1),(2,0))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>line(<type>point</type>, <type>point</type>)</function></literal></entry>
        <entry><type>line</type></entry>
<!--
        <entry>points to line</entry>
-->
        <entry>座標点を直線に変換</entry>
        <entry><literal>line(point '(-1,0)', point '(1,0)')</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>lseg</primary>
         </indexterm>
         <literal><function>lseg(<type>box</type>)</function></literal>
        </entry>
        <entry><type>lseg</type></entry>
<!--
        <entry>box diagonal to line segment</entry>
-->
        <entry>矩形の対角線を線分に変換</entry>
        <entry><literal>lseg(box '((-1,0),(1,0))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>lseg(<type>point</type>, <type>point</type>)</function></literal></entry>
        <entry><type>lseg</type></entry>
<!--
        <entry>points to line segment</entry>
-->
        <entry>座標点を線分に変換</entry>
        <entry><literal>lseg(point '(-1,0)', point '(1,0)')</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>path</primary>
         </indexterm>
         <literal><function>path(<type>polygon</type>)</function></literal>
        </entry>
        <entry><type>path</type></entry>
<!--
        <entry>polygon to path</entry>
-->
        <entry>多角形を経路に変換</entry>
        <entry><literal>path(polygon '((0,0),(1,1),(2,0))')</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>point</primary>
         </indexterm>
         <literal><function>point</function>(<type>double
         precision</type>, <type>double precision</type>)</literal>
        </entry>
        <entry><type>point</type></entry>
<!--
        <entry>construct point</entry>
-->
        <entry>座標点の構築</entry>
        <entry><literal>point(23.4, -44.5)</literal></entry>
       </row>
       <row>
        <entry><literal><function>point(<type>box</type>)</function></literal></entry>
        <entry><type>point</type></entry>
<!--
        <entry>center of box</entry>
-->
        <entry>矩形の中心</entry>
        <entry><literal>point(box '((-1,0),(1,0))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>point(<type>circle</type>)</function></literal></entry>
        <entry><type>point</type></entry>
<!--
        <entry>center of circle</entry>
-->
        <entry>円の中心</entry>
        <entry><literal>point(circle '((0,0),2.0)')</literal></entry>
       </row>
       <row>
        <entry><literal><function>point(<type>lseg</type>)</function></literal></entry>
        <entry><type>point</type></entry>
<!--
        <entry>center of line segment</entry>
-->
        <entry>線分の中心</entry>
        <entry><literal>point(lseg '((-1,0),(1,0))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>point(<type>polygon</type>)</function></literal></entry>
        <entry><type>point</type></entry>
<!--
        <entry>center of polygon</entry>
-->
        <entry>多角形の中心</entry>
        <entry><literal>point(polygon '((0,0),(1,1),(2,0))')</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>polygon</primary>
         </indexterm>
         <literal><function>polygon(<type>box</type>)</function></literal>
        </entry>
        <entry><type>polygon</type></entry>
<!--
        <entry>box to 4-point polygon</entry>
-->
        <entry>矩形を4頂点の多角形に変換</entry>
        <entry><literal>polygon(box '((0,0),(1,1))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>polygon(<type>circle</type>)</function></literal></entry>
        <entry><type>polygon</type></entry>
<!--
        <entry>circle to 12-point polygon</entry>
-->
        <entry>円を12角形に変換</entry>
        <entry><literal>polygon(circle '((0,0),2.0)')</literal></entry>
       </row>
       <row>
        <entry><literal><function>polygon(<replaceable class="parameter">npts</replaceable>, <type>circle</type>)</function></literal></entry>
        <entry><type>polygon</type></entry>
<!--
        <entry>circle to <replaceable class="parameter">npts</replaceable>-point polygon</entry>
-->
        <entry>円を<replaceable class="parameter">npts</replaceable>角形に変換</entry>
        <entry><literal>polygon(12, circle '((0,0),2.0)')</literal></entry>
       </row>
       <row>
        <entry><literal><function>polygon(<type>path</type>)</function></literal></entry>
        <entry><type>polygon</type></entry>
<!--
        <entry>path to polygon</entry>
-->
        <entry>経路を多角形に変換</entry>
        <entry><literal>polygon(path '((0,0),(1,1),(2,0))')</literal></entry>
       </row>
      </tbody>
     </tgroup>
   </table>

    <para>
<!--
     It is possible to access the two component numbers of a <type>point</type>
     as though the point were an array with indexes 0 and 1.  For example, if
     <literal>t.p</literal> is a <type>point</type> column then
     <literal>SELECT p[0] FROM t</literal> retrieves the X coordinate and
     <literal>UPDATE t SET p[1] = ...</literal> changes the Y coordinate.
     In the same way, a value of type <type>box</type> or <type>lseg</type> can be treated
     as an array of two <type>point</type> values.
-->
あたかもpointは添字0、1を有する配列であるかのように、<type>point</type>の２つの構成要素にアクセスすることができます。
例えば、<literal>t.p</literal>が<type>point</type>列の場合、<literal>SELECT p[0] FROM t</literal>という式でX座標を抽出できます。また、<literal>UPDATE t SET p[1] = ...</literal>でY座標を変更できます。
同様に、<type>box</type>型または<type>lseg</type>型の値も、2つの<type>point</type>型の値の配列のように扱えます。
    </para>

    <para>
<!--
     The <function>area</function> function works for the types
     <type>box</type>, <type>circle</type>, and <type>path</type>.
     The <function>area</function> function only works on the
     <type>path</type> data type if the points in the
     <type>path</type> are non-intersecting.  For example, the
     <type>path</type>
     <literal>'((0,0),(0,1),(2,1),(2,2),(1,2),(1,0),(0,0))'::PATH</literal>
     will not work;  however, the following visually identical
     <type>path</type>
     <literal>'((0,0),(0,1),(1,1),(1,2),(2,2),(2,1),(1,1),(1,0),(0,0))'::PATH</literal>
     will work.  If the concept of an intersecting versus
     non-intersecting <type>path</type> is confusing, draw both of the
     above <type>path</type>s side by side on a piece of graph paper.
-->
<function>area</function>関数は、<type>box</type>、<type>circle</type>、<type>path</type>型に対して動作します。
<type>path</type>データ型に対する<function>area</function>関数は、その<type>path</type>が交差しない場合にのみ動作します。
例えば、<literal>'((0,0),(0,1),(2,1),(2,2),(1,2),(1,0),(0,0))'::PATH</literal>という<type>path</type>は動作しません。しかし、見た目は同じですが、<literal>'((0,0),(0,1),(1,1),(1,2),(2,2),(2,1),(1,1),(1,0),(0,0))'::PATH</literal>という<type>path</type>では動作します。
<type>path</type>の交差する、しないという概念がよくわからなければ、上の2つの<type>path</type>を並べてグラフ用紙に書いてみてください。
    </para>

  </sect1>


 <sect1 id="functions-net">
<!--
  <title>Network Address Functions and Operators</title>
-->
  <title>ネットワークアドレス関数と演算子</title>

  <para>
<!--
   <xref linkend="cidr-inet-operators-table"/> shows the operators
   available for the <type>cidr</type> and <type>inet</type> types.
   The operators <literal>&lt;&lt;</literal>,
   <literal>&lt;&lt;=</literal>, <literal>&gt;&gt;</literal>,
   <literal>&gt;&gt;=</literal>, and <literal>&amp;&amp;</literal>
   test for subnet inclusion.  They
   consider only the network parts of the two addresses (ignoring any
   host part) and determine whether one network is identical to
   or a subnet of the other.
-->
<xref linkend="cidr-inet-operators-table"/>に、<type>inet</type>型および<type>cidr</type>型で使用可能な演算子を示します。
演算子 <literal>&lt;&lt;</literal>、<literal>&lt;&lt;=</literal>、<literal>&gt;&gt;</literal>、<literal>&gt;&gt;=</literal>および<literal>&amp;&amp;</literal>はサブネットの包含関係を調べるものです。
これらは2つのアドレスのネットワークの部分のみを考慮（ホスト部分を無視）して2つのネットワークアドレスが等しいか、もしくは一方のネットワークが他方のサブネットになっているかを特定します。
  </para>

    <table id="cidr-inet-operators-table">
<!--
     <title><type>cidr</type> and <type>inet</type> Operators</title>
-->
     <title><type>cidr</type>と<type>inet</type>演算子</title>
     <tgroup cols="3">
      <thead>
       <row>
<!--
        <entry>Operator</entry>
        <entry>Description</entry>
        <entry>Example</entry>
-->
        <entry>演算子</entry>
        <entry>説明</entry>
        <entry>例</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry> <literal>&lt;</literal> </entry>
<!--
        <entry>is less than</entry>
-->
        <entry>未満</entry>
        <entry><literal>inet '192.168.1.5' &lt; inet '192.168.1.6'</literal></entry>
       </row>
       <row>
        <entry> <literal>&lt;=</literal> </entry>
<!--
        <entry>is less than or equal</entry>
-->
        <entry>未満もしくは等しい（以下）</entry>
        <entry><literal>inet '192.168.1.5' &lt;= inet '192.168.1.5'</literal></entry>
       </row>
       <row>
        <entry> <literal>=</literal> </entry>
<!--
        <entry>equals</entry>
-->
        <entry>等しい</entry>
        <entry><literal>inet '192.168.1.5' = inet '192.168.1.5'</literal></entry>
       </row>
       <row>
        <entry> <literal>&gt;=</literal> </entry>
<!--
        <entry>is greater or equal</entry>
-->
        <entry>より大きいもしくは等しい（以上）</entry>
        <entry><literal>inet '192.168.1.5' &gt;= inet '192.168.1.5'</literal></entry>
       </row>
       <row>
        <entry> <literal>&gt;</literal> </entry>
<!--
        <entry>is greater than</entry>
-->
        <entry>より大きい</entry>
        <entry><literal>inet '192.168.1.5' &gt; inet '192.168.1.4'</literal></entry>
       </row>
       <row>
        <entry> <literal>&lt;&gt;</literal> </entry>
<!--
        <entry>is not equal</entry>
-->
        <entry>等しくない</entry>
        <entry><literal>inet '192.168.1.5' &lt;&gt; inet '192.168.1.4'</literal></entry>
       </row>
       <row>
        <entry> <literal>&lt;&lt;</literal> </entry>
<!--
        <entry>is contained by</entry>
-->
        <entry>内包される</entry>
        <entry><literal>inet '192.168.1.5' &lt;&lt; inet '192.168.1/24'</literal></entry>
       </row>
       <row>
        <entry> <literal>&lt;&lt;=</literal> </entry>
<!--
        <entry>is contained by or equals</entry>
-->
        <entry>内包されるか等しい</entry>
        <entry><literal>inet '192.168.1/24' &lt;&lt;= inet '192.168.1/24'</literal></entry>
       </row>
       <row>
        <entry> <literal>&gt;&gt;</literal> </entry>
<!--
        <entry>contains</entry>
-->
        <entry>内包する</entry>
        <entry><literal>inet '192.168.1/24' &gt;&gt; inet '192.168.1.5'</literal></entry>
       </row>
       <row>
        <entry> <literal>&gt;&gt;=</literal> </entry>
<!--
        <entry>contains or equals</entry>
-->
        <entry>内包するか等しい</entry>
        <entry><literal>inet '192.168.1/24' &gt;&gt;= inet '192.168.1/24'</literal></entry>
       </row>
       <row>
        <entry> <literal>&amp;&amp;</literal> </entry>
<!--
        <entry>contains or is contained by</entry>
-->
        <entry>内包するか内包されるか</entry>
        <entry><literal>inet '192.168.1/24' &amp;&amp; inet '192.168.1.80/28'</literal></entry>
       </row>
       <row>
        <entry> <literal>~</literal> </entry>
<!--
        <entry>bitwise NOT</entry>
-->
        <entry>ビット否定</entry>
        <entry><literal>~ inet '192.168.1.6'</literal></entry>
       </row>
       <row>
        <entry> <literal>&amp;</literal> </entry>
<!--
        <entry>bitwise AND</entry>
-->
        <entry>ビット積</entry>
        <entry><literal>inet '192.168.1.6' &amp; inet '0.0.0.255'</literal></entry>
       </row>
       <row>
        <entry> <literal>|</literal> </entry>
<!--
        <entry>bitwise OR</entry>
-->
        <entry>ビット和</entry>
        <entry><literal>inet '192.168.1.6' | inet '0.0.0.255'</literal></entry>
       </row>
       <row>
        <entry> <literal>+</literal> </entry>
<!--
        <entry>addition</entry>
-->
        <entry>加算</entry>
        <entry><literal>inet '192.168.1.6' + 25</literal></entry>
       </row>
       <row>
        <entry> <literal>-</literal> </entry>
<!--
        <entry>subtraction</entry>
-->
        <entry>減算</entry>
        <entry><literal>inet '192.168.1.43' - 36</literal></entry>
       </row>
       <row>
        <entry> <literal>-</literal> </entry>
<!--
        <entry>subtraction</entry>
-->
        <entry>減算</entry>
        <entry><literal>inet '192.168.1.43' - inet '192.168.1.19'</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

  <para>
<!--
   <xref linkend="cidr-inet-functions-table"/> shows the functions
   available for use with the <type>cidr</type> and <type>inet</type>
   types.  The <function>abbrev</function>, <function>host</function>,
   and <function>text</function>
   functions are primarily intended to offer alternative display
   formats.
-->
<xref linkend="cidr-inet-functions-table"/>に、<type>inet</type>型および<type>cidr</type>型で使用可能な関数を示します。
関数<function>abbrev</function>、<function>host</function>、および<function>text</function>、は主として、代替の整形表示を提供する目的のものです。
  </para>

    <table id="cidr-inet-functions-table">
<!--
     <title><type>cidr</type> and <type>inet</type> Functions</title>
-->
     <title><type>cidr</type>および<type>inet</type>型関数</title>
     <tgroup cols="5">
      <thead>
       <row>
<!--
        <entry>Function</entry>
        <entry>Return Type</entry>
        <entry>Description</entry>
        <entry>Example</entry>
        <entry>Result</entry>
-->
        <entry>関数</entry>
        <entry>戻り値</entry>
        <entry>説明</entry>
        <entry>例</entry>
        <entry>結果</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>
         <indexterm>
          <primary>abbrev</primary>
         </indexterm>
         <literal><function>abbrev(<type>inet</type>)</function></literal>
        </entry>
        <entry><type>text</type></entry>
<!--
        <entry>abbreviated display format as text</entry>
-->
        <entry>表示用テキスト省略形</entry>
        <entry><literal>abbrev(inet '10.1.0.0/16')</literal></entry>
        <entry><literal>10.1.0.0/16</literal></entry>
       </row>
       <row>
        <entry><literal><function>abbrev(<type>cidr</type>)</function></literal></entry>
        <entry><type>text</type></entry>
<!--
        <entry>abbreviated display format as text</entry>
-->
        <entry>表示用テキスト省略形</entry>
        <entry><literal>abbrev(cidr '10.1.0.0/16')</literal></entry>
        <entry><literal>10.1/16</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>broadcast</primary>
         </indexterm>
         <literal><function>broadcast(<type>inet</type>)</function></literal>
        </entry>
        <entry><type>inet</type></entry>
<!--
        <entry>broadcast address for network</entry>
-->
        <entry>ネットワークブロードキャストアドレス</entry>
        <entry><literal>broadcast('192.168.1.5/24')</literal></entry>
        <entry><literal>192.168.1.255/24</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>family</primary>
         </indexterm>
         <literal><function>family(<type>inet</type>)</function></literal>
        </entry>
        <entry><type>int</type></entry>
<!--
        <entry>extract family of address; <literal>4</literal> for IPv4,
         <literal>6</literal> for IPv6</entry>
-->
         <entry>アドレスファミリの取り出し。IPv4では<literal>4</literal>、IPv6では<literal>6</literal>。</entry>
        <entry><literal>family('::1')</literal></entry>
        <entry><literal>6</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>host</primary>
         </indexterm>
         <literal><function>host(<type>inet</type>)</function></literal>
        </entry>
        <entry><type>text</type></entry>
<!--
        <entry>extract IP address as text</entry>
-->
        <entry>IPアドレスをテキストで抽出</entry>
        <entry><literal>host('192.168.1.5/24')</literal></entry>
        <entry><literal>192.168.1.5</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>hostmask</primary>
         </indexterm>
         <literal><function>hostmask(<type>inet</type>)</function></literal>
        </entry>
        <entry><type>inet</type></entry>
<!--
        <entry>construct host mask for network</entry>
-->
        <entry>ネットワーク用のホストマスクの構築</entry>
        <entry><literal>hostmask('192.168.23.20/30')</literal></entry>
        <entry><literal>0.0.0.3</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>masklen</primary>
         </indexterm>
         <literal><function>masklen(<type>inet</type>)</function></literal>
        </entry>
        <entry><type>int</type></entry>
<!--
        <entry>extract netmask length</entry>
-->
        <entry>ネットマスク長の抽出</entry>
        <entry><literal>masklen('192.168.1.5/24')</literal></entry>
        <entry><literal>24</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>netmask</primary>
         </indexterm>
         <literal><function>netmask(<type>inet</type>)</function></literal>
        </entry>
        <entry><type>inet</type></entry>
<!--
        <entry>construct netmask for network</entry>
-->
        <entry>ネットワーク用ネットマスクの構築</entry>
        <entry><literal>netmask('192.168.1.5/24')</literal></entry>
        <entry><literal>255.255.255.0</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>network</primary>
         </indexterm>
         <literal><function>network(<type>inet</type>)</function></literal>
        </entry>
        <entry><type>cidr</type></entry>
<!--
        <entry>extract network part of address</entry>
-->
        <entry>ネットワークアドレスからネットワーク部を抽出</entry>
        <entry><literal>network('192.168.1.5/24')</literal></entry>
        <entry><literal>192.168.1.0/24</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>set_masklen</primary>
         </indexterm>
         <literal><function>set_masklen(<type>inet</type>, <type>int</type>)</function></literal>
        </entry>
        <entry><type>inet</type></entry>
<!--
        <entry>set netmask length for <type>inet</type> value</entry>
-->
        <entry><type>inet</type>値のネットマスク長を設定</entry>
        <entry><literal>set_masklen('192.168.1.5/24', 16)</literal></entry>
        <entry><literal>192.168.1.5/16</literal></entry>
       </row>
       <row>
        <entry><literal><function>set_masklen(<type>cidr</type>, <type>int</type>)</function></literal></entry>
        <entry><type>cidr</type></entry>
<!--
        <entry>set netmask length for <type>cidr</type> value</entry>
-->
        <entry><type>cidr</type>値のネットマスク長を設定</entry>
        <entry><literal>set_masklen('192.168.1.0/24'::cidr, 16)</literal></entry>
        <entry><literal>192.168.0.0/16</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>text</primary>
         </indexterm>
         <literal><function>text(<type>inet</type>)</function></literal>
        </entry>
        <entry><type>text</type></entry>
<!--
        <entry>extract IP address and netmask length as text</entry>
-->
        <entry>IPアドレスとネットマスク長をテキストで抽出</entry>
        <entry><literal>text(inet '192.168.1.5')</literal></entry>
        <entry><literal>192.168.1.5/32</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>inet_same_family</primary>
         </indexterm>
         <literal><function>inet_same_family(<type>inet</type>, <type>inet</type>)</function></literal>
        </entry>
        <entry><type>boolean</type></entry>
<!--
        <entry>are the addresses from the same family?</entry>
-->
        <entry>同じアドレスファミリかどうかを返す</entry>
        <entry><literal>inet_same_family('192.168.1.5/24', '::1')</literal></entry>
        <entry><literal>false</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>inet_merge</primary>
         </indexterm>
         <literal><function>inet_merge(<type>inet</type>, <type>inet</type>)</function></literal>
        </entry>
        <entry><type>cidr</type></entry>
<!--
        <entry>the smallest network which includes both of the given networks</entry>
-->
        <entry>両方のネットワークを含む最小のネットワークを返す</entry>
        <entry><literal>inet_merge('192.168.1.5/24', '192.168.2.5/24')</literal></entry>
        <entry><literal>192.168.0.0/22</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

  <para>
<!--
   Any <type>cidr</type> value can be cast to <type>inet</type> implicitly
   or explicitly; therefore, the functions shown above as operating on
   <type>inet</type> also work on <type>cidr</type> values.  (Where there are
   separate functions for <type>inet</type> and <type>cidr</type>, it is because
   the behavior should be different for the two cases.)
   Also, it is permitted to cast an <type>inet</type> value to <type>cidr</type>.
   When this is done, any bits to the right of the netmask are silently zeroed
   to create a valid <type>cidr</type> value.
   In addition,
   you can cast a text value to <type>inet</type> or <type>cidr</type>
   using normal casting syntax: for example,
   <literal>inet(<replaceable>expression</replaceable>)</literal> or
   <literal><replaceable>colname</replaceable>::cidr</literal>.
-->
<type>cidr</type>値はすべて、暗黙的または明示的に<type>inet</type>型にキャスト可能です。
したがって、上で示した<type>inet</type>に対する操作を行う関数は<type>cidr</type>値でも動作します。
（<type>inet</type>と<type>cidr</type>で別々に関数が存在するものがありますが、それは、この2つで動作に違いがあるためです。）
また、<type>inet</type>値から<type>cidr</type>へのキャストも許されます。これが行われると、ネットマスクの右側のビットは、<type>cidr</type>として有効な値とするために0となります。
さらに、通常のキャスト構文、例えば、<literal>inet(<replaceable>expression</replaceable>)</literal>や<literal><replaceable>colname</replaceable>::cidr</literal>を使用して、テキスト値を<type>inet</type>や<type>cidr</type>にキャストすることもできます。
  </para>

  <para>
<!--
   <xref linkend="macaddr-functions-table"/> shows the functions
   available for use with the <type>macaddr</type> type.  The function
   <literal><function>trunc(<type>macaddr</type>)</function></literal> returns a MAC
   address with the last 3 bytes set to zero.  This can be used to
   associate the remaining prefix with a manufacturer.
-->
<xref linkend="macaddr-functions-table"/>に、<type>macaddr</type>型で使用可能な関数を示します。
関数<literal><function>trunc(<type>macaddr</type>)</function></literal>は終わりの3バイトがゼロに設定されたMACアドレスを返します。
これは、残った接頭部を製造者に対応させることに使えます。
  </para>

    <table id="macaddr-functions-table">
<!--
     <title><type>macaddr</type> Functions</title>
-->
     <title><type>macaddr</type>型関数</title>
     <tgroup cols="5">
      <thead>
       <row>
<!--
        <entry>Function</entry>
        <entry>Return Type</entry>
        <entry>Description</entry>
        <entry>Example</entry>
        <entry>Result</entry>
-->
        <entry>関数</entry>
        <entry>戻り値</entry>
        <entry>説明</entry>
        <entry>例</entry>
        <entry>結果</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>
         <indexterm>
          <primary>trunc</primary>
         </indexterm>
         <literal><function>trunc(<type>macaddr</type>)</function></literal>
        </entry>
        <entry><type>macaddr</type></entry>
<!--
        <entry>set last 3 bytes to zero</entry>
-->
        <entry>終わりの３バイトをゼロに設定</entry>
        <entry><literal>trunc(macaddr '12:34:56:78:90:ab')</literal></entry>
        <entry><literal>12:34:56:00:00:00</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
<!--
    The <type>macaddr</type> type also supports the standard relational
    operators (<literal>&gt;</literal>, <literal>&lt;=</literal>, etc.) for
    lexicographical ordering, and the bitwise arithmetic operators
    (<literal>~</literal>, <literal>&amp;</literal> and <literal>|</literal>)
    for NOT, AND and OR.
-->
<type>macaddr</type>型は（<literal>&gt;</literal>、<literal>&lt;=</literal>等の）辞書編集順に並べる標準関係演算子とNOT、AND、ORのビット演算子(<literal>~</literal>、<literal>&amp;</literal>、<literal>|</literal>)もサポートしています。
   </para>

   <para>
<!--
   <xref linkend="macaddr8-functions-table"/> shows the functions
   available for use with the <type>macaddr8</type> type.  The function
   <literal><function>trunc(<type>macaddr8</type>)</function></literal> returns a MAC
   address with the last 5 bytes set to zero.  This can be used to
   associate the remaining prefix with a manufacturer.
-->
<type>macaddr8</type>型で利用できる関数を<xref linkend="macaddr8-functions-table"/>に示します。
関数<literal><function>trunc(<type>macaddr8</type>)</function></literal>は終わりの5バイトをゼロに設定したMACアドレスを返します。
これは、残りの先頭部分を製造者と紐付けるのに使用できます。
  </para>

    <table id="macaddr8-functions-table">
<!--
     <title><type>macaddr8</type> Functions</title>
-->
     <title><type>macaddr8</type>関数</title>
     <tgroup cols="5">
      <thead>
       <row>
<!--
        <entry>Function</entry>
        <entry>Return Type</entry>
        <entry>Description</entry>
        <entry>Example</entry>
        <entry>Result</entry>
-->
        <entry>関数</entry>
        <entry>戻り値</entry>
        <entry>説明</entry>
        <entry>例</entry>
        <entry>結果</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>
         <indexterm>
          <primary>trunc</primary>
         </indexterm>
         <literal><function>trunc(<type>macaddr8</type>)</function></literal>
        </entry>
        <entry><type>macaddr8</type></entry>
<!--
        <entry>set last 5 bytes to zero</entry>
-->
        <entry>終わりの5バイトをゼロにする</entry>
        <entry><literal>trunc(macaddr8 '12:34:56:78:90:ab:cd:ef')</literal></entry>
        <entry><literal>12:34:56:00:00:00:00:00</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>macaddr8_set7bit</primary>
         </indexterm>
         <literal><function>macaddr8_set7bit(<type>macaddr8</type>)</function></literal>
        </entry>
        <entry><type>macaddr8</type></entry>
<!--
        <entry>set 7th bit to one, also known as modified EUI-64, for inclusion in an IPv6 address</entry>
-->
        <entry>7番目のビットを1にし、修正EUI-64と呼ばれる形式にして、IPv6アドレスに含められるようにする</entry>
        <entry><literal>macaddr8_set7bit(macaddr8 '00:34:56:ab:cd:ef')</literal></entry>
        <entry><literal>02:34:56:ff:fe:ab:cd:ef</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
<!--
    The <type>macaddr8</type> type also supports the standard relational
    operators (<literal>&gt;</literal>, <literal>&lt;=</literal>, etc.) for
    ordering, and the bitwise arithmetic operators (<literal>~</literal>,
    <literal>&amp;</literal> and <literal>|</literal>) for NOT, AND and OR.
-->
<type>macaddr8</type>型は、順序付けのための標準的関係演算（<literal>&gt;</literal>、<literal>&lt;=</literal>など）およびNOT、AND、ORに関するビットごとの算術演算（<literal>~</literal>、<literal>&amp;</literal>、<literal>|</literal>）もサポートします。
   </para>

  </sect1>


 <sect1 id="functions-textsearch">
<!--
  <title>Text Search Functions and Operators</title>
-->
  <title>テキスト検索関数と演算子</title>

   <indexterm zone="datatype-textsearch">
<!--
    <primary>full text search</primary>
    <secondary>functions and operators</secondary>
-->
    <primary>全文テキスト検索</primary>
    <secondary>関数と演算子</secondary>
   </indexterm>

   <indexterm zone="datatype-textsearch">
<!--
    <primary>text search</primary>
    <secondary>functions and operators</secondary>
-->
    <primary>テキスト検索</primary>
    <secondary>関数と演算子</secondary>
   </indexterm>

  <para>
<!--
   <xref linkend="textsearch-operators-table"/>,
   <xref linkend="textsearch-functions-table"/> and
   <xref linkend="textsearch-functions-debug-table"/>
   summarize the functions and operators that are provided
   for full text searching.  See <xref linkend="textsearch"/> for a detailed
   explanation of <productname>PostgreSQL</productname>'s text search
   facility.
-->
<xref linkend="textsearch-operators-table"/>、<xref linkend="textsearch-functions-table"/>および<xref linkend="textsearch-functions-debug-table"/>は全文検索用に提供されている関数と演算子を要約しています。<productname>PostgreSQL</productname>のテキスト検索機能の詳細は<xref linkend="textsearch"/>を参照してください。
  </para>

    <table id="textsearch-operators-table">
<!--
     <title>Text Search Operators</title>
-->
     <title>テキスト検索演算子</title>
     <tgroup cols="5">
      <thead>
       <row>
<!--
        <entry>Operator</entry>
        <entry>Return Type</entry>
        <entry>Description</entry>
        <entry>Example</entry>
        <entry>Result</entry>
-->
        <entry>演算子</entry>
        <entry>戻り値型</entry>
        <entry>説明</entry>
        <entry>例</entry>
        <entry>結果</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry> <literal>@@</literal> </entry>
        <entry><type>boolean</type></entry>
<!--
        <entry><type>tsvector</type> matches <type>tsquery</type> ?</entry>
-->
        <entry><type>tsvector</type>が<type>tsquery</type>の条件に合うか？</entry>
        <entry><literal>to_tsvector('fat cats ate rats') @@ to_tsquery('cat &amp; rat')</literal></entry>
        <entry><literal>t</literal></entry>
       </row>
       <row>
        <entry> <literal>@@@</literal> </entry>
        <entry><type>boolean</type></entry>
<!--
        <entry>deprecated synonym for <literal>@@</literal></entry>
-->
        <entry><literal>@@</literal>に対する廃止予定の同義語</entry>
        <entry><literal>to_tsvector('fat cats ate rats') @@@ to_tsquery('cat &amp; rat')</literal></entry>
        <entry><literal>t</literal></entry>
       </row>
       <row>
        <entry> <literal>||</literal> </entry>
        <entry><type>tsvector</type></entry>
<!--
        <entry>concatenate <type>tsvector</type>s</entry>
-->
        <entry><type>tsvector</type>を連結</entry>
        <entry><literal>'a:1 b:2'::tsvector || 'c:1 d:2 b:3'::tsvector</literal></entry>
        <entry><literal>'a':1 'b':2,5 'c':3 'd':4</literal></entry>
       </row>
       <row>
        <entry> <literal>&amp;&amp;</literal> </entry>
        <entry><type>tsquery</type></entry>
<!--
        <entry>AND <type>tsquery</type>s together</entry>
-->
        <entry><type>tsquery</type>にAND演算を行う</entry>
        <entry><literal>'fat | rat'::tsquery &amp;&amp; 'cat'::tsquery</literal></entry>
        <entry><literal>( 'fat' | 'rat' ) &amp; 'cat'</literal></entry>
       </row>
       <row>
        <entry> <literal>||</literal> </entry>
        <entry><type>tsquery</type></entry>
<!--
        <entry>OR <type>tsquery</type>s together</entry>
-->
        <entry><type>tsquery</type>にOR演算を行う</entry>
        <entry><literal>'fat | rat'::tsquery || 'cat'::tsquery</literal></entry>
        <entry><literal>( 'fat' | 'rat' ) | 'cat'</literal></entry>
       </row>
       <row>
        <entry> <literal>!!</literal> </entry>
        <entry><type>tsquery</type></entry>
<!--
        <entry>negate a <type>tsquery</type></entry>
-->
        <entry><type>tsquery</type>を否定</entry>
        <entry><literal>!! 'cat'::tsquery</literal></entry>
        <entry><literal>!'cat'</literal></entry>
       </row>
       <row>
        <entry> <literal>&lt;-&gt;</literal> </entry>
        <entry><type>tsquery</type></entry>
<!--
        <entry><type>tsquery</type> followed by <type>tsquery</type></entry>
-->
        <entry><type>tsquery</type>に続く<type>tsquery</type></entry>
        <entry><literal>to_tsquery('fat') &lt;-&gt; to_tsquery('rat')</literal></entry>
        <entry><literal>'fat' &lt;-&gt; 'rat'</literal></entry>
       </row>
       <row>
        <entry> <literal>@&gt;</literal> </entry>
        <entry><type>boolean</type></entry>
<!--
        <entry><type>tsquery</type> contains another ?</entry>
-->
        <entry><type>tsquery</type>は他方を包含するか？</entry>
        <entry><literal>'cat'::tsquery @&gt; 'cat &amp; rat'::tsquery</literal></entry>
        <entry><literal>f</literal></entry>
       </row>
       <row>
        <entry> <literal>&lt;@</literal> </entry>
        <entry><type>boolean</type></entry>
<!--
        <entry><type>tsquery</type> is contained in ?</entry>
-->
        <entry><type>tsquery</type>は他方に包含されるか？</entry>
        <entry><literal>'cat'::tsquery &lt;@ 'cat &amp; rat'::tsquery</literal></entry>
        <entry><literal>t</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

    <note>
     <para>
<!--
      The <type>tsquery</type> containment operators consider only the lexemes
      listed in the two queries, ignoring the combining operators.
-->
<type>tsquery</type>の包含演算子は２つの問い合わせで列挙された語彙素のみを対象とし、結合演算子を無視します。
     </para>
    </note>

    <para>
<!--
     In addition to the operators shown in the table, the ordinary B-tree
     comparison operators (<literal>=</literal>, <literal>&lt;</literal>, etc) are defined
     for types <type>tsvector</type> and <type>tsquery</type>.  These are not very
     useful for text searching but allow, for example, unique indexes to be
     built on columns of these types.
-->
表に示された演算子に加え、通常のB-tree比較演算子（<literal>=</literal>、<literal>&lt;</literal>など）が、型<type>tsvector</type>および<type>tsquery</type>に対して定義されます。
これらはテキスト検索に対してそれほど有用ではありませんが、例えばこれらの型の列に一意インデックスを作成することを可能にします。
    </para>

    <table id="textsearch-functions-table">
<!--
     <title>Text Search Functions</title>
-->
     <title>テキスト検索関数</title>
     <tgroup cols="5">
      <thead>
       <row>
<!--
        <entry>Function</entry>
        <entry>Return Type</entry>
        <entry>Description</entry>
        <entry>Example</entry>
        <entry>Result</entry>
-->
        <entry>関数</entry>
        <entry>戻り値型</entry>
        <entry>説明</entry>
        <entry>例</entry>
        <entry>結果</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>
         <indexterm>
          <primary>array_to_tsvector</primary>
         </indexterm>
         <literal><function>array_to_tsvector(<type>text[]</type>)</function></literal>
        </entry>
        <entry><type>tsvector</type></entry>
<!--
        <entry>convert array of lexemes to <type>tsvector</type></entry>
-->
        <entry>語彙素の配列を<type>tsvector</type>に変換</entry>
        <entry><literal>array_to_tsvector('{fat,cat,rat}'::text[])</literal></entry>
        <entry><literal>'cat' 'fat' 'rat'</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>get_current_ts_config</primary>
         </indexterm>
         <literal><function>get_current_ts_config()</function></literal>
        </entry>
        <entry><type>regconfig</type></entry>
<!--
        <entry>get default text search configuration</entry>
-->
        <entry>
         デフォルトのテキスト検索設定の取得
        </entry>
        <entry><literal>get_current_ts_config()</literal></entry>
        <entry><literal>english</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>length</primary>
         </indexterm>
         <literal><function>length(<type>tsvector</type>)</function></literal>
        </entry>
        <entry><type>integer</type></entry>
<!--
        <entry>number of lexemes in <type>tsvector</type></entry>
-->
        <entry><type>tsvector</type>にある語彙素の数</entry>
        <entry><literal>length('fat:2,4 cat:3 rat:5A'::tsvector)</literal></entry>
        <entry><literal>3</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>numnode</primary>
         </indexterm>
         <literal><function>numnode(<type>tsquery</type>)</function></literal>
        </entry>
        <entry><type>integer</type></entry>
<!--
        <entry>number of lexemes plus operators in <type>tsquery</type></entry>
-->
        <entry>
         <type>tsquery</type>にある語彙素の数と演算子の数の和
        </entry>
        <entry><literal> numnode('(fat &amp; rat) | cat'::tsquery)</literal></entry>
        <entry><literal>5</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>plainto_tsquery</primary>
         </indexterm>
         <literal><function>plainto_tsquery(<optional> <replaceable class="parameter">config</replaceable> <type>regconfig</type> , </optional> <replaceable class="parameter">query</replaceable> <type>text</type>)</function></literal>
        </entry>
        <entry><type>tsquery</type></entry>
<!--
        <entry>produce <type>tsquery</type> ignoring punctuation</entry>
-->
        <entry>句読点を無視して、<type>tsquery</type>を作成</entry>
        <entry><literal>plainto_tsquery('english', 'The Fat Rats')</literal></entry>
        <entry><literal>'fat' &amp; 'rat'</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>phraseto_tsquery</primary>
         </indexterm>
         <literal><function>phraseto_tsquery(<optional> <replaceable class="parameter">config</replaceable> <type>regconfig</type> , </optional> <replaceable class="parameter">query</replaceable> <type>text</type>)</function></literal>
        </entry>
        <entry><type>tsquery</type></entry>
<!--
        <entry>produce <type>tsquery</type> that searches for a phrase,
         ignoring punctuation</entry>
-->
        <entry>句読点を無視して、語句を検索する<type>tsquery</type>を生成</entry>
        <entry><literal>phraseto_tsquery('english', 'The Fat Rats')</literal></entry>
        <entry><literal>'fat' &lt;-&gt; 'rat'</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>websearch_to_tsquery</primary>
         </indexterm>
          <literal><function>websearch_to_tsquery(<optional> <replaceable class="parameter">config</replaceable> <type>regconfig</type> , </optional> <replaceable class="parameter">query</replaceable> <type>text</type>)</function></literal>
         </entry>
        <entry><type>tsquery</type></entry>
<!--
        <entry>produce <type>tsquery</type> from a web search style query</entry>
-->
        <entry>web検索形式の問い合わせから<type>tsquery</type>を生成</entry>
        <entry><literal>websearch_to_tsquery('english', '"fat rat" or rat')</literal></entry>
        <entry><literal>'fat' &lt;-&gt; 'rat' | 'rat'</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>querytree</primary>
         </indexterm>
         <literal><function>querytree(<replaceable class="parameter">query</replaceable> <type>tsquery</type>)</function></literal>
        </entry>
        <entry><type>text</type></entry>
<!--
        <entry>get indexable part of a <type>tsquery</type></entry>
-->
        <entry><type>tsquery</type>のインデックス付け可能部分の取得</entry>
        <entry><literal>querytree('foo &amp; ! bar'::tsquery)</literal></entry>
        <entry><literal>'foo'</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>setweight</primary>
         </indexterm>
         <literal><function>setweight(<replaceable class="parameter">vector</replaceable> <type>tsvector</type>, <replaceable class="parameter">weight</replaceable> <type>"char"</type>)</function></literal>
        </entry>
        <entry><type>tsvector</type></entry>
<!--
        <entry>assign <replaceable class="parameter">weight</replaceable> to each element of <replaceable class="parameter">vector</replaceable></entry>
-->
        <entry><replaceable class="parameter">vector</replaceable>の各要素に<replaceable class="parameter">weight</replaceable>を割り当てる</entry>
        <entry><literal>setweight('fat:2,4 cat:3 rat:5B'::tsvector, 'A')</literal></entry>
        <entry><literal>'cat':3A 'fat':2A,4A 'rat':5A</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>setweight</primary>
<!--
          <secondary>setweight for specific lexeme(s)</secondary>
-->
          <secondary>特定の語彙素に対するsetweight</secondary>
         </indexterm>
         <literal><function>setweight(<replaceable class="parameter">vector</replaceable> <type>tsvector</type>, <replaceable class="parameter">weight</replaceable> <type>"char"</type>, <replaceable class="parameter">lexemes</replaceable> <type>text[]</type>)</function></literal>
        </entry>
        <entry><type>tsvector</type></entry>
<!--
        <entry>assign <replaceable class="parameter">weight</replaceable> to elements of <replaceable class="parameter">vector</replaceable> that are listed in <replaceable class="parameter">lexemes</replaceable></entry>
-->
        <entry><replaceable class="parameter">lexemes</replaceable>に列挙された<replaceable class="parameter">vector</replaceable>の要素に<replaceable class="parameter">weight</replaceable>を割り当てる</entry>
        <entry><literal>setweight('fat:2,4 cat:3 rat:5B'::tsvector, 'A', '{cat,rat}')</literal></entry>
        <entry><literal>'cat':3A 'fat':2,4 'rat':5A</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>strip</primary>
         </indexterm>
         <literal><function>strip(<type>tsvector</type>)</function></literal>
        </entry>
        <entry><type>tsvector</type></entry>
<!--
        <entry>remove positions and weights from <type>tsvector</type></entry>
-->
        <entry><type>tsvector</type>から位置と重みを削除</entry>
        <entry><literal>strip('fat:2,4 cat:3 rat:5A'::tsvector)</literal></entry>
        <entry><literal>'cat' 'fat' 'rat'</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>to_tsquery</primary>
         </indexterm>
         <literal><function>to_tsquery(<optional> <replaceable class="parameter">config</replaceable> <type>regconfig</type> , </optional> <replaceable class="parameter">query</replaceable> <type>text</type>)</function></literal>
        </entry>
        <entry><type>tsquery</type></entry>
<!--
        <entry>normalize words and convert to <type>tsquery</type></entry>
-->
        <entry>単語（複数）を正規化し<type>tsquery</type>に変換</entry>
        <entry><literal>to_tsquery('english', 'The &amp; Fat &amp; Rats')</literal></entry>
        <entry><literal>'fat' &amp; 'rat'</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>to_tsvector</primary>
         </indexterm>
         <literal><function>to_tsvector(<optional> <replaceable class="parameter">config</replaceable> <type>regconfig</type> , </optional> <replaceable class="parameter">document</replaceable> <type>text</type>)</function></literal>
        </entry>
        <entry><type>tsvector</type></entry>
<!--
        <entry>reduce document text to <type>tsvector</type></entry>
-->
        <entry>ドキュメントテキストを<type>tsvector</type>に縮小</entry>
        <entry><literal>to_tsvector('english', 'The Fat Rats')</literal></entry>
        <entry><literal>'fat':2 'rat':3</literal></entry>
       </row>
       <row>
        <entry>
         <literal><function>to_tsvector(<optional> <replaceable class="parameter">config</replaceable> <type>regconfig</type> , </optional> <replaceable class="parameter">document</replaceable> <type>json(b)</type>)</function></literal>
        </entry>
        <entry><type>tsvector</type></entry>
        <entry>
<!--
          reduce each string value in the document to a <type>tsvector</type>, and then
          concatenate those in document order to produce a single <type>tsvector</type>
-->
ドキュメント内の各文字列の値を<type>tsvector</type>に縮小し、それを繋げて一つの<type>tsvector</type>にする
        </entry>
        <entry><literal>to_tsvector('english', '{"a": "The Fat Rats"}'::json)</literal></entry>
        <entry><literal>'fat':2 'rat':3</literal></entry>
       </row>
       <row>
        <entry>
         <literal><function>json(b)_to_tsvector(<optional> <replaceable class="parameter">config</replaceable> <type>regconfig</type>,
         </optional> <replaceable class="parameter">document</replaceable> <type>json(b)</type>,
         <replaceable class="parameter">filter</replaceable> <type>json(b)</type>)</function></literal>
        </entry>
        <entry><type>tsvector</type></entry>
        <entry>
<!--
          reduce each value in the document, specified by <replaceable class="parameter">filter</replaceable> to a <type>tsvector</type>,
          and then concatenate those in document order to produce a single <type>tsvector</type>.
          <replaceable class="parameter">filter</replaceable> is a <type>jsonb</type> array, that enumerates what kind of elements need to be included
          into the resulting <type>tsvector</type>. Possible values for <replaceable class="parameter">filter</replaceable> are
          <literal>"string"</literal> (to include all string values), <literal>"numeric"</literal> (to include all numeric values in the string format),
          <literal>"boolean"</literal> (to include all Boolean values in the string format <literal>"true"</literal>/<literal>"false"</literal>),
          <literal>"key"</literal> (to include all keys) or <literal>"all"</literal> (to include all above). These values
          can be combined together to include, e.g. all string and numeric values.
-->
<replaceable class="parameter">filter</replaceable>によって指定された文書中の各々の値を<type>tsvector</type>にまとめ、次に文書にあらわれる順にそれらを結合して単一の<type>tsvector</type>を生成します。
<replaceable class="parameter">filter</replaceable>は<type>jsonb</type>の配列で、結果の<type>tsvector</type>にどの種類の要素を含める必要があるのかを列挙します。
<replaceable class="parameter">filter</replaceable>に指定可能な値は、<literal>"string"</literal> (すべての文字列値を含める)、<literal>"numeric"</literal> (すべての文字列形式の数値を含める)、<literal>"key"</literal> (すべてのキーを含める)、<literal>"all"</literal> (それらすべてを含める)です。
これらの値は、たとえばすべての文字列と数値、のように組み合わせることができます。
        </entry>
        <entry><literal>json_to_tsvector('english', '{"a": "The Fat Rats", "b": 123}'::json, '["string", "numeric"]')</literal></entry>
        <entry><literal>'123':5 'fat':2 'rat':3</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>ts_delete</primary>
         </indexterm>
         <literal><function>ts_delete(<replaceable class="parameter">vector</replaceable> <type>tsvector</type>, <replaceable class="parameter">lexeme</replaceable> <type>text</type>)</function></literal>
        </entry>
        <entry><type>tsvector</type></entry>
<!--
        <entry>remove given <replaceable class="parameter">lexeme</replaceable> from <replaceable class="parameter">vector</replaceable></entry>
-->
        <entry><replaceable class="parameter">vector</replaceable>から指定の<replaceable class="parameter">lexeme</replaceable>を削除する</entry>
        <entry><literal>ts_delete('fat:2,4 cat:3 rat:5A'::tsvector, 'fat')</literal></entry>
        <entry><literal>'cat':3 'rat':5A</literal></entry>
       </row>
       <row>
        <entry>
         <!-- previous indexterm entry covers this too -->
         <literal><function>ts_delete(<replaceable class="parameter">vector</replaceable> <type>tsvector</type>, <replaceable class="parameter">lexemes</replaceable> <type>text[]</type>)</function></literal>
        </entry>
        <entry><type>tsvector</type></entry>
<!--
        <entry>remove any occurrence of lexemes in <replaceable class="parameter">lexemes</replaceable> from <replaceable class="parameter">vector</replaceable></entry>
-->
        <entry><replaceable class="parameter">vector</replaceable>から<replaceable class="parameter">lexemes</replaceable>内にある語彙素の出現のすべてを削除する</entry>
        <entry><literal>ts_delete('fat:2,4 cat:3 rat:5A'::tsvector, ARRAY['fat','rat'])</literal></entry>
        <entry><literal>'cat':3</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>ts_filter</primary>
         </indexterm>
         <literal><function>ts_filter(<replaceable class="parameter">vector</replaceable> <type>tsvector</type>, <replaceable class="parameter">weights</replaceable> <type>"char"[]</type>)</function></literal>
        </entry>
        <entry><type>tsvector</type></entry>
<!--
        <entry>select only elements with given <replaceable class="parameter">weights</replaceable> from <replaceable class="parameter">vector</replaceable></entry>
-->
        <entry><replaceable class="parameter">vector</replaceable>から指定の<replaceable class="parameter">weights</replaceable>の要素のみを選択する</entry>
        <entry><literal>ts_filter('fat:2,4 cat:3b rat:5A'::tsvector, '{a,b}')</literal></entry>
        <entry><literal>'cat':3B 'rat':5A</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>ts_headline</primary>
         </indexterm>
         <literal><function>ts_headline(<optional> <replaceable class="parameter">config</replaceable> <type>regconfig</type>, </optional> <replaceable class="parameter">document</replaceable> <type>text</type>, <replaceable class="parameter">query</replaceable> <type>tsquery</type> <optional>, <replaceable class="parameter">options</replaceable> <type>text</type> </optional>)</function></literal>
        </entry>
        <entry><type>text</type></entry>
<!--
        <entry>display a query match</entry>
-->
        <entry>問い合わせによるマッチを表示</entry>
        <entry><literal>ts_headline('x y z', 'z'::tsquery)</literal></entry>
        <entry><literal>x y &lt;b&gt;z&lt;/b&gt;</literal></entry>
       </row>
       <row>
        <entry>
         <literal><function>ts_headline(<optional> <replaceable class="parameter">config</replaceable> <type>regconfig</type>, </optional> <replaceable class="parameter">document</replaceable> <type>json(b)</type>, <replaceable class="parameter">query</replaceable> <type>tsquery</type> <optional>, <replaceable class="parameter">options</replaceable> <type>text</type> </optional>)</function></literal>
        </entry>
        <entry><type>text</type></entry>
<!--
        <entry>display a query match</entry>
-->
        <entry>問い合わせによるマッチを表示</entry>
        <entry><literal>ts_headline('{"a":"x y z"}'::json, 'z'::tsquery)</literal></entry>
        <entry><literal>{"a":"x y &lt;b&gt;z&lt;/b&gt;"}</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>ts_rank</primary>
         </indexterm>
         <literal><function>ts_rank(<optional> <replaceable class="parameter">weights</replaceable> <type>float4[]</type>, </optional> <replaceable class="parameter">vector</replaceable> <type>tsvector</type>, <replaceable class="parameter">query</replaceable> <type>tsquery</type> <optional>, <replaceable class="parameter">normalization</replaceable> <type>integer</type> </optional>)</function></literal>
        </entry>
        <entry><type>float4</type></entry>
<!--
        <entry>rank document for query</entry>
-->
        <entry>問い合わせのためのドキュメント順位付け</entry>
        <entry><literal>ts_rank(textsearch, query)</literal></entry>
        <entry><literal>0.818</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>ts_rank_cd</primary>
         </indexterm>
         <literal><function>ts_rank_cd(<optional> <replaceable class="parameter">weights</replaceable> <type>float4[]</type>, </optional> <replaceable class="parameter">vector</replaceable> <type>tsvector</type>, <replaceable class="parameter">query</replaceable> <type>tsquery</type> <optional>, <replaceable class="parameter">normalization</replaceable> <type>integer</type> </optional>)</function></literal>
        </entry>
        <entry><type>float4</type></entry>
<!--
        <entry>rank document for query using cover density</entry>
-->
        <entry>被覆密度を用いた問い合わせのためのドキュメント順位付け</entry>
        <entry><literal>ts_rank_cd('{0.1, 0.2, 0.4, 1.0}', textsearch, query)</literal></entry>
        <entry><literal>2.01317</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>ts_rewrite</primary>
         </indexterm>
         <literal><function>ts_rewrite(<replaceable class="parameter">query</replaceable> <type>tsquery</type>, <replaceable class="parameter">target</replaceable> <type>tsquery</type>, <replaceable class="parameter">substitute</replaceable> <type>tsquery</type>)</function></literal>
        </entry>
        <entry><type>tsquery</type></entry>
<!--
        <entry>replace <replaceable>target</replaceable> with <replaceable>substitute</replaceable>
         within query</entry>
-->
        <entry>問い合わせ内の<replaceable>target</replaceable>を<replaceable>substitute</replaceable>で置換する</entry>
        <entry><literal>ts_rewrite('a &amp; b'::tsquery, 'a'::tsquery, 'foo|bar'::tsquery)</literal></entry>
        <entry><literal>'b' &amp; ( 'foo' | 'bar' )</literal></entry>
       </row>
       <row>
        <entry><literal><function>ts_rewrite(<replaceable class="parameter">query</replaceable> <type>tsquery</type>, <replaceable class="parameter">select</replaceable> <type>text</type>)</function></literal></entry>
        <entry><type>tsquery</type></entry>
<!--
        <entry>replace using targets and substitutes from a <command>SELECT</command> command</entry>
-->
        <entry><command>SELECT</command>から対象と代替を使用して置換</entry>
        <entry><literal>SELECT ts_rewrite('a &amp; b'::tsquery, 'SELECT t,s FROM aliases')</literal></entry>
        <entry><literal>'b' &amp; ( 'foo' | 'bar' )</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>tsquery_phrase</primary>
         </indexterm>
         <literal><function>tsquery_phrase(<replaceable class="parameter">query1</replaceable> <type>tsquery</type>, <replaceable class="parameter">query2</replaceable> <type>tsquery</type>)</function></literal>
        </entry>
        <entry><type>tsquery</type></entry>
<!--
        <entry>make query that searches for <replaceable>query1</replaceable> followed
         by <replaceable>query2</replaceable> (same as <literal>&lt;-&gt;</literal>
         operator)</entry>
-->
        <entry><replaceable>query1</replaceable>の後に<replaceable>query2</replaceable>が続くものを検索する問い合わせを作成する（<literal>&lt;-&gt;</literal>演算子と同じ）</entry>
        <entry><literal>tsquery_phrase(to_tsquery('fat'), to_tsquery('cat'))</literal></entry>
        <entry><literal>'fat' &lt;-&gt; 'cat'</literal></entry>
       </row>
       <row>
        <entry>
         <literal><function>tsquery_phrase(<replaceable class="parameter">query1</replaceable> <type>tsquery</type>, <replaceable class="parameter">query2</replaceable> <type>tsquery</type>, <replaceable class="parameter">distance</replaceable> <type>integer</type>)</function></literal>
        </entry>
        <entry><type>tsquery</type></entry>
<!--
        <entry>make query that searches for <replaceable>query1</replaceable> followed by
         <replaceable>query2</replaceable> at distance <replaceable>distance</replaceable></entry>
-->
        <entry><replaceable>query1</replaceable>の後に<replaceable>distance</replaceable>の距離で<replaceable>query2</replaceable>があるものを検索する問い合わせを作成する</entry>
        <entry><literal>tsquery_phrase(to_tsquery('fat'), to_tsquery('cat'), 10)</literal></entry>
        <entry><literal>'fat' &lt;10&gt; 'cat'</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>tsvector_to_array</primary>
         </indexterm>
         <literal><function>tsvector_to_array(<type>tsvector</type>)</function></literal>
        </entry>
        <entry><type>text[]</type></entry>
<!--
        <entry>convert <type>tsvector</type> to array of lexemes</entry>
-->
        <entry><type>tsvector</type>を語彙素の配列に変換する</entry>
        <entry><literal>tsvector_to_array('fat:2,4 cat:3 rat:5A'::tsvector)</literal></entry>
        <entry><literal>{cat,fat,rat}</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>tsvector_update_trigger</primary>
         </indexterm>
         <literal><function>tsvector_update_trigger()</function></literal>
        </entry>
        <entry><type>trigger</type></entry>
<!--
        <entry>trigger function for automatic <type>tsvector</type> column update</entry>
-->
        <entry><type>tsvector</type>列の自動更新のためのトリガ関数</entry>
        <entry><literal>CREATE TRIGGER ... tsvector_update_trigger(tsvcol, 'pg_catalog.swedish', title, body)</literal></entry>
        <entry><literal></literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>tsvector_update_trigger_column</primary>
         </indexterm>
         <literal><function>tsvector_update_trigger_column()</function></literal>
        </entry>
        <entry><type>trigger</type></entry>
<!--
        <entry>trigger function for automatic <type>tsvector</type> column update</entry>
-->
        <entry><type>tsvector</type>列の自動更新のためのトリガ関数</entry>
        <entry><literal>CREATE TRIGGER ... tsvector_update_trigger_column(tsvcol, configcol, title, body)</literal></entry>
        <entry><literal></literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>unnest</primary>
<!--
          <secondary>for tsvector</secondary>
-->
          <secondary>tsvector用の</secondary>
         </indexterm>
         <literal><function>unnest(<type>tsvector</type>, OUT <replaceable class="parameter">lexeme</replaceable> <type>text</type>, OUT <replaceable class="parameter">positions</replaceable> <type>smallint[]</type>, OUT <replaceable class="parameter">weights</replaceable> <type>text</type>)</function></literal>
        </entry>
        <entry><type>setof record</type></entry>
<!--
        <entry>expand a <type>tsvector</type> to a set of rows</entry>
-->
        <entry><type>tsvector</type>を行の集合に展開する</entry>
        <entry><literal>unnest('fat:2,4 cat:3 rat:5A'::tsvector)</literal></entry>
        <entry><literal>(cat,{3},{D}) ...</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

  <note>
   <para>
<!--
    All the text search functions that accept an optional <type>regconfig</type>
    argument will use the configuration specified by
    <xref linkend="guc-default-text-search-config"/>
    when that argument is omitted.
-->
オプションの<type>regconfig</type>引数を受け付ける全てのテキスト検索関数は、その引数が省略された場合<xref linkend="guc-default-text-search-config"/>で指定された構成を使用します。
   </para>
  </note>

  <para>
<!--
   The functions in
   <xref linkend="textsearch-functions-debug-table"/>
   are listed separately because they are not usually used in everyday text
   searching operations.  They are helpful for development and debugging
   of new text search configurations.
-->
<xref linkend="textsearch-functions-debug-table"/>の関数は、日常のテキスト検索操作では通常使用されないので、別の表にしました。
これらは新しいテキスト検索設定の開発およびデバッグに役立ちます。
  </para>

    <table id="textsearch-functions-debug-table">
<!--
     <title>Text Search Debugging Functions</title>
-->
     <title>テキスト検索デバッグ関数</title>
     <tgroup cols="5">
      <thead>
       <row>
<!--
        <entry>Function</entry>
        <entry>Return Type</entry>
        <entry>Description</entry>
        <entry>Example</entry>
        <entry>Result</entry>
-->
        <entry>関数</entry>
        <entry>戻り値型</entry>
        <entry>説明</entry>
        <entry>例</entry>
        <entry>結果</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>
         <indexterm>
          <primary>ts_debug</primary>
         </indexterm>
         <literal><function>ts_debug(<optional> <replaceable class="parameter">config</replaceable> <type>regconfig</type>, </optional> <replaceable class="parameter">document</replaceable> <type>text</type>, OUT <replaceable class="parameter">alias</replaceable> <type>text</type>, OUT <replaceable class="parameter">description</replaceable> <type>text</type>, OUT <replaceable class="parameter">token</replaceable> <type>text</type>, OUT <replaceable class="parameter">dictionaries</replaceable> <type>regdictionary[]</type>, OUT <replaceable class="parameter">dictionary</replaceable> <type>regdictionary</type>, OUT <replaceable class="parameter">lexemes</replaceable> <type>text[]</type>)</function></literal>
        </entry>
        <entry><type>setof record</type></entry>
<!--
        <entry>test a configuration</entry>
-->
        <entry>構成を検査</entry>
        <entry><literal>ts_debug('english', 'The Brightest supernovaes')</literal></entry>
        <entry><literal>(asciiword,"Word, all ASCII",The,{english_stem},english_stem,{}) ...</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>ts_lexize</primary>
         </indexterm>
         <literal><function>ts_lexize(<replaceable class="parameter">dict</replaceable> <type>regdictionary</type>, <replaceable class="parameter">token</replaceable> <type>text</type>)</function></literal>
        </entry>
        <entry><type>text[]</type></entry>
<!--
        <entry>test a dictionary</entry>
-->
        <entry>辞書を検査</entry>
        <entry><literal>ts_lexize('english_stem', 'stars')</literal></entry>
        <entry><literal>{star}</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>ts_parse</primary>
         </indexterm>
         <literal><function>ts_parse(<replaceable class="parameter">parser_name</replaceable> <type>text</type>, <replaceable class="parameter">document</replaceable> <type>text</type>, OUT <replaceable class="parameter">tokid</replaceable> <type>integer</type>, OUT <replaceable class="parameter">token</replaceable> <type>text</type>)</function></literal>
        </entry>
        <entry><type>setof record</type></entry>
<!--
        <entry>test a parser</entry>
-->
        <entry>パーサを検査</entry>
        <entry><literal>ts_parse('default', 'foo - bar')</literal></entry>
        <entry><literal>(1,foo) ...</literal></entry>
       </row>
       <row>
        <entry><literal><function>ts_parse(<replaceable class="parameter">parser_oid</replaceable> <type>oid</type>, <replaceable class="parameter">document</replaceable> <type>text</type>, OUT <replaceable class="parameter">tokid</replaceable> <type>integer</type>, OUT <replaceable class="parameter">token</replaceable> <type>text</type>)</function></literal></entry>
        <entry><type>setof record</type></entry>
<!--
        <entry>test a parser</entry>
-->
        <entry>パーサを検査</entry>
        <entry><literal>ts_parse(3722, 'foo - bar')</literal></entry>
        <entry><literal>(1,foo) ...</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>ts_token_type</primary>
         </indexterm>
         <literal><function>ts_token_type(<replaceable class="parameter">parser_name</replaceable> <type>text</type>, OUT <replaceable class="parameter">tokid</replaceable> <type>integer</type>, OUT <replaceable class="parameter">alias</replaceable> <type>text</type>, OUT <replaceable class="parameter">description</replaceable> <type>text</type>)</function></literal>
        </entry>
        <entry><type>setof record</type></entry>
<!--
        <entry>get token types defined by parser</entry>
-->
    <entry>パーサで定義されたトークンの型を入手</entry>
        <entry><literal>ts_token_type('default')</literal></entry>
        <entry><literal>(1,asciiword,"Word, all ASCII") ...</literal></entry>
       </row>
       <row>
        <entry><literal><function>ts_token_type(<replaceable class="parameter">parser_oid</replaceable> <type>oid</type>, OUT <replaceable class="parameter">tokid</replaceable> <type>integer</type>, OUT <replaceable class="parameter">alias</replaceable> <type>text</type>, OUT <replaceable class="parameter">description</replaceable> <type>text</type>)</function></literal></entry>
        <entry><type>setof record</type></entry>
<!--
        <entry>get token types defined by parser</entry>
-->
        <entry>パーサで定義されたトークンの型を入手</entry>
        <entry><literal>ts_token_type(3722)</literal></entry>
        <entry><literal>(1,asciiword,"Word, all ASCII") ...</literal></entry>
       </row>
       <row>
        <entry>
         <indexterm>
          <primary>ts_stat</primary>
         </indexterm>
         <literal><function>ts_stat(<replaceable class="parameter">sqlquery</replaceable> <type>text</type>, <optional> <replaceable class="parameter">weights</replaceable> <type>text</type>, </optional> OUT <replaceable class="parameter">word</replaceable> <type>text</type>, OUT <replaceable class="parameter">ndoc</replaceable> <type>integer</type>, OUT <replaceable class="parameter">nentry</replaceable> <type>integer</type>)</function></literal>
        </entry>
        <entry><type>setof record</type></entry>
<!--
        <entry>get statistics of a <type>tsvector</type> column</entry>
-->
        <entry><type>tsvector</type>列の統計情報を入手</entry>
        <entry><literal>ts_stat('SELECT vector from apod')</literal></entry>
        <entry><literal>(foo,10,15) ...</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

 </sect1>


 <sect1 id="functions-xml">

<!--
  <title>XML Functions</title>
-->
  <title>XML関数</title>

  <indexterm>
   <primary>XML Functions</primary>
  </indexterm>

  <para>
<!--
   The functions and function-like expressions described in this
   section operate on values of type <type>xml</type>.  See <xref
   linkend="datatype-xml"/> for information about the <type>xml</type>
   type.  The function-like expressions <function>xmlparse</function>
   and <function>xmlserialize</function> for converting to and from
   type <type>xml</type> are documented there, not in this section.
-->
この節で説明される関数および擬似関数式は、<type>xml</type>型の値に対して機能します。
<type>xml</type>型についての情報は<xref linkend="datatype-xml"/>を参照してください。
<type>xml</type>型のやりとりを変換する<function>xmlparse</function>および<function>xmlserialize</function>擬似関数式はこの節ではなく、そこに記載されています。
  </para>

  <para>
<!--
   Use of most of these functions
   requires <productname>PostgreSQL</productname> to have been built
   with <command>configure &#045;&#045;with-libxml</command>.
-->
これらの関数の大半は<productname>PostgreSQL</productname>が<command>configure --with-libxml</command>でビルドされていることを必要としています。
  </para>

  <sect2 id="functions-producing-xml">
<!--
   <title>Producing XML Content</title>
-->
   <title>XML内容の生成</title>

   <para>
<!--
    A set of functions and function-like expressions are available for
    producing XML content from SQL data.  As such, they are
    particularly suitable for formatting query results into XML
    documents for processing in client applications.
-->
SQLデータからXML内容を生成するために関数と擬似関数式の一式が提供されています。
そのようなものとして、クライアントアプリケーションが問い合わせ結果を処理のためXML文書に書式化するのにこれらは特に適しています。
   </para>

   <sect3>
    <title><literal>xmlcomment</literal></title>

    <indexterm>
     <primary>xmlcomment</primary>
    </indexterm>

<synopsis>
<function>xmlcomment</function>(<replaceable>text</replaceable>)
</synopsis>

    <para>
<!--
     The function <function>xmlcomment</function> creates an XML value
     containing an XML comment with the specified text as content.
     The text cannot contain <quote><literal>&#045;-</literal></quote> or end with a
     <quote><literal>-</literal></quote> so that the resulting construct is a valid
     XML comment.  If the argument is null, the result is null.
-->
関数<function>xmlcomment</function>は指定のテキストを内容とするXMLコメントを含んだXML値を作成します。
結果として構築されるXMLコメントが有効になるよう、テキストは<quote><literal>--</literal></quote>を含むこと、または<quote><literal>-</literal></quote>で終結することはできません。
引数がNULLならば結果もNULLになります。
    </para>

    <para>
<!--
     Example:
-->
例：
<screen><![CDATA[
SELECT xmlcomment('hello');

  xmlcomment
--------------
 <!--hello-->
]]></screen>
    </para>
   </sect3>

   <sect3>
    <title><literal>xmlconcat</literal></title>

    <indexterm>
     <primary>xmlconcat</primary>
    </indexterm>

<synopsis>
<function>xmlconcat</function>(<replaceable>xml</replaceable><optional>, ...</optional>)
</synopsis>

    <para>
<!--
     The function <function>xmlconcat</function> concatenates a list
     of individual XML values to create a single value containing an
     XML content fragment.  Null values are omitted; the result is
     only null if there are no nonnull arguments.
-->
関数<function>xmlconcat</function>は、個々のXML値のリストを結合し、XMLの内容断片を含む単一の値を作成します。
NULL値は削除され、NULL以外の引数が存在しないときのみ結果はNULLになります。
    </para>

    <para>
<!--
     Example:
-->
例：
<screen><![CDATA[
SELECT xmlconcat('<abc/>', '<bar>foo</bar>');

      xmlconcat
----------------------
 <abc/><bar>foo</bar>
]]></screen>
    </para>

    <para>
<!--
     XML declarations, if present, are combined as follows.  If all
     argument values have the same XML version declaration, that
     version is used in the result, else no version is used.  If all
     argument values have the standalone declaration value
     <quote>yes</quote>, then that value is used in the result.  If
     all argument values have a standalone declaration value and at
     least one is <quote>no</quote>, then that is used in the result.
     Else the result will have no standalone declaration.  If the
     result is determined to require a standalone declaration but no
     version declaration, a version declaration with version 1.0 will
     be used because XML requires an XML declaration to contain a
     version declaration.  Encoding declarations are ignored and
     removed in all cases.
-->
XML宣言が提示されている場合は次のように組み合わされます。
全ての引数の値が同一のXMLversion宣言を持っていれば、そのversionが結果に使用されます。さもなければversionは使用されません。
全ての引数の値でstandaloneの宣言値が<quote>yes</quote>であれば、その値が結果に使用されます。
全ての引数の値にstandalone宣言値があり、その中で１つでも<quote>no</quote>がある場合、それが結果に使用されます。
それ以外の場合は、結果はstandalone宣言を持ちません。
standalone宣言を必要とするが、standalone宣言がないという結果になった場合には、version 1.0のversion宣言が使用されます。
これはXMLがXML宣言においてversion宣言を含むことを要求するためです。
encoding宣言は無視され、全ての場合で削除されます。
    </para>

    <para>
<!--
     Example:
-->
例：
<screen><![CDATA[
SELECT xmlconcat('<?xml version="1.1"?><foo/>', '<?xml version="1.1" standalone="no"?><bar/>');

             xmlconcat
-----------------------------------
 <?xml version="1.1"?><foo/><bar/>
]]></screen>
    </para>
   </sect3>

   <sect3>
    <title><literal>xmlelement</literal></title>

   <indexterm>
    <primary>xmlelement</primary>
   </indexterm>

<synopsis>
<function>xmlelement</function>(name <replaceable>name</replaceable> <optional>, xmlattributes(<replaceable>value</replaceable> <optional>AS <replaceable>attname</replaceable></optional> <optional>, ... </optional>)</optional> <optional><replaceable>, content, ...</replaceable></optional>)
</synopsis>

    <para>
<!--
     The <function>xmlelement</function> expression produces an XML
     element with the given name, attributes, and content.
-->
<function>xmlelement</function>式は与えられた名前、属性、および内容を持つXML要素を生成します。
    </para>

    <para>
<!--
     Examples:
-->
例：
<screen><![CDATA[
SELECT xmlelement(name foo);

 xmlelement
------------
 <foo/>

SELECT xmlelement(name foo, xmlattributes('xyz' as bar));

    xmlelement
------------------
 <foo bar="xyz"/>

SELECT xmlelement(name foo, xmlattributes(current_date as bar), 'cont', 'ent');

             xmlelement
-------------------------------------
 <foo bar="2007-01-26">content</foo>
]]></screen>
    </para>

    <para>
<!--
     Element and attribute names that are not valid XML names are
     escaped by replacing the offending characters by the sequence
     <literal>_x<replaceable>HHHH</replaceable>_</literal>, where
     <replaceable>HHHH</replaceable> is the character's Unicode
     codepoint in hexadecimal notation.  For example:
-->
有効なXML名ではない要素名と属性名は、シーケンス<literal>_x<replaceable>HHHH</replaceable>_</literal>により障害となる文字を置換することでエスケープされます。ここで、<replaceable>HHHH</replaceable>は16進数によるその文字のUnicode文字コード番号です。
例をあげます。
<screen><![CDATA[
SELECT xmlelement(name "foo$bar", xmlattributes('xyz' as "a&b"));

            xmlelement
----------------------------------
 <foo_x0024_bar a_x0026_b="xyz"/>
]]></screen>
    </para>

    <para>
<!--
     An explicit attribute name need not be specified if the attribute
     value is a column reference, in which case the column's name will
     be used as the attribute name by default.  In other cases, the
     attribute must be given an explicit name.  So this example is
     valid:
-->
属性値が列参照の場合、明示的な属性名を指定する必要はありません。この場合、デフォルトで列名が属性名として使用されます。
その他の場合には、属性は明示的な名前で与えられなければなりません。
従って、以下の例は有効です。
<screen>
CREATE TABLE test (a xml, b xml);
SELECT xmlelement(name test, xmlattributes(a, b)) FROM test;
</screen>
<!--
     But these are not:
-->
しかし、以下の例は有効ではありません。
<screen>
SELECT xmlelement(name test, xmlattributes('constant'), a, b) FROM test;
SELECT xmlelement(name test, xmlattributes(func(a, b))) FROM test;
</screen>
    </para>

    <para>
<!--
     Element content, if specified, will be formatted according to
     its data type.  If the content is itself of type <type>xml</type>,
     complex XML documents can be constructed.  For example:
-->
もし要素内容が指定されればそのデータ型に従って書式化されます。
もし内容そのものが<type>xml</type>型であれば、複合XML文書が構築されます。
例をあげます。
<screen><![CDATA[
SELECT xmlelement(name foo, xmlattributes('xyz' as bar),
                            xmlelement(name abc),
                            xmlcomment('test'),
                            xmlelement(name xyz));

                  xmlelement
----------------------------------------------
 <foo bar="xyz"><abc/><!--test--><xyz/></foo>
]]></screen>

<!--
     Content of other types will be formatted into valid XML character
     data.  This means in particular that the characters &lt;, &gt;,
     and &amp; will be converted to entities.  Binary data (data type
     <type>bytea</type>) will be represented in base64 or hex
     encoding, depending on the setting of the configuration parameter
     <xref linkend="guc-xmlbinary"/>.  The particular behavior for
     individual data types is expected to evolve in order to align the
     PostgreSQL mappings with those specified in SQL:2006 and later,
     as discussed in <xref linkend="functions-xml-limits-casts"/>.
-->
そのほかの型の内容は有効なXML文字データにフォーマットされます。
これは特に文字&lt;、&gt;、および&amp;がエンティティに変換されることを意味します。
バイナリデータ（データ型は<type>bytea</type>）は、設定パラメータ<xref linkend="guc-xmlbinary"/>の設定にしたがって、base64もしくは16進符号化方式で表現されます。
個々のデータ型に対する特定の動作は、XMLスキーマ仕様でのSQLおよびPostgreSQLデータ型に調整するため発展すると期待されます。
その時点で記述がより詳細になるでしょう。
    </para>
   </sect3>

   <sect3>
    <title><literal>xmlforest</literal></title>

   <indexterm>
    <primary>xmlforest</primary>
   </indexterm>

<synopsis>
<function>xmlforest</function>(<replaceable>content</replaceable> <optional>AS <replaceable>name</replaceable></optional> <optional>, ...</optional>)
</synopsis>

    <para>
<!--
     The <function>xmlforest</function> expression produces an XML
     forest (sequence) of elements using the given names and content.
-->
<function>xmlforest</function>式は与えられた名前と内容を使用し、要素のXMLフォレスト（シーケンス）を生成します。
    </para>

    <para>
<!--
     Examples:
-->
例：
<screen><![CDATA[
SELECT xmlforest('abc' AS foo, 123 AS bar);

          xmlforest
------------------------------
 <foo>abc</foo><bar>123</bar>


SELECT xmlforest(table_name, column_name)
FROM information_schema.columns
WHERE table_schema = 'pg_catalog';

                                         xmlforest
-------------------------------------------------------------------------------------------
 <table_name>pg_authid</table_name><column_name>rolname</column_name>
 <table_name>pg_authid</table_name><column_name>rolsuper</column_name>
 ...
]]></screen>

<!--
     As seen in the second example, the element name can be omitted if
     the content value is a column reference, in which case the column
     name is used by default.  Otherwise, a name must be specified.
-->
第２の例に見られるように、内容の値が列参照の場合、要素名は省略可能です。この時は、列名がデフォルトで使用されます。
そうでない時は、名前が指定されなければなりません。
    </para>

    <para>
<!--
     Element names that are not valid XML names are escaped as shown
     for <function>xmlelement</function> above.  Similarly, content
     data is escaped to make valid XML content, unless it is already
     of type <type>xml</type>.
-->
有効なXML名ではない要素名は上の<function>xmlelement</function>で説明した通りエスケープされます。
同様にして、既に<type>xml</type>型であるものを除き、内容データは有効なXML内容になるようにエスケープされます。
    </para>

    <para>
<!--
     Note that XML forests are not valid XML documents if they consist
     of more than one element, so it might be useful to wrap
     <function>xmlforest</function> expressions in
     <function>xmlelement</function>.
-->
XMLフォレストは２つ以上の要素からなる場合、有効なXML文書ではないことに注意してください。
したがって、<function>xmlelement</function>内に<function>xmlforest</function>式をラップすることが有用なことがあります。
    </para>
   </sect3>

   <sect3>
    <title><literal>xmlpi</literal></title>

   <indexterm>
    <primary>xmlpi</primary>
   </indexterm>

<synopsis>
<function>xmlpi</function>(name <replaceable>target</replaceable> <optional>, <replaceable>content</replaceable></optional>)
</synopsis>

    <para>
<!--
     The <function>xmlpi</function> expression creates an XML
     processing instruction.  The content, if present, must not
     contain the character sequence <literal>?&gt;</literal>.
-->
<function>xmlpi</function>式はXML処理命令を作成します。
内容が存在すれば、その内容は<literal>?&gt;</literal>文字シーケンスを含んではなりません。
    </para>

    <para>
<!--
     Example:
-->
例：
<screen><![CDATA[
SELECT xmlpi(name php, 'echo "hello world";');

            xmlpi
-----------------------------
 <?php echo "hello world";?>
]]></screen>
    </para>
   </sect3>

   <sect3>
    <title><literal>xmlroot</literal></title>

   <indexterm>
    <primary>xmlroot</primary>
   </indexterm>

<synopsis>
<function>xmlroot</function>(<replaceable>xml</replaceable>, version <replaceable>text</replaceable> | no value <optional>, standalone yes|no|no value</optional>)
</synopsis>

    <para>
<!--
     The <function>xmlroot</function> expression alters the properties
     of the root node of an XML value.  If a version is specified,
     it replaces the value in the root node's version declaration; if a
     standalone setting is specified, it replaces the value in the
     root node's standalone declaration.
-->
<function>xmlroot</function>式はXML値のルートノードの属性を変更します。
versionが指定されていると、ルートノードのversion宣言での値を変更し、standalone設定が指定されていると、ルートノードのstandalone宣言での値を変更します。
    </para>

    <para>
<screen><![CDATA[
SELECT xmlroot(xmlparse(document '<?xml version="1.1"?><content>abc</content>'),
               version '1.0', standalone yes);

                xmlroot
----------------------------------------
 <?xml version="1.0" standalone="yes"?>
 <content>abc</content>
]]></screen>
    </para>
   </sect3>

   <sect3 id="functions-xml-xmlagg">
    <title><literal>xmlagg</literal></title>

    <indexterm>
     <primary>xmlagg</primary>
    </indexterm>

<synopsis>
<function>xmlagg</function>(<replaceable>xml</replaceable>)
</synopsis>

    <para>
<!--
     The function <function>xmlagg</function> is, unlike the other
     functions described here, an aggregate function.  It concatenates the
     input values to the aggregate function call,
     much like <function>xmlconcat</function> does, except that concatenation
     occurs across rows rather than across expressions in a single row.
     See <xref linkend="functions-aggregate"/> for additional information
     about aggregate functions.
-->
ここで説明している他の関数とは異なり、<function>xmlagg</function>関数は集約関数です。
これは<function>xmlconcat</function>が行うように、入力値を連結する集約関数ですが、単一行内の複数の式にまたがった連結ではなく、複数行にまたがった連結を行います。
集約関数についての追加情報は<xref linkend="functions-aggregate"/>を参照してください。
    </para>

    <para>
<!--
     Example:
-->
例：
<screen><![CDATA[
CREATE TABLE test (y int, x xml);
INSERT INTO test VALUES (1, '<foo>abc</foo>');
INSERT INTO test VALUES (2, '<bar/>');
SELECT xmlagg(x) FROM test;
        xmlagg
----------------------
 <foo>abc</foo><bar/>
]]></screen>
    </para>

    <para>
<!--
     To determine the order of the concatenation, an <literal>ORDER BY</literal>
     clause may be added to the aggregate call as described in
     <xref linkend="syntax-aggregates"/>. For example:
-->
連結の順序を決定するため、<xref linkend="syntax-aggregates"/>に記述されているように<literal>ORDER BY</literal>句を集計呼び出しに追加することができます。
以下は例です。

<screen><![CDATA[
SELECT xmlagg(x ORDER BY y DESC) FROM test;
        xmlagg
----------------------
 <bar/><foo>abc</foo>
]]></screen>
    </para>

    <para>
<!--
     The following non-standard approach used to be recommended
     in previous versions, and may still be useful in specific
     cases:
-->
下記は以前のバージョンで推奨されていた、非標準的な方法例です。特定のケースでは有用かもしれません。

<screen><![CDATA[
SELECT xmlagg(x) FROM (SELECT * FROM test ORDER BY y DESC) AS tab;
        xmlagg
----------------------
 <bar/><foo>abc</foo>
]]></screen>
    </para>
   </sect3>
   </sect2>

   <sect2 id="functions-xml-predicates">
<!--
    <title>XML Predicates</title>
-->
    <title>XML述語</title>

    <para>
<!--
     The expressions described in this section check properties
     of <type>xml</type> values.
-->
この節で記述されている式は、<type>xml</type>値の属性をチェックします。
    </para>

   <sect3>
    <title><literal>IS DOCUMENT</literal></title>

    <indexterm>
     <primary>IS DOCUMENT</primary>
    </indexterm>

<synopsis>
<replaceable>xml</replaceable> IS DOCUMENT
</synopsis>

    <para>
<!--
     The expression <literal>IS DOCUMENT</literal> returns true if the
     argument XML value is a proper XML document, false if it is not
     (that is, it is a content fragment), or null if the argument is
     null.  See <xref linkend="datatype-xml"/> about the difference
     between documents and content fragments.
-->
式<literal>IS DOCUMENT</literal>は引数XML値が適切なXML文書であれば真を返し、そうでなければ（つまり、内容の断片）偽を返すか、もしくは引数がNULLであればNULLを返します。
文書と内容の断片の差異については<xref linkend="datatype-xml"/>を参照してください。
    </para>
   </sect3>

   <sect3>
    <title><literal>IS NOT DOCUMENT</literal></title>

    <indexterm>
     <primary>IS NOT DOCUMENT</primary>
    </indexterm>

<synopsis>
<replaceable>xml</replaceable> IS NOT DOCUMENT
</synopsis>

    <para>
<!--
     The expression <literal>IS NOT DOCUMENT</literal> returns false if the
     argument XML value is a proper XML document, true if it is not (that is,
     it is a content fragment), or null if the argument is null.
-->
式<literal>IS NOT DOCUMENT</literal>は引数XML値が適切なXML文書であれば偽を返し、そうでなければ（つまり、内容の断片）真を返すか、もしくは引数がNULLであればNULLを返します。
    </para>
   </sect3>

   <sect3 id="xml-exists">
    <title><literal>XMLEXISTS</literal></title>

    <indexterm>
     <primary>XMLEXISTS</primary>
    </indexterm>

<synopsis>
<function>XMLEXISTS</function>(<replaceable>text</replaceable> PASSING <optional>BY { REF | VALUE }</optional> <replaceable>xml</replaceable> <optional>BY { REF | VALUE }</optional>)
</synopsis>

    <para>
<!--
     The function <function>xmlexists</function> evaluates an XPath 1.0
     expression (the first argument), with the passed XML value as its context
     item.  The function returns false if the result of that evaluation
     yields an empty node-set, true if it yields any other value.  The
     function returns null if any argument is null.  A nonnull value
     passed as the context item must be an XML document, not a content
     fragment or any non-XML value.
-->
関数<function>xmlexists</function>は渡されたXML値をコンテキスト項目としてXPath 1.0式（第一引数）を評価します。
この関数は評価が空のノード集合を生成する場合には偽を返し、それ以外の値を返すならば真を返します。
もしどれかの引数がNULLであった場合はNULLを返します。
コンテキスト項目として渡される非NULLの値は、内容の断片や非XML値ではなく、XML文書でなければなりません。
    </para>

    <para>
<!--
     Example:
-->
例:
     <screen><![CDATA[
SELECT xmlexists('//town[text() = ''Toronto'']' PASSING BY VALUE '<towns><town>Toronto</town><town>Ottawa</town></towns>');

 xmlexists
------------
 t
(1 row)
]]></screen>
    </para>

    <para>
<!--
     The <literal>BY REF</literal> and <literal>BY VALUE</literal> clauses
     are accepted in <productname>PostgreSQL</productname>, but are ignored,
     as discussed in <xref linkend="functions-xml-limits-postgresql"/>.
     In the SQL standard, the <function>xmlexists</function> function
     evaluates an expression in the XML Query language,
     but <productname>PostgreSQL</productname> allows only an XPath 1.0
     expression, as discussed in
     <xref linkend="functions-xml-limits-xpath1"/>.
-->
<productname>PostgreSQL</productname>は<literal>BY REF</literal>句と<literal>BY VALUE</literal>句を受け付けますが、<xref linkend="functions-xml-limits-postgresql"/>で議論されているように無視します。
SQL標準では<function>xmlexists</function>関数はXML問い合わせ言語における式を評価しますが、<xref linkend="functions-xml-limits-xpath1"/>で議論されているように、<productname>PostgreSQL</productname>はXPath 1.0の式だけを受け付けます。
    </para>
   </sect3>

   <sect3 id="xml-is-well-formed">
    <title><literal>xml_is_well_formed</literal></title>

    <indexterm>
     <primary>xml_is_well_formed</primary>
    </indexterm>

    <indexterm>
     <primary>xml_is_well_formed_document</primary>
    </indexterm>

    <indexterm>
     <primary>xml_is_well_formed_content</primary>
    </indexterm>

<synopsis>
<function>xml_is_well_formed</function>(<replaceable>text</replaceable>)
<function>xml_is_well_formed_document</function>(<replaceable>text</replaceable>)
<function>xml_is_well_formed_content</function>(<replaceable>text</replaceable>)
</synopsis>

    <para>
<!--
     These functions check whether a <type>text</type> string is well-formed XML,
     returning a Boolean result.
     <function>xml_is_well_formed_document</function> checks for a well-formed
     document, while <function>xml_is_well_formed_content</function> checks
     for well-formed content.  <function>xml_is_well_formed</function> does
     the former if the <xref linkend="guc-xmloption"/> configuration
     parameter is set to <literal>DOCUMENT</literal>, or the latter if it is set to
     <literal>CONTENT</literal>.  This means that
     <function>xml_is_well_formed</function> is useful for seeing whether
     a simple cast to type <type>xml</type> will succeed, whereas the other two
     functions are useful for seeing whether the corresponding variants of
     <function>XMLPARSE</function> will succeed.
-->
これらの関数は<type>text</type>文字列が整形式かどうかをチェックし、論理値で結果を返します。
<function>xml_is_well_formed_document</function>は文書が整形式かをチェックし、一方<function>xml_is_well_formed_content</function>は内容が整形式かをチェックします。
<function>xml_is_well_formed</function>は、<xref linkend="guc-xmloption"/>パラメータ値が<literal>DOCUMENT</literal>に設定されていれば前者を、<literal>CONTENT</literal>が設定されていれば後者のチェックを実施します。
これは、<function>xml_is_well_formed</function>は単純な<type>xml</type>型へのキャストが成功するかの判断に有用であり、その他の２つの関数は<function>XMLPARSE</function>の対応による変換が成功するかの判断に有用であることを意味します。
    </para>

    <para>
<!--
     Examples:
-->
例:

<screen><![CDATA[
SET xmloption TO DOCUMENT;
SELECT xml_is_well_formed('<>');
 xml_is_well_formed 
--------------------
 f
(1 row)

SELECT xml_is_well_formed('<abc/>');
 xml_is_well_formed 
--------------------
 t
(1 row)

SET xmloption TO CONTENT;
SELECT xml_is_well_formed('abc');
 xml_is_well_formed 
--------------------
 t
(1 row)

SELECT xml_is_well_formed_document('<pg:foo xmlns:pg="http://postgresql.org/stuff">bar</pg:foo>');
 xml_is_well_formed_document 
-----------------------------
 t
(1 row)

SELECT xml_is_well_formed_document('<pg:foo xmlns:pg="http://postgresql.org/stuff">bar</my:foo>');
 xml_is_well_formed_document 
-----------------------------
 f
(1 row)
]]></screen>

<!--
     The last example shows that the checks include whether
     namespaces are correctly matched.
-->
最後の例は、名前空間が正しく一致しているかのチェックも含むことを示しています。
    </para>
   </sect3>
  </sect2>

  <sect2 id="functions-xml-processing">
<!--
   <title>Processing XML</title>
-->
   <title>XMLの処理</title>

   <para>
<!--
    To process values of data type <type>xml</type>, PostgreSQL offers
    the functions <function>xpath</function> and
    <function>xpath_exists</function>, which evaluate XPath 1.0
    expressions, and the <function>XMLTABLE</function>
    table function.
-->
データ型<type>xml</type>の値を処理するため、PostgreSQLはXPath 1.0式を評価する関数<function>xpath</function>および<function>xpath_exists</function>と、テーブル関数<function>XMLTABLE</function>を提供しています。
   </para>

   <sect3 id="functions-xml-processing-xpath">
    <title><literal>xpath</literal></title>

    <indexterm>
     <primary>XPath</primary>
    </indexterm>

<synopsis>
<function>xpath</function>(<replaceable>xpath</replaceable>, <replaceable>xml</replaceable> <optional>, <replaceable>nsarray</replaceable></optional>)
</synopsis>

    <para>
<!--
     The function <function>xpath</function> evaluates the XPath 1.0
     expression <replaceable>xpath</replaceable> (a <type>text</type> value)
     against the XML value
     <replaceable>xml</replaceable>.  It returns an array of XML values
     corresponding to the node-set produced by the XPath expression.
     If the XPath expression returns a scalar value rather than a node-set,
     a single-element array is returned.
-->
関数<function>xpath</function>は、XML値<replaceable>xml</replaceable>に対し、XPath 1.0式<replaceable>xpath</replaceable>(ひとつの<type>text</type>値)を評価します。
そして、XPath式で作成されたノード集合に対応するXML値の配列を返します。
もし、XPath式がノード集合ではなくスカラー値を返す場合、単一要素の配列が返されます。
    </para>

    <para>
<!--
     The second argument must be a well formed XML document. In particular,
     it must have a single root node element.
-->
2番目の引数は整形済XML文書でなければなりません。特に、単一のルートノード要素を持たなければなりません。
    </para>

    <para>
<!--
     The optional third argument of the function is an array of namespace
     mappings.  This array should be a two-dimensional <type>text</type> array with
     the length of the second axis being equal to 2 (i.e., it should be an
     array of arrays, each of which consists of exactly 2 elements).
     The first element of each array entry is the namespace name (alias), the
     second the namespace URI. It is not required that aliases provided in
     this array be the same as those being used in the XML document itself (in
     other words, both in the XML document and in the <function>xpath</function>
     function context, aliases are <emphasis>local</emphasis>).
-->
オプショナルな関数の３番目の引数は名前空間マッピング配列です。
この配列は、第２軸が２に等しい長さをもつ２次元<type>text</type>配列です（つまり、それは配列の配列で、それぞれは正確に２つの要素からなります）。
それぞれの配列のエントリの最初の要素は名前空間の名前（別名）で、２番目は名前空間のURIです。
この配列内で提供される別名がXML文書自身で使用されるものと同じであることは必要ではありません（言い換えると、XML文書内および<function>xpath</function>関数の両方の文脈の中で、別名は<emphasis>ローカル</emphasis>です）。
    </para>

    <para>
<!--
     Example:
-->
例：
<screen><![CDATA[
SELECT xpath('/my:a/text()', '<my:a xmlns:my="http://example.com">test</my:a>',
             ARRAY[ARRAY['my', 'http://example.com']]);

 xpath  
--------
 {test}
(1 row)
]]></screen>
    </para>

    <para>
<!--
     To deal with default (anonymous) namespaces, do something like this:
-->
デフォルト(匿名)名前空間を取り扱うためには、以下のようなことを実施してください。
<screen><![CDATA[
SELECT xpath('//mydefns:b/text()', '<a xmlns="http://example.com"><b>test</b></a>',
             ARRAY[ARRAY['mydefns', 'http://example.com']]);

 xpath
--------
 {test}
(1 row)
]]></screen>
    </para>
   </sect3>

   <sect3 id="functions-xml-processing-xpath-exists">
    <title><literal>xpath_exists</literal></title>

    <indexterm>
     <primary>xpath_exists</primary>
    </indexterm>

<synopsis>
<function>xpath_exists</function>(<replaceable>xpath</replaceable>, <replaceable>xml</replaceable> <optional>, <replaceable>nsarray</replaceable></optional>)
</synopsis>

    <para>
<!--
     The function <function>xpath_exists</function> is a specialized form
     of the <function>xpath</function> function.  Instead of returning the
     individual XML values that satisfy the XPath 1.0 expression, this function
     returns a Boolean indicating whether the query was satisfied or not
     (specifically, whether it produced any value other than an empty node-set).
     This function is equivalent to the <literal>XMLEXISTS</literal> predicate,
     except that it also offers support for a namespace mapping argument.
-->
関数<function>xpath_exists</function>は、<function>xpath</function>関数の特別な形式です。
この関数は、XPath 1.0を満足する個別のXML値を返す代わりに、問い合わせがそれを満足するかどうか（具体的には空のノード集合以外の値を返すかどうか）を論理値で返します。
この関数は、名前空間にマッピングされた引数をもサポートする点を除き、標準の<literal>XMLEXISTS</literal>述語と同じです。
    </para>

    <para>
<!--
     Example:
-->
例:
<screen><![CDATA[
SELECT xpath_exists('/my:a/text()', '<my:a xmlns:my="http://example.com">test</my:a>',
                     ARRAY[ARRAY['my', 'http://example.com']]);

 xpath_exists  
--------------
 t
(1 row)
]]></screen>
    </para>
   </sect3>

   <sect3 id="functions-xml-processing-xmltable">
    <title><literal>xmltable</literal></title>

    <indexterm>
     <primary>xmltable</primary>
    </indexterm>

    <indexterm zone="functions-xml-processing-xmltable">
<!--
     <primary>table function</primary>
-->
     <primary>テーブル関数</primary>
     <secondary>XMLTABLE</secondary>
    </indexterm>

<synopsis>
<function>xmltable</function>( <optional>XMLNAMESPACES(<replaceable>namespace uri</replaceable> AS <replaceable>namespace name</replaceable><optional>, ...</optional>), </optional>
          <replaceable>row_expression</replaceable> PASSING <optional>BY { REF | VALUE }</optional> <replaceable>document_expression</replaceable> <optional>BY { REF | VALUE }</optional>
          COLUMNS <replaceable>name</replaceable> { <replaceable>type</replaceable> <optional>PATH <replaceable>column_expression</replaceable></optional> <optional>DEFAULT <replaceable>default_expression</replaceable></optional> <optional>NOT NULL | NULL</optional>
                        | FOR ORDINALITY }
                   <optional>, ...</optional>
)
</synopsis>

    <para>
<!--
     The <function>xmltable</function> function produces a table based
     on the given XML value, an XPath filter to extract rows, and a
     set of column definitions.
-->
<function>xmltable</function>関数は、与えられたXML値、行を抽出するXPathフィルタ、オプションの列定義の集合に基づいてテーブルを生成します。
    </para>

    <para>
<!--
     The optional <literal>XMLNAMESPACES</literal> clause is a comma-separated
     list of namespaces.  It specifies the XML namespaces used in
     the document and their aliases. A default namespace specification
     is not currently supported.
-->
オプションの<literal>XMLNAMESPACES</literal>句はカンマで区切られた名前空間のリストです。
これは文書とその別名で使用されるXML名前空間を指定します。
デフォルトの名前空間指定は現在のところサポートされていません。
    </para>

    <para>
<!--
     The required <replaceable>row_expression</replaceable> argument is
     an XPath 1.0 expression that is evaluated, passing the
     <replaceable>document_expression</replaceable> as its context item, to
     obtain a set of XML nodes. These nodes are what
     <function>xmltable</function> transforms into output rows. No rows
     will be produced if the <replaceable>document_expression</replaceable>
     is null, nor if the <replaceable>row_expression</replaceable> produces
     an empty node-set or any value other than a node-set.
-->
必須の<replaceable>row_expression</replaceable>引数は評価されるXPath 1.0式で、XMLノード集合を得るために<replaceable>document_expression</replaceable>をそのコンテキスト項目として渡します。
このノードは<function>xmltable</function>が出力行に変換します。
<replaceable>document_expression</replaceable>がNULLであるか、<replaceable>row_expression</replaceable>が空のノード集合あるいはノード集合以外の値を生成するなら行は出力されません。
    </para>

    <para>
<!--
     <replaceable>document_expression</replaceable> provides the context
     item for the <replaceable>row_expression</replaceable>. It must be a
     well-formed XML document; fragments/forests are not accepted.
     The <literal>BY REF</literal> and <literal>BY VALUE</literal> clauses
     are accepted but ignored, as discussed in
     <xref linkend="functions-xml-limits-postgresql"/>.
     In the SQL standard, the <function>xmltable</function> function
     evaluates expressions in the XML Query language,
     but <productname>PostgreSQL</productname> allows only XPath 1.0
     expressions, as discussed in
     <xref linkend="functions-xml-limits-xpath1"/>.
-->
<replaceable>document_expression</replaceable>は<replaceable>row_expression</replaceable>のためのコンテキスト項目を提供します。
それは整形式XMLの文書でなければならず、フラグメントやフォレストは受け付けられません。
<xref linkend="functions-xml-limits-postgresql"/>で議論されているように、<literal>BY REF</literal>句と<literal>BY VALUE</literal>句は受け付けられますが、無視されます。
SQL標準では<function>xmltable</function>関数はXML問い合わせ言語の式を評価しますが、<xref linkend="functions-xml-limits-xpath1"/>で議論されているように<productname>PostgreSQL</productname>ではXPath 1.0式だけを受け付けます。
    </para>

    <para>
<!--
     The mandatory <literal>COLUMNS</literal> clause specifies the list
     of columns in the output table.
     Each entry describes a single column.
     See the syntax summary above for the format.
     The column name and type are required; the path, default and
     nullability clauses are optional.
-->
必須の<literal>COLUMNS</literal>句は、出力テーブルの列のリストを指定します。
<literal>COLUMNS</literal>句を省略した場合、結果集合の行には<literal>xml</literal>型の列が1つだけ含まれ、そこには<replaceable>row_expression</replaceable>にマッチしたデータが含まれます。
<literal>COLUMNS</literal>が指定された場合、各エントリは一つの列を表します。
形式については上記の構文サマリーを参照してください。
列名と型は必須ですが、パス、デフォルト値、NULLを許すかどうかの句は省略できます。
    </para>

    <para>
<!--
     A column marked <literal>FOR ORDINALITY</literal> will be populated
     with row numbers, starting with 1, in the order of nodes retrieved from
     the <replaceable>row_expression</replaceable>'s result node-set.
     At most one column may be marked <literal>FOR ORDINALITY</literal>.
-->
<literal>FOR ORDINALITY</literal>と印がつけられた列には、<replaceable>row_expression</replaceable>の結果ノード集合から取得されたノードの順序に対応する1から始まる行番号が入ります。
<literal>FOR ORDINALITY</literal>の印が付けられるのは最大でも1列です。
    </para>

    <note>
     <para>
<!--
      XPath 1.0 does not specify an order for nodes in a node-set, so code
      that relies on a particular order of the results will be
      implementation-dependent.  Details can be found in
      <xref linkend="xml-xpath-1-specifics"/>.
-->
XPath 1.0はノード集合内のノードの順序を指定しません。ですから、結果が特定の順序になっていることに依存するコードは実装依存となります。
詳細は<xref linkend="xml-xpath-1-specifics"/>をご覧ください。
     </para>
    </note>

    <para>
<!--
     The <replaceable>column_expression</replaceable> for a column is an
     XPath 1.0 expression that is evaluated for each row, with the current
     node from the <replaceable>row_expression</replaceable> result as its
     context item, to find the value of the column.  If
     no <replaceable>column_expression</replaceable> is given, then the
     column name is used as an implicit path.
-->
列の<literal>column_expression</literal>はXPath 1.0式で、<replaceable>row_expression</replaceable>の結果における現在のノードをそのコンテキスト項目として<replaceable>row_expression</replaceable>の結果に対応する各行について評価されて、列の値を得ます。
<literal>column_expression</literal>が与えられなかった場合は、暗黙的なパスとして列名が使用されます。
    </para>

    <para>
<!--
     If a column's XPath expression returns a non-XML value (limited to
     string, boolean, or double in XPath 1.0) and the column has a
     PostgreSQL type other than <type>xml</type>, the column will be set
     as if by assigning the value's string representation to the PostgreSQL
     type.  (If the value is a boolean, its string representation is taken
     to be <literal>1</literal> or <literal>0</literal> if the output
     column's type category is numeric, otherwise <literal>true</literal> or
     <literal>false</literal>.)
-->
列のXPath式が非XML値（XPath 1.0における文字列、真偽値、倍精度浮動小数点数に限られます）を返し、その列が<type>xml</type>以外のPostgreSQL型なら、あたかも値の文字列表現をPostgreSQL型にアサインしたように列に値がセットされます。
（値が真偽値の場合、出力列型が数値カテゴリに属するならその文字列表現は<literal>1</literal>または<literal>0</literal>になり、それ外なら<literal>true</literal>または<literal>false</literal>になります。）
    </para>

    <para>
<!--
     If a column's XPath expression returns a non-empty set of XML nodes
     and the column's PostgreSQL type is <type>xml</type>, the column will
     be assigned the expression result exactly, if it is of document or
     content form.
-->
列のXPath表現が空ではないXMLノードの集合を返し、列のPostgreSQL型が<type>xml</type>である場合には、式が文書あるいはフォームの内容なら、列には正確に式の結果がアサインされます。
     <footnote>
      <para>
<!--
       A result containing more than one element node at the top level, or
       non-whitespace text outside of an element, is an example of content form.
       An XPath result can be of neither form, for example if it returns an
       attribute node selected from the element that contains it. Such a result
       will be put into content form with each such disallowed node replaced by
       its string value, as defined for the XPath 1.0
       <function>string</function> function.
-->
トップレベルにおいて複数の要素ノードを含むか、あるいは要素の外側の非空白テキストであるような結果は、コンテントフォームの例です。
XPathの結果はそのどちらでもないフォームであることがあり得ます。
たとえば、それを含む要素から選択された属性ノードを返す場合です。
XPath 1.0の<function>string</function>関数で定義されているように、そうした結果は、許可されないノードを文字列値で置き換えたコンテントフォームに設定されます。
      </para>
     </footnote>
    </para>

    <para>
<!--
     A non-XML result assigned to an <type>xml</type> output column produces
     content, a single text node with the string value of the result.
     An XML result assigned to a column of any other type may not have more than
     one node, or an error is raised. If there is exactly one node, the column
     will be set as if by assigning the node's string
     value (as defined for the XPath 1.0 <function>string</function> function)
     to the PostgreSQL type.
-->
<type>xml</type>出力列にアサインされた非XMLの結果は、結果の値が文字列値となる単一のテキストノードであるコンテントを生成します。
それ以外の型の列にアサインされたXMLの結果は複数のノードを持たないかも知れませんし、エラーを生じするかも知れません。
正確に一つのノードだけが存在するなら、列にはあたかもノードの文字列値（XPath 1.0 <function>string</function>関数の定義されているように） がPostgreSQL型にアサインされたように設定されます。
    </para>

    <para>
<!--
     The string value of an XML element is the concatenation, in document order,
     of all text nodes contained in that element and its descendants. The string
     value of an element with no descendant text nodes is an
     empty string (not <literal>NULL</literal>).
     Any <literal>xsi:nil</literal> attributes are ignored.
     Note that the whitespace-only <literal>text()</literal> node between two non-text
     elements is preserved, and that leading whitespace on a <literal>text()</literal>
     node is not flattened.
     The XPath 1.0 <function>string</function> function may be consulted for the
     rules defining the string value of other XML node types and non-XML values.
-->
ある要素と、その子孫に含まれるすべてのテキストノードをドキュメントの順に結合したものがXML要素の文字列値です。
テキストノードの子孫を持たない要素の文字列値は空文字列です。（ <literal>NULL</literal>ではありません。）
すべての<literal>xsi:nil</literal>属性は無視されます。
非テキスト要素の間にある空白のみからなる<literal>text()</literal>2つのノードは保存され、<literal>text()</literal>の先頭の空白は平坦化されないことに注意してください。
XPath 1.0 <function>string</function>関数が、他のXMLノード型と非XML値の文字列値を定義するルールのために参照されるかも知れません。
    </para>

    <para>
<!--
     The conversion rules presented here are not exactly those of the SQL
     standard, as discussed in <xref linkend="functions-xml-limits-casts"/>.
-->
ここで示した変換ルールは、<xref linkend="functions-xml-limits-casts"/>で議論されているように、正確にSQL標準に従っているわけではありません。
    </para>

    <para>
<!--
     If the path expression returns an empty node-set
     (typically, when it does not match)
     for a given row, the column will be set to <literal>NULL</literal>, unless
     a <replaceable>default_expression</replaceable> is specified; then the
     value resulting from evaluating that expression is used.
-->
パス式がある行に対して空のノード集合（典型的にはマッチしなかった場合）を返した時は、<replaceable>default_expression</replaceable>が指定されている場合を除き、列には<literal>NULL</literal>が設定されます。
そしてその式を評価した結果から生じる値が使用されます。
    </para>

    <para>
<!--
     Columns may be marked <literal>NOT NULL</literal>. If the
     <replaceable>column_expression</replaceable> for a <literal>NOT NULL</literal> column
     does not match anything and there is no <literal>DEFAULT</literal> or the
     <replaceable>default_expression</replaceable> also evaluates to null, an error
     is reported.
-->
列には<literal>NOT NULL</literal>の印をつけることができます。
<literal>NOT NULL</literal>の列の<replaceable>column_expression</replaceable>が何にもマッチせず、<literal>DEFAULT</literal>がない、あるいは<replaceable>default_expression</replaceable>の評価結果もNULLになるという場合はエラーが報告されます。
    </para>

    <para>
<!--
     A <replaceable>default_expression</replaceable>, rather than being
     evaluated immediately when <function>xmltable</function> is called,
     is evaluated each time a default is needed for the column.
     If the expression qualifies as stable or immutable, the repeat
     evaluation may be skipped.
     This means that you can usefully use volatile functions like
     <function>nextval</function> in
     <replaceable>default_expression</replaceable>.
-->
<function>xmltable</function>が呼び出されて直ちに評価されるのと異なり、<replaceable>default_expression</replaceable>はその列に対してデフォルトが必要になるたびに評価されます。
式が安定（stable）または不変（immutable）とみなされる場合、評価は繰り返し行われないかもしれません。
これは<replaceable>default_expression</replaceable>の中で<function>nextval</function>のような揮発性関数を使用できることを意味します。
    </para>

    <para>
<!--
     Examples:
-->
例：
  <screen><![CDATA[
CREATE TABLE xmldata AS SELECT
xml $$
<ROWS>
  <ROW id="1">
    <COUNTRY_ID>AU</COUNTRY_ID>
    <COUNTRY_NAME>Australia</COUNTRY_NAME>
  </ROW>
  <ROW id="5">
    <COUNTRY_ID>JP</COUNTRY_ID>
    <COUNTRY_NAME>Japan</COUNTRY_NAME>
    <PREMIER_NAME>Shinzo Abe</PREMIER_NAME>
    <SIZE unit="sq_mi">145935</SIZE>
  </ROW>
  <ROW id="6">
    <COUNTRY_ID>SG</COUNTRY_ID>
    <COUNTRY_NAME>Singapore</COUNTRY_NAME>
    <SIZE unit="sq_km">697</SIZE>
  </ROW>
</ROWS>
$$ AS data;

SELECT xmltable.*
  FROM xmldata,
       XMLTABLE('//ROWS/ROW'
                PASSING data
                COLUMNS id int PATH '@id',
                        ordinality FOR ORDINALITY,
                        "COUNTRY_NAME" text,
                        country_id text PATH 'COUNTRY_ID',
                        size_sq_km float PATH 'SIZE[@unit = "sq_km"]',
                        size_other text PATH
                             'concat(SIZE[@unit!="sq_km"], " ", SIZE[@unit!="sq_km"]/@unit)',
                        premier_name text PATH 'PREMIER_NAME' DEFAULT 'not specified') ;

 id | ordinality | COUNTRY_NAME | country_id | size_sq_km |  size_other  | premier_name  
----+------------+--------------+------------+------------+--------------+---------------
  1 |          1 | Australia    | AU         |            |              | not specified
  5 |          2 | Japan        | JP         |            | 145935 sq_mi | Shinzo Abe
  6 |          3 | Singapore    | SG         |        697 |              | not specified
]]></screen>

<!--
     The following example shows concatenation of multiple text() nodes,
     usage of the column name as XPath filter, and the treatment of whitespace,
     XML comments and processing instructions:
-->
以下の例では、複数のtext()ノードの結合、列名のXPathフィルターとしての使用、空白文字、XMLコメント、処理命令の取扱いを示します。

  <screen><![CDATA[
CREATE TABLE xmlelements AS SELECT
xml $$
  <root>
   <element>  Hello<!-- xyxxz -->2a2<?aaaaa?> <!--x-->  bbb<x>xxx</x>CC  </element>
  </root>
$$ AS data;

SELECT xmltable.*
  FROM xmlelements, XMLTABLE('/root' PASSING data COLUMNS element text);
         element         
-------------------------
   Hello2a2   bbbxxxCC  
]]></screen>
    </para>

    <para>
<!--
     The following example illustrates how
     the <literal>XMLNAMESPACES</literal> clause can be used to specify
     a list of namespaces
     used in the XML document as well as in the XPath expressions:
-->
以下の例では、<literal>XMLNAMESPACES</literal>句を使ってXMLドキュメントやXPath式で使われる追加の名前空間のリストを指定する方法を示します。

  <screen><![CDATA[
WITH xmldata(data) AS (VALUES ('
<example xmlns="http://example.com/myns" xmlns:B="http://example.com/b">
 <item foo="1" B:bar="2"/>
 <item foo="3" B:bar="4"/>
 <item foo="4" B:bar="5"/>
</example>'::xml)
)
SELECT xmltable.*
  FROM XMLTABLE(XMLNAMESPACES('http://example.com/myns' AS x,
                              'http://example.com/b' AS "B"),
             '/x:example/x:item'
                PASSING (SELECT data FROM xmldata)
                COLUMNS foo int PATH '@foo',
                  bar int PATH '@B:bar');
 foo | bar
-----+-----
   1 |   2
   3 |   4
   4 |   5
(3 rows)
]]></screen>
    </para>
   </sect3>
  </sect2>

  <sect2 id="functions-xml-mapping">
<!--
   <title>Mapping Tables to XML</title>
-->
   <title>XMLにテーブルをマップ</title>

   <indexterm zone="functions-xml-mapping">
<!--
    <primary>XML export</primary>
-->
    <primary>XMLエクスポート</primary>
   </indexterm>

   <para>
<!--
    The following functions map the contents of relational tables to
    XML values.  They can be thought of as XML export functionality:
-->
以下の関数はリレーショナルテーブルの内容をXML値にマップします。
これらはXMLエクスポート機能と考えることができます。
<synopsis>
table_to_xml(tbl regclass, nulls boolean, tableforest boolean, targetns text)
query_to_xml(query text, nulls boolean, tableforest boolean, targetns text)
cursor_to_xml(cursor refcursor, count int, nulls boolean,
              tableforest boolean, targetns text)
</synopsis>
<!--
    The return type of each function is <type>xml</type>.
-->
それぞれの関数の戻り値型は<type>xml</type>です。
   </para>

   <para>
<!--
    <function>table_to_xml</function> maps the content of the named
    table, passed as parameter <parameter>tbl</parameter>.  The
    <type>regclass</type> type accepts strings identifying tables using the
    usual notation, including optional schema qualifications and
    double quotes.  <function>query_to_xml</function> executes the
    query whose text is passed as parameter
    <parameter>query</parameter> and maps the result set.
    <function>cursor_to_xml</function> fetches the indicated number of
    rows from the cursor specified by the parameter
    <parameter>cursor</parameter>.  This variant is recommended if
    large tables have to be mapped, because the result value is built
    up in memory by each function.
-->
<function>table_to_xml</function>は、パラメータ<parameter>tbl</parameter>として渡された名前付きのテーブルの内容をマップします。
<type>regclass</type>型はオプションのスキーマ修飾と二重引用符を含む、通常の表記法を使用しテーブルを特定する文字列を受け付けます。
<function>query_to_xml</function>は、パラメータ<parameter>query</parameter>としてテキストが渡された問い合わせを実行し、結果セットをマップします。
<function>cursor_to_xml</function>は、パラメータ<parameter>cursor</parameter>で指定されたカーソルから提示された行数を取得します。
それぞれの関数により結果値がメモリーに構築されるため、この異形は巨大なテーブルをマップする必要がある場合推奨されます。
   </para>

   <para>
<!--
    If <parameter>tableforest</parameter> is false, then the resulting
    XML document looks like this:
-->
<parameter>tableforest</parameter>が偽であれば、結果のXML文書は以下のようになります。
<screen><![CDATA[
<tablename>
  <row>
    <columnname1>data</columnname1>
    <columnname2>data</columnname2>
  </row>

  <row>
    ...
  </row>

  ...
</tablename>
]]></screen>

<!--
    If <parameter>tableforest</parameter> is true, the result is an
    XML content fragment that looks like this:
-->
<parameter>tableforest</parameter>が真であれば、結果は以下のようなXML文書の断片です。
<screen><![CDATA[
<tablename>
  <columnname1>data</columnname1>
  <columnname2>data</columnname2>
</tablename>

<tablename>
  ...
</tablename>

...
]]></screen>

<!--
    If no table name is available, that is, when mapping a query or a
    cursor, the string <literal>table</literal> is used in the first
    format, <literal>row</literal> in the second format.
-->
テーブル名が利用できないとき、つまり、問い合わせ、またはカーソルをマップする時は、最初の書式では文字列<literal>table</literal>が使用され、２番目の書式では<literal>row</literal>が使用されます。
   </para>

   <para>
<!--
    The choice between these formats is up to the user.  The first
    format is a proper XML document, which will be important in many
    applications.  The second format tends to be more useful in the
    <function>cursor_to_xml</function> function if the result values are to be
    reassembled into one document later on.  The functions for
    producing XML content discussed above, in particular
    <function>xmlelement</function>, can be used to alter the results
    to taste.
-->
これらどの書式を選択するのかはユーザ次第です。
最初の書式は適切なXML文書で、多くのアプリケーションにおいて重要です。
第２の書式は、後に結果値が１つの文書に再び組み立てられる場合、<function>cursor_to_xml</function>関数内でより有用になる傾向があります。
上記で説明したXML内容を作成する関数、特に<function>xmlelement</function>は結果を好みにかえるために使用することができます。
   </para>

   <para>
<!--
    The data values are mapped in the same way as described for the
    function <function>xmlelement</function> above.
-->
データの値は上記関数<function>xmlelement</function>で説明したのと同じ方法でマップされます。
   </para>

   <para>
<!--
    The parameter <parameter>nulls</parameter> determines whether null
    values should be included in the output.  If true, null values in
    columns are represented as:
-->
パラメータ<parameter>nulls</parameter>は出力にNULL値が含まれる必要があるかを決定します。
もし真であれば列内のNULL値は以下のように表現されます。
<screen><![CDATA[
<columnname xsi:nil="true"/>
]]></screen>
<!--
    where <literal>xsi</literal> is the XML namespace prefix for XML
    Schema Instance.  An appropriate namespace declaration will be
    added to the result value.  If false, columns containing null
    values are simply omitted from the output.
-->
ここで<literal>xsi</literal>はXMLスキーマインスタンスに対するXML名前空間接頭辞です。
適切な名前空間宣言が結果値に追加されます。
もし偽の場合、NULL値を含む列は単に出力から削除されます。
   </para>

   <para>
<!--
    The parameter <parameter>targetns</parameter> specifies the
    desired XML namespace of the result.  If no particular namespace
    is wanted, an empty string should be passed.
-->
パラメータ<parameter>targetns</parameter>は結果の希望するXML名前空間を指定します。
特定の名前空間が必要なければ、空文字列を渡す必要があります。
   </para>

   <para>
<!--
    The following functions return XML Schema documents describing the
    mappings performed by the corresponding functions above:
-->
以下の関数は、対応する上記関数により行われたマッピングを記述するXMLスキーマ文書を返します。
<synopsis>
table_to_xmlschema(tbl regclass, nulls boolean, tableforest boolean, targetns text)
query_to_xmlschema(query text, nulls boolean, tableforest boolean, targetns text)
cursor_to_xmlschema(cursor refcursor, nulls boolean, tableforest boolean, targetns text)
</synopsis>
<!--
    It is essential that the same parameters are passed in order to
    obtain matching XML data mappings and XML Schema documents.
-->
    一致するXMLデータマッピングとXMLスキーマ文書を取得するため、同じパラメータが渡されることが不可欠です。
   </para>

   <para>
<!--
    The following functions produce XML data mappings and the
    corresponding XML Schema in one document (or forest), linked
    together.  They can be useful where self-contained and
    self-describing results are wanted:
-->
以下の関数は、XMLデータマッピングとそれに対応するXMLスキーマがお互いにリンクされた、１つの文書（またはフォレスト）を作成します。
これらは自己完結した、自己記述的な結果を希望する場合に便利です。
<synopsis>
table_to_xml_and_xmlschema(tbl regclass, nulls boolean, tableforest boolean, targetns text)
query_to_xml_and_xmlschema(query text, nulls boolean, tableforest boolean, targetns text)
</synopsis>
   </para>

   <para>
<!--
    In addition, the following functions are available to produce
    analogous mappings of entire schemas or the entire current
    database:
-->
さらに、以下の関数がスキーマ全体、または現在のデータベース全体の類似マッピングを作成するため利用できます。
<synopsis>
schema_to_xml(schema name, nulls boolean, tableforest boolean, targetns text)
schema_to_xmlschema(schema name, nulls boolean, tableforest boolean, targetns text)
schema_to_xml_and_xmlschema(schema name, nulls boolean, tableforest boolean, targetns text)

database_to_xml(nulls boolean, tableforest boolean, targetns text)
database_to_xmlschema(nulls boolean, tableforest boolean, targetns text)
database_to_xml_and_xmlschema(nulls boolean, tableforest boolean, targetns text)
</synopsis>

<!--
    Note that these potentially produce a lot of data, which needs to
    be built up in memory.  When requesting content mappings of large
    schemas or databases, it might be worthwhile to consider mapping the
    tables separately instead, possibly even through a cursor.
-->
これらはメモリー内に作成される必要がある、多くのデータを生成する潜在的可能性があることに注意してください。
巨大なスキーマ、またはデータベースの内容マッピングを要求する際は、その代わりにテーブルを別々にマップすること、さらにはカーソル経由とすることさえ、検討することは無駄ではありません。
   </para>

   <para>
<!--
    The result of a schema content mapping looks like this:
-->
スキーマ内容マッピングの結果は以下のようになります。

<screen><![CDATA[
<schemaname>

table1-mapping

table2-mapping

...

</schemaname>]]></screen>

<!--
    where the format of a table mapping depends on the
    <parameter>tableforest</parameter> parameter as explained above.
-->
ここで、テーブルマッピング書式は上で説明したとおり<parameter>tableforest</parameter>パラメータに依存します。
   </para>

   <para>
<!--
    The result of a database content mapping looks like this:
-->
データベース内容マッピング書式は以下のようになります。

<screen><![CDATA[
<dbname>

<schema1name>
  ...
</schema1name>

<schema2name>
  ...
</schema2name>

...

</dbname>]]></screen>

<!--
    where the schema mapping is as above.
-->
ここで、スキーママッピングは上記のとおりです。
   </para>

   <para>
<!--
    As an example of using the output produced by these functions,
    <xref linkend="xslt-xml-html"/> shows an XSLT stylesheet that
    converts the output of
    <function>table_to_xml_and_xmlschema</function> to an HTML
    document containing a tabular rendition of the table data.  In a
    similar manner, the results from these functions can be
    converted into other XML-based formats.
-->
これらの関数で作成された出力を使用する１つの例として、<xref linkend="xslt-xml-html"/>は、テーブルデータの表形式への翻訳を含む<function>table_to_xml_and_xmlschema</function>からHTML文書への出力の変換をおこなうXSLTスタイルシートを示します。
同じようにして、これらの関数の結果は他のXML基準書式に変換されます。
   </para>

   <figure id="xslt-xml-html">
<!--
    <title>XSLT Stylesheet for Converting SQL/XML Output to HTML</title>
-->
    <title>SQL/XML出力をHTMLに変換するXSLTスタイルシート</title>
<programlisting><![CDATA[
<?xml version="1.0"?>
<xsl:stylesheet version="1.0"
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:xsd="http://www.w3.org/2001/XMLSchema"
    xmlns="http://www.w3.org/1999/xhtml"
>

  <xsl:output method="xml"
      doctype-system="http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"
      doctype-public="-//W3C/DTD XHTML 1.0 Strict//EN"
      indent="yes"/>

  <xsl:template match="/*">
    <xsl:variable name="schema" select="//xsd:schema"/>
    <xsl:variable name="tabletypename"
                  select="$schema/xsd:element[@name=name(current())]/@type"/>
    <xsl:variable name="rowtypename"
                  select="$schema/xsd:complexType[@name=$tabletypename]/xsd:sequence/xsd:element[@name='row']/@type"/>

    <html>
      <head>
        <title><xsl:value-of select="name(current())"/></title>
      </head>
      <body>
        <table>
          <tr>
            <xsl:for-each select="$schema/xsd:complexType[@name=$rowtypename]/xsd:sequence/xsd:element/@name">
              <th><xsl:value-of select="."/></th>
            </xsl:for-each>
          </tr>

          <xsl:for-each select="row">
            <tr>
              <xsl:for-each select="*">
                <td><xsl:value-of select="."/></td>
              </xsl:for-each>
            </tr>
          </xsl:for-each>
        </table>
      </body>
    </html>
  </xsl:template>

</xsl:stylesheet>
]]></programlisting>
   </figure>
  </sect2>
 </sect1>

<!-- split-func2-end -->
<!-- split-func3-start -->

 <sect1 id="functions-json">
<!--
  <title>JSON Functions and Operators</title>
-->
  <title>JSON関数と演算子</title>

  <indexterm zone="functions-json">
   <primary>JSON</primary>
<!--
   <secondary>functions and operators</secondary>
-->
   <secondary>関数と演算子</secondary>
  </indexterm>

  <para>
<!--
   This section describes:
-->
この節では次のことを説明します。

   <itemizedlist>
    <listitem>
     <para>
<!--
      functions and operators for processing and creating JSON data
-->
JSONデータを処理、生成する関数と演算子
     </para>
    </listitem>
    <listitem>
     <para>
<!--
      the SQL/JSON path language
-->
SQL/JSONパス言語
     </para>
    </listitem>
   </itemizedlist>
  </para>

  <para>
<!--
   To learn more about the SQL/JSON standard, see
   <xref linkend="sqltr-19075-6"/>. For details on JSON types
   supported in <productname>PostgreSQL</productname>,
   see <xref linkend="datatype-json"/>.
-->
SQL/JSON標準を更に学ぶためには、<xref linkend="sqltr-19075-6"/>をご覧ください。
<productname>PostgreSQL</productname>でサポートされているJSON型の詳細に関しては、<xref linkend="datatype-json"/>をご覧ください。
  </para>

  <sect2 id="functions-json-processing">
<!--
   <title>Processing and Creating JSON Data</title>
-->
   <title>JSONデータの処理と生成</title>

  <para>
<!--
   <xref linkend="functions-json-op-table"/> shows the operators that
   are available for use with JSON data types (see <xref
   linkend="datatype-json"/>).
-->
<xref linkend="functions-json-op-table"/>にJSONデータ型(<xref linkend="datatype-json"/>を参照)で使用可能な演算子を示します。
  </para>

  <table id="functions-json-op-table">
<!--
     <title><type>json</type> and <type>jsonb</type> Operators</title>
-->
     <title><type>json</type>と<type>jsonb</type>演算子</title>
     <tgroup cols="6">
      <thead>
       <row>
<!--
        <entry>Operator</entry>
        <entry>Right Operand Type</entry>
        <entry>Return type</entry>
        <entry>Description</entry>
        <entry>Example</entry>
        <entry>Example Result</entry>
-->
        <entry>演算子</entry>
        <entry>右オペランド型</entry>
        <entry>戻り値型</entry>
        <entry>説明</entry>
        <entry>例</entry>
        <entry>例の結果</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><literal>-&gt;</literal></entry>
        <entry><type>int</type></entry>
        <entry><type>json</type> or <type>jsonb</type></entry>
<!--
        <entry>Get JSON array element (indexed from zero, negative
        integers count from the end)</entry>
-->
        <entry>JSON配列要素を取得（添字はゼロから、負数なら後ろから数える）</entry>
        <entry><literal>'[{"a":"foo"},{"b":"bar"},{"c":"baz"}]'::json-&gt;2</literal></entry>
        <entry><literal>{"c":"baz"}</literal></entry>
       </row>
       <row>
        <entry><literal>-&gt;</literal></entry>
        <entry><type>text</type></entry>
        <entry><type>json</type> or <type>jsonb</type></entry>
<!--
        <entry>Get JSON object field by key</entry>
-->
        <entry>キーに依るJSONオブジェクトフィールド取得</entry>
        <entry><literal>'{"a": {"b":"foo"}}'::json-&gt;'a'</literal></entry>
        <entry><literal>{"b":"foo"}</literal></entry>
       </row>
        <row>
        <entry><literal>-&gt;&gt;</literal></entry>
        <entry><type>int</type></entry>
        <entry><type>text</type></entry>
<!--
        <entry>Get JSON array element as <type>text</type></entry>
-->
        <entry>JSON 配列要素を<type>text</type>として取得</entry>
        <entry><literal>'[1,2,3]'::json-&gt;&gt;2</literal></entry>
        <entry><literal>3</literal></entry>
       </row>
       <row>
        <entry><literal>-&gt;&gt;</literal></entry>
        <entry><type>text</type></entry>
        <entry><type>text</type></entry>
<!--
        <entry>Get JSON object field as <type>text</type></entry>
-->
        <entry>JSON オブジェクトフィールドを<type>text</type>として取得</entry>
        <entry><literal>'{"a":1,"b":2}'::json-&gt;&gt;'b'</literal></entry>
        <entry><literal>2</literal></entry>
       </row>
       <row>
        <entry><literal>#&gt;</literal></entry>
        <entry><type>text[]</type></entry>
        <entry><type>json</type> or <type>jsonb</type></entry>
<!--
        <entry>Get JSON object at the specified path</entry>
-->
        <entry>指定されたパスにあるJSONオブジェクトを取得</entry>
        <entry><literal>'{"a": {"b":{"c": "foo"}}}'::json#&gt;'{a,b}'</literal></entry>
        <entry><literal>{"c": "foo"}</literal></entry>
       </row>
       <row>
        <entry><literal>#&gt;&gt;</literal></entry>
        <entry><type>text[]</type></entry>
        <entry><type>text</type></entry>
<!--
        <entry>Get JSON object at the specified path as <type>text</type></entry>
-->
        <entry>指定されたパスにあるJSONオブジェクトを<type>text</type>として取得</entry>
        <entry><literal>'{"a":[1,2,3],"b":[4,5,6]}'::json#&gt;&gt;'{a,2}'</literal></entry>
        <entry><literal>3</literal></entry>
       </row>
      </tbody>
     </tgroup>
   </table>

  <note>
   <para>
<!--
    There are parallel variants of these operators for both the
    <type>json</type> and <type>jsonb</type> types.
    The field/element/path extraction operators
    return the same type as their left-hand input (either <type>json</type>
    or <type>jsonb</type>), except for those specified as
    returning <type>text</type>, which coerce the value to text.
    The field/element/path extraction operators return NULL, rather than
    failing, if the JSON input does not have the right structure to match
    the request; for example if no such element exists.  The
    field/element/path extraction operators that accept integer JSON
    array subscripts all support negative subscripting from the end of
    arrays.
-->
<type>json</type>と<type>jsonb</type>型の両方に対して、以上の演算子の対応するものがあります。
フィールド/要素/パス抽出演算子は左辺の入力と同じ型（<type>json</type>または<type>jsonb</type>）を返します。
ただし、<type>text</type>を返すと明示してあるものは、値をテキストに変換して返します。
JSON入力が要求と一致する正しい構造をしていなければ、フィールド/要素/パス抽出演算子は失敗するのではなくNULLを返します。例えばそのような要素が存在しない場合です。
JSON配列の添字を整数で受け取り、フィールド、要素、パスを返す演算子はすべて、配列の終わりから数える負の添字をサポートします。
   </para>
  </note>
  <para>
<!--
   The standard comparison operators shown in  <xref
   linkend="functions-comparison-op-table"/> are available for
   <type>jsonb</type>, but not for <type>json</type>. They follow the
   ordering rules for B-tree operations outlined at <xref
   linkend="json-indexing"/>.
-->
<xref linkend="functions-comparison-op-table"/>に示されている標準の比較演算子が<type>jsonb</type>で利用可能ですが、<type>json</type>ではそうではありません。
それらは<xref linkend="json-indexing"/>で概略を述べたB-tree演算子の順序規則に従います。
  </para>
  <para>
<!--
   Some further operators also exist only for <type>jsonb</type>, as shown
   in <xref linkend="functions-jsonb-op-table"/>.
   Many of these operators can be indexed by
   <type>jsonb</type> operator classes.  For a full description of
   <type>jsonb</type> containment and existence semantics, see <xref
   linkend="json-containment"/>.  <xref linkend="json-indexing"/>
   describes how these operators can be used to effectively index
   <type>jsonb</type> data.
-->
ほかに<type>jsonb</type>だけで利用可能な演算子もいくつか存在します。
それらを<xref linkend="functions-jsonb-op-table"/>に示します。
これらのうち多くの演算子は<type>jsonb</type>演算子クラスでインデックス付けすることが可能です。
<type>jsonb</type>の包含と存在の意味に関する完全な記述は<xref linkend="json-containment"/>を参照してください。
<xref linkend="json-indexing"/>には、<type>jsonb</type>データを効率的にインデックス付けするためにこれらの演算子をどのように利用できるかについて書いてあります。
  </para>
  <table id="functions-jsonb-op-table">
<!--
     <title>Additional <type>jsonb</type> Operators</title>
-->
     <title>追加<type>jsonb</type>演算子</title>
     <tgroup cols="4">
      <thead>
       <row>
<!--
        <entry>Operator</entry>
        <entry>Right Operand Type</entry>
        <entry>Description</entry>
        <entry>Example</entry>
-->
        <entry>演算子</entry>
        <entry>右オペランド型</entry>
        <entry>説明</entry>
        <entry>例</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><literal>@&gt;</literal></entry>
        <entry><type>jsonb</type></entry>
<!--
        <entry>Does the left JSON value contain the right JSON
        path/value entries at the top level?</entry>
-->
        <entry>左のJSON値はトップレベルにおいて右のJSONパスまたは値を包含するか</entry>
        <entry><literal>'{"a":1, "b":2}'::jsonb &#64;&gt; '{"b":2}'::jsonb</literal></entry>
       </row>
       <row>
        <entry><literal>&lt;@</literal></entry>
        <entry><type>jsonb</type></entry>
<!--
        <entry>Are the left JSON path/value entries contained at the top level within
        the right JSON value?</entry>
-->
        <entry>左のJSONパスまたは値は右のJSON値にトップレベルで包含されるか</entry>
        <entry><literal>'{"b":2}'::jsonb &lt;@ '{"a":1, "b":2}'::jsonb</literal></entry>
       </row>
       <row>
        <entry><literal>?</literal></entry>
        <entry><type>text</type></entry>
<!--
        <entry>Does the <emphasis>string</emphasis> exist as a top-level
        key within the JSON value?</entry>
-->
        <entry><emphasis>文字列</emphasis>はJSON値のトップレベルのキーとして存在するか</entry>
        <entry><literal>'{"a":1, "b":2}'::jsonb ? 'b'</literal></entry>
       </row>
       <row>
        <entry><literal>?|</literal></entry>
        <entry><type>text[]</type></entry>
<!--
        <entry>Do any of these array <emphasis>strings</emphasis>
        exist as top-level keys?</entry>
-->
        <entry>配列の<emphasis>文字列</emphasis>のいずれかがトップレベルのキーとして存在するか。</entry>
        <entry><literal>'{"a":1, "b":2, "c":3}'::jsonb ?| array['b', 'c']</literal></entry>
       </row>
       <row>
        <entry><literal>?&amp;</literal></entry>
        <entry><type>text[]</type></entry>
<!--
        <entry>Do all of these array <emphasis>strings</emphasis> exist
        as top-level keys?</entry>
-->
        <entry>配列の<emphasis>文字列</emphasis>のすべてがトップレベルのキーとして存在するか。</entry>
        <entry><literal>'["a", "b"]'::jsonb ?&amp; array['a', 'b']</literal></entry>
       </row>
       <row>
        <entry><literal>||</literal></entry>
        <entry><type>jsonb</type></entry>
<!--
        <entry>Concatenate two <type>jsonb</type> values into a new <type>jsonb</type> value</entry>
-->
        <entry>2つの<type>jsonb</type>値を結合して、新しい<type>jsonb</type>値を作る</entry>
        <entry><literal>'["a", "b"]'::jsonb || '["c", "d"]'::jsonb</literal></entry>
       </row>
       <row>
        <entry><literal>-</literal></entry>
        <entry><type>text</type></entry>
<!--
        <entry>Delete key/value pair or <emphasis>string</emphasis>
        element from left operand.  Key/value pairs are matched based
        on their key value.</entry>
-->
        <entry>左のオペランドからキー／値のペア、あるいは<emphasis>文字列</emphasis>要素を削除する。
キー／値のペアはキーの値に基づいてマッチされる。</entry>
        <entry><literal>'{"a": "b"}'::jsonb - 'a' </literal></entry>
       </row>
       <row>
        <entry><literal>-</literal></entry>
        <entry><type>text[]</type></entry>
<!--
        <entry>Delete multiple key/value pairs or <emphasis>string</emphasis>
        elements from left operand.  Key/value pairs are matched based
        on their key value.</entry>
-->
        <entry>左のオペランドから複数のキー／値のペア、あるいは<emphasis>文字列</emphasis>要素を削除する。
キー／値のペアはキーの値に基づいてマッチされる。</entry>
        <entry><literal>'{"a": "b", "c": "d"}'::jsonb - '{a,c}'::text[] </literal></entry>
       </row>
       <row>
        <entry><literal>-</literal></entry>
        <entry><type>integer</type></entry>
<!--
        <entry>Delete the array element with specified index (Negative
        integers count from the end).  Throws an error if top level
        container is not an array.</entry>
-->
        <entry>指定した添字の配列要素を削除する（負数の場合は後ろから数えます）。
トップレベルのコンテナが配列でないときはエラーが発生する。</entry>
        <entry><literal>'["a", "b"]'::jsonb - 1 </literal></entry>
       </row>
       <row>
        <entry><literal>#-</literal></entry>
        <entry><type>text[]</type></entry>
<!--
        <entry>Delete the field or element with specified path (for
        JSON arrays, negative integers count from the end)</entry>
-->
        <entry>指定したパスのフィールドまたは要素を削除する（JSON配列では、負数は後ろから数えます）</entry>
        <entry><literal>'["a", {"b":1}]'::jsonb #- '{1,b}'</literal></entry>
       </row>
       <row>
        <entry><literal>@?</literal></entry>
        <entry><type>jsonpath</type></entry>
<!--
        <entry>Does JSON path return any item for the specified JSON value?</entry>
-->
        <entry>JSONパスが指定したJSON値に対応する要素を返すか？</entry>
        <entry><literal>'{"a":[1,2,3,4,5]}'::jsonb @? '$.a[*] ? (@ > 2)'</literal></entry>
       </row>
       <row>
        <entry><literal>@@</literal></entry>
        <entry><type>jsonpath</type></entry>
<!--
        <entry>Returns the result of JSON path predicate check for the specified JSON value.
        Only the first item of the result is taken into account.  If the
        result is not Boolean, then <literal>null</literal> is returned.</entry>
-->
        <entry>指定したJSON値のJSONパス述語チェックの結果を返す。
        結果の最初の項目だけが考慮されます。
        結果がBooleanでないなら、<literal>null</literal>が返ります。</entry>
        <entry><literal>'{"a":[1,2,3,4,5]}'::jsonb @@ '$.a[*] > 2'</literal></entry>
       </row>
      </tbody>
     </tgroup>
   </table>

  <note>
   <para>
<!--
    The <literal>||</literal> operator concatenates the elements at the top level of
    each of its operands. It does not operate recursively. For example, if
    both operands are objects with a common key field name, the value of the
    field in the result will just be the value from the right hand operand.
-->
<literal>||</literal>演算子は、両オペランドのトップレベルで要素を結合します。
再帰的には作用しません。
例えば、両方のオペランドが同じキーフィールド名のオブジェクトの場合、そのフィールドの値は、単に右側のオペランドの値になります。
   </para>
  </note>

  <note>
   <para>
<!--
    The <literal>@?</literal> and <literal>@@</literal> operators suppress
    the following errors: lacking object field or array element, unexpected
    JSON item type, and numeric errors.
    This behavior might be helpful while searching over JSON document
    collections of varying structure.
-->
<literal>@?</literal>および<literal>@@</literal>演算子は以下のエラーを抑止します。
オブジェクトフィールドあるいは配列要素の欠如、期待しないJSON要素型、数値エラー。
この振る舞いは、異なる構造のJSON文書集合を検索する際に役に立つかも知れません。
   </para>
  </note>

  <para>
<!--
   <xref linkend="functions-json-creation-table"/> shows the functions that are
   available for creating <type>json</type> and <type>jsonb</type> values.
   (There are no equivalent functions for <type>jsonb</type>, of the <literal>row_to_json</literal>
   and <literal>array_to_json</literal> functions. However, the <literal>to_jsonb</literal>
   function supplies much the same functionality as these functions would.)
-->
<xref linkend="functions-json-creation-table"/>に、JSON値および<type>jsonb</type>値を作成するために利用可能な関数を示します。
（<literal>row_to_json</literal>関数および<literal>array_to_json</literal>関数と同等な<type>jsonb</type>の関数はありません。
しかし、<literal>to_jsonb</literal>を使えば、これらの関数と同じ機能を提供できるでしょう。）
  </para>

  <indexterm>
   <primary>to_json</primary>
  </indexterm>
  <indexterm>
   <primary>array_to_json</primary>
  </indexterm>
  <indexterm>
   <primary>row_to_json</primary>
  </indexterm>
  <indexterm>
   <primary>json_build_array</primary>
  </indexterm>
  <indexterm>
   <primary>json_build_object</primary>
  </indexterm>
  <indexterm>
   <primary>json_object</primary>
  </indexterm>
  <indexterm>
   <primary>to_jsonb</primary>
  </indexterm>
  <indexterm>
   <primary>jsonb_build_array</primary>
  </indexterm>
  <indexterm>
   <primary>jsonb_build_object</primary>
  </indexterm>
  <indexterm>
   <primary>jsonb_object</primary>
  </indexterm>

  <table id="functions-json-creation-table">
<!--
    <title>JSON Creation Functions</title>
-->
    <title>JSON作成関数</title>
    <tgroup cols="4">
     <thead>
      <row>
<!--
       <entry>Function</entry>
       <entry>Description</entry>
       <entry>Example</entry>
       <entry>Example Result</entry>
-->
       <entry>関数</entry>
       <entry>説明</entry>
       <entry>例</entry>
       <entry>例の結果</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><para><literal>to_json(anyelement)</literal>
          </para><para><literal>to_jsonb(anyelement)</literal>
       </para></entry>
       <entry>
<!--
         Returns the value as <type>json</type> or <type>jsonb</type>.
         Arrays and composites are converted
         (recursively) to arrays and objects; otherwise, if there is a cast
         from the type to <type>json</type>, the cast function will be used to
         perform the conversion; otherwise, a scalar value is produced.
         For any scalar type other than a number, a Boolean, or a null value,
         the text representation will be used, in such a fashion that it is a
         valid <type>json</type> or <type>jsonb</type> value.
-->
<type>json</type>あるいは<type>jsonb</type>として値を返す。
配列と複合型は（再帰的に）配列とオブジェクトに変換される。
あるいは、その型から<type>json</type>にキャストがあれば、キャスト関数が変換のために用いられる。
そうでなければ、スカラ値が生成される。
数値、論理値、またはNULL値以外のスカラ型に対しては、有効な<type>json</type>値あるいは<type>jsonb</type>値となる形式の文字列表現が使用される。
       </entry>
       <entry><literal>to_json('Fred said "Hi."'::text)</literal></entry>
       <entry><literal>"Fred said \"Hi.\""</literal></entry>
      </row>
      <row>
       <entry>
         <literal>array_to_json(anyarray [, pretty_bool])</literal>
       </entry>
       <entry>
<!--
         Returns the array as a JSON array. A PostgreSQL multidimensional array
         becomes a JSON array of arrays. Line feeds will be added between
         dimension-1 elements if <parameter>pretty_bool</parameter> is true.
-->
配列をJSON配列として返す。
PostgreSQLの多次元配列はJSON配列の配列となる。
<parameter>pretty_bool</parameter>が真の場合、次元数-1の要素の間に改行が加えられる。
       </entry>
       <entry><literal>array_to_json('{{1,5},{99,100}}'::int[])</literal></entry>
       <entry><literal>[[1,5],[99,100]]</literal></entry>
      </row>
      <row>
       <entry>
         <literal>row_to_json(record [, pretty_bool])</literal>
       </entry>
       <entry>
<!--
         Returns the row as a JSON object. Line feeds will be added between
         level-1 elements if <parameter>pretty_bool</parameter> is true.
-->
行をJSONオブジェクトとして返す。
<parameter>pretty_bool</parameter>が真の場合、レベル-1の要素の間に改行が加えられる。
       </entry>
       <entry><literal>row_to_json(row(1,'foo'))</literal></entry>
       <entry><literal>{"f1":1,"f2":"foo"}</literal></entry>
      </row>
      <row>
       <entry><para><literal>json_build_array(VARIADIC "any")</literal>
          </para><para><literal>jsonb_build_array(VARIADIC "any")</literal>
       </para></entry>
       <entry>
<!--
         Builds a possibly-heterogeneously-typed JSON array out of a variadic
         argument list.
-->
異なる型から構成される可能性のあるJSON配列をvariadic引数リストから作成。
       </entry>
       <entry><literal>json_build_array(1,2,'3',4,5)</literal></entry>
       <entry><literal>[1, 2, "3", 4, 5]</literal></entry>
      </row>
      <row>
       <entry><para><literal>json_build_object(VARIADIC "any")</literal>
          </para><para><literal>jsonb_build_object(VARIADIC "any")</literal>
       </para></entry>
       <entry>
<!--
         Builds a JSON object out of a variadic argument list.  By
         convention, the argument list consists of alternating
         keys and values.
-->
variadic引数リストからJSONオブジェクトを作成。
慣例により引数リストはキーと値が交互に並んだもの。
       </entry>
       <entry><literal>json_build_object('foo',1,'bar',2)</literal></entry>
       <entry><literal>{"foo": 1, "bar": 2}</literal></entry>
      </row>
      <row>
       <entry><para><literal>json_object(text[])</literal>
          </para><para><literal>jsonb_object(text[])</literal>
       </para></entry>
       <entry>
<!--
         Builds a JSON object out of a text array.  The array must have either
         exactly one dimension with an even number of members, in which case
         they are taken as alternating key/value pairs, or two dimensions
         such that each inner array has exactly two elements, which
         are taken as a key/value pair.
-->
テキスト配列からJSONオブジェクトを作成。
配列は、偶数個の要素からなる1次元（キー／値の対が交互に並んでいるものと扱われる)）あるいは内側の配列が2つの要素を持つ2次元（2つの要素がキー／値の対として扱われる）のいずれかでなければならない。
       </entry>
       <entry><para><literal>json_object('{a, 1, b, "def", c, 3.5}')</literal></para>
        <para><literal>json_object('{{a, 1},{b, "def"},{c, 3.5}}')</literal></para></entry>
       <entry><literal>{"a": "1", "b": "def", "c": "3.5"}</literal></entry>
      </row>
      <row>
       <entry><para><literal>json_object(keys text[], values text[])</literal>
          </para><para><literal>jsonb_object(keys text[], values text[])</literal>
       </para></entry>
       <entry>
<!--
         This form of <function>json_object</function> takes keys and values pairwise from two separate
         arrays. In all other respects it is identical to the one-argument form.
-->
この形の<function>json_object</function>は2つの別々の配列からキーと値の対を取る。
他の点ではすべて、引数1つの形と同じ。
       </entry>
       <entry><literal>json_object('{a, b}', '{1,2}')</literal></entry>
       <entry><literal>{"a": "1", "b": "2"}</literal></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <note>
    <para>
<!--
     <function>array_to_json</function> and <function>row_to_json</function> have the same
     behavior as <function>to_json</function> except for offering a pretty-printing
     option.  The behavior described for <function>to_json</function> likewise applies
     to each individual value converted by the other JSON creation functions.
-->
<function>array_to_json</function>と<function>row_to_json</function>は表示を整えるオプションを提供する以外は<function>to_json</function>と同様の振舞いをします。
同様に<function>to_json</function>に書かれた振舞いはJSON作成関数により変換された個々の値に適用されます。
    </para>
  </note>

  <note>
    <para>
<!--
     The <xref linkend="hstore"/> extension has a cast
     from <type>hstore</type> to <type>json</type>, so that
     <type>hstore</type> values converted via the JSON creation functions
     will be represented as JSON objects, not as primitive string values.
-->
<xref linkend="hstore"/>拡張は<type>hstore</type>から<type>json</type>へのキャストを含みます。従って、JSON作成関数で変換された<type>hstore</type>値は元の文字列値ではなくJSONオブジェクトとして示されます。
    </para>
  </note>

  <para>
<!--
   <xref linkend="functions-json-processing-table"/> shows the functions that
   are available for processing <type>json</type> and <type>jsonb</type> values.
-->
<xref linkend="functions-json-processing-table"/>に<type>json</type>と<type>jsonb</type>値を処理するのに使える関数を示します。
  </para>

  <indexterm>
   <primary>json_array_length</primary>
  </indexterm>
  <indexterm>
   <primary>jsonb_array_length</primary>
  </indexterm>
  <indexterm>
   <primary>json_each</primary>
  </indexterm>
  <indexterm>
   <primary>jsonb_each</primary>
  </indexterm>
  <indexterm>
   <primary>json_each_text</primary>
  </indexterm>
  <indexterm>
   <primary>jsonb_each_text</primary>
  </indexterm>
  <indexterm>
   <primary>json_extract_path</primary>
  </indexterm>
  <indexterm>
   <primary>jsonb_extract_path</primary>
  </indexterm>
  <indexterm>
   <primary>json_extract_path_text</primary>
  </indexterm>
  <indexterm>
   <primary>jsonb_extract_path_text</primary>
  </indexterm>
  <indexterm>
   <primary>json_object_keys</primary>
  </indexterm>
  <indexterm>
   <primary>jsonb_object_keys</primary>
  </indexterm>
  <indexterm>
   <primary>json_populate_record</primary>
  </indexterm>
  <indexterm>
   <primary>jsonb_populate_record</primary>
  </indexterm>
  <indexterm>
   <primary>json_populate_recordset</primary>
  </indexterm>
  <indexterm>
   <primary>jsonb_populate_recordset</primary>
  </indexterm>
  <indexterm>
   <primary>json_array_elements</primary>
  </indexterm>
  <indexterm>
   <primary>jsonb_array_elements</primary>
  </indexterm>
  <indexterm>
   <primary>json_array_elements_text</primary>
  </indexterm>
  <indexterm>
   <primary>jsonb_array_elements_text</primary>
  </indexterm>
  <indexterm>
   <primary>json_typeof</primary>
  </indexterm>
  <indexterm>
   <primary>jsonb_typeof</primary>
  </indexterm>
  <indexterm>
   <primary>json_to_record</primary>
  </indexterm>
  <indexterm>
   <primary>jsonb_to_record</primary>
  </indexterm>
  <indexterm>
   <primary>json_to_recordset</primary>
  </indexterm>
  <indexterm>
   <primary>jsonb_to_recordset</primary>
  </indexterm>
  <indexterm>
   <primary>json_strip_nulls</primary>
  </indexterm>
  <indexterm>
   <primary>jsonb_strip_nulls</primary>
  </indexterm>
  <indexterm>
   <primary>jsonb_set</primary>
  </indexterm>
  <indexterm>
   <primary>jsonb_insert</primary>
  </indexterm>
  <indexterm>
   <primary>jsonb_pretty</primary>
  </indexterm>
  <indexterm>
   <primary>jsonb_path_exists</primary>
  </indexterm>
  <indexterm>
   <primary>jsonb_path_match</primary>
  </indexterm>
  <indexterm>
   <primary>jsonb_path_query</primary>
  </indexterm>
  <indexterm>
   <primary>jsonb_path_query_array</primary>
  </indexterm>
  <indexterm>
   <primary>jsonb_path_query_first</primary>
  </indexterm>

  <table id="functions-json-processing-table">
<!--
    <title>JSON Processing Functions</title>
-->
    <title>JSON処理関数</title>
    <tgroup cols="5">
     <thead>
      <row>
<!--
       <entry>Function</entry>
       <entry>Return Type</entry>
       <entry>Description</entry>
       <entry>Example</entry>
       <entry>Example Result</entry>
-->
       <entry>関数</entry>
       <entry>戻り値型</entry>
       <entry>説明</entry>
       <entry>例</entry>
       <entry>例の結果</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><para><literal>json_array_length(json)</literal>
         </para><para><literal>jsonb_array_length(jsonb)</literal>
       </para></entry>
       <entry><type>int</type></entry>
       <entry>
<!--
         Returns the number of elements in the outermost JSON array.
-->
         JSON配列の最も外側の要素の数を返す。
       </entry>
       <entry><literal>json_array_length('[1,2,3,{"f1":1,"f2":[5,6]},4]')</literal></entry>
       <entry><literal>5</literal></entry>
      </row>
      <row>
       <entry><para><literal>json_each(json)</literal>
         </para><para><literal>jsonb_each(jsonb)</literal>
       </para></entry>
       <entry><para><literal>setof key text, value json</literal>
         </para><para><literal>setof key text, value jsonb</literal>
       </para></entry>
       <entry>
<!--
         Expands the outermost JSON object into a set of key/value pairs.
-->
         JSONオブジェクトの最も外側をkey/valueの組み合わせに拡張する。
       </entry>
       <entry><literal>select * from json_each('{"a":"foo", "b":"bar"}')</literal></entry>
       <entry>
<programlisting>
 key | value
-----+-------
 a   | "foo"
 b   | "bar"
</programlisting>
       </entry>
      </row>
      <row>
       <entry><para><literal>json_each_text(json)</literal>
         </para><para><literal>jsonb_each_text(jsonb)</literal>
       </para></entry>
       <entry><type>setof key text, value text</type></entry>
       <entry>
<!--
         Expands the outermost JSON object into a set of key/value pairs. The
         returned values will be of type <type>text</type>.
-->
        JSONオブジェクトの最も外側をkey/valueの組み合わせに拡張する。返り値は型<type>text</type>。
       </entry>
       <entry><literal>select * from json_each_text('{"a":"foo", "b":"bar"}')</literal></entry>
       <entry>
<programlisting>
 key | value
-----+-------
 a   | foo
 b   | bar
</programlisting>
       </entry>
      </row>
      <row>
       <entry><para><literal>json_extract_path(from_json json, VARIADIC path_elems text[])</literal>
        </para><para><literal>jsonb_extract_path(from_json jsonb, VARIADIC path_elems text[])</literal>
       </para></entry>
       <entry><para><type>json</type></para><para><type>jsonb</type>
       </para></entry>
       <entry>
<!--
         Returns JSON value pointed to by <replaceable>path_elems</replaceable>
         (equivalent to <literal>#&gt;</literal> operator).
-->
        <replaceable>path_elems</replaceable>で示されたJSONオブジェクトを返す(<literal>#&gt;</literal>と同じ)。
       </entry>
       <entry><literal>json_extract_path('{"f2":{"f3":1},"f4":{"f5":99,"f6":"foo"}}','f4')</literal></entry>
       <entry><literal>{"f5":99,"f6":"foo"}</literal></entry>
      </row>
      <row>
       <entry><para><literal>json_extract_path_text(from_json json, VARIADIC path_elems text[])</literal>
         </para><para><literal>jsonb_extract_path_text(from_json jsonb, VARIADIC path_elems text[])</literal>
       </para></entry>
       <entry><type>text</type></entry>
       <entry>
<!--
         Returns JSON value pointed to by <replaceable>path_elems</replaceable>
         as <type>text</type>
         (equivalent to <literal>#&gt;&gt;</literal> operator).
-->
        <replaceable>path_elems</replaceable>で示されたJSONオブジェクトを<type>text</type>として返す(<literal>#&gt;&gt;</literal>演算子と同じ)。
       </entry>
       <entry><literal>json_extract_path_text('{"f2":{"f3":1},"f4":{"f5":99,"f6":"foo"}}','f4', 'f6')</literal></entry>
       <entry><literal>foo</literal></entry>
      </row>
      <row>
       <entry><para><literal>json_object_keys(json)</literal>
         </para><para><literal>jsonb_object_keys(jsonb)</literal>
       </para></entry>
       <entry><type>setof text</type></entry>
       <entry>
<!--
          Returns set of keys in the outermost JSON object.
-->
        最も外側のJSONオブジェクトの中のキーの集合を返す。
       </entry>
       <entry><literal>json_object_keys('{"f1":"abc","f2":{"f3":"a", "f4":"b"}}')</literal></entry>
       <entry>
<programlisting>
 json_object_keys
------------------
 f1
 f2
</programlisting>
       </entry>
      </row>
      <row>
       <entry><para><literal>json_populate_record(base anyelement, from_json json)</literal>
         </para><para><literal>jsonb_populate_record(base anyelement, from_json jsonb)</literal>
       </para></entry>
       <entry><type>anyelement</type></entry>
       <entry>
<!--
         Expands the object in <replaceable>from_json</replaceable> to a row
         whose columns match the record type defined by <replaceable>base</replaceable>
         (see note below).
-->
<replaceable>from_json</replaceable>内のオブジェクト行を<replaceable>base</replaceable>で定義されたレコード型に一致する列に拡張する(以下の注意書きを参照)。
       </entry>
       <entry><literal>select * from json_populate_record(null::myrowtype, '{"a": 1, "b": ["2", "a b"], "c": {"d": 4, "e": "a  b c"}}')</literal></entry>
       <entry>
<programlisting>
 a |   b       |      c
---+-----------+-------------
 1 | {2,"a b"} | (4,"a b c")
</programlisting>
       </entry>
      </row>
      <row>
       <entry><para><literal>json_populate_recordset(base anyelement, from_json json)</literal>
         </para><para><literal>jsonb_populate_recordset(base anyelement, from_json jsonb)</literal>
       </para></entry>
       <entry><type>setof anyelement</type></entry>
       <entry>
<!--
         Expands the outermost array of objects
         in <replaceable>from_json</replaceable> to a set of rows whose
         columns match the record type defined by <replaceable>base</replaceable> (see
         note below).
-->
<replaceable>from_json</replaceable>におけるオブジェクトの最も外側の配列を<replaceable>base</replaceable>で定義されたレコード型に一致する列を持つ行の集合に展開する(以下の注意書き参照)。
       </entry>
       <entry><literal>select * from json_populate_recordset(null::myrowtype, '[{"a":1,"b":2},{"a":3,"b":4}]')</literal></entry>
       <entry>
<programlisting>
 a | b
---+---
 1 | 2
 3 | 4
</programlisting>
       </entry>
      </row>
      <row>
       <entry><para><literal>json_array_elements(json)</literal>
         </para><para><literal>jsonb_array_elements(jsonb)</literal>
       </para></entry>
       <entry><para><type>setof json</type>
         </para><para><type>setof jsonb</type>
       </para></entry>
       <entry>
<!--
         Expands a JSON array to a set of JSON values.
-->
JSON配列をJSON値の集合に展開する。
       </entry>
       <entry><literal>select * from json_array_elements('[1,true, [2,false]]')</literal></entry>
       <entry>
<programlisting>
   value
-----------
 1
 true
 [2,false]
</programlisting>
       </entry>
      </row>
      <row>
       <entry><para><literal>json_array_elements_text(json)</literal>
         </para><para><literal>jsonb_array_elements_text(jsonb)</literal>
       </para></entry>
       <entry><type>setof text</type></entry>
       <entry>
<!--
         Expands a JSON array to a set of <type>text</type> values.
-->
JSON配列を<type>text</type>値の集合に展開する。
       </entry>
       <entry><literal>select * from json_array_elements_text('["foo", "bar"]')</literal></entry>
       <entry>
<programlisting>
   value
-----------
 foo
 bar
</programlisting>
       </entry>
      </row>
      <row>
       <entry><para><literal>json_typeof(json)</literal>
         </para><para><literal>jsonb_typeof(jsonb)</literal>
       </para></entry>
       <entry><type>text</type></entry>
       <entry>
<!--
         Returns the type of the outermost JSON value as a text string.
         Possible types are
         <literal>object</literal>, <literal>array</literal>, <literal>string</literal>, <literal>number</literal>,
         <literal>boolean</literal>, and <literal>null</literal>.
-->
最も外側のJSON値の型をテキスト文字列として返す。
取りうる型は<literal>object</literal>、 <literal>array</literal>、 <literal>string</literal>、 <literal>number</literal>、<literal>boolean</literal>、<literal>null</literal>である。
       </entry>
       <entry><literal>json_typeof('-123.4')</literal></entry>
       <entry><literal>number</literal></entry>
      </row>
      <row>
       <entry><para><literal>json_to_record(json)</literal>
          </para><para><literal>jsonb_to_record(jsonb)</literal>
       </para></entry>
       <entry><type>record</type></entry>
       <entry>
<!--
         Builds an arbitrary record from a JSON object (see note below).  As
         with all functions returning <type>record</type>, the caller must
         explicitly define the structure of the record with an <literal>AS</literal>
         clause.
-->
JSONオブジェクトから任意のレコードを作成する（下記の注釈を参照）。
<type>record</type>を返す関数すべてと同様、呼び出し側が<literal>AS</literal>句でレコードの構造を明示的に決める必要がある。
       </entry>
       <entry><literal>select * from json_to_record('{"a":1,"b":[1,2,3],"c":[1,2,3],"e":"bar","r": {"a": 123, "b": "a b c"}}') as x(a int, b text, c int[], d text, r myrowtype) </literal></entry>
       <entry>
<programlisting>
 a |    b    |    c    | d |       r
---+---------+---------+---+---------------
 1 | [1,2,3] | {1,2,3} |   | (123,"a b c")
</programlisting>
       </entry>
      </row>
      <row>
       <entry><para><literal>json_to_recordset(json)</literal>
         </para><para><literal>jsonb_to_recordset(jsonb)</literal>
       </para></entry>
       <entry><type>setof record</type></entry>
       <entry>
<!--
         Builds an arbitrary set of records from a JSON array of objects (see
         note below).  As with all functions returning <type>record</type>, the
         caller must explicitly define the structure of the record with
         an <literal>AS</literal> clause.
-->
オブジェクトの配列のJSONから任意のレコードの集合を作成する（下記の注釈を参照）。
<type>record</type>を返す関数すべてと同様、呼び出し側が<literal>AS</literal>句でレコードの構造を明示的に決める必要がある。
       </entry>
       <entry><literal>select * from json_to_recordset('[{"a":1,"b":"foo"},{"a":"2","c":"bar"}]') as x(a int, b text);</literal></entry>
       <entry>
<programlisting>
 a |  b
---+-----
 1 | foo
 2 |
</programlisting>
       </entry>
      </row>
      <row>
       <entry><para><literal>json_strip_nulls(from_json json)</literal>
         </para><para><literal>jsonb_strip_nulls(from_json jsonb)</literal>
       </para></entry>
       <entry><para><type>json</type></para><para><type>jsonb</type></para></entry>
       <entry>
<!--
         Returns <replaceable>from_json</replaceable>
         with all object fields that have null values omitted. Other null values
         are untouched.
-->
NULL値を持つオブジェクトフィールドを削除した<replaceable>from_json</replaceable>を返す。
他のNULL値はそのまま残る。
       </entry>
       <entry><literal>json_strip_nulls('[{"f1":1,"f2":null},2,null,3]')</literal></entry>
       <entry><literal>[{"f1":1},2,null,3]</literal></entry>
       </row>
      <row>
       <entry><para><literal>jsonb_set(target jsonb, path text[], new_value jsonb <optional>, create_missing boolean</optional>)</literal>
         </para></entry>
       <entry><para><type>jsonb</type></para></entry>
       <entry>
<!--
         Returns <replaceable>target</replaceable>
         with the section designated by <replaceable>path</replaceable>
         replaced by <replaceable>new_value</replaceable>, or with
         <replaceable>new_value</replaceable> added if
         <replaceable>create_missing</replaceable> is true (default is
         <literal>true</literal>) and the item
         designated by <replaceable>path</replaceable> does not exist.
         As with the path oriented operators, negative integers that
         appear in <replaceable>path</replaceable> count from the end
         of JSON arrays.
-->
<replaceable>path</replaceable>で指定した部分を<replaceable>new_value</replaceable>で置換、
あるいは<replaceable>create_missing</replaceable>が真（デフォルトは<literal>true</literal>）で<replaceable>path</replaceable>で指定した項目が存在しないなら<replaceable>new_value</replaceable>を追加して、
<replaceable>target</replaceable>を返す。
パスの位置についての演算子について、<replaceable>path</replaceable>の中にある負の整数はJSON配列の終わりから数える。
       </entry>
       <entry><para><literal>jsonb_set('[{"f1":1,"f2":null},2,null,3]', '{0,f1}','[2,3,4]', false)</literal>
         </para><para><literal>jsonb_set('[{"f1":1,"f2":null},2]', '{0,f3}','[2,3,4]')</literal>
         </para></entry>
       <entry><para><literal>[{"f1":[2,3,4],"f2":null},2,null,3]</literal>
         </para><para><literal>[{"f1": 1, "f2": null, "f3": [2, 3, 4]}, 2]</literal>
        </para></entry>
       </row>
      <row>
       <entry>
           <para><literal>
           jsonb_insert(target jsonb, path text[], new_value jsonb <optional>, insert_after boolean</optional>)
           </literal></para>
       </entry>
       <entry><para><type>jsonb</type></para></entry>
       <entry>
<!--
         Returns <replaceable>target</replaceable> with
         <replaceable>new_value</replaceable> inserted. If
         <replaceable>target</replaceable> section designated by
         <replaceable>path</replaceable> is in a JSONB array,
         <replaceable>new_value</replaceable> will be inserted before target or
         after if <replaceable>insert_after</replaceable> is true (default is
         <literal>false</literal>). If <replaceable>target</replaceable> section
         designated by <replaceable>path</replaceable> is in JSONB object,
         <replaceable>new_value</replaceable> will be inserted only if
         <replaceable>target</replaceable> does not exist. As with the path
         oriented operators, negative integers that appear in
         <replaceable>path</replaceable> count from the end of JSON arrays.
-->
<replaceable>new_value</replaceable>を挿入して<replaceable>target</replaceable>を返す。
<replaceable>path</replaceable>で指定した<replaceable>target</replaceable>の部分がJSONB配列内にある場合は、<replaceable>new_value</replaceable>はtargetの前に挿入されるか、あるいは、<replaceable>insert_after</replaceable>が真であれば（デフォルトは<literal>false</literal>）、後に挿入される。
<replaceable>path</replaceable>で指定した<replaceable>target</replaceable>の部分がJSONBオブジェクト内にある場合は、<replaceable>new_value</replaceable>は<replaceable>target</replaceable>が存在しない場合にのみ挿入される。
pathについての演算子について言うと、<replaceable>new_value</replaceable>内の負の整数はJSON配列の終わりから数える。
       </entry>
       <entry>
           <para><literal>
               jsonb_insert('{"a": [0,1,2]}', '{a, 1}', '"new_value"')
           </literal></para>
           <para><literal>
               jsonb_insert('{"a": [0,1,2]}', '{a, 1}', '"new_value"', true)
           </literal></para>
       </entry>
       <entry><para><literal>{"a": [0, "new_value", 1, 2]}</literal>
         </para><para><literal>{"a": [0, 1, "new_value", 2]}</literal>
        </para></entry>
       </row>
      <row>
       <entry><para><literal>jsonb_pretty(from_json jsonb)</literal>
         </para></entry>
       <entry><para><type>text</type></para></entry>
       <entry>
<!--
         Returns <replaceable>from_json</replaceable>
         as indented JSON text.
-->
<replaceable>from_json</replaceable>をインデントしたJSON文字列にして返す。
       </entry>
       <entry><literal>jsonb_pretty('[{"f1":1,"f2":null},2,null,3]')</literal></entry>
       <entry>
<programlisting>
[
    {
        "f1": 1,
        "f2": null
    },
    2,
    null,
    3
]
</programlisting>
        </entry>
       </row>
       <row>
        <entry>
         <para><literal>
           jsonb_path_exists(target jsonb, path jsonpath <optional>, vars jsonb <optional>, silent bool</optional></optional>)
         </literal></para>
        </entry>
        <entry><type>boolean</type></entry>
        <entry>
<!--
          Checks whether JSON path returns any item for the specified JSON
          value.
-->
JSONパスが指定したJSON値に対して項目を返すかどうかをチェックする。
        </entry>
        <entry>
         <para><literal>
           jsonb_path_exists('{"a":[1,2,3,4,5]}', '$.a[*] ? (@ >= $min &amp;&amp; @ &lt;= $max)', '{"min":2,"max":4}')
         </literal></para>
        </entry>
        <entry>
          <para><literal>true</literal></para>
        </entry>
       </row>
       <row>
        <entry>
         <para><literal>
           jsonb_path_match(target jsonb, path jsonpath <optional>, vars jsonb <optional>, silent bool</optional></optional>)
         </literal></para>
        </entry>
        <entry><type>boolean</type></entry>
        <entry>
<!--
          Returns the result of JSON path predicate check for the specified JSON value.
          Only the first item of the result is taken into account.  If the
          result is not Boolean, then <literal>null</literal> is returned.
-->
        指定したJSON値のJSONパス述語チェックの結果を返す。
        結果の最初の項目だけが考慮されます。
        結果がBooleanでないなら、<literal>null</literal>が返ります。
        </entry>
        <entry>
         <para><literal>
           jsonb_path_match('{"a":[1,2,3,4,5]}', 'exists($.a[*] ? (@ >= $min &amp;&amp; @ &lt;= $max))', '{"min":2,"max":4}')
        </literal></para>
        </entry>
        <entry>
          <para><literal>true</literal></para>
        </entry>
       </row>
       <row>
        <entry>
         <para><literal>
           jsonb_path_query(target jsonb, path jsonpath <optional>, vars jsonb <optional>, silent bool</optional></optional>)
         </literal></para>
        </entry>
        <entry><type>setof jsonb</type></entry>
        <entry>
<!--
          Gets all JSON items returned by JSON path for the specified JSON
          value.
-->
指定したJSON値に対してJSONパスが返すすべてのJSON項目を得る。
        </entry>
        <entry>
         <para><literal>
           select * from jsonb_path_query('{"a":[1,2,3,4,5]}', '$.a[*] ? (@ >= $min &amp;&amp; @ &lt;= $max)', '{"min":2,"max":4}');
         </literal></para>
        </entry>
        <entry>
         <para>
<programlisting>
 jsonb_path_query
------------------
 2
 3
 4
</programlisting>
         </para>
        </entry>
       </row>
       <row>
        <entry>
         <para><literal>
           jsonb_path_query_array(target jsonb, path jsonpath <optional>, vars jsonb <optional>, silent bool</optional></optional>)
         </literal></para>
        </entry>
        <entry><type>jsonb</type></entry>
        <entry>
<!--
          Gets all JSON items returned by JSON path for the specified JSON
          value and wraps result into an array.
-->
指定したJSON値に対してJSONパスが返すすべてのJSON項目を得て配列に格納する。
        </entry>
        <entry>
         <para><literal>
           jsonb_path_query_array('{"a":[1,2,3,4,5]}', '$.a[*] ? (@ >= $min &amp;&amp; @ &lt;= $max)', '{"min":2,"max":4}')
         </literal></para>
        </entry>
        <entry>
          <para><literal>[2, 3, 4]</literal></para>
        </entry>
       </row>
       <row>
        <entry>
         <para><literal>
           jsonb_path_query_first(target jsonb, path jsonpath <optional>, vars jsonb <optional>, silent bool</optional></optional>)
         </literal></para>
        </entry>
        <entry><type>jsonb</type></entry>
        <entry>
<!--
          Gets the first JSON item returned by JSON path for the specified JSON
          value.  Returns <literal>NULL</literal> on no results.
-->
指定したJSON値に対するJSONパスが返す最初のJSON項目を得る。
結果がなければ<literal>NULL</literal>を返す。
        </entry>
        <entry>
         <para><literal>
           jsonb_path_query_first('{"a":[1,2,3,4,5]}', '$.a[*] ? (@ >= $min &amp;&amp; @ &lt;= $max)', '{"min":2,"max":4}')
         </literal></para>
        </entry>
        <entry>
          <para><literal>2</literal></para>
        </entry>
       </row>
     </tbody>
    </tgroup>
   </table>

  <note>
    <para>
<!--
      Many of these functions and operators will convert Unicode escapes in
      JSON strings to the appropriate single character.  This is a non-issue
      if the input is type <type>jsonb</type>, because the conversion was already
      done; but for <type>json</type> input, this may result in throwing an error,
      as noted in <xref linkend="datatype-json"/>.
-->
これらの関数や演算子の多くは、JSON文字列のUnicodeのエスケープを適切な一文字に変換します。
これは入力が<type>jsonb</type>型であれば、変換は既に行なわれていますので、重要な問題ではありません。しかし、<type>json</type>の入力に対しては、<xref linkend="datatype-json"/>で言及したようにこれはエラーを発生させる結果になるかもしれません。
    </para>
  </note>

  <note>
   <para>
<!--
    The functions
    <function>json[b]_populate_record</function>,
    <function>json[b]_populate_recordset</function>,
    <function>json[b]_to_record</function> and
    <function>json[b]_to_recordset</function>
    operate on a JSON object, or array of objects, and extract the values
    associated with keys whose names match column names of the output row
    type.
    Object fields that do not correspond to any output column name are
    ignored, and output columns that do not match any object field will be
    filled with nulls.
    To convert a JSON value to the SQL type of an output column, the
    following rules are applied in sequence:
-->
関数<function>json[b]_populate_record</function>、<function>json[b]_populate_recordset</function>、<function>json[b]_to_record</function>、<function>json[b]_to_recordset</function>はJSONオブジェクトあるいはJSONオブジェクトの配列を操作し、出力行型の列名と一致する名前を持つキーに関連付けられた値を取り出します。
出力列名と関連付けられないオブジェクトのフィールドは無視され、どのオブジェクトフィールドとも一致しない出力列はNULLで満たされます。
JSON値を出力列のSQL型に変換する際に以下のルールが順番に適用されます。
    <itemizedlist spacing="compact">
     <listitem>
      <para>
<!--
       A JSON null value is converted to a SQL null in all cases.
-->
すべての場合にJSONのNULL値はSQLのNULLに変換されます。
      </para>
     </listitem>
     <listitem>
      <para>
<!--
       If the output column is of type <type>json</type>
       or <type>jsonb</type>, the JSON value is just reproduced exactly.
-->
出力列が<type>json</type>型あるいは<type>jsonb</type>型なら、JSON値は単にそのまま複製されます。
      </para>
     </listitem>
     <listitem>
      <para>
<!--
       If the output column is a composite (row) type, and the JSON value is
       a JSON object, the fields of the object are converted to columns of
       the output row type by recursive application of these rules.
-->
出力行が複合(行)型でJSON値がJSONオブジェクトなら、これらのルールを再帰的に適用することによって、オブジェクトのフィールドが出力行型の列に変換されます。
      </para>
     </listitem>
     <listitem>
      <para>
<!--
       Likewise, if the output column is an array type and the JSON value is
       a JSON array, the elements of the JSON array are converted to elements
       of the output array by recursive application of these rules.
-->
同様に、出力行が配列型でJSON値がJSON配列なら、これらのルールを再帰的に適用することによって、JSON配列の要素が出力配列の要素に変換されます。
      </para>
     </listitem>
     <listitem>
      <para>
<!--
       Otherwise, if the JSON value is a string literal, the contents of the
       string are fed to the input conversion function for the column's data
       type.
-->
それ以外の場合で、JSON値が文字列リテラルなら、その文字列の内容が列のデータ型に対応する入力変換関数に送られます。
      </para>
     </listitem>
     <listitem>
      <para>
<!--
       Otherwise, the ordinary text representation of the JSON value is fed
       to the input conversion function for the column's data type.
-->
さもなければ、通常のJSON値のテキスト表現が列のデータ型に対応する入力変換関数に送られます。
      </para>
     </listitem>
    </itemizedlist>
   </para>

   <para>
<!--
    While the examples for these functions use constants, the typical use
    would be to reference a table in the <literal>FROM</literal> clause
    and use one of its <type>json</type> or <type>jsonb</type> columns
    as an argument to the function.  Extracted key values can then be
    referenced in other parts of the query, like <literal>WHERE</literal>
    clauses and target lists.  Extracting multiple values in this
    way can improve performance over extracting them separately with
    per-key operators.
  -->
これらの関数の例では定数を使用していますが、典型的な使用法は<literal>FROM</literal>句でテーブルを参照し、その<type>json</type>または<type>jsonb</type>列を関数の引数として使用することです。
<literal>WHERE</literal>句やターゲットリストのように、抽出されたキー値はクエリの他の部分で参照することができます。
この方法で複数の値を抽出すると、キー単位の演算子で個別に抽出するよりもパフォーマンスが向上します。
   </para>
  </note>

  <note>
    <para>
<!--
      All the items of the <literal>path</literal> parameter of <literal>jsonb_set</literal>
      as well as <literal>jsonb_insert</literal> except the last item must be present
      in the <literal>target</literal>. If <literal>create_missing</literal> is false, all
      items of the <literal>path</literal> parameter of <literal>jsonb_set</literal> must be
      present. If these conditions are not met the <literal>target</literal> is
      returned unchanged.
-->
<literal>jsonb_set</literal>および<literal>jsonb_insert</literal>の<literal>path</literal>パラメータは、最後の項目を除き、すべての項目が<literal>target</literal>内に存在しなければなりません。
<literal>create_missing</literal>が偽なら、<literal>jsonb_set</literal>の<literal>path</literal>パラメータのすべての項目が存在しなければなりません。
これらの条件が満たされなければ、<literal>target</literal>が変更されずに返されます。
    </para>
    <para>
<!--
      If the last path item is an object key, it will be created if it
      is absent and given the new value. If the last path item is an array
      index, if it is positive the item to set is found by counting from
      the left, and if negative by counting from the right - <literal>-1</literal>
      designates the rightmost element, and so on.
      If the item is out of the range -array_length .. array_length -1,
      and create_missing is true, the new value is added at the beginning
      of the array if the item is negative, and at the end of the array if
      it is positive.
-->
パスの最後の要素がオブジェクトのキーの場合、それが存在しなければ作成されて、新しい値が与えられます。
パスの最後の項目が配列の添字の場合、それが正ならセットすべき項目は左から数えられ、負なら右から数えられます（<literal>-1</literal>は最も右側の要素を指す、という具合です）。
項目が[-array_length .. array_length -1]の範囲外にあり、かつcreate_missingが真なら、新しい値が配列の先頭（項目が負数のとき）あるいは配列の終わり（項目が正数のとき）に追加されます。
    </para>
  </note>

  <note>
    <para>
<!--
      The <literal>json_typeof</literal> function's <literal>null</literal> return value
      should not be confused with a SQL NULL.  While
      calling <literal>json_typeof('null'::json)</literal> will
      return <literal>null</literal>, calling <literal>json_typeof(NULL::json)</literal>
      will return a SQL NULL.
-->
<literal>json_typeof</literal>の<literal>null</literal>戻り値をSQLのNULLと混同してはいけません。
<literal>json_typeof('null'::json)</literal>を呼び出すと<literal>null</literal>が返りますが、<literal>json_typeof(NULL::json)</literal>を呼び出すとSQLのNULLが返ります。
    </para>
  </note>

  <note>
    <para>
<!--
      If the argument to <literal>json_strip_nulls</literal> contains duplicate
      field names in any object, the result could be semantically somewhat
      different, depending on the order in which they occur. This is not an
      issue for <literal>jsonb_strip_nulls</literal> since <type>jsonb</type> values never have
      duplicate object field names.
-->
<literal>json_strip_nulls</literal>の引数で、オブジェクト内にフィールド名が重複しているものがある場合、それが発生している順序によって、結果は意味的にやや異なるものになることがあります。
<type>jsonb</type>値はオブジェクトのフィールド名が重複することがないので、<literal>jsonb_strip_nulls</literal>にはこのような問題はありません。
    </para>
  </note>

  <note>
   <para>
<!--
    The <literal>jsonb_path_exists</literal>, <literal>jsonb_path_match</literal>,
    <literal>jsonb_path_query</literal>, <literal>jsonb_path_query_array</literal>, and
    <literal>jsonb_path_query_first</literal>
    functions have optional <literal>vars</literal> and <literal>silent</literal>
    arguments.
-->
<literal>jsonb_path_exists</literal>、<literal>jsonb_path_match</literal>、<literal>jsonb_path_query</literal>, <literal>jsonb_path_query_array</literal>、<literal>jsonb_path_query_first</literal>関数はオプションの<literal>vars</literal>と<literal>silent</literal>引数を持ちます。
   </para>
   <para>
<!--
    If the <parameter>vars</parameter> argument is specified, it provides an
    object containing named variables to be substituted into a
    <literal>jsonpath</literal> expression.
-->
<parameter>vars</parameter>引数が指定されると、<literal>jsonpath</literal>式に変換できる名前付きの変数を含むオブジェクトを関数は返します。
   </para>
   <para>
<!--
    If the <parameter>silent</parameter> argument is specified and has the
    <literal>true</literal> value, these functions suppress the same errors
    as the <literal>@?</literal> and <literal>@@</literal> operators.
-->
<parameter>silent</parameter>引数が指定され、それが値<literal>true</literal>なら、これらの関数は<literal>@?</literal>と<literal>@@</literal>演算子と同じエラーを抑止します。
   </para>
  </note>

  <para>
<!--
    See also <xref linkend="functions-aggregate"/> for the aggregate
    function <function>json_agg</function> which aggregates record
    values as JSON, and the aggregate function
    <function>json_object_agg</function> which aggregates pairs of values
    into a JSON object, and their <type>jsonb</type> equivalents,
    <function>jsonb_agg</function> and <function>jsonb_object_agg</function>.
-->
レコードの値をJSONに集約する<function>json_agg</function>集約関数、値の対をJSONオブジェクトに集約する<function>json_object_agg</function>集約関数、およびそれらの<type>jsonb</type>版の<function>jsonb_agg</function>と<function>jsonb_object_agg</function>については<xref linkend="functions-aggregate"/>を参照して下さい。
  </para>

 </sect2>

 <sect2 id="functions-sqljson-path">
<!--
  <title>The SQL/JSON Path Language</title>
-->
  <title>SQL/JSONパス言語</title>

  <indexterm zone="functions-sqljson-path">
<!--
   <primary>SQL/JSON path language</primary>
-->
   <primary>SQL/JSONパス言語</primary>
  </indexterm>

  <para>
<!--
   SQL/JSON path expressions specify the items to be retrieved
   from the JSON data, similar to XPath expressions used
   for SQL access to XML. In <productname>PostgreSQL</productname>,
   path expressions are implemented as the <type>jsonpath</type>
   data type and can use any elements described in
   <xref linkend="datatype-jsonpath"/>.
-->
SQL/JSONパス式は、XMLへのSQLアクセスで使用されるXPath同様、JSONデータから取り出す項目を指定します。
<productname>PostgreSQL</productname>ではパス式は<type>jsonpath</type>データ型として実装されており、<xref linkend="datatype-jsonpath"/>で説明されているすべての要素を使うことができます。
  </para>

<!--
  <para>JSON query functions and operators
   pass the provided path expression to the <firstterm>path engine</firstterm>
   for evaluation. If the expression matches the queried JSON data,
   the corresponding SQL/JSON item is returned.
   Path expressions are written in the SQL/JSON path language
   and can also include arithmetic expressions and functions.
   Query functions treat the provided expression as a
   text string, so it must be enclosed in single quotes.
-->
  <para>
JSON問い合わせ関数と演算子は与えられたパス式を<firstterm>path engine</firstterm>に渡して評価します。
式が問い合わせ対象のJSONデータにマッチすれば、関連するSQL/JSON項目が返却されます。
パス式はSQL/JSONパス言語で書かれ、算術式と関数を含むことができます。
問い合わせ関数は与えられた式をテキスト文字列として扱うので、単一引用符で括らなければなりません。
  </para>

  <para>
<!--
   A path expression consists of a sequence of elements allowed
   by the <type>jsonpath</type> data type.
   The path expression is evaluated from left to right, but
   you can use parentheses to change the order of operations.
   If the evaluation is successful, a sequence of SQL/JSON items
   (<firstterm>SQL/JSON sequence</firstterm>) is produced,
   and the evaluation result is returned to the JSON query function
   that completes the specified computation.
-->
パス式は<type>jsonpath</type>データ型で認められた一連の要素からなります。
パス式は左から右へと評価されますが、括弧を使って演算の順序を変更することができます。
評価が成功すれば、一連のSQL/JSON項目（<firstterm>SQL/JSON sequence</firstterm>）が生成され、評価結果が指定した計算を完了したJSON問い合わせ関数に戻されます。
  </para>

  <para>
<!--
   To refer to the JSON data to be queried (the
   <firstterm>context item</firstterm>), use the <literal>$</literal> sign
   in the path expression. It can be followed by one or more
   <link linkend="type-jsonpath-accessors">accessor operators</link>,
   which go down the JSON structure level by level to retrieve the
   content of context item. Each operator that follows deals with the
   result of the previous evaluation step.
-->
問い合わせ対象（<firstterm>context item</firstterm>）のJSONデータを参照するには、パス式内で<literal>$</literal>記号を使います。
複数の<link linkend="type-jsonpath-accessors">アクセッサ演算子</link>をその後に記述することもできます。
それによってJSON構造をレベル順に訪れて文脈の項目の内容を取り出します。
後続の個々の演算子はその前の評価段階の結果を処理します。
  </para>

  <para>
<!--
   For example, suppose you have some JSON data from a GPS tracker that you
   would like to parse, such as:
-->
たとえば、次のようなパースしたいGPSトラッカーからのJSONデータがあるとします。
<programlisting>
{
  "track": {
    "segments": [
      {
        "location":   [ 47.763, 13.4034 ],
        "start time": "2018-10-14 10:05:14",
        "HR": 73
      },
      {
        "location":   [ 47.706, 13.2635 ],
        "start time": "2018-10-14 10:39:21",
        "HR": 135
      }
    ]
  }
}
</programlisting>
  </para>

  <para>
<!--
   To retrieve the available track segments, you need to use the
   <literal>.<replaceable>key</replaceable></literal> accessor
   operator for all the preceding JSON objects:
-->
存在するトラックセグメントを取り出すには、<literal>.<replaceable>key</replaceable></literal>アクセッサ演算子をすべての先行するJSONオブジェクトに使用する必要があります。
<programlisting>
'$.track.segments'
</programlisting>
  </para>

  <para>
<!--
   If the item to retrieve is an element of an array, you have
   to unnest this array using the <literal>[*]</literal> operator. For example,
   the following path will return location coordinates for all
   the available track segments:
-->
取得したい項目が配列要素なら、<literal>[*]</literal>演算子を使って非配列化（unnest）する必要があります。
たとえば次のパスはすべての存在するトラックセグメントの位置座標を返します。
<programlisting>
'$.track.segments[*].location'
</programlisting>
  </para>

  <para>
<!--
   To return the coordinates of the first segment only, you can
   specify the corresponding subscript in the <literal>[]</literal>
   accessor operator. Note that the SQL/JSON arrays are 0-relative:
-->
最初のセグメントの座標だけを返すには、<literal>[]</literal>アクセッサ演算子の中で対応する添え字を指定することができます。
SQL/JSON配列は0スタートであることに注意してください。
<programlisting>
'$.track.segments[0].location'
</programlisting>
  </para>

  <para>
<!--
   The result of each path evaluation step can be processed
   by one or more <type>jsonpath</type> operators and methods
   listed in <xref linkend="functions-sqljson-path-operators"/>.
   Each method name must be preceded by a dot. For example,
   you can get an array size:
-->
各段階でのパス評価結果は<xref linkend="functions-sqljson-path-operators"/>に列挙されている一つ以上の<type>jsonpath</type>演算子とメソッドで処理することができます。
各々のメソッド名の前にピリオドを付けなければなりません。
たとえば配列の大きさを得ることができます。
<programlisting>
'$.track.segments.size()'
</programlisting>
<!--
   For more examples of using <type>jsonpath</type> operators
   and methods within path expressions, see
   <xref linkend="functions-sqljson-path-operators"/>.
-->
パス式内の<type>jsonpath</type>演算子とメソッドについては<xref linkend="functions-sqljson-path-operators"/>を参照してください。
  </para>

  <para>
<!--
   When defining the path, you can also use one or more
   <firstterm>filter expressions</firstterm> that work similar to the
   <literal>WHERE</literal> clause in SQL. A filter expression begins with
   a question mark and provides a condition in parentheses:
-->
パスを定義する際にはSQLの<literal>WHERE</literal>節のように働く一つ以上の<firstterm>フィルター式</firstterm>が利用できます。
フィルター式はクェスチョンマークで始まり、カッコ内に条件を記述します。

<programlisting>
? (<replaceable>condition</replaceable>)
</programlisting>
  </para>

  <para>
<!--
   Filter expressions must be specified right after the path evaluation step
   to which they are applied. The result of this step is filtered to include
   only those items that satisfy the provided condition. SQL/JSON defines
   three-valued logic, so the condition can be <literal>true</literal>, <literal>false</literal>,
   or <literal>unknown</literal>. The <literal>unknown</literal> value
   plays the same role as SQL <literal>NULL</literal> and can be tested
   for with the <literal>is unknown</literal> predicate. Further path
   evaluation steps use only those items for which filter expressions
   return <literal>true</literal>.
-->
フィルター式はそれを適用するパス評価段階の直後に指定しなければなりません。
この段階の結果は、指定した条件を満たす項目だけが含まれるようにフィルターされます。
SQL/JSONは3値論理を定義しており、条件は<literal>true</literal>、<literal>false</literal>、<literal>unknown</literal>のどれかです。
<literal>unknown</literal>は値はSQLの<literal>NULL</literal>と同じ役割を果たし、<literal>is unknown</literal>述語で評価できます。
その後の評価段階では<literal>true</literal>を返すフィルター式に対応する項目だけが使われます。
  </para>

  <para>
<!--
   Functions and operators that can be used in filter expressions are listed
   in <xref linkend="functions-sqljson-filter-ex-table"/>. The path
   evaluation result to be filtered is denoted by the <literal>@</literal>
   variable. To refer to a JSON element stored at a lower nesting level,
   add one or more accessor operators after <literal>@</literal>.
-->
フィルター式内で利用できる関数と演算子は<xref linkend="functions-sqljson-filter-ex-table"/>にリストされています。
フィルターする必要のあるパス評価結果は<literal>@</literal>変数で示します。
下位の入れ子レベルに格納されているJSON要素を参照するには、一つ以上のアクセッサ演算子を<literal>@</literal>の後に追加してください。
  </para>

  <para>
<!--
   Suppose you would like to retrieve all heart rate values higher
   than 130. You can achieve this using the following expression:
-->
130より高い心拍数を取り出したいとします。次の式を使ってそれを得ることができます。
<programlisting>
'$.track.segments[*].HR ? (@ &gt; 130)'
</programlisting>
  </para>

  <para>
<!--
   To get the start time of segments with such values instead, you have to
   filter out irrelevant segments before returning the start time, so the
   filter expression is applied to the previous step, and the path used
   in the condition is different:
-->
代わりにそうした値を持つセグメントの開始時刻を得たい場合は、開始時刻を返す前に無関係のセグメントを取り除く必要があります。
そうすることにより前の段階にフィルター式が適用されるので、その条件で適用されるパスは異なります。
<programlisting>
'$.track.segments[*] ? (@.HR &gt; 130)."start time"'
</programlisting>
  </para>

  <para>
<!--
   You can use several filter expressions on the same nesting level, if
   required. For example, the following expression selects all segments
   that contain locations with relevant coordinates and high heart rate values:
-->
必要なら同じ入れ子レベルに対して複数のフィルター式を使用することができます。
たとえば次の式は指定した座標と高い心拍数値を持つ位置を持つすべてのセグメントを選択します。
<programlisting>
'$.track.segments[*] ? (@.location[1] &lt; 13.4) ? (@.HR &gt; 130)."start time"'
</programlisting>
  </para>

  <para>
<!--
   Using filter expressions at different nesting levels is also allowed.
   The following example first filters all segments by location, and then
   returns high heart rate values for these segments, if available:
-->
異なる入れ子レベルに対してフィルター式を適用することもできます。
次の例では、まず位置ですべてのセグメントをフィルターし、もしあれば高い心拍数値を返します。
<programlisting>
'$.track.segments[*] ? (@.location[1] &lt; 13.4).HR ? (@ &gt; 130)'
</programlisting>
  </para>

  <para>
<!--
   You can also nest filter expressions within each other:
-->
フィルター式をお互いに入れ子にすることもできます。
<programlisting>
'$.track ? (exists(@.segments[*] ? (@.HR &gt; 130))).segments.size()'
</programlisting>
<!--
   This expression returns the size of the track if it contains any
   segments with high heart rate values, or an empty sequence otherwise.
-->
この式は高い心拍数値を含むトラックがあればそのすべてのサイズを返します。もしなければ空のシーケンスが返ります。
  </para>

  <para>
<!--
   <productname>PostgreSQL</productname>'s implementation of SQL/JSON path
   language has the following deviations from the SQL/JSON standard:
-->
<productname>PostgreSQL</productname>のSQL/JSONパス言語の実装はSQL/JSON標準と次の点が異なります。
  </para>

  <itemizedlist>
   <listitem>
    <para>
<!--
     <literal>.datetime()</literal> item method is not implemented yet
     mainly because immutable <type>jsonpath</type> functions and operators
     cannot reference session timezone, which is used in some datetime
     operations.  Datetime support will be added to <type>jsonpath</type>
     in future versions of <productname>PostgreSQL</productname>.
-->
<literal>.datetime()</literal>項目メソッドは、主に不揮発性<type>jsonpath</type>関数と演算子が日付時刻操作で使用されているセッション時間帯を参照できないという理由でまだ実装されていません。
将来の<productname>PostgreSQL</productname>バージョンでは<type>jsonpath</type>のサポートが追加される予定です。
    </para>
   </listitem>

   <listitem>
    <para>
<!--
     A path expression can be a Boolean predicate, although the SQL/JSON
     standard allows predicates only in filters.  This is necessary for
     implementation of the <literal>@@</literal> operator. For example,
     the following <type>jsonpath</type> expression is valid in
     <productname>PostgreSQL</productname>:
-->
SQL/JSON標準ではフィルター内でのみ述語が使えますが、パス式はBoolean述語でも構いません。
これは<literal>@@</literal>演算子を実装するために必要です。
たとえば、次の<type>jsonpath</type>式は<productname>PostgreSQL</productname>では有効です。
<programlisting>
'$.track.segments[*].HR &lt; 70'
</programlisting>
    </para>
   </listitem>

   <listitem>
    <para>
<!--
     There are minor differences in the interpretation of regular
     expression patterns used in <literal>like_regex</literal> filters, as
     described in <xref linkend="jsonpath-regular-expressions"/>.
-->
<xref linkend="jsonpath-regular-expressions"/>で述べるように、<literal>like_regex</literal>フィルターで使用される正規表現パターンの解釈には些細な違いがあります。
    </para>
   </listitem>
  </itemizedlist>

   <sect3 id="strict-and-lax-modes">
<!--
   <title>Strict and Lax Modes</title>
-->
   <title>厳密モードと非厳密モード</title>
    <para>
<!--
     When you query JSON data, the path expression may not match the
     actual JSON data structure. An attempt to access a non-existent
     member of an object or element of an array results in a
     structural error. SQL/JSON path expressions have two modes
     of handling structural errors:
-->
JSONデータを問い合わせる際、パス式は実際のJSONデータ構造に一致しないかも知れません。
存在しないオブジェクトのメンバーあるいは配列要素にアクセスしようとすると、構造上のエラーとなります。
SQL/JSONパス式には構造上のエラーを扱うための2つのモードがあります。
    </para>

   <itemizedlist>
    <listitem>
     <para>
<!--
      lax (default) &mdash; the path engine implicitly adapts
      the queried data to the specified path.
      Any remaining structural errors are suppressed and converted
      to empty SQL/JSON sequences.
-->
非厳密(lax)モード（デフォルト）&mdash; パスエンジンは指定したパスを問い合わせデータに暗黙的に適合させます。
構造上のエラーは抑止され、空のSQL/JSONシーケンスへと変換されます。
     </para>
    </listitem>
    <listitem>
     <para>
<!--
      strict &mdash; if a structural error occurs, an error is raised.
-->
厳密(strict)モード &mdash; 構造上のエラーがあるとエラーが発生します。
     </para>
    </listitem>
   </itemizedlist>

   <para>
<!--
    The lax mode facilitates matching of a JSON document structure and path
    expression if the JSON data does not conform to the expected schema.
    If an operand does not match the requirements of a particular operation,
    it can be automatically wrapped as an SQL/JSON array or unwrapped by
    converting its elements into an SQL/JSON sequence before performing
    this operation. Besides, comparison operators automatically unwrap their
    operands in the lax mode, so you can compare SQL/JSON arrays
    out-of-the-box. An array of size 1 is considered equal to its sole element.
    Automatic unwrapping is not performed only when:
-->
非厳密モードは、JSONデータが期待されるスキーマに沿わないときにJSON文書構造とパス式のマッチングを助けます。
あるオペランドが操作の要件に合わないときにはそれをSQL/JSON配列にまとめたり、あるいは操作を行う前にそれをSQL/JSONシーケンスに展開することもできます。
また非厳密モードにおいては、比較演算子は自動的にオペランドを展開し、SQL/JSON配列をそのまま比較することができます。
大きさ1の配列はその単独要素と同じものとして扱われます。
自動展開は以下の場合にのみ行われません。
    <itemizedlist>
     <listitem>
      <para>
<!--
       The path expression contains <literal>type()</literal> or
       <literal>size()</literal> methods that return the type
       and the number of elements in the array, respectively.
-->
それぞれ配列の型、要素数を返す<literal>type()</literal>、<literal>size()</literal>をパス式が含む。
      </para>
     </listitem>
     <listitem>
      <para>
<!--
       The queried JSON data contain nested arrays. In this case, only
       the outermost array is unwrapped, while all the inner arrays
       remain unchanged. Thus, implicit unwrapping can only go one
       level down within each path evaluation step.
-->
問い合わせ対象のJSONデータが入れ子の配列を含む。
この場合はもっとも外側の配列のみが展開され、内側の配列は変わりません。
ですから、それぞれの評価段階において1レベルのみに暗黙的な展開が行われます。
      </para>
     </listitem>
    </itemizedlist>
   </para>

   <para>
<!--
    For example, when querying the GPS data listed above, you can
    abstract from the fact that it stores an array of segments
    when using the lax mode:
-->
たとえば、上述のGPSデータに問い合わせする際、非厳密モードでは配列のセグメントを含んでいることを抽象化できます。
<programlisting>
'lax $.track.segments.location'
</programlisting>
   </para>

   <para>
<!--
    In the strict mode, the specified path must exactly match the structure of
    the queried JSON document to return an SQL/JSON item, so using this
    path expression will cause an error. To get the same result as in
    the lax mode, you have to explicitly unwrap the
    <literal>segments</literal> array:
-->
厳密モードでは、指定したパスはSQL/JSON項目を返す問い合わせ対象のJSON文書の構造に正確に一致していなければなりません。ですから、このパス式を使うとエラーになります。
非厳密モードと同じ結果を得るためには、<literal>segments</literal>配列を明示的に展開する必要があります。
<programlisting>
'strict $.track.segments[*].location'
</programlisting>
   </para>

   </sect3>

   <sect3 id="jsonpath-regular-expressions">
<!--
    <title>Regular Expressions</title>
-->
    <title>正規表現</title>

    <indexterm zone="jsonpath-regular-expressions">
     <primary><literal>LIKE_REGEX</literal></primary>
<!--
     <secondary>in SQL/JSON</secondary>
-->
     <secondary>SQL/JSONにおける</secondary>
    </indexterm>

    <para>
<!--
     SQL/JSON path expressions allow matching text to a regular expression
     with the <literal>like_regex</literal> filter.  For example, the
     following SQL/JSON path query would case-insensitively match all
     strings in an array that start with an English vowel:
-->
SQL/JSONパス式では<literal>like_regex</literal>フィルターを使ってテキストを正規表現にマッチさせることができます。
たとえば、次のSQL/JSONパス式問い合わせは、英語の母音で始まる配列内のすべての文字列に大文字小文字を無視してマッチするでしょう。
<programlisting>
'$[*] ? (@ like_regex "^[aeiou]" flag "i")'
</programlisting>
    </para>

    <para>
<!--
     The optional <literal>flag</literal> string may include one or more of
     the characters
     <literal>i</literal> for case-insensitive match,
     <literal>m</literal> to allow <literal>^</literal>
     and <literal>$</literal> to match at newlines,
     <literal>s</literal> to allow <literal>.</literal> to match a newline,
     and <literal>q</literal> to quote the whole pattern (reducing the
     behavior to a simple substring match).
-->
オプションの<literal>flag</literal>文字列は一つ以上の文字を含むことができます。
<literal>i</literal>は大文字小文字を無視したマッチ、<literal>m</literal>は<literal>^</literal>と<literal>$</literal>で改行にマッチ、<literal>s</literal>は<literal>.</literal>が改行にマッチ、<literal>q</literal>はパターン全体を参照します。（振る舞いを単純な部分文字列マッチとします）
    </para>

    <para>
<!--
     The SQL/JSON standard borrows its definition for regular expressions
     from the <literal>LIKE_REGEX</literal> operator, which in turn uses the
     XQuery standard.  PostgreSQL does not currently support the
     <literal>LIKE_REGEX</literal> operator.  Therefore,
     the <literal>like_regex</literal> filter is implemented using the
     POSIX regular expression engine described in
     <xref linkend="functions-posix-regexp"/>.  This leads to various minor
     discrepancies from standard SQL/JSON behavior, which are cataloged in
     <xref linkend="posix-vs-xquery"/>.
     Note, however, that the flag-letter incompatibilities described there
     do not apply to SQL/JSON, as it translates the XQuery flag letters to
     match what the POSIX engine expects.
-->
SQL/JSON標準は正規表現の定義を、XQuery標準を使用する<literal>LIKE_REGEX</literal>演算子から借りています。
PostgreSQLは今の所<literal>LIKE_REGEX</literal>演算子をサポートしていません。
ですから、<literal>like_regex</literal>フィルターは<xref linkend="functions-posix-regexp"/>で説明されているPOSIX正規表現で実装されています。
このことにより、<xref linkend="posix-vs-xquery"/>で列挙されているSQL/JSON標準の振る舞いとの小さな違いが生じます。
しかし、ここで述べているフラグ文字の非互換性はSQL/JSONには適用されないことに注意してください。SQL/JSONは、XQueryのフラグ文字をPOSIXエンジンが期待するのと一致するように解釈するからです。
    </para>

    <para>
<!--
     Keep in mind that the pattern argument of <literal>like_regex</literal>
     is a JSON path string literal, written according to the rules given in
     <xref linkend="datatype-jsonpath"/>.  This means in particular that any
     backslashes you want to use in the regular expression must be doubled.
     For example, to match strings that contain only digits:
-->
<literal>like_regex</literal>のパターン引数は<xref linkend="datatype-jsonpath"/>で説明されているルールにしたがって書かれたJSONパス文字列リテラルであることに注意してください。
これは、正規表現で使用するすべてのバックスラッシュを二重に書かなければならないことを意味します。
たとえば、数字のみを含む文字列にマッチさせるには以下のようにします。
<programlisting>
'$ ? (@ like_regex "^\\d+$")'
</programlisting>
    </para>

   </sect3>

   <sect3 id="functions-sqljson-path-operators">
<!--
   <title>SQL/JSON Path Operators and Methods</title>
-->
   <title>SQL/JSONパス演算子とメソッド</title>

   <para>
<!--
    <xref linkend="functions-sqljson-op-table"/> shows the operators and
    methods available in <type>jsonpath</type>.  <xref
    linkend="functions-sqljson-filter-ex-table"/> shows the available filter
    expression elements.
-->
<xref linkend="functions-sqljson-op-table"/>に<type>jsonpath</type>で利用可能な演算子とメソッドを示します。
<xref linkend="functions-sqljson-filter-ex-table"/>には利用可能なフィルター式要素が示されています。
   </para>

   <table id="functions-sqljson-op-table">
<!--
    <title><type>jsonpath</type> Operators and Methods</title>
-->
    <title><type>jsonpath</type>演算子とメソッド</title>
     <tgroup cols="5">
      <thead>
       <row>
<!--
        <entry>Operator/Method</entry>
        <entry>Description</entry>
        <entry>Example JSON</entry>
        <entry>Example Query</entry>
        <entry>Result</entry>
-->
        <entry>演算子/メソッド</entry>
        <entry>説明</entry>
        <entry>JSONの例</entry>
        <entry>問い合わせ例</entry>
        <entry>結果</entry>
       </row>
      </thead>
      <tbody>
       <row>
<!--
        <entry><literal>+</literal> (unary)</entry>
        <entry>Plus operator that iterates over the SQL/JSON sequence</entry>
-->
        <entry><literal>+</literal>（単項）</entry>
        <entry>SQL/JSONシーケンスに繰り返し適用される加算演算子</entry>
        <entry><literal>{"x": [2.85, -14.7, -9.4]}</literal></entry>
        <entry><literal>+ $.x.floor()</literal></entry>
        <entry><literal>2, -15, -10</literal></entry>
       </row>
       <row>
<!--
        <entry><literal>-</literal> (unary)</entry>
        <entry>Minus operator that iterates over the SQL/JSON sequence</entry>
-->
        <entry><literal>-</literal>（単項）</entry>
        <entry>SQL/JSONシーケンスに繰り返し適用される減算演算子</entry>
        <entry><literal>{"x": [2.85, -14.7, -9.4]}</literal></entry>
        <entry><literal>- $.x.floor()</literal></entry>
        <entry><literal>-2, 15, 10</literal></entry>
       </row>
       <row>
<!--
        <entry><literal>+</literal> (binary)</entry>
        <entry>Addition</entry>
-->
        <entry><literal>+</literal>（二項）</entry>
        <entry>加算</entry>
        <entry><literal>[2]</literal></entry>
        <entry><literal>2 + $[0]</literal></entry>
        <entry><literal>4</literal></entry>
       </row>
       <row>
<!--
        <entry><literal>-</literal> (binary)</entry>
        <entry>Subtraction</entry>
-->
        <entry><literal>-</literal>（二項）</entry>
        <entry>減算</entry>
        <entry><literal>[2]</literal></entry>
        <entry><literal>4 - $[0]</literal></entry>
        <entry><literal>2</literal></entry>
       </row>
       <row>
        <entry><literal>*</literal></entry>
<!--
        <entry>Multiplication</entry>
-->
        <entry>積算</entry>
        <entry><literal>[4]</literal></entry>
        <entry><literal>2 * $[0]</literal></entry>
        <entry><literal>8</literal></entry>
       </row>
       <row>

        <entry><literal>/</literal></entry>
<!--
        <entry>Division</entry>
-->
        <entry>除算</entry>
        <entry><literal>[8]</literal></entry>
        <entry><literal>$[0] / 2</literal></entry>
        <entry><literal>4</literal></entry>
       </row>
       <row>
        <entry><literal>%</literal></entry>
<!--
        <entry>Modulus</entry>
-->
        <entry>剰余</entry>
        <entry><literal>[32]</literal></entry>
        <entry><literal>$[0] % 10</literal></entry>
        <entry><literal>2</literal></entry>
       </row>
       <row>
        <entry><literal>type()</literal></entry>
<!--
        <entry>Type of the SQL/JSON item</entry>
-->
        <entry>SQL/JSON項目の型</entry>
        <entry><literal>[1, "2", {}]</literal></entry>
        <entry><literal>$[*].type()</literal></entry>
        <entry><literal>"number", "string", "object"</literal></entry>
       </row>
       <row>
        <entry><literal>size()</literal></entry>
<!--
        <entry>Size of the SQL/JSON item</entry>
-->
        <entry>SQL/JSON項目の大きさ</entry>
        <entry><literal>{"m": [11, 15]}</literal></entry>
        <entry><literal>$.m.size()</literal></entry>
        <entry><literal>2</literal></entry>
       </row>
       <row>
        <entry><literal>double()</literal></entry>
<!--
        <entry>Approximate floating-point number converted from an SQL/JSON number or a string</entry>
-->
        <entry>SQL/JSONの数字あるいは文字列から変換されたおおよその浮動小数点数</entry>
        <entry><literal>{"len": "1.9"}</literal></entry>
        <entry><literal>$.len.double() * 2</literal></entry>
        <entry><literal>3.8</literal></entry>
       </row>
       <row>
        <entry><literal>ceiling()</literal></entry>
<!--
        <entry>Nearest integer greater than or equal to the SQL/JSON number</entry>
-->
        <entry>SQL/JSON数字以上でもっとも近い整数</entry>
        <entry><literal>{"h": 1.3}</literal></entry>
        <entry><literal>$.h.ceiling()</literal></entry>
        <entry><literal>2</literal></entry>
       </row>
       <row>
        <entry><literal>floor()</literal></entry>
<!--
        <entry>Nearest integer less than or equal to the SQL/JSON number</entry>
-->
        <entry>SQL/JSON数字以下でもっとも近い整数</entry>
        <entry><literal>{"h": 1.3}</literal></entry>
        <entry><literal>$.h.floor()</literal></entry>
        <entry><literal>1</literal></entry>
       </row>
       <row>
        <entry><literal>abs()</literal></entry>
<!--
        <entry>Absolute value of the SQL/JSON number</entry>
-->
        <entry>SQL/JSON数字の絶対値</entry>
        <entry><literal>{"z": -0.3}</literal></entry>
        <entry><literal>$.z.abs()</literal></entry>
        <entry><literal>0.3</literal></entry>
       </row>
       <row>
        <entry><literal>keyvalue()</literal></entry>
        <entry>
<!--
          Sequence of object's key-value pairs represented as array of items
          containing three fields (<literal>"key"</literal>,
          <literal>"value"</literal>, and <literal>"id"</literal>).
          <literal>"id"</literal> is a unique identifier of the object
          key-value pair belongs to.
-->
3つのフィールド（<literal>"key"</literal>、<literal>"value"</literal>、<literal>"id"</literal>）を含む項目の配列で表現されたオブジェクトのキーバリューペアのシーケンス。
<literal>"id"</literal>はキーバリューペアが所属するオブジェクトのユニーク識別子です。
        </entry>
        <entry><literal>{"x": "20", "y": 32}</literal></entry>
        <entry><literal>$.keyvalue()</literal></entry>
        <entry><literal>{"key": "x", "value": "20", "id": 0}, {"key": "y", "value": 32, "id": 0}</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

    <table id="functions-sqljson-filter-ex-table">
<!--
     <title><type>jsonpath</type> Filter Expression Elements</title>
-->
     <title><type>jsonpath</type>フィルター式要素</title>
     <tgroup cols="5">
      <thead>
       <row>
<!--
        <entry>Value/Predicate</entry>
        <entry>Description</entry>
        <entry>Example JSON</entry>
        <entry>Example Query</entry>
        <entry>Result</entry>
-->
        <entry>値/述語</entry>
        <entry>説明</entry>
        <entry>JSONの例</entry>
        <entry>問い合わせ例</entry>
        <entry>結果</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><literal>==</literal></entry>
<!--
        <entry>Equality operator</entry>
-->
        <entry>等値演算子</entry>
        <entry><literal>[1, 2, 1, 3]</literal></entry>
        <entry><literal>$[*] ? (@ == 1)</literal></entry>
        <entry><literal>1, 1</literal></entry>
       </row>
       <row>
        <entry><literal>!=</literal></entry>
<!--
        <entry>Non-equality operator</entry>
-->
        <entry>非等値演算子</entry>
        <entry><literal>[1, 2, 1, 3]</literal></entry>
        <entry><literal>$[*] ? (@ != 1)</literal></entry>
        <entry><literal>2, 3</literal></entry>
       </row>
       <row>
        <entry><literal>&lt;&gt;</literal></entry>
<!--
        <entry>Non-equality operator (same as <literal>!=</literal>)</entry>
-->
        <entry>非等値演算子（<literal>!=</literal>と同じ）</entry>
        <entry><literal>[1, 2, 1, 3]</literal></entry>
        <entry><literal>$[*] ? (@ &lt;&gt; 1)</literal></entry>
        <entry><literal>2, 3</literal></entry>
       </row>
       <row>
        <entry><literal>&lt;</literal></entry>
<!--
        <entry>Less-than operator</entry>
-->
        <entry>未満演算子</entry>
        <entry><literal>[1, 2, 3]</literal></entry>
        <entry><literal>$[*] ? (@ &lt; 2)</literal></entry>
        <entry><literal>1</literal></entry>
       </row>
       <row>
        <entry><literal>&lt;=</literal></entry>
<!--
        <entry>Less-than-or-equal-to operator</entry>
-->
        <entry>以下演算子</entry>
        <entry><literal>[1, 2, 3]</literal></entry>
        <entry><literal>$[*] ? (@ &lt;= 2)</literal></entry>
        <entry><literal>1, 2</literal></entry>
       </row>
       <row>
        <entry><literal>&gt;</literal></entry>
<!--
        <entry>Greater-than operator</entry>
-->
        <entry>より大きい演算子</entry>
        <entry><literal>[1, 2, 3]</literal></entry>
        <entry><literal>$[*] ? (@ &gt; 2)</literal></entry>
        <entry><literal>3</literal></entry>
       </row>
       <row>
        <entry><literal>&gt;=</literal></entry>
<!--
        <entry>Greater-than-or-equal-to operator</entry>
-->
        <entry>以上演算子</entry>
        <entry><literal>[1, 2, 3]</literal></entry>
        <entry><literal>$[*] ? (@ &gt;= 2)</literal></entry>
        <entry><literal>2, 3</literal></entry>
       </row>
       <row>
        <entry><literal>true</literal></entry>
<!--
        <entry>Value used to perform comparison with JSON <literal>true</literal> literal</entry>
-->
        <entry>JSONの<literal>true</literal>リテラルとの比較に用いられる値</entry>
        <entry><literal>[{"name": "John", "parent": false},
                           {"name": "Chris", "parent": true}]</literal></entry>
        <entry><literal>$[*] ? (@.parent == true)</literal></entry>
        <entry><literal>{"name": "Chris", "parent": true}</literal></entry>
       </row>
       <row>
        <entry><literal>false</literal></entry>
<!--
        <entry>Value used to perform comparison with JSON <literal>false</literal> literal</entry>
-->
        <entry>JSONの<literal>false</literal>リテラルとの比較に用いられる値</entry>
        <entry><literal>[{"name": "John", "parent": false},
                           {"name": "Chris", "parent": true}]</literal></entry>
        <entry><literal>$[*] ? (@.parent == false)</literal></entry>
        <entry><literal>{"name": "John", "parent": false}</literal></entry>
       </row>
       <row>
        <entry><literal>null</literal></entry>
<!--
        <entry>Value used to perform comparison with JSON <literal>null</literal> value</entry>
-->
        <entry>JSONの<literal>null</literal>値との比較に用いられる値</entry>
        <entry><literal>[{"name": "Mary", "job": null},
                         {"name": "Michael", "job": "driver"}]</literal></entry>
        <entry><literal>$[*] ? (@.job == null) .name</literal></entry>
        <entry><literal>"Mary"</literal></entry>
       </row>
       <row>
        <entry><literal>&amp;&amp;</literal></entry>
<!--
        <entry>Boolean AND</entry>
-->
        <entry>論理AND</entry>
        <entry><literal>[1, 3, 7]</literal></entry>
        <entry><literal>$[*] ? (@ &gt; 1 &amp;&amp; @ &lt; 5)</literal></entry>
        <entry><literal>3</literal></entry>
       </row>
       <row>
        <entry><literal>||</literal></entry>
<!--
        <entry>Boolean OR</entry>
-->
        <entry>論理OR</entry>
        <entry><literal>[1, 3, 7]</literal></entry>
        <entry><literal>$[*] ? (@ &lt; 1 || @ &gt; 5)</literal></entry>
        <entry><literal>7</literal></entry>
       </row>
       <row>
        <entry><literal>!</literal></entry>

<!--
        <entry>Boolean NOT</entry>
-->
        <entry>論理NOT</entry>
        <entry><literal>[1, 3, 7]</literal></entry>
        <entry><literal>$[*] ? (!(@ &lt; 5))</literal></entry>
        <entry><literal>7</literal></entry>
       </row>
       <row>
        <entry><literal>like_regex</literal></entry>
        <entry>
<!--
          Tests whether the first operand matches the regular expression
          given by the second operand, optionally with modifications
          described by a string of <literal>flag</literal> characters (see
          <xref linkend="jsonpath-regular-expressions"/>)
-->
最初のオペランドが2番目のオペランドで与えられる正規表現にマッチするかどうかテストする。
オプションで<literal>flag</literal>文字列で記述される変更を伴う。（<xref linkend="jsonpath-regular-expressions"/>参照）
        </entry>
        <entry><literal>["abc", "abd", "aBdC", "abdacb", "babc"]</literal></entry>
        <entry><literal>$[*] ? (@ like_regex "^ab.*c" flag "i")</literal></entry>
        <entry><literal>"abc", "aBdC", "abdacb"</literal></entry>
       </row>
       <row>
        <entry><literal>starts with</literal></entry>
<!--
        <entry>Tests whether the second operand is an initial substring of the first operand</entry>
-->
        <entry>2番目の文字列が1番目のオペランドの最初の部分文字列かどうかをテストする</entry>
        <entry><literal>["John Smith", "Mary Stone", "Bob Johnson"]</literal></entry>
        <entry><literal>$[*] ? (@ starts with "John")</literal></entry>
        <entry><literal>"John Smith"</literal></entry>
       </row>
       <row>
        <entry><literal>exists</literal></entry>
<!--
        <entry>Tests whether a path expression matches at least one SQL/JSON item</entry>
-->
        <entry>パス式が少なくとも一つのSQL/JSON項目とマッチするかどうかをテストする</entry>
        <entry><literal>{"x": [1, 2], "y": [2, 4]}</literal></entry>
        <entry><literal>strict $.* ? (exists (@ ? (@[*] > 2)))</literal></entry>
        <entry><literal>2, 4</literal></entry>
       </row>
       <row>
        <entry><literal>is unknown</literal></entry>
<!--
        <entry>Tests whether a Boolean condition is <literal>unknown</literal></entry>
-->
        <entry>論理条件が<literal>unknown</literal>かどうかをテストする</entry>
        <entry><literal>[-1, 2, 7, "infinity"]</literal></entry>
        <entry><literal>$[*] ? ((@ > 0) is unknown)</literal></entry>
        <entry><literal>"infinity"</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   </sect3>
  </sect2>
 </sect1>

 <sect1 id="functions-sequence">
<!--
  <title>Sequence Manipulation Functions</title>
-->
  <title>シーケンス操作関数</title>

  <indexterm>
   <primary>sequence</primary>
  </indexterm>
  <indexterm>
   <primary>nextval</primary>
  </indexterm>
  <indexterm>
   <primary>currval</primary>
  </indexterm>
  <indexterm>
   <primary>lastval</primary>
  </indexterm>
  <indexterm>
   <primary>setval</primary>
  </indexterm>

  <para>
<!--
   This section describes functions for operating on <firstterm>sequence
   objects</firstterm>, also called sequence generators or just sequences.
   Sequence objects are special single-row tables created with <xref
   linkend="sql-createsequence"/>.
   Sequence objects are commonly used to generate unique identifiers
   for rows of a table.  The sequence functions, listed in <xref
   linkend="functions-sequence-table"/>, provide simple, multiuser-safe
   methods for obtaining successive sequence values from sequence
   objects.
-->
本節では<firstterm>シーケンスオブジェクト</firstterm>に対し演算を行う関数について説明します。
シーケンスオブジェクトは、シーケンスジェネレータ、あるいは単にシーケンスとも呼ばれます。
シーケンスオブジェクトは特殊な一行だけのテーブルで、<xref linkend="sql-createsequence"/>で作成されます。
シーケンスオブジェクトは一般的にテーブルの行に一意の識別子を生成するために使用されます。
<xref linkend="functions-sequence-table"/>に列挙されているシーケンス関数は、シーケンスオブジェクトから連続したシーケンス値を取得するための、簡易でマルチユーザに対応した関数です。
  </para>

   <table id="functions-sequence-table">
<!--
    <title>Sequence Functions</title>
-->
    <title>シーケンス関数</title>
    <tgroup cols="3">
     <thead>
<!--
      <row><entry>Function</entry> <entry>Return Type</entry> <entry>Description</entry></row>
-->
      <row><entry>関数</entry> <entry>戻り値</entry> <entry>説明</entry></row>
     </thead>

     <tbody>
      <row>
        <entry><literal><function>currval(<type>regclass</type>)</function></literal></entry>
        <entry><type>bigint</type></entry>
<!--
        <entry>Return value most recently obtained with
        <function>nextval</function> for specified sequence</entry>
-->
        <entry>指定されたシーケンスに対し<function>nextval</function>で得られた最新の値を返す</entry>
      </row>
      <row>
        <entry><literal><function>lastval()</function></literal></entry>
        <entry><type>bigint</type></entry>
<!--
        <entry>Return value most recently obtained with
        <function>nextval</function> for any sequence</entry>
-->
        <entry>すべてのシーケンスに対して<function>nextval</function>により最も最近取得された値を返す</entry>
      </row>
      <row>
        <entry><literal><function>nextval(<type>regclass</type>)</function></literal></entry>
        <entry><type>bigint</type></entry>
<!--
        <entry>Advance sequence and return new value</entry>
-->
        <entry>シーケンスを進め、新しい値を返す</entry>
      </row>
      <row>
        <entry><literal><function>setval(<type>regclass</type>, <type>bigint</type>)</function></literal></entry>
        <entry><type>bigint</type></entry>
<!--
        <entry>Set sequence's current value</entry>
-->
        <entry>シーケンスの現在値を設定する</entry>
      </row>
      <row>
        <entry><literal><function>setval(<type>regclass</type>, <type>bigint</type>, <type>boolean</type>)</function></literal></entry>
        <entry><type>bigint</type></entry>
<!--
        <entry>Set sequence's current value and <literal>is_called</literal> flag</entry>
-->
        <entry>シーケンスの現在値と<literal>is_called</literal>フラグを設定する</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <para>
<!--
   The sequence to be operated on by a sequence function is specified by
   a <type>regclass</type> argument, which is simply the OID of the sequence in the
   <structname>pg_class</structname> system catalog.  You do not have to look up the
   OID by hand, however, since the <type>regclass</type> data type's input
   converter will do the work for you.  Just write the sequence name enclosed
   in single quotes so that it looks like a literal constant.  For
   compatibility with the handling of ordinary
   <acronym>SQL</acronym> names, the string will be converted to lower case
   unless it contains double quotes around the sequence name.  Thus:
-->
シーケンス関数により操作されるシーケンスは<type>regclass</type>引数で指定されますが、それは<structname>pg_class</structname>システムカタログ内にある、そのシーケンスの単なるOIDです。
しかしながら、手作業でOIDを検索する必要はなく、<type>regclass</type>データ型の入力変換器が代わってその作業を行ってくれます。
単一引用符で括られたシーケンス名を記述するだけで良いので、リテラル定数のように見えます。
通常の<acronym>SQL</acronym>の名称での操作との互換のため、文字列はシーケンス名が二重引用符で括られていなければ、小文字に変換されます。
よって、以下のようになります。
<programlisting>
<!--
nextval('foo')      <lineannotation>operates on sequence <literal>foo</literal></lineannotation>
nextval('FOO')      <lineannotation>operates on sequence <literal>foo</literal></lineannotation>
nextval('"Foo"')    <lineannotation>operates on sequence <literal>Foo</literal></lineannotation>
-->
nextval('foo')      <lineannotation>シーケンス<literal>foo</literal>の操作</lineannotation>
nextval('FOO')      <lineannotation>シーケンス<literal>foo</literal>の操作</lineannotation>
nextval('"Foo"')    <lineannotation>シーケンス<literal>Foo</literal>の操作</lineannotation>
</programlisting>
<!--
   The sequence name can be schema-qualified if necessary:
-->
必要であれば、以下のようにシーケンス名をスキーマで修飾することができます。
<programlisting>
<!--
nextval('myschema.foo')     <lineannotation>operates on <literal>myschema.foo</literal></lineannotation>
nextval('"myschema".foo')   <lineannotation>same as above</lineannotation>
nextval('foo')              <lineannotation>searches search path for <literal>foo</literal></lineannotation>
-->
nextval('myschema.foo')     <lineannotation><literal>myschema.foo</literal>の操作</lineannotation>
nextval('"myschema".foo')   <lineannotation>上と同じ</lineannotation>
nextval('foo')              <lineannotation><literal>foo</literal>を検索パスで探す</lineannotation>
</programlisting>
<!--
   See <xref linkend="datatype-oid"/> for more information about
   <type>regclass</type>.
-->
<type>regclass</type>に関してのより詳細な情報は<xref linkend="datatype-oid"/>を参照してください。
  </para>

  <note>
   <para>
<!--
    Before <productname>PostgreSQL</productname> 8.1, the arguments of the
    sequence functions were of type <type>text</type>, not <type>regclass</type>, and
    the above-described conversion from a text string to an OID value would
    happen at run time during each call.  For backward compatibility, this
    facility still exists, but internally it is now handled as an implicit
    coercion from <type>text</type> to <type>regclass</type> before the function is
    invoked.
-->
<productname>PostgreSQL</productname>の8.1より前においては、シーケンス関数の引数は<type>regclass</type>型ではなく、<type>text</type>型で、そして上記のテキスト文字列からOID値への変換はそれぞれの呼び出し実行時に起こりました。
後方互換性のため、この仕組みはまだ存在しますが、内部的には関数が実行される前に<type>text</type>から<type>regclass</type>への暗黙的強制型変換として現在処理されています。
   </para>

   <para>
<!--
    When you write the argument of a sequence function as an unadorned
    literal string, it becomes a constant of type <type>regclass</type>.
    Since this is really just an OID, it will track the originally
    identified sequence despite later renaming, schema reassignment,
    etc.  This <quote>early binding</quote> behavior is usually desirable for
    sequence references in column defaults and views.  But sometimes you might
    want <quote>late binding</quote> where the sequence reference is resolved
    at run time.  To get late-binding behavior, force the constant to be
    stored as a <type>text</type> constant instead of <type>regclass</type>:
-->
ありのままのリテラル文字列としてシーケンス関数の引数を記述すると、<type>regclass</type>データ型の定数になります。
これは単なるOIDなので、後で名前付けが再び行われたとか、スキーマの再割り振りとかに関わらず、最初に特定されたシーケンスを引き継ぎます。
この<quote>初期束縛</quote>の動作は、列のデフォルトやビューからシーケンスを参照する場合は望ましいことが多いでしょう。
しかし、実行時にシーケンス参照が解決されるような<quote>動的束縛</quote>が望まれる場合もあります。
動的束縛の動作を得るには、その定数を<type>regclass</type>ではなく<type>text</type>定数として保存させます。
<programlisting>
nextval('foo'::text)      <lineannotation><literal>foo</literal> is looked up at runtime</lineannotation>
</programlisting>
<!--
    Note that late binding was the only behavior supported in
    <productname>PostgreSQL</productname> releases before 8.1, so you
    might need to do this to preserve the semantics of old applications.
-->
<productname>PostgreSQL</productname>のリリース8.1より前では動的束縛のみがサポートされる動作だったので、旧来のアプリケーションのセマンティクスを保ちたい場合このようにする必要があるかもしれません。
   </para>

   <para>
<!--
    Of course, the argument of a sequence function can be an expression
    as well as a constant.  If it is a text expression then the implicit
    coercion will result in a run-time lookup.
-->
もちろん、シーケンス関数の引数は定数だけでなく、評価式とすることも可能です。
テキスト式の場合は暗黙的型変換により、実行時検索が行われます。
   </para>
  </note>

  <para>
<!--
   The available sequence functions are:
-->
使用できるシーケンス関数には以下のものがあります。

    <variablelist>
     <varlistentry>
      <term><function>nextval</function></term>
      <listitem>
       <para>
<!--
        Advance the sequence object to its next value and return that
        value.  This is done atomically: even if multiple sessions
        execute <function>nextval</function> concurrently, each will safely receive
        a distinct sequence value.
-->
シーケンスオブジェクトをその次の値に進め、その値を返します。
これは原子的に処理され、複数のセッションが同時に<function>nextval</function>を実行したとしても、それぞれのセッションは異なるシーケンス値を安全に受け取ります。
       </para>

       <para>
<!--
        If a sequence object has been created with default parameters,
        successive <function>nextval</function> calls will return successive
        values beginning with 1.  Other behaviors can be obtained by using
        special parameters in the <xref linkend="sql-createsequence"/> command;
        see its command reference page for more information.
-->
デフォルトのパラメータによってシーケンスオブジェクトが作成されているなら、引き続く<function>nextval</function>呼び出しは１から始まる連続的な値を返します。
その他の動作を<xref linkend="sql-createsequence"/>コマンドの特別なパラメータを使用してさせることが可能です。より詳しくはコマンドのリファレンスガイドを参照ください。
       </para>

       <important>
        <para>
<!--
         To avoid blocking concurrent transactions that obtain numbers from
         the same sequence, a <function>nextval</function> operation is never
         rolled back; that is, once a value has been fetched it is considered
         used and will not be returned again.  This is true even if the
         surrounding transaction later aborts, or if the calling query ends
         up not using the value.  For example an <command>INSERT</command> with
         an <literal>ON CONFLICT</literal> clause will compute the to-be-inserted
         tuple, including doing any required <function>nextval</function>
         calls, before detecting any conflict that would cause it to follow
         the <literal>ON CONFLICT</literal> rule instead.  Such cases will leave
         unused <quote>holes</quote> in the sequence of assigned values.
         Thus, <productname>PostgreSQL</productname> sequence objects <emphasis>cannot
         be used to obtain <quote>gapless</quote> sequences</emphasis>.
-->
同一のシーケンスから数値を取得する同時実行トランザクション同士のブロックを防止するため、<function>nextval</function>演算は決してロールバックされません。
つまり、値が一度取り出されたら、それは使用されたものと見なされ、同じ値が再び返されることはありません。
これは、それを取り囲むトランザクションが後にアボートした場合でも、あるいは呼び出し側の問い合わせがその値を使用せずに終わった場合でも当てはまります。
例えば<literal>ON CONFLICT</literal>句のある<command>INSERT</command>では、挿入される予定のタプルについて、必要となるすべての<function>nextval</function>の呼び出しも含めて計算し、その後で<literal>ON CONFLICT</literal>のルールを代わりに使用することになる競合について検知します。
このような場合には、割り当てられた値のシーケンス内に未使用の<quote>欠損</quote>を残すことになります。
従って、<productname>PostgreSQL</productname>のシーケンスオブジェクトは<emphasis><quote>欠番のない</quote>シーケンスを得るために使うことはできません</emphasis>。
        </para>
       </important>

       <para>
<!--
        This function requires <literal>USAGE</literal>
        or <literal>UPDATE</literal> privilege on the sequence.
-->
この関数はシーケンスについて<literal>USAGE</literal>または<literal>UPDATE</literal>権限を必要とします。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>currval</function></term>
      <listitem>
       <para>
<!--
        Return the value most recently obtained by <function>nextval</function>
        for this sequence in the current session.  (An error is
        reported if <function>nextval</function> has never been called for this
        sequence in this session.)  Because this is returning
        a session-local value, it gives a predictable answer whether or not
        other sessions have executed <function>nextval</function> since the
        current session did.
-->
現在のセッションにおいて、そのシーケンスから<function>nextval</function>によって取得された直近の値を返します。
（セッション内でそのシーケンスに対し<function>nextval</function>が呼ばれていない場合には、エラーが報告されます。）
これはセッションごとの個別の値を返すので、現在のセッションが<function>nextval</function>を実行した後、他のセッションが<function>nextval</function>を実行したかどうかに関わらず、期待通りの回答をもたらします。
       </para>

       <para>
<!--
        This function requires <literal>USAGE</literal>
        or <literal>SELECT</literal> privilege on the sequence.
-->
この関数はシーケンスについて<literal>USAGE</literal>または<literal>SELECT</literal>権限を必要とします。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>lastval</function></term>
      <listitem>
       <para>
<!--
        Return the value most recently returned by
        <function>nextval</function> in the current session. This function is
        identical to <function>currval</function>, except that instead
        of taking the sequence name as an argument it refers to whichever
        sequence <function>nextval</function> was most recently applied to
        in the current session. It is an error to call
        <function>lastval</function> if <function>nextval</function>
        has not yet been called in the current session.
-->
現在のセッションの<function>nextval</function>で直近に戻された値を返します。
この関数は<function>currval</function>と同等ですが、引数としてシーケンス名をとる代わりに、現在のセッションで最後に<function>nextval</function>で使用されたシーケンスを参照するところが異なります。
現在のセッションで<function>nextval</function>が未だ呼ばれていなければエラーになります。
       </para>

       <para>
<!--
        This function requires <literal>USAGE</literal>
        or <literal>SELECT</literal> privilege on the last used sequence.
-->
この関数は、最後に使用したシーケンスについて<literal>USAGE</literal>または<literal>SELECT</literal>権限を必要とします。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>setval</function></term>
      <listitem>
       <para>
<!--
        Reset the sequence object's counter value.  The two-parameter
        form sets the sequence's <literal>last_value</literal> field to the
        specified value and sets its <literal>is_called</literal> field to
        <literal>true</literal>, meaning that the next
        <function>nextval</function> will advance the sequence before
        returning a value.  The value reported by <function>currval</function> is
        also set to the specified value.  In the three-parameter form,
        <literal>is_called</literal> can be set to either <literal>true</literal>
        or <literal>false</literal>.  <literal>true</literal> has the same effect as
        the two-parameter form. If it is set to <literal>false</literal>, the
        next <function>nextval</function> will return exactly the specified
        value, and sequence advancement commences with the following
        <function>nextval</function>.  Furthermore, the value reported by
        <function>currval</function> is not changed in this case.  For example,
-->
シーケンスオブジェクトの計数値をリセットします。
パラメータが２つの形式では、シーケンスの<literal>last_value</literal>フィールドを指定された値に設定し、<literal>is_called</literal>フィールドを<literal>true</literal>（真）に設定します。
この意味は、次の<function>nextval</function>が値を返す前にシーケンスを進めるということです。
<function>currval</function>で報告される値も指定された値に設定されます。
３パラメータ形式の場合、<literal>is_called</literal>を<literal>true</literal>（真）もしくは<literal>false</literal>（偽）に設定することができます。
<literal>true</literal>（真）は２パラメータ形式と同じ効果があります。
<literal>false</literal>（偽）に設定された場合、次の<function>nextval</function>は指定されたその値を返し、シーケンスの進行は引き続く<function>nextval</function>から始まります。
さらにこの場合、<function>currval</function>で報告される値は変更されません。
例えば、次の例です。

<screen>
<!--
SELECT setval('foo', 42);           <lineannotation>Next <function>nextval</function> will return 43</lineannotation>
SELECT setval('foo', 42, true);     <lineannotation>Same as above</lineannotation>
SELECT setval('foo', 42, false);    <lineannotation>Next <function>nextval</function> will return 42</lineannotation>
-->
SELECT setval('foo', 42);           <lineannotation>次の<function>nextval</function>は43を返す</lineannotation>
SELECT setval('foo', 42, true);     <lineannotation>上と同じ</lineannotation>
SELECT setval('foo', 42, false);    <lineannotation>次の<function>nextval</function>は42を返す</lineannotation>
</screen>

<!--
        The result returned by <function>setval</function> is just the value of its
        second argument.
-->
<function>setval</function>によって返される結果は単にその第2番目の引数の値です。
       </para>
       <important>
        <para>
<!--
         Because sequences are non-transactional, changes made by
         <function>setval</function> are not undone if the transaction rolls
         back.
-->
シーケンスはトランザクションとは異なる扱いを受けるため、<function>setval</function>による変更は、そのトランザクションがロールバックされたとしても元に戻りません。
        </para>
       </important>

       <para>
<!--
        This function requires <literal>UPDATE</literal> privilege on the
        sequence.
-->
この関数はシーケンスについて<literal>UPDATE</literal>権限を必要とします。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
  </para>

 </sect1>


 <sect1 id="functions-conditional">
<!--
  <title>Conditional Expressions</title>
-->
  <title>条件式</title>

  <indexterm>
   <primary>CASE</primary>
  </indexterm>

  <indexterm>
<!--
   <primary>conditional expression</primary>
-->
   <primary>条件式</primary>
  </indexterm>

  <para>
<!--
   This section describes the <acronym>SQL</acronym>-compliant conditional expressions
   available in <productname>PostgreSQL</productname>.
-->
本節では<productname>PostgreSQL</productname>で使用可能な<acronym>SQL</acronym>準拠の条件式について説明します。
  </para>

  <tip>
   <para>
<!--
    If your needs go beyond the capabilities of these conditional
    expressions, you might want to consider writing a server-side function
    in a more expressive programming language.
-->
ここで説明する条件式より発展した機能を求める場合は、より表現の豊富なプログラム言語でストアドプロシージャを記述することで解決されます。
   </para>
  </tip>

   <note>
    <para>
<!--
     Although <token>COALESCE</token>, <token>GREATEST</token>, and
     <token>LEAST</token> are syntactically similar to functions, they are
     not ordinary functions, and thus cannot be used with explicit
     <token>VARIADIC</token> array arguments.
-->
<token>COALESCE</token>、<token>GREATEST</token>、<token>LEAST</token>は構文的には関数に似ていますが通常の関数ではなく、明示的な<token>VARIADIC</token>配列引数と一緒には使えません。
    </para>
   </note>

  <sect2 id="functions-case">
   <title><literal>CASE</literal></title>

  <para>
<!--
   The <acronym>SQL</acronym> <token>CASE</token> expression is a
   generic conditional expression, similar to if/else statements in
   other programming languages:
-->
<acronym>SQL</acronym>の<token>CASE</token>式は他のプログラミング言語のif/else構文に類似した汎用条件式です。

<synopsis>
CASE WHEN <replaceable>condition</replaceable> THEN <replaceable>result</replaceable>
     <optional>WHEN ...</optional>
     <optional>ELSE <replaceable>result</replaceable></optional>
END
</synopsis>

<!--
   <token>CASE</token> clauses can be used wherever
   an expression is valid.  Each <replaceable>condition</replaceable> is an
   expression that returns a <type>boolean</type> result.  If the condition's
   result is true, the value of the <token>CASE</token> expression is the
   <replaceable>result</replaceable> that follows the condition, and the
   remainder of the <token>CASE</token> expression is not processed.  If the
   condition's result is not true, any subsequent <token>WHEN</token> clauses
   are examined in the same manner.  If no <token>WHEN</token>
   <replaceable>condition</replaceable> yields true, the value of the
   <token>CASE</token> expression is the <replaceable>result</replaceable> of the
   <token>ELSE</token> clause.  If the <token>ELSE</token> clause is
   omitted and no condition is true, the result is null.
-->
<token>CASE</token>句は式が有効な位置であればどこでも使用可能です。
それぞれの<replaceable>condition</replaceable>とは<type>boolean</type>型の結果を返す式です。
もしconditionの結果が真であれば、<token>CASE</token>式の値は、conditionに続く<replaceable>result</replaceable>となります。そして、<token>CASE</token>式の残りは処理されません。
もしconditionの結果が偽であれば後に続く全ての<token>WHEN</token>句が同じようにして調べられます。
<token>WHEN</token>の<replaceable>condition</replaceable>の1つも真でない場合、CASE式の値は<token>ELSE</token>句の<replaceable>result</replaceable>になります。
<token>ELSE</token>句が省略され、どのconditionも真でない場合、結果はNULLです。
  </para>

   <para>
<!--
    An example:
-->
以下に例を示します。
<screen>
SELECT * FROM test;

 a
---
 1
 2
 3


SELECT a,
       CASE WHEN a=1 THEN 'one'
            WHEN a=2 THEN 'two'
            ELSE 'other'
       END
    FROM test;

 a | case
---+-------
 1 | one
 2 | two
 3 | other
</screen>
   </para>

  <para>
<!--
   The data types of all the <replaceable>result</replaceable>
   expressions must be convertible to a single output type.
   See <xref linkend="typeconv-union-case"/> for more details.
-->
全ての<replaceable>result</replaceable>式のデータ型は単一の出力型に変換可能でなければなりません。
詳細は<xref linkend="typeconv-union-case"/>を参照してください。
  </para>

  <para>
<!--
   There is a <quote>simple</quote> form of <token>CASE</token> expression
   that is a variant of the general form above:
-->
以下のように、上記の一般的な形式と異なる<token>CASE</token>式の<quote>単純な</quote>形式が存在します。

<synopsis>
CASE <replaceable>expression</replaceable>
    WHEN <replaceable>value</replaceable> THEN <replaceable>result</replaceable>
    <optional>WHEN ...</optional>
    <optional>ELSE <replaceable>result</replaceable></optional>
END
</synopsis>

<!--
   The first
   <replaceable>expression</replaceable> is computed, then compared to
   each of the <replaceable>value</replaceable> expressions in the
   <token>WHEN</token> clauses until one is found that is equal to it.  If
   no match is found, the <replaceable>result</replaceable> of the
   <token>ELSE</token> clause (or a null value) is returned.  This is similar
   to the <function>switch</function> statement in C.
-->
最初の<replaceable>expression</replaceable>が計算され、そしてそれに等しいものが見つかるまで<token>WHEN</token>句のそれぞれの<replaceable>value</replaceable>式と比較されます。
等しいものが見つからない場合、<token>ELSE</token>句の<replaceable>result</replaceable>（もしくはNULL値）が返されます。
これはC言語の<function>switch</function>文に似ています。
  </para>

   <para>
<!--
    The example above can be written using the simple
    <token>CASE</token> syntax:
-->
上の例は簡略形<token>CASE</token>構文を使って次のように書くことができます。
<screen>
SELECT a,
       CASE a WHEN 1 THEN 'one'
              WHEN 2 THEN 'two'
              ELSE 'other'
       END
    FROM test;

 a | case
---+-------
 1 | one
 2 | two
 3 | other
</screen>
   </para>

   <para>
<!--
    A <token>CASE</token> expression does not evaluate any subexpressions
    that are not needed to determine the result.  For example, this is a
    possible way of avoiding a division-by-zero failure:
-->
<token>CASE</token>式は、結果を決定するために不必要などんな副式をも評価しません。
例えば、以下は0除算エラーを防ぐための方法です。
<programlisting>
SELECT ... WHERE CASE WHEN x &lt;&gt; 0 THEN y/x &gt; 1.5 ELSE false END;
</programlisting>
   </para>

   <note>
    <para>
<!--
     As described in <xref linkend="syntax-express-eval"/>, there are various
     situations in which subexpressions of an expression are evaluated at
     different times, so that the principle that <quote><token>CASE</token>
     evaluates only necessary subexpressions</quote> is not ironclad.  For
     example a constant <literal>1/0</literal> subexpression will usually result in
     a division-by-zero failure at planning time, even if it's within
     a <token>CASE</token> arm that would never be entered at run time.
-->
<xref linkend="syntax-express-eval"/>で説明したとおり、式の副式が異なる時点で評価される様々な状況があります。そのため<quote><token>CASE</token>は必要な副式のみを評価する</quote>という原則は厳格なものではありません。
例えば、定数<literal>1/0</literal>副式は、実行時には決して入らない<token>CASE</token>節の中にあったとしても、通常は計画時にゼロによる除算での失敗という結果に終わります。
    </para>
   </note>
  </sect2>

  <sect2 id="functions-coalesce-nvl-ifnull">
   <title><literal>COALESCE</literal></title>

  <indexterm>
   <primary>COALESCE</primary>
  </indexterm>

  <indexterm>
   <primary>NVL</primary>
  </indexterm>

  <indexterm>
   <primary>IFNULL</primary>
  </indexterm>

<synopsis>
<function>COALESCE</function>(<replaceable>value</replaceable> <optional>, ...</optional>)
</synopsis>

  <para>
<!--
   The <function>COALESCE</function> function returns the first of its
   arguments that is not null.  Null is returned only if all arguments
   are null.  It is often used to substitute a default value for
   null values when data is retrieved for display, for example:
-->
<function>COALESCE</function>関数は、NULLでない自身の最初の引数を返します。
全ての引数がNULLの場合にのみNULLが返されます。データを表示目的で取り出す際、NULL値をデフォルト値で置き換えるためによく使用されています。以下に例を示します。
<programlisting>
SELECT COALESCE(description, short_description, '(none)') ...
</programlisting>
<!--
   This returns <varname>description</varname> if it is not null, otherwise
   <varname>short_description</varname> if it is not null, otherwise <literal>(none)</literal>.
-->
これは<varname>description</varname>がNULLでなければそれを返します。
そうでない場合（NULLの場合）は、<varname>short_description</varname>がNULLでなければそれを返します。
それ以外の場合（short_descriptionもNULLの場合）は<literal>(none)</literal>が返ります。
  </para>

   <para>
<!--
    Like a <token>CASE</token> expression, <function>COALESCE</function> only
    evaluates the arguments that are needed to determine the result;
    that is, arguments to the right of the first non-null argument are
    not evaluated.  This SQL-standard function provides capabilities similar
    to <function>NVL</function> and <function>IFNULL</function>, which are used in some other
    database systems.
-->
<token>CASE</token>式同様、<function>COALESCE</function>は結果を決定するために必要な引数のみを評価します。つまり、非NULL引数が見つかれば、その右側にある引数は評価されません。
このSQL標準関数は、他のいくつかのデータベースで使用されている<function>NVL</function>および<function>IFNULL</function>と類似の機能を提供します。
   </para>
  </sect2>

  <sect2 id="functions-nullif">
   <title><literal>NULLIF</literal></title>

  <indexterm>
   <primary>NULLIF</primary>
  </indexterm>

<synopsis>
<function>NULLIF</function>(<replaceable>value1</replaceable>, <replaceable>value2</replaceable>)
</synopsis>

  <para>
<!--
   The <function>NULLIF</function> function returns a null value if
   <replaceable>value1</replaceable> equals <replaceable>value2</replaceable>;
   otherwise it returns <replaceable>value1</replaceable>.
   This can be used to perform the inverse operation of the
   <function>COALESCE</function> example given above:
-->
<function>NULLIF</function>関数は、<replaceable>value1</replaceable>が<replaceable>value2</replaceable>と等しい場合、NULL値を返します。
その他の場合は<replaceable>value1</replaceable>を返します。
これを使って、上記の<function>COALESCE</function>の例の逆演算を実行できます
<programlisting>
SELECT NULLIF(value, '(none)') ...
</programlisting>
  </para>
  <para>
<!--
   In this example, if <literal>value</literal> is <literal>(none)</literal>,
   null is returned, otherwise the value of <literal>value</literal>
   is returned.
-->
この例では、<replaceable>value1</replaceable>が<literal>(none)</literal>ならばNULLが返ります。
さもなくば<replaceable>value1</replaceable>を返します
  </para>

  </sect2>

  <sect2 id="functions-greatest-least">
<!--
   <title><literal>GREATEST</literal> and <literal>LEAST</literal></title>
-->
   <title><literal>GREATEST</literal>および<literal>LEAST</literal></title>

  <indexterm>
   <primary>GREATEST</primary>
  </indexterm>
  <indexterm>
   <primary>LEAST</primary>
  </indexterm>

<synopsis>
<function>GREATEST</function>(<replaceable>value</replaceable> <optional>, ...</optional>)
</synopsis>
<synopsis>
<function>LEAST</function>(<replaceable>value</replaceable> <optional>, ...</optional>)
</synopsis>

   <para>
<!--
    The <function>GREATEST</function> and <function>LEAST</function> functions select the
    largest or smallest value from a list of any number of expressions.
    The expressions must all be convertible to a common data type, which
    will be the type of the result
    (see <xref linkend="typeconv-union-case"/> for details).  NULL values
    in the list are ignored.  The result will be NULL only if all the
    expressions evaluate to NULL.
-->
<function>GREATEST</function>と<function>LEAST</function>関数は任意の数の式のリストから最大値もしくは最小値を選択します。
評価される全ての式は共通の型に変換できる必要があり、それが結果の型になります（詳細は<xref linkend="typeconv-union-case"/>を参照してください）。
リストの中のNULL値は無視されます。
全ての式がNULLと評価された場合に限って結果はNULLになります。
   </para>

   <para>
<!--
    Note that <function>GREATEST</function> and <function>LEAST</function> are not in
    the SQL standard, but are a common extension.  Some other databases
    make them return NULL if any argument is NULL, rather than only when
    all are NULL.
-->
<function>GREATEST</function>および<function>LEAST</function>はSQL標準に載っていませんが、共通した拡張です。
他のいくつかのデータベースでは、全てがNULLの場合に限定せず、いずれかの引数がNULLである場合にNULLを返すようにしているものもあります。
   </para>
  </sect2>
 </sect1>

 <sect1 id="functions-array">
<!--
  <title>Array Functions and Operators</title>
-->
  <title>配列関数と演算子</title>

  <para>
<!--
   <xref linkend="array-operators-table"/> shows the operators
   available for array types.
-->
<xref linkend="array-operators-table"/>に、配列型で使用可能な演算子を示します。
  </para>

    <table id="array-operators-table">
<!--
     <title>Array Operators</title>
-->
     <title>配列演算子</title>
     <tgroup cols="4">
      <thead>
       <row>
<!--
        <entry>Operator</entry>
        <entry>Description</entry>
        <entry>Example</entry>
        <entry>Result</entry>
-->
        <entry>演算子</entry>
        <entry>説明</entry>
        <entry>例</entry>
        <entry>結果</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry> <literal>=</literal> </entry>
<!--
        <entry>equal</entry>
-->
        <entry>等しい</entry>
        <entry><literal>ARRAY[1.1,2.1,3.1]::int[] = ARRAY[1,2,3]</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>&lt;&gt;</literal> </entry>
<!--
        <entry>not equal</entry>
-->
        <entry>等しくない</entry>
        <entry><literal>ARRAY[1,2,3] &lt;&gt; ARRAY[1,2,4]</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>&lt;</literal> </entry>
<!--
        <entry>less than</entry>
-->
        <entry>未満</entry>
        <entry><literal>ARRAY[1,2,3] &lt; ARRAY[1,2,4]</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>&gt;</literal> </entry>
<!--
        <entry>greater than</entry>
-->
        <entry>より大きい</entry>
        <entry><literal>ARRAY[1,4,3] &gt; ARRAY[1,2,4]</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>&lt;=</literal> </entry>
<!--
        <entry>less than or equal</entry>
-->
        <entry>以下</entry>
        <entry><literal>ARRAY[1,2,3] &lt;= ARRAY[1,2,3]</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>&gt;=</literal> </entry>
<!--
        <entry>greater than or equal</entry>
-->
        <entry>以上</entry>
        <entry><literal>ARRAY[1,4,3] &gt;= ARRAY[1,4,3]</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>@&gt;</literal> </entry>
<!--
        <entry>contains</entry>
-->
        <entry>包含する</entry>
        <entry><literal>ARRAY[1,4,3] @&gt; ARRAY[3,1,3]</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>&lt;@</literal> </entry>
<!--
        <entry>is contained by</entry>
-->
        <entry>・・・により包含される</entry>
        <entry><literal>ARRAY[2,2,7] &lt;@ ARRAY[1,7,4,2,6]</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>&amp;&amp;</literal> </entry>
<!--
        <entry>overlap (have elements in common)</entry>
-->
        <entry>重複する(共通要素を持つ)</entry>
        <entry><literal>ARRAY[1,4,3] &amp;&amp; ARRAY[2,1]</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>||</literal> </entry>
<!--
        <entry>array-to-array concatenation</entry>
-->
        <entry>配列と配列を連結</entry>
        <entry><literal>ARRAY[1,2,3] || ARRAY[4,5,6]</literal></entry>
        <entry><literal>{1,2,3,4,5,6}</literal></entry>
       </row>

       <row>
        <entry> <literal>||</literal> </entry>
<!--
        <entry>array-to-array concatenation</entry>
-->
        <entry>配列と配列を連結</entry>
        <entry><literal>ARRAY[1,2,3] || ARRAY[[4,5,6],[7,8,9]]</literal></entry>
        <entry><literal>{{1,2,3},{4,5,6},{7,8,9}}</literal></entry>
       </row>

       <row>
        <entry> <literal>||</literal> </entry>
<!--
        <entry>element-to-array concatenation</entry>
-->
        <entry>要素と配列を連結</entry>
        <entry><literal>3 || ARRAY[4,5,6]</literal></entry>
        <entry><literal>{3,4,5,6}</literal></entry>
       </row>

       <row>
        <entry> <literal>||</literal> </entry>
<!--
        <entry>array-to-element concatenation</entry>
-->
        <entry>配列と要素を連結</entry>
        <entry><literal>ARRAY[4,5,6] || 7</literal></entry>
        <entry><literal>{4,5,6,7}</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

  <para>
<!--
   The array ordering operators (<literal>&lt;</literal>,
   <literal>&gt;=</literal>, etc) compare the array contents
   element-by-element, using the default B-tree comparison function for
   the element data type, and sort based on the first difference.
   In multidimensional arrays the elements are visited in row-major order
   (last subscript varies most rapidly).
   If the contents of two arrays are equal but the dimensionality is
   different, the first difference in the dimensionality information
   determines the sort order.  (This is a change from versions of
   <productname>PostgreSQL</productname> prior to 8.2: older versions would claim
   that two arrays with the same contents were equal, even if the
   number of dimensions or subscript ranges were different.)
-->
配列比較では、配列要素ごとに、要素のデータ型のデフォルトのB-tree比較関数を使用して、その内容が比較されます。
多次元配列では、行番号を優先して取り出します（最後の添え字が最も速く変わる順序で比較します）。
2つの配列の内容が同じで次元数が異なる場合、どの次元で最初に違いがあったかによってソート順が決まります。
（これは8.2より前の<productname>PostgreSQL</productname>では異なります。古いバージョンでは、次数や添え字範囲が異なっていたとしても、内容が同じであれば、2つの配列は同じものとしていました。）
  </para>

  <para>
   The array containment operators (<literal>&lt;@</literal>
   and <literal>@&gt;</literal>) consider one array to be contained in
   another one if each of its elements appears in the other one.
   Duplicates are not treated specially, thus <literal>ARRAY[1]</literal>
   and <literal>ARRAY[1,1]</literal> are each considered to contain the
   other.
  </para>

  <para>
<!--
   See <xref linkend="arrays"/> for more details about array operator
   behavior.  See <xref linkend="indexes-types"/> for more details about
   which operators support indexed operations.
-->
配列演算子の振舞いの詳細は<xref linkend="arrays"/>を参照してください。
どの演算子がインデックス付きの操作をサポートしているかのより詳細については<xref linkend="indexes-types"/>を参照してください。
  </para>

  <para>
<!--
   <xref linkend="array-functions-table"/> shows the functions
   available for use with array types. See <xref linkend="arrays"/>
   for more information  and examples of the use of these functions.
-->
<xref linkend="array-functions-table"/>に配列型で使用可能な関数を示します。
これらの関数の情報と例については<xref linkend="arrays"/>を参照してください。
  </para>

  <indexterm>
    <primary>array_append</primary>
  </indexterm>
  <indexterm>
    <primary>array_cat</primary>
  </indexterm>
  <indexterm>
    <primary>array_ndims</primary>
  </indexterm>
  <indexterm>
    <primary>array_dims</primary>
  </indexterm>
  <indexterm>
    <primary>array_fill</primary>
  </indexterm>
  <indexterm>
    <primary>array_length</primary>
  </indexterm>
  <indexterm>
    <primary>array_lower</primary>
  </indexterm>
  <indexterm>
    <primary>array_position</primary>
  </indexterm>
  <indexterm>
    <primary>array_positions</primary>
  </indexterm>
  <indexterm>
    <primary>array_prepend</primary>
  </indexterm>
  <indexterm>
    <primary>array_remove</primary>
  </indexterm>
  <indexterm>
    <primary>array_replace</primary>
  </indexterm>
  <indexterm>
    <primary>array_to_string</primary>
  </indexterm>
 <indexterm>
    <primary>array_upper</primary>
  </indexterm>
  <indexterm>
    <primary>cardinality</primary>
  </indexterm>
  <indexterm>
    <primary>string_to_array</primary>
  </indexterm>
  <indexterm>
    <primary>unnest</primary>
  </indexterm>

    <table id="array-functions-table">
<!--
     <title>Array Functions</title>
-->
     <title>配列関数</title>
     <tgroup cols="5">
      <thead>
       <row>
<!--
        <entry>Function</entry>
        <entry>Return Type</entry>
        <entry>Description</entry>
        <entry>Example</entry>
        <entry>Result</entry>
-->
        <entry>関数</entry>
        <entry>戻り値型</entry>
        <entry>説明</entry>
        <entry>例</entry>
        <entry>結果</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>
         <literal>
          <function>array_append</function>(<type>anyarray</type>, <type>anyelement</type>)
         </literal>
        </entry>
        <entry><type>anyarray</type></entry>
<!--
        <entry>append an element to the end of an array</entry>
-->
        <entry>配列の末尾に要素を追加</entry>
        <entry><literal>array_append(ARRAY[1,2], 3)</literal></entry>
        <entry><literal>{1,2,3}</literal></entry>
       </row>
       <row>
        <entry>
         <literal>
          <function>array_cat</function>(<type>anyarray</type>, <type>anyarray</type>)
         </literal>
        </entry>
        <entry><type>anyarray</type></entry>
<!--
        <entry>concatenate two arrays</entry>
-->
        <entry>２つの配列を連結</entry>
        <entry><literal>array_cat(ARRAY[1,2,3], ARRAY[4,5])</literal></entry>
        <entry><literal>{1,2,3,4,5}</literal></entry>
       </row>
       <row>
        <entry>
         <literal>
          <function>array_ndims</function>(<type>anyarray</type>)
         </literal>
        </entry>
        <entry><type>int</type></entry>
<!--
        <entry>returns the number of dimensions of the array</entry>
-->
        <entry>配列の次元数を返す</entry>
        <entry><literal>array_ndims(ARRAY[[1,2,3], [4,5,6]])</literal></entry>
        <entry><literal>2</literal></entry>
       </row>
       <row>
        <entry>
         <literal>
          <function>array_dims</function>(<type>anyarray</type>)
         </literal>
        </entry>
        <entry><type>text</type></entry>
<!--
        <entry>returns a text representation of array's dimensions</entry>
-->
        <entry>配列の次元をテキスト表現で返す</entry>
        <entry><literal>array_dims(ARRAY[[1,2,3], [4,5,6]])</literal></entry>
        <entry><literal>[1:2][1:3]</literal></entry>
       </row>
       <row>
        <entry>
         <literal>
          <function>array_fill</function>(<type>anyelement</type>, <type>int[]</type>
          <optional>, <type>int[]</type></optional>)
         </literal>
        </entry>
        <entry><type>anyarray</type></entry>
<!--
        <entry>returns an array initialized with supplied value and
         dimensions, optionally with lower bounds other than 1</entry>
-->
         <entry>提供された値と次元で初期化された配列を返す。オプションで１以外の添字の下限を指定する。</entry>
        <entry><literal>array_fill(7, ARRAY[3], ARRAY[2])</literal></entry>
        <entry><literal>[2:4]={7,7,7}</literal></entry>
       </row>
       <row>
        <entry>
         <literal>
          <function>array_length</function>(<type>anyarray</type>, <type>int</type>)
         </literal>
        </entry>
        <entry><type>int</type></entry>
<!--
        <entry>returns the length of the requested array dimension</entry>
-->
        <entry>指定次数での配列の長さを返す</entry>
        <entry><literal>array_length(array[1,2,3], 1)</literal></entry>
        <entry><literal>3</literal></entry>
       </row>
       <row>
        <entry>
         <literal>
          <function>array_lower</function>(<type>anyarray</type>, <type>int</type>)
         </literal>
        </entry>
        <entry><type>int</type></entry>
<!--
        <entry>returns lower bound of the requested array dimension</entry>
-->
        <entry>指定次数での配列の添字の下限を返す</entry>
        <entry><literal>array_lower('[0:2]={1,2,3}'::int[], 1)</literal></entry>
        <entry><literal>0</literal></entry>
       </row>
       <row>
        <entry>
         <literal>
          <function>array_position</function>(<type>anyarray</type>, <type>anyelement</type> <optional>, <type>int</type></optional>)
         </literal>
        </entry>
        <entry><type>int</type></entry>
<!--
        <entry>returns the subscript of the first occurrence of the second
        argument in the array, starting at the element indicated by the third
        argument or at the first element (array must be one-dimensional)</entry>
-->
        <entry>配列を第3引数で指定された要素、省略時は最初の要素から調べて、第2引数が最初に現れる添字を返す（配列は1次元であること）</entry>
        <entry><literal>array_position(ARRAY['sun','mon','tue','wed','thu','fri','sat'], 'mon')</literal></entry>
        <entry><literal>2</literal></entry>
       </row>
       <row>
        <entry>
         <literal>
          <function>array_positions</function>(<type>anyarray</type>, <type>anyelement</type>)
         </literal>
        </entry>
        <entry><type>int[]</type></entry>
<!--
        <entry>returns an array of subscripts of all occurrences of the second
        argument in the array given as first argument (array must be
        one-dimensional)</entry>
-->
        <entry>第1引数の配列内で第2引数が現れるすべての添字からなる配列を返す（配列は1次元であること）</entry>
        <entry><literal>array_positions(ARRAY['A','A','B','A'], 'A')</literal></entry>
        <entry><literal>{1,2,4}</literal></entry>
       </row>
       <row>
        <entry>
         <literal>
          <function>array_prepend</function>(<type>anyelement</type>, <type>anyarray</type>)
         </literal>
        </entry>
        <entry><type>anyarray</type></entry>
<!--
        <entry>append an element to the beginning of an array</entry>
-->
        <entry>配列の先頭に要素を追加</entry>
        <entry><literal>array_prepend(1, ARRAY[2,3])</literal></entry>
        <entry><literal>{1,2,3}</literal></entry>
       </row>
       <row>
        <entry>
         <literal>
          <function>array_remove</function>(<type>anyarray</type>, <type>anyelement</type>)
         </literal>
        </entry>
        <entry><type>anyarray</type></entry>
<!--
        <entry>remove all elements equal to the given value from the array
         (array must be one-dimensional)</entry>
-->
        <entry>配列から指定の値と等しい要素をすべて削除（配列は一次元であること）</entry>
        <entry><literal>array_remove(ARRAY[1,2,3,2], 2)</literal></entry>
        <entry><literal>{1,3}</literal></entry>
       </row>
       <row>
        <entry>
         <literal>
          <function>array_replace</function>(<type>anyarray</type>, <type>anyelement</type>, <type>anyelement</type>)
         </literal>
        </entry>
        <entry><type>anyarray</type></entry>
<!--
        <entry>replace each array element equal to the given value with a new value</entry>
-->
        <entry>指定の値と等しい各要素を新しい値で置換</entry>
        <entry><literal>array_replace(ARRAY[1,2,5,4], 5, 3)</literal></entry>
        <entry><literal>{1,2,3,4}</literal></entry>
       </row>
       <row>
        <entry>
         <literal>
          <function>array_to_string</function>(<type>anyarray</type>, <type>text</type> <optional>, <type>text</type></optional>)
         </literal>
        </entry>
        <entry><type>text</type></entry>
<!--
        <entry>concatenates array elements using supplied delimiter and
         optional null string</entry>
-->
        <entry>配列の要素を提供された区切り文字、およびオプションで指定するNULL文字列を使用して連結</entry>
        <entry><literal>array_to_string(ARRAY[1, 2, 3, NULL, 5], ',', '*')</literal></entry>
        <entry><literal>1,2,3,*,5</literal></entry>
       </row>
       <row>
        <entry>
         <literal>
          <function>array_upper</function>(<type>anyarray</type>, <type>int</type>)
         </literal>
        </entry>
        <entry><type>int</type></entry>
<!--
        <entry>returns upper bound of the requested array dimension</entry>
-->
        <entry>指定次数での配列の添字の上限を返す</entry>
        <entry><literal>array_upper(ARRAY[1,8,3,7], 1)</literal></entry>
        <entry><literal>4</literal></entry>
       </row>
       <row>
        <entry>
         <literal>
          <function>cardinality</function>(<type>anyarray</type>)
         </literal>
        </entry>
        <entry><type>int</type></entry>
<!--
        <entry>returns the total number of elements in the array, or 0 if the array is empty</entry>
-->
        <entry>配列の中の要素の総数を返す。配列が空であれば0</entry>
        <entry><literal>cardinality(ARRAY[[1,2],[3,4]])</literal></entry>
        <entry><literal>4</literal></entry>
       </row>
       <row>
        <entry>
         <literal>
          <function>string_to_array</function>(<type>text</type>, <type>text</type> <optional>, <type>text</type></optional>)
         </literal>
        </entry>
        <entry><type>text[]</type></entry>
<!--
        <entry>splits string into array elements using supplied delimiter and
         optional null string</entry>
-->
        <entry>提供された区切り文字、およびオプションで指定するNULL文字列を使用して、文字列を配列の要素に分割</entry>
        <entry><literal>string_to_array('xx~^~yy~^~zz', '~^~', 'yy')</literal></entry>
        <entry><literal>{xx,NULL,zz}</literal></entry>
       </row>
       <row>
        <entry>
         <literal>
          <function>unnest</function>(<type>anyarray</type>)
         </literal>
        </entry>
        <entry><type>setof anyelement</type></entry>
<!--
        <entry>expand an array to a set of rows</entry>
-->
        <entry>配列を行集合に展開</entry>
        <entry><literal>unnest(ARRAY[1,2])</literal></entry>
        <entry><literallayout class="monospaced">1
2</literallayout>(2 rows)</entry>
       </row>
       <row>
        <entry>
         <literal>
          <function>unnest</function>(<type>anyarray</type>, <type>anyarray</type> [, ...])
         </literal>
        </entry>
        <entry><type>setof anyelement, anyelement [, ...]</type></entry>
<!--
        <entry>expand multiple arrays (possibly of different types) to a set
         of rows.  This is only allowed in the FROM clause; see
         <xref linkend="queries-tablefunctions"/></entry>
-->
        <entry>複数の配列(型が異なっているかもしれない)を行の集合に展開。これはFROM句の中でのみ使用可能。<xref linkend="queries-tablefunctions"/>を参照</entry>
        <entry><literal>unnest(ARRAY[1,2],ARRAY['foo','bar','baz'])</literal></entry>
        <entry><literallayout class="monospaced">1    foo
2    bar
NULL baz</literallayout>(3 rows)</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
<!--
    In <function>array_position</function> and <function>array_positions</function>,
    each array element is compared to the searched value using
    <literal>IS NOT DISTINCT FROM</literal> semantics.
-->
<function>array_position</function>および<function>array_positions</function>では、各配列要素は検索する値と<literal>IS NOT DISTINCT FROM</literal>の意味を用いて比較されます。
   </para>

   <para>
<!--
    In <function>array_position</function>, <literal>NULL</literal> is returned
    if the value is not found.
-->
<function>array_position</function>で値が見つからない時は<literal>NULL</literal>が返されます。
   </para>

   <para>
<!--
    In <function>array_positions</function>, <literal>NULL</literal> is returned
    only if the array is <literal>NULL</literal>; if the value is not found in
    the array, an empty array is returned instead.
-->
<function>array_positions</function>で<literal>NULL</literal>が返されるのは配列が<literal>NULL</literal>のときだけで、配列内に値が見つからない時は、空の配列が返されます。
   </para>

   <para>
<!--
    In <function>string_to_array</function>, if the delimiter parameter is
    NULL, each character in the input string will become a separate element in
    the resulting array.  If the delimiter is an empty string, then the entire
    input string is returned as a one-element array.  Otherwise the input
    string is split at each occurrence of the delimiter string.
-->
<function>string_to_array</function>では、区切り文字列がNULLの場合、入力された文字列の各々の文字が別々の要素となった配列を返します。
区切り文字列が空文字列の場合、入力された文字列全体が一つの要素となる配列を返します。
それ以外の場合、入力された文字列が区切り文字列のある箇所で分割されます。
   </para>

   <para>
<!--
    In <function>string_to_array</function>, if the null-string parameter
    is omitted or NULL, none of the substrings of the input will be replaced
    by NULL.
    In <function>array_to_string</function>, if the null-string parameter
    is omitted or NULL, any null elements in the array are simply skipped
    and not represented in the output string.
-->
<function>string_to_array</function>では、NULL文字列パラメータが省略、もしくはNULLの指定がされた場合、入力文字列中の部分文字列がNULLに置換されることはありません。
<function>array_to_string</function>では、NULL文字列パラメータが省略、もしくはNULLの指定がされた場合、配列中のNULL要素はスキップされ、出力文字列に現れません。
   </para>

   <note>
    <para>
<!--
     There are two differences in the behavior of <function>string_to_array</function>
     from pre-9.1 versions of <productname>PostgreSQL</productname>.
     First, it will return an empty (zero-element) array rather than NULL when
     the input string is of zero length.  Second, if the delimiter string is
     NULL, the function splits the input into individual characters, rather
     than returning NULL as before.
-->
<function>string_to_array</function>は、<productname>PostgreSQL</productname>9.1から、前のバージョンとは2つの異なる振る舞いするようになりました。
1つ目は、入力した文字列長が0の場合、NULLを返すのではなく空の(要素数が0の)配列を返すようになりました。
2つ目は区切り文字列がNULLの場合、以前はNULLを返していましたが9.1からは入力文字列を個別の文字に分割するようになりました。
    </para>
   </note>

   <para>
<!--
    See also <xref linkend="functions-aggregate"/> about the aggregate
    function <function>array_agg</function> for use with arrays.
-->
配列を使用する集約関数<function>array_agg</function>について、<xref linkend="functions-aggregate"/>も参照してください。
   </para>
  </sect1>

 <sect1 id="functions-range">
<!--
  <title>Range Functions and Operators</title>
-->
  <title>範囲関数と演算子</title>

  <para>
<!--
   See <xref linkend="rangetypes"/> for an overview of range types.
-->
範囲型の概要に関しては<xref linkend="rangetypes"/>を参照してください。
  </para>

  <para>
<!--
   <xref linkend="range-operators-table"/> shows the operators
   available for range types.
-->
範囲型に対して利用可能な演算子を<xref linkend="range-operators-table"/>に示します。
  </para>

    <table id="range-operators-table">
<!--
     <title>Range Operators</title>
-->
     <title>範囲演算子</title>
     <tgroup cols="4">
      <thead>
       <row>
<!--
        <entry>Operator</entry>
        <entry>Description</entry>
        <entry>Example</entry>
        <entry>Result</entry>
-->
        <entry>演算子</entry>
        <entry>説明</entry>
        <entry>例</entry>
        <entry>結果</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry> <literal>=</literal> </entry>
<!--
        <entry>equal</entry>
-->
        <entry>等しい</entry>
        <entry><literal>int4range(1,5) = '[1,4]'::int4range</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>&lt;&gt;</literal> </entry>
<!--
        <entry>not equal</entry>
-->
        <entry>等しくない</entry>
        <entry><literal>numrange(1.1,2.2) &lt;&gt; numrange(1.1,2.3)</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>&lt;</literal> </entry>
<!--
        <entry>less than</entry>
-->
        <entry>未満</entry>
        <entry><literal>int4range(1,10) &lt; int4range(2,3)</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>&gt;</literal> </entry>
<!--
        <entry>greater than</entry>
-->
        <entry>より大きい</entry>
        <entry><literal>int4range(1,10) &gt; int4range(1,5)</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>&lt;=</literal> </entry>
<!--
        <entry>less than or equal</entry>
-->
        <entry>以下</entry>
        <entry><literal>numrange(1.1,2.2) &lt;= numrange(1.1,2.2)</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>&gt;=</literal> </entry>
<!--
        <entry>greater than or equal</entry>
-->
        <entry>以上</entry>
        <entry><literal>numrange(1.1,2.2) &gt;= numrange(1.1,2.0)</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>@&gt;</literal> </entry>
<!--
        <entry>contains range</entry>
-->
        <entry>範囲を包含する</entry>
        <entry><literal>int4range(2,4) @&gt; int4range(2,3)</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>@&gt;</literal> </entry>
<!--
        <entry>contains element</entry>
-->
        <entry>要素を包含する</entry>
        <entry><literal>'[2011-01-01,2011-03-01)'::tsrange @&gt; '2011-01-10'::timestamp</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>&lt;@</literal> </entry>
<!--
        <entry>range is contained by</entry>
-->
        <entry>・・・により範囲が包含される</entry>
        <entry><literal>int4range(2,4) &lt;@ int4range(1,7)</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>&lt;@</literal> </entry>
<!--
        <entry>element is contained by</entry>
-->
        <entry>・・・により要素が包含される</entry>
        <entry><literal>42 &lt;@ int4range(1,7)</literal></entry>
        <entry><literal>f</literal></entry>
       </row>

       <row>
        <entry> <literal>&amp;&amp;</literal> </entry>
<!--
        <entry>overlap (have points in common)</entry>
-->
        <entry>重複する(共通点を持つ)</entry>
        <entry><literal>int8range(3,7) &amp;&amp; int8range(4,12)</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>&lt;&lt;</literal> </entry>
<!--
        <entry>strictly left of</entry>
-->
        <entry>厳密に左に位置する</entry>
        <entry><literal>int8range(1,10) &lt;&lt; int8range(100,110)</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>&gt;&gt;</literal> </entry>
<!--
        <entry>strictly right of</entry>
-->
        <entry>厳密に右に位置する</entry>
        <entry><literal>int8range(50,60) &gt;&gt; int8range(20,30)</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>&amp;&lt;</literal> </entry>
<!--
        <entry>does not extend to the right of</entry>
-->
        <entry>右側を越えない</entry>
        <entry><literal>int8range(1,20) &amp;&lt; int8range(18,20)</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>&amp;&gt;</literal> </entry>
<!--
        <entry>does not extend to the left of</entry>
-->
        <entry>左側を越えない</entry>
        <entry><literal>int8range(7,20) &amp;&gt; int8range(5,10)</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>-|-</literal> </entry>
<!--
        <entry>is adjacent to</entry>
-->
        <entry>隣接する</entry>
        <entry><literal>numrange(1.1,2.2) -|- numrange(2.2,3.3)</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>+</literal> </entry>
<!--
        <entry>union</entry>
-->
        <entry>範囲の結合</entry>
        <entry><literal>numrange(5,15) + numrange(10,20)</literal></entry>
        <entry><literal>[5,20)</literal></entry>
       </row>

       <row>
        <entry> <literal>*</literal> </entry>
<!--
        <entry>intersection</entry>
-->
        <entry>範囲の共通部分</entry>
        <entry><literal>int8range(5,15) * int8range(10,20)</literal></entry>
        <entry><literal>[10,15)</literal></entry>
       </row>

       <row>
        <entry> <literal>-</literal> </entry>
<!--
        <entry>difference</entry>
-->
        <entry>範囲の差分</entry>
        <entry><literal>int8range(5,15) - int8range(10,20)</literal></entry>
        <entry><literal>[5,10)</literal></entry>
       </row>

      </tbody>
     </tgroup>
    </table>

  <para>
<!--
   The simple comparison operators <literal>&lt;</literal>,
   <literal>&gt;</literal>, <literal>&lt;=</literal>, and
   <literal>&gt;=</literal> compare the lower bounds first, and only if those
   are equal, compare the upper bounds.  These comparisons are not usually
   very useful for ranges, but are provided to allow B-tree indexes to be
   constructed on ranges.
-->
単純な比較演算子である<literal>&lt;</literal>、<literal>&gt;</literal>、<literal>&lt;=</literal>そして<literal>&gt;=</literal>は、最初に下限の境界を比較し、それらが等しい場合のみ上限の境界を比較します。
これらの比較演算子は、範囲型のデータに関しては大抵便利なものではありませんが、範囲型へB-treeインデックスを付与するのに必要なため提供されています。
  </para>

  <para>
<!--
   The left-of/right-of/adjacent operators always return false when an empty
   range is involved; that is, an empty range is not considered to be either
   before or after any other range.
-->
左に位置する/右に位置する/隣接する、の演算子は、範囲の一方が空の時は常に偽を返します。つまり、空の範囲に対しては、他のどの範囲の前後のどちらであるともみなされない、ということです。
  </para>

  <para>
<!--
   The union and difference operators will fail if the resulting range would
   need to contain two disjoint sub-ranges, as such a range cannot be
   represented.
-->
結合範囲と差分範囲演算子は、もし得られる結果が互いに離れた2つの範囲を含む必要がある場合、このような範囲を表現することができないためエラーとなります。
  </para>

  <para>
<!--
   <xref linkend="range-functions-table"/> shows the functions
   available for use with range types.
-->
範囲型に対して利用可能な関数を<xref linkend="range-functions-table"/>に示します。
  </para>

  <indexterm>
    <primary>lower</primary>
  </indexterm>
  <indexterm>
    <primary>upper</primary>
  </indexterm>
  <indexterm>
    <primary>isempty</primary>
  </indexterm>
  <indexterm>
    <primary>lower_inc</primary>
  </indexterm>
  <indexterm>
    <primary>upper_inc</primary>
  </indexterm>
  <indexterm>
    <primary>lower_inf</primary>
  </indexterm>
  <indexterm>
    <primary>upper_inf</primary>
  </indexterm>

    <table id="range-functions-table">
<!--
     <title>Range Functions</title>
-->
     <title>範囲関数</title>
     <tgroup cols="5">
      <thead>
       <row>
<!--
        <entry>Function</entry>
        <entry>Return Type</entry>
        <entry>Description</entry>
        <entry>Example</entry>
        <entry>Result</entry>
-->
        <entry>関数</entry>
        <entry>戻り値型</entry>
        <entry>説明</entry>
        <entry>例</entry>
        <entry>結果</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>
         <literal>
          <function>lower</function>(<type>anyrange</type>)
         </literal>
        </entry>
<!--
        <entry>range's element type</entry>
        <entry>lower bound of range</entry>
-->
        <entry>範囲の要素の型</entry>
        <entry>範囲の下限</entry>
        <entry><literal>lower(numrange(1.1,2.2))</literal></entry>
        <entry><literal>1.1</literal></entry>
       </row>
       <row>
        <entry>
         <literal>
          <function>upper</function>(<type>anyrange</type>)
         </literal>
        </entry>
<!--
        <entry>range's element type</entry>
        <entry>upper bound of range</entry>
-->
        <entry>範囲の要素の型</entry>
        <entry>範囲の上限</entry>
        <entry><literal>upper(numrange(1.1,2.2))</literal></entry>
        <entry><literal>2.2</literal></entry>
       </row>
       <row>
        <entry>
         <literal>
          <function>isempty</function>(<type>anyrange</type>)
         </literal>
        </entry>
        <entry><type>boolean</type></entry>
<!--
        <entry>is the range empty?</entry>
-->
        <entry>空の範囲か？</entry>
        <entry><literal>isempty(numrange(1.1,2.2))</literal></entry>
        <entry><literal>false</literal></entry>
       </row>
       <row>
        <entry>
         <literal>
          <function>lower_inc</function>(<type>anyrange</type>)
         </literal>
        </entry>
        <entry><type>boolean</type></entry>
<!--
        <entry>is the lower bound inclusive?</entry>
-->
        <entry>下限は範囲に含まれるか？</entry>
        <entry><literal>lower_inc(numrange(1.1,2.2))</literal></entry>
        <entry><literal>true</literal></entry>
       </row>
       <row>
        <entry>
         <literal>
          <function>upper_inc</function>(<type>anyrange</type>)
         </literal>
        </entry>
        <entry><type>boolean</type></entry>
<!--
        <entry>is the upper bound inclusive?</entry>
-->
        <entry>上限は範囲に含まれるか？</entry>
        <entry><literal>upper_inc(numrange(1.1,2.2))</literal></entry>
        <entry><literal>false</literal></entry>
       </row>
       <row>
        <entry>
         <literal>
          <function>lower_inf</function>(<type>anyrange</type>)
         </literal>
        </entry>
        <entry><type>boolean</type></entry>
<!--
        <entry>is the lower bound infinite?</entry>
-->
        <entry>下限は無限大か？</entry>
        <entry><literal>lower_inf('(,)'::daterange)</literal></entry>
        <entry><literal>true</literal></entry>
       </row>
       <row>
        <entry>
         <literal>
          <function>upper_inf</function>(<type>anyrange</type>)
         </literal>
        </entry>
        <entry><type>boolean</type></entry>
<!--
        <entry>is the upper bound infinite?</entry>
-->
        <entry>上限は無限大か？</entry>
        <entry><literal>upper_inf('(,)'::daterange)</literal></entry>
        <entry><literal>true</literal></entry>
       </row>
       <row>
        <entry>
         <literal>
          <function>range_merge</function>(<type>anyrange</type>, <type>anyrange</type>)
         </literal>
        </entry>
        <entry><type>anyrange</type></entry>
<!--
        <entry>the smallest range which includes both of the given ranges</entry>
-->
        <entry>両方の範囲を含む最小の範囲</entry>
        <entry><literal>range_merge('[1,2)'::int4range, '[3,4)'::int4range)</literal></entry>
        <entry><literal>[1,4)</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

  <para>
<!--
   The <function>lower</function> and  <function>upper</function> functions return null
   if the range is empty or the requested bound is infinite.
   The <function>lower_inc</function>, <function>upper_inc</function>,
   <function>lower_inf</function>, and <function>upper_inf</function>
   functions all return false for an empty range.
-->
<function>lower</function>と<function>upper</function>関数は、範囲が空の場合および対象の境界が無限大の場合は、NULLを返します。
<function>lower_inc</function>、<function>upper_inc</function>、<function>lower_inf</function>、そして<function>upper_inf</function>関数は、空の範囲に対しては全て偽を返します。
  </para>
  </sect1>

 <sect1 id="functions-aggregate">
<!--
  <title>Aggregate Functions</title>
-->
  <title>集約関数</title>

  <indexterm zone="functions-aggregate">
<!--
   <primary>aggregate function</primary>
   <secondary>built-in</secondary>
-->
   <primary>集約関数</primary>
   <secondary>組み込み</secondary>
  </indexterm>

  <para>
<!--
   <firstterm>Aggregate functions</firstterm> compute a single result
   from a set of input values.  The built-in general-purpose aggregate
   functions are listed in <xref linkend="functions-aggregate-table"/>
   and statistical aggregates in <xref
   linkend="functions-aggregate-statistics-table"/>.
   The built-in within-group ordered-set aggregate functions
   are listed in <xref linkend="functions-orderedset-table"/>
   while the built-in within-group hypothetical-set ones are in <xref
   linkend="functions-hypothetical-table"/>.  Grouping operations,
   which are closely related to aggregate functions, are listed in
   <xref linkend="functions-grouping-table"/>.
   The special syntax considerations for aggregate
   functions are explained in <xref linkend="syntax-aggregates"/>.
   Consult <xref linkend="tutorial-agg"/> for additional introductory
   information.
-->
<firstterm>集約関数</firstterm>は入力値の集合から単一の結果を計算します。
<xref linkend="functions-aggregate-table"/>に組み込みの汎用的な集約関数を、<xref linkend="functions-aggregate-statistics-table"/>に統計集約関数を示します。
<xref linkend="functions-orderedset-table"/>には組み込みのグループ内順序集合集約関数を、一方<xref linkend="functions-hypothetical-table"/>には組み込みのグループ内仮想集合用の順序集約関数を示します。
<xref linkend="functions-grouping-table"/>には、集約関数と密接に関係するグループ化演算を示します。
集約関数の特殊な構文に関する考察は<xref linkend="syntax-aggregates"/>で説明されています。
また、初歩的な情報については<xref linkend="tutorial-agg"/>を参照して下さい。
  </para>

  <table id="functions-aggregate-table">
<!--
   <title>General-Purpose Aggregate Functions</title>
-->
   <title>汎用集約関数</title>

   <tgroup cols="5">
    <thead>
     <row>
<!--
      <entry>Function</entry>
      <entry>Argument Type(s)</entry>
      <entry>Return Type</entry>
      <entry>Partial Mode</entry>
      <entry>Description</entry>
-->
      <entry>関数</entry>
      <entry>引数のデータ型</entry>
      <entry>戻り値型</entry>
      <entry>部分モード</entry>
      <entry>説明</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>
       <indexterm>
        <primary>array_agg</primary>
       </indexterm>
       <function>array_agg(<replaceable class="parameter">expression</replaceable>)</function>
      </entry>
      <entry>
<!--
       any non-array type
-->
配列以外の任意の型
      </entry>
      <entry>
<!--
       array of the argument type
-->
       引数の型の配列
      </entry>
<!--
      <entry>No</entry>
      <entry>input values, including nulls, concatenated into an array</entry>
-->
      <entry>不可</entry>
      <entry>NULLを含めて入力値が結合された配列</entry>
     </row>

     <row>
      <entry>
       <function>array_agg(<replaceable class="parameter">expression</replaceable>)</function>
      </entry>
      <entry>
<!--
       any array type
-->
任意の配列型
      </entry>
      <entry>
<!--
       same as argument data type
-->
引数と同じデータ型
      </entry>
<!--
      <entry>No</entry>
      <entry>input arrays concatenated into array of one higher dimension
       (inputs must all have same dimensionality,
        and cannot be empty or null)</entry>
-->
      <entry>不可</entry>
      <entry>入力配列が結合された、1次元高い配列（入力はすべて同じ次元であり、空やNULLではないこと）</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>average</primary>
       </indexterm>
       <indexterm>
        <primary>avg</primary>
       </indexterm>
       <function>avg(<replaceable class="parameter">expression</replaceable>)</function>
      </entry>
      <entry>
<!--
       <type>smallint</type>, <type>int</type>,
       <type>bigint</type>, <type>real</type>, <type>double
       precision</type>, <type>numeric</type>, or <type>interval</type>
-->
       <type>smallint</type>、<type>int</type>、<type>bigint</type>、<type>real</type>、<type>double precision</type>、<type>numeric</type>、または<type>interval</type>
      </entry>
      <entry>
<!--
       <type>numeric</type> for any integer-type argument,
       <type>double precision</type> for a floating-point argument,
       otherwise the same as the argument data type
-->
       整数型の引数であれば全て<type>numeric</type>、浮動小数点の引数であれば<type>double precision</type>、それ以外は引数のデータ型と同じ
      </entry>
<!--
      <entry>Yes</entry>
      <entry>the average (arithmetic mean) of all non-null input values</entry>
-->
      <entry>可</entry>
      <entry>全ての入力値の平均値（算術平均）</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>bit_and</primary>
       </indexterm>
       <function>bit_and(<replaceable class="parameter">expression</replaceable>)</function>
      </entry>
      <entry>
<!--
       <type>smallint</type>, <type>int</type>, <type>bigint</type>, or
       <type>bit</type>
-->
       <type>smallint</type>、<type>int</type>、<type>bigint</type>、または<type>bit</type>
      </entry>
      <entry>
<!--
        same as argument data type
-->
        引数のデータ型と同じ
      </entry>
<!--
      <entry>Yes</entry>
      <entry>the bitwise AND of all non-null input values, or null if none</entry>
-->
      <entry>可</entry>
      <entry>全ての非NULLの入力値のビット積、非NULLの入力値がなければNULL</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>bit_or</primary>
       </indexterm>
       <function>bit_or(<replaceable class="parameter">expression</replaceable>)</function>
      </entry>
      <entry>
<!--
       <type>smallint</type>, <type>int</type>, <type>bigint</type>, or
       <type>bit</type>
-->
       <type>smallint</type>、<type>int</type>、<type>bigint</type>、または
       <type>bit</type>
      </entry>
      <entry>
<!--
        same as argument data type
-->
        引数のデータ型と同じ
      </entry>
<!--
      <entry>Yes</entry>
      <entry>the bitwise OR of all non-null input values, or null if none</entry>
-->
      <entry>可</entry>
      <entry>全ての非NULLの入力値のビット和、非NULLの入力値がなければNULL</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>bool_and</primary>
       </indexterm>
       <function>bool_and(<replaceable class="parameter">expression</replaceable>)</function>
      </entry>
      <entry>
       <type>bool</type>
      </entry>
      <entry>
       <type>bool</type>
      </entry>
<!--
      <entry>Yes</entry>
      <entry>true if all input values are true, otherwise false</entry>
-->
      <entry>可</entry>
      <entry>全ての入力が真ならば真、そうでなければ偽</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>bool_or</primary>
       </indexterm>
       <function>bool_or(<replaceable class="parameter">expression</replaceable>)</function>
      </entry>
      <entry>
       <type>bool</type>
      </entry>
      <entry>
       <type>bool</type>
      </entry>
<!--
      <entry>Yes</entry>
      <entry>true if at least one input value is true, otherwise false</entry>
-->
      <entry>可</entry>
      <entry>少なくとも1つの入力値が真ならば真。そうでなければ偽</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>count</primary>
       </indexterm>
       <function>count(*)</function>
      </entry>
      <entry></entry>
      <entry><type>bigint</type></entry>
<!--
      <entry>Yes</entry>
      <entry>number of input rows</entry>
-->
      <entry>可</entry>
      <entry>入力行の数</entry>
     </row>

     <row>
      <entry><function>count(<replaceable class="parameter">expression</replaceable>)</function></entry>
<!--
      <entry>any</entry>
-->
      <entry>任意の型</entry>
      <entry><type>bigint</type></entry>
<!--
      <entry>Yes</entry>
-->
      <entry>可</entry>
      <entry>
<!--
       number of input rows for which the value of <replaceable
       class="parameter">expression</replaceable> is not null
-->
       <replaceable class="parameter">expression</replaceable>が非NULL値を持つ入力行の個数
      </entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>every</primary>
       </indexterm>
       <function>every(<replaceable class="parameter">expression</replaceable>)</function>
      </entry>
      <entry>
       <type>bool</type>
      </entry>
      <entry>
       <type>bool</type>
      </entry>
<!--
      <entry>Yes</entry>
      <entry>equivalent to <function>bool_and</function></entry>
-->
      <entry>可</entry>
      <entry><function>bool_and</function>と等価</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>json_agg</primary>
       </indexterm>
       <function>json_agg(<replaceable class="parameter">expression</replaceable>)</function>
      </entry>
      <entry>
       <type>any</type>
      </entry>
      <entry>
       <type>json</type>
      </entry>
<!--
      <entry>No</entry>
      <entry>aggregates values, including nulls, as a JSON array</entry>
-->
      <entry>不可</entry>
      <entry>JSON配列として値を集約</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>jsonb_agg</primary>
       </indexterm>
       <function>jsonb_agg(<replaceable class="parameter">expression</replaceable>)</function>
      </entry>
      <entry>
       <type>any</type>
      </entry>
      <entry>
       <type>jsonb</type>
      </entry>
<!--
      <entry>No</entry>
      <entry>aggregates values, including nulls, as a JSON array</entry>
-->
      <entry>不可</entry>
      <entry>値をJSON配列として集約する</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>json_object_agg</primary>
       </indexterm>
       <function>json_object_agg(<replaceable class="parameter">name</replaceable>, <replaceable class="parameter">value</replaceable>)</function>
      </entry>
      <entry>
       <type>(any, any)</type>
      </entry>
      <entry>
       <type>json</type>
      </entry>
<!--
      <entry>No</entry>
      <entry>aggregates name/value pairs as a JSON object; values can be
       null, but not names</entry>
-->
      <entry>不可</entry>
      <entry>名前／値の対をJSONオブジェクトとして集約</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>jsonb_object_agg</primary>
       </indexterm>
       <function>jsonb_object_agg(<replaceable class="parameter">name</replaceable>, <replaceable class="parameter">value</replaceable>)</function>
      </entry>
      <entry>
       <type>(any, any)</type>
      </entry>
      <entry>
       <type>jsonb</type>
      </entry>
<!--
      <entry>No</entry>
      <entry>aggregates name/value pairs as a JSON object; values can be
       null, but not names</entry>
-->
      <entry>不可</entry>
      <entry>名前／値のペアをJSONオブジェクトとして集約</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>max</primary>
       </indexterm>
       <function>max(<replaceable class="parameter">expression</replaceable>)</function>
      </entry>
<!--
      <entry>any numeric, string, date/time, network, or enum type,
             or arrays of these types</entry>
-->
      <entry>任意の数値型、文字列型、日付時刻型、ネットワーク型、列挙型、あるいはそれらの配列</entry>
<!--
      <entry>same as argument type</entry>
      <entry>Yes</entry>
-->
      <entry>引数の型と同じ</entry>
      <entry>可</entry>
      <entry>
<!--
       maximum value of <replaceable
       class="parameter">expression</replaceable> across all non-null input
       values
-->
       全ての入力値にわたり<replaceable class="parameter">expression</replaceable>の最大値
      </entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>min</primary>
       </indexterm>
       <function>min(<replaceable class="parameter">expression</replaceable>)</function>
      </entry>
<!--
      <entry>any numeric, string, date/time, network, or enum type,
             or arrays of these types</entry>
-->
      <entry>任意の数値型、文字列型、日付時刻型、ネットワーク型、列挙型、あるいはそれらの配列</entry>
<!--
      <entry>same as argument type</entry>
      <entry>Yes</entry>
-->
      <entry>引数の型と同じ</entry>
      <entry>可</entry>
      <entry>
<!--
       minimum value of <replaceable
       class="parameter">expression</replaceable> across all non-null input
       values
-->
       全ての入力値にわたり<replaceable class="parameter">expression</replaceable>の最小値
      </entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>string_agg</primary>
       </indexterm>
       <function>
         string_agg(<replaceable class="parameter">expression</replaceable>,
                    <replaceable class="parameter">delimiter</replaceable>)
       </function>
      </entry>
      <entry>
<!--
       (<type>text</type>, <type>text</type>) or (<type>bytea</type>, <type>bytea</type>)
-->
       (<type>text</type>, <type>text</type>)または(<type>bytea</type>, <type>bytea</type>)
      </entry>
      <entry>
<!--
       same as argument types
-->
       引数と同じ型
      </entry>
<!--
      <entry>No</entry>
      <entry>non-null input values concatenated into a string, separated by delimiter</entry>
-->
      <entry>不可</entry>
      <entry>入力された値が指定したデリミタで区切られた一つの文字列に連結されます。</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>sum</primary>
       </indexterm>
       <function>sum(<replaceable class="parameter">expression</replaceable>)</function>
      </entry>
      <entry>
<!--
       <type>smallint</type>, <type>int</type>,
       <type>bigint</type>, <type>real</type>, <type>double
       precision</type>, <type>numeric</type>,
       <type>interval</type>, or <type>money</type>
-->
       <type>smallint</type>、<type>int</type>、<type>bigint</type>、<type>real</type>、<type>double precision</type>、<type>numeric</type>、<type>interval</type>または<type>money</type>
      </entry>
      <entry>
<!--
       <type>bigint</type> for <type>smallint</type> or
       <type>int</type> arguments, <type>numeric</type> for
       <type>bigint</type> arguments, otherwise the same as the
       argument data type
-->
       <type>smallint</type>または<type>int</type>型の引数であれば<type>bigint</type>、<type>bigint</type>型の引数であれば<type>numeric</type>、それ以外は引数のデータ型と同じ
      </entry>
<!--
      <entry>Yes</entry>
      <entry>sum of <replaceable class="parameter">expression</replaceable>
       across all non-null input values</entry>
-->
      <entry>可</entry>
      <entry>全ての入力値に渡り<replaceable class="parameter">expression</replaceable>の和</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>xmlagg</primary>
       </indexterm>
       <function>xmlagg(<replaceable class="parameter">expression</replaceable>)</function>
      </entry>
      <entry>
       <type>xml</type>
      </entry>
      <entry>
       <type>xml</type>
      </entry>
<!--
      <entry>No</entry>
      <entry>concatenation of non-null XML values
       (see also <xref linkend="functions-xml-xmlagg"/>)</entry>
-->
      <entry>不可</entry>
      <entry>XML値の連結（ <xref linkend="functions-xml-xmlagg"/>も参照）</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
<!--
   It should be noted that except for <function>count</function>,
   these functions return a null value when no rows are selected.  In
   particular, <function>sum</function> of no rows returns null, not
   zero as one might expect, and <function>array_agg</function>
   returns null rather than an empty array when there are no input
   rows.  The <function>coalesce</function> function can be used to
   substitute zero or an empty array for null when necessary.
-->
上記の関数は、<function>count</function>関数を除き、1行も選択されなかった場合NULL値を返すことに注意してください。
特に、行の選択がない<function>sum</function>関数は、予想されるであろうゼロではなくNULLを返し、そして<function>array_agg</function>は、入力行が存在しない場合に、空配列ではなくNULLを返します。
必要であれば、NULLをゼロまたは空配列と置換する目的で<function>coalesce</function>関数を使うことができます。
  </para>

  <para>
<!--
   Aggregate functions which support <firstterm>Partial Mode</firstterm>
   are eligible to participate in various optimizations, such as parallel
   aggregation.
-->
<firstterm>部分モード</firstterm>をサポートする集約関数は並列集約など、様々な最適化に参加することができます。
  </para>

  <note>
    <indexterm>
      <primary>ANY</primary>
    </indexterm>
    <indexterm>
      <primary>SOME</primary>
    </indexterm>
    <para>
<!--
      Boolean aggregates <function>bool_and</function> and
      <function>bool_or</function> correspond to standard SQL aggregates
      <function>every</function> and <function>any</function> or
      <function>some</function>.
      As for <function>any</function> and <function>some</function>,
      it seems that there is an ambiguity built into the standard syntax:
-->
<function>bool_and</function>、<function>bool_or</function>論理集約関数は標準SQLの集約関数<function>every</function>、<function>any</function>または<function>some</function>に対応します。
<function>any</function>と<function>some</function>についてですが、標準の構文には曖昧さがあるようです。
<programlisting>
SELECT b1 = ANY((SELECT b2 FROM t2 ...)) FROM t1 ...;
</programlisting>
<!--
      Here <function>ANY</function> can be considered either as introducing
      a subquery, or as being an aggregate function, if the subquery
      returns one row with a Boolean value.
      Thus the standard name cannot be given to these aggregates.
-->
ここで、副問い合わせが論理値での１行を返す場合、<function>ANY</function>は副問い合わせを導入するもの、もしくは集約関数であるものいずれかとみなすことができます。
従って、これらの集約関数に標準の名前を付けることはできません。
    </para>
  </note>

  <note>
   <para>
<!--
    Users accustomed to working with other SQL database management
    systems might be disappointed by the performance of the
    <function>count</function> aggregate when it is applied to the
    entire table. A query like:
-->
他のSQLデータベース管理システムでの作業に親しんだユーザは、<function>count</function>集約関数がテーブル全体に適用される場合の性能に失望するかも知れません。
<programlisting>
SELECT count(*) FROM sometable;
</programlisting>
<!--
    will require effort proportional to the size of the table:
    <productname>PostgreSQL</productname> will need to scan either the
    entire table or the entirety of an index which includes all rows in
    the table.
-->
のような問い合わせはテーブルサイズに比例した労力が必要です。<productname>PostgreSQL</productname>はテーブル全体か、そのテーブルの全ての行を含んだインデックス全体のスキャンを必要とします。

   </para>
  </note>

  <para>
<!--
   The aggregate functions <function>array_agg</function>,
   <function>json_agg</function>, <function>jsonb_agg</function>,
   <function>json_object_agg</function>, <function>jsonb_object_agg</function>,
   <function>string_agg</function>,
   and <function>xmlagg</function>, as well as similar user-defined
   aggregate functions, produce meaningfully different result values
   depending on the order of the input values.  This ordering is
   unspecified by default, but can be controlled by writing an
   <literal>ORDER BY</literal> clause within the aggregate call, as shown in
   <xref linkend="syntax-aggregates"/>.
   Alternatively, supplying the input values from a sorted subquery
   will usually work.  For example:
-->
集約関数<function>array_agg</function>、<function>json_agg</function>、<function>jsonb_agg</function>、<function>json_object_agg</function>、<function>jsonb_object_agg</function>、<function>string_agg</function>、および<function>xmlagg</function>、そして類似のユーザ定義の集約関数は、入力値の順序に依存した意味のある別の結果値を生成します。
この並び順はデフォルトでは指定されませんが、<xref linkend="syntax-aggregates"/>に記述されているように、集計呼び出し中に<literal>ORDER BY</literal>句を書くことで制御可能となります。別の方法として、並び替えられた副問い合わせから入力値を供給することでも上手くいきます。
例をあげます。

<screen><![CDATA[
SELECT xmlagg(x) FROM (SELECT x FROM test ORDER BY y DESC) AS tab;
]]></screen>

<!--
   Beware that this approach can fail if the outer query level contains
   additional processing, such as a join, because that might cause the
   subquery's output to be reordered before the aggregate is computed.
-->
外側の問い合わせのレベルで結合などの追加処理がある場合、この方法は失敗するかもしれないことに注意して下さい。
なぜなら、集約の計算の前に副問い合わせの出力を並べ替える必要があるかも知れないからです。
  </para>

  <para>
<!--
   <xref linkend="functions-aggregate-statistics-table"/> shows
   aggregate functions typically used in statistical analysis.
   (These are separated out merely to avoid cluttering the listing
   of more-commonly-used aggregates.)  Where the description mentions
   <replaceable class="parameter">N</replaceable>, it means the
   number of input rows for which all the input expressions are non-null.
   In all cases, null is returned if the computation is meaningless,
   for example when <replaceable class="parameter">N</replaceable> is zero.
-->
統計解析処理によく使用される集約関数を<xref linkend="functions-aggregate-statistics-table"/>に示します。
（これらは、より一般的に使用される集約関数との混乱を防ぐために別出ししました。）
説明の部分における<replaceable class="parameter">N</replaceable>は、すべての入力式が非NULLの入力行の個数を表します。
すべての場合にて、例えば<replaceable class="parameter">N</replaceable>が0の時など計算が無意味である場合にはNULLが返されます。
  </para>

  <indexterm>
<!--
   <primary>statistics</primary>
-->
   <primary>統計処理</primary>
  </indexterm>
  <indexterm>
<!--
   <primary>linear regression</primary>
-->
   <primary>線形リグレッション</primary>
  </indexterm>

  <table id="functions-aggregate-statistics-table">
<!--
   <title>Aggregate Functions for Statistics</title>
-->
   <title>統計処理用の集約関数</title>

   <tgroup cols="5">
    <thead>
     <row>
<!--
      <entry>Function</entry>
      <entry>Argument Type</entry>
      <entry>Return Type</entry>
      <entry>Partial Mode</entry>
      <entry>Description</entry>
-->
      <entry>関数</entry>
      <entry>引数の型</entry>
      <entry>戻り値の型</entry>
      <entry>部分モード</entry>
      <entry>説明</entry>
     </row>
    </thead>

    <tbody>

     <row>
      <entry>
       <indexterm>
<!--
        <primary>correlation</primary>
-->
        <primary>相関</primary>
       </indexterm>
       <indexterm>
        <primary>corr</primary>
       </indexterm>
       <function>corr(<replaceable class="parameter">Y</replaceable>, <replaceable class="parameter">X</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
<!--
      <entry>Yes</entry>
      <entry>correlation coefficient</entry>
-->
      <entry>可</entry>
      <entry>相関係数</entry>
     </row>

     <row>
      <entry>
       <indexterm>
<!--
        <primary>covariance</primary>
        <secondary>population</secondary>
-->
        <primary>共分散</primary>
        <secondary>母集団</secondary>
       </indexterm>
       <indexterm>
        <primary>covar_pop</primary>
       </indexterm>
       <function>covar_pop(<replaceable class="parameter">Y</replaceable>, <replaceable class="parameter">X</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
<!--
      <entry>Yes</entry>
      <entry>population covariance</entry>
-->
      <entry>可</entry>
      <entry>母共分散</entry>
     </row>

     <row>
      <entry>
       <indexterm>
<!--
        <primary>covariance</primary>
        <secondary>sample</secondary>
-->
        <primary>共分散</primary>
        <secondary>標本</secondary>
       </indexterm>
       <indexterm>
        <primary>covar_samp</primary>
       </indexterm>
       <function>covar_samp(<replaceable class="parameter">Y</replaceable>, <replaceable class="parameter">X</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
<!--
      <entry>Yes</entry>
      <entry>sample covariance</entry>
-->
      <entry>可</entry>
      <entry>標本共分散</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>regr_avgx</primary>
       </indexterm>
       <function>regr_avgx(<replaceable class="parameter">Y</replaceable>, <replaceable class="parameter">X</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
<!--
      <entry>Yes</entry>
      <entry>average of the independent variable
      (<literal>sum(<replaceable class="parameter">X</replaceable>)/<replaceable class="parameter">N</replaceable></literal>)</entry>
-->
      <entry>可</entry>
      <entry>独立変数の平均値
      (<literal>sum(<replaceable class="parameter">X</replaceable>)/<replaceable class="parameter">N</replaceable></literal>)</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>regr_avgy</primary>
       </indexterm>
       <function>regr_avgy(<replaceable class="parameter">Y</replaceable>, <replaceable class="parameter">X</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
<!--
      <entry>Yes</entry>
      <entry>average of the dependent variable
      (<literal>sum(<replaceable class="parameter">Y</replaceable>)/<replaceable class="parameter">N</replaceable></literal>)</entry>
-->
      <entry>可</entry>
      <entry>従属変数の平均値
      (<literal>sum(<replaceable class="parameter">Y</replaceable>)/<replaceable class="parameter">N</replaceable></literal>)</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>regr_count</primary>
       </indexterm>
       <function>regr_count(<replaceable class="parameter">Y</replaceable>, <replaceable class="parameter">X</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>
       <type>bigint</type>
      </entry>
<!--
      <entry>Yes</entry>
      <entry>number of input rows in which both expressions are nonnull</entry>
-->
      <entry>可</entry>
      <entry>両式が非NULLとなる入力行の個数</entry>
     </row>

     <row>
      <entry>
       <indexterm>
<!--
        <primary>regression intercept</primary>
-->
        <primary>回帰切片</primary>
       </indexterm>
       <indexterm>
        <primary>regr_intercept</primary>
       </indexterm>
       <function>regr_intercept(<replaceable class="parameter">Y</replaceable>, <replaceable class="parameter">X</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
<!--
      <entry>Yes</entry>
      <entry>y-intercept of the least-squares-fit linear equation
      determined by the (<replaceable
      class="parameter">X</replaceable>, <replaceable
      class="parameter">Y</replaceable>) pairs</entry>
-->
      <entry>可</entry>
      <entry>(<replaceable class="parameter">X</replaceable>, <replaceable class="parameter">Y</replaceable>)の組み合わせで決まる、最小二乗法による線形方程式のY切片</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>regr_r2</primary>
       </indexterm>
       <function>regr_r2(<replaceable class="parameter">Y</replaceable>, <replaceable class="parameter">X</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
<!--
      <entry>Yes</entry>
      <entry>square of the correlation coefficient</entry>
-->
      <entry>可</entry>
      <entry>相関係数の二乗</entry>
     </row>

     <row>
      <entry>
       <indexterm>
<!--
        <primary>regression slope</primary>
-->
        <primary>回帰勾配</primary>
       </indexterm>
       <indexterm>
        <primary>regr_slope</primary>
       </indexterm>
       <function>regr_slope(<replaceable class="parameter">Y</replaceable>, <replaceable class="parameter">X</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
<!--
      <entry>Yes</entry>
      <entry>slope of the least-squares-fit linear equation determined
      by the (<replaceable class="parameter">X</replaceable>,
      <replaceable class="parameter">Y</replaceable>) pairs</entry>
-->
      <entry>可</entry>
      <entry><replaceable class="parameter">X</replaceable>, <replaceable class="parameter">Y</replaceable>)の組み合わせで決まる、最小二乗法による線型方程式の傾き</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>regr_sxx</primary>
       </indexterm>
       <function>regr_sxx(<replaceable class="parameter">Y</replaceable>, <replaceable class="parameter">X</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
<!--
      <entry>Yes</entry>
      <entry><literal>sum(<replaceable
      class="parameter">X</replaceable>^2) - sum(<replaceable
      class="parameter">X</replaceable>)^2/<replaceable
      class="parameter">N</replaceable></literal> (<quote>sum of
      squares</quote> of the independent variable)</entry>
-->
      <entry>可</entry>
      <entry><literal>sum(<replaceable
      class="parameter">X</replaceable>^2) - sum(<replaceable
      class="parameter">X</replaceable>)^2/<replaceable
      class="parameter">N</replaceable></literal>
     （従属変数の<quote>二乗和</quote>）
     </entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>regr_sxy</primary>
       </indexterm>
       <function>regr_sxy(<replaceable class="parameter">Y</replaceable>, <replaceable class="parameter">X</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
<!--
      <entry>Yes</entry>
      <entry><literal>sum(<replaceable
      class="parameter">X</replaceable>*<replaceable
      class="parameter">Y</replaceable>) - sum(<replaceable
      class="parameter">X</replaceable>) * sum(<replaceable
      class="parameter">Y</replaceable>)/<replaceable
      class="parameter">N</replaceable></literal> (<quote>sum of
      products</quote> of independent times dependent
      variable)</entry>
-->
      <entry>可</entry>
      <entry><literal>sum(<replaceable
      class="parameter">X</replaceable>*<replaceable
      class="parameter">Y</replaceable>) - sum(<replaceable
      class="parameter">X</replaceable>) * sum(<replaceable
      class="parameter">Y</replaceable>)/<replaceable
      class="parameter">N</replaceable></literal>
     （従属変数と独立変数の<quote>積の和</quote>）
      </entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>regr_syy</primary>
       </indexterm>
       <function>regr_syy(<replaceable class="parameter">Y</replaceable>, <replaceable class="parameter">X</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
<!--
      <entry>Yes</entry>
      <entry><literal>sum(<replaceable
      class="parameter">Y</replaceable>^2) - sum(<replaceable
      class="parameter">Y</replaceable>)^2/<replaceable
      class="parameter">N</replaceable></literal> (<quote>sum of
      squares</quote> of the dependent variable)</entry>
-->
      <entry>可</entry>
      <entry><literal>sum(<replaceable
      class="parameter">Y</replaceable>^2) - sum(<replaceable
      class="parameter">Y</replaceable>)^2/<replaceable
      class="parameter">N</replaceable></literal>
     （独立変数の<quote>二乗和</quote>）</entry>
     </row>

     <row>
      <entry>
       <indexterm>
<!--
        <primary>standard deviation</primary>
-->
        <primary>標準偏差</primary>
       </indexterm>
       <indexterm>
        <primary>stddev</primary>
       </indexterm>
       <function>stddev(<replaceable class="parameter">expression</replaceable>)</function>
      </entry>
      <entry>
<!--
       <type>smallint</type>, <type>int</type>,
       <type>bigint</type>, <type>real</type>, <type>double
       precision</type>, or <type>numeric</type>
-->
       <type>smallint</type>、<type>int</type>、
       <type>bigint</type>、<type>real</type>、<type>double
       precision</type>、または<type>numeric</type>
      </entry>
      <entry>
<!--
       <type>double precision</type> for floating-point arguments,
       otherwise <type>numeric</type>
-->
       浮動小数点型の引数では<type>double precision</type>。それ以外では<type>numeric</type>
      </entry>
<!--
      <entry>Yes</entry>
      <entry>historical alias for <function>stddev_samp</function></entry>
-->
      <entry>可</entry>
      <entry><function>stddev_samp</function>の歴史的な別名</entry>
     </row>

     <row>
      <entry>
       <indexterm>
<!--
        <primary>standard deviation</primary>
-->
    <primary>標準偏差</primary>
<!--
        <secondary>population</secondary>
-->
    <secondary>母集団</secondary>
       </indexterm>
       <indexterm>
        <primary>stddev_pop</primary>
       </indexterm>
       <function>stddev_pop(<replaceable class="parameter">expression</replaceable>)</function>
      </entry>
      <entry>
<!--
       <type>smallint</type>, <type>int</type>,
       <type>bigint</type>, <type>real</type>, <type>double
       precision</type>, or <type>numeric</type>
-->
       <type>smallint</type>、<type>int</type>、
       <type>bigint</type>、<type>real</type>、<type>double
       precision</type>、または<type>numeric</type>
      </entry>
      <entry>
<!--
       <type>double precision</type> for floating-point arguments,
       otherwise <type>numeric</type>
-->
       浮動小数点型の引数では<type>double precision</type>。それ以外では<type>numeric</type>
      </entry>
<!--
      <entry>Yes</entry>
      <entry>population standard deviation of the input values</entry>
-->
      <entry>可</entry>
      <entry>入力値に対する母標準偏差</entry>
     </row>

     <row>
      <entry>
       <indexterm>
<!--
        <primary>standard deviation</primary>
        <secondary>sample</secondary>
-->
        <primary>標準偏差</primary>
        <secondary>標本</secondary>
       </indexterm>
       <indexterm>
        <primary>stddev_samp</primary>
       </indexterm>
       <function>stddev_samp(<replaceable class="parameter">expression</replaceable>)</function>
      </entry>
      <entry>
<!--
       <type>smallint</type>, <type>int</type>,
       <type>bigint</type>, <type>real</type>, <type>double
       precision</type>, or <type>numeric</type>
-->
       <type>smallint</type>、<type>int</type>、
       <type>bigint</type>、<type>real</type>、<type>double
       precision</type>、または<type>numeric</type>
      </entry>
      <entry>
<!--
       <type>double precision</type> for floating-point arguments,
       otherwise <type>numeric</type>
-->
       浮動小数点型の引数では<type>double precision</type>。それ以外では<type>numeric</type>
      </entry>
<!--
      <entry>Yes</entry>
      <entry>sample standard deviation of the input values</entry>
-->
      <entry>可</entry>
      <entry>入力値に対する標本標準偏差</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>variance</primary>
       </indexterm>
       <function>variance</function>(<replaceable class="parameter">expression</replaceable>)
      </entry>
      <entry>
<!--
       <type>smallint</type>, <type>int</type>,
       <type>bigint</type>, <type>real</type>, <type>double
       precision</type>, or <type>numeric</type>
-->
       <type>smallint</type>、<type>int</type>、
       <type>bigint</type>、<type>real</type>、<type>double
       precision</type>、または<type>numeric</type>
      </entry>
      <entry>
<!--
       <type>double precision</type> for floating-point arguments,
       otherwise <type>numeric</type>
-->
       浮動小数点型の引数では<type>double precision</type>。それ以外では<type>numeric</type>
      </entry>
<!--
      <entry>Yes</entry>
      <entry>historical alias for <function>var_samp</function></entry>
-->
      <entry>可</entry>
      <entry><function>var_samp</function>の歴史的な別名</entry>
     </row>

     <row>
      <entry>
       <indexterm>
<!--
        <primary>variance</primary>
        <secondary>population</secondary>
-->
        <primary>分散</primary>
        <secondary>母集団</secondary>
       </indexterm>
       <indexterm>
        <primary>var_pop</primary>
       </indexterm>
       <function>var_pop</function>(<replaceable class="parameter">expression</replaceable>)
      </entry>
      <entry>
<!--
       <type>smallint</type>, <type>int</type>,
       <type>bigint</type>, <type>real</type>, <type>double
       precision</type>, or <type>numeric</type>
-->
       <type>smallint</type>、<type>int</type>、
       <type>bigint</type>、<type>real</type>、<type>double
       precision</type>、または<type>numeric</type>
      </entry>
      <entry>
<!--
       <type>double precision</type> for floating-point arguments,
       otherwise <type>numeric</type>
-->
       浮動小数点型の引数では<type>double precision</type>。それ以外では<type>numeric</type>
      </entry>
<!--
      <entry>Yes</entry>
      <entry>population variance of the input values (square of the population standard deviation)</entry>
-->
      <entry>可</entry>
      <entry>入力値に対する母分散（母標準偏差の二乗）</entry>
     </row>

     <row>
      <entry>
       <indexterm>
<!--
        <primary>variance</primary>
        <secondary>sample</secondary>
-->
        <primary>分散</primary>
        <secondary>標本</secondary>
       </indexterm>
       <indexterm>
        <primary>var_samp</primary>
       </indexterm>
       <function>var_samp</function>(<replaceable class="parameter">expression</replaceable>)
      </entry>
      <entry>
<!--
       <type>smallint</type>, <type>int</type>,
       <type>bigint</type>, <type>real</type>, <type>double
       precision</type>, or <type>numeric</type>
-->
       <type>smallint</type>、<type>int</type>、
       <type>bigint</type>、<type>real</type>、<type>double
       precision</type>、または<type>numeric</type>
      </entry>
      <entry>
<!--
       <type>double precision</type> for floating-point arguments,
       otherwise <type>numeric</type>
-->
       浮動小数点型の引数では<type>double precision</type>。それ以外では<type>numeric</type>
      </entry>
<!--
      <entry>Yes</entry>
      <entry>sample variance of the input values (square of the sample standard deviation)</entry>
-->
      <entry>可</entry>
      <entry>入力値に対する標本分散（標本標準偏差の二乗）</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
<!--
   <xref linkend="functions-orderedset-table"/> shows some
   aggregate functions that use the <firstterm>ordered-set aggregate</firstterm>
   syntax.  These functions are sometimes referred to as <quote>inverse
   distribution</quote> functions.
-->
<xref linkend="functions-orderedset-table"/>に<firstterm>順序集合集約</firstterm>構文を使う集約関数を示します。
これらの関数は<quote>逆分散</quote>関数として参照されることがあります。
  </para>

  <indexterm>
<!--
   <primary>ordered-set aggregate</primary>
   <secondary>built-in</secondary>
-->
   <primary>順序集合集約</primary>
   <secondary>組み込み</secondary>
  </indexterm>
  <indexterm>
<!--
   <primary>inverse distribution</primary>
-->
   <primary>逆分散</primary>
  </indexterm>

  <table id="functions-orderedset-table">
<!--
   <title>Ordered-Set Aggregate Functions</title>
-->
   <title>順序集合集約関数</title>

   <tgroup cols="6">
    <thead>
     <row>
<!--
      <entry>Function</entry>
      <entry>Direct Argument Type(s)</entry>
      <entry>Aggregated Argument Type(s)</entry>
      <entry>Return Type</entry>
      <entry>Partial Mode</entry>
      <entry>Description</entry>
-->
      <entry>関数</entry>
      <entry>直接引数型</entry>
      <entry>集約された引数型</entry>
      <entry>戻り値型</entry>
      <entry>部分モード</entry>
      <entry>説明</entry>
     </row>
    </thead>

    <tbody>

     <row>
      <entry>
       <indexterm>
<!--
        <primary>mode</primary>
        <secondary>statistical</secondary>
-->
        <primary>最頻値(モード)</primary>
        <secondary>統計</secondary>
       </indexterm>
       <function>mode() WITHIN GROUP (ORDER BY <replaceable class="parameter">sort_expression</replaceable>)</function>
      </entry>
      <entry>
      </entry>
      <entry>
<!--
       any sortable type
-->
       ソート可能な型
      </entry>
      <entry>
<!--
       same as sort expression
-->
       ソート式と同じ
      </entry>
<!--
      <entry>No</entry>
-->
      <entry>不可</entry>
      <entry>
<!--
       returns the most frequent input value (arbitrarily choosing the first
       one if there are multiple equally-frequent results)
-->
       入力の最頻値を返す(複数の同じ度数の結果があれば、任意に選んだ最初のもの)
      </entry>
     </row>

     <row>
      <entry>
       <indexterm>
<!--
        <primary>percentile</primary>
        <secondary>continuous</secondary>
-->
        <primary>百分位数</primary>
        <secondary>連続</secondary>
       </indexterm>
       <function>percentile_cont(<replaceable class="parameter">fraction</replaceable>) WITHIN GROUP (ORDER BY <replaceable class="parameter">sort_expression</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>
<!--
       <type>double precision</type> or <type>interval</type>
-->
       <type>double precision</type>または<type>interval</type>
      </entry>
      <entry>
<!--
       same as sort expression
-->
       ソート式と同じ
      </entry>
<!--
      <entry>No</entry>
-->
      <entry>不可</entry>
      <entry>
<!--
       continuous percentile: returns a value corresponding to the specified
       fraction in the ordering, interpolating between adjacent input items if
       needed
-->
       連続百分位数: 入力項目を並べて必要であれば隣り合うものを補間して指定された割合に対応する値を返す
      </entry>
     </row>

     <row>
      <entry>
       <function>percentile_cont(<replaceable class="parameter">fractions</replaceable>) WITHIN GROUP (ORDER BY <replaceable class="parameter">sort_expression</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision[]</type>
      </entry>
      <entry>
<!--
       <type>double precision</type> or <type>interval</type>
-->
       <type>double precision</type>または<type>interval</type>
      </entry>
      <entry>
<!--
       array of sort expression's type
-->
       ソート式の型の配列
      </entry>
<!--
      <entry>No</entry>
-->
      <entry>不可</entry>
      <entry>
<!--
       multiple continuous percentile: returns an array of results matching
       the shape of the <replaceable>fractions</replaceable> parameter, with each
       non-null element replaced by the value corresponding to that percentile
-->
       複数の連続百分位数: 各非NULL要素をその百分位数に対応する値で置き換えて、<replaceable>fractions</replaceable>パラメータの形に一致する結果の配列を返す
      </entry>
     </row>

     <row>
      <entry>
       <indexterm>
<!--
        <primary>percentile</primary>
        <secondary>discrete</secondary>
-->
        <primary>百分位数</primary>
        <secondary>離散</secondary>
       </indexterm>
       <function>percentile_disc(<replaceable class="parameter">fraction</replaceable>) WITHIN GROUP (ORDER BY <replaceable class="parameter">sort_expression</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
      <entry>
<!--
       any sortable type
-->
       ソート可能な型
      </entry>
      <entry>
<!--
       same as sort expression
-->
       ソート式と同じ
      </entry>
<!--
      <entry>No</entry>
-->
      <entry>不可</entry>
      <entry>
<!--
       discrete percentile: returns the first input value whose position in
       the ordering equals or exceeds the specified fraction
-->
       離散百分位数: 並べた時のその位置が指定された割合と等しいもしくは越える最初の入力値を返す
      </entry>
     </row>

     <row>
      <entry>
       <function>percentile_disc(<replaceable class="parameter">fractions</replaceable>) WITHIN GROUP (ORDER BY <replaceable class="parameter">sort_expression</replaceable>)</function>
      </entry>
      <entry>
       <type>double precision[]</type>
      </entry>
      <entry>
<!--
       any sortable type
-->
       ソート可能な型
      </entry>
      <entry>
<!--
       array of sort expression's type
-->
       ソート式の型の配列
      </entry>
<!--
      <entry>No</entry>
-->
      <entry>不可</entry>
      <entry>
<!--
       multiple discrete percentile: returns an array of results matching the
       shape of the <replaceable>fractions</replaceable> parameter, with each non-null
       element replaced by the input value corresponding to that percentile
-->
       複数の離散百分位数: 各非NULL要素をその百分位数に対応する値で置き換えて、<replaceable>fractions</replaceable>パラメータの形に一致する結果の配列を返す
      </entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <para>
<!--
   All the aggregates listed in <xref linkend="functions-orderedset-table"/>
   ignore null values in their sorted input.  For those that take
   a <replaceable>fraction</replaceable> parameter, the fraction value must be
   between 0 and 1; an error is thrown if not.  However, a null fraction value
   simply produces a null result.
-->
<xref linkend="functions-orderedset-table"/>に列挙された集約はすべて整列された入力内のNULL値を無視します。
<replaceable>fraction</replaceable>パラメータを取るものでは、fraction（割合）の値は0と1の間でなければなりません。そうでなければエラーが投げられます。
しかしながら、franctionの値がNULLなら単にNULLという結果になります。
  </para>

  <indexterm>
<!--
   <primary>hypothetical-set aggregate</primary>
   <secondary>built-in</secondary>
-->
   <primary>仮想集合集約</primary>
   <secondary>組み込み</secondary>
  </indexterm>

  <para>
<!--
   Each of the aggregates listed in
   <xref linkend="functions-hypothetical-table"/> is associated with a
   window function of the same name defined in
   <xref linkend="functions-window"/>.  In each case, the aggregate result
   is the value that the associated window function would have
   returned for the <quote>hypothetical</quote> row constructed from
   <replaceable>args</replaceable>, if such a row had been added to the sorted
   group of rows computed from the <replaceable>sorted_args</replaceable>.
-->
<xref linkend="functions-hypothetical-table"/>に列挙されている集約は、それぞれ<xref linkend="functions-window"/>で定義されている同じ名前のウィンドウ関数と関連します。
どの場合も、集約結果は、<replaceable>args</replaceable>から構築される<quote>仮想的な</quote>行に対して、関連するウィンドウ関数が返す値で、そのような行が<replaceable>sorted_args</replaceable>から計算されるソートされた行のグループに追加される場合を想定します。
  </para>

  <table id="functions-hypothetical-table">
<!--
   <title>Hypothetical-Set Aggregate Functions</title>
-->
   <title>仮想集合集約関数</title>

   <tgroup cols="6">
    <thead>
     <row>
<!--
      <entry>Function</entry>
      <entry>Direct Argument Type(s)</entry>
      <entry>Aggregated Argument Type(s)</entry>
      <entry>Return Type</entry>
      <entry>Partial Mode</entry>
      <entry>Description</entry>
-->
      <entry>関数</entry>
      <entry>直接引数型</entry>
      <entry>集約された引数型</entry>
      <entry>戻り値型</entry>
      <entry>部分モード</entry>
      <entry>説明</entry>
     </row>
    </thead>

    <tbody>

     <row>
      <entry>
       <indexterm>
        <primary>rank</primary>
<!--
        <secondary>hypothetical</secondary>
-->
        <secondary>仮想の</secondary>
       </indexterm>
       <function>rank(<replaceable class="parameter">args</replaceable>) WITHIN GROUP (ORDER BY <replaceable class="parameter">sorted_args</replaceable>)</function>
      </entry>
      <entry>
       <literal>VARIADIC</literal> <type>"any"</type>
      </entry>
      <entry>
       <literal>VARIADIC</literal> <type>"any"</type>
      </entry>
      <entry>
       <type>bigint</type>
      </entry>
<!--
      <entry>No</entry>
-->
      <entry>不可</entry>
      <entry>
<!--
       rank of the hypothetical row, with gaps for duplicate rows
-->
       重複する行のギャップを含む仮想の行の順位
      </entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>dense_rank</primary>
<!--
        <secondary>hypothetical</secondary>
-->
        <secondary>仮想の</secondary>
       </indexterm>
       <function>dense_rank(<replaceable class="parameter">args</replaceable>) WITHIN GROUP (ORDER BY <replaceable class="parameter">sorted_args</replaceable>)</function>
      </entry>
      <entry>
       <literal>VARIADIC</literal> <type>"any"</type>
      </entry>
      <entry>
       <literal>VARIADIC</literal> <type>"any"</type>
      </entry>
      <entry>
       <type>bigint</type>
      </entry>
<!--
      <entry>No</entry>
-->
      <entry>不可</entry>
      <entry>
<!--
       rank of the hypothetical row, without gaps
-->
       ギャップを含まない仮想の行の順位
      </entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>percent_rank</primary>
<!--
        <secondary>hypothetical</secondary>
-->
        <secondary>仮想の</secondary>
       </indexterm>
       <function>percent_rank(<replaceable class="parameter">args</replaceable>) WITHIN GROUP (ORDER BY <replaceable class="parameter">sorted_args</replaceable>)</function>
      </entry>
      <entry>
       <literal>VARIADIC</literal> <type>"any"</type>
      </entry>
      <entry>
       <literal>VARIADIC</literal> <type>"any"</type>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
<!--
      <entry>No</entry>
-->
      <entry>不可</entry>
      <entry>
<!--
       relative rank of the hypothetical row, ranging from 0 to 1
-->
       仮想の行の相対順位、0から1まで
      </entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>cume_dist</primary>
<!--
        <secondary>hypothetical</secondary>
-->
        <secondary>仮想の</secondary>
       </indexterm>
       <function>cume_dist(<replaceable class="parameter">args</replaceable>) WITHIN GROUP (ORDER BY <replaceable class="parameter">sorted_args</replaceable>)</function>
      </entry>
      <entry>
       <literal>VARIADIC</literal> <type>"any"</type>
      </entry>
      <entry>
       <literal>VARIADIC</literal> <type>"any"</type>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
<!--
      <entry>No</entry>
-->
      <entry>不可</entry>
      <entry>
<!--
       relative rank of the hypothetical row, ranging from
       1/<replaceable>N</replaceable> to 1
-->
       仮想の行の相対順位、1/<replaceable>N</replaceable>から1まで
      </entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <para>
<!--
   For each of these hypothetical-set aggregates, the list of direct arguments
   given in <replaceable>args</replaceable> must match the number and types of
   the aggregated arguments given in <replaceable>sorted_args</replaceable>.
   Unlike most built-in aggregates, these aggregates are not strict, that is
   they do not drop input rows containing nulls.  Null values sort according
   to the rule specified in the <literal>ORDER BY</literal> clause.
-->
各仮想集合集約に対して<replaceable>args</replaceable>で与えられる直接引数のリストは、<replaceable>sorted_args</replaceable>で与えられる集約された引数の数と型に一致しなければなりません。
ほとんどの組み込み集約とは異なり、この集約はSTRICTではありません、すなわち、NULLを含む入力行を落としません。
NULL値は<literal>ORDER BY</literal>節で指定されるルールに従って並べられます。
  </para>

  <table id="functions-grouping-table">
<!--
   <title>Grouping Operations</title>
-->
   <title>グループ化演算</title>

   <tgroup cols="3">
    <thead>
     <row>
<!--
      <entry>Function</entry>
      <entry>Return Type</entry>
      <entry>Description</entry>
-->
      <entry>関数</entry>
      <entry>戻り値型</entry>
      <entry>説明</entry>
     </row>
    </thead>

    <tbody>

     <row>
      <entry>
       <indexterm>
        <primary>GROUPING</primary>
       </indexterm>
       <function>GROUPING(<replaceable class="parameter">args...</replaceable>)</function>
      </entry>
      <entry>
       <type>integer</type>
      </entry>
      <entry>
<!--
       Integer bit mask indicating which arguments are not being included in the current
       grouping set
-->
どの引数が現在のグループ化セットに含まれないかを示す整数のビットマスク
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

   <para>
<!--
    Grouping operations are used in conjunction with grouping sets (see
    <xref linkend="queries-grouping-sets"/>) to distinguish result rows.  The
    arguments to the <literal>GROUPING</literal> operation are not actually evaluated,
    but they must match exactly expressions given in the <literal>GROUP BY</literal>
    clause of the associated query level.  Bits are assigned with the rightmost
    argument being the least-significant bit; each bit is 0 if the corresponding
    expression is included in the grouping criteria of the grouping set generating
    the result row, and 1 if it is not.  For example:
-->
グループ化演算はグループ化セット（<xref linkend="queries-grouping-sets"/>参照）と一緒に使われ、結果の行を区別するものです。
<literal>GROUPING</literal>演算の引数は実際には評価されませんが、関連する問い合わせの<literal>GROUP BY</literal>句にある式と正確に一致する必要があります。
最も右側の引数が最下位ビットになるようにビットが割り当てられます。
各ビットは、対応する式が結果の行を生成するグループ化セットのグループ化条件に含まれていれば0、そうでなければ1です。
例えば以下のようになります。
<screen>
<prompt>=&gt;</prompt> <userinput>SELECT * FROM items_sold;</userinput>
 make  | model | sales
-------+-------+-------
 Foo   | GT    |  10
 Foo   | Tour  |  20
 Bar   | City  |  15
 Bar   | Sport |  5
(4 rows)

<prompt>=&gt;</prompt> <userinput>SELECT make, model, GROUPING(make,model), sum(sales) FROM items_sold GROUP BY ROLLUP(make,model);</userinput>
 make  | model | grouping | sum
-------+-------+----------+-----
 Foo   | GT    |        0 | 10
 Foo   | Tour  |        0 | 20
 Bar   | City  |        0 | 15
 Bar   | Sport |        0 | 5
 Foo   |       |        1 | 30
 Bar   |       |        1 | 20
       |       |        3 | 50
(7 rows)
</screen>
   </para>

 </sect1>

 <sect1 id="functions-window">
<!--
  <title>Window Functions</title>
-->
  <title>ウィンドウ関数</title>

  <indexterm zone="functions-window">
<!--
   <primary>window function</primary>
   <secondary>built-in</secondary>
-->
   <primary>ウィンドウ関数</primary>
   <secondary>組み込み</secondary>
  </indexterm>

  <para>
<!--
   <firstterm>Window functions</firstterm> provide the ability to perform
   calculations across sets of rows that are related to the current query
   row.  See <xref linkend="tutorial-window"/> for an introduction to this
   feature, and <xref linkend="syntax-window-functions"/> for syntax
   details.
-->
<firstterm>ウィンドウ関数</firstterm>は現在の問い合わせ行に関連した行集合に渡っての計算処理機能を提供します。
この機能の手引きは<xref linkend="tutorial-window"/>を、文法の詳細は<xref linkend="syntax-window-functions"/>を参照してください。
  </para>

  <para>
<!--
   The built-in window functions are listed in
   <xref linkend="functions-window-table"/>.  Note that these functions
   <emphasis>must</emphasis> be invoked using window function syntax, i.e., an
   <literal>OVER</literal> clause is required.
-->
組み込みウィンドウ関数は<xref linkend="functions-window-table"/>に一覧されています。
これらの関数は<emphasis>必ず</emphasis>ウィンドウ関数構文で呼び出されなければなりません。つまり、<literal>OVER</literal>句が必要です。
  </para>

  <para>
<!--
   In addition to these functions, any built-in or user-defined
   general-purpose or statistical
   aggregate (i.e., not ordered-set or hypothetical-set aggregates)
   can be used as a window function; see
   <xref linkend="functions-aggregate"/> for a list of the built-in aggregates.
   Aggregate functions act as window functions only when an <literal>OVER</literal>
   clause follows the call; otherwise they act as non-window aggregates
   and return a single row for the entire set.
-->
これらの関数に加え、どんな組み込み、またはユーザ定義の汎用集約関数または統計集約関数もウィンドウ関数として使用できます(ただし順序集合や仮想集合集約はそうではありません)。組み込み集約関数一覧は<xref linkend="functions-aggregate"/>を参照してください。
集約関数は、呼び出しの後に<literal>OVER</literal>句が続いた場合のみウィンドウ関数として動作します。それ以外の場合は、非ウィンドウの集約関数として動作し、集合全体に対して1行だけを返します。
  </para>

  <table id="functions-window-table">
<!--
   <title>General-Purpose Window Functions</title>
-->
   <title>汎用ウィンドウ関数</title>

   <tgroup cols="3">
    <thead>
     <row>
<!--
      <entry>Function</entry>
      <entry>Return Type</entry>
      <entry>Description</entry>
-->
      <entry>関数</entry>
      <entry>戻り値</entry>
      <entry>説明</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>
       <indexterm>
        <primary>row_number</primary>
       </indexterm>
       <function>row_number()</function>
      </entry>
      <entry>
       <type>bigint</type>
      </entry>
<!--
      <entry>number of the current row within its partition, counting from 1</entry>
-->
      <entry>現在行のパーティション内での行番号（１から数える）</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>rank</primary>
       </indexterm>
       <function>rank()</function>
      </entry>
      <entry>
       <type>bigint</type>
      </entry>
<!--
      <entry>rank of the current row with gaps; same as <function>row_number</function> of its first peer</entry>
-->
      <entry>ギャップを含んだ現在行の順位。先頭ピアの<function>row_number</function>と同じになる。</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>dense_rank</primary>
       </indexterm>
       <function>dense_rank()</function>
      </entry>
      <entry>
       <type>bigint</type>
      </entry>
<!--
      <entry>rank of the current row without gaps; this function counts peer groups</entry>
-->
      <entry>ギャップを含まない現在行の順位。この関数はピアのグループ数を数える。</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>percent_rank</primary>
       </indexterm>
       <function>percent_rank()</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
<!--
      <entry>relative rank of the current row: (<function>rank</function> - 1) / (total partition rows - 1)</entry>
-->
      <entry>現在行の相対順位。 (<function>rank</function> - 1) / (パーティションの総行数 - 1)</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>cume_dist</primary>
       </indexterm>
       <function>cume_dist()</function>
      </entry>
      <entry>
       <type>double precision</type>
      </entry>
<!--
      <entry>cumulative distribution: (number of partition rows preceding or peer with current row) / total partition rows</entry>
-->
      <entry>現在行の相対順位。 (現在行より先行する行およびピアの行数) / (パーティションの総行数)</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>ntile</primary>
       </indexterm>
       <function>ntile(<replaceable class="parameter">num_buckets</replaceable> <type>integer</type>)</function>
      </entry>
      <entry>
       <type>integer</type>
      </entry>
<!--
      <entry>integer ranging from 1 to the argument value, dividing the
       partition as equally as possible</entry>
-->
       <entry>できるだけ等価にパーティションを分割した、1から引数値までの整数</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>lag</primary>
       </indexterm>
       <function>
         lag(<replaceable class="parameter">value</replaceable> <type>anyelement</type>
             [, <replaceable class="parameter">offset</replaceable> <type>integer</type>
             [, <replaceable class="parameter">default</replaceable> <type>anyelement</type> ]])
       </function>
      </entry>
      <entry>
<!--
       <type>same type as <replaceable class="parameter">value</replaceable></type>
-->
       <type><replaceable class="parameter">value</replaceable>と同じ型</type>
      </entry>
      <entry>
<!--
       returns <replaceable class="parameter">value</replaceable> evaluated at
       the row that is <replaceable class="parameter">offset</replaceable>
       rows before the current row within the partition; if there is no such
       row, instead return <replaceable class="parameter">default</replaceable>
       (which must be of the same type as
       <replaceable class="parameter">value</replaceable>).
       Both <replaceable class="parameter">offset</replaceable> and
       <replaceable class="parameter">default</replaceable> are evaluated
       with respect to the current row.  If omitted,
       <replaceable class="parameter">offset</replaceable> defaults to 1 and
       <replaceable class="parameter">default</replaceable> to null
-->
パーティション内の現在行より<replaceable class="parameter">offset</replaceable>行だけ前の行で評価された<replaceable class="parameter">value</replaceable>を返す。
該当する行がない場合、その代わりとして<replaceable class="parameter">default</replaceable>(<replaceable class="parameter">value</replaceable>と同じ型でなければならない)を返す。
<replaceable class="parameter">offset</replaceable>と<replaceable class="parameter">default</replaceable>は共に現在行について評価される。
省略された場合、<replaceable class="parameter">offset</replaceable>は1となり、<replaceable class="parameter">default</replaceable>はNULLになる。
      </entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>lead</primary>
       </indexterm>
       <function>
         lead(<replaceable class="parameter">value</replaceable> <type>anyelement</type>
              [, <replaceable class="parameter">offset</replaceable> <type>integer</type>
              [, <replaceable class="parameter">default</replaceable> <type>anyelement</type> ]])
       </function>
      </entry>
      <entry>
<!--
       <type>same type as <replaceable class="parameter">value</replaceable></type>
-->
       <type><replaceable class="parameter">value</replaceable>と同じ型</type>
      </entry>
      <entry>
<!--
       returns <replaceable class="parameter">value</replaceable> evaluated at
       the row that is <replaceable class="parameter">offset</replaceable>
       rows after the current row within the partition; if there is no such
       row, instead return <replaceable class="parameter">default</replaceable>
       (which must be of the same type as
       <replaceable class="parameter">value</replaceable>).
       Both <replaceable class="parameter">offset</replaceable> and
       <replaceable class="parameter">default</replaceable> are evaluated
       with respect to the current row.  If omitted,
       <replaceable class="parameter">offset</replaceable> defaults to 1 and
       <replaceable class="parameter">default</replaceable> to null
-->
パーティション内の現在行より<replaceable class="parameter">offset</replaceable>行だけ後の行で評価された<replaceable class="parameter">value</replaceable>を返す。
該当する行がない場合、その代わりとして<replaceable class="parameter">default</replaceable>(<replaceable class="parameter">value</replaceable>と同じ型でなければならない)を返す。
<replaceable class="parameter">offset</replaceable>と<replaceable class="parameter">default</replaceable>は共に現在行について評価される。
省略された場合、<replaceable class="parameter">offset</replaceable>は1となり、<replaceable class="parameter">default</replaceable>はNULLになる。
      </entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>first_value</primary>
       </indexterm>
       <function>first_value(<replaceable class="parameter">value</replaceable> <type>any</type>)</function>
      </entry>
      <entry>
<!--
       <type>same type as <replaceable class="parameter">value</replaceable></type>
-->
       <type><replaceable class="parameter">value</replaceable>と同じ型</type>
      </entry>
      <entry>
<!--
       returns <replaceable class="parameter">value</replaceable> evaluated
       at the row that is the first row of the window frame
-->
       ウィンドウフレームの最初の行である行で評価された<replaceable class="parameter">value</replaceable> を返す
      </entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>last_value</primary>
       </indexterm>
       <function>last_value(<replaceable class="parameter">value</replaceable> <type>any</type>)</function>
      </entry>
      <entry>
<!--
       <type>same type as <replaceable class="parameter">value</replaceable></type>
-->
       <type><replaceable class="parameter">value</replaceable>と同じ型</type>
      </entry>
      <entry>
<!--
       returns <replaceable class="parameter">value</replaceable> evaluated
       at the row that is the last row of the window frame
-->
       ウィンドウフレームの最後の行である行で評価された<replaceable class="parameter">value</replaceable> を返す
      </entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>nth_value</primary>
       </indexterm>
       <function>
         nth_value(<replaceable class="parameter">value</replaceable> <type>any</type>, <replaceable class="parameter">nth</replaceable> <type>integer</type>)
       </function>
      </entry>
      <entry>
<!--
       <type>same type as <replaceable class="parameter">value</replaceable></type>
-->
       <type><replaceable class="parameter">value</replaceable>と同じ型</type>
      </entry>
      <entry>
<!--
       returns <replaceable class="parameter">value</replaceable> evaluated
       at the row that is the <replaceable class="parameter">nth</replaceable>
       row of the window frame (counting from 1); null if no such row
-->
       ウィンドウフレームの（１から数えて）<replaceable class="parameter">nth</replaceable>番目の行である行で評価された<replaceable class="parameter">value</replaceable>を返す。行が存在しない場合はNULLを返す
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
<!--
   All of the functions listed in
   <xref linkend="functions-window-table"/> depend on the sort ordering
   specified by the <literal>ORDER BY</literal> clause of the associated window
   definition.  Rows that are not distinct when considering only the
   <literal>ORDER BY</literal> columns are said to be <firstterm>peers</firstterm>.
   The four ranking functions (including <function>cume_dist</function>) are
   defined so that they give the same answer for all peer rows.
-->
<xref linkend="functions-window-table"/>に列挙された関数はすべて、対応するウィンドウ定義の<literal>ORDER BY</literal>句で指定されるソート順に依存します。
<literal>ORDER BY</literal>の列だけを考慮した場合に重複する行は<firstterm>ピア</firstterm>と呼ばれます。
4つの順位付け関数（<function>cume_dist</function>を含む）は、すべてのピア行に対して同じ答えになるように定義されています。
  </para>

  <para>
<!--
   Note that <function>first_value</function>, <function>last_value</function>, and
   <function>nth_value</function> consider only the rows within the <quote>window
   frame</quote>, which by default contains the rows from the start of the
   partition through the last peer of the current row.  This is
   likely to give unhelpful results for <function>last_value</function> and
   sometimes also <function>nth_value</function>.  You can redefine the frame by
   adding a suitable frame specification (<literal>RANGE</literal>,
   <literal>ROWS</literal> or <literal>GROUPS</literal>) to
   the <literal>OVER</literal> clause.
   See <xref linkend="syntax-window-functions"/> for more information
   about frame specifications.
-->
<function>first_value</function>、<function>last_value</function>、<function>nth_value</function>関数は<quote>ウィンドウフレーム</quote>内の行のみを考慮することに注意してください。
デフォルトで、ウィンドウフレームにはパーティションの先頭から現在の行の最終ピアまでの行が含まれます。
これは<function>last_value</function>、または時々<function>nth_value</function>では有用ではない結果を得ることになりがちです。
<literal>OVER</literal>句に適切なフレーム指定(<literal>RANGE</literal>、<literal>GROUP</literal>、もしくは<literal>ROWS</literal>)を加えることで、フレームを再定義することができます。
フレーム指定についての詳細は<xref linkend="syntax-window-functions"/>を参照してください。
  </para>

  <para>
<!--
   When an aggregate function is used as a window function, it aggregates
   over the rows within the current row's window frame.
   An aggregate used with <literal>ORDER BY</literal> and the default window frame
   definition produces a <quote>running sum</quote> type of behavior, which may or
   may not be what's wanted.  To obtain
   aggregation over the whole partition, omit <literal>ORDER BY</literal> or use
   <literal>ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING</literal>.
   Other frame specifications can be used to obtain other effects.
-->
集約関数をウィンドウ関数として使用する場合、現在の行のウィンドウフレーム内の行に渡って集約処理を行います。
<literal>ORDER BY</literal>および、デフォルトのウィンドウフレーム定義を使用した集約では、<quote>中間和</quote>のような動作を行います。これが望まれる場合もあれば、望まれない場合もあります。
パーティション全体に渡る集約処理を行うためには、<literal>ORDER BY</literal>を省略するか<literal>ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING</literal>を使用してください。
他のフレーム指定を使用することで様々な結果を得ることができます。
  </para>

  <note>
   <para>
<!--
    The SQL standard defines a <literal>RESPECT NULLS</literal> or
    <literal>IGNORE NULLS</literal> option for <function>lead</function>, <function>lag</function>,
    <function>first_value</function>, <function>last_value</function>, and
    <function>nth_value</function>.  This is not implemented in
    <productname>PostgreSQL</productname>: the behavior is always the
    same as the standard's default, namely <literal>RESPECT NULLS</literal>.
    Likewise, the standard's <literal>FROM FIRST</literal> or <literal>FROM LAST</literal>
    option for <function>nth_value</function> is not implemented: only the
    default <literal>FROM FIRST</literal> behavior is supported.  (You can achieve
    the result of <literal>FROM LAST</literal> by reversing the <literal>ORDER BY</literal>
    ordering.)
-->
SQL標準は、<function>lead</function>、<function>lag</function>、<function>first_value</function>、<function>last_value</function>、および<function>nth_value</function>に対し<literal>RESPECT NULLS</literal>、または<literal>IGNORE NULLS</literal>オプションを定義します。
これは<productname>PostgreSQL</productname>に実装されていません。動作は常に標準のデフォルトと同一です。つまり、<literal>RESPECT NULLS</literal>です。同様にして、標準の<function>nth_value</function>に対する<literal>FROM FIRST</literal>、または<literal>FROM LAST</literal>オプションは実装されていません。デフォルトの<literal>FROM FIRST</literal>動作のみに対応しています。
（<literal>ORDER BY</literal>順序付けを逆に行うことで、<literal>FROM LAST</literal>の結果を得ることができます。）
   </para>
  </note>

  <para>
<!--
   <function>cume_dist</function> computes the fraction of partition rows that
   are less than or equal to the current row and its peers, while
   <function>percent_rank</function> computes the fraction of partition rows that
   are less than the current row, assuming the current row does not exist
   in the partition.
-->
<function>cume_dist</function>が現在行およびそのピアより小さいか等しいパーティション行の割合を計算するのに対し、<function>percent_rank</function>は現在行がそのパーティション内にないものとして、現在行より小さいパーティション行の割合を計算します。
  </para>

 </sect1>

<!-- split-func3-end -->
<!-- split-func4-start -->

 <sect1 id="functions-subquery">
<!--
  <title>Subquery Expressions</title>
-->
  <title>副問い合わせ式</title>

  <indexterm>
   <primary>EXISTS</primary>
  </indexterm>

  <indexterm>
   <primary>IN</primary>
  </indexterm>

  <indexterm>
   <primary>NOT IN</primary>
  </indexterm>

  <indexterm>
   <primary>ANY</primary>
  </indexterm>

  <indexterm>
   <primary>ALL</primary>
  </indexterm>

  <indexterm>
   <primary>SOME</primary>
  </indexterm>

  <indexterm>
   <primary>subquery</primary>
  </indexterm>

  <para>
<!--
   This section describes the <acronym>SQL</acronym>-compliant subquery
   expressions available in <productname>PostgreSQL</productname>.
   All of the expression forms documented in this section return
   Boolean (true/false) results.
-->
本節では<productname>PostgreSQL</productname>で使用できる<acronym>SQL</acronym>準拠の副問い合わせについて説明します。
本節で記載した全ての式は結果として論理値（真/偽）を返します。
  </para>

  <sect2 id="functions-subquery-exists">
   <title><literal>EXISTS</literal></title>

<synopsis>
EXISTS (<replaceable>subquery</replaceable>)
</synopsis>

  <para>
<!--
   The argument of <token>EXISTS</token> is an arbitrary <command>SELECT</command> statement,
   or <firstterm>subquery</firstterm>.  The
   subquery is evaluated to determine whether it returns any rows.
   If it returns at least one row, the result of <token>EXISTS</token> is
   <quote>true</quote>; if the subquery returns no rows, the result of <token>EXISTS</token>
   is <quote>false</quote>.
-->
<token>EXISTS</token>の引数は、任意の<command>SELECT</command>文、つまり<firstterm>副問い合わせ</firstterm>です。
副問い合わせはそれが何らかの行を返すか否かの決定のために評価されます。
もし1つでも行を返すのであれば、<token>EXISTS</token>の結果は<quote>true（真）</quote>となり、副問い合わせが行を返さない場合、<token>EXISTS</token>の結果は<quote>false（偽）</quote>となります。
  </para>

  <para>
<!--
   The subquery can refer to variables from the surrounding query,
   which will act as constants during any one evaluation of the subquery.
-->
副問い合わせは、取り囲んでいる問い合わせから変数を参照することができ、その値は副問い合わせの評価時には定数として扱われます。
  </para>

  <para>
<!--
   The subquery will generally only be executed long enough to determine
   whether at least one row is returned, not all the way to completion.
   It is unwise to write a subquery that has side effects (such as
   calling sequence functions); whether the side effects occur
   might be unpredictable.
-->
この副問い合わせは通常、最後まで実行されず、少なくとも１つの行が返されたかどうかを判定し得るに足りる時点まで実行されます。
（シーケンス関数を呼び出すような）副作用のある副問い合わせを記述することは配慮不足です。副作用が生じるかどうかは予想できません。
  </para>

  <para>
<!--
   Since the result depends only on whether any rows are returned,
   and not on the contents of those rows, the output list of the
   subquery is normally unimportant.  A common coding convention is
   to write all <literal>EXISTS</literal> tests in the form
   <literal>EXISTS(SELECT 1 WHERE ...)</literal>.  There are exceptions to
   this rule however, such as subqueries that use <token>INTERSECT</token>.
-->
結果は何らかの行が返されるのかのみに依存し、それらの行の内容には依存しないことから、副問い合わせの出力リストは通常重要ではありません。
よく使われるコーディング規約は、全ての<literal>EXISTS</literal>テストを<literal>EXISTS(SELECT 1 WHERE ...)</literal>といった形式で記述することです。
とは言っても、<token>INTERSECT</token>を使う副問い合わせのようにこの規則には例外があります。
  </para>

  <para>
<!--
   This simple example is like an inner join on <literal>col2</literal>, but
   it produces at most one output row for each <literal>tab1</literal> row,
   even if there are several matching <literal>tab2</literal> rows:
-->
以下の簡単な例は<literal>col2</literal>上の内部結合に似ていますが、しかしたとえ<literal>tab2</literal>の行といくつか一致したとしても<literal>tab1</literal>のそれぞれの行に対して最大限１つの出力行を生成します。
<screen>
SELECT col1
FROM tab1
WHERE EXISTS (SELECT 1 FROM tab2 WHERE col2 = tab1.col2);
</screen>
  </para>
  </sect2>

  <sect2 id="functions-subquery-in">
   <title><literal>IN</literal></title>

<synopsis>
<replaceable>expression</replaceable> IN (<replaceable>subquery</replaceable>)
</synopsis>

  <para>
<!--
   The right-hand side is a parenthesized
   subquery, which must return exactly one column.  The left-hand expression
   is evaluated and compared to each row of the subquery result.
   The result of <token>IN</token> is <quote>true</quote> if any equal subquery row is found.
   The result is <quote>false</quote> if no equal row is found (including the
   case where the subquery returns no rows).
-->
右辺は括弧で括られた副問い合わせで、正確に１列を返すものでなければなりません。
左辺式は評価され、副問い合わせの結果行と比較されます。
副問い合わせの行のどれかと等しい場合、<token>IN</token>の結果は<quote>true（真）</quote>です。
（副問い合わせが行を返さない場合を含め）等しい行が見つからない場合、結果は<quote>false（偽）</quote>です。
  </para>

  <para>
<!--
   Note that if the left-hand expression yields null, or if there are
   no equal right-hand values and at least one right-hand row yields
   null, the result of the <token>IN</token> construct will be null, not false.
   This is in accordance with SQL's normal rules for Boolean combinations
   of null values.
-->
左辺の式がNULLを生じる場合、または右辺の値に等しいものがなくて少なくとも1つの右辺の行がNULLを持つ場合、<token>IN</token>構文の結果は偽ではなくNULLとなることに注意してください。
これは、NULL値の論理的な組み合わせに対するSQLの標準規則に従うものです。
  </para>

  <para>
<!--
   As with <token>EXISTS</token>, it's unwise to assume that the subquery will
   be evaluated completely.
-->
<token>EXISTS</token>と同様、副問い合わせが完全に評価されることを前提としてはなりません。
  </para>

<synopsis>
<replaceable>row_constructor</replaceable> IN (<replaceable>subquery</replaceable>)
</synopsis>

  <para>
<!--
   The left-hand side of this form of <token>IN</token> is a row constructor,
   as described in <xref linkend="sql-syntax-row-constructors"/>.
   The right-hand side is a parenthesized
   subquery, which must return exactly as many columns as there are
   expressions in the left-hand row.  The left-hand expressions are
   evaluated and compared row-wise to each row of the subquery result.
   The result of <token>IN</token> is <quote>true</quote> if any equal subquery row is found.
   The result is <quote>false</quote> if no equal row is found (including the
   case where the subquery returns no rows).
-->
<token>IN</token>のこの形式の左辺は、<xref linkend="sql-syntax-row-constructors"/>で説明する、行のコンストラクタです。
右辺は括弧で括られた副問い合わせで、左辺の行にある式の数と正確に同じ数の列を返さなければなりません。
左辺の式は副問い合わせの結果のそれぞれの行に対し、行に関して評価、比較が行われます。
副問い合わせの行に等しいものが見つかった場合、<token>IN</token> の結果は<quote>true（真）</quote>となります。
（副問い合わせが行を返さない場合を含め）等しい行が見つからない場合、結果は<quote>false（偽）</quote>です。
  </para>

  <para>
<!--
   As usual, null values in the rows are combined per
   the normal rules of SQL Boolean expressions.  Two rows are considered
   equal if all their corresponding members are non-null and equal; the rows
   are unequal if any corresponding members are non-null and unequal;
   otherwise the result of that row comparison is unknown (null).
   If all the per-row results are either unequal or null, with at least one
   null, then the result of <token>IN</token> is null.
-->
通常通り、行にあるNULL値はSQLの論理式の標準規則で結合されます。
２つの行は対応する全ての構成要素が非NULLかつ等しい場合に等しいとみなされます。
１つでも対応する構成要素が非NULLかつ等しくないものがあれば、２つの行は等しくないとみなされます。
それ以外の場合、その行の比較結果は不明（NULL）です。
行毎の結果すべてが不等もしくはNULLの場合、少なくとも１つのNULLがあると、<token>IN</token>の結果はNULLとなります。
  </para>
  </sect2>

  <sect2 id="functions-subquery-notin">
   <title><literal>NOT IN</literal></title>

<synopsis>
<replaceable>expression</replaceable> NOT IN (<replaceable>subquery</replaceable>)
</synopsis>

  <para>
<!--
   The right-hand side is a parenthesized
   subquery, which must return exactly one column.  The left-hand expression
   is evaluated and compared to each row of the subquery result.
   The result of <token>NOT IN</token> is <quote>true</quote> if only unequal subquery rows
   are found (including the case where the subquery returns no rows).
   The result is <quote>false</quote> if any equal row is found.
-->
右辺は括弧で括られた副問い合わせで、正確に１つの列を返さなければなりません。
左辺の式は副問い合わせ結果の行それぞれに対して評価、比較されます。
等しくない副問い合わせの行だけがある（副問い合わせが行を返さない場合を含む）と、<token>NOT IN</token>の結果は<quote>true（真）</quote>です。
等しい行が1つでもあれば、結果は<quote>false（偽）</quote>です。
  </para>

  <para>
<!--
   Note that if the left-hand expression yields null, or if there are
   no equal right-hand values and at least one right-hand row yields
   null, the result of the <token>NOT IN</token> construct will be null, not true.
   This is in accordance with SQL's normal rules for Boolean combinations
   of null values.
-->
左辺の式でNULLが生じる場合、または右辺の値に等しいものがなく、少なくとも１つの右辺の式がNULLを生み出す場合、<token>NOT IN</token>構文の結果は真ではなくNULLとなることに注意してください。
これは、NULL値の論理的な組み合わせに対するSQLの標準規則に従うものです。
  </para>

  <para>
<!--
   As with <token>EXISTS</token>, it's unwise to assume that the subquery will
   be evaluated completely.
-->
<token>EXISTS</token>と同様、副問い合わせが完全に評価されることを前提としてはなりません。
  </para>

<synopsis>
<replaceable>row_constructor</replaceable> NOT IN (<replaceable>subquery</replaceable>)
</synopsis>

  <para>
<!--
   The left-hand side of this form of <token>NOT IN</token> is a row constructor,
   as described in <xref linkend="sql-syntax-row-constructors"/>.
   The right-hand side is a parenthesized
   subquery, which must return exactly as many columns as there are
   expressions in the left-hand row.  The left-hand expressions are
   evaluated and compared row-wise to each row of the subquery result.
   The result of <token>NOT IN</token> is <quote>true</quote> if only unequal subquery rows
   are found (including the case where the subquery returns no rows).
   The result is <quote>false</quote> if any equal row is found.
-->
<token>NOT IN</token>のこの形式の左辺は、<xref linkend="sql-syntax-row-constructors"/>で説明する行コンストラクタです。
右辺は括弧で括られた副問い合わせで、左辺の行にある式の数と正確に同じ数の列を返さなければなりません。
左辺の式は副問い合わせの結果のそれぞれの行に対し、評価、比較が行われます。
副問い合わせの行に不等のもののみが見つかった場合（副問い合わせが行を返さない場合を含む）、<token>NOT IN</token>の結果は<quote>true（真）</quote>となります。
等しい行が１つでも見つかった場合、結果は<quote>false（偽）</quote>です。
  </para>

  <para>
<!--
   As usual, null values in the rows are combined per
   the normal rules of SQL Boolean expressions.  Two rows are considered
   equal if all their corresponding members are non-null and equal; the rows
   are unequal if any corresponding members are non-null and unequal;
   otherwise the result of that row comparison is unknown (null).
   If all the per-row results are either unequal or null, with at least one
   null, then the result of <token>NOT IN</token> is null.
-->
通常通り、行にあるNULL値はSQLの論理式の標準規則で結合されます。
2つの行は対応する全ての構成要素が非NULLかつ等しい場合に等しいとみなされます。
１つでも構成要素が非NULLかつ等しくない場合、２つの行は等しくないとみなされます。
それ以外の場合、その行の比較結果は不明（NULL）です。
行毎の結果すべてが不等もしくはNULLの場合、少なくとも1つのNULLがあると、<token>NOT IN</token>の結果はNULLとなります。
  </para>
  </sect2>

  <sect2 id="functions-subquery-any-some">
   <title><literal>ANY</literal>/<literal>SOME</literal></title>

<synopsis>
<replaceable>expression</replaceable> <replaceable>operator</replaceable> ANY (<replaceable>subquery</replaceable>)
<replaceable>expression</replaceable> <replaceable>operator</replaceable> SOME (<replaceable>subquery</replaceable>)
</synopsis>

  <para>
<!--
   The right-hand side is a parenthesized
   subquery, which must return exactly one column.  The left-hand expression
   is evaluated and compared to each row of the subquery result using the
   given <replaceable>operator</replaceable>, which must yield a Boolean
   result.
   The result of <token>ANY</token> is <quote>true</quote> if any true result is obtained.
   The result is <quote>false</quote> if no true result is found (including the
   case where the subquery returns no rows).
-->
右辺は括弧で括られた副問い合わせで、正確に1つの列を返さなければなりません。
左辺の式は副問い合わせの結果行それぞれに対して、指定された<replaceable>operator</replaceable>を使用して評価、比較されます。なお、<replaceable>operator</replaceable>は結果として論理値を生成する必要があります。
真の結果が１つでもあると、<token>ANY</token>の結果は<quote>true（真）</quote>です。
真の結果がない（副問い合わせが行を返さない場合を含む）と、結果は<quote>false（偽）</quote>です。
  </para>

  <para>
<!--
   <token>SOME</token> is a synonym for <token>ANY</token>.
   <token>IN</token> is equivalent to <literal>= ANY</literal>.
-->
<token>SOME</token>は<token>ANY</token>の同義語です。
<token>IN</token>は<literal>= ANY</literal>と等価です。
  </para>

  <para>
<!--
   Note that if there are no successes and at least one right-hand row yields
   null for the operator's result, the result of the <token>ANY</token> construct
   will be null, not false.
   This is in accordance with SQL's normal rules for Boolean combinations
   of null values.
-->
成功がなく、右辺の行が演算子の結果として１つでもNULLを生成した場合、<token>ANY</token>構文の結果は偽ではなくNULLになることに注意してください。
これは、NULL値の論理的な組み合わせに対するSQLの標準規則に従うものです。
  </para>

  <para>
<!--
   As with <token>EXISTS</token>, it's unwise to assume that the subquery will
   be evaluated completely.
-->
<token>EXISTS</token>と同様、副問い合わせが完全に評価されると前提してはなりません。
  </para>

<synopsis>
<replaceable>row_constructor</replaceable> <replaceable>operator</replaceable> ANY (<replaceable>subquery</replaceable>)
<replaceable>row_constructor</replaceable> <replaceable>operator</replaceable> SOME (<replaceable>subquery</replaceable>)
</synopsis>

  <para>
<!--
   The left-hand side of this form of <token>ANY</token> is a row constructor,
   as described in <xref linkend="sql-syntax-row-constructors"/>.
   The right-hand side is a parenthesized
   subquery, which must return exactly as many columns as there are
   expressions in the left-hand row.  The left-hand expressions are
   evaluated and compared row-wise to each row of the subquery result,
   using the given <replaceable>operator</replaceable>.
   The result of <token>ANY</token> is <quote>true</quote> if the comparison
   returns true for any subquery row.
   The result is <quote>false</quote> if the comparison returns false for every
   subquery row (including the case where the subquery returns no
   rows).
   The result is NULL if no comparison with a subquery row returns true,
   and at least one comparison returns NULL.
-->
<token>ANY</token>のこの形式の左辺は、<xref linkend="sql-syntax-row-constructors"/>で説明されている行コンストラクタです。
右辺は括弧で括られた副問い合わせで、左辺の行にある式の数と正確に同じ数の列を返さなければなりません。
左辺の式は副問い合わせの結果のそれぞれの行に対し、与えられた<replaceable>operator</replaceable>を使用して行に関する評価、比較が行われます。
比較の結果、副問い合わせの行のどれかに対して真となる場合、<token>ANY</token>の結果は<quote>true（真）</quote>です。
比較の結果、副問い合わせの全ての行に対して偽となる場合（副問い合わせが行を返さないという場合も含む）、結果は<quote>false（偽）</quote>です。
いかなる副問合せ行との比較の結果も偽を返さず、かつ、少なくとも１つの比較がNULLを返す場合、結果はNULLになります。
  </para>

  <para>
<!--
   See <xref linkend="row-wise-comparison"/> for details about the meaning
   of a row constructor comparison.
-->
行コンストラクタ比較の意味についての詳細は<xref linkend="row-wise-comparison"/>を参照して下さい。
  </para>
  </sect2>

  <sect2 id="functions-subquery-all">
   <title><literal>ALL</literal></title>

<synopsis>
<replaceable>expression</replaceable> <replaceable>operator</replaceable> ALL (<replaceable>subquery</replaceable>)
</synopsis>

  <para>
<!--
   The right-hand side is a parenthesized
   subquery, which must return exactly one column.  The left-hand expression
   is evaluated and compared to each row of the subquery result using the
   given <replaceable>operator</replaceable>, which must yield a Boolean
   result.
   The result of <token>ALL</token> is <quote>true</quote> if all rows yield true
   (including the case where the subquery returns no rows).
   The result is <quote>false</quote> if any false result is found.
   The result is NULL if no comparison with a subquery row returns false,
   and at least one comparison returns NULL.
-->
右辺は括弧で括られた副問い合わせで、正確に１つの列を返さなければなりません。
左辺の式は副問い合わせの結果行それぞれに対して、指定された<replaceable>operator</replaceable>を使用して評価、比較されます。なお、<replaceable>operator</replaceable>は結果として論理値を生成する必要があります。
全ての行が真になる場合（副問い合わせが行を返さない場合を含む）、<token>ALL</token>の結果は<quote>true（真）</quote>です。
1つでも偽の結果があると、結果は<quote>false（偽）</quote>です。
比較がどの行でも偽を返さず、かつ、少なくとも1つの行でNULLを返した場合、結果はNULLとなります。
  </para>

  <para>
<!--
   <token>NOT IN</token> is equivalent to <literal>&lt;&gt; ALL</literal>.
-->
   <token>NOT IN</token>は<literal>&lt;&gt; ALL</literal>と等価です。
  </para>

  <para>
<!--
   As with <token>EXISTS</token>, it's unwise to assume that the subquery will
   be evaluated completely.
-->
<token>EXISTS</token>と同様、副問い合わせが完全に評価されることを前提としてはなりません。
  </para>

<synopsis>
<replaceable>row_constructor</replaceable> <replaceable>operator</replaceable> ALL (<replaceable>subquery</replaceable>)
</synopsis>

  <para>
<!--
   The left-hand side of this form of <token>ALL</token> is a row constructor,
   as described in <xref linkend="sql-syntax-row-constructors"/>.
   The right-hand side is a parenthesized
   subquery, which must return exactly as many columns as there are
   expressions in the left-hand row.  The left-hand expressions are
   evaluated and compared row-wise to each row of the subquery result,
   using the given <replaceable>operator</replaceable>.
   The result of <token>ALL</token> is <quote>true</quote> if the comparison
   returns true for all subquery rows (including the
   case where the subquery returns no rows).
   The result is <quote>false</quote> if the comparison returns false for any
   subquery row.
   The result is NULL if no comparison with a subquery row returns false,
   and at least one comparison returns NULL.
-->
<token>ALL</token>のこの形式の左辺は、<xref linkend="sql-syntax-row-constructors"/>で説明する行コンストラクタです。
右辺は括弧で括られた副問い合わせで、左辺の行にある式の数と正確に同じ数の列を返さなければなりません。
左辺の式は副問い合わせの結果のそれぞれの行に対し、与えられた<replaceable>operator</replaceable>を使用して行に関する評価、比較が行われます。
比較した結果、すべての副問い合わせ行に対して真を返す場合（副問い合わせが行を返さないという場合も含む）、<token>ALL</token>の結果は<quote>true（真）</quote>となります。
比較した結果、いずれかの副問い合わせ行で偽を返す場合、この結果は<quote>false（偽）</quote>となります。
比較結果がすべての副問い合わせ行に対して偽を返さず、少なくとも１行でNULLを返す場合、結果はNULLとなります。
  </para>

  <para>
<!--
   See <xref linkend="row-wise-comparison"/> for details about the meaning
   of a row constructor comparison.
-->
行コンストラクタに関する比較の意味については<xref linkend="row-wise-comparison"/>を参照してください。
  </para>
  </sect2>

  <sect2>
<!--
   <title>Single-Row Comparison</title>
-->
   <title>単独行に関する比較</title>

   <indexterm zone="functions-subquery">
<!--
    <primary>comparison</primary>
-->
    <primary>比較</primary>
<!--
    <secondary>subquery result row</secondary>
-->
    <secondary>副問い合わせ結果行</secondary>
   </indexterm>

<synopsis>
<replaceable>row_constructor</replaceable> <replaceable>operator</replaceable> (<replaceable>subquery</replaceable>)
</synopsis>

  <para>
<!--
   The left-hand side is a row constructor,
   as described in <xref linkend="sql-syntax-row-constructors"/>.
   The right-hand side is a parenthesized subquery, which must return exactly
   as many columns as there are expressions in the left-hand row. Furthermore,
   the subquery cannot return more than one row.  (If it returns zero rows,
   the result is taken to be null.)  The left-hand side is evaluated and
   compared row-wise to the single subquery result row.
-->
左辺は、<xref linkend="sql-syntax-row-constructors"/>で説明されている行コンストラクタです。
右辺は括弧で括られた副問い合わせで、左辺の行とまったく同じ数の列を返さなければなりません。さらに、副問い合わせは複数行を返すことはできません。
（行をまったく返さない場合、結果はNULLとみなされます。）
左辺は副問い合わせの結果の単一行に対し行全体で評価、比較が行われます。
  </para>

  <para>
<!--
   See <xref linkend="row-wise-comparison"/> for details about the meaning
   of a row constructor comparison.
-->
行コンストラクタに関する比較の意味についての詳細は<xref linkend="row-wise-comparison"/>を参照してください。
  </para>
  </sect2>
 </sect1>


 <sect1 id="functions-comparisons">
<!--
  <title>Row and Array Comparisons</title>
-->
  <title>行と配列の比較</title>

  <indexterm>
   <primary>IN</primary>
  </indexterm>

  <indexterm>
   <primary>NOT IN</primary>
  </indexterm>

  <indexterm>
   <primary>ANY</primary>
  </indexterm>

  <indexterm>
   <primary>ALL</primary>
  </indexterm>

  <indexterm>
   <primary>SOME</primary>
  </indexterm>

  <indexterm>
<!--
   <primary>composite type</primary>
   <secondary>comparison</secondary>
-->
   <primary>複合型</primary>
   <secondary>比較</secondary>
  </indexterm>

  <indexterm>
<!--
   <primary>row-wise comparison</primary>
-->
   <primary>行に関する比較</primary>
  </indexterm>

  <indexterm>
<!--
   <primary>comparison</primary>
   <secondary>composite type</secondary>
-->
   <primary>比較</primary>
   <secondary>複合型</secondary>
  </indexterm>

  <indexterm>
<!--
   <primary>comparison</primary>
   <secondary>row constructor</secondary>
-->
   <primary>比較</primary>
   <secondary>行コンストラクタ</secondary>
  </indexterm>

  <indexterm>
   <primary>IS DISTINCT FROM</primary>
  </indexterm>

  <indexterm>
   <primary>IS NOT DISTINCT FROM</primary>
  </indexterm>

  <para>
<!--
   This section describes several specialized constructs for making
   multiple comparisons between groups of values.  These forms are
   syntactically related to the subquery forms of the previous section,
   but do not involve subqueries.
   The forms involving array subexpressions are
   <productname>PostgreSQL</productname> extensions; the rest are
   <acronym>SQL</acronym>-compliant.
   All of the expression forms documented in this section return
   Boolean (true/false) results.
-->
本節では、値のグループ間で複数の比較を行う、さまざまな特殊化したコンストラクトについて説明します。
この形式は構文的には、前節の副問い合わせ形式と関係しています。しかし、副問い合わせを含みません。
配列副式を含む形式は<productname>PostgreSQL</productname>の拡張ですが、それ以外は<acronym>SQL</acronym>準拠です。
本節で記載した全ての式形式は結果として論理値（真/偽）を返します。
  </para>

  <sect2 id="functions-comparisons-in-scalar">
   <title><literal>IN</literal></title>

<synopsis>
<replaceable>expression</replaceable> IN (<replaceable>value</replaceable> <optional>, ...</optional>)
</synopsis>

  <para>
<!--
   The right-hand side is a parenthesized list
   of scalar expressions.  The result is <quote>true</quote> if the left-hand expression's
   result is equal to any of the right-hand expressions.  This is a shorthand
   notation for
-->
右辺は括弧で括られたスカラ式のリストです。
左辺の式の結果が右辺の式のいずれかと等しい場合、結果は<quote>true（真）</quote>になります。
これは以下の省略形です。

<synopsis>
<replaceable>expression</replaceable> = <replaceable>value1</replaceable>
OR
<replaceable>expression</replaceable> = <replaceable>value2</replaceable>
OR
...
</synopsis>
  </para>

  <para>
<!--
   Note that if the left-hand expression yields null, or if there are
   no equal right-hand values and at least one right-hand expression yields
   null, the result of the <token>IN</token> construct will be null, not false.
   This is in accordance with SQL's normal rules for Boolean combinations
   of null values.
-->
左辺の式がNULLを生じる場合、または右側の値に等しいものがなくて少なくとも1つの右辺の行がNULLを持つ場合、<token>IN</token>構文の結果は偽ではなくNULLとなることに注意してください。
これは、NULL値の論理的な組み合わせに対するSQLの標準規則に従うものです。
  </para>
  </sect2>

  <sect2>
   <title><literal>NOT IN</literal></title>

<synopsis>
<replaceable>expression</replaceable> NOT IN (<replaceable>value</replaceable> <optional>, ...</optional>)
</synopsis>

  <para>
<!--
   The right-hand side is a parenthesized list
   of scalar expressions.  The result is <quote>true</quote> if the left-hand expression's
   result is unequal to all of the right-hand expressions.  This is a shorthand
   notation for
-->
右辺は括弧で括られたスカラ式のリストです。
左辺の式の結果が右辺の式の全てと等しくない場合、結果は<quote>真</quote>です。
これは以下の省略形です。

<synopsis>
<replaceable>expression</replaceable> &lt;&gt; <replaceable>value1</replaceable>
AND
<replaceable>expression</replaceable> &lt;&gt; <replaceable>value2</replaceable>
AND
...
</synopsis>
  </para>

  <para>
<!--
   Note that if the left-hand expression yields null, or if there are
   no equal right-hand values and at least one right-hand expression yields
   null, the result of the <token>NOT IN</token> construct will be null, not true
   as one might naively expect.
   This is in accordance with SQL's normal rules for Boolean combinations
   of null values.
-->
左辺の式でNULLが生じる場合、または右辺の値に左辺の式と等しいものがなく、かつ少なくとも1つの右辺の式がNULLを生じる場合、<token>NOT IN</token>構文の結果は、一部の人が予想する真ではなく、NULLとなることに注意してください。
これは、NULL値の論理的な組み合わせに対するSQLの標準規則に従うものです。
  </para>

  <tip>
  <para>
<!--
   <literal>x NOT IN y</literal> is equivalent to <literal>NOT (x IN y)</literal> in all
   cases.  However, null values are much more likely to trip up the novice when
   working with <token>NOT IN</token> than when working with <token>IN</token>.
   It is best to express your condition positively if possible.
-->
全ての場合において、<literal>x NOT IN y</literal>は<literal>NOT (x IN y)</literal>と等価です。
しかし、<token>IN</token>を使用するよりも<token>NOT IN</token>を使用する方が初心者がNULL値による間違いをしやすくなります。
可能な限り条件を肯定的に表現することが最善です。
  </para>
  </tip>
  </sect2>

  <sect2>
<!--
   <title><literal>ANY</literal>/<literal>SOME</literal> (array)</title>
-->
   <title><literal>ANY</literal>/<literal>SOME</literal> (配列)</title>

<synopsis>
<replaceable>expression</replaceable> <replaceable>operator</replaceable> ANY (<replaceable>array expression</replaceable>)
<replaceable>expression</replaceable> <replaceable>operator</replaceable> SOME (<replaceable>array expression</replaceable>)
</synopsis>

  <para>
<!--
   The right-hand side is a parenthesized expression, which must yield an
   array value.
   The left-hand expression
   is evaluated and compared to each element of the array using the
   given <replaceable>operator</replaceable>, which must yield a Boolean
   result.
   The result of <token>ANY</token> is <quote>true</quote> if any true result is obtained.
   The result is <quote>false</quote> if no true result is found (including the
   case where the array has zero elements).
-->
右辺は括弧で括られた式で、配列値を返さなければなりません。
左辺の式は配列要素それぞれに対して、指定された<replaceable>operator</replaceable>を使用して評価、比較されます。なお、<replaceable>operator</replaceable>は結果として論理値を生成する必要があります。
真の結果が１つでもあると、<token>ANY</token>の結果は<quote>true（真）</quote>です。
真の結果がない（配列の要素数がゼロである場合を含む）と、結果は<quote>false（偽）</quote>です。
  </para>

  <para>
<!--
   If the array expression yields a null array, the result of
   <token>ANY</token> will be null.  If the left-hand expression yields null,
   the result of <token>ANY</token> is ordinarily null (though a non-strict
   comparison operator could possibly yield a different result).
   Also, if the right-hand array contains any null elements and no true
   comparison result is obtained, the result of <token>ANY</token>
   will be null, not false (again, assuming a strict comparison operator).
   This is in accordance with SQL's normal rules for Boolean combinations
   of null values.
-->
配列式がNULL配列を生成する場合、<token>ANY</token>の結果はNULLになります。
左辺式がNULLとなる場合、<token>ANY</token>の結果は通常NULLになります（STRICTでない比較演算子では異なる結果になるかもしれません）。
また、右辺の配列にNULL要素が含まれ、かつ、比較の結果、真が得られなかった場合、<token>ANY</token>の結果は偽ではなくNULLになります（ここでも、STRICTな演算子の場合です）。
これは、NULLに対する、SQLの論理値組み合わせに関する標準規則に従うものです。
  </para>

  <para>
<!--
   <token>SOME</token> is a synonym for <token>ANY</token>.
-->
<token>SOME</token>は<token>ANY</token>の同義語です。
  </para>
  </sect2>

  <sect2>
<!--
   <title><literal>ALL</literal> (array)</title>
-->
   <title><literal>ALL</literal> (配列)</title>

<synopsis>
<replaceable>expression</replaceable> <replaceable>operator</replaceable> ALL (<replaceable>array expression</replaceable>)
</synopsis>

  <para>
<!--
   The right-hand side is a parenthesized expression, which must yield an
   array value.
   The left-hand expression
   is evaluated and compared to each element of the array using the
   given <replaceable>operator</replaceable>, which must yield a Boolean
   result.
   The result of <token>ALL</token> is <quote>true</quote> if all comparisons yield true
   (including the case where the array has zero elements).
   The result is <quote>false</quote> if any false result is found.
-->
右辺は括弧で括られた式で、配列値を返さなければなりません。
左辺の式は配列の要素それぞれに対して、指定された<replaceable>operator</replaceable>を使用して評価、比較されます。なお、<replaceable>operator</replaceable>は結果として論理値を生成する必要があります。
全ての比較が真になる場合（配列の要素数がゼロである場合を含む）、<token>ALL</token>の結果は<quote>true（真）</quote>です。
1つでも偽の結果があると、結果は<quote>false（偽）</quote>です。
  </para>

  <para>
<!--
   If the array expression yields a null array, the result of
   <token>ALL</token> will be null.  If the left-hand expression yields null,
   the result of <token>ALL</token> is ordinarily null (though a non-strict
   comparison operator could possibly yield a different result).
   Also, if the right-hand array contains any null elements and no false
   comparison result is obtained, the result of <token>ALL</token>
   will be null, not true (again, assuming a strict comparison operator).
   This is in accordance with SQL's normal rules for Boolean combinations
   of null values.
-->
配列式がNULL配列を生成する場合、<token>ALL</token>の結果はNULLになります。
左辺式がNULLとなる場合、<token>ALL</token>の結果は通常NULLになります（厳格でない比較演算子では異なる結果になるかもしれません）。
また、右辺の配列にNULL要素が含まれ、かつ、比較の結果、偽が得られなかった場合、<token>ALL</token>の結果は真ではなくNULLになります（ここでも、厳格な演算子の場合です）。
これは、NULLに対する、SQLの論理値組み合わせに関する標準規則に従うものです。
  </para>
  </sect2>

  <sect2 id="row-wise-comparison">
<!--
   <title>Row Constructor Comparison</title>
-->
   <title>行コンストラクタの比較</title>

<synopsis>
<replaceable>row_constructor</replaceable> <replaceable>operator</replaceable> <replaceable>row_constructor</replaceable>
</synopsis>

  <para>
<!--
   Each side is a row constructor,
   as described in <xref linkend="sql-syntax-row-constructors"/>.
   The two row values must have the same number of fields.
   Each side is evaluated and they are compared row-wise.  Row constructor
   comparisons are allowed when the <replaceable>operator</replaceable> is
   <literal>=</literal>,
   <literal>&lt;&gt;</literal>,
   <literal>&lt;</literal>,
   <literal>&lt;=</literal>,
   <literal>&gt;</literal> or
   <literal>&gt;=</literal>.
   Every row element must be of a type which has a default B-tree operator
   class or the attempted comparison may generate an error.
-->
両辺とも<xref linkend="sql-syntax-row-constructors"/>で説明する行コンストラクタです。
この２つの行値は同じフィールド数でなければなりません。
両辺はそれぞれ評価され、行として比較されます。
行コンストラクタの比較は、<replaceable>operator</replaceable>が<literal>=</literal>、<literal>&lt;&gt;</literal>、<literal>&lt;</literal>、<literal>&lt;=</literal>、<literal>&gt;</literal>、<literal>&gt;=</literal>の場合に認められます。
各行の要素はデフォルトのB-tree演算子クラスを持つ型でなければなりません。そうでなければ、比較を試みるとエラーが発生します。
  </para>

  <note>
   <para>
<!--
    Errors related to the number or types of elements might not occur if
    the comparison is resolved using earlier columns.
-->
比較が先行する列で解決された場合、要素の数や型に関係するエラーは起きないこともあります。
   </para>
  </note>

  <para>
<!--
   The <literal>=</literal> and <literal>&lt;&gt;</literal> cases work slightly differently
   from the others.  Two rows are considered
   equal if all their corresponding members are non-null and equal; the rows
   are unequal if any corresponding members are non-null and unequal;
   otherwise the result of the row comparison is unknown (null).
-->
<literal>=</literal>と<literal>&lt;&gt;</literal>の場合、他と動作が多少異なります。
2つの行は対応する全ての構成要素が非NULLかつ等しい場合に等しいとみなされます。
１つでも構成要素が非NULLかつ等しくない場合、2つの行は等しくないとみなされます。
それ以外の場合、その行の比較結果は不明（NULL）です。
  </para>

  <para>
<!--
   For the <literal>&lt;</literal>, <literal>&lt;=</literal>, <literal>&gt;</literal> and
   <literal>&gt;=</literal> cases, the row elements are compared left-to-right,
   stopping as soon as an unequal or null pair of elements is found.
   If either of this pair of elements is null, the result of the
   row comparison is unknown (null); otherwise comparison of this pair
   of elements determines the result.  For example,
   <literal>ROW(1,2,NULL) &lt; ROW(1,3,0)</literal>
   yields true, not null, because the third pair of elements are not
   considered.
-->
<literal>&lt;</literal>、<literal>&lt;=</literal>、<literal>&gt;</literal>、<literal>&gt;=</literal>の場合、行の要素は左から右に比較されます。そして、不等またはNULLの組み合わせが見つかったところで停止します。
要素の組み合わせのどちらかがNULLであった場合、行比較の結果は不明（NULL）です。さもなくば、要素の組み合わせの比較により結果が決まります。
例えば、<literal>ROW(1,2,NULL) &lt; ROW(1,3,0)</literal>は、３番目の要素の組み合わせまで進まないため、NULLではなく真を返します。
  </para>

  <note>
   <para>
<!--
    Prior to <productname>PostgreSQL</productname> 8.2, the
    <literal>&lt;</literal>, <literal>&lt;=</literal>, <literal>&gt;</literal> and <literal>&gt;=</literal>
    cases were not handled per SQL specification.  A comparison like
    <literal>ROW(a,b) &lt; ROW(c,d)</literal>
    was implemented as
    <literal>a &lt; c AND b &lt; d</literal>
    whereas the correct behavior is equivalent to
    <literal>a &lt; c OR (a = c AND b &lt; d)</literal>.
-->
<productname>PostgreSQL</productname>の8.2より前では、<literal>&lt;</literal>、<literal>&lt;=</literal>、<literal>&gt;</literal> 、<literal>&gt;=</literal>の場合SQL仕様に従っていませんでした。
<literal>ROW(a,b) &lt; ROW(c,d)</literal>などの比較は正しくは<literal>a &lt; c OR (a = c AND b &lt; d)</literal>ですが、<literal>a &lt; c AND b &lt; d</literal>として実装されていました。
   </para>
  </note>

<synopsis>
<replaceable>row_constructor</replaceable> IS DISTINCT FROM <replaceable>row_constructor</replaceable>
</synopsis>

  <para>
<!--
   This construct is similar to a <literal>&lt;&gt;</literal> row comparison,
   but it does not yield null for null inputs.  Instead, any null value is
   considered unequal to (distinct from) any non-null value, and any two
   nulls are considered equal (not distinct).  Thus the result will
   either be true or false, never null.
-->
このコンストラクトは<literal>&lt;&gt;</literal>行比較と類似していますが、NULL入力に対してNULLを生成しない点が異なります。
その代わりに、全てのNULL値は非NULL値と等しくない（DISTINCT FROM）ものとみなされ、また、２つのNULLは等しい（NOT DISTINCT）ものとみなされます。
したがって、結果は真か偽のいずれかで、NULLにはなりません。
  </para>

<synopsis>
<replaceable>row_constructor</replaceable> IS NOT DISTINCT FROM <replaceable>row_constructor</replaceable>
</synopsis>

  <para>
<!--
   This construct is similar to a <literal>=</literal> row comparison,
   but it does not yield null for null inputs.  Instead, any null value is
   considered unequal to (distinct from) any non-null value, and any two
   nulls are considered equal (not distinct).  Thus the result will always
   be either true or false, never null.
-->
このコンストラクトは<literal>=</literal>行比較と類似していますが、NULL入力に対してNULLを生成しません。
代わりに、NULL値を、すべての非NULLの値に対して不等（DISTINCT FROM）とみなし、２つのNULLを等しいもの（NOT DISTINCT）とみなします。
したがって、結果は常に真か偽となり、NULLになることはありません
  </para>

  </sect2>

  <sect2 id="composite-type-comparison">
<!--
   <title>Composite Type Comparison</title>
-->
   <title>複合型の比較</title>

<synopsis>
<replaceable>record</replaceable> <replaceable>operator</replaceable> <replaceable>record</replaceable>
</synopsis>

  <para>
<!--
   The SQL specification requires row-wise comparison to return NULL if the
   result depends on comparing two NULL values or a NULL and a non-NULL.
   <productname>PostgreSQL</productname> does this only when comparing the
   results of two row constructors (as in
   <xref linkend="row-wise-comparison"/>) or comparing a row constructor
   to the output of a subquery (as in <xref linkend="functions-subquery"/>).
   In other contexts where two composite-type values are compared, two
   NULL field values are considered equal, and a NULL is considered larger
   than a non-NULL.  This is necessary in order to have consistent sorting
   and indexing behavior for composite types.
-->
SQL仕様では、結果が2つのNULL値、またはNULLと非NULLの比較に依存するのであれば、行の観点からの比較はNULLを返すことを要求されています。
<productname>PostgreSQL</productname>は、(<xref linkend="row-wise-comparison"/>にあるように)２つの行コンストラクタの出力の比較を行う時、または副問い合わせの出力に対し(<xref linkend="functions-subquery"/>にあるように)行コンストラクタの比較を行う時のみこれを実施します。
２つの複合型の値が比較されるほかの状況では、２つのNULLフィールドの値は等しいと考えられ、NULLは非NULLより大きいとみなされます。
複合型に対して、これは一貫した並び替えとインデックス付け動作担保のため必要です。
  </para>

  <para>
<!--
   Each side is evaluated and they are compared row-wise.  Composite type
   comparisons are allowed when the <replaceable>operator</replaceable> is
   <literal>=</literal>,
   <literal>&lt;&gt;</literal>,
   <literal>&lt;</literal>,
   <literal>&lt;=</literal>,
   <literal>&gt;</literal> or
   <literal>&gt;=</literal>,
   or has semantics similar to one of these.  (To be specific, an operator
   can be a row comparison operator if it is a member of a B-tree operator
   class, or is the negator of the <literal>=</literal> member of a B-tree operator
   class.)  The default behavior of the above operators is the same as for
   <literal>IS [ NOT ] DISTINCT FROM</literal> for row constructors (see
   <xref linkend="row-wise-comparison"/>).
-->
各辺が評価され、行単位で比較が行なわれます。
複合型の比較は<replaceable>operator</replaceable>が<literal>=</literal>、<literal>&lt;&gt;</literal>、<literal>&lt;</literal>、<literal>&lt;=</literal>、<literal>&gt;</literal>、<literal>&gt;=</literal>またはそのいずれかと類似の意味を持つ場合に許されます。
(正確には、演算子はB-tree演算子クラスのメンバである場合、またはB-tree演算子クラスの<literal>=</literal>メンバの否定子である場合に行比較演算子となり得ます。)
上記の演算子のデフォルトの動作は、行コンストラクタに対する<literal>IS [ NOT ] DISTINCT FROM</literal>と同じです（<xref linkend="row-wise-comparison"/>参照）。
  </para>

  <para>
<!--
   To support matching of rows which include elements without a default
   B-tree operator class, the following operators are defined for composite
   type comparison:
   <literal>*=</literal>,
   <literal>*&lt;&gt;</literal>,
   <literal>*&lt;</literal>,
   <literal>*&lt;=</literal>,
   <literal>*&gt;</literal>, and
   <literal>*&gt;=</literal>.
   These operators compare the internal binary representation of the two
   rows.  Two rows might have a different binary representation even
   though comparisons of the two rows with the equality operator is true.
   The ordering of rows under these comparison operators is deterministic
   but not otherwise meaningful.  These operators are used internally for
   materialized views and might be useful for other specialized purposes
   such as replication but are not intended to be generally useful for
   writing queries.
-->
デフォルトのB-tree演算子クラスを持たない要素を含む行の一致をサポートするために、いくつかの演算子が複合型の比較のために定義されています。
それは<literal>*=</literal>、<literal>*&lt;&gt;</literal>、<literal>*&lt;</literal>、<literal>*&lt;=</literal>、<literal>*&gt;</literal>、<literal>*&gt;=</literal>です。
上記の演算子は2つの行の内部バイナリ表現を比較します。
2つの行の等価演算子での比較が真であっても、2つの行はバイナリ表現が異なるかもしれません。
上記の比較演算子での行の順序は決定論的ですが、それ以外は意味がありません。
上記の演算子はマテリアライズドビューで内部的に使われ、レプリケーションのような他の特定の目的のためには有用かもしれませんが、問い合わせを書くのに一般的に有用であるようにとは意図していません。
  </para>
  </sect2>
 </sect1>

 <sect1 id="functions-srf">
<!--
  <title>Set Returning Functions</title>
-->
  <title>集合を返す関数</title>

  <indexterm zone="functions-srf">
<!--
   <primary>set returning functions</primary>
-->
   <primary>集合を返す関数</primary>
<!--
   <secondary>functions</secondary>
-->
   <secondary>関数</secondary>
  </indexterm>

  <indexterm>
   <primary>generate_series</primary>
  </indexterm>

  <para>
<!--
   This section describes functions that possibly return more than one row.
   The most widely used functions in this class are series generating
   functions, as detailed in <xref linkend="functions-srf-series"/> and
   <xref linkend="functions-srf-subscripts"/>.  Other, more specialized
   set-returning functions are described elsewhere in this manual.
   See <xref linkend="queries-tablefunctions"/> for ways to combine multiple
   set-returning functions.
-->
本節では、場合により複数行を返す関数について説明します。
このクラスで最も広く用いられている関数は、<xref linkend="functions-srf-series"/>、および<xref linkend="functions-srf-subscripts"/>にて詳細が触れられている、連続値生成関数です。
他方、より特化された集合を返す関数の記述がこのマニュアルの他の場所にあります。
集合を返す関数を複数組み合わせる方法については<xref linkend="queries-tablefunctions"/>を参照してください。
  </para>

  <table id="functions-srf-series">
<!--
   <title>Series Generating Functions</title>
-->
   <title>連続値生成関数</title>
   <tgroup cols="4">
    <thead>
     <row>
<!--
      <entry>Function</entry>
      <entry>Argument Type</entry>
      <entry>Return Type</entry>
      <entry>Description</entry>
-->
      <entry>関数</entry>
      <entry>引数型</entry>
      <entry>戻り型</entry>
      <entry>説明</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal><function>generate_series(<parameter>start</parameter>, <parameter>stop</parameter>)</function></literal></entry>
<!--
      <entry><type>int</type>, <type>bigint</type> or <type>numeric</type></entry>
-->
      <entry><type>int</type>、<type>bigint</type>、または<type>numeric</type></entry>
<!--
      <entry><type>setof int</type>, <type>setof bigint</type>, or <type>setof numeric</type> (same as argument type)</entry>
-->
      <entry><type>setof int</type>、<type>setof bigint</type>または<type>setof numeric</type>（引数の型と同一）</entry>
      <entry>
<!--
       Generate a series of values, from <parameter>start</parameter> to <parameter>stop</parameter>
       with a step size of one
-->
      <parameter>start</parameter>から<parameter>stop</parameter>まで、刻み１で連続する値を生成します。
      </entry>
     </row>

     <row>
      <entry><literal><function>generate_series(<parameter>start</parameter>, <parameter>stop</parameter>, <parameter>step</parameter>)</function></literal></entry>
<!--
      <entry><type>int</type>, <type>bigint</type> or <type>numeric</type></entry>
-->
      <entry><type>int</type>、<type>bigint</type>または<type>numeric</type></entry>
<!--
      <entry><type>setof int</type>, <type>setof bigint</type> or <type>setof numeric</type> (same as argument type)</entry>
-->
      <entry><type>setof int</type>、<type>setof bigint</type>または<type>setof numeric</type>（引数の型と同一）</entry>
      <entry>
<!--
       Generate a series of values, from <parameter>start</parameter> to <parameter>stop</parameter>
       with a step size of <parameter>step</parameter>
-->
       <parameter>start</parameter>から<parameter>stop</parameter>まで、刻み<parameter>step</parameter>で連続する値を生成します。
      </entry>
     </row>

     <row>
      <entry><literal><function>generate_series(<parameter>start</parameter>, <parameter>stop</parameter>, <parameter>step</parameter> <type>interval</type>)</function></literal></entry>
<!--
      <entry><type>timestamp</type> or <type>timestamp with time zone</type></entry>
-->
      <entry><type>timestamp</type> または <type>timestamp with time zone</type></entry>
<!--
      <entry><type>setof timestamp</type> or <type>setof timestamp with time zone</type> (same as argument type)</entry>
-->
      <entry><type>setof timestamp</type> または <type>setof timestamp with time zone</type>（引数型と同じ）</entry>
      <entry>
<!--
       Generate a series of values, from <parameter>start</parameter> to <parameter>stop</parameter>
       with a step size of <parameter>step</parameter>
-->
       <parameter>start</parameter>から<parameter>stop</parameter>まで、刻み<parameter>step</parameter>で連続する値を生成します。
      </entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <para>
<!--
   When <parameter>step</parameter> is positive, zero rows are returned if
   <parameter>start</parameter> is greater than <parameter>stop</parameter>.
   Conversely, when <parameter>step</parameter> is negative, zero rows are
   returned if <parameter>start</parameter> is less than <parameter>stop</parameter>.
   Zero rows are also returned for <literal>NULL</literal> inputs. It is an error
   for <parameter>step</parameter> to be zero. Some examples follow:
-->
<parameter>step</parameter>が正の場合、<parameter>start</parameter>が<parameter>stop</parameter>よりも大きいと０行が返ります。
反対に、<parameter>step</parameter>が負の場合は、<parameter>start</parameter>が<parameter>stop</parameter>よりも小さいと０行が返ります。
また、<literal>NULL</literal>が入力された場合も０行が返ります。
<parameter>step</parameter>が０の時はエラーになります。
以下にいくつか例を示します。
<programlisting>
SELECT * FROM generate_series(2,4);
 generate_series
-----------------
               2
               3
               4
(3 rows)

SELECT * FROM generate_series(5,1,-2);
 generate_series
-----------------
               5
               3
               1
(3 rows)

SELECT * FROM generate_series(4,3);
 generate_series
-----------------
(0 rows)

SELECT generate_series(1.1, 4, 1.3);
 generate_series 
-----------------
             1.1
             2.4
             3.7
(3 rows)

<!--
&#045;- this example relies on the date-plus-integer operator
-->
-- この例は日付に整数を足し込む演算子に依存します。
SELECT current_date + s.a AS dates FROM generate_series(0,14,7) AS s(a);
   dates
------------
 2004-02-05
 2004-02-12
 2004-02-19
(3 rows)

SELECT * FROM generate_series('2008-03-01 00:00'::timestamp,
                              '2008-03-04 12:00', '10 hours');
   generate_series   
---------------------
 2008-03-01 00:00:00
 2008-03-01 10:00:00
 2008-03-01 20:00:00
 2008-03-02 06:00:00
 2008-03-02 16:00:00
 2008-03-03 02:00:00
 2008-03-03 12:00:00
 2008-03-03 22:00:00
 2008-03-04 08:00:00
(9 rows)
</programlisting>
  </para>

  <table id="functions-srf-subscripts">
<!--
   <title>Subscript Generating Functions</title>
-->
   <title>添え字生成関数</title>
   <tgroup cols="3">
    <thead>
     <row>
<!--
      <entry>Function</entry>
      <entry>Return Type</entry>
      <entry>Description</entry>
-->
      <entry>関数</entry>
      <entry>戻り値型</entry>
      <entry>説明</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal><function>generate_subscripts(<parameter>array anyarray</parameter>, <parameter>dim int</parameter>)</function></literal></entry>
      <entry><type>setof int</type></entry>
      <entry>
<!--
       Generate a series comprising the given array's subscripts.
-->
       指定した配列の添え字を構成する連番を生成します。
      </entry>
     </row>

     <row>
      <entry><literal><function>generate_subscripts(<parameter>array anyarray</parameter>, <parameter>dim int</parameter>, <parameter>reverse boolean</parameter>)</function></literal></entry>
      <entry><type>setof int</type></entry>
      <entry>
<!--
       Generate a series comprising the given array's subscripts. When
       <parameter>reverse</parameter> is true, the series is returned in
       reverse order.
-->
       指定した配列の添え字を構成する連番を生成します。
       <parameter>reverse</parameter>が真の場合、連番は逆順に返されます。
      </entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <indexterm>
   <primary>generate_subscripts</primary>
  </indexterm>

  <para>
<!--
   <function>generate_subscripts</function> is a convenience function that generates
   the set of valid subscripts for the specified dimension of the given
   array.
   Zero rows are returned for arrays that do not have the requested dimension,
   or for NULL arrays (but valid subscripts are returned for NULL array
   elements).  Some examples follow:
-->
<function>generate_subscripts</function>は、指定した配列の指定した次数で有効な添え字からなる集合を生成するために便利な関数です。
要求された次数を持たない配列またはNULL配列では行は返されません。
（しかしこれはNULL配列要素では有効な添え字です。）
いくつかの例を以下に示します。
   
<programlisting>
<!--
&#045;- basic usage
-->
-- 基本的用法
SELECT generate_subscripts('{NULL,1,NULL,2}'::int[], 1) AS s;
 s 
---
 1
 2
 3
 4
(4 rows)

<!--
&#045;- presenting an array, the subscript and the subscripted
&#045;- value requires a subquery
-->
-- 配列、添え字とその添え字が示す値を表示するには
-- 副問い合わせが必要です。
SELECT * FROM arrays;
         a          
--------------------
 {-1,-2}
 {100,200,300}
(2 rows)

SELECT a AS array, s AS subscript, a[s] AS value
FROM (SELECT generate_subscripts(a, 1) AS s, a FROM arrays) foo;
     array     | subscript | value
---------------+-----------+-------
 {-1,-2}       |         1 |    -1
 {-1,-2}       |         2 |    -2
 {100,200,300} |         1 |   100
 {100,200,300} |         2 |   200
 {100,200,300} |         3 |   300
(5 rows)

<!--
&#045;- unnest a 2D array
-->
-- 2次元配列の入れ子を解きます。
CREATE OR REPLACE FUNCTION unnest2(anyarray)
RETURNS SETOF anyelement AS $$
select $1[i][j]
   from generate_subscripts($1,1) g1(i),
        generate_subscripts($1,2) g2(j);
$$ LANGUAGE sql IMMUTABLE;
CREATE FUNCTION
SELECT * FROM unnest2(ARRAY[[1,2],[3,4]]);
 unnest2 
---------
       1
       2
       3
       4
(4 rows)
</programlisting>
  </para>

  <indexterm>
<!--
   <primary>ordinality</primary>
-->
   <primary>順序性</primary>
  </indexterm>

  <para>
<!--
   When a function in the <literal>FROM</literal> clause is suffixed
   by <literal>WITH ORDINALITY</literal>, a <type>bigint</type> column is
   appended to the output which starts from 1 and increments by 1 for each row
   of the function's output.  This is most useful in the case of set returning
   functions such as <function>unnest()</function>.
-->
<literal>FROM</literal>句の関数の後に<literal>WITH ORDINALITY</literal>が付いている場合、1から始まり関数の出力の行毎に1増えていく<type>bigint</type>列が出力に追加されます。
これは<function>unnest()</function>のような集合を返す関数の場合に最も役に立ちます。

<programlisting>
<!--
&#045;- set returning function WITH ORDINALITY
-->
-- WITH ORDINALITYの付いた集合を返す関数
SELECT * FROM pg_ls_dir('.') WITH ORDINALITY AS t(ls,n);
       ls        | n
-----------------+----
 pg_serial       |  1
 pg_twophase     |  2
 postmaster.opts |  3
 pg_notify       |  4
 postgresql.conf |  5
 pg_tblspc       |  6
 logfile         |  7
 base            |  8
 postmaster.pid  |  9
 pg_ident.conf   | 10
 global          | 11
 pg_xact         | 12
 pg_snapshots    | 13
 pg_multixact    | 14
 PG_VERSION      | 15
 pg_wal          | 16
 pg_hba.conf     | 17
 pg_stat_tmp     | 18
 pg_subtrans     | 19
(19 rows)
</programlisting>
  </para>

 </sect1>

 <sect1 id="functions-info">
<!--
  <title>System Information Functions and Operators</title>
-->
  <title>システム情報関数</title>

  <para>
<!--
   <xref linkend="functions-info-session-table"/> shows several
   functions that extract session and system information.
-->
<xref linkend="functions-info-session-table"/>に、セッションおよびシステムの情報を抽出する関数を示します。
  </para>

  <para>
<!--
   In addition to the functions listed in this section, there are a number of
   functions related to the statistics system that also provide system
   information. See <xref linkend="monitoring-stats-views"/> for more
   information.
-->
本節で列挙されている関数のほかに、同様にシステム情報を提供する統計システムに関連した数多くの関数があります。
<xref linkend="monitoring-stats-views"/>にさらに情報があります。
  </para>

   <table id="functions-info-session-table">
<!--
    <title>Session Information Functions</title>
-->
    <title>セッション情報関数</title>
    <tgroup cols="3">
     <thead>
<!--
      <row><entry>Name</entry> <entry>Return Type</entry> <entry>Description</entry></row>
-->
      <row><entry>名前</entry> <entry>戻り型</entry> <entry>説明</entry></row>
     </thead>

     <tbody>
      <row>
       <entry><literal><function>current_catalog</function></literal></entry>
       <entry><type>name</type></entry>
<!--
       <entry>name of current database (called <quote>catalog</quote> in the SQL standard)</entry>
-->
       <entry>現在のデータベースの名前（SQL標準では<quote>カタログ</quote>と呼ばれる）</entry>
      </row>

      <row>
       <entry><literal><function>current_database()</function></literal></entry>
       <entry><type>name</type></entry>
<!--
       <entry>name of current database</entry>
-->
       <entry>現在のデータベースの名前</entry>
      </row>

      <row>
       <entry><literal><function>current_query()</function></literal></entry>
       <entry><type>text</type></entry>
<!--
       <entry>text of the currently executing query, as submitted
       by the client (might contain more than one statement)</entry>
-->
       <entry>クライアントから提示された、現在実行中問い合わせのテキスト（複数の文を含むことあり）</entry>
      </row>

      <row>
       <entry><literal><function>current_role</function></literal></entry>
       <entry><type>name</type></entry>
<!--
       <entry>equivalent to <function>current_user</function></entry>
-->
       <entry><function>current_user</function>と同等</entry>
      </row>

      <row>
       <entry><literal><function>current_schema</function>[()]</literal></entry>
       <entry><type>name</type></entry>
<!--
       <entry>name of current schema</entry>
-->
       <entry>現在のスキーマの名前</entry>
      </row>

      <row>
       <entry><literal><function>current_schemas(<type>boolean</type>)</function></literal></entry>
       <entry><type>name[]</type></entry>
<!--
       <entry>names of schemas in search path, optionally including implicit schemas</entry>
-->
       <entry>検索パス内のスキーマの名前、オプションにより暗黙的なスキーマも含める</entry>
      </row>

      <row>
       <entry><literal><function>current_user</function></literal></entry>
       <entry><type>name</type></entry>
<!--
       <entry>user name of current execution context</entry>
-->
       <entry>現在の処理実施コンテキストのユーザ名</entry>
      </row>

      <row>
       <entry><literal><function>inet_client_addr()</function></literal></entry>
       <entry><type>inet</type></entry>
<!--
       <entry>address of the remote connection</entry>
-->
       <entry>リモート接続のアドレス</entry>
      </row>

      <row>
       <entry><literal><function>inet_client_port()</function></literal></entry>
       <entry><type>int</type></entry>
<!--
       <entry>port of the remote connection</entry>
-->
       <entry>リモート接続のポート</entry>
      </row>

      <row>
       <entry><literal><function>inet_server_addr()</function></literal></entry>
       <entry><type>inet</type></entry>
<!--
       <entry>address of the local connection</entry>
-->
       <entry>ローカル接続のアドレス</entry>
      </row>

      <row>
       <entry><literal><function>inet_server_port()</function></literal></entry>
       <entry><type>int</type></entry>
<!--
       <entry>port of the local connection</entry>
-->
       <entry>ローカル接続のポート</entry>
      </row>

      <row>
       <!-- See also the entry for this in monitoring.sgml -->
       <!-- これについてmonitoring.sgmlの項目も参照 -->
       <entry><literal><function>pg_backend_pid()</function></literal></entry>
       <entry><type>int</type></entry>
       <entry>
<!--
        Process ID of the server process attached to the current session
-->
        現在のセッションに結びついたサーバプロセスのプロセスID
       </entry>
      </row>

      <row>
       <entry><literal><function>pg_blocking_pids(<type>int</type>)</function></literal></entry>
       <entry><type>int[]</type></entry>
<!--
       <entry>Process ID(s) that are blocking specified server process ID from acquiring a lock</entry>
-->
       <entry>指定のサーバプロセスIDによるロック取得をブロックしているプロセスID</entry>
      </row>

      <row>
       <entry><literal><function>pg_conf_load_time()</function></literal></entry>
       <entry><type>timestamp with time zone</type></entry>
<!--
       <entry>configuration load time</entry>
-->
       <entry>設定を読み込んだ時刻</entry>
      </row>

      <row>
       <entry><literal><function>pg_current_logfile(<optional><type>text</type></optional>)</function></literal></entry>
       <entry><type>text</type></entry>
<!--
       <entry>Primary log file name, or log in the requested format,
       currently in use by the logging collector</entry>
-->
       <entry>ログ収集機構が現在使用しているプライマリ、または指定のフォーマットのログのログファイルの名前</entry>
      </row>

      <row>
       <entry><literal><function>pg_my_temp_schema()</function></literal></entry>
       <entry><type>oid</type></entry>
<!--
       <entry>OID of session's temporary schema, or 0 if none</entry>
-->
       <entry>セッションの一時スキーマのOID、なければ0</entry>
      </row>

      <row>
       <entry><literal><function>pg_is_other_temp_schema(<type>oid</type>)</function></literal></entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>is schema another session's temporary schema?</entry>
-->
       <entry>スキーマが他のセッションの一時スキーマかどうか？</entry>
      </row>

      <row>
       <entry><literal><function>pg_jit_available()</function></literal></entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>is <acronym>JIT</acronym> compilation available in this session
       (see <xref linkend="jit"/>)? Returns <literal>false</literal> if <xref
       linkend="guc-jit"/> is set to false.</entry>
-->
<entry>is <acronym>JIT</acronym>コンパイルがこのセッションで可能か？(<xref linkend="jit"/>参照)
<xref linkend="guc-jit"/>がfalseなら、<literal>false</literal>を返します。</entry>
      </row>

      <row>
       <entry><literal><function>pg_listening_channels()</function></literal></entry>
       <entry><type>setof text</type></entry>
<!--
       <entry>channel names that the session is currently listening on</entry>
-->
       <entry>今のセッションにおいて現在待ち受け中のチャンネル名</entry>
      </row>

      <row>
       <entry><literal><function>pg_notification_queue_usage()</function></literal></entry>
       <entry><type>double</type></entry>
<!--
       <entry>fraction of the asynchronous notification queue currently occupied (0-1)</entry>
-->
       <entry>非同期通知キューのうち、現在占められている割合（0から1まで）</entry>
      </row>

      <row>
       <entry><literal><function>pg_postmaster_start_time()</function></literal></entry>
       <entry><type>timestamp with time zone</type></entry>
<!--
       <entry>server start time</entry>
-->
       <entry>サーバの起動時刻</entry>
      </row>

      <row>
       <entry><literal><function>pg_safe_snapshot_blocking_pids(<type>int</type>)</function></literal></entry>
       <entry><type>int[]</type></entry>
<!--
       <entry>Process ID(s) that are blocking specified server process ID from acquiring a safe snapshot</entry>
-->
       <entry>指定のサーバプロセスIDによる安全なスナップショットの取得をブロックしているプロセスID</entry>
      </row>

      <row>
       <entry><literal><function>pg_trigger_depth()</function></literal></entry>
       <entry><type>int</type></entry>
<!--
       <entry>current nesting level of <productname>PostgreSQL</productname> triggers
       (0 if not called, directly or indirectly, from inside a trigger)</entry>
-->
       <entry><productname>PostgreSQL</productname>のトリガの現在の入れ子の深さ (直接的であれ間接的であれ、トリガ内部から呼ばれていなければ0を返す)</entry>
      </row>

      <row>
       <entry><literal><function>session_user</function></literal></entry>
       <entry><type>name</type></entry>
<!--
       <entry>session user name</entry>
-->
       <entry>セッションのユーザ名</entry>
      </row>

      <row>
       <entry><literal><function>user</function></literal></entry>
       <entry><type>name</type></entry>
<!--
       <entry>equivalent to <function>current_user</function></entry>
-->
       <entry><function>current_user</function>と等価</entry>
      </row>

      <row>
       <entry><literal><function>version()</function></literal></entry>
       <entry><type>text</type></entry>
<!--
       <entry><productname>PostgreSQL</productname> version information. See also <xref linkend="guc-server-version-num"/> for a machine-readable version.</entry>
-->
       <entry><productname>PostgreSQL</productname>バージョン情報。機械読み取り可能なバージョンについては<xref linkend="guc-server-version-num"/>を参照。</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <note>
    <para>
<!--
     <function>current_catalog</function>,
     <function>current_role</function>,
     <function>current_schema</function>,
     <function>current_user</function>,
     <function>session_user</function>,
     and <function>user</function> have special syntactic status
     in <acronym>SQL</acronym>: they must be called without trailing
     parentheses.  (In PostgreSQL, parentheses can optionally be used with
     <function>current_schema</function>, but not with the others.)
-->
<function>current_catalog</function>、<function>current_role</function>、<function>current_schema</function>、<function>current_user</function>、<function>session_user</function>および<function>user</function>は<acronym>SQL</acronym>において特殊な構文上の地位を持っており、最後に括弧を付けずに呼び出さなければなりません。
（PostgreSQLでは<function>current_schema</function>の場合括弧を使用することができますが、他は使えません。）
    </para>
   </note>

   <indexterm>
    <primary>current_catalog</primary>
   </indexterm>

   <indexterm>
    <primary>current_database</primary>
   </indexterm>

   <indexterm>
    <primary>current_query</primary>
   </indexterm>

   <indexterm>
    <primary>current_role</primary>
   </indexterm>

   <indexterm>
    <primary>current_schema</primary>
   </indexterm>

   <indexterm>
    <primary>current_schemas</primary>
   </indexterm>

   <indexterm>
    <primary>current_user</primary>
   </indexterm>

   <indexterm>
    <primary>pg_backend_pid</primary>
   </indexterm>

   <indexterm>
<!--
    <primary>schema</primary>
    <secondary>current</secondary>
-->
    <primary>スキーマ</primary>
    <secondary>現在の</secondary>
   </indexterm>

   <indexterm>
<!--
    <primary>search path</primary>
    <secondary>current</secondary>
-->
    <primary>検索パス</primary>
    <secondary>現在の</secondary>
   </indexterm>

   <indexterm>
    <primary>session_user</primary>
   </indexterm>

   <indexterm>
<!--
    <primary>user</primary>
    <secondary>current</secondary>
-->
    <primary>ユーザ</primary>
    <secondary>現在の</secondary>
   </indexterm>

   <indexterm>
    <primary>user</primary>
   </indexterm>

   <para>
<!--
    The <function>session_user</function> is normally the user who initiated
    the current database connection; but superusers can change this setting
    with <xref linkend="sql-set-session-authorization"/>.
    The <function>current_user</function> is the user identifier
    that is applicable for permission checking. Normally it is equal
    to the session user, but it can be changed with
    <xref linkend="sql-set-role"/>.
    It also changes during the execution of
    functions with the attribute <literal>SECURITY DEFINER</literal>.
    In Unix parlance, the session user is the <quote>real user</quote> and
    the current user is the <quote>effective user</quote>.
    <function>current_role</function> and <function>user</function> are
    synonyms for <function>current_user</function>.  (The SQL standard draws
    a distinction between <function>current_role</function>
    and <function>current_user</function>, but <productname>PostgreSQL</productname>
    does not, since it unifies users and roles into a single kind of entity.)
-->
<function>session_user</function>は、通常、現在のデータベース接続を開始したユーザです。しかし、スーパーユーザはこの設定を<xref linkend="sql-set-session-authorization"/>を使用して変更することができます。
<function>current_user</function>は、権限の検査に適用されるユーザ識別子です。
通常はセッションユーザと同じですが、<xref linkend="sql-set-role"/>を使用して変更可能です。
<literal>SECURITY DEFINER</literal>属性を持つ関数の実行中にも変わります。
Unix用語で言うと、セッションユーザは<quote>実ユーザ</quote>で、現在のユーザは<quote>実効ユーザ</quote>です。
<function>current_role</function>と<function>user</function>は<function>current_user</function>の同義語です。
（標準SQLでは<function>current_role</function>と<function>current_user</function>を区別していますが、<productname>PostgreSQL</productname>ではユーザとロールを1種類のエンティティに統合しているため、両者に区別はありません。）
   </para>

   <para>
<!--
    <function>current_schema</function> returns the name of the schema that is
    first in the search path (or a null value if the search path is
    empty).  This is the schema that will be used for any tables or
    other named objects that are created without specifying a target schema.
    <function>current_schemas(boolean)</function> returns an array of the names of all
    schemas presently in the search path.  The Boolean option determines whether or not
    implicitly included system schemas such as <literal>pg_catalog</literal> are included in the
    returned search path.
-->
<function>current_schema</function>関数は、検索パスの最初にあるスキーマ名（もしくは、検索パスが空の場合はNULL値）を返します。
これは、対象スキーマを指定せずに作成される、すべてのテーブルまたは他の名前付きオブジェクトに使用されるスキーマです。
また、<function>current_schemas(boolean)</function> は、検索パスに存在する全てのスキーマ名の配列を返します。
booleanオプションにより、<literal>pg_catalog</literal>のような暗黙的に含まれているシステムスキーマを、結果の検索パスに含めるかどうかを指定します。
   </para>

   <note>
    <para>
<!--
     The search path can be altered at run time.  The command is:
-->
検索パスは、実行時に変更することができます。
使用するコマンドは以下の通りです。
<programlisting>
SET search_path TO <replaceable>schema</replaceable> <optional>, <replaceable>schema</replaceable>, ...</optional>
</programlisting>
    </para>
   </note>

   <indexterm>
    <primary>inet_client_addr</primary>
   </indexterm>

   <indexterm>
    <primary>inet_client_port</primary>
   </indexterm>

   <indexterm>
    <primary>inet_server_addr</primary>
   </indexterm>

   <indexterm>
    <primary>inet_server_port</primary>
   </indexterm>

   <para>
<!--
     <function>inet_client_addr</function> returns the IP address of the
     current client, and <function>inet_client_port</function> returns the
     port number.
     <function>inet_server_addr</function> returns the IP address on which
     the server accepted the current connection, and
     <function>inet_server_port</function> returns the port number.
     All these functions return NULL if the current connection is via a
     Unix-domain socket.
-->
<function>inet_client_addr</function>は現在のクライアントのIPアドレスを返し、<function>inet_client_port</function>はそのポート番号を返します。
<function>inet_server_addr</function>は、現在の接続を受け付けたサーバのIPアドレスを返し、<function>inet_server_port</function>はそのポート番号を返します。
これら全ての関数は接続がUnixドメインソケット経由の場合NULLを返します。
   </para>

   <indexterm>
    <primary>pg_blocking_pids</primary>
   </indexterm>

   <para>
<!--
    <function>pg_blocking_pids</function> returns an array of the process IDs
    of the sessions that are blocking the server process with the specified
    process ID, or an empty array if there is no such server process or it is
    not blocked.  One server process blocks another if it either holds a lock
    that conflicts with the blocked process's lock request (hard block), or is
    waiting for a lock that would conflict with the blocked process's lock
    request and is ahead of it in the wait queue (soft block).  When using
    parallel queries the result always lists client-visible process IDs (that
    is, <function>pg_backend_pid</function> results) even if the actual lock is held
    or awaited by a child worker process.  As a result of that, there may be
    duplicated PIDs in the result.  Also note that when a prepared transaction
    holds a conflicting lock, it will be represented by a zero process ID in
    the result of this function.
    Frequent calls to this function could have some impact on database
    performance, because it needs exclusive access to the lock manager's
    shared state for a short time.
-->
<function>pg_blocking_pids</function>は指定のプロセスIDのサーバプロセスをブロックしているセッションのプロセスIDの配列を返します。
指定のサーバプロセスが存在しない、あるいはそれがブロックされていないときは空の配列を返します。
あるサーバプロセスが別のサーバプロセスをブロックするのは、ブロックされるプロセスのロック要求と競合するロックを保持している場合（ハードブロック）、あるいは、ブロックされるプロセスのロック要求と競合するロックを待っていて、かつロック待ちキュー内でより前方にいる場合（ソフトロック）です。
パラレルクエリーを使っている場合、実際のロックを子ワーカプロセスが保持または待っている場合であっても、この結果には必ずクライアントから可視のプロセスID（つまり、<function>pg_backend_pid</function>の結果）が示されます。
そのような仕様なので、この結果には重複するPIDが含まれることもあります。
また、プリペアドのトランザクションが競合するロックを保持している場合、この関数の結果ではプロセスIDがゼロとして示されることにも注意して下さい。
この関数はロックマネージャの共有状態に短時間、排他的アクセスをする必要があるため、それを頻繁に呼び出すとデータベースのパフォーマンスに多少、影響するかもしれません。
   </para>

   <indexterm>
    <primary>pg_conf_load_time</primary>
   </indexterm>

   <para>
<!--
    <function>pg_conf_load_time</function> returns the
    <type>timestamp with time zone</type> when the
    server configuration files were last loaded.
    (If the current session was alive at the time, this will be the time
    when the session itself re-read the configuration files, so the
    reading will vary a little in different sessions.  Otherwise it is
    the time when the postmaster process re-read the configuration files.)
-->
<function>pg_conf_load_time</function>はサーバの設定ファイルが最後に読み込まれた時の<type>timestamp with time zone</type>を返します。
（現在のセッションがそのときに活動中だった場合、これはそのセッション自身が設定ファイルを再読み込みした時刻になるため、その結果はセッションによって少し異なるかもしれません。
それ以外の場合は、postmasterプロセスが設定ファイルを再読み込みした時刻になります。）
   </para>

   <indexterm>
    <primary>pg_current_logfile</primary>
   </indexterm>

   <indexterm>
<!--
    <primary>Logging</primary>
    <secondary>pg_current_logfile function</secondary>
-->
    <primary>ログ出力</primary>
    <secondary>pg_current_logfile関数</secondary>
   </indexterm>

   <indexterm>
     <primary>current_logfiles</primary>
<!--
     <secondary>and the pg_current_logfile function</secondary>
-->
     <secondary>およびpg_current_logfile関数</secondary>
   </indexterm>

   <indexterm>
<!--
    <primary>Logging</primary>
    <secondary>current_logfiles file and the pg_current_logfile
    function</secondary>
-->
    <primary>ログ出力</primary>
    <secondary>current_logfilesファイルおよびpg_current_logfile関数</secondary>
   </indexterm>

   <para>
<!--
    <function>pg_current_logfile</function> returns, as <type>text</type>,
    the path of the log file(s) currently in use by the logging collector.
    The path includes the <xref linkend="guc-log-directory"/> directory
    and the log file name.  Log collection must be enabled or the return value
    is <literal>NULL</literal>.  When multiple log files exist, each in a
    different format, <function>pg_current_logfile</function> called
    without arguments returns the path of the file having the first format
    found in the ordered list: <systemitem>stderr</systemitem>, <systemitem>csvlog</systemitem>.
    <literal>NULL</literal> is returned when no log file has any of these
    formats.  To request a specific file format supply, as <type>text</type>,
    either <systemitem>csvlog</systemitem> or <systemitem>stderr</systemitem> as the value of the
    optional parameter. The return value is <literal>NULL</literal> when the
    log format requested is not a configured
    <xref linkend="guc-log-destination"/>.  The
    <function>pg_current_logfile</function> reflects the contents of the
    <filename>current_logfiles</filename> file.
-->
<function>pg_current_logfile</function>はログ収集機構が現在使用しているログファイルのパスを<type>text</type>として返します。
パスには<xref linkend="guc-log-directory"/>ディレクトリとログファイルの名前が含まれます。
ログ収集が有効になっていなければならず、そうでなければ戻り値は<literal>NULL</literal>になります。
複数のログファイルがそれぞれ異なる形式で存在する場合、引数なしの<function>pg_current_logfile</function>は、順序リスト（<systemitem>stderr</systemitem>、<systemitem>csvlog</systemitem>）の最初に出てくる形式のファイルのパスを返します。
これらの形式のログファイルがないときは<literal>NULL</literal>が返されます。
特定のファイル形式を要求するには、オプションパラメータの値として<systemitem>csvlog</systemitem>または<systemitem>stderr</systemitem>を<type>text</type>として渡してください。
指定のログ形式が<xref linkend="guc-log-destination"/>で設定されていない場合は、戻り値が<literal>NULL</literal>となります。
<function>pg_current_logfiles</function>は<filename>current_logfiles</filename>ファイルの内容を反映します。
   </para>

   <indexterm>
    <primary>pg_my_temp_schema</primary>
   </indexterm>

   <indexterm>
    <primary>pg_is_other_temp_schema</primary>
   </indexterm>

   <para>
<!--
    <function>pg_my_temp_schema</function> returns the OID of the current
    session's temporary schema, or zero if it has none (because it has not
    created any temporary tables).
    <function>pg_is_other_temp_schema</function> returns true if the
    given OID is the OID of another session's temporary schema.
    (This can be useful, for example, to exclude other sessions' temporary
    tables from a catalog display.)
-->
<function>pg_my_temp_schema</function>は、現在のセッションの一時スキーマのOIDを返します。（一時テーブルをまだ１つも作成しておらず）存在しなければゼロを返します。
<function>pg_is_other_temp_schema</function>は、指定したOIDが他のセッションの一時スキーマのOIDであれば、真を返します。
（例えば、他のセッションの一時テーブルをカタログ表示から除外したい場合などで有用です。）
   </para>

   <indexterm>
    <primary>pg_listening_channels</primary>
   </indexterm>

   <indexterm>
    <primary>pg_notification_queue_usage</primary>
   </indexterm>

   <para>
<!--
    <function>pg_listening_channels</function> returns a set of names of
    asynchronous notification channels that the current session is listening
    to.  <function>pg_notification_queue_usage</function> returns the
    fraction of the total available space for notifications currently
    occupied by notifications that are waiting to be processed, as a
    <type>double</type> in the range 0-1.
    See <xref linkend="sql-listen"/> and <xref linkend="sql-notify"/>
    for more information.
-->
<function>pg_listening_channels</function>は現在のセッションが監視している非同期通知チャネルの名前の集合を返します。
<function>pg_notification_queue_usage</function>は通知用に利用可能な全領域のうち、処理待ちになっている通知によって現在占められている割合を0から1の範囲の<type>double</type>として返します。
詳しくは<xref linkend="sql-listen"/>および<xref linkend="sql-notify"/>を参照して下さい。
   </para>

   <indexterm>
    <primary>pg_postmaster_start_time</primary>
   </indexterm>

   <para>
<!--
    <function>pg_postmaster_start_time</function> returns the
    <type>timestamp with time zone</type> when the
    server started.
-->
<function>pg_postmaster_start_time</function>は、サーバが起動したときの<type>timestamp with time zone</type>を返します。
   </para>

   <indexterm>
    <primary>pg_safe_snapshot_blocking_pids</primary>
   </indexterm>

   <para>
<!--
    <function>pg_safe_snapshot_blocking_pids</function> returns an array of
    the process IDs of the sessions that are blocking the server process with
    the specified process ID from acquiring a safe snapshot, or an empty array
    if there is no such server process or it is not blocked.  A session
    running a <literal>SERIALIZABLE</literal> transaction blocks
    a <literal>SERIALIZABLE READ ONLY DEFERRABLE</literal> transaction from
    acquiring a snapshot until the latter determines that it is safe to avoid
    taking any predicate locks.  See <xref linkend="xact-serializable"/> for
    more information about serializable and deferrable transactions.  Frequent
    calls to this function could have some impact on database performance,
    because it needs access to the predicate lock manager's shared
    state for a short time.
-->
<function>pg_safe_snapshot_blocking_pids</function>は、指定のプロセスIDが安全なスナップショットを取得するのをブロックしているサーバプロセスのセッションのプロセスIDの配列を返します。
そのようなサーバプロセスが存在しない場合、またはブロックされていない場合は空の配列が返されます。
<literal>SERIALIZABLE</literal>トランザクションを実行しているセッションは、<literal>SERIALIZABLE READ ONLY DEFERRABLE</literal>トランザクションが述語ロックの取得をすべて回避しても安全であると決定するまで、後者がスナップショットを取得するのをブロックします。
シリアライザブルトランザクションおよび遅延可能トランザクションについてのさらなる情報については<xref linkend="xact-serializable"/>を参照してください。
この関数を頻繁に呼び出すと、短時間に述語ロックマネージャの共有状態にアクセスする必要があるため、データベースのパフォーマンスに若干の影響が出るかもしれません。
   </para>

   <indexterm>
    <primary>version</primary>
   </indexterm>

   <para>
<!--
    <function>version</function> returns a string describing the
    <productname>PostgreSQL</productname> server's version. You can also
    get this information from <xref linkend="guc-server-version"/> or
    for a machine-readable version, <xref linkend="guc-server-version-num"/>.
    Software developers should use <literal>server_version_num</literal>
    (available since 8.2) or <xref linkend="libpq-pqserverversion"/> instead
    of parsing the text version.
-->
<function>version</function>関数は<productname>PostgreSQL</productname>サーバのバージョンを記述した文字列を返します。
この情報は<xref linkend="guc-server-version"/>でも取得できますし、機械読み取り可能なバージョンは<xref linkend="guc-server-version-num"/>で取得できます。
ソフトウェア開発者はテキスト版の結果を解析するのではなく、<literal>server_version_num</literal>（バージョン8.2以降で利用可能）あるいは<xref linkend="libpq-pqserverversion"/>を利用すべきです。
   </para>

  <indexterm>
<!--
   <primary>privilege</primary>
   <secondary>querying</secondary>
-->
   <primary>権限</primary>
   <secondary>問い合わせ</secondary>
  </indexterm>

  <para>
<!--
   <xref linkend="functions-info-access-table"/> lists functions that
   allow the user to query object access privileges programmatically.
   See <xref linkend="ddl-priv"/> for more information about
   privileges.
-->
<xref linkend="functions-info-access-table"/>に列挙した関数を使用して、ユーザはオブジェクトのアクセス権限をプログラムから問い合わせることができます。
権限についての詳細は、<xref linkend="ddl-priv"/>を参照してください。
  </para>

   <table id="functions-info-access-table">
<!--
    <title>Access Privilege Inquiry Functions</title>
-->
    <title>アクセス権限照会関数</title>
    <tgroup cols="3">
     <thead>
<!--
      <row><entry>Name</entry> <entry>Return Type</entry> <entry>Description</entry></row>
-->
      <row><entry>名前</entry> <entry>戻り型</entry> <entry>説明</entry></row>
     </thead>

     <tbody>
      <row>
       <entry><literal><function>has_any_column_privilege</function>(<parameter>user</parameter>,
                                  <parameter>table</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>does user have privilege for any column of table</entry>
-->
       <entry>ユーザがテーブルのどれか１つの列に対して権限を所有しているか</entry>
      </row>
      <row>
       <entry><literal><function>has_any_column_privilege</function>(<parameter>table</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>does current user have privilege for any column of table</entry>
-->
       <entry>現在のユーザがテーブルのどれか１つの列に対して権限を所有しているか</entry>
      </row>
      <row>
       <entry><literal><function>has_column_privilege</function>(<parameter>user</parameter>,
                                  <parameter>table</parameter>,
                                  <parameter>column</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>does user have privilege for column</entry>
-->
       <entry>ユーザに列に対する権限があるか</entry>
      </row>
      <row>
       <entry><literal><function>has_column_privilege</function>(<parameter>table</parameter>,
                                  <parameter>column</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>does current user have privilege for column</entry>
-->
       <entry>現在のユーザに列に対する権限があるか</entry>
      </row>
      <row>
       <entry><literal><function>has_database_privilege</function>(<parameter>user</parameter>,
                                  <parameter>database</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>does user have privilege for database</entry>
-->
       <entry>ユーザにデータベースに対する権限があるのか</entry>
      </row>
      <row>
       <entry><literal><function>has_database_privilege</function>(<parameter>database</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>does current user have privilege for database</entry>
-->
       <entry>現在のユーザにデータベースに対する権限があるのか</entry>
      </row>
      <row>
       <entry><literal><function>has_foreign_data_wrapper_privilege</function>(<parameter>user</parameter>,
                                  <parameter>fdw</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>does user have privilege for foreign-data wrapper</entry>
-->
       <entry>ユーザに外部データラッパに対する権限があるのか</entry>
      </row>
      <row>
       <entry><literal><function>has_foreign_data_wrapper_privilege</function>(<parameter>fdw</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>does current user have privilege for foreign-data wrapper</entry>
-->
       <entry>現在のユーザに外部データラッパに対する権限があるのか</entry>
      </row>
      <row>
       <entry><literal><function>has_function_privilege</function>(<parameter>user</parameter>,
                                  <parameter>function</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>does user have privilege for function</entry>
-->
       <entry>ユーザに関数に対する権限があるのか</entry>
      </row>
      <row>
       <entry><literal><function>has_function_privilege</function>(<parameter>function</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>does current user have privilege for function</entry>
-->
       <entry>現在のユーザに関数に対する権限があるのか</entry>
      </row>
      <row>
       <entry><literal><function>has_language_privilege</function>(<parameter>user</parameter>,
                                  <parameter>language</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>does user have privilege for language</entry>
-->
       <entry>ユーザに言語に対する権限があるのか</entry>
      </row>
      <row>
       <entry><literal><function>has_language_privilege</function>(<parameter>language</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>does current user have privilege for language</entry>
-->
       <entry>現在のユーザに言語に対する権限があるのか</entry>
      </row>
      <row>
       <entry><literal><function>has_schema_privilege</function>(<parameter>user</parameter>,
                                  <parameter>schema</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>does user have privilege for schema</entry>
-->
       <entry>ユーザにスキーマに対する権限があるのか</entry>
      </row>
      <row>
       <entry><literal><function>has_schema_privilege</function>(<parameter>schema</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>does current user have privilege for schema</entry>
-->
       <entry>現在のユーザにスキーマに対する権限があるのか</entry>
      </row>
      <row>
       <entry><literal><function>has_sequence_privilege</function>(<parameter>user</parameter>,
                                  <parameter>sequence</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>does user have privilege for sequence</entry>
-->
       <entry>ユーザにシーケンスに対する権限があるのか</entry>
      </row>
      <row>
       <entry><literal><function>has_sequence_privilege</function>(<parameter>sequence</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>does current user have privilege for sequence</entry>
-->
       <entry>現在のユーザにシーケンスに対する権限があるのか</entry>
      </row>
      <row>
       <entry><literal><function>has_server_privilege</function>(<parameter>user</parameter>,
                                  <parameter>server</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>does user have privilege for foreign server</entry>
-->
       <entry>ユーザに外部サーバに対する権限があるのか</entry>
      </row>
      <row>
       <entry><literal><function>has_server_privilege</function>(<parameter>server</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>does current user have privilege for foreign server</entry>
-->
       <entry>現在のユーザに外部サーバに対する権限があるのか</entry>
      </row>
      <row>
       <entry><literal><function>has_table_privilege</function>(<parameter>user</parameter>,
                                  <parameter>table</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>does user have privilege for table</entry>
-->
       <entry>ユーザにテーブルに対する権限があるのか</entry>
      </row>
      <row>
       <entry><literal><function>has_table_privilege</function>(<parameter>table</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>does current user have privilege for table</entry>
-->
       <entry>現在のユーザにテーブルに対する権限があるのか</entry>
      </row>
      <row>
       <entry><literal><function>has_tablespace_privilege</function>(<parameter>user</parameter>,
                                  <parameter>tablespace</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>does user have privilege for tablespace</entry>
-->
       <entry>ユーザにテーブル空間に対する権限があるのか</entry>
      </row>
      <row>
       <entry><literal><function>has_tablespace_privilege</function>(<parameter>tablespace</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>does current user have privilege for tablespace</entry>
-->
       <entry>現在のユーザにテーブル空間に対する権限があるのか</entry>
      </row>
      <row>
       <entry><literal><function>has_type_privilege</function>(<parameter>user</parameter>,
                                  <parameter>type</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>does user have privilege for type</entry>
-->
       <entry>ユーザに型に対する権限があるのか</entry>
      </row>
      <row>
       <entry><literal><function>has_type_privilege</function>(<parameter>type</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>does current user have privilege for type</entry>
-->
       <entry>現在のユーザに型に対する権限があるのか</entry>
      </row>
      <row>
       <entry><literal><function>pg_has_role</function>(<parameter>user</parameter>,
                                  <parameter>role</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>does user have privilege for role</entry>
-->
       <entry>ユーザにロールに対する権限があるのか</entry>
      </row>
      <row>
       <entry><literal><function>pg_has_role</function>(<parameter>role</parameter>,
                                  <parameter>privilege</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>does current user have privilege for role</entry>
-->
       <entry>現在のユーザにロールに対する権限があるのか</entry>
      </row>
      <row>
       <entry><literal><function>row_security_active</function>(<parameter>table</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>does current user have row level security active for table</entry>
-->
       <entry>現在のユーザに有効なテーブルの行単位セキュリティがあるのか</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <indexterm>
    <primary>has_any_column_privilege</primary>
   </indexterm>
   <indexterm>
    <primary>has_column_privilege</primary>
   </indexterm>
   <indexterm>
    <primary>has_database_privilege</primary>
   </indexterm>
   <indexterm>
    <primary>has_function_privilege</primary>
   </indexterm>
   <indexterm>
    <primary>has_foreign_data_wrapper_privilege</primary>
   </indexterm>
   <indexterm>
    <primary>has_language_privilege</primary>
   </indexterm>
   <indexterm>
    <primary>has_schema_privilege</primary>
   </indexterm>
   <indexterm>
    <primary>has_server_privilege</primary>
   </indexterm>
   <indexterm>
    <primary>has_sequence_privilege</primary>
   </indexterm>
   <indexterm>
    <primary>has_table_privilege</primary>
   </indexterm>
   <indexterm>
    <primary>has_tablespace_privilege</primary>
   </indexterm>
   <indexterm>
    <primary>has_type_privilege</primary>
   </indexterm>
   <indexterm>
    <primary>pg_has_role</primary>
   </indexterm>
   <indexterm>
    <primary>row_security_active</primary>
   </indexterm>

   <para>
<!--
    <function>has_table_privilege</function> checks whether a user
    can access a table in a particular way.  The user can be
    specified by name, by OID (<literal>pg_authid.oid</literal>),
    <literal>public</literal> to indicate the PUBLIC pseudo-role, or if the argument is
    omitted
    <function>current_user</function> is assumed.  The table can be specified
    by name or by OID.  (Thus, there are actually six variants of
    <function>has_table_privilege</function>, which can be distinguished by
    the number and types of their arguments.)  When specifying by name,
    the name can be schema-qualified if necessary.
    The desired access privilege type
    is specified by a text string, which must evaluate to one of the
    values <literal>SELECT</literal>, <literal>INSERT</literal>,
    <literal>UPDATE</literal>, <literal>DELETE</literal>, <literal>TRUNCATE</literal>,
    <literal>REFERENCES</literal>, or <literal>TRIGGER</literal>.  Optionally,
    <literal>WITH GRANT OPTION</literal> can be added to a privilege type to test
    whether the privilege is held with grant option.  Also, multiple privilege
    types can be listed separated by commas, in which case the result will
    be <literal>true</literal> if any of the listed privileges is held.
    (Case of the privilege string is not significant, and extra whitespace
    is allowed between but not within privilege names.)
    Some examples:
-->
<function>has_table_privilege</function>はユーザが特定の方法でテーブルにアクセス可能かどうかを検査します。
ユーザは名前、OID(<literal>pg_authid.oid</literal>)、もしくは擬似的なPUBLICロールを意味する<literal>public</literal>で指定できます。省略された場合は<function>current_user</function>が使われます。
テーブルは名前もしくはOIDで指定可能です。
（従って、実際には<function>has_table_privilege</function>の６つの変形があり、引数の数と型で区別されます。）
名前を指定する場合、必要であればスキーマ修飾できます。
対象とするアクセス権限の種類はテキスト文字列で指定され、それは、<literal>SELECT</literal>、<literal>INSERT</literal>、<literal>UPDATE</literal>、<literal>DELETE</literal>、<literal>TRUNCATE</literal>、<literal>REFERENCES</literal>、または<literal>TRIGGER</literal>のどれかである必要があります。
オプションとして、権限がGRANTオプションにより付与されているかどうかの権限の検査するため、<literal>WITH GRANT OPTION</literal>を付加することができます。
更に、複数の権限の種類をコンマで区切って列挙可能です。この場合、結果は列挙された権限の１つでも存在すれば<literal>真</literal>となります。
（権限文字列の大文字小文字は重要ではありません。余分な空白は権限名と権限名の間にはあっても良いですが、権限名の途中にはあってはいけません。）
例を示します。

<programlisting>
SELECT has_table_privilege('myschema.mytable', 'select');
SELECT has_table_privilege('joe', 'mytable', 'INSERT, SELECT WITH GRANT OPTION');
</programlisting>
   </para>

   <para>
<!--
    <function>has_sequence_privilege</function> checks whether a user
    can access a sequence in a particular way.  The possibilities for its
    arguments are analogous to <function>has_table_privilege</function>.
    The desired access privilege type must evaluate to one of
    <literal>USAGE</literal>,
    <literal>SELECT</literal>, or
    <literal>UPDATE</literal>.
-->
<function>has_sequence_privilege</function>はユーザが特定の方法でシーケンスにアクセス可能かどうかを検査します。
取り得る引数は<function>has_table_privilege</function>に対するものと類似しています。
対象とする権限の種類は<literal>USAGE</literal>、<literal>SELECT</literal>または<literal>UPDATE</literal>のいずれかである必要があります。
   </para>

   <para>
<!--
    <function>has_any_column_privilege</function> checks whether a user can
    access any column of a table in a particular way.
    Its argument possibilities
    are analogous to <function>has_table_privilege</function>,
    except that the desired access privilege type must evaluate to some
    combination of
    <literal>SELECT</literal>,
    <literal>INSERT</literal>,
    <literal>UPDATE</literal>, or
    <literal>REFERENCES</literal>.  Note that having any of these privileges
    at the table level implicitly grants it for each column of the table,
    so <function>has_any_column_privilege</function> will always return
    <literal>true</literal> if <function>has_table_privilege</function> does for the same
    arguments.  But <function>has_any_column_privilege</function> also succeeds if
    there is a column-level grant of the privilege for at least one column.
-->
<function>has_any_column_privilege</function>はユーザが特定の方法でテーブルのどれか１つの列にアクセス可能かどうかを検査します。
取り得る引数は<function>has_table_privilege</function>に対するものと類似していますが、対象とする権限の種類が<literal>SELECT</literal>、<literal>INSERT</literal>、<literal>UPDATE</literal>、または<literal>REFERENCES</literal>の組み合わせである必要がある点を除きます。
テーブル単位でこれらの権限を所有することは、テーブルのそれぞれの列に対し暗黙的にそれらの権限を与えることになるため、<function>has_table_privilege</function>が<literal>真</literal>を返す場合は、同一の引数に対して<function>has_any_column_privilege</function>は常に<literal>真</literal>を返すということに注意して下さい。
しかし、少なくとも一つの列に対し権限の列単位の許可がある場合にも<function>has_any_column_privilege</function>は成功します。
   </para>

   <para>
<!--
    <function>has_column_privilege</function> checks whether a user
    can access a column in a particular way.
    Its argument possibilities
    are analogous to <function>has_table_privilege</function>,
    with the addition that the column can be specified either by name
    or attribute number.
    The desired access privilege type must evaluate to some combination of
    <literal>SELECT</literal>,
    <literal>INSERT</literal>,
    <literal>UPDATE</literal>, or
    <literal>REFERENCES</literal>.  Note that having any of these privileges
    at the table level implicitly grants it for each column of the table.
-->
<function>has_column_privilege</function>はユーザが特定の方法でテーブルのある列にもアクセス可能かどうかを検査します。
取り得る引数は<function>has_table_privilege</function>と類似していますが、名前または属性番号のいずれかで列の指定が追加されます。
対象とするアクセス権限の種類は<literal>SELECT</literal>、<literal>INSERT</literal>、<literal>UPDATE</literal>、または<literal>REFERENCES</literal>の組み合わせでなければなりません。
テーブル単位のこれらの権限を所有することは、テーブルのそれぞれの列に対し暗黙的にそれら権限を与えることに注意してください。
   </para>

   <para>
<!--
    <function>has_database_privilege</function> checks whether a user
    can access a database in a particular way.
    Its argument possibilities
    are analogous to <function>has_table_privilege</function>.
    The desired access privilege type must evaluate to some combination of
    <literal>CREATE</literal>,
    <literal>CONNECT</literal>,
    <literal>TEMPORARY</literal>, or
    <literal>TEMP</literal> (which is equivalent to
    <literal>TEMPORARY</literal>).
-->
<function>has_database_privilege</function>関数は、ユーザが特定の方法でデータベースにアクセス可能かどうかを検査します。
取り得る引数は、<function>has_table_privilege</function>に類似しています。
対象とするアクセス権限の種類は<literal>CREATE</literal>、<literal>CONNECT</literal>、<literal>TEMPORARY</literal>、または<literal>TEMP</literal>（<literal>TEMPORARY</literal>と同じ）の組み合わせである必要があります。
   </para>

   <para>
<!--
    <function>has_function_privilege</function> checks whether a user
    can access a function in a particular way.
    Its argument possibilities
    are analogous to <function>has_table_privilege</function>.
    When specifying a function by a text string rather than by OID,
    the allowed input is the same as for the <type>regprocedure</type> data type
    (see <xref linkend="datatype-oid"/>).
    The desired access privilege type must evaluate to
    <literal>EXECUTE</literal>.
    An example is:
-->
<function>has_function_privilege</function>関数は、ユーザが特定の方法で関数にアクセス可能かどうかを検査します。
取り得る引数は<function>has_table_privilege</function>と同じです。
関数をOIDではなくテキスト文字列で指定する場合、<type>regprocedure</type> データ型（<xref linkend="datatype-oid"/>を参照）と同じ入力が可能です。
対象とするアクセス権限の種類は<literal>EXECUTE</literal>である必要があります。
以下に例を示します。
<programlisting>
SELECT has_function_privilege('joeuser', 'myfunc(int, text)', 'execute');
</programlisting>
   </para>

   <para>
<!--
    <function>has_foreign_data_wrapper_privilege</function> checks whether a user
    can access a foreign-data wrapper in a particular way.
    Its argument possibilities
    are analogous to <function>has_table_privilege</function>.
    The desired access privilege type must evaluate to
    <literal>USAGE</literal>.
-->
<function>has_foreign_data_wrapper_privilege</function>関数は、ユーザが特定の方法で外部データラッパーにアクセス可能かどうかを検査します。
取り得る引数は<function>has_table_privilege</function>と同じです。
対象とするアクセス権限の種類は<literal>USAGE</literal>である必要があります。
   </para>

   <para>
<!--
    <function>has_language_privilege</function> checks whether a user
    can access a procedural language in a particular way.
    Its argument possibilities
    are analogous to <function>has_table_privilege</function>.
    The desired access privilege type must evaluate to
    <literal>USAGE</literal>.
-->
<function>has_language_privilege</function>関数は、ユーザが特定の方法で手続き言語にアクセス可能かどうかを検査します。
取り得る引数は、<function>has_table_privilege</function>に類似しています。
対象とするアクセス権限の種類は<literal>USAGE</literal>である必要があります。
   </para>

   <para>
<!--
    <function>has_schema_privilege</function> checks whether a user
    can access a schema in a particular way.
    Its argument possibilities
    are analogous to <function>has_table_privilege</function>.
    The desired access privilege type must evaluate to some combination of
    <literal>CREATE</literal> or
    <literal>USAGE</literal>.
-->
<function>has_schema_privilege</function>関数は、ユーザが特定の方法でスキーマにアクセス可能かどうかを検査します。
取り得る引数は、<function>has_table_privilege</function>に類似しています。
対象とするアクセス権限の種類は、<literal>CREATE</literal>もしくは<literal>USAGE</literal>の組み合わせである必要があります。
   </para>

   <para>
<!--
    <function>has_server_privilege</function> checks whether a user
    can access a foreign server in a particular way.
    Its argument possibilities
    are analogous to <function>has_table_privilege</function>.
    The desired access privilege type must evaluate to
    <literal>USAGE</literal>.

-->
<function>has_server_privilege</function>はユーザが特定の方法で外部サーバにアクセスできるかどうかを検査します。
取り得る引数は<function>has_table_privilege</function>に類似しています。
対象とするアクセス権限の種類は<literal>USAGE</literal>である必要があります。
   </para>

   <para>
<!--
    <function>has_tablespace_privilege</function> checks whether a user
    can access a tablespace in a particular way.
    Its argument possibilities
    are analogous to <function>has_table_privilege</function>.
    The desired access privilege type must evaluate to
    <literal>CREATE</literal>.
-->
<function>has_tablespace_privilege</function>関数は、ユーザが特定の方法でテーブル空間にアクセス可能かどうかを検査します。
取り得る引数は、<function>has_table_privilege</function>に類似しています。
対象とするアクセス権限の種類は、<literal>CREATE</literal>である必要があります。
   </para>

   <para>
<!--
    <function>has_type_privilege</function> checks whether a user
    can access a type in a particular way.
    Its argument possibilities
    are analogous to <function>has_table_privilege</function>.
    When specifying a type by a text string rather than by OID,
    the allowed input is the same as for the <type>regtype</type> data type
    (see <xref linkend="datatype-oid"/>).
    The desired access privilege type must evaluate to
    <literal>USAGE</literal>.
-->
<function>has_type_privilege</function>は、ユーザが型に特定の方法でアクセス可能かどうかを検査します。
取り得る引数は<function>has_table_privilege</function>に類似しています。
型をOIDではなくテキスト文字列で指定する場合、可能な入力は<type>regtype</type>データ型に対するものと同じです（<xref linkend="datatype-oid"/>参照）。
対象とするアクセス権限の種類は<literal>USAGE</literal>である必要があります。
   </para>

   <para>
<!--
    <function>pg_has_role</function> checks whether a user
    can access a role in a particular way.
    Its argument possibilities
    are analogous to <function>has_table_privilege</function>,
    except that <literal>public</literal> is not allowed as a user name.
    The desired access privilege type must evaluate to some combination of
    <literal>MEMBER</literal> or
    <literal>USAGE</literal>.
    <literal>MEMBER</literal> denotes direct or indirect membership in
    the role (that is, the right to do <command>SET ROLE</command>), while
    <literal>USAGE</literal> denotes whether the privileges of the role
    are immediately available without doing <command>SET ROLE</command>.
-->
<function>pg_has_role</function>は、ユーザが特定の方法でロールにアクセスできるかどうかを検査します。
取り得る引数については、<literal>public</literal>がユーザ名として使用不可であることを除き、<function>has_table_privilege</function>と類似しています。
対象とするアクセス権限の種類は、 <literal>MEMBER</literal>、<literal>USAGE</literal>の組み合わせである必要があります。
<literal>MEMBER</literal>は、ロールの直接または間接メンバ資格（つまり、<command>SET ROLE</command>を行う権限）を表します。一方、<literal>USAGE</literal>は、そのロール権限が<command>SET ROLE</command>をしなくてもすぐに利用できることを表します。
   </para>

   <para>
<!--
    <function>row_security_active</function> checks whether row level
    security is active for the specified table in the context of the
    <function>current_user</function> and environment. The table can
    be specified by name or by OID.
-->
<function>row_security_active</function>は<function>current_user</function>と現在の環境において、指定のテーブルで行単位セキュリティが有効かどうかを検査します。
テーブルは名前またはOIDで指定できます。
   </para>

  <para>
<!--
   <xref linkend="functions-aclitem-fn-table"/> shows the operators
   available for the <type>aclitem</type> type, which is the catalog
   representation of access privileges.  See <xref linkend="ddl-priv"/>
   for information about how to read access privilege values.
-->
アクセス権限のカタログ表現である<type>aclitem</type>型で利用可能な演算子を<xref linkend="functions-aclitem-fn-table"/>に示します。
アクセス権限値を解釈する方法に関する情報は<xref linkend="ddl-priv"/>をご覧ください。
  </para>

   <indexterm>
    <primary>acldefault</primary>
   </indexterm>
   <indexterm>
    <primary>aclitemeq</primary>
   </indexterm>
   <indexterm>
    <primary>aclcontains</primary>
   </indexterm>
   <indexterm>
    <primary>aclexplode</primary>
   </indexterm>
   <indexterm>
    <primary>makeaclitem</primary>
   </indexterm>

    <table id="functions-aclitem-op-table">
<!--
     <title><type>aclitem</type> Operators</title>
-->
     <title><type>aclitem</type>演算子</title>
     <tgroup cols="4">
      <thead>
       <row>
<!--
        <entry>Operator</entry>
        <entry>Description</entry>
        <entry>Example</entry>
        <entry>Result</entry>
-->
        <entry>演算子</entry>
        <entry>説明</entry>
        <entry>例</entry>
        <entry>結果</entry>
       </row>
      </thead>
      <tbody>

       <row>
        <entry> <literal>=</literal> </entry>
<!--
        <entry>equal</entry>
-->
        <entry>等しい</entry>
        <entry><literal>'calvin=r*w/hobbes'::aclitem = 'calvin=r*w*/hobbes'::aclitem</literal></entry>
        <entry><literal>f</literal></entry>
       </row>

       <row>
        <entry> <literal>@&gt;</literal> </entry>
<!--
        <entry>contains element</entry>
-->
        <entry>要素を含む</entry>
        <entry><literal>'{calvin=r*w/hobbes,hobbes=r*w*/postgres}'::aclitem[] @&gt; 'calvin=r*w/hobbes'::aclitem</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>~</literal> </entry>
<!--
        <entry>contains element</entry>
-->
        <entry>要素を含む</entry>
        <entry><literal>'{calvin=r*w/hobbes,hobbes=r*w*/postgres}'::aclitem[] ~ 'calvin=r*w/hobbes'::aclitem</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

      </tbody>
     </tgroup>
    </table>

   <para>
<!--
    <xref linkend="functions-aclitem-fn-table"/> shows some additional
    functions to manage the <type>aclitem</type> type.
-->
<xref linkend="functions-aclitem-fn-table"/>に<type>aclitem</type>型を管理する追加の関数を示します。
   </para>

   <table id="functions-aclitem-fn-table">
<!--
    <title><type>aclitem</type> Functions</title>
-->
    <title><type>aclitem</type>関数</title>
    <tgroup cols="3">
     <thead>
<!--
      <row><entry>Name</entry> <entry>Return Type</entry> <entry>Description</entry></row>
-->
      <row><entry>名称</entry> <entry>戻り型</entry> <entry>説明</entry></row>
     </thead>
     <tbody>
      <row>
       <entry><literal><function>acldefault</function>(<parameter>type</parameter>,
        <parameter>ownerId</parameter>)</literal></entry>
       <entry><type>aclitem[]</type></entry>
<!--
       <entry>get the default access privileges for an object belonging to <parameter>ownerId</parameter></entry>
-->
       <entry><parameter>ownerId</parameter>に所属するオブジェクトのデフォルトアクセス権限を得る</entry>
      </row>
      <row>
       <entry><literal><function>aclexplode</function>(<parameter>aclitem[]</parameter>)</literal></entry>
       <entry><type>setof record</type></entry>
<!--
       <entry>get <type>aclitem</type> array as tuples</entry>
-->
       <entry><type>aclitem</type>配列をタプルとして得る</entry>
      </row>
      <row>
       <entry><literal><function>makeaclitem</function>(<parameter>grantee</parameter>, <parameter>grantor</parameter>, <parameter>privilege</parameter>, <parameter>grantable</parameter>)</literal></entry>
       <entry><type>aclitem</type></entry>
<!--
       <entry>build an <type>aclitem</type> from input</entry>
-->
       <entry>入力から<type>aclitem</type>を構築する</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
<!--
    <function>acldefault</function> returns the built-in default access
    privileges for an object of type <parameter>type</parameter> belonging to
    role <parameter>ownerId</parameter>.  These represent the access
    privileges that will be assumed when an object's ACL entry is null.
    (The default access privileges are described in <xref linkend="ddl-priv"/>.)
    The <parameter>type</parameter> parameter is a <type>CHAR</type>: write
    'c' for <literal>COLUMN</literal>,
    'r' for <literal>TABLE</literal> and table-like objects,
    's' for <literal>SEQUENCE</literal>,
    'd' for <literal>DATABASE</literal>,
    'f' for <literal>FUNCTION</literal> or <literal>PROCEDURE</literal>,
    'l' for <literal>LANGUAGE</literal>,
    'L' for <literal>LARGE OBJECT</literal>,
    'n' for <literal>SCHEMA</literal>,
    't' for <literal>TABLESPACE</literal>,
    'F' for <literal>FOREIGN DATA WRAPPER</literal>,
    'S' for <literal>FOREIGN SERVER</literal>,
    or
    'T' for <literal>TYPE</literal> or <literal>DOMAIN</literal>.
-->
<function>acldefault</function>は<parameter>ownerId</parameter>ロールに所属する<parameter>type</parameter>型のオブジェクトの組み込みデフォルトアクセス権限を返します。
これらはオブジェクトのACLエントリがNULLの時に持つと見なされるアクセス権限を表現します。
（デフォルトアクセス権限は<xref linkend="ddl-priv"/>で説明されています。）
<parameter>type</parameter>パラメータは<type>CHAR</type>であり、'c'で<literal>COLUMN</literal>、'r'で<literal>TABLE</literal>およびテーブルに見えるオブジェクト、's'で<literal>SEQUENCE</literal>、'd'で<literal>DATABASE</literal>、'f'で<literal>FUNCTION</literal>あるいは<literal>PROCEDURE</literal>、'l'で<literal>LANGUAGE</literal>、'L'で<literal>LARGE OBJECT</literal>、'n'で<literal>SCHEMA</literal>、't'で<literal>TABLESPACE</literal>、'F'で<literal>FOREIGN DATA WRAPPER</literal>、'S'で<literal>FOREIGN SERVER</literal>、'T'で<literal>TYPE</literal>あるいは<literal>DOMAIN</literal>を表します。
   </para>

   <para>
<!--
    <function>aclexplode</function> returns an <type>aclitem</type> array
    as a set of rows. Output columns are grantor <type>oid</type>,
    grantee <type>oid</type> (<literal>0</literal> for <literal>PUBLIC</literal>),
    granted privilege as <type>text</type> (<literal>SELECT</literal>, ...)
    and whether the privilege is grantable as <type>boolean</type>.
    <function>makeaclitem</function> performs the inverse operation.
-->
<function>aclexplode</function>は行の集合として<type>aclitem</type>配列を返します。
出力列はアクセス権を与える側の<type>oid</type>、アクセス権を与えられる側の<type>oid</type>（<literal>0</literal>で<literal>PUBLIC</literal>を表します）、与えられた権限<type>text</type>（<literal>SELECT</literal>, ...）、権限が許可可能かどうかの<type>boolean</type>です。
<function>makeaclitem</function>は逆の操作を実行します。
   </para>

  <para>
<!--
   <xref linkend="functions-info-schema-table"/> shows functions that
   determine whether a certain object is <firstterm>visible</firstterm> in the
   current schema search path.
   For example, a table is said to be visible if its
   containing schema is in the search path and no table of the same
   name appears earlier in the search path.  This is equivalent to the
   statement that the table can be referenced by name without explicit
   schema qualification.  To list the names of all visible tables:
-->
<xref linkend="functions-info-schema-table"/>に、特定のオブジェクトが、現行スキーマの検索パスにおいて<firstterm>可視</firstterm>かどうかを判別する関数を示します。
例えば、あるテーブルを含むスキーマが検索パス内に存在し、検索パス内の前方に同じ名前のテーブルがない場合、そのテーブルは可視であると言います。
つまり、これは、テーブルが明示的なスキーマ修飾なしで名前によって参照可能であるということです。
全ての可視テーブルの名前を列挙するには以下のようにします。
<programlisting>
SELECT relname FROM pg_class WHERE pg_table_is_visible(oid);
</programlisting>
  </para>

   <indexterm>
<!--
    <primary>search path</primary>
    <secondary>object visibility</secondary>
-->
    <primary>検索パス</primary>
    <secondary>オブジェクトの可視性</secondary>
   </indexterm>

   <table id="functions-info-schema-table">
<!--
    <title>Schema Visibility Inquiry Functions</title>
-->
    <title>スキーマ可視性照会関数</title>
    <tgroup cols="3">
     <thead>
<!--
      <row><entry>Name</entry> <entry>Return Type</entry> <entry>Description</entry></row>
-->
      <row><entry>名前</entry> <entry>戻り型</entry> <entry>説明</entry></row>
     </thead>

     <tbody>
      <row>
       <entry><literal><function>pg_collation_is_visible(<parameter>collation_oid</parameter>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>is collation visible in search path</entry>
-->
       <entry>照合順序が検索パスにおいて可視かどうか</entry>
      </row>
      <row>
       <entry><literal><function>pg_conversion_is_visible(<parameter>conversion_oid</parameter>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>is conversion visible in search path</entry>
-->
       <entry>変換が検索パスにおいて可視かどうか</entry>
      </row>
      <row>
       <entry><literal><function>pg_function_is_visible(<parameter>function_oid</parameter>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>is function visible in search path</entry>
-->
       <entry>関数が検索パスにおいて可視であるか</entry>
      </row>
      <row>
       <entry><literal><function>pg_opclass_is_visible(<parameter>opclass_oid</parameter>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>is operator class visible in search path</entry>
-->
       <entry>演算子クラスが検索パスにおいて可視であるか</entry>
      </row>
      <row>
       <entry><literal><function>pg_operator_is_visible(<parameter>operator_oid</parameter>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>is operator visible in search path</entry>
-->
       <entry>演算子が検索パスにおいて可視であるか</entry>
      </row>
      <row>
       <entry><literal><function>pg_opfamily_is_visible(<parameter>opclass_oid</parameter>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>is operator family visible in search path</entry>
-->
       <entry>演算子族が検索パスにおいて可視であるか</entry>
      </row>
      <row>
       <entry><literal><function>pg_statistics_obj_is_visible(<parameter>stat_oid</parameter>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>is statistics object visible in search path</entry>
-->
       <entry>統計情報オブジェクトが検索パスにおいて可視であるか</entry>
      </row>
      <row>
       <entry><literal><function>pg_table_is_visible(<parameter>table_oid</parameter>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>is table visible in search path</entry>
-->
       <entry>テーブルが検索パスにおいて可視かどうか</entry>
      </row>
      <row>
       <entry><literal><function>pg_ts_config_is_visible(<parameter>config_oid</parameter>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>is text search configuration visible in search path</entry>
-->
       <entry>テキスト検索設定が検索パスにおいて可視かどうか</entry>
      </row>
      <row>
       <entry><literal><function>pg_ts_dict_is_visible(<parameter>dict_oid</parameter>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>is text search dictionary visible in search path</entry>
-->
       <entry>テキスト検索辞書が検索パスにおいて可視かどうか</entry>
      </row>
      <row>
       <entry><literal><function>pg_ts_parser_is_visible(<parameter>parser_oid</parameter>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>is text search parser visible in search path</entry>
-->
       <entry>テキスト検索パーサが検索パスにおいて可視かどうか</entry>
      </row>
      <row>
       <entry><literal><function>pg_ts_template_is_visible(<parameter>template_oid</parameter>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>is text search template visible in search path</entry>
-->
       <entry>テキスト検索テンプレートが検索パスにおいて可視かどうか</entry>
      </row>
      <row>
       <entry><literal><function>pg_type_is_visible(<parameter>type_oid</parameter>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>is type (or domain) visible in search path</entry>
-->
       <entry>型（またはドメイン）が検索パスにおいて可視かどうか</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <indexterm>
    <primary>pg_collation_is_visible</primary>
   </indexterm>
   <indexterm>
    <primary>pg_conversion_is_visible</primary>
   </indexterm>
   <indexterm>
    <primary>pg_function_is_visible</primary>
   </indexterm>
   <indexterm>
    <primary>pg_opclass_is_visible</primary>
   </indexterm>
   <indexterm>
    <primary>pg_operator_is_visible</primary>
   </indexterm>
   <indexterm>
    <primary>pg_opfamily_is_visible</primary>
   </indexterm>
   <indexterm>
    <primary>pg_statistics_obj_is_visible</primary>
   </indexterm>
   <indexterm>
    <primary>pg_table_is_visible</primary>
   </indexterm>
   <indexterm>
    <primary>pg_ts_config_is_visible</primary>
   </indexterm>
   <indexterm>
    <primary>pg_ts_dict_is_visible</primary>
   </indexterm>
   <indexterm>
    <primary>pg_ts_parser_is_visible</primary>
   </indexterm>
   <indexterm>
    <primary>pg_ts_template_is_visible</primary>
   </indexterm>
   <indexterm>
    <primary>pg_type_is_visible</primary>
   </indexterm>

   <para>
<!--
    Each function performs the visibility check for one type of database
    object.  Note that <function>pg_table_is_visible</function> can also be used
    with views, materialized views, indexes, sequences and foreign tables;
    <function>pg_function_is_visible</function> can also be used with
    procedures and aggregates;
    <function>pg_type_is_visible</function> can also be used with domains.
    For functions and operators, an object in
    the search path is visible if there is no object of the same name
    <emphasis>and argument data type(s)</emphasis> earlier in the path.  For operator
    classes, both name and associated index access method are considered.
-->
それぞれの関数はデータベースオブジェクトの１つの型に対して可視性の検査を行います。
<function>pg_table_is_visible</function>がビュー、マテリアライズドビュー、インデックス、シーケンス、外部テーブルに対しても使用できること、<function>pg_type_is_visible</function>がドメインに対しても使用できることに注意してください。
<function>pg_function_is_visible</function>は手続きと集約にも使えます。
関数および演算子では、パスの前方に同じ名前かつ同じ<emphasis>引数のデータ型</emphasis>を持つオブジェクトが存在しなければ、検索パス内のオブジェクトは可視です。
演算子クラスでは、名前と関連するインデックスアクセスメソッドが考慮されます。
   </para>

   <para>
<!--
    All these functions require object OIDs to identify the object to be
    checked.  If you want to test an object by name, it is convenient to use
    the OID alias types (<type>regclass</type>, <type>regtype</type>,
    <type>regprocedure</type>, <type>regoperator</type>, <type>regconfig</type>,
    or <type>regdictionary</type>),
    for example:
-->
これらの関数は全て、検査するオブジェクトを識別するために、オブジェクトのOIDを必要とします。
オブジェクトを名前でテストする場合、OID別名型（<type>regclass</type>、<type>regtype</type>、<type>regprocedure</type>、<type>regoperator</type>、<type>regconfig</type>、または<type>regdictionary</type>）を使用すると便利です。
例えば、以下のようにします。
<programlisting>
SELECT pg_type_is_visible('myschema.widget'::regtype);
</programlisting>
<!--
    Note that it would not make much sense to test a non-schema-qualified
    type name in this way &mdash; if the name can be recognized at all, it must be visible.
-->
ただし、このようなやり方でスキーマ修飾されていない型名をテストしても、あまり意味がないことに注意してください。名前が認識されれば、それは必ず可視ということになります。
   </para>

   <indexterm>
    <primary>format_type</primary>
   </indexterm>

   <indexterm>
    <primary>pg_get_constraintdef</primary>
   </indexterm>

   <indexterm>
    <primary>pg_get_expr</primary>
   </indexterm>

   <indexterm>
    <primary>pg_get_functiondef</primary>
   </indexterm>

   <indexterm>
    <primary>pg_get_function_arguments</primary>
   </indexterm>

   <indexterm>
    <primary>pg_get_function_identity_arguments</primary>
   </indexterm>

   <indexterm>
    <primary>pg_get_function_result</primary>
   </indexterm>

   <indexterm>
    <primary>pg_get_indexdef</primary>
   </indexterm>

   <indexterm>
    <primary>pg_get_keywords</primary>
   </indexterm>

   <indexterm>
    <primary>pg_get_ruledef</primary>
   </indexterm>

   <indexterm>
    <primary>pg_get_serial_sequence</primary>
   </indexterm>

   <indexterm>
    <primary>pg_get_statisticsobjdef</primary>
   </indexterm>

   <indexterm>
    <primary>pg_get_triggerdef</primary>
   </indexterm>

   <indexterm>
    <primary>pg_get_userbyid</primary>
   </indexterm>

   <indexterm>
    <primary>pg_get_viewdef</primary>
   </indexterm>

   <indexterm>
    <primary>pg_index_column_has_property</primary>
   </indexterm>

   <indexterm>
    <primary>pg_index_has_property</primary>
   </indexterm>

   <indexterm>
    <primary>pg_indexam_has_property</primary>
   </indexterm>

   <indexterm>
    <primary>pg_options_to_table</primary>
   </indexterm>

   <indexterm>
    <primary>pg_tablespace_databases</primary>
   </indexterm>

   <indexterm>
    <primary>pg_tablespace_location</primary>
   </indexterm>

   <indexterm>
    <primary>pg_typeof</primary>
   </indexterm>

   <indexterm>
    <primary>collation for</primary>
   </indexterm>

   <indexterm>
    <primary>to_regclass</primary>
   </indexterm>

   <indexterm>
    <primary>to_regproc</primary>
   </indexterm>

   <indexterm>
    <primary>to_regprocedure</primary>
   </indexterm>

   <indexterm>
    <primary>to_regoper</primary>
   </indexterm>

   <indexterm>
    <primary>to_regoperator</primary>
   </indexterm>

   <indexterm>
    <primary>to_regtype</primary>
   </indexterm>

   <indexterm>
    <primary>to_regnamespace</primary>
   </indexterm>

   <indexterm>
    <primary>to_regrole</primary>
   </indexterm>

  <para>
<!--
   <xref linkend="functions-info-catalog-table"/> lists functions that
   extract information from the system catalogs.
-->
<xref linkend="functions-info-catalog-table"/>に、システムカタログから情報を抽出する関数を列挙します。
  </para>

   <table id="functions-info-catalog-table">
<!--
    <title>System Catalog Information Functions</title>
-->
    <title>システムカタログ情報関数</title>
    <tgroup cols="3">
     <thead>
<!--
      <row><entry>Name</entry> <entry>Return Type</entry> <entry>Description</entry></row>
-->
      <row><entry>名前</entry> <entry>戻り型</entry> <entry>説明</entry></row>
     </thead>

     <tbody>
      <row>
       <entry><literal><function>format_type(<parameter>type_oid</parameter>, <parameter>typemod</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
<!--
       <entry>get SQL name of a data type</entry>
-->
       <entry>データ型のSQL名を取得</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_constraintdef(<parameter>constraint_oid</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
<!--
       <entry>get definition of a constraint</entry>
-->
       <entry>制約の定義を取得</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_constraintdef(<parameter>constraint_oid</parameter>, <parameter>pretty_bool</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
<!--
       <entry>get definition of a constraint</entry>
-->
       <entry>制約の定義を取得</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_expr(<parameter>pg_node_tree</parameter>, <parameter>relation_oid</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
<!--
       <entry>decompile internal form of an expression, assuming that any Vars
       in it refer to the relation indicated by the second parameter</entry>
-->
       <entry>式中のすべてのVarが２番目のパラメータによって指定されるリレーションを参照すると仮定して、式の内部形式を逆コンパイル</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_expr(<parameter>pg_node_tree</parameter>, <parameter>relation_oid</parameter>, <parameter>pretty_bool</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
<!--
       <entry>decompile internal form of an expression, assuming that any Vars
       in it refer to the relation indicated by the second parameter</entry>
-->
       <entry>式中のすべてのVarが２番目のパラメータによって指定されるリレーションを参照すると仮定して、式の内部形式を逆コンパイル</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_functiondef(<parameter>func_oid</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
<!--
       <entry>get definition of a function or procedure</entry>
-->
       <entry>関数あるいは手続きの定義の取得</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_function_arguments(<parameter>func_oid</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
<!--
       <entry>get argument list of function's or procedure's definition (with default values)</entry>
-->
       <entry>関数あるいは手続きの定義の引数リスト（デフォルト値付き）を取得</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_function_identity_arguments(<parameter>func_oid</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
<!--
       <entry>get argument list to identify a function or procedure (without default values)</entry>
-->
       <entry>関数あるいは手続きを特定するための引数リスト（デフォルト値なし）を取得</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_function_result(<parameter>func_oid</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
<!--
       <entry>get <literal>RETURNS</literal> clause for function (returns null for a procedure)</entry>
-->
       <entry>関数に対する<literal>RETURNS</literal>句の取得（プロシージャに対してはNULLを返します）</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_indexdef(<parameter>index_oid</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
<!--
       <entry>get <command>CREATE INDEX</command> command for index</entry>
-->
       <entry>インデックスに対する<command>CREATE INDEX</command>コマンドの取得</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_indexdef(<parameter>index_oid</parameter>, <parameter>column_no</parameter>, <parameter>pretty_bool</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
<!--
       <entry>get <command>CREATE INDEX</command> command for index,
       or definition of just one index column when
       <parameter>column_no</parameter> is not zero</entry>
-->
       <entry>インデックスに対する<command>CREATE INDEX</command>コマンドの取得、または<parameter>column_no</parameter>が非ゼロの場合は、１つのインデックス列のみの定義の取得</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_keywords()</function></literal></entry>
       <entry><type>setof record</type></entry>
<!--
       <entry>get list of SQL keywords and their categories</entry>
-->
       <entry>SQLキーワードとそれらの種類のリストを取得</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_ruledef(<parameter>rule_oid</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
<!--
       <entry>get <command>CREATE RULE</command> command for rule</entry>
-->
       <entry>ルールに対する<command>CREATE RULE</command>コマンドを取得</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_ruledef(<parameter>rule_oid</parameter>, <parameter>pretty_bool</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
<!--
       <entry>get <command>CREATE RULE</command> command for rule</entry>
-->
       <entry>ルールに対する<command>CREATE RULE</command>コマンドを取得</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_serial_sequence(<parameter>table_name</parameter>, <parameter>column_name</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
<!--
       <entry>get name of the sequence that a serial or identity column uses</entry>
-->
       <entry>SERIAL、またはIDENTITY列が使用するシーケンス名を取得</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_statisticsobjdef(<parameter>statobj_oid</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
<!--
       <entry>get <command>CREATE STATISTICS</command> command for extended statistics object</entry>
-->
       <entry>拡張統計情報オブジェクトの<command>CREATE STATISTICS</command>コマンドを取得</entry>
      </row>
      <row>
       <entry><function>pg_get_triggerdef</function>(<parameter>trigger_oid</parameter>)</entry>
       <entry><type>text</type></entry>
<!--
       <entry>get <command>CREATE [ CONSTRAINT ] TRIGGER</command> command for trigger</entry>
-->
       <entry>トリガに対する<command>CREATE [ CONSTRAINT ] TRIGGER</command>コマンドの取得</entry>
      </row>
      <row>
       <entry><function>pg_get_triggerdef</function>(<parameter>trigger_oid</parameter>, <parameter>pretty_bool</parameter>)</entry>
       <entry><type>text</type></entry>
<!--
       <entry>get <command>CREATE [ CONSTRAINT ] TRIGGER</command> command for trigger</entry>
-->
       <entry>トリガに対する<command>CREATE [ CONSTRAINT ] TRIGGER</command>コマンドの取得</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_userbyid(<parameter>role_oid</parameter>)</function></literal></entry>
       <entry><type>name</type></entry>
<!--
       <entry>get role name with given OID</entry>
-->
       <entry>与えられたOIDでロール名を取得</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_viewdef(<parameter>view_name</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
<!--
       <entry>get underlying <command>SELECT</command> command for view or materialized view (<emphasis>deprecated</emphasis>)</entry>
-->
       <entry>ビューまたはマテリアライズドビューの元になる<command>SELECT</command>コマンドを取得（<emphasis>廃止予定</emphasis>）</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_viewdef(<parameter>view_name</parameter>, <parameter>pretty_bool</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
<!--
       <entry>get underlying <command>SELECT</command> command for view or materialized view (<emphasis>deprecated</emphasis>)</entry>
-->
       <entry>ビューまたはマテリアライズドビューの元になる<command>SELECT</command>コマンドを取得（<emphasis>廃止予定</emphasis>）</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_viewdef(<parameter>view_oid</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
<!--
       <entry>get underlying <command>SELECT</command> command for view or materialized view</entry>
-->
       <entry>ビューまたはマテリアライズドビューの元になる<command>SELECT</command>コマンドを取得</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_viewdef(<parameter>view_oid</parameter>, <parameter>pretty_bool</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
<!--
       <entry>get underlying <command>SELECT</command> command for view or materialized view</entry>
-->
       <entry>ビューまたはマテリアライズドビューの元になる<command>SELECT</command>コマンドを取得</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_viewdef(<parameter>view_oid</parameter>, <parameter>wrap_column_int</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
<!--
       <entry>get underlying <command>SELECT</command> command for view or
              materialized view; lines with fields are wrapped to specified
              number of columns, pretty-printing is implied</entry>
-->
       <entry>ビューまたはマテリアライズドビューの元になる<command>SELECT</command>コマンドを取得。
       フィールドを含む行は指定された列数で折り返され、成形された表示が行われます。</entry>
      </row>
      <row>
       <entry><literal><function>pg_index_column_has_property(<parameter>index_oid</parameter>, <parameter>column_no</parameter>, <parameter>prop_name</parameter>)</function></literal></entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>test whether an index column has a specified property</entry>
-->
       <entry>インデックス列が指定の属性を持っているかどうか検査する</entry>
      </row>
      <row>
       <entry><literal><function>pg_index_has_property(<parameter>index_oid</parameter>, <parameter>prop_name</parameter>)</function></literal></entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>test whether an index has a specified property</entry>
-->
       <entry>インデックスが指定の属性を持っているかどうか検査する</entry>
      </row>
      <row>
       <entry><literal><function>pg_indexam_has_property(<parameter>am_oid</parameter>, <parameter>prop_name</parameter>)</function></literal></entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>test whether an index access method has a specified property</entry>
-->
       <entry>インデックスアクセスメソッドが指定の属性を持っているかどうか検査する</entry>
      </row>
      <row>
       <entry><literal><function>pg_options_to_table(<parameter>reloptions</parameter>)</function></literal></entry>
       <entry><type>setof record</type></entry>
<!--
       <entry>get the set of storage option name/value pairs</entry>
-->
       <entry>格納オプションの名前/値のペアのセットを取得</entry>
      </row>
      <row>
       <entry><literal><function>pg_tablespace_databases(<parameter>tablespace_oid</parameter>)</function></literal></entry>
       <entry><type>setof oid</type></entry>
<!--
       <entry>get the set of database OIDs that have objects in the tablespace</entry>
-->
       <entry>テーブル空間内にオブジェクトを所有するデータベースOID集合を取得</entry>
      </row>
      <row>
       <entry><literal><function>pg_tablespace_location(<parameter>tablespace_oid</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
<!--
       <entry>get the path in the file system that this tablespace is located in</entry>
-->
       <entry>指定したテーブル空間が実際に配置されているファイルシステム上のパスを取得</entry>
      </row>
      <row>
       <entry><literal><function>pg_typeof(<parameter>any</parameter>)</function></literal></entry>
       <entry><type>regtype</type></entry>
<!--
       <entry>get the data type of any value</entry>
-->
       <entry>指定した値のデータ型を取得</entry>
      </row>
      <row>
       <entry><literal><function>collation for (<parameter>any</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
<!--
       <entry>get the collation of the argument</entry>
-->
       <entry>引数の照合順序を取得</entry>
      </row>
      <row>
       <entry><literal><function>to_regclass(<parameter>rel_name</parameter>)</function></literal></entry>
       <entry><type>regclass</type></entry>
<!--
       <entry>get the OID of the named relation</entry>
-->
       <entry>指定のリレーションのOIDを取得</entry>

      </row>
      <row>
       <entry><literal><function>to_regproc(<parameter>func_name</parameter>)</function></literal></entry>
       <entry><type>regproc</type></entry>
<!--
       <entry>get the OID of the named function</entry>
-->
       <entry>指定の関数のOIDを取得</entry>
      </row>
      <row>
       <entry><literal><function>to_regprocedure(<parameter>func_name</parameter>)</function></literal></entry>
       <entry><type>regprocedure</type></entry>
<!--
       <entry>get the OID of the named function</entry>
-->
       <entry>指定の関数のOIDを取得</entry>
      </row>
      <row>
       <entry><literal><function>to_regoper(<parameter>operator_name</parameter>)</function></literal></entry>
       <entry><type>regoper</type></entry>
<!--
       <entry>get the OID of the named operator</entry>
-->
       <entry>指定の演算子のOIDを取得</entry>
      </row>
      <row>
       <entry><literal><function>to_regoperator(<parameter>operator_name</parameter>)</function></literal></entry>
       <entry><type>regoperator</type></entry>
<!--
       <entry>get the OID of the named operator</entry>
-->
       <entry>指定の演算子のOIDを取得</entry>
      </row>
      <row>
       <entry><literal><function>to_regtype(<parameter>type_name</parameter>)</function></literal></entry>
       <entry><type>regtype</type></entry>
<!--
       <entry>get the OID of the named type</entry>
-->
       <entry>指定の型のOIDを取得</entry>
      </row>
      <row>
       <entry><literal><function>to_regnamespace(<parameter>schema_name</parameter>)</function></literal></entry>
       <entry><type>regnamespace</type></entry>
<!--
       <entry>get the OID of the named schema</entry>
-->
       <entry>指定のスキーマのOIDを取得</entry>
      </row>
      <row>
       <entry><literal><function>to_regrole(<parameter>role_name</parameter>)</function></literal></entry>
       <entry><type>regrole</type></entry>
<!--
       <entry>get the OID of the named role</entry>
-->
       <entry>指定のロールのOIDを取得</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <para>
<!--
   <function>format_type</function> returns the SQL name of a data type that
   is identified by its type OID and possibly a type modifier.  Pass NULL
   for the type modifier if no specific modifier is known.
-->
関数<function>format_type</function>は、自身の型OIDと場合により型修飾子によって特定されるデータ型のSQL名を返します。
特定の修飾子が既知でなければ型修飾子にNULLを渡します。
  </para>

  <para>
<!--
   <function>pg_get_keywords</function> returns a set of records describing
   the SQL keywords recognized by the server. The <structfield>word</structfield> column
   contains the keyword.  The <structfield>catcode</structfield> column contains a
   category code: <literal>U</literal> for unreserved, <literal>C</literal> for column name,
   <literal>T</literal> for type or function name, or <literal>R</literal> for reserved.
   The <structfield>catdesc</structfield> column contains a possibly-localized string
   describing the category.
-->
関数<function>pg_get_keywords</function>は、サーバが認識したSQLキーワードを記述するレコードの集合を返します。
<structfield>word</structfield>列にはキーワードが含まれます。
<structfield>catcode</structfield>列は種類コードで、<literal>U</literal>は未予約(unreserved)、<literal>C</literal>は列名(column)、<literal>T</literal>は型名(type)または関数名、<literal>R</literal>は予約語(reserved)です。
<structfield>catdesc</structfield>列は種類を記述する文字列を含み、現地語化されている場合もあります。
  </para>

  <para>
<!--
   <function>pg_get_constraintdef</function>,
   <function>pg_get_indexdef</function>, <function>pg_get_ruledef</function>,
   <function>pg_get_statisticsobjdef</function>, and
   <function>pg_get_triggerdef</function>, respectively reconstruct the
   creating command for a constraint, index, rule, extended statistics object,
   or trigger. (Note that this is a decompiled reconstruction, not the
   original text of the command.) <function>pg_get_expr</function> decompiles
   the internal form of an individual expression, such as the default value
   for a column.  It can be useful when examining the contents of system
   catalogs.  If the expression might contain Vars, specify the OID of the
   relation they refer to as the second parameter; if no Vars are expected,
   zero is sufficient. <function>pg_get_viewdef</function> reconstructs the
   <command>SELECT</command> query that defines a view. Most of these functions come
   in two variants, one of which can optionally <quote>pretty-print</quote> the
   result.  The pretty-printed format is more readable, but the default format
   is more likely to be interpreted the same way by future versions of
   <productname>PostgreSQL</productname>; avoid using pretty-printed output for dump
   purposes.  Passing <literal>false</literal> for the pretty-print parameter yields
   the same result as the variant that does not have the parameter at all.
-->
<function>pg_get_constraintdef</function>、<function>pg_get_indexdef</function>、<function>pg_get_ruledef</function>、<function>pg_get_statisticsobjdef</function>、および<function>pg_get_triggerdef</function>はそれぞれ、制約、インデックス、ルール、拡張統計情報オブジェクト、もしくはトリガに対する作成コマンドを再構築します。
（これはコマンドの元々のテキストではなく、逆コンパイルにより再構築されたテキストであることに注意してください。）
<function>pg_get_expr</function>は、列のデフォルト値のような個々の式の内部形式を逆コンパイルします。
システムカタログの内容を試験するときに便利です。
式がVarを含んでいるかもしれない場合、２番目のパラメータとして参照する関連（リレーション）のOIDを指定します。Varがないと期待されるならゼロで充分です。
<function>pg_get_viewdef</function> はビューを定義する<command>SELECT</command>問い合わせを再構築します。
これらの関数のほとんどは２つの異形があり、そのうちの１つはオプションとして結果を<quote>見やすく表示</quote>します。
見やすく表示された書式はより読みやすい半面、デフォルトの書式の方が今後のバージョンの<productname>PostgreSQL</productname>でも同様に解釈することができそうです。ダンプを目的とする場合は、見やすく表示する出力を使用しないでください。
見やすい表示用のパラメータに<literal>false</literal>を渡すことで、このパラメータをまったく持たない種類の結果と同一の結果を生成します。
  </para>

  <para>
<!--
   <function>pg_get_functiondef</function> returns a complete
   <command>CREATE OR REPLACE FUNCTION</command> statement for a function.
   <function>pg_get_function_arguments</function> returns the argument list
   of a function, in the form it would need to appear in within
   <command>CREATE FUNCTION</command>.
   <function>pg_get_function_result</function> similarly returns the
   appropriate <literal>RETURNS</literal> clause for the function.
   <function>pg_get_function_identity_arguments</function> returns the
   argument list necessary to identify a function, in the form it
   would need to appear in within <command>ALTER FUNCTION</command>, for
   instance.  This form omits default values.
-->
<function>pg_get_functiondef</function>は、関数の完全な<command>CREATE OR REPLACE FUNCTION</command>文を返します。
<function>pg_get_function_arguments</function>は、<command>CREATE FUNCTION</command>の中に出現しなければならない形式で、引数リストを返します。
<function>pg_get_function_result</function>は同様、その関数の適切な<literal>RETURNS</literal>句を返します。
<function>pg_get_function_identity_arguments</function>は、例えば<command>ALTER FUNCTION</command>の中に出現しなければならない形式で、関数を特定するのに必要な引数リストを返します。
この形式はデフォルト値を省略します。
  </para>

  <para>
<!--
   <function>pg_get_serial_sequence</function> returns the name of the
   sequence associated with a column, or NULL if no sequence is associated
   with the column.  If the column is an identity column, the associated
   sequence is the sequence internally created for the identity column.  For
   columns created using one of the serial types
   (<type>serial</type>, <type>smallserial</type>, <type>bigserial</type>), it
   is the sequence created for that serial column definition.  In the latter
   case, this association can be modified or removed with <command>ALTER
   SEQUENCE OWNED BY</command>.  (The function probably should have been called
   <function>pg_get_owned_sequence</function>; its current name reflects the
   fact that it has typically been used with <type>serial</type>
   or <type>bigserial</type> columns.)  The first input parameter is a table name
   with optional schema, and the second parameter is a column name.  Because
   the first parameter is potentially a schema and table, it is not treated as
   a double-quoted identifier, meaning it is lower cased by default, while the
   second parameter, being just a column name, is treated as double-quoted and
   has its case preserved.  The function returns a value suitably formatted
   for passing to sequence functions
   (see <xref linkend="functions-sequence"/>).  A typical use is in reading the
   current value of a sequence for an identity or serial column, for example:
-->
<function>pg_get_serial_sequence</function>は、列に関連するシーケンスの名前を返します。
列に関連するシーケンスが存在しなければ、NULLを返します。
列がIDENTITY列の場合、関連するシーケンスはIDENTITY列に対して内部的に作成されたシーケンスとなります。
SERIAL型（<type>serial</type>、<type>smallserial</type>、<type>bigserial</type>）の一つを使って作られた列については、そのSERIAL列の定義に対して作られたシーケンスとなります。
後者の場合、この関連付けは<command>ALTER SEQUENCE OWNED BY</command>で修正または削除することができます。
（この関数はおそらく<function>pg_get_owned_sequence</function>と呼ばれるべきだったのでしょうが、現在の名前はそれが主に<type>serial</type>列または<type>bigserial</type>列と一緒に使われていたという事実によります。）
最初の入力パラメータはテーブル名で、スキーマを付けることもできます。
２番目のパラメータは列名です。
最初のパラメータは普通はスキーマとテーブルですので、二重引用符付の識別子としては解釈されません。
つまり、デフォルトで小文字に変換されます。
一方２番目のパラメータは単なる列名であり、二重引用符付として解釈され、その大文字小文字は保持されます。
この関数は、シーケンス関数（<xref linkend="functions-sequence"/>を参照）に渡すことができるよう適切な書式で値を返します。
典型的な使用法はIDENITY列またはSERIAL列のシーケンスの現在値を読み取ることで、例えば
<programlisting>
SELECT currval(pg_get_serial_sequence('sometable', 'id'));
</programlisting>
  </para>

  <para>
<!--
   <function>pg_get_userbyid</function> extracts a role's name given
   its OID.
-->
<function>pg_get_userbyid</function>はそのOIDで与えられたロールの名前を抽出します。
  </para>

  <para>
<!--
   <function>pg_index_column_has_property</function>,
   <function>pg_index_has_property</function>, and
   <function>pg_indexam_has_property</function> return whether the
   specified index column, index, or index access method possesses the named
   property. <literal>NULL</literal> is returned if the property name is not
   known or does not apply to the particular object, or if the OID or column
   number does not identify a valid object.  Refer to
   <xref linkend="functions-info-index-column-props"/> for column properties,
   <xref linkend="functions-info-index-props"/> for index properties, and
   <xref linkend="functions-info-indexam-props"/> for access method properties.
   (Note that extension access methods can define additional property names
   for their indexes.)
-->
<function>pg_index_column_has_property</function>、<function>pg_index_has_property</function>、<function>pg_indexam_has_property</function>は指定のインデックス列、インデックス、あるいはインデックスアクセスメソッドが、指定の属性を所有しているかどうかを返します。
属性名が不明の場合、属性がその特定のオブジェクトに当てはまらない場合、OIDや列番号が有効なオブジェクトを特定できない場合は<literal>NULL</literal>が返されます。
列の属性については<xref linkend="functions-info-index-column-props"/>、インデックスの属性については<xref linkend="functions-info-index-props"/>、アクセスメソッドの属性については<xref linkend="functions-info-indexam-props"/>を参照して下さい。
（拡張のアクセスメソッドはそのインデックスについて追加の属性名を定義できることに注意して下さい。）
  </para>

  <table id="functions-info-index-column-props">
<!--
   <title>Index Column Properties</title>
-->
   <title>インデックス列の属性</title>
   <tgroup cols="2">
    <thead>
<!--
     <row><entry>Name</entry><entry>Description</entry></row>
-->
     <row><entry>名前</entry><entry>説明</entry></row>
    </thead>
    <tbody>
     <row>
      <entry><literal>asc</literal></entry>
<!--
      <entry>Does the column sort in ascending order on a forward scan?
-->
      <entry>前方スキャンで列は昇順にソートされるか
      </entry>
     </row>
     <row>
      <entry><literal>desc</literal></entry>
<!--
      <entry>Does the column sort in descending order on a forward scan?
-->
      <entry>前方スキャンで列は降順にソートされるか
      </entry>
     </row>
     <row>
      <entry><literal>nulls_first</literal></entry>
<!--
      <entry>Does the column sort with nulls first on a forward scan?
-->
      <entry>前方スキャンで列はNULLを先頭にしてソートするか
      </entry>
     </row>
     <row>
      <entry><literal>nulls_last</literal></entry>
<!--
      <entry>Does the column sort with nulls last on a forward scan?
-->
      <entry>前方スキャンで列はNULLを最後にしてソートするか
      </entry>
     </row>
     <row>
      <entry><literal>orderable</literal></entry>
<!--
      <entry>Does the column possess any defined sort ordering?
-->
      <entry>列は定義済みのソート順を所有しているか
      </entry>
     </row>
     <row>
      <entry><literal>distance_orderable</literal></entry>
<!--
      <entry>Can the column be scanned in order by a <quote>distance</quote>
      operator, for example <literal>ORDER BY col &lt;-&gt; constant</literal> ?
-->
      <entry>列は<quote>距離</quote>の演算子の順序に従ってスキャンできるか、例えば<literal>ORDER BY col &lt;-&gt; 定数</literal>など
      </entry>
     </row>
     <row>
      <entry><literal>returnable</literal></entry>
<!--
      <entry>Can the column value be returned by an index-only scan?
-->
      <entry>列の値をインデックスオンリースキャンで返すことができるか
      </entry>
     </row>
     <row>
      <entry><literal>search_array</literal></entry>
<!--
      <entry>Does the column natively support <literal>col = ANY(array)</literal>
      searches?
-->
      <entry>列は<literal>col = ANY(array)</literal>の検索をネイティブにサポートしているか
      </entry>
     </row>
     <row>
      <entry><literal>search_nulls</literal></entry>
<!--
      <entry>Does the column support <literal>IS NULL</literal> and
      <literal>IS NOT NULL</literal> searches?
-->
      <entry>列は<literal>IS NULL</literal>および<literal>IS NOT NULL</literal>の検索をサポートしているか
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <table id="functions-info-index-props">
<!--
   <title>Index Properties</title>
-->
   <title>インデックスの属性</title>
   <tgroup cols="2">
    <thead>
<!--
     <row><entry>Name</entry><entry>Description</entry></row>
-->
     <row><entry>名前</entry><entry>説明</entry></row>
    </thead>
    <tbody>
     <row>
      <entry><literal>clusterable</literal></entry>
<!--
      <entry>Can the index be used in a <literal>CLUSTER</literal> command?
-->
      <entry>インデックスを<literal>CLUSTER</literal>コマンドで使うことができるか
      </entry>
     </row>
     <row>
      <entry><literal>index_scan</literal></entry>
<!--
      <entry>Does the index support plain (non-bitmap) scans?
-->
      <entry>インデックスは通常の（ビットマップでない）スキャンをサポートしているか
      </entry>
     </row>
     <row>
      <entry><literal>bitmap_scan</literal></entry>
<!--
      <entry>Does the index support bitmap scans?
-->
      <entry>インデックスはビットマップスキャンをサポートしているか
      </entry>
     </row>
     <row>
      <entry><literal>backward_scan</literal></entry>
<!--
      <entry>Can the scan direction be changed in mid-scan (to
             support <literal>FETCH BACKWARD</literal> on a cursor without
             needing materialization)?
-->
      <entry>スキャンの途中でスキャン方向を変更できるか（マテリアライゼーションを必要とせずにカーソルの <literal>FETCH BACKWARD</literal>をサポートするため）
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <table id="functions-info-indexam-props">
<!--
   <title>Index Access Method Properties</title>
-->
   <title>インデックスアクセスメソッドの属性</title>
   <tgroup cols="2">
    <thead>
<!--
     <row><entry>Name</entry><entry>Description</entry></row>
-->
     <row><entry>名前</entry><entry>説明</entry></row>
    </thead>
    <tbody>
     <row>
      <entry><literal>can_order</literal></entry>
<!--
      <entry>Does the access method support <literal>ASC</literal>,
      <literal>DESC</literal> and related keywords in
      <literal>CREATE INDEX</literal>?
-->
      <entry>アクセスメソッドは<literal>CREATE INDEX</literal>において<literal>ASC</literal>、<literal>DESC</literal>および関連するキーワードをサポートしているか
      </entry>
     </row>
     <row>
      <entry><literal>can_unique</literal></entry>
<!--
      <entry>Does the access method support unique indexes?
-->
      <entry>アクセスメソッドは一意インデックスをサポートしているか
      </entry>
     </row>
     <row>
      <entry><literal>can_multi_col</literal></entry>
<!--
      <entry>Does the access method support indexes with multiple columns?
-->
      <entry>アクセスメソッドは複数列にまたがるインデックスをサポートしているか
      </entry>
     </row>
     <row>
      <entry><literal>can_exclude</literal></entry>
<!--
      <entry>Does the access method support exclusion constraints?
-->
      <entry>アクセスメソッドは除外制約をサポートしているか
      </entry>
     </row>
     <row>
      <entry><literal>can_include</literal></entry>
<!--
      <entry>Does the access method support the <literal>INCLUDE</literal>
        clause of <literal>CREATE INDEX</literal>?
      </entry>
-->
      <entry>アクセスメソッドが<literal>CREATE INDEX</literal>の<literal>INCLUDE</literal>句をサポートしているか</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
<!--
   <function>pg_options_to_table</function> returns the set of storage
   option name/value pairs
   (<replaceable>option_name</replaceable>/<replaceable>option_value</replaceable>) when passed
   <structname>pg_class</structname>.<structfield>reloptions</structfield> or
   <structname>pg_attribute</structname>.<structfield>attoptions</structfield>.
-->
<function>pg_options_to_table</function>は、<structname>pg_class</structname>.<structfield>reloptions</structfield>または<structname>pg_attribute</structname>.<structfield>attoptions</structfield>が渡されたときに、格納オプションの名前と値のペア(<replaceable>option_name</replaceable>/<replaceable>option_value</replaceable>)の集合を返します。
  </para>

  <para>
<!--
   <function>pg_tablespace_databases</function> allows a tablespace to be
   examined. It returns the set of OIDs of databases that have objects stored
   in the tablespace. If this function returns any rows, the tablespace is not
   empty and cannot be dropped. To display the specific objects populating the
   tablespace, you will need to connect to the databases identified by
   <function>pg_tablespace_databases</function> and query their
   <structname>pg_class</structname> catalogs.
-->
<function>pg_tablespace_databases</function>によりテーブル空間を調べることができ
ます。
これは、そのテーブル空間内に格納されたオブジェクトを持つデータベースのOIDの集合を返します。
この関数が何らかの行を返した場合、このテーブル空間は空ではなく、削除することがで
きません。
テーブル空間内に格納された特定のオブジェクトを表示するためには、<function>pg_tablespace_databases</function>で識別されたデータベースに接続し、その<structname>pg_class</structname>カタログに問い合わせを行う必要があります。
  </para>

  <para>
<!--
   <function>pg_typeof</function> returns the OID of the data type of the
   value that is passed to it.  This can be helpful for troubleshooting or
   dynamically constructing SQL queries.  The function is declared as
   returning <type>regtype</type>, which is an OID alias type (see
   <xref linkend="datatype-oid"/>); this means that it is the same as an
   OID for comparison purposes but displays as a type name.  For example:
-->
<function>pg_typeof</function>は、渡される値のデータ型のOIDを返します。
これはトラブル解決作業、または動的にSQL問い合わせを生成するのに便利です。
この関数は、OID型の別名である<type>regtype</type>を返すものとして宣言されます（<xref linkend="datatype-oid"/>を参照）。つまり、比較が目的ならOIDと同一ですが、型名として表示されます。
以下に例をあげます。
<programlisting>
SELECT pg_typeof(33);

 pg_typeof 
-----------
 integer
(1 row)

SELECT typlen FROM pg_type WHERE oid = pg_typeof(33);
 typlen 
--------
      4
(1 row)
</programlisting>
  </para>

  <para>
<!--
   The expression <literal>collation for</literal> returns the collation of the
   value that is passed to it.  Example:
-->
<literal>collation for</literal>式は、それに渡された値の照合順序を返します。
例を示します。
<programlisting>
SELECT collation for (description) FROM pg_description LIMIT 1;
 pg_collation_for 
------------------
 "default"
(1 row)

SELECT collation for ('foo' COLLATE "de_DE");
 pg_collation_for 
------------------
 "de_DE"
(1 row)
</programlisting>
<!--
  The value might be quoted and schema-qualified.  If no collation is derived
  for the argument expression, then a null value is returned.  If the argument
  is not of a collatable data type, then an error is raised.
-->
値には引用符が付けられ、またはスキーマ修飾されることがあります。
もし引数の式から何も照合順序が得られなかった場合、NULLが返されます。
もし引数が照合順序をサポートしないデータ型だった場合、エラーとなります。
  </para>

  <para>
<!--
   The <function>to_regclass</function>, <function>to_regproc</function>,
   <function>to_regprocedure</function>, <function>to_regoper</function>,
   <function>to_regoperator</function>, <function>to_regtype</function>,
   <function>to_regnamespace</function>, and <function>to_regrole</function>
   functions translate relation, function, operator, type, schema, and role
   names (given as <type>text</type>) to objects of
   type <type>regclass</type>, <type>regproc</type>, <type>regprocedure</type>,
   <type>regoper</type>, <type>regoperator</type>, <type>regtype</type>,
   <type>regnamespace</type>, and <type>regrole</type>
   respectively.  These functions differ from a cast from
   text in that they don't accept a numeric OID, and that they return null
   rather than throwing an error if the name is not found (or, for
   <function>to_regproc</function> and <function>to_regoper</function>, if
   the given name matches multiple objects).
-->
<function>to_regclass</function>、<function>to_regproc</function>、<function>to_regprocedure</function>、<function>to_regoper</function>、<function>to_regoperator</function>、<function>to_regtype</function>、<function>to_regnamespace</function>、<function>to_regrole</function>関数はリレーション、関数、演算子、型、スキーマ、ロールの名前（<type>text</type>として渡されます）をそれぞれ<type>regclass</type>、<type>regproc</type>、<type>regprocedure</type>、<type>regoper</type>、<type>regoperator</type>、<type>regtype</type>、<type>regnamespace</type>、<type>regrole</type>型のオブジェクトに変換します。
数値OIDを受け付けず、名前が見つからない(もしくは、<function>to_regproc</function>と<function>to_regoper</function>では、与えられた名前が複数のオブジェクトに一致する)場合にはエラーを発生するのではなくnullを返すという点で、これらの関数はテキストからのキャストとは異なります。
  </para>

   <indexterm>
    <primary>pg_describe_object</primary>
   </indexterm>

   <indexterm>
    <primary>pg_identify_object</primary>
   </indexterm>

   <indexterm>
    <primary>pg_identify_object_as_address</primary>
   </indexterm>

   <indexterm>
    <primary>pg_get_object_address</primary>
   </indexterm>

  <para>
<!--
   <xref linkend="functions-info-object-table"/> lists functions related to
   database object identification and addressing.
-->
<xref linkend="functions-info-object-table"/>にデータベースオブジェクトの識別とアドレスに関連する関数を示します。
  </para>

   <table id="functions-info-object-table">
<!--
    <title>Object Information and Addressing Functions</title>
-->
    <title>オブジェクト情報とアドレスの関数</title>
    <tgroup cols="3">
     <thead>
<!--
      <row><entry>Name</entry> <entry>Return Type</entry> <entry>Description</entry></row>
-->
      <row><entry>名前</entry> <entry>戻り型</entry> <entry>説明</entry></row>
     </thead>

     <tbody>
      <row>
       <entry><literal><function>pg_describe_object(<parameter>classid</parameter> <type>oid</type>, <parameter>objid</parameter> <type>oid</type>, <parameter>objsubid</parameter> <type>integer</type>)</function></literal></entry>
       <entry><type>text</type></entry>
<!--
       <entry>get description of a database object</entry>
-->
       <entry>データベースオブジェクトの説明の取得</entry>
      </row>
      <row>
       <entry><literal><function>pg_identify_object(<parameter>classid</parameter> <type>oid</type>, <parameter>objid</parameter> <type>oid</type>, <parameter>objsubid</parameter> <type>integer</type>)</function></literal></entry>
       <entry><parameter>type</parameter> <type>text</type>, <parameter>schema</parameter> <type>text</type>, <parameter>name</parameter> <type>text</type>, <parameter>identity</parameter> <type>text</type></entry>
<!--
       <entry>get identity of a database object</entry>
-->
       <entry>データベースオブジェクトの識別の取得</entry>
      </row>
      <row>
       <entry><literal><function>pg_identify_object_as_address(<parameter>classid</parameter> <type>oid</type>, <parameter>objid</parameter> <type>oid</type>, <parameter>objsubid</parameter> <type>integer</type>)</function></literal></entry>
       <entry><parameter>type</parameter> <type>text</type>, <parameter>object_names</parameter> <type>text[]</type>, <parameter>object_args</parameter> <type>text[]</type></entry>
<!--
       <entry>get external representation of a database object's address</entry>
-->
       <entry>データベースオブジェクトのアドレスの外部表現を取得</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_object_address(<parameter>type</parameter> <type>text</type>, <parameter>object_names</parameter> <type>text[]</type>, <parameter>object_args</parameter> <type>text[]</type>)</function></literal></entry>
       <entry><parameter>classid</parameter> <type>oid</type>, <parameter>objid</parameter> <type>oid</type>, <parameter>objsubid</parameter> <type>integer</type></entry>
<!--
       <entry>get address of a database object from its external representation</entry>
-->
       <entry>データベースオブジェクトのアドレスの外部表現から、アドレスを取得</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <para>
<!--
   <function>pg_describe_object</function> returns a textual description of a database
   object specified by catalog OID, object OID, and sub-object ID (such as
   a column number within a table; the sub-object ID is zero when referring
   to a whole object).
   This description is intended to be human-readable, and might be translated,
   depending on server configuration.
   This is useful to determine the identity of an object as stored in the
   <structname>pg_depend</structname> catalog.
-->
<function>pg_describe_object</function>はカタログOID、オブジェクトOID、もしくはサブオブジェクトOID（たとえばテーブル中の列番号。オブジェクト全体を参照している場合は0）で指定されたデータベースオブジェクトのテキストによる説明を返します。
この説明はサーバの設定に依存しますが、人が読んでわかる、そして翻訳も可能になることを目的としたのもです。
これは<structname>pg_depend</structname>カタログに格納されたオブジェクトの識別判断の際に有用です。
  </para>

  <para>
<!--
   <function>pg_identify_object</function> returns a row containing enough information
   to uniquely identify the database object specified by catalog OID, object OID and
   sub-object ID.  This information is intended to be machine-readable,
   and is never translated.
   <parameter>type</parameter> identifies the type of database object;
   <parameter>schema</parameter> is the schema name that the object belongs in, or
   <literal>NULL</literal> for object types that do not belong to schemas;
   <parameter>name</parameter> is the name of the object, quoted if necessary,
   if the name (along with schema name, if pertinent) is sufficient to
   uniquely identify the object, otherwise <literal>NULL</literal>;
   <parameter>identity</parameter> is the complete object identity, with the
   precise format depending on object type, and each name within the format
   being schema-qualified and quoted as necessary.
-->
<function>pg_identify_object</function>はカタログOID、オブジェクトOID、そしてサブオブジェクトIDにより指定されるデータベースオブジェクトを一意に特定するために十分な情報を含む行を返します。
この情報は機械による読み取りを目的としており、決して翻訳されません。
<parameter>type</parameter>はデータベースオブジェクトの型を識別するものです。
<parameter>schema</parameter>はオブジェクトが所属するスキーマの名前ですが、スキーマに所属しないオブジェクト型の場合は<literal>NULL</literal>になります。
<parameter>name</parameter>は（必要なら引用符で括った）オブジェクトの名前ですが、（適切ならスキーマ名と合わせて）オブジェクトの一意識別子として使用できる場合にのみ指定し、それ以外の場合は<literal>NULL</literal>にします。
<parameter>identity</parameter>は完全なオブジェクトの識別で、オブジェクトの型に依存した正確なフォーマットを持っています。
フォーマット内の各部分はスキーマ修飾されており、必要に応じて引用符で括られます。
  </para>

  <para>
<!--
   <function>pg_identify_object_as_address</function> returns a row containing
   enough information to uniquely identify the database object specified by
   catalog OID, object OID and sub-object ID.  The returned
   information is independent of the current server, that is, it could be used
   to identify an identically named object in another server.
   <parameter>type</parameter> identifies the type of database object;
   <parameter>object_names</parameter> and <parameter>object_args</parameter>
   are text arrays that together form a reference to the object.
   These three values can be passed to
   <function>pg_get_object_address</function> to obtain the internal address
   of the object.
   This function is the inverse of <function>pg_get_object_address</function>.
-->
<function>pg_identify_object_as_address</function>はカタログOID、オブジェクトOID、そしてサブオブジェクトIDにより指定されるデータベースオブジェクトを一意に特定するために充分な情報を含む行を返します。
返される情報は現在のサーバに依存しません。
つまり、他のサーバで全く同じ名前を付けられたオブジェクトを識別するために使うことができます。
<parameter>type</parameter>はデータベースオブジェクトの型を識別するものです。
<parameter>object_names</parameter>と<parameter>object_args</parameter>は文字列の配列で、それらが組み合わされてオブジェクトへの参照を構成します。
これらの3つの値は、オブジェクトの内部アドレスを取得するために<function>pg_get_object_address</function>に渡すことができます。
この関数は<function>pg_get_object_address</function>の逆関数です。
  </para>

  <para>
<!--
   <function>pg_get_object_address</function> returns a row containing enough
   information to uniquely identify the database object specified by its
   type and object name and argument arrays.  The returned values are the
   ones that would be used in system catalogs such as <structname>pg_depend</structname>
   and can be passed to other system functions such as
   <function>pg_identify_object</function> or <function>pg_describe_object</function>.
   <parameter>classid</parameter> is the OID of the system catalog containing the
   object;
   <parameter>objid</parameter> is the OID of the object itself, and
   <parameter>objsubid</parameter> is the sub-object ID, or zero if none.
   This function is the inverse of <function>pg_identify_object_as_address</function>.
-->
<function>pg_get_object_address</function>は、型、オブジェクト名および引数の配列で指定されたデータベースオブジェクトを一意に特定するために十分な情報を含む行を返します。
返される値は、<structname>pg_depend</structname>などのシステムカタログで使用されるもので、<function>pg_identify_object</function>や<function>pg_describe_object</function>など他のシステム関数に渡すことができます。
<parameter>classid</parameter>はオブジェクトを含むシステムカタログのOIDです。
<parameter>objid</parameter>はオブジェクト自体のOIDです。
<parameter>objsubid</parameter>はオブジェクトのサブID、なければ0です。
この関数は<function>pg_identify_object_as_address</function>の逆関数です。
  </para>

   <indexterm>
    <primary>col_description</primary>
   </indexterm>

   <indexterm>
    <primary>obj_description</primary>
   </indexterm>

   <indexterm>
    <primary>shobj_description</primary>
   </indexterm>

   <indexterm>
<!--
    <primary>comment</primary>
    <secondary sortas="database objects">about database objects</secondary>
-->
    <primary>コメント</primary>
    <secondary sortas="database objects">データベースオブジェクトについて</secondary>
   </indexterm>

   <para>
<!--
    The functions shown in <xref linkend="functions-info-comment-table"/>
    extract comments previously stored with the <xref linkend="sql-comment"/>
    command.  A null value is returned if no
    comment could be found for the specified parameters.
-->
<xref linkend="functions-info-comment-table"/>に示される関数は、<xref linkend="sql-comment"/>コマンドによって以前に保存されたコメントを抽出します。
指定されたパラメータに対するコメントが存在しない場合、NULL値が返されます。
   </para>

   <table id="functions-info-comment-table">
<!--
    <title>Comment Information Functions</title>
-->
    <title>コメント情報関数</title>
    <tgroup cols="3">
     <thead>
<!--
      <row><entry>Name</entry> <entry>Return Type</entry> <entry>Description</entry></row>
-->
      <row><entry>名前</entry> <entry>戻り型</entry> <entry>説明</entry></row>
     </thead>

     <tbody>
      <row>
       <entry><literal><function>col_description(<parameter>table_oid</parameter>, <parameter>column_number</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
<!--
       <entry>get comment for a table column</entry>
-->
       <entry>テーブル列のコメントを取得</entry>
      </row>
      <row>
       <entry><literal><function>obj_description(<parameter>object_oid</parameter>, <parameter>catalog_name</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
<!--
       <entry>get comment for a database object</entry>
-->
       <entry>データベースオブジェクトのコメントを取得</entry>
      </row>
      <row>
       <entry><literal><function>obj_description(<parameter>object_oid</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
<!--
       <entry>get comment for a database object (<emphasis>deprecated</emphasis>)</entry>
-->
       <entry>データベースオブジェクトのコメントを取得（<emphasis>廃止予定</emphasis>）</entry>
      </row>
      <row>
       <entry><literal><function>shobj_description(<parameter>object_oid</parameter>, <parameter>catalog_name</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
<!--
       <entry>get comment for a shared database object</entry>
-->
       <entry>共有データベースオブジェクトのコメントを取得</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
<!--
    <function>col_description</function> returns the comment for a table
    column, which is specified by the OID of its table and its column number.
    (<function>obj_description</function> cannot be used for table columns
    since columns do not have OIDs of their own.)
-->
<function>col_description()</function>関数は、テーブルのOIDとその列番号で指定されるテーブルの列のコメントを返します。
（<function>obj_description()</function>関数は、テーブル列自体がOIDを所有していませんので、テーブル列に対して使用することはできません。）
   </para>

   <para>
<!--
    The two-parameter form of <function>obj_description</function> returns the
    comment for a database object specified by its OID and the name of the
    containing system catalog.  For example,
    <literal>obj_description(123456,'pg_class')</literal>
    would retrieve the comment for the table with OID 123456.
    The one-parameter form of <function>obj_description</function> requires only
    the object OID.  It is deprecated since there is no guarantee that
    OIDs are unique across different system catalogs; therefore, the wrong
    comment might be returned.
-->
<function>obj_description()</function>関数の２つのパラメータを取る形式はそのOIDと保有しているシステムカタログの名前で指定されたデータベースオブジェクトのコメントを返します。
例えば、<literal>obj_description(123456,'pg_class')</literal>はOID 123456を持つテーブルのコメントを抽出します。
<function>obj_description()</function>関数の単一パラメータ形式はオブジェクトのOIDのみ必要とします。
異なったシステムカタログに渡ってOIDが一意である保証はないことから廃止予定です。従って、間違ったコメントが返ることがあります。
   </para>

   <para>
<!--
    <function>shobj_description</function> is used just like
    <function>obj_description</function> except it is used for retrieving
    comments on shared objects.  Some system catalogs are global to all
    databases within each cluster, and the descriptions for objects in them
    are stored globally as well.
-->
<function>shobj_description</function>は、共有オブジェクトのコメント取得のために使用されることを除いて、<function>obj_description</function>と同じように使用されます。
一部のシステムカタログは、各クラスタ内のデータベース全体に対して大域的です。これらのコメントも同様に大域的に格納されます。
   </para>

   <indexterm>
    <primary>txid_current</primary>
   </indexterm>

   <indexterm>
    <primary>txid_current_if_assigned</primary>
   </indexterm>

   <indexterm>
    <primary>txid_current_snapshot</primary>
   </indexterm>

   <indexterm>
    <primary>txid_snapshot_xip</primary>
   </indexterm>

   <indexterm>
    <primary>txid_snapshot_xmax</primary>
   </indexterm>

   <indexterm>
    <primary>txid_snapshot_xmin</primary>
   </indexterm>

   <indexterm>
    <primary>txid_visible_in_snapshot</primary>
   </indexterm>

   <indexterm>
    <primary>txid_status</primary>
   </indexterm>

   <para>
<!--
    The functions shown in <xref linkend="functions-txid-snapshot"/>
    provide server transaction information in an exportable form.  The main
    use of these functions is to determine which transactions were committed
    between two snapshots.
-->
<xref linkend="functions-txid-snapshot"/>で示される関数はサーバトランザクション情報をエクスポートできる形式で提供します。
これら関数の主な使用目的は２つのスナップショット間でどちらのトランザクションがコミットされたのかを特定するためです。
   </para>

   <table id="functions-txid-snapshot">
<!--
    <title>Transaction IDs and Snapshots</title>
-->
    <title>トランザクションIDとスナップショット</title>
    <tgroup cols="3">
     <thead>
<!--
      <row><entry>Name</entry> <entry>Return Type</entry> <entry>Description</entry></row>
-->
      <row><entry>名前</entry> <entry>戻り型</entry> <entry>説明</entry></row>
     </thead>

     <tbody>
      <row>
       <entry><literal><function>txid_current()</function></literal></entry>
       <entry><type>bigint</type></entry>
<!--
       <entry>get current transaction ID, assigning a new one if the current transaction does not have one</entry>
-->
       <entry>現在のトランザクションIDの取得、現在のトランザクションにIDがなければ新規に割り当てる</entry>
      </row>
      <row>
       <entry><literal><function>txid_current_if_assigned()</function></literal></entry>
       <entry><type>bigint</type></entry>
<!--
       <entry>same as <function>txid_current()</function> but returns null instead of assigning a new transaction ID if none is already assigned</entry>
-->
       <entry><function>txid_current()</function>と同じだが、まだトランザクションIDが割り当てられていなければ、新規に割り当てずにNULLを返す</entry>
      </row>
      <row>
       <entry><literal><function>txid_current_snapshot()</function></literal></entry>
       <entry><type>txid_snapshot</type></entry>
<!--
       <entry>get current snapshot</entry>
-->
       <entry>現在のスナップショットの取得</entry>
      </row>
      <row>
       <entry><literal><function>txid_snapshot_xip(<parameter>txid_snapshot</parameter>)</function></literal></entry>
       <entry><type>setof bigint</type></entry>
<!--
       <entry>get in-progress transaction IDs in snapshot</entry>
-->
       <entry>スナップショットにある進行中のトランザクションIDの取得</entry>
      </row>
      <row>
       <entry><literal><function>txid_snapshot_xmax(<parameter>txid_snapshot</parameter>)</function></literal></entry>
       <entry><type>bigint</type></entry>
<!--
       <entry>get <literal>xmax</literal> of snapshot</entry>
-->
       <entry>スナップショットの<literal>xmax</literal>の取得</entry>
      </row>
      <row>
       <entry><literal><function>txid_snapshot_xmin(<parameter>txid_snapshot</parameter>)</function></literal></entry>
       <entry><type>bigint</type></entry>
<!--
       <entry>get <literal>xmin</literal> of snapshot</entry>
-->
       <entry>スナップショットの<literal>xmin</literal>の取得</entry>
      </row>
      <row>
       <entry><literal><function>txid_visible_in_snapshot(<parameter>bigint</parameter>, <parameter>txid_snapshot</parameter>)</function></literal></entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>is transaction ID visible in snapshot? (do not use with subtransaction ids)</entry>
-->
       <entry>スナップショットにあるトランザクションIDは可視か？（サブトランザクションIDで使用しないこと）</entry>
      </row>
      <row>
       <entry><literal><function>txid_status(<parameter>bigint</parameter>)</function></literal></entry>
       <entry><type>text</type></entry>
<!--
       <entry>report the status of the given transaction: <literal>committed</literal>, <literal>aborted</literal>, <literal>in progress</literal>, or null if the transaction ID is too old</entry>
-->
       <entry>指定のトランザクションのステータス（<literal>committed</literal>、<literal>aborted</literal>、<literal>in progress</literal>、NULL（トランザクションIDが古すぎる場合））を報告する</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
<!--
    The internal transaction ID type (<type>xid</type>) is 32 bits wide and
    wraps around every 4 billion transactions.  However, these functions
    export a 64-bit format that is extended with an <quote>epoch</quote> counter
    so it will not wrap around during the life of an installation.
    The data type used by these functions, <type>txid_snapshot</type>,
    stores information about transaction ID
    visibility at a particular moment in time.  Its components are
    described in <xref linkend="functions-txid-snapshot-parts"/>.
-->
内部トランザクションID型（<type>xid</type>）は32ビット幅なので40億トランザクション毎にラップします。
とは言っても、これらの関数は<quote>epoch</quote>カウンタにより拡張された64ビット形式をエクスポートするため、インストレーションの生涯にわたってラップしないでしょう。
これらの関数で使用されるデータ型、<type>txid_snapshot</type>はある特定の時間におけるトランザクションIDの可視性に関する情報を格納します。
構成要素は<xref linkend="functions-txid-snapshot-parts"/>に記載されています。
   </para>

   <table id="functions-txid-snapshot-parts">
<!--
    <title>Snapshot Components</title>
-->
    <title>スナップショット構成要素</title>
    <tgroup cols="2">
     <thead>
      <row>
<!--
       <entry>Name</entry>
       <entry>Description</entry>
-->
       <entry>名前</entry>
       <entry>説明</entry>
      </row>
     </thead>

     <tbody>

      <row>
       <entry><type>xmin</type></entry>
       <entry>
<!--
         Earliest transaction ID (txid) that is still active.  All earlier
         transactions will either be committed and visible, or rolled
         back and dead.
-->
現在実行中で最も早いトランザクションID（txid）。
これより早い全てのトランザクションはコミットされて可視となっているか、またはロールバックされて消滅している。
       </entry>
      </row>

      <row>
       <entry><type>xmax</type></entry>
       <entry>
<!--
        First as-yet-unassigned txid.  All txids greater than or equal to this
        are not yet started as of the time of the snapshot, and thus invisible.
-->
まだ割り当てられていない最初のtxid。
これと等しいかより大きい全てのtxidはスナップショットの時点で未開始であり、従って不可視。
       </entry>
      </row>

      <row>
       <entry><type>xip_list</type></entry>
       <entry>
<!--
        Active txids at the time of the snapshot.  The list
        includes only those active txids between <literal>xmin</literal>
        and <literal>xmax</literal>; there might be active txids higher
        than <literal>xmax</literal>.  A txid that is <literal>xmin &lt;= txid &lt;
        xmax</literal> and not in this list was already completed
        at the time of the snapshot, and thus either visible or
        dead according to its commit status.  The list does not
        include txids of subtransactions.
-->
スナップショット時の実行中のtxid。
リストは<literal>xmin</literal>と<literal>xmax</literal>間の実行中のtxidのみを含む。
<literal>xmax</literal>より高位で実行中のtxidが存在することもある。
<literal>xmin &lt;= txid &lt; xmax</literal>であり、このリストにないtxidはスナップショット時に既に完了しており、従って、コミット状態によって、可視か消滅かのいずれか。
リストには副トランザクションのtxidは含まれない。
       </entry>
      </row>

     </tbody>
    </tgroup>
   </table>

   <para>
<!--
    <type>txid_snapshot</type>'s textual representation is
    <literal><replaceable>xmin</replaceable>:<replaceable>xmax</replaceable>:<replaceable>xip_list</replaceable></literal>.
    For example <literal>10:20:10,14,15</literal> means
    <literal>xmin=10, xmax=20, xip_list=10, 14, 15</literal>.
-->
<type>txid_snapshot</type>のテキスト表現は<literal><replaceable>xmin</replaceable>:<replaceable>xmax</replaceable>:<replaceable>xip_list</replaceable></literal>です。
例えば、<literal>10:20:10,14,15</literal>は<literal>xmin=10, xmax=20, xip_list=10, 14, 15</literal>を意味します。
   </para>

   <para>
<!--
    <function>txid_status(bigint)</function> reports the commit status of a recent
    transaction.  Applications may use it to determine whether a transaction
    committed or aborted when the application and database server become
    disconnected while a <literal>COMMIT</literal> is in progress.
    The status of a transaction will be reported as either
    <literal>in progress</literal>,
    <literal>committed</literal>, or <literal>aborted</literal>, provided that the
    transaction is recent enough that the system retains the commit status
    of that transaction.  If is old enough that no references to that
    transaction survive in the system and the commit status information has
    been discarded, this function will return NULL.  Note that prepared
    transactions are reported as <literal>in progress</literal>; applications must
    check <link
    linkend="view-pg-prepared-xacts"><literal>pg_prepared_xacts</literal></link> if they
    need to determine whether the txid is a prepared transaction.
-->
<function>txid_status(bigint)</function>は最近のトランザクションのコミット状態について報告します。
<literal>COMMIT</literal>の進行中にアプリケーションとデータベースが切断されたときに、アプリケーションはトランザクションがコミットされたか中断されたかを知るためにこれを使うことができます。
トランザクションが最近のもので、システムがそのトランザクションのコミット状態を保持している場合は、トランザクションの状態は<literal>in progress</literal>、<literal>committed</literal>あるいは<literal>aborted</literal>として報告されます。
トランザクションが古く、その参照がシステムに残っておらず、コミット状態の情報が破棄されている場合は、この関数はNULLを返します。
プリペアドのトランザクションは<literal>in progress</literal>として報告されること、そして指定のtxidがプリペアドのトランザクションかどうかを確認する必要がある場合は、アプリケーションは<link linkend="view-pg-prepared-xacts"><literal>pg_prepared_xacts</literal></link>を調べなければならないことに注意してください。
   </para>

   <para>
<!--
    The functions shown in <xref linkend="functions-commit-timestamp"/>
    provide information about transactions that have been already committed.
    These functions mainly provide information about when the transactions
    were committed. They only provide useful data when
    <xref linkend="guc-track-commit-timestamp"/> configuration option is enabled
    and only for transactions that were committed after it was enabled.
-->
<xref linkend="functions-commit-timestamp"/>に示す関数は、コミット済みのトランザクションに関する情報を提供します。
これらの関数は主に、トランザクションがいつコミットされたかについての情報を提供します。
これらは、設定オプション<xref linkend="guc-track-commit-timestamp"/>が有効な時にのみ、しかもそれが有効にされた後にコミットされたトランザクションについてのみ有意なデータを提供します。
   </para>

   <table id="functions-commit-timestamp">
<!--
    <title>Committed Transaction Information</title>
-->
    <title>コミットされたトランザクションの情報</title>
    <tgroup cols="3">
     <thead>
<!--
      <row><entry>Name</entry> <entry>Return Type</entry> <entry>Description</entry></row>
-->
      <row><entry>名前</entry> <entry>戻り型</entry> <entry>説明</entry></row>
     </thead>

     <tbody>
      <row>
       <entry>
        <indexterm><primary>pg_xact_commit_timestamp</primary></indexterm>
        <literal><function>pg_xact_commit_timestamp(<parameter>xid</parameter>)</function></literal>
       </entry>
       <entry><type>timestamp with time zone</type></entry>
<!--
       <entry>get commit timestamp of a transaction</entry>
-->
       <entry>トランザクションのコミットのタイムスタンプを取得</entry>
      </row>

      <row>
       <entry>
        <indexterm><primary>pg_last_committed_xact</primary></indexterm>
        <literal><function>pg_last_committed_xact()</function></literal>
       </entry>
       <entry><parameter>xid</parameter> <type>xid</type>, <parameter>timestamp</parameter> <type>timestamp with time zone</type></entry>
<!--
       <entry>get transaction ID and commit timestamp of latest committed transaction</entry>
-->
       <entry>最後にコミットされたトランザクションのトランザクションIDとコミットのタイムスタンプを取得</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
<!--
    The functions shown in <xref linkend="functions-controldata"/>
    print information initialized during <command>initdb</command>, such
    as the catalog version. They also show information about write-ahead
    logging and checkpoint processing. This information is cluster-wide,
    and not specific to any one database. They provide most of the same
    information, from the same source, as
    <xref linkend="app-pgcontroldata"/>, although in a form better suited
    to <acronym>SQL</acronym> functions.
-->
<xref linkend="functions-controldata"/>に示す関数は、カタログのバージョンなどといった<command>initdb</command>の実行時に初期化される情報を表示します。
それらはまた、先行書き込みログとチェックポイント処理についての情報も示します。
この情報はクラスタ全体に渡るもので、どれか１つのデータベースに特有のものではありません。
それらは<xref linkend="app-pgcontroldata"/>と同じ情報源から、ほぼ同じ情報を提供しますが、<acronym>SQL</acronym>関数により適した形式になります。
   </para>

   <table id="functions-controldata">
<!--
    <title>Control Data Functions</title>
-->
    <title>制御データ関数</title>
    <tgroup cols="3">
     <thead>
<!--
      <row><entry>Name</entry> <entry>Return Type</entry> <entry>Description</entry></row>
-->
      <row><entry>名前</entry> <entry>戻り値型</entry> <entry>説明</entry></row>
     </thead>

     <tbody>
      <row>
       <entry>
        <indexterm><primary>pg_control_checkpoint</primary></indexterm>
        <literal><function>pg_control_checkpoint()</function></literal>
       </entry>
       <entry><type>record</type></entry>
       <entry>
<!--
        Returns information about current checkpoint state.
-->
現在のチェックポイントの状態に関する情報を返す
       </entry>
      </row>

      <row>
       <entry>
        <indexterm><primary>pg_control_system</primary></indexterm>
        <literal><function>pg_control_system()</function></literal>
       </entry>
       <entry><type>record</type></entry>
       <entry>
<!--
        Returns information about current control file state.
-->
現在の制御ファイルの状態に関する情報を返す
       </entry>
      </row>

      <row>
       <entry>
        <indexterm><primary>pg_control_init</primary></indexterm>
        <literal><function>pg_control_init()</function></literal>
       </entry>
       <entry><type>record</type></entry>
       <entry>
<!--
        Returns information about cluster initialization state.
-->
クラスタの初期化状態に関する情報を返す
       </entry>
      </row>

      <row>
       <entry>
        <indexterm><primary>pg_control_recovery</primary></indexterm>
        <literal><function>pg_control_recovery()</function></literal>
       </entry>
       <entry><type>record</type></entry>
       <entry>
<!--
        Returns information about recovery state.
-->
リカバリの状態に関する情報を返す
       </entry>
      </row>

     </tbody>
    </tgroup>
   </table>

   <para>
<!--
    <function>pg_control_checkpoint</function> returns a record, shown in
    <xref linkend="functions-pg-control-checkpoint"/>
-->
<function>pg_control_checkpoint</function>は<xref linkend="functions-pg-control-checkpoint"/>に示すレコードを返します。
   </para>

   <table id="functions-pg-control-checkpoint">
<!--
    <title><function>pg_control_checkpoint</function> Columns</title>
-->
    <title><function>pg_control_checkpoint</function>の列</title>
    <tgroup cols="2">
     <thead>
      <row>
<!--
       <entry>Column Name</entry>
       <entry>Data Type</entry>
-->
       <entry>列名</entry>
       <entry>データ型</entry>
      </row>
     </thead>

     <tbody>

      <row>
       <entry><literal>checkpoint_lsn</literal></entry>
       <entry><type>pg_lsn</type></entry>
      </row>

      <row>
       <entry><literal>redo_lsn</literal></entry>
       <entry><type>pg_lsn</type></entry>
      </row>

      <row>
       <entry><literal>redo_wal_file</literal></entry>
       <entry><type>text</type></entry>
      </row>

      <row>
       <entry><literal>timeline_id</literal></entry>
       <entry><type>integer</type></entry>
      </row>

      <row>
       <entry><literal>prev_timeline_id</literal></entry>
       <entry><type>integer</type></entry>
      </row>

      <row>
       <entry><literal>full_page_writes</literal></entry>
       <entry><type>boolean</type></entry>
      </row>

      <row>
       <entry><literal>next_xid</literal></entry>
       <entry><type>text</type></entry>
      </row>

      <row>
       <entry><literal>next_oid</literal></entry>
       <entry><type>oid</type></entry>
      </row>

      <row>
       <entry><literal>next_multixact_id</literal></entry>
       <entry><type>xid</type></entry>
      </row>

      <row>
       <entry><literal>next_multi_offset</literal></entry>
       <entry><type>xid</type></entry>
      </row>

      <row>
       <entry><literal>oldest_xid</literal></entry>
       <entry><type>xid</type></entry>
      </row>

      <row>
       <entry><literal>oldest_xid_dbid</literal></entry>
       <entry><type>oid</type></entry>
      </row>

      <row>
       <entry><literal>oldest_active_xid</literal></entry>
       <entry><type>xid</type></entry>
      </row>

      <row>
       <entry><literal>oldest_multi_xid</literal></entry>
       <entry><type>xid</type></entry>
      </row>

      <row>
       <entry><literal>oldest_multi_dbid</literal></entry>
       <entry><type>oid</type></entry>
      </row>

      <row>
       <entry><literal>oldest_commit_ts_xid</literal></entry>
       <entry><type>xid</type></entry>
      </row>

      <row>
       <entry><literal>newest_commit_ts_xid</literal></entry>
       <entry><type>xid</type></entry>
      </row>

      <row>
       <entry><literal>checkpoint_time</literal></entry>
       <entry><type>timestamp with time zone</type></entry>
      </row>

     </tbody>
    </tgroup>
   </table>

   <para>
<!--
    <function>pg_control_system</function> returns a record, shown in
    <xref linkend="functions-pg-control-system"/>
-->
<function>pg_control_system</function>は<xref linkend="functions-pg-control-system"/>に示すレコードを返します。
   </para>

   <table id="functions-pg-control-system">
<!--
    <title><function>pg_control_system</function> Columns</title>
-->
    <title><function>pg_control_system</function>の列</title>
    <tgroup cols="2">
     <thead>
      <row>
<!--
       <entry>Column Name</entry>
       <entry>Data Type</entry>
-->
       <entry>列名</entry>
       <entry>データ型</entry>
      </row>
     </thead>

     <tbody>

      <row>
       <entry><literal>pg_control_version</literal></entry>
       <entry><type>integer</type></entry>
      </row>

      <row>
       <entry><literal>catalog_version_no</literal></entry>
       <entry><type>integer</type></entry>
      </row>

      <row>
       <entry><literal>system_identifier</literal></entry>
       <entry><type>bigint</type></entry>
      </row>

      <row>
       <entry><literal>pg_control_last_modified</literal></entry>
       <entry><type>timestamp with time zone</type></entry>
      </row>

     </tbody>
    </tgroup>
   </table>

   <para>
<!--
    <function>pg_control_init</function> returns a record, shown in
-->
<function>pg_control_init</function>は<xref linkend="functions-pg-control-init"/>に示すレコードを返します。
    <xref linkend="functions-pg-control-init"/>
   </para>

   <table id="functions-pg-control-init">
<!--
    <title><function>pg_control_init</function> Columns</title>
-->
    <title><function>pg_control_init</function>の列</title>
    <tgroup cols="2">
     <thead>
      <row>
<!--
       <entry>Column Name</entry>
       <entry>Data Type</entry>
-->
       <entry>列名</entry>
       <entry>データ型</entry>
      </row>
     </thead>

     <tbody>

      <row>
       <entry><literal>max_data_alignment</literal></entry>
       <entry><type>integer</type></entry>
      </row>

      <row>
       <entry><literal>database_block_size</literal></entry>
       <entry><type>integer</type></entry>
      </row>

      <row>
       <entry><literal>blocks_per_segment</literal></entry>
       <entry><type>integer</type></entry>
      </row>

      <row>
       <entry><literal>wal_block_size</literal></entry>
       <entry><type>integer</type></entry>
      </row>

      <row>
       <entry><literal>bytes_per_wal_segment</literal></entry>
       <entry><type>integer</type></entry>
      </row>

      <row>
       <entry><literal>max_identifier_length</literal></entry>
       <entry><type>integer</type></entry>
      </row>

      <row>
       <entry><literal>max_index_columns</literal></entry>
       <entry><type>integer</type></entry>
      </row>

      <row>
       <entry><literal>max_toast_chunk_size</literal></entry>
       <entry><type>integer</type></entry>
      </row>

      <row>
       <entry><literal>large_object_chunk_size</literal></entry>
       <entry><type>integer</type></entry>
      </row>

      <row>
       <entry><literal>float4_pass_by_value</literal></entry>
       <entry><type>boolean</type></entry>
      </row>

      <row>
       <entry><literal>float8_pass_by_value</literal></entry>
       <entry><type>boolean</type></entry>
      </row>

      <row>
       <entry><literal>data_page_checksum_version</literal></entry>
       <entry><type>integer</type></entry>
      </row>

     </tbody>
    </tgroup>
   </table>

   <para>
<!--
    <function>pg_control_recovery</function> returns a record, shown in
-->
<function>pg_control_recovery</function>は<xref linkend="functions-pg-control-recovery"/>に示すレコードを返します。
    <xref linkend="functions-pg-control-recovery"/>
   </para>

   <table id="functions-pg-control-recovery">
<!--
    <title><function>pg_control_recovery</function> Columns</title>
-->
    <title><function>pg_control_recovery</function>の列</title>
    <tgroup cols="2">
     <thead>
      <row>
<!--
       <entry>Column Name</entry>
       <entry>Data Type</entry>
-->
       <entry>列名</entry>
       <entry>データ型</entry>
      </row>
     </thead>

     <tbody>

      <row>
       <entry><literal>min_recovery_end_lsn</literal></entry>
       <entry><type>pg_lsn</type></entry>
      </row>

      <row>
       <entry><literal>min_recovery_end_timeline</literal></entry>
       <entry><type>integer</type></entry>
      </row>

      <row>
       <entry><literal>backup_start_lsn</literal></entry>
       <entry><type>pg_lsn</type></entry>
      </row>

      <row>
       <entry><literal>backup_end_lsn</literal></entry>
       <entry><type>pg_lsn</type></entry>
      </row>

      <row>
       <entry><literal>end_of_backup_record_required</literal></entry>
       <entry><type>boolean</type></entry>
      </row>

     </tbody>
    </tgroup>
   </table>

  </sect1>

  <sect1 id="functions-admin">
<!--
   <title>System Administration Functions</title>
-->
   <title>システム管理関数</title>

   <para>
<!--
    The functions described in this section are used to control and
    monitor a <productname>PostgreSQL</productname> installation.
-->
本節で説明する関数は、<productname>PostgreSQL</productname>インストレーションの制御と監視を行うために使用されます。
   </para>

  <sect2 id="functions-admin-set">
<!--
   <title>Configuration Settings Functions</title>
-->
   <title>構成設定関数</title>

   <para>
<!--
    <xref linkend="functions-admin-set-table"/> shows the functions
    available to query and alter run-time configuration parameters.
-->
<xref linkend="functions-admin-set-table"/>は、実行時設定パラメータの問い合わせや変更に使用できる関数を示しています。
   </para>

   <table id="functions-admin-set-table">
<!--
    <title>Configuration Settings Functions</title>
-->
    <title>構成設定関数</title>
    <tgroup cols="3">
     <thead>
<!--
      <row><entry>Name</entry> <entry>Return Type</entry> <entry>Description</entry></row>
-->
      <row><entry>名前</entry> <entry>戻り型</entry> <entry>説明</entry></row>
     </thead>

     <tbody>
      <row>
       <entry>
        <indexterm>
         <primary>current_setting</primary>
        </indexterm>
        <literal><function>current_setting(<parameter>setting_name</parameter> [, <parameter>missing_ok</parameter> ])</function></literal>
       </entry>
       <entry><type>text</type></entry>
<!--
       <entry>get current value of setting</entry>
-->
       <entry>現在の設定値の取得</entry>
      </row>
      <row>
       <entry>
        <indexterm>
         <primary>set_config</primary>
        </indexterm>
        <literal><function>set_config(<parameter>setting_name</parameter>,
                             <parameter>new_value</parameter>,
                             <parameter>is_local</parameter>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
<!--
       <entry>set parameter and return new value</entry>
-->
       <entry>パラメータを設定し、新規値を返す</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <indexterm>
    <primary>SET</primary>
   </indexterm>

   <indexterm>
    <primary>SHOW</primary>
   </indexterm>

   <indexterm>
<!--
    <primary>configuration</primary>
-->
    <primary>設定</primary>
<!--
    <secondary sortas="server">of the server</secondary>
-->
    <secondary sortas="server">サーバの</secondary>
<!--
    <tertiary>functions</tertiary>
-->
    <tertiary>関数</tertiary>
   </indexterm>

   <para>
<!--
    The function <function>current_setting</function> yields the
    current value of the setting <parameter>setting_name</parameter>.
    It corresponds to the <acronym>SQL</acronym> command
    <command>SHOW</command>.  An example:
-->
関数<function>current_setting</function>は、設定<parameter>setting_name</parameter>の現在の値を返します。
この関数は、<acronym>SQL</acronym>の<command>SHOW</command>コマンドと同じです。
以下に例を示します。
<programlisting>
SELECT current_setting('datestyle');

 current_setting
-----------------
 ISO, MDY
(1 row)
</programlisting>

<!--
    If there is no setting named <parameter>setting_name</parameter>,
    <function>current_setting</function> throws an error
    unless <parameter>missing_ok</parameter> is supplied and is
    <literal>true</literal>.
-->
<parameter>setting_name</parameter>という名前の設定がない場合、<parameter>missing_ok</parameter>が渡され、かつ、それが<literal>true</literal>のときを除き、<function>current_setting</function>はエラーを発生させます。
   </para>

   <para>
<!--
    <function>set_config</function> sets the parameter
    <parameter>setting_name</parameter> to
    <parameter>new_value</parameter>.  If
    <parameter>is_local</parameter> is <literal>true</literal>, the
    new value will only apply to the current transaction. If you want
    the new value to apply for the current session, use
    <literal>false</literal> instead. The function corresponds to the
    SQL command <command>SET</command>. An example:
-->
<function>set_config</function>関数は、パラメータ<parameter>setting_name</parameter>を<parameter>new_value</parameter>に設定します。
ただし、<parameter>is_local</parameter>が<literal>true</literal>の場合、新規値は現在のトランザクションにのみ適用されます。
新規値を現在のセッションに適用する場合は、代わりに<literal>false</literal>を使用してください。
この関数は、SQLの<command>SET</command>コマンドと同じです。
以下に例を示します。
<programlisting>
SELECT set_config('log_statement_stats', 'off', false);

 set_config
------------
 off
(1 row)
</programlisting>
   </para>

  </sect2>

  <sect2 id="functions-admin-signal">
<!--
   <title>Server Signaling Functions</title>
-->
   <title>サーバシグナル送信関数</title>

   <indexterm>
    <primary>pg_cancel_backend</primary>
   </indexterm>
   <indexterm>
    <primary>pg_reload_conf</primary>
   </indexterm>
   <indexterm>
    <primary>pg_rotate_logfile</primary>
   </indexterm>
   <indexterm>
    <primary>pg_terminate_backend</primary>
   </indexterm>

   <indexterm>
<!--
    <primary>signal</primary>
    <secondary sortas="backend">backend processes</secondary>
-->
    <primary>シグナル</primary>
    <secondary sortas="backend">バックエンドプロセス</secondary>
   </indexterm>

   <para>
<!--
    The functions shown in <xref
    linkend="functions-admin-signal-table"/> send control signals to
    other server processes.  Use of these functions is restricted to
    superusers by default but access may be granted to others using
    <command>GRANT</command>, with noted exceptions.
-->
<xref linkend="functions-admin-signal-table"/>に示す関数は、制御用シグナルを他のサーバプロセスに送信します。
これらの関数の使用は、デフォルトでスーパーユーザのみに制限されていますが、注記された例外を除き、<command>GRANT</command>を使用して他のユーザにアクセスを許可できます。
   </para>

   <table id="functions-admin-signal-table">
<!--
    <title>Server Signaling Functions</title>
-->
    <title>サーバシグナル送信関数</title>
    <tgroup cols="3">
     <thead>
<!--
      <row><entry>Name</entry> <entry>Return Type</entry> <entry>Description</entry>
-->
      <row><entry>名前</entry> <entry>戻り型</entry> <entry>説明</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry>
        <literal><function>pg_cancel_backend(<parameter>pid</parameter> <type>int</type>)</function></literal>
        </entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>Cancel a backend's current query.  This is also allowed if the
        calling role is a member of the role whose backend is being canceled or
        the calling role has been granted <literal>pg_signal_backend</literal>,
        however only superusers can cancel superuser backends.
-->
       <entry>バックエンドの現在の問い合わせを取り消す。
       関数を呼ぶユーザが取り消す対象のバックエンドのロールのメンバーであるとき、あるいは<literal>pg_signal_backend</literal>の権限を与えられているときも実行できます。
       ただし、スーパーユーザのバックエンドはスーパーユーザのみが取り消せます。
        </entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_reload_conf()</function></literal>
        </entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>Cause server processes to reload their configuration files</entry>
-->
       <entry>サーバプロセスに構成ファイルの再読み込みをさせる</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_rotate_logfile()</function></literal>
        </entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>Rotate server's log file</entry>
-->
       <entry>サーバログファイルを循環させる</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_terminate_backend(<parameter>pid</parameter> <type>int</type>)</function></literal>
        </entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>Terminate a backend.  This is also allowed if the calling role
        is a member of the role whose backend is being terminated or the
        calling role has been granted <literal>pg_signal_backend</literal>,
        however only superusers can terminate superuser backends.
-->
       <entry>バックエンドを終了する。
       関数を呼ぶユーザが終了対象のバックエンドのロールのメンバーであるとき、あるいは<literal>pg_signal_backend</literal>の権限を与えられているときも実行できます。
       ただし、スーパーユーザのバックエンドはスーパーユーザのみが終了できます。
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
<!--
    Each of these functions returns <literal>true</literal> if
    successful and <literal>false</literal> otherwise.
-->
これらのそれぞれの関数は成功の場合<literal>true</literal>（真）を返し、そうでない場合は<literal>false</literal>（偽）を返します。
   </para>

   <para>
<!--
    <function>pg_cancel_backend</function> and <function>pg_terminate_backend</function>
    send signals (<systemitem>SIGINT</systemitem> or <systemitem>SIGTERM</systemitem>
    respectively) to backend processes identified by process ID.
    The process ID of an active backend can be found from
    the <structfield>pid</structfield> column of the
    <structname>pg_stat_activity</structname> view, or by listing the
    <command>postgres</command> processes on the server (using
    <application>ps</application> on Unix or the <application>Task
    Manager</application> on <productname>Windows</productname>).
    The role of an active backend can be found from the
    <structfield>usename</structfield> column of the
    <structname>pg_stat_activity</structname> view.
-->
<function>pg_cancel_backend</function>と<function>pg_terminate_backend</function>は（それぞれ、<systemitem>SIGINT</systemitem>または<systemitem>SIGTERM</systemitem>）シグナルをプロセス識別子で特定されたバックエンドプロセスに送ります。
使用中のバックエンドのプロセス識別子は<structname>pg_stat_activity</structname>ビューの<structfield>pid</structfield>列から、もしくは、（Unixでは<application>ps</application>、<productname>Windows</productname>では<application>Task Manager</application>により）サーバ上の<command>postgres</command>プロセスをリストすることで見つけられます。
実行中のバックエンドのロールは<structname>pg_stat_activity</structname>の<structfield>usename</structfield>列から確認することができます。
   </para>

   <para>
<!--
    <function>pg_reload_conf</function> sends a <systemitem>SIGHUP</systemitem> signal
    to the server, causing configuration files
    to be reloaded by all server processes.
-->
<function>pg_reload_conf</function>は<systemitem>SIGHUP</systemitem>シグナルをサーバに送り、その結果全てのサーバプロセスが構成ファイルを再読み込みすることになります。
   </para>

   <para>
<!--
    <function>pg_rotate_logfile</function> signals the log-file manager to switch
    to a new output file immediately.  This works only when the built-in
    log collector is running, since otherwise there is no log-file manager
    subprocess.
-->
<function>pg_rotate_logfile</function>はログファイルマネージャに即座に新規出力ファイルに切替えるようシグナルを送ります。
これは組み込みログ取得が起動している場合のみ有効です。起動していない場合はログファイルマネージャの子プロセスが存在しない理由からです。
   </para>

  </sect2>

  <sect2 id="functions-admin-backup">
<!--
   <title>Backup Control Functions</title>
-->
   <title>バックアップ制御関数</title>

   <indexterm>
<!--
    <primary>backup</primary>
-->
    <primary>バックアップ</primary>
   </indexterm>
   <indexterm>
    <primary>pg_create_restore_point</primary>
   </indexterm>
   <indexterm>
    <primary>pg_current_wal_flush_lsn</primary>
   </indexterm>
   <indexterm>
    <primary>pg_current_wal_insert_lsn</primary>
   </indexterm>
   <indexterm>
    <primary>pg_current_wal_lsn</primary>
   </indexterm>
   <indexterm>
    <primary>pg_start_backup</primary>
   </indexterm>
   <indexterm>
    <primary>pg_stop_backup</primary>
   </indexterm>
   <indexterm>
    <primary>pg_is_in_backup</primary>
   </indexterm>
   <indexterm>
    <primary>pg_backup_start_time</primary>
   </indexterm>
   <indexterm>
    <primary>pg_switch_wal</primary>
   </indexterm>
   <indexterm>
    <primary>pg_walfile_name</primary>
   </indexterm>
   <indexterm>
    <primary>pg_walfile_name_offset</primary>
   </indexterm>
   <indexterm>
    <primary>pg_wal_lsn_diff</primary>
   </indexterm>

   <para>
<!--
    The functions shown in <xref
    linkend="functions-admin-backup-table"/> assist in making on-line backups.
    These functions cannot be executed during recovery (except
    non-exclusive <function>pg_start_backup</function>,
    non-exclusive <function>pg_stop_backup</function>,
    <function>pg_is_in_backup</function>, <function>pg_backup_start_time</function>
    and <function>pg_wal_lsn_diff</function>).
-->
<xref linkend="functions-admin-backup-table"/>に示す関数はオンラインバックアップの作成を支援するものです。
これらの関数は、リカバリ中には実行できません(非排他的<function>pg_start_backup</function>、非排他的<function>pg_stop_backup</function>、<function>pg_is_in_backup</function>、<function>pg_backup_start_time</function>、および<function>pg_wal_lsn_diff</function>は除く)。
   </para>

   <table id="functions-admin-backup-table">
<!--
    <title>Backup Control Functions</title>
-->
    <title>バックアップ制御関数</title>
    <tgroup cols="3">
     <thead>
<!--
      <row><entry>Name</entry> <entry>Return Type</entry> <entry>Description</entry>
-->
      <row><entry>名前</entry> <entry>戻り型</entry> <entry>説明</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry>
        <literal><function>pg_create_restore_point(<parameter>name</parameter> <type>text</type>)</function></literal>
        </entry>
       <entry><type>pg_lsn</type></entry>
<!--
       <entry>Create a named point for performing restore (restricted to superusers by default, but other users can be granted EXECUTE to run the function)</entry>
-->
       <entry>リストア実行用に名前付けされたポイントを作成(デフォルトではスーパーユーザのみ実施可能、ただし他のユーザにも関数を実行するEXECUTE権限を与えることができる)</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_current_wal_flush_lsn()</function></literal>
        </entry>
       <entry><type>pg_lsn</type></entry>
<!--
       <entry>Get current write-ahead log flush location</entry>
-->
       <entry>先行書き込みログの現在のフラッシュ位置を取得する</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_current_wal_insert_lsn()</function></literal>
        </entry>
       <entry><type>pg_lsn</type></entry>
<!--
       <entry>Get current write-ahead log insert location</entry>
-->
       <entry>現在の先行書き込みログの挿入位置の取得</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_current_wal_lsn()</function></literal>
        </entry>
       <entry><type>pg_lsn</type></entry>
<!--
       <entry>Get current write-ahead log write location</entry>
-->
       <entry>現在の先行書き込みログの書き込み位置を取得</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_start_backup(<parameter>label</parameter> <type>text</type> <optional>, <parameter>fast</parameter> <type>boolean</type> <optional>, <parameter>exclusive</parameter> <type>boolean</type> </optional></optional>)</function></literal>
        </entry>
       <entry><type>pg_lsn</type></entry>
<!--
       <entry>Prepare for performing on-line backup (restricted to superusers by default, but other users can be granted EXECUTE to run the function)</entry>
-->
       <entry>オンラインバックアップの実行準備(デフォルトではスーパーユーザでのみ実施可能、ただし他のユーザにも関数を実行するEXECUTE権限を与えることができる)</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_stop_backup()</function></literal>
        </entry>
       <entry><type>pg_lsn</type></entry>
<!--
       <entry>Finish performing exclusive on-line backup (restricted to superusers by default, but other users can be granted EXECUTE to run the function)</entry>
-->
       <entry>排他的オンラインバックアップの実行の終了(デフォルトではスーパーユーザでのみ実施可能、ただし他のユーザにも関数を実行するEXECUTE権限を与えることができる)</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_stop_backup(<parameter>exclusive</parameter> <type>boolean</type> <optional>, <parameter>wait_for_archive</parameter> <type>boolean</type> </optional>)</function></literal>
        </entry>
       <entry><type>setof record</type></entry>
<!--
       <entry>Finish performing exclusive or non-exclusive on-line backup (restricted to superusers by default, but other users can be granted EXECUTE to run the function)</entry>
-->
       <entry>排他的、あるいは非排他的オンラインバックアップの実行の終了（デフォルトではスーパーユーザでのみ実行可能、ただし他のユーザにも関数を実行するEXECUTE権限を与えることができる）</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_is_in_backup()</function></literal>
        </entry>
       <entry><type>bool</type></entry>
<!--
       <entry>True if an on-line exclusive backup is still in progress.</entry>
-->
       <entry>オンラインでの排他的バックアップが実行中は真。</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_backup_start_time()</function></literal>
        </entry>
       <entry><type>timestamp with time zone</type></entry>
<!--
       <entry>Get start time of an on-line exclusive backup in progress.</entry>
-->
       <entry>実行中のオンライン排他的バックアップの開始時刻を取得。</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_switch_wal()</function></literal>
        </entry>
       <entry><type>pg_lsn</type></entry>
<!--
       <entry>Force switch to a new write-ahead log file (restricted to superusers by default, but other users can be granted EXECUTE to run the function)</entry>
-->
       <entry>新しい先行書き込みログファイルへの強制移行(デフォルトではスーパーユーザのみ実行可能、ただし他のユーザにも関数を実行するEXECUTE権限を与えることができる)</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_walfile_name(<parameter>lsn</parameter> <type>pg_lsn</type>)</function></literal>
        </entry>
       <entry><type>text</type></entry>
<!--
       <entry>Convert write-ahead log location to file name</entry>
-->
       <entry>先行書き込みログの位置をファイル名に変換</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_walfile_name_offset(<parameter>lsn</parameter> <type>pg_lsn</type>)</function></literal>
        </entry>
       <entry><type>text</type>, <type>integer</type></entry>
<!--
       <entry>Convert write-ahead log location to file name and decimal byte offset within file</entry>
-->
       <entry>先行書き込みログの位置を、ファイル名とファイル内の10進のバイトオフセットに変換</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_wal_lsn_diff(<parameter>lsn</parameter> <type>pg_lsn</type>, <parameter>lsn</parameter> <type>pg_lsn</type>)</function></literal>
       </entry>
       <entry><type>numeric</type></entry>
<!--
       <entry>Calculate the difference between two write-ahead log locations</entry>
-->
       <entry>2つの先行書き込みログの位置差分を算出</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
<!--
    <function>pg_start_backup</function> accepts an arbitrary user-defined label for
    the backup.  (Typically this would be the name under which the backup dump
    file will be stored.) When used in exclusive mode, the function writes a
    backup label file (<filename>backup_label</filename>) and, if there are any links
    in the <filename>pg_tblspc/</filename> directory, a tablespace map file
    (<filename>tablespace_map</filename>) into the database cluster's data directory,
    performs a checkpoint, and then returns the backup's starting write-ahead
    log location as text.  The user can ignore this result value, but it is
    provided in case it is useful. When used in non-exclusive mode, the
    contents of these files are instead returned by the
    <function>pg_stop_backup</function> function, and should be written to the backup
    by the caller.
-->
<function>pg_start_backup</function>は、ユーザが任意に定義したバックアップラベルを受け付けます。
（通常、格納に使用するバックアップダンプファイルにちなんだ名前が付けられます。）
排他モードで使用される場合、この関数は、データベースクラスタのデータディレクトリにバックアップラベルファイル（<filename>backup_label</filename>）および<filename>pg_tblspc/</filename>ディレクトリにリンクがあるならテーブル空間マップファイル（<filename>tablespace_map</filename>）を書き出し、チェックポイントを実行し、先行書き込みログのバックアップ開始位置をテキスト形式で返します。
ユーザはこの結果値を無視することができますが、便利なこともあるので提供されています。
非排他モードで使用される場合は、排他モードとは違い、これらのファイルの内容が<function>pg_stop_backup</function>関数によって戻され、呼び出しユーザはそれをバックアップに書き込む必要があります。

<programlisting>
postgres=# select pg_start_backup('label_goes_here');
 pg_start_backup
-----------------
 0/D4445B8
(1 row)
</programlisting>
<!--
    There is an optional second parameter of type <type>boolean</type>.  If <literal>true</literal>,
    it specifies executing <function>pg_start_backup</function> as quickly as
    possible.  This forces an immediate checkpoint which will cause a
    spike in I/O operations, slowing any concurrently executing queries.
-->
オプションの<type>boolean</type>型パラメータがあります。
<literal>true</literal>であれば、できる限り高速に<function>pg_start_backup</function>を実行します。
これは、即時のチェックポイントを強制するため、I/O 操作の急激な増加を引き起こし、実行中の問い合わせ全てを遅延させることがあります。
   </para>

   <para>
<!--
    In an exclusive backup, <function>pg_stop_backup</function> removes the label file
    and, if it exists, the <filename>tablespace_map</filename> file created by
    <function>pg_start_backup</function>. In a non-exclusive backup, the contents of
    the <filename>backup_label</filename> and <filename>tablespace_map</filename> are returned
    in the result of the function, and should be written to files in the
    backup (and not in the data directory).  There is an optional second
    parameter of type <type>boolean</type>.  If false, the <function>pg_stop_backup</function>
    will return immediately after the backup is completed without waiting for
    WAL to be archived.  This behavior is only useful for backup
    software which independently monitors WAL archiving. Otherwise, WAL
    required to make the backup consistent might be missing and make the backup
    useless.  When this parameter is set to true, <function>pg_stop_backup</function>
    will wait for WAL to be archived when archiving is enabled; on the standby,
    this means that it will wait only when <varname>archive_mode = always</varname>.
    If write activity on the primary is low, it may be useful to run
    <function>pg_switch_wal</function> on the primary in order to trigger
    an immediate segment switch.
-->
排他的バックアップでは、<function>pg_stop_backup</function>は、<function>pg_start_backup</function>で作成されたラベルファイルおよび、もしあれば<filename>tablespace_map</filename>ファイルを削除します。
非排他的バックアップでは、<filename>backup_label</filename>および<filename>tablespace_map</filename>の内容が関数の結果として返され、それをバックアップ内のファイルに書き込む必要があります（データディレクトリ内のファイルに書いてはいけません）。
2番目のパラメータは<type>boolean</type>型で省略可能です。
falseの場合、<function>pg_stop_backup</function>はバックアップの完了後、WALがアーカイブされるのを待たずに、即座に戻ります。
この動作はWALのアーカイブを独立して監視するバックアップソフトウェアに対してのみ有用でしょう。
それ以外の場合、バックアップを一貫性のあるものにするために必要なWALが欠けていて、バックアップが役立たなくなるかもしれません。
このパラメータがtrueのとき、アーカイブが有効なら、<function>pg_stop_backup</function>はWALがアーカイブされるまで待機します。
スタンバイでは、これはつまり<varname>archive_mode = always</varname>のときのみ待機するということです。
プライマリでの書き込み活動が少ないときは、セグメントの変更を即座に起こさせるためにプライマリで<function>pg_switch_wal</function>を実行するのが有効かもしれません。
   </para>

   <para>
<!--
    When executed on a primary, the function also creates a backup history file
    in the write-ahead log
    archive area. The history file includes the label given to
    <function>pg_start_backup</function>, the starting and ending write-ahead log locations for
    the backup, and the starting and ending times of the backup.  The return
    value is the backup's ending write-ahead log location (which again
    can be ignored).  After recording the ending location, the current
    write-ahead log insertion
    point is automatically advanced to the next write-ahead log file, so that the
    ending write-ahead log file can be archived immediately to complete the backup.
-->
プライマリで実行された場合、この関数はまた、先行書き込みログの格納領域にバックアップ履歴ファイルを作成します。
履歴ファイルには<function>pg_start_backup</function>で付与されたラベル、バックアップの先行書き込みログの位置の開始位置、終了位置、バックアップ開始時刻、終了時刻が含まれます。
戻り値は、バックアップの終了先行書き込みログの位置です（これもまた無視可能です）。
終了位置を記録した後、現在の先行書き込みログの挿入位置は自動的に、次の先行書き込みログファイルに進みます。
従って、終了先行書き込みログファイルをすぐにアーカイブし、バックアップを完了させることができます。
   </para>

   <para>
<!--
    <function>pg_switch_wal</function> moves to the next write-ahead log file, allowing the
    current file to be archived (assuming you are using continuous archiving).
    The return value is the ending write-ahead log location + 1 within the just-completed write-ahead log file.
    If there has been no write-ahead log activity since the last write-ahead log switch,
    <function>pg_switch_wal</function> does nothing and returns the start location
    of the write-ahead log file currently in use.
-->
<function>pg_switch_wal</function>は次の先行書き込みログファイルに移動し、現在のファイルがアーカイブできるようにします（継続的アーカイブを使用している場合）。
戻り値は完了したばかりの先行書き込みログの終了書き込みログ位置に1を加えたものです。
最後に先行書き込みログを変更したときから先行書き込みログの活動がなかった場合は、<function>pg_switch_wal</function>は何もせずに、現在使用中の先行書き込みログファイルの開始位置を返します。
   </para>

   <para>
<!--
    <function>pg_create_restore_point</function> creates a named write-ahead log
    record that can be used as recovery target, and returns the corresponding
    write-ahead log location.  The given name can then be used with
    <xref linkend="guc-recovery-target-name"/> to specify the point up to which
    recovery will proceed.  Avoid creating multiple restore points with the
    same name, since recovery will stop at the first one whose name matches
    the recovery target.
-->
<function>pg_create_restore_point</function>はリカバリターゲットとして使用可能な名前付けされた先行書き込みログレコードを生成し、それに該当するログ位置を返します。
与えられた名前は、どこまでリカバリをするかを明示的に指定する<xref linkend="guc-recovery-target-name"/>パラメータに使用することができます。
リカバリ処理はリカバリターゲットに指定した名前と一致した最初の時点で終了するため、同じ名前で複数のリストアポイントを作成することは避けてください。
   </para>

   <para>
<!--
    <function>pg_current_wal_lsn</function> displays the current write-ahead log write
    location in the same format used by the above functions.  Similarly,
    <function>pg_current_wal_insert_lsn</function> displays the current write-ahead log
    insertion location and <function>pg_current_wal_flush_lsn</function> displays the
    current write-ahead log flush location. The insertion location is the <quote>logical</quote>
    end of the write-ahead log at any instant, while the write location is the end of
    what has actually been written out from the server's internal buffers and flush
    location is the location guaranteed to be written to durable storage. The write
    location is the end of what can be examined from outside the server, and is usually
    what you want if you are interested in archiving partially-complete write-ahead log
    files.  The insertion and flush locations are made available primarily for server
    debugging purposes.  These are both read-only operations and do not
    require superuser permissions.
-->
<function>pg_current_wal_lsn</function>は、上記の関数で使用されるのと同じ書式で現在の先行書き込みログの書き込み位置を表示します。
同様に<function>pg_current_wal_insert_lsn</function>は、現在の先行書き込みログの挿入位置を表示し、<function>pg_current_wal_flush_lsn</function>はトランザクションログの現在のフラッシュ位置を表示します。
挿入位置は <quote>論理的</quote>な任意の時点の先行書き込みログの終了位置です。
一方、書き込み位置は、サーバの内部バッファから書き出された実際の終了位置、またフラッシュ位置は永続的ストレージへの書き込みが保証される位置です。
書き込み位置はサーバ外部から検証可能なものの終端です。通常は、部分的に完了した先行書き込みログファイルのアーカイブ処理を行いたい場合に必要とされるものです。
挿入およびフラッシュ位置はサーバをデバッグする際に主に使用されます。
これらはどちらも読み取りのみの操作であり、スーパーユーザ権限を必要としません。
   </para>

   <para>
<!--
    You can use <function>pg_walfile_name_offset</function> to extract the
    corresponding write-ahead log file name and byte offset from the results of any of the
    above functions.  For example:
-->
<function>pg_walfile_name_offset</function>を使用して、上記いずれの関数の結果からも、対応する先行書き込みログファイルとバイトオフセットを取り出すことができます。
以下に例を示します。
<programlisting>
postgres=# SELECT * FROM pg_walfile_name_offset(pg_stop_backup());
        file_name         | file_offset 
--------------------------+-------------
 00000001000000000000000D |     4039624
(1 row)
</programlisting>
<!--
    Similarly, <function>pg_walfile_name</function> extracts just the write-ahead log file name.
    When the given write-ahead log location is exactly at a write-ahead log file boundary, both
    these functions return the name of the preceding write-ahead log file.
    This is usually the desired behavior for managing write-ahead log archiving
    behavior, since the preceding file is the last one that currently
    needs to be archived.
-->
同様に、<function>pg_walfile_name</function>は、先行書き込みログファイル名のみを取り出します。
指定した先行書き込みログの位置が正確に先行書き込みログファイルの境界であった場合、これらの両関数は前の先行書き込みログファイルの名前を返します。
通常これは、先行書き込みログファイルのアーカイブ動作では好まれる動作です。
前のファイルが現在のアーカイブで必要とする最後のファイルであるからです。
   </para>

   <para>
<!--
    <function>pg_wal_lsn_diff</function> calculates the difference in bytes
    between two write-ahead log locations. It can be used with
    <structname>pg_stat_replication</structname> or some functions shown in
    <xref linkend="functions-admin-backup-table"/> to get the replication lag.
-->
<function>pg_wal_lsn_diff</function>は、2つの先行書き込みログの位置の差分をバイト数で算出します。
この関数は<structname>pg_stat_replication</structname>や<xref linkend="functions-admin-backup-table"/>に示される関数と併用することで、レプリケーションの遅延の確認に使用できます。
   </para>

   <para>
<!--
    For details about proper usage of these functions, see
    <xref linkend="continuous-archiving"/>.
-->
これらの関数の正しい使用方法については、<xref linkend="continuous-archiving"/>を参照してください。
   </para>

  </sect2>

  <sect2 id="functions-recovery-control">
<!--
   <title>Recovery Control Functions</title>
-->
   <title>リカバリ制御関数</title>

   <indexterm>
    <primary>pg_is_in_recovery</primary>
   </indexterm>
   <indexterm>
    <primary>pg_last_wal_receive_lsn</primary>
   </indexterm>
   <indexterm>
    <primary>pg_last_wal_replay_lsn</primary>
   </indexterm>
   <indexterm>
    <primary>pg_last_xact_replay_timestamp</primary>
   </indexterm>

   <para>
<!--
    The functions shown in <xref
    linkend="functions-recovery-info-table"/> provide information
    about the current status of the standby.
    These functions may be executed both during recovery and in normal running.
-->
<xref linkend="functions-recovery-info-table"/>に示される関数は、スタンバイサーバの現在のステータス情報を提供します。
これらの関数はリカバリ中、および通常稼動時に実行することができるでしょう。
   </para>

   <table id="functions-recovery-info-table">
<!--
    <title>Recovery Information Functions</title>
-->
    <title>リカバリ情報関数</title>
    <tgroup cols="3">
     <thead>
<!--
      <row><entry>Name</entry> <entry>Return Type</entry> <entry>Description</entry>
-->
      <row><entry>名前</entry> <entry>戻り型</entry> <entry>説明</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry>
        <literal><function>pg_is_in_recovery()</function></literal>
        </entry>
       <entry><type>bool</type></entry>
<!--
       <entry>True if recovery is still in progress.
-->
       <entry>まだリカバリ実施中であれば真を返します。
       </entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_last_wal_receive_lsn()</function></literal>
        </entry>
       <entry><type>pg_lsn</type></entry>
<!--
       <entry>Get last write-ahead log location received and synced to disk by
        streaming replication. While streaming replication is in progress
        this will increase monotonically. If recovery has completed this will
        remain static at
        the value of the last WAL record received and synced to disk during
        recovery. If streaming replication is disabled, or if it has not yet
        started, the function returns NULL.
-->
       <entry>ストリーミングレプリケーションにより受信されディスクに書き込みされた、先行書き込みログの最後の位置を取得します。ストリーミングレプリケーションが実施されている場合は、この値が単調に増加していくでしょう。リカバリが完了した場合、受信されディスクに書き込まれた最後のWALレコードの位置の値がそのまま残ります。ストリーミングレプリケーションが無効、もしくは開始されていない場合、この関数はNULLを返します。
       </entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_last_wal_replay_lsn()</function></literal>
        </entry>
       <entry><type>pg_lsn</type></entry>
<!--
       <entry>Get last write-ahead log location replayed during recovery.
        If recovery is still in progress this will increase monotonically.
        If recovery has completed then this value will remain static at
        the value of the last WAL record applied during that recovery.
        When the server has been started normally without recovery
        the function returns NULL.
-->
       <entry>リカバリ中に再生された最後の先行書き込みログの位置を取得します。リカバリが実施されている場合は、この値が単調に増加していくでしょう。リカバリが完了した場合は、リカバリ時に適用された最後のWALレコードの値がそのまま残ります。もしサーバがリカバリ無しで普通に起動された場合、この関数はNULLを返します。
       </entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_last_xact_replay_timestamp()</function></literal>
        </entry>
       <entry><type>timestamp with time zone</type></entry>
<!--
       <entry>Get time stamp of last transaction replayed during recovery.
        This is the time at which the commit or abort WAL record for that
        transaction was generated on the primary.
        If no transactions have been replayed during recovery, this function
        returns NULL.  Otherwise, if recovery is still in progress this will
        increase monotonically.  If recovery has completed then this value will
        remain static at the value of the last transaction applied during that
        recovery.  When the server has been started normally without recovery
        the function returns NULL.
-->
        <entry>
リカバリ中に再生された最後のトランザクションのタイムスタンプを取得します。
このタイムスタンプは、プライマリにて該当するトランザクションがコミット、もしくはアボートされた際のWALレコードが生成された時間です。
リカバリ中に何のトランザクションも再生されていない場合、この関数はNULLを返します。
リカバリがまだ実行中の場合、この関数の戻り値は単調に増加します。
リカバリが完了している場合、この関数の戻り値はリカバリ中に再生した最後のトランザクションの時間のまま変化しません。
サーバがリカバリ処理無しに正常に開始された場合、この関数はNULLを返します。
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <indexterm>
    <primary>pg_is_wal_replay_paused</primary>
   </indexterm>
   <indexterm>
    <primary>pg_promote</primary>
   </indexterm>
   <indexterm>
    <primary>pg_wal_replay_pause</primary>
   </indexterm>
   <indexterm>
    <primary>pg_wal_replay_resume</primary>
   </indexterm>

   <para>
<!--
    The functions shown in <xref
    linkend="functions-recovery-control-table"/> control the progress of recovery.
    These functions may be executed only during recovery.
-->
<xref linkend="functions-recovery-control-table"/>に示す関数は、リカバリの進行を制御する関数です。
これらの関数はリカバリ中のみ実行することが可能です。
   </para>

   <table id="functions-recovery-control-table">
<!--
    <title>Recovery Control Functions</title>
-->
    <title>リカバリ制御関数</title>
    <tgroup cols="3">
     <thead>
<!--
      <row><entry>Name</entry> <entry>Return Type</entry> <entry>Description</entry>
-->
      <row><entry>名前</entry> <entry>戻り型</entry> <entry>説明</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry>
        <literal><function>pg_is_wal_replay_paused()</function></literal>
        </entry>
       <entry><type>bool</type></entry>
<!--
       <entry>True if recovery is paused.
       </entry>
-->
       <entry>リカバリが停止中であれば真を返す
       </entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_promote(<parameter>wait</parameter> <type>boolean</type> DEFAULT true, <parameter>wait_seconds</parameter> <type>integer</type> DEFAULT 60)</function></literal>
        </entry>
       <entry><type>boolean</type></entry>
       <entry>
<!--
        Promotes a physical standby server.  With <parameter>wait</parameter>
        set to <literal>true</literal> (the default), the function waits until
        promotion is completed or <parameter>wait_seconds</parameter> seconds
        have passed, and returns <literal>true</literal> if promotion is
        successful and <literal>false</literal> otherwise.
        If <parameter>wait</parameter> is set to <literal>false</literal>, the
        function returns <literal>true</literal> immediately after sending
        <literal>SIGUSR1</literal> to the postmaster to trigger the promotion.
        This function is restricted to superusers by default, but other users
        can be granted EXECUTE to run the function.
-->
物理スタンバイサーバを昇格します。
<parameter>wait</parameter>に<literal>true</literal>（デフォルト）を設定すると、この関数は昇格が完了するか、<parameter>wait_seconds</parameter>秒が経過するまで待ち、昇格に成功すれば<literal>true</literal>、さもなければ<literal>false</literal>を返します。
<parameter>wait</parameter>に<literal>false</literal>を設定すると、この関数は昇格を起こすためにpostmasterに<literal>SIGUSR1</literal>を送信した後、直ちに<literal>true</literal>を返します。
デフォルトではこの関数の実行はスーパーユーザに限定されますが、他のユーザに関数を実行するEXECUTE権限を与えることができます。
       </entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_wal_replay_pause()</function></literal>
        </entry>
       <entry><type>void</type></entry>
<!--
       <entry>Pauses recovery immediately (restricted to superusers by default, but other users can be granted EXECUTE to run the function).
-->
       <entry>即座にリカバリを停止する(デフォルトではスーパーユーザのみ実行可能、ただし他のユーザにも関数を実行するEXECUTE権限を与えることができる)
       </entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_wal_replay_resume()</function></literal>
        </entry>
       <entry><type>void</type></entry>
<!--
       <entry>Restarts recovery if it was paused (restricted to superusers by default, but other users can be granted EXECUTE to run the function).
-->
       <entry>もしリカバリ停止中であれば再開する(デフォルトではスーパーユーザのみ実行可能、ただし他のユーザにも関数を実行するEXECUTE権限を与えることができる)
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
<!--
    While recovery is paused no further database changes are applied.
    If in hot standby, all new queries will see the same consistent snapshot
    of the database, and no further query conflicts will be generated until
    recovery is resumed.
-->
リカバリ停止中は、それ以降のデータベースへの変更は適用されません。
ホットスタンバイ側では、新しい問い合わせはすべて、同じ一貫性を持ったデータベースのスナップショットを参照することになります。
そしてリカバリが再開されるまで、これ以上の問い合わせの競合は発生しません。
   </para>

   <para>
<!--
    If streaming replication is disabled, the paused state may continue
    indefinitely without problem. While streaming replication is in
    progress WAL records will continue to be received, which will
    eventually fill available disk space, depending upon the duration of
    the pause, the rate of WAL generation and available disk space.
-->
ストリーミングレプリケーションが無効の場合、停止状態はいつまでも問題なく継続するでしょう。
ストリーミングレプリケーションの実行中は、WALレコードの受信が継続され、停止時間、WALの生成速度、ディスクの残存容量によりますが、ディスク溢れが発生する可能性があります。
   </para>

  </sect2>

  <sect2 id="functions-snapshot-synchronization">
<!--
   <title>Snapshot Synchronization Functions</title>
-->
   <title>スナップショット同期関数</title>

   <indexterm>
     <primary>pg_export_snapshot</primary>
   </indexterm>

   <para>
<!--
    <productname>PostgreSQL</productname> allows database sessions to synchronize their
    snapshots. A <firstterm>snapshot</firstterm> determines which data is visible to the
    transaction that is using the snapshot. Synchronized snapshots are
    necessary when two or more sessions need to see identical content in the
    database. If two sessions just start their transactions independently,
    there is always a possibility that some third transaction commits
    between the executions of the two <command>START TRANSACTION</command> commands,
    so that one session sees the effects of that transaction and the other
    does not.
-->
<productname>PostgreSQL</productname>はデータベースのセッションに対して、それらのスナップショットを同期させることが可能です。
<firstterm>スナップショット</firstterm>は、そのスナップショットを使用しているトランザクションにどのデータが可視かを決定します。
同期スナップショットは、2つ以上のセッションにおいて、全く同じデータベース内容を見たい場合に必要となります。
単に2つのセッションが独立してそれぞれのトランザクションを開始するだけでは、第3のトランザクションのコミットが、2つのトランザクションの<command>START TRANSACTION</command>の狭間で実行され、そのため一方のトランザクションではそのコミット結果が見え、他方では見えないという可能性が常にあります。
   </para>

   <para>
<!--
    To solve this problem, <productname>PostgreSQL</productname> allows a transaction to
    <firstterm>export</firstterm> the snapshot it is using.  As long as the exporting
    transaction remains open, other transactions can <firstterm>import</firstterm> its
    snapshot, and thereby be guaranteed that they see exactly the same view
    of the database that the first transaction sees.  But note that any
    database changes made by any one of these transactions remain invisible
    to the other transactions, as is usual for changes made by uncommitted
    transactions.  So the transactions are synchronized with respect to
    pre-existing data, but act normally for changes they make themselves.
-->
このような問題を解決するため、<productname>PostgreSQL</productname>ではトランザクションが使用しているスナップショットを<firstterm>エクスポート</firstterm>できるようになっています。エクスポートしたトランザクションが開かれ続けている限り、他のトランザクションがそれを<firstterm>インポート</firstterm>することができ、
そしてこれにより最初のトランザクションと正確に同じとなるデータベースの可視性を保証されます。ただし、これらの(スナップショットを共有している)トランザクションによって発生したデータベースへの変更は、コミットされていないトランザクションによる変更と同様に、(スナップショットを共有している)他のトランザクションには見えないままです。
つまり、既存データに対しては同期されますが、それら自身による変更については通常の振る舞いをします。
   </para>

   <para>
<!--
    Snapshots are exported with the <function>pg_export_snapshot</function> function,
    shown in <xref linkend="functions-snapshot-synchronization-table"/>, and
    imported with the <xref linkend="sql-set-transaction"/> command.
-->
スナップショットは、<xref linkend="functions-snapshot-synchronization-table"/>に示す<function>pg_export_snapshot</function>関数を用いてエクスポートされ、<xref linkend="sql-set-transaction"/>コマンドを用いてインポートされます。
   </para>

   <table id="functions-snapshot-synchronization-table">
<!--
    <title>Snapshot Synchronization Functions</title>
-->
    <title>スナップショット同期関数</title>
    <tgroup cols="3">
     <thead>
<!--
      <row><entry>Name</entry> <entry>Return Type</entry> <entry>Description</entry>
-->
      <row><entry>名前</entry> <entry>戻り値型</entry> <entry>説明</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry>
        <literal><function>pg_export_snapshot()</function></literal>
       </entry>
       <entry><type>text</type></entry>
<!--
       <entry>Save the current snapshot and return its identifier</entry>
-->
       <entry>現在のスナップショットを保存し、その識別子を返す</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
<!--
    The function <function>pg_export_snapshot</function> saves the current snapshot
    and returns a <type>text</type> string identifying the snapshot.  This string
    must be passed (outside the database) to clients that want to import the
    snapshot.  The snapshot is available for import only until the end of the
    transaction that exported it.  A transaction can export more than one
    snapshot, if needed.  Note that doing so is only useful in <literal>READ
    COMMITTED</literal> transactions, since in <literal>REPEATABLE READ</literal> and
    higher isolation levels, transactions use the same snapshot throughout
    their lifetime.  Once a transaction has exported any snapshots, it cannot
    be prepared with <xref linkend="sql-prepare-transaction"/>.
-->
<function>pg_export_snapshot</function>関数は現在のスナップショットを保存し、そのスナップショットを識別する<type>text</type>文字列を返します。
この文字列はスナップショットをインポートしたい(データベース外の)クライアントに渡されなければなりません。
エクスポートしたトランザクションが終わるまでの間のみ、そのスナップショットをインポートすることができます。
必要ならばトランザクションは複数のスナップショットをエクスポートできます。
<literal>REPEATABLE READ</literal>や上位の隔離レベルでは、トランザクションはその有効期間の間同じスナップショットを使用しますので、これは<literal>READ COMMITTED</literal>トランザクションでのみ有用であることに注意してください。
一旦スナップショットをエクスポートしたトランザクションでは、<xref linkend="sql-prepare-transaction"/>による準備を使用することができなくなります。
   </para>

   <para>
<!--
    See  <xref linkend="sql-set-transaction"/> for details of how to use an
    exported snapshot.
-->
エクスポートしたトランザクションの使用方法の詳細については<xref linkend="sql-set-transaction"/>を参照してください。
   </para>
  </sect2>

  <sect2 id="functions-replication">
<!--
   <title>Replication Functions</title>
-->
   <title>レプリケーション関数</title>

   <para>
<!--
    The functions shown
    in <xref linkend="functions-replication-table"/> are for
    controlling and interacting with replication features.
    See <xref linkend="streaming-replication"/>,
    <xref linkend="streaming-replication-slots"/>, and
    <xref linkend="replication-origins"/>
    for information about the underlying features.
    Use of functions for replication origin is restricted to superusers.
    Use of functions for replication slot is restricted to superusers
    and users having <literal>REPLICATION</literal> privilege.
-->
<xref linkend="functions-replication-table"/>に示す関数はレプリケーション機能を制御したり、情報を取得したりするためのものです。
基盤となっている機能の情報に関しては<xref linkend="streaming-replication"/>、<xref linkend="streaming-replication-slots"/>、<xref linkend="replication-origins"/>を参照してください。
これらの関数のレプリケーションオリジンでの使用はスーパーユーザに限定されています。
これらの関数のレプリケーションスロットでの使用はスーパーユーザと<literal>REPLICATION</literal>権限を持つユーザに限定されています。
   </para>

   <para>
<!--
    Many of these functions have equivalent commands in the replication
    protocol; see <xref linkend="protocol-replication"/>.
-->
これらの関数の多くには、レプリケーションプロトコルに等価なコマンドがあります。
<xref linkend="protocol-replication"/>を参照してください。
   </para>

   <para>
<!--
    The functions described in
    <xref linkend="functions-admin-backup"/>,
    <xref linkend="functions-recovery-control"/>, and
    <xref linkend="functions-snapshot-synchronization"/>
    are also relevant for replication.
-->
<xref linkend="functions-admin-backup"/>、<xref linkend="functions-recovery-control"/>、<xref linkend="functions-snapshot-synchronization"/>に書かれている関数もレプリケーションに関係するものです。
   </para>

   <table id="functions-replication-table">
<!--
    <title>Replication <acronym>SQL</acronym> Functions</title>
-->
    <title>レプリケーション<acronym>SQL</acronym>関数</title>
    <tgroup cols="3">
     <thead>
      <row>
<!--
       <entry>Function</entry>
       <entry>Return Type</entry>
       <entry>Description</entry>
-->
       <entry>関数</entry>
       <entry>戻り値型</entry>
       <entry>説明</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>
        <indexterm>
         <primary>pg_create_physical_replication_slot</primary>
        </indexterm>
        <literal><function>pg_create_physical_replication_slot(<parameter>slot_name</parameter> <type>name</type> <optional>, <parameter>immediately_reserve</parameter> <type>boolean</type>, <parameter>temporary</parameter> <type>boolean</type></optional>)</function></literal>
       </entry>
       <entry>
        (<parameter>slot_name</parameter> <type>name</type>, <parameter>lsn</parameter> <type>pg_lsn</type>)
       </entry>
       <entry>
<!--
        Creates a new physical replication slot named
        <parameter>slot_name</parameter>. The optional second parameter,
        when <literal>true</literal>, specifies that the <acronym>LSN</acronym> for this
        replication slot be reserved immediately; otherwise
        the <acronym>LSN</acronym> is reserved on first connection from a streaming
        replication client. Streaming changes from a physical slot is only
        possible with the streaming-replication protocol &mdash;
        see <xref linkend="protocol-replication"/>. The optional third
        parameter, <parameter>temporary</parameter>, when set to true, specifies that
        the slot should not be permanently stored to disk and is only meant
        for use by current session. Temporary slots are also
        released upon any error. This function corresponds
        to the replication protocol command <literal>CREATE_REPLICATION_SLOT
        ... PHYSICAL</literal>.
-->

<parameter>slot_name</parameter>という名前の新しい物理レプリケーションスロットを作成します。
2番目のパラメータはオプションで、<literal>true</literal>の場合、このレプリケーションスロットの<acronym>LSN</acronym>が即座に予約されることを指定します。
それ以外の場合は<acronym>LSN</acronym>はストリーミングレプリケーションのクライアントから最初に接続された時に予約されます。
物理スロットからのストリーミングの変更はストリーミングレプリケーションプロトコルでのみ可能です。<xref linkend="protocol-replication"/>を参照してください。
3番目のパラメータ<parameter>temporary</parameter>はオプションで、trueに設定されるとそのスロットは永続的にディスクに保存されるものではなく、現在のセッションによってのみ用いられることを意図していることを指定します。
一時的なスロットはエラーが発生したときも解放されます。
この関数は、レプリケーションプロトコルコマンド<literal>CREATE_REPLICATION_SLOT ... PHYSICAL</literal>に対応するものです。
       </entry>
      </row>
      <row>
       <entry>
        <indexterm>
         <primary>pg_drop_replication_slot</primary>
        </indexterm>
        <literal><function>pg_drop_replication_slot(<parameter>slot_name</parameter> <type>name</type>)</function></literal>
       </entry>
       <entry>
        <type>void</type>
       </entry>
       <entry>
<!--
        Drops the physical or logical replication slot
        named <parameter>slot_name</parameter>. Same as replication protocol
        command <literal>DROP_REPLICATION_SLOT</literal>. For logical slots, this must
        be called when connected to the same database the slot was created on.
-->
<parameter>slot_name</parameter>という名前の物理もしくは論理レプリケーションスロットを削除します。
レプリケーションプロトコルコマンド<literal>DROP_REPLICATION_SLOT</literal>と同じです。
論理スロットの場合、この関数はスロットが作成されたのと同じデータベースに接続している時に呼ばなければなりません。
       </entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>pg_create_logical_replication_slot</primary>
        </indexterm>
        <literal><function>pg_create_logical_replication_slot(<parameter>slot_name</parameter> <type>name</type>, <parameter>plugin</parameter> <type>name</type> <optional>, <parameter>temporary</parameter> <type>boolean</type></optional>)</function></literal>
       </entry>
       <entry>
        (<parameter>slot_name</parameter> <type>name</type>, <parameter>lsn</parameter> <type>pg_lsn</type>)
       </entry>
       <entry>
<!--
        Creates a new logical (decoding) replication slot named
        <parameter>slot_name</parameter> using the output plugin
        <parameter>plugin</parameter>. The optional third
        parameter, <parameter>temporary</parameter>, when set to true, specifies that
        the slot should not be permanently stored to disk and is only meant
        for use by current session. Temporary slots are also
        released upon any error. A call to this function has the same
        effect as the replication protocol command
        <literal>CREATE_REPLICATION_SLOT ... LOGICAL</literal>.
-->
出力プラグイン<parameter>plugin</parameter>を使って<parameter>slot_name</parameter>という名前の新しいロジカル（デコーディング）レプリケーションスロットを作ります。
3番目のオプションパラメータ<parameter>temporary</parameter>をtrueに設定すると、このスロットを永続的にディスクに保存するべきではなく、現在のセッションでのみ使われることを意図します。
また、一時スロットはエラーが起きると解放されます。
この関数の呼び出しはレプリケーションプロトコルコマンドの<literal>CREATE_REPLICATION_SLOT ... LOGICAL</literal>と同じ効果があります。
       </entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>pg_copy_physical_replication_slot</primary>
        </indexterm>
        <literal><function>pg_copy_physical_replication_slot(<parameter>src_slot_name</parameter> <type>name</type>, <parameter>dst_slot_name</parameter> <type>name</type> <optional>, <parameter>temporary</parameter> <type>boolean</type></optional>)</function></literal>
       </entry>
       <entry>
        (<parameter>slot_name</parameter> <type>name</type>, <parameter>lsn</parameter> <type>pg_lsn</type>)
       </entry>
       <entry>
<!--
        Copies an existing physical replication slot named <parameter>src_slot_name</parameter>
        to a physical replication slot named <parameter>dst_slot_name</parameter>.
        The copied physical slot starts to reserve WAL from the same <acronym>LSN</acronym> as the
        source slot.
        <parameter>temporary</parameter> is optional. If <parameter>temporary</parameter>
        is omitted, the same value as the source slot is used.
-->
<parameter>src_slot_name</parameter>という名前の既存の物理レプリケーションスロットを<parameter>dst_slot_name</parameter>という名前の物理レプリケーションスロットにコピーします。
コピーされた物理スロットはソーススロットと同じ<acronym>LSN</acronym>からWALの保存を開始します。
<parameter>temporary</parameter>はオプションです。
<parameter>temporary</parameter>を省略すると、ソーススロットと同じ値を使用します。
       </entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>pg_copy_logical_replication_slot</primary>
        </indexterm>
        <literal><function>pg_copy_logical_replication_slot(<parameter>src_slot_name</parameter> <type>name</type>, <parameter>dst_slot_name</parameter> <type>name</type> <optional>, <parameter>temporary</parameter> <type>boolean</type> <optional>, <parameter>plugin</parameter> <type>name</type></optional></optional>)</function></literal>
       </entry>
       <entry>
        (<parameter>slot_name</parameter> <type>name</type>, <parameter>lsn</parameter> <type>pg_lsn</type>)
       </entry>
       <entry>
<!--
        Copies an existing logical replication slot name <parameter>src_slot_name</parameter>
        to a logical replication slot named <parameter>dst_slot_name</parameter>
        while changing the output plugin and persistence. The copied logical slot starts
        from the same <acronym>LSN</acronym> as the source logical slot. Both
        <parameter>temporary</parameter> and <parameter>plugin</parameter> are optional.
        If <parameter>temporary</parameter> or <parameter>plugin</parameter> are omitted,
        the same values as the source logical slot are used.
-->
<parameter>src_slot_name</parameter>という名前の既存の論理レプリケーションスロットを<parameter>dst_slot_name</parameter>という名前の論理レプリケーションスロットに出力プラグインと永続性を変更しながらコピーします。
コピーされたロジカルスロットはソースロジカルスロットと同じ<acronym>LSN</acronym>から開始します。
<parameter>temporary</parameter>と<parameter>plugin</parameter>はどちらもオプションです。
<parameter>temporary</parameter>あるいは<parameter>plugin</parameter>を省略すると、ソースロジカルスロットと同じ値が使用されます。
       </entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>pg_logical_slot_get_changes</primary>
        </indexterm>
        <literal><function>pg_logical_slot_get_changes(<parameter>slot_name</parameter> <type>name</type>, <parameter>upto_lsn</parameter> <type>pg_lsn</type>, <parameter>upto_nchanges</parameter> <type>int</type>, VARIADIC <parameter>options</parameter> <type>text[]</type>)</function></literal>
       </entry>
       <entry>
        (<parameter>lsn</parameter> <type>pg_lsn</type>, <parameter>xid</parameter> <type>xid</type>, <parameter>data</parameter> <type>text</type>)
       </entry>
       <entry>
<!--
        Returns changes in the slot <parameter>slot_name</parameter>, starting
        from the point at which since changes have been consumed last.  If
        <parameter>upto_lsn</parameter> and <parameter>upto_nchanges</parameter> are NULL,
        logical decoding will continue until end of WAL.  If
        <parameter>upto_lsn</parameter> is non-NULL, decoding will include only
        those transactions which commit prior to the specified LSN.  If
        <parameter>upto_nchanges</parameter> is non-NULL, decoding will
        stop when the number of rows produced by decoding exceeds
        the specified value.  Note, however, that the actual number of
        rows returned may be larger, since this limit is only checked after
        adding the rows produced when decoding each new transaction commit.
-->
変更が最後に消費された時点から開始して、スロット<parameter>slot_name</parameter>の変更を返します。
<parameter>upto_lsn</parameter>と<parameter>upto_nchanges</parameter>がNULLならば論理デコードはWALの最後まで続きます。
<parameter>upto_lsn</parameter>が非NULLであれば、デコードは指定されたLSNより前にコミットされたトランザクションのみを含みます。
<parameter>upto_nchanges</parameter>が非NULLであれば、デコードにより生成された行の数が指定された値を越えたときに、デコードは止まります。
しかしながら、新しいトランザクションの各コミットをデコードして生成された行を追加した後でしかこの制限は確認されませんので、実際に返される行の数は大きいかもしれないことに注意してください。
       </entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>pg_logical_slot_peek_changes</primary>
        </indexterm>
        <literal><function>pg_logical_slot_peek_changes(<parameter>slot_name</parameter> <type>name</type>, <parameter>upto_lsn</parameter> <type>pg_lsn</type>, <parameter>upto_nchanges</parameter> <type>int</type>, VARIADIC <parameter>options</parameter> <type>text[]</type>)</function></literal>
       </entry>
       <entry>
        (<parameter>lsn</parameter> <type>pg_lsn</type>, <parameter>xid</parameter> <type>xid</type>, <parameter>data</parameter> <type>text</type>)
       </entry>
       <entry>
<!--
        Behaves just like
        the <function>pg_logical_slot_get_changes()</function> function,
        except that changes are not consumed; that is, they will be returned
        again on future calls.
-->
        変更が消費されないということを除いて、<function>pg_logical_slot_get_changes()</function>関数と同じように振る舞います。すなわち、将来の呼び出しでは再び同じものが返ります。
       </entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>pg_logical_slot_get_binary_changes</primary>
        </indexterm>
        <literal><function>pg_logical_slot_get_binary_changes(<parameter>slot_name</parameter> <type>name</type>, <parameter>upto_lsn</parameter> <type>pg_lsn</type>, <parameter>upto_nchanges</parameter> <type>int</type>, VARIADIC <parameter>options</parameter> <type>text[]</type>)</function></literal>
       </entry>
       <entry>
        (<parameter>lsn</parameter> <type>pg_lsn</type>, <parameter>xid</parameter> <type>xid</type>, <parameter>data</parameter> <type>bytea</type>)
       </entry>
       <entry>
<!--
        Behaves just like
        the <function>pg_logical_slot_get_changes()</function> function,
        except that changes are returned as <type>bytea</type>.
-->
        変更は<type>bytea</type>として返されるということを除いて<function>pg_logical_slot_get_changes()</function>関数と同じように振る舞います。
       </entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>pg_logical_slot_peek_binary_changes</primary>
        </indexterm>
        <literal><function>pg_logical_slot_peek_binary_changes(<parameter>slot_name</parameter> <type>name</type>, <parameter>upto_lsn</parameter> <type>pg_lsn</type>, <parameter>upto_nchanges</parameter> <type>int</type>, VARIADIC <parameter>options</parameter> <type>text[]</type>)</function></literal>
       </entry>
       <entry>
        (<parameter>lsn</parameter> <type>pg_lsn</type>, <parameter>xid</parameter> <type>xid</type>, <parameter>data</parameter> <type>bytea</type>)
       </entry>
       <entry>
<!--
        Behaves just like
        the <function>pg_logical_slot_get_changes()</function> function,
        except that changes are returned as <type>bytea</type> and that
        changes are not consumed; that is, they will be returned again
        on future calls.
-->
        変更は<type>bytea</type>として返され消費されないということを除いて<function>pg_logical_slot_get_changes()</function>関数と同じように振る舞います。すなわち、将来の呼び出しでは再び同じものが返ります。
       </entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>pg_replication_slot_advance</primary>
        </indexterm>
        <literal><function>pg_replication_slot_advance(<parameter>slot_name</parameter> <type>name</type>, <parameter>upto_lsn</parameter> <type>pg_lsn</type>)</function></literal>
       </entry>
       <entry>
        (<parameter>slot_name</parameter> <type>name</type>, <parameter>end_lsn</parameter> <type>pg_lsn</type>)
        <type>bool</type>
       </entry>
       <entry>
<!--
        Advances the current confirmed position of a replication slot named
        <parameter>slot_name</parameter>. The slot will not be moved backwards,
        and it will not be moved beyond the current insert location.  Returns
        name of the slot and real position to which it was advanced to.
-->
<parameter>slot_name</parameter>という名前のレプリケーションスロットの現在の確認された位置を進めます。
スロットは後方には動きませんし、現在の挿入位置を超えて進むこともありません。
スロットの名前と前に進んだ実際の位置を返します。
       </entry>
      </row>

      <row>
       <entry id="pg-replication-origin-create">
        <indexterm>
         <primary>pg_replication_origin_create</primary>
        </indexterm>
        <literal><function>pg_replication_origin_create(<parameter>node_name</parameter> <type>text</type>)</function></literal>
       </entry>
       <entry>
        <type>oid</type>
       </entry>
       <entry>
<!--
        Create a replication origin with the given external
        name, and return the internal id assigned to it.
-->
指定した外部名でレプリケーション起点を作成し、割り当てられた内部IDを返します。
       </entry>
      </row>

      <row>
       <entry id="pg-replication-origin-drop">
        <indexterm>
         <primary>pg_replication_origin_drop</primary>
        </indexterm>
        <literal><function>pg_replication_origin_drop(<parameter>node_name</parameter> <type>text</type>)</function></literal>
       </entry>
       <entry>
        <type>void</type>
       </entry>
       <entry>
<!--
        Delete a previously created replication origin, including any
        associated replay progress.
-->
以前に作成されたレプリケーション起点を、それに関連するすべての再生の進捗も含めて削除します。
       </entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>pg_replication_origin_oid</primary>
        </indexterm>
        <literal><function>pg_replication_origin_oid(<parameter>node_name</parameter> <type>text</type>)</function></literal>
       </entry>
       <entry>
        <type>oid</type>
       </entry>
       <entry>
<!--
        Lookup a replication origin by name and return the internal id. If no
        corresponding replication origin is found an error is thrown.
-->
レプリケーション起点を名前で検索し、内部IDを返します。
相当するレプリケーション起点が見つからない場合はエラーが発生します。
       </entry>
      </row>

      <row>
       <entry id="pg-replication-origin-session-setup">
        <indexterm>
         <primary>pg_replication_origin_session_setup</primary>
        </indexterm>
        <literal><function>pg_replication_origin_session_setup(<parameter>node_name</parameter> <type>text</type>)</function></literal>
       </entry>
       <entry>
        <type>void</type>
       </entry>
       <entry>
<!--
        Mark the current session as replaying from the given
        origin, allowing replay progress to be tracked.  Use
        <function>pg_replication_origin_session_reset</function> to revert.
        Can only be used if no previous origin is configured.
-->
現在のセッションに、指定の起点から再生中であると印を付け、再生の進捗が追跡できるようにします。
元に戻すには<function>pg_replication_origin_session_reset</function>を使って下さい。
以前に起点が設定されていない場合にのみ使うことができます。
       </entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>pg_replication_origin_session_reset</primary>
        </indexterm>
        <literal><function>pg_replication_origin_session_reset()</function></literal>
       </entry>
       <entry>
        <type>void</type>
       </entry>
       <entry>
<!--
        Cancel the effects
        of <function>pg_replication_origin_session_setup()</function>.
-->
<function>pg_replication_origin_session_setup()</function>の効果を取り消します。
       </entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>pg_replication_origin_session_is_setup</primary>
        </indexterm>
        <literal><function>pg_replication_origin_session_is_setup()</function></literal>
       </entry>
       <entry>
        <type>bool</type>
       </entry>
       <entry>
<!--
        Has a replication origin been configured in the current session?
-->
現在のセッションで、レプリケーション起点が設定されたかどうかを返します。
       </entry>
      </row>

      <row>
       <entry id="pg-replication-origin-session-progress">
        <indexterm>
         <primary>pg_replication_origin_session_progress</primary>
        </indexterm>
        <literal><function>pg_replication_origin_session_progress(<parameter>flush</parameter> <type>bool</type>)</function></literal>
       </entry>
       <entry>
        <type>pg_lsn</type>
       </entry>
       <entry>
<!--
        Return the replay location for the replication origin configured in
        the current session. The parameter <parameter>flush</parameter>
        determines whether the corresponding local transaction will be
        guaranteed to have been flushed to disk or not.
-->
現在のセッションで設定されたレプリケーション起点の再生位置を返します。
パラメータ<parameter>flush</parameter>により、対応するローカルトランザクションがディスクにフラッシュされていることが保証されるかどうかを決定します。
       </entry>
      </row>

      <row>
       <entry id="pg-replication-origin-xact-setup">
        <indexterm>
         <primary>pg_replication_origin_xact_setup</primary>
        </indexterm>
        <literal><function>pg_replication_origin_xact_setup(<parameter>origin_lsn</parameter> <type>pg_lsn</type>, <parameter>origin_timestamp</parameter> <type>timestamptz</type>)</function></literal>
       </entry>
       <entry>
        <type>void</type>
       </entry>
       <entry>
<!--
        Mark the current transaction as replaying a transaction that has
        committed at the given <acronym>LSN</acronym> and timestamp. Can
        only be called when a replication origin has previously been
        configured using
        <function>pg_replication_origin_session_setup()</function>.
-->
現在のトランザクションに、指定の<acronym>LSN</acronym>およびタイムスタンプでコミットしたトランザクションを再生中であると印をつけます。
事前にレプリケーション起点が<function>pg_replication_origin_session_setup()</function>を使って設定されている場合にのみ呼び出せます。
       </entry>
      </row>

      <row>
       <entry id="pg-replication-origin-xact-reset">
        <indexterm>
         <primary>pg_replication_origin_xact_reset</primary>
        </indexterm>
        <literal><function>pg_replication_origin_xact_reset()</function></literal>
       </entry>
       <entry>
        <type>void</type>
       </entry>
       <entry>
<!--
        Cancel the effects of
        <function>pg_replication_origin_xact_setup()</function>.
-->
<function>pg_replication_origin_xact_setup()</function>の効果を取り消します。
       </entry>
      </row>

      <row>
       <entry id="pg-replication-origin-advance">
        <indexterm>
         <primary>pg_replication_origin_advance</primary>
        </indexterm>
        <literal>pg_replication_origin_advance<function>(<parameter>node_name</parameter> <type>text</type>, <parameter>lsn</parameter> <type>pg_lsn</type>)</function></literal>
       </entry>
       <entry>
        <type>void</type>
       </entry>
       <entry>
<!--
        Set replication progress for the given node to the given
        location. This primarily is useful for setting up the initial location
        or a new location after configuration changes and similar. Be aware
        that careless use of this function can lead to inconsistently
        replicated data.
-->
指定したノードのレプリケーションの進捗を、指定の位置に設定します。
これは主に設定変更の後で初期位置や新しい位置を設定するときなどに役立ちます。
この関数を不注意に使うと、レプリケーションデータが一貫性を失うかもしれないことに注意して下さい。
       </entry>
      </row>

      <row>
       <entry id="pg-replication-origin-progress">
        <indexterm>
         <primary>pg_replication_origin_progress</primary>
        </indexterm>
        <literal><function>pg_replication_origin_progress(<parameter>node_name</parameter> <type>text</type>, <parameter>flush</parameter> <type>bool</type>)</function></literal>
       </entry>
       <entry>
        <type>pg_lsn</type>
       </entry>
       <entry>
<!--
        Return the replay location for the given replication origin. The
        parameter <parameter>flush</parameter> determines whether the
        corresponding local transaction will be guaranteed to have been
        flushed to disk or not.
-->
指定したレプリケーション起点の再生位置を返します。
パラメータ<parameter>flush</parameter>により、対応するローカルトランザクションがディスクにフラッシュされていることが保証されるかどうかを決定します。
       </entry>
      </row>

      <row>
       <entry id="pg-logical-emit-message-text">
        <indexterm>
         <primary>pg_logical_emit_message</primary>
        </indexterm>
        <literal><function>pg_logical_emit_message(<parameter>transactional</parameter> <type>bool</type>, <parameter>prefix</parameter> <type>text</type>, <parameter>content</parameter> <type>text</type>)</function></literal>
       </entry>
       <entry>
        <type>pg_lsn</type>
       </entry>
       <entry>
<!--
        Emit text logical decoding message. This can be used to pass generic
        messages to logical decoding plugins through WAL. The parameter
        <parameter>transactional</parameter> specifies if the message should
        be part of current transaction or if it should be written immediately
        and decoded as soon as the logical decoding reads the record. The
        <parameter>prefix</parameter> is textual prefix used by the logical
        decoding plugins to easily recognize interesting messages for them.
        The <parameter>content</parameter> is the text of the message.
-->
論理デコードのテキストのメッセージを送出します
これは汎用的なメッセージをWALを通して論理デコードのプラグインに渡すのに使うことができます。
パラメータ<parameter>transactional</parameter>は、メッセージが現在のトランザクションの一部なのか、あるいはすぐに書き込み、論理デコードがレコードを読んだらすぐにデコードされるべきものなのかを指定します。
<parameter>prefix</parameter>は文字通りの接頭辞で、論理デコードのプラグインが、自分にとって関心のあるメッセージを容易に認識できるように使われます。
<parameter>content</parameter>はメッセージのテキストです。
       </entry>
      </row>

      <row>
       <entry id="pg-logical-emit-message-bytea">
        <literal><function>pg_logical_emit_message(<parameter>transactional</parameter> <type>bool</type>, <parameter>prefix</parameter> <type>text</type>, <parameter>content</parameter> <type>bytea</type>)</function></literal>
       </entry>
       <entry>
        <type>pg_lsn</type>
       </entry>
       <entry>
<!--
        Emit binary logical decoding message. This can be used to pass generic
        messages to logical decoding plugins through WAL. The parameter
        <parameter>transactional</parameter> specifies if the message should
        be part of current transaction or if it should be written immediately
        and decoded as soon as the logical decoding reads the record. The
        <parameter>prefix</parameter> is textual prefix used by the logical
        decoding plugins to easily recognize interesting messages for them.
        The <parameter>content</parameter> is the binary content of the
        message.
-->
論理デコードのバイナリのメッセージを送出します
これは汎用的なメッセージをWALを通して論理デコードのプラグインに渡すのに使うことができます。
パラメータ<parameter>transactional</parameter>は、メッセージが現在のトランザクションの一部なのか、あるいはすぐに書き込み、論理デコードがレコードを読んだらすぐにデコードされるべきものなのかを指定します。
<parameter>prefix</parameter>は文字通りの接頭辞で、論理デコードのプラグインが、自分にとって関心のあるメッセージを容易に認識できるように使われます。
<parameter>content</parameter>はメッセージのバイナリの内容です。
       </entry>
      </row>

     </tbody>
    </tgroup>
   </table>

  </sect2>

  <sect2 id="functions-admin-dbobject">
<!--
   <title>Database Object Management Functions</title>
-->
   <title>データベースオブジェクト管理関数</title>

   <para>
<!--
    The functions shown in <xref linkend="functions-admin-dbsize"/> calculate
    the disk space usage of database objects.
-->
<xref linkend="functions-admin-dbsize"/>で示された関数はデータベースオブジェクトのディスク領域を計算します。
   </para>

   <indexterm>
    <primary>pg_column_size</primary>
   </indexterm>
   <indexterm>
    <primary>pg_database_size</primary>
   </indexterm>
   <indexterm>
    <primary>pg_indexes_size</primary>
   </indexterm>
   <indexterm>
    <primary>pg_relation_size</primary>
   </indexterm>
   <indexterm>
    <primary>pg_size_bytes</primary>
   </indexterm>
   <indexterm>
    <primary>pg_size_pretty</primary>
   </indexterm>
   <indexterm>
    <primary>pg_table_size</primary>
   </indexterm>
   <indexterm>
    <primary>pg_tablespace_size</primary>
   </indexterm>
   <indexterm>
    <primary>pg_total_relation_size</primary>
   </indexterm>

   <table id="functions-admin-dbsize">
<!--
    <title>Database Object Size Functions</title>
-->
    <title>データベースオブジェクト容量関数</title>
    <tgroup cols="3">
     <thead>
<!--
      <row><entry>Name</entry> <entry>Return Type</entry> <entry>Description</entry>
-->
      <row><entry>名前</entry> <entry>戻り型</entry> <entry>説明</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry><literal><function>pg_column_size(<type>any</type>)</function></literal></entry>
       <entry><type>int</type></entry>
<!--
       <entry>Number of bytes used to store a particular value (possibly compressed)</entry>
-->
       <entry>特定の値を格納するのに使用される（場合により圧縮された）バイト数</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_database_size(<type>oid</type>)</function></literal>
        </entry>
       <entry><type>bigint</type></entry>
<!--
       <entry>Disk space used by the database with the specified OID</entry>
-->
       <entry>指定されたOIDのデータベースで使用されるディスク容量</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_database_size(<type>name</type>)</function></literal>
        </entry>
       <entry><type>bigint</type></entry>
<!--
       <entry>Disk space used by the database with the specified name</entry>
-->
       <entry>指定された名前のデータベースで使用されるディスク容量</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_indexes_size(<type>regclass</type>)</function></literal>
        </entry>
       <entry><type>bigint</type></entry>
       <entry>
<!--
        Total disk space used by indexes attached to the specified table
-->
指定されテーブルに付与されたインデックスで使用される総ディスク容量。
       </entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_relation_size(<parameter>relation</parameter> <type>regclass</type>, <parameter>fork</parameter> <type>text</type>)</function></literal>
        </entry>
       <entry><type>bigint</type></entry>
       <entry>
<!--
        Disk space used by the specified fork (<literal>'main'</literal>,
        <literal>'fsm'</literal>, <literal>'vm'</literal>, or <literal>'init'</literal>)
        of the specified table or index
-->
指定されたテーブルまたはインデックスの指定されたフォーク（<literal>'main'</literal>、<literal>'fsm'</literal>、<literal>'vm'</literal>または<literal>'init'</literal>）で使用されるディスク容量
       </entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_relation_size(<parameter>relation</parameter> <type>regclass</type>)</function></literal>
        </entry>
       <entry><type>bigint</type></entry>
       <entry>
<!--
        Shorthand for <literal>pg_relation_size(..., 'main')</literal>
-->
<literal>pg_relation_size(..., 'main')</literal>の省略表現
       </entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_size_bytes(<type>text</type>)</function></literal>
        </entry>
       <entry><type>bigint</type></entry>
       <entry>
<!--
         Converts a size in human-readable format with size units into bytes
-->
単位付きの可読性の高い形式のサイズをバイトに変換
       </entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_size_pretty(<type>bigint</type>)</function></literal>
        </entry>
       <entry><type>text</type></entry>
       <entry>
<!--
         Converts a size in bytes expressed as a 64-bit integer into a
         human-readable format with size units
-->
64ビット整数で表現されたサイズ（バイト数）を、サイズの単位をつけた可読性が高い書式に変換
       </entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_size_pretty(<type>numeric</type>)</function></literal>
        </entry>
       <entry><type>text</type></entry>
       <entry>
<!--
         Converts a size in bytes expressed as a numeric value into a
         human-readable format with size units
-->
numeric値で表現されたサイズ（バイト数）を、サイズの単位をつけた可読性が高い書式に変換
       </entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_table_size(<type>regclass</type>)</function></literal>
        </entry>
       <entry><type>bigint</type></entry>
       <entry>
<!--
        Disk space used by the specified table, excluding indexes
        (but including TOAST, free space map, and visibility map)
-->
指定されたテーブルで使用されるディスク容量、インデックスは除外する（しかしTOAST、空き領域マップ、可視性マップは含む）
       </entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_tablespace_size(<type>oid</type>)</function></literal>
        </entry>
       <entry><type>bigint</type></entry>
<!--
       <entry>Disk space used by the tablespace with the specified OID</entry>
-->
       <entry>指定されたOIDを持つテーブル空間で使用されるディスク容量</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_tablespace_size(<type>name</type>)</function></literal>
        </entry>
       <entry><type>bigint</type></entry>
<!--
       <entry>Disk space used by the tablespace with the specified name</entry>
-->
       <entry>指定された名前を持つテーブル空間で使用されるディスク容量</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_total_relation_size(<type>regclass</type>)</function></literal>
        </entry>
       <entry><type>bigint</type></entry>
       <entry>
<!--
        Total disk space used by the specified table,
        including all indexes and <acronym>TOAST</acronym> data
-->
指定されたテーブルで使用される、すべてのインデックスと<acronym>TOAST</acronym>データを含むディスク総容量
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
<!--
    <function>pg_column_size</function> shows the space used to store any individual
    data value.
-->
    <function>pg_column_size</function>は任意の個別のデータ値を格納するのに使用されている領域を示します。
   </para>

   <para>
<!--
    <function>pg_total_relation_size</function> accepts the OID or name of a
    table or toast table, and returns the total on-disk space used for
    that table, including all associated indexes.  This function is
    equivalent to <function>pg_table_size</function>
    <literal>+</literal> <function>pg_indexes_size</function>.
-->
<function>pg_total_relation_size</function>は、テーブルまたはTOASTテーブルのOIDまたは名前を受け付け、指定されたテーブルと関連する全てのインデックスで使用される総ディスク容量を返します。
この関数は<function>pg_table_size</function> <literal>+</literal> <function>pg_indexes_size</function> の結果と等しいです。
   </para>

   <para>
<!--
    <function>pg_table_size</function> accepts the OID or name of a table and
    returns the disk space needed for that table, exclusive of indexes.
    (TOAST space, free space map, and visibility map are included.)
-->
<function>pg_table_size</function>は、テーブルのOIDまたは名前を受け付け、インデックスを除いたテーブルのみで使用されるディスク容量を返します。
(TOAST領域、空き領域マップ、可視性マップは含みます。)
   </para>

   <para>
<!--
    <function>pg_indexes_size</function> accepts the OID or name of a table and
    returns the total disk space used by all the indexes attached to that
    table.
-->
<function>pg_indexes_size</function>は、テーブルのOIDまたは名前を受け付け、指定されたテーブル付与されている全てのインデックスで使用されるディスク容量を返します。
   </para>

   <para>
<!--
    <function>pg_database_size</function> and <function>pg_tablespace_size</function>
    accept the OID or name of a database or tablespace, and return the total
    disk space used therein.  To use <function>pg_database_size</function>,
    you must have <literal>CONNECT</literal> permission on the specified database
    (which is granted by default), or be a member of the <literal>pg_read_all_stats</literal>
    role. To use <function>pg_tablespace_size</function>, you must have
    <literal>CREATE</literal> permission on the specified tablespace, or be a member
    of the <literal>pg_read_all_stats</literal> role unless it is the default tablespace for
    the current database.
-->
<function>pg_database_size</function>と<function>pg_tablespace_size</function>はデータベースまたはテーブル空間の名前またはOIDを受付け、そこで使用される総容量を返します。
<function>pg_database_size</function>を使うためには、指定されたデータベースに<literal>CONNECT</literal>権限(デフォルトで付与されている)を持っているか、あるいは<literal>pg_read_all_stats</literal>ロールのメンバーでなければなりません。
<function>pg_tablespace_size</function>を使うためには、それが現在のデータベースのデフォルトテーブル空間でない限り、指定されたテーブル空間に<literal>CREATE</literal>権限を持っているか、あるいは<literal>pg_read_all_stats</literal>ロールのメンバーでなければなりません。
   </para>

   <para>
<!--
    <function>pg_relation_size</function> accepts the OID or name of a table, index
    or toast table, and returns the on-disk size in bytes of one fork of
    that relation.  (Note that for most purposes it is more convenient to
    use the higher-level functions <function>pg_total_relation_size</function>
    or <function>pg_table_size</function>, which sum the sizes of all forks.)
    With one argument, it returns the size of the main data fork of the
    relation.  The second argument can be provided to specify which fork
    to examine:
-->
<function>pg_relation_size</function>は、テーブル、インデックス、またはTOASTテーブルのOIDまたは名前を受け付け、そのリレーションの1つのフォークのディスク容量をバイト単位で返します。
(たいていの目的には、高位の関数<function>pg_total_relation_size</function>や<function>pg_table_size</function>を使うのがより便利であることに注意してください。高位の関数はフォークすべての容量を合計します。)
引数1つでは、そのリレーションの主データフォークの容量を返します。
2番目の引数はどのフォークを調査するかを指定するために設定できます。
    <itemizedlist spacing="compact">
     <listitem>
      <para>
<!--
       <literal>'main'</literal> returns the size of the main
       data fork of the relation.
-->
<literal>'main'</literal>を指定すると、そのリレーションの主データフォークの容量を返します。
      </para>
     </listitem>
     <listitem>
      <para>
<!--
       <literal>'fsm'</literal> returns the size of the Free Space Map
       (see <xref linkend="storage-fsm"/>) associated with the relation.
-->
<literal>'fsm'</literal>を指定すると、リレーションに関連した空き領域マップ(<xref linkend="storage-fsm"/>を参照)を返します。
      </para>
     </listitem>
     <listitem>
      <para>
<!--
       <literal>'vm'</literal> returns the size of the Visibility Map
       (see <xref linkend="storage-vm"/>) associated with the relation.
-->
<literal>'vm'</literal>を指定すると、リレーションに関連した可視性マップ(<xref linkend="storage-vm"/>を参照)の容量を返します。
      </para>
     </listitem>
     <listitem>
      <para>
<!--
       <literal>'init'</literal> returns the size of the initialization
       fork, if any, associated with the relation.
-->
<literal>'init'</literal>を指定すると、もしあれば、リレーションに関連した初期化フォークの容量を返します。
      </para>
     </listitem>
    </itemizedlist>
   </para>

   <para>
<!--
    <function>pg_size_pretty</function> can be used to format the result of one of
    the other functions in a human-readable way, using bytes, kB, MB, GB or TB
    as appropriate.
-->
<function>pg_size_pretty</function>は、適切にbytes、kB、MB、GB、もしくはTB単位を使用して目で見て判るようにその他の関数の1つの結果を整形するのに使用可能です。
   </para>

   <para>
<!--
    <function>pg_size_bytes</function> can be used to get the size in bytes from a
    string in human-readable format. The input may have units of bytes, kB,
    MB, GB or TB, and is parsed case-insensitively. If no units are specified,
    bytes are assumed.
-->
<function>pg_size_bytes</function>可読性の高い形式の文字列からバイト単位のサイズを取得するのに使用可能です。
入力はbytes、kB、MB、GB、TBの単位を使用可能で、大文字小文字を区別せずに解釈されます。
単位の指定がなければ、bytes（バイト）であるとみなされます。
   </para>

   <note>
    <para>
<!--
     The units kB, MB, GB and TB used by the functions
     <function>pg_size_pretty</function> and <function>pg_size_bytes</function> are defined
     using powers of 2 rather than powers of 10, so 1kB is 1024 bytes, 1MB is
     1024<superscript>2</superscript> = 1048576 bytes, and so on.
-->
<function>pg_size_pretty</function>および<function>pg_size_bytes</function>が利用するkB、MB、GB、TBの単位は10のべき乗ではなく2のべき乗として定義されているため、1kBは1024バイト、1MBは1024<superscript>2</superscript> = 1048576バイト、それ以上も同じようになります。
    </para>
   </note>

   <para>
<!--
    The functions above that operate on tables or indexes accept a
    <type>regclass</type> argument, which is simply the OID of the table or index
    in the <structname>pg_class</structname> system catalog.  You do not have to look up
    the OID by hand, however, since the <type>regclass</type> data type's input
    converter will do the work for you.  Just write the table name enclosed in
    single quotes so that it looks like a literal constant.  For compatibility
    with the handling of ordinary <acronym>SQL</acronym> names, the string
    will be converted to lower case unless it contains double quotes around
    the table name.
-->
上記の関数において、テーブルやインデックスを<type>regclass</type>引数として受け取って処理するものがありますが、この引数は単に<structname>pg_class</structname>システムカタログにあるテーブルやインデックスのOIDです。
ただし、<type>regclass</type>データ型が自動で入力変換を行うため、ユーザが手動で該当するOIDを調べる必要はありません。リテラル定数のようにシングルクオートで囲んだテーブル名を記述するだけです。
通常のSQL名に対する処理互換のため、テーブル名をダブルクオートで囲わない限り、テーブル名として入力された文字列は小文字に変換されます。
   </para>

   <para>
<!--
    If an OID that does not represent an existing object is passed as
    argument to one of the above functions, NULL is returned.
-->
上記の関数に対し、既存オブジェクトに該当するものがないOIDが渡された場合はNULLが返されます。
   </para>

   <para>
<!--
    The functions shown in <xref linkend="functions-admin-dblocation"/> assist
    in identifying the specific disk files associated with database objects.
-->
<xref linkend="functions-admin-dblocation"/> に示される関数は、データベースオブジェクトに関連する特定のディスクファイルを確認する際の手助けとなります。
   </para>

   <indexterm>
    <primary>pg_relation_filenode</primary>
   </indexterm>
   <indexterm>
    <primary>pg_relation_filepath</primary>
   </indexterm>
   <indexterm>
    <primary>pg_filenode_relation</primary>
   </indexterm>

   <table id="functions-admin-dblocation">
<!--
    <title>Database Object Location Functions</title>
-->
    <title>データベースオブジェクト位置関数</title>
    <tgroup cols="3">
     <thead>
<!--
      <row><entry>Name</entry> <entry>Return Type</entry> <entry>Description</entry>
-->
      <row><entry>名前</entry> <entry>戻り型</entry> <entry>説明</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry>
        <literal><function>pg_relation_filenode(<parameter>relation</parameter> <type>regclass</type>)</function></literal>
        </entry>
       <entry><type>oid</type></entry>
       <entry>
<!--
        Filenode number of the specified relation
-->
        指定されたリレーションのファイルノード番号
       </entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_relation_filepath(<parameter>relation</parameter> <type>regclass</type>)</function></literal>
        </entry>
       <entry><type>text</type></entry>
       <entry>
<!--
        File path name of the specified relation
-->
        指定されたリレーションのファイルパス
       </entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_filenode_relation(<parameter>tablespace</parameter> <type>oid</type>, <parameter>filenode</parameter> <type>oid</type>)</function></literal>
        </entry>
       <entry><type>regclass</type></entry>
       <entry>
<!--
        Find the relation associated with a given tablespace and filenode
-->
        与えられたテーブル空間とファイルノードに関連するリレーションを見つける
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
<!--
    <function>pg_relation_filenode</function> accepts the OID or name of a table,
    index, sequence, or toast table, and returns the <quote>filenode</quote> number
    currently assigned to it.  The filenode is the base component of the file
    name(s) used for the relation (see <xref linkend="storage-file-layout"/>
    for more information).  For most tables the result is the same as
    <structname>pg_class</structname>.<structfield>relfilenode</structfield>, but for certain
    system catalogs <structfield>relfilenode</structfield> is zero and this function must
    be used to get the correct value.  The function returns NULL if passed
    a relation that does not have storage, such as a view.
-->
<function>pg_relation_filenode</function>は、テーブル、インデックス、シーケンス、もしくはTOASTテーブルのOIDまたは名前を受け付け、現在それに充てられている<quote>ファイルノード</quote>番号を返します。
ファイルノードは、リレーションに使用しているファイル名の基礎部分です(詳しくは<xref linkend="storage-file-layout"/>を参照して下さい)。
ほとんどのテーブルについては、結果が<structname>pg_class</structname>.<structfield>relfilenode</structfield>と同じになります。ただし、いくつかのシステムカタログでは<structfield>relfilenode</structfield>が0になるため、これらのシステムカタログの正しいファイルノードを取得するには、この関数を使用しなければいけません。
この関数は、ビューの様にストレージに格納されないリレーションが指定された場合はNULLを返します。
   </para>

   <para>
<!--
    <function>pg_relation_filepath</function> is similar to
    <function>pg_relation_filenode</function>, but it returns the entire file path name
    (relative to the database cluster's data directory <varname>PGDATA</varname>) of
    the relation.
-->
<function>pg_relation_filepath</function>は<function>pg_relation_filenode</function>と似ていますが、こちらはリレーションのファイルパス名(データベースクラスタのディレクトリである<varname>PGDATA</varname>からの相対パス)を返します。
   </para>

   <para>
<!--
    <function>pg_filenode_relation</function> is the reverse of
    <function>pg_relation_filenode</function>. Given a <quote>tablespace</quote> OID and
    a <quote>filenode</quote>, it returns the associated relation's OID. For a table
    in the database's default tablespace, the tablespace can be specified as 0.
-->
<function>pg_filenode_relation</function>は<function>pg_relation_filenode</function>の逆です。
<quote>テーブル空間</quote>OIDと<quote>ファイルノード</quote>を与えると、関連するリレーションのOIDを返します。
データベースのデフォルトテーブル空間内のテーブルに対しては、テーブル空間は0と指定できます。
   </para>

   <para>
<!--
    <xref linkend="functions-admin-collation"/> lists functions used to manage
    collations.
-->
<xref linkend="functions-admin-collation"/>に照合順序の管理に使用される関数の一覧を示します。
   </para>

   <table id="functions-admin-collation">
<!--
    <title>Collation Management Functions</title>
-->
    <title>照合順序管理関数</title>
    <tgroup cols="3">
     <thead>
<!--
      <row><entry>Name</entry> <entry>Return Type</entry> <entry>Description</entry></row>
-->
      <row><entry>名前</entry> <entry>戻り型</entry> <entry>説明</entry></row>
     </thead>

     <tbody>
      <row>
       <entry>
        <indexterm><primary>pg_collation_actual_version</primary></indexterm>
        <literal><function>pg_collation_actual_version(<type>oid</type>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
<!--
       <entry>Return actual version of collation from operating system</entry>
-->
       <entry>照合順序の実際のバージョンをオペレーティングシステムから返す</entry>
      </row>
      <row>
       <entry>
        <indexterm><primary>pg_import_system_collations</primary></indexterm>
        <literal><function>pg_import_system_collations(<parameter>schema</parameter> <type>regnamespace</type>)</function></literal>
       </entry>
       <entry><type>integer</type></entry>
<!--
       <entry>Import operating system collations</entry>
-->
       <entry>オペレーティングシステムの照合順序をインポートする</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
<!--
    <function>pg_collation_actual_version</function> returns the actual
    version of the collation object as it is currently installed in the
    operating system.  If this is different from the value
    in <literal>pg_collation.collversion</literal>, then objects depending on
    the collation might need to be rebuilt.  See also
    <xref linkend="sql-altercollation"/>.
-->
<function>pg_collation_actual_version</function>は照合順序の実際のバージョンをオペレーティングシステムに現在インストールされている通りに返します。
これが<literal>pg_collation.collversion</literal>の値と異なる場合は、その照合順序に依存するオブジェクトは再構築が必要かもしれません。
<xref linkend="sql-altercollation"/>も参照してください。
   </para>

   <para>
<!--
    <function>pg_import_system_collations</function> adds collations to the system
    catalog <literal>pg_collation</literal> based on all the
    locales it finds in the operating system.  This is
    what <command>initdb</command> uses;
    see <xref linkend="collation-managing"/> for more details.  If additional
    locales are installed into the operating system later on, this function
    can be run again to add collations for the new locales.  Locales that
    match existing entries in <literal>pg_collation</literal> will be skipped.
    (But collation objects based on locales that are no longer
    present in the operating system are not removed by this function.)
    The <parameter>schema</parameter> parameter would typically
    be <literal>pg_catalog</literal>, but that is not a requirement;
    the collations could be installed into some other schema as well.
    The function returns the number of new collation objects it created.
-->
<function>pg_import_system_collations</function>は、オペレーティングシステム上にあるすべてのロケールに基づき、システムカタログ<literal>pg_collation</literal>に照合順序を追加します。
これは<command>initdb</command>が使用しているもので、より詳細については<xref linkend="collation-managing"/>を参照してください。
その後にオペレーティングシステムに追加のロケールをインストールした場合、この関数を再度実行して、その新しいロケールの照合順序を追加することができます。
<literal>pg_collation</literal>に既存のエントリにマッチするロケールはスキップされます。
（しかし、オペレーティングシステム上にもはや存在しなくなったロケールに基づく照合順序オブジェクトはこの関数では削除されません。）
<parameter>schema</parameter>パラメータは通常は<literal>pg_catalog</literal>ですが、必ずしもそうでなければならないわけではなく、照合順序をどれか他のスキーマにインストールすることもできます。
この関数は新しく作成された照合順序オブジェクトの数を返します。
   </para>

   <table id="functions-info-partition">
<!--
    <title>Partitioning Information Functions</title>
-->
    <title>パーティション情報関数</title>
    <tgroup cols="3">
     <thead>
<!--
      <row><entry>Name</entry> <entry>Return Type</entry> <entry>Description</entry></row>
-->
      <row><entry>名前</entry> <entry>戻り型</entry> <entry>説明</entry></row>
     </thead>

     <tbody>
      <row>
       <entry>
        <indexterm><primary>pg_partition_tree</primary></indexterm>
        <literal><function>pg_partition_tree(<type>regclass</type>)</function></literal>
       </entry>
       <entry><type>setof record</type></entry>
       <entry>
<!--
        List information about tables or indexes in a partition tree for a
        given partitioned table or partitioned index, with one row for each
        partition.  Information provided includes the name of the partition,
        the name of its immediate parent, a boolean value telling if the
        partition is a leaf, and an integer telling its level in the hierarchy.
        The value of level begins at <literal>0</literal> for the input table
        or index in its role as the root of the partition tree,
        <literal>1</literal> for its partitions, <literal>2</literal> for
        their partitions, and so on.
-->
1行1パーティションで与えられたパーティション化テーブルあるいはパーティション化インデックスのパーティションツリー内のテーブルあるいはインデックスの情報を表示します。
提供される情報にはパーティション名、その直接の親、パーティションが葉かどうかを示す真偽値、階層内のレベルを表す整数が含まれます。
レベル値は与えられたテーブルあるいはインデックスがパーティションツリーの根としての役割を持つことを表す<literal>0</literal>で始まり、<literal>1</literal>ならその直下のパーティション、<literal>2</literal>ならそのまた下のパーティションなどとなります。
       </entry>
      </row>
      <row>
       <entry>
        <indexterm><primary>pg_partition_ancestors</primary></indexterm>
        <literal><function>pg_partition_ancestors(<type>regclass</type>)</function></literal>
       </entry>
       <entry><type>setof regclass</type></entry>
       <entry>
<!--
        List the ancestor relations of the given partition,
        including the partition itself.
-->
パーティション自身を含む、与えられたパーティションの先祖リレーションを列挙します。
       </entry>
      </row>
      <row>
       <entry>
        <indexterm><primary>pg_partition_root</primary></indexterm>
        <literal><function>pg_partition_root(<type>regclass</type>)</function></literal>
       </entry>
       <entry><type>regclass</type></entry>
       <entry>
<!--
        Return the top-most parent of a partition tree to which the given
        relation belongs.
-->
与えられたリレーションが所属するパーティションツリーの最上位の親を返します。
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
<!--
    To check the total size of the data contained in
    <structname>measurement</structname> table described in
    <xref linkend="ddl-partitioning-declarative-example"/>, one could use the
    following query:
-->
<xref linkend="ddl-partitioning-declarative-example"/>で説明されている<structname>measurement</structname>テーブルに含まれるデータの全体サイズを確認するには、次の問い合わせが利用できます。
   </para>

<programlisting>
=# SELECT pg_size_pretty(sum(pg_relation_size(relid))) AS total_size
     FROM pg_partition_tree('measurement');
 total_size 
------------
 24 kB
(1 row)
</programlisting>

  </sect2>

  <sect2 id="functions-admin-index">
<!--
   <title>Index Maintenance Functions</title>
-->
   <title>インデックス保守関数</title>

   <indexterm>
    <primary>brin_summarize_new_values</primary>
   </indexterm>

   <indexterm>
    <primary>gin_clean_pending_list</primary>
   </indexterm>

   <indexterm>
    <primary>brin_summarize_range</primary>
   </indexterm>

   <indexterm>
    <primary>brin_desummarize_range</primary>
   </indexterm>

   <para>
<!--
    <xref linkend="functions-admin-index-table"/> shows the functions
    available for index maintenance tasks.
    These functions cannot be executed during recovery.
    Use of these functions is restricted to superusers and the owner
    of the given index.
-->
<xref linkend="functions-admin-index-table"/>にインデックスの保守タスクに使用可能な関数を示します。
これらの関数はリカバリ中は実行できません。
これらの関数の使用はスーパーユーザと対象のインデックスの所有者に限定されます。
   </para>

   <table id="functions-admin-index-table">
<!--
    <title>Index Maintenance Functions</title>
-->
    <title>インデックス保守関数</title>
    <tgroup cols="3">
     <thead>
<!--
      <row><entry>Name</entry> <entry>Return Type</entry> <entry>Description</entry></row>
-->
      <row><entry>名前</entry> <entry>戻り型</entry> <entry>説明</entry></row>
     </thead>

     <tbody>
      <row>
       <entry>
        <literal><function>brin_summarize_new_values(<parameter>index</parameter> <type>regclass</type>)</function></literal>
       </entry>
       <entry><type>integer</type></entry>
<!--
       <entry>summarize page ranges not already summarized</entry>
-->
       <entry>まだ要約されていないページ範囲を要約する</entry>
      </row>
      <row>
       <entry>
        <literal><function>brin_summarize_range(<parameter>index</parameter> <type>regclass</type>, <parameter>blockNumber</parameter> <type>bigint</type>)</function></literal>
       </entry>
       <entry><type>integer</type></entry>
<!--
       <entry>summarize the page range covering the given block, if not already summarized</entry>
-->
       <entry>指定のブロックを含むページ範囲が、まだ要約されていなければ、要約する</entry>
      </row>
      <row>
       <entry>
        <literal><function>brin_desummarize_range(<parameter>index</parameter> <type>regclass</type>, <parameter>blockNumber</parameter> <type>bigint</type>)</function></literal>
       </entry>
       <entry><type>integer</type></entry>
<!--
       <entry>de-summarize the page range covering the given block, if summarized</entry>
-->
       <entry>指定のブロックを含むページ範囲が要約されていれば、要約されていない状態にする</entry>
      </row>
      <row>
       <entry>
        <literal><function>gin_clean_pending_list(<parameter>index</parameter> <type>regclass</type>)</function></literal>
       </entry>
       <entry><type>bigint</type></entry>
<!--
       <entry>move GIN pending list entries into main index structure</entry>
-->
       <entry>GINの処理待ちリストのエントリをメインのインデックス構造に移動する</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
<!--
    <function>brin_summarize_new_values</function> accepts the OID or name of a
    BRIN index and inspects the index to find page ranges in the base table
    that are not currently summarized by the index; for any such range
    it creates a new summary index tuple by scanning the table pages.
    It returns the number of new page range summaries that were inserted
    into the index.  <function>brin_summarize_range</function> does the same, except
    it only summarizes the range that covers the given block number.
-->
<function>brin_summarize_new_values</function>はBRINインデックスのOIDまたは名前を受け取り、インデックスを検査してベーステーブル内のインデックスによって現在要約されていないページ範囲を探します。
そのような範囲があれば、テーブルのページをスキャンして新しい要約インデックスタプルを作成します。
インデックスに挿入された新しいページ範囲要約の数を返します。
<function>brin_summarize_range</function>も同じですが、ただし指定のブロック番号を含む範囲についてしか要約しません。
   </para>

   <para>
<!--
    <function>gin_clean_pending_list</function> accepts the OID or name of
    a GIN index and cleans up the pending list of the specified index
    by moving entries in it to the main GIN data structure in bulk.
    It returns the number of pages removed from the pending list.
    Note that if the argument is a GIN index built with
    the <literal>fastupdate</literal> option disabled, no cleanup happens and the
    return value is 0, because the index doesn't have a pending list.
    Please see <xref linkend="gin-fast-update"/> and <xref linkend="gin-tips"/>
    for details of the pending list and <literal>fastupdate</literal> option.
-->
<function>gin_clean_pending_list</function>はGINインデックスのOIDまたは名前を受け取り、指定のインデックスの処理待ちリストのエントリをメインのGINデータ構造にまとめて移動することで、リストを削除します。
処理待ちリストから削除されたページ数が返されます。
引数が<literal>fastupdate</literal>オプションを無効にして構築されたGINインデックスの場合、インデックスには処理待ちリストがないため、削除は発生せず、戻り値は0になることに注意して下さい。
処理待ちリストおよび<literal>fastupdate</literal>の詳細については<xref linkend="gin-fast-update"/>および<xref linkend="gin-tips"/>を参照して下さい。
   </para>

  </sect2>

  <sect2 id="functions-admin-genfile">
<!--
   <title>Generic File Access Functions</title>
-->
   <title>汎用ファイルアクセス関数</title>

   <para>
<!--
    The functions shown in <xref
    linkend="functions-admin-genfile-table"/> provide native access to
    files on the machine hosting the server. Only files within the
    database cluster directory and the <varname>log_directory</varname> can be
    accessed unless the user is granted the role
    <literal>pg_read_server_files</literal>.  Use a relative path for files in
    the cluster directory, and a path matching the <varname>log_directory</varname>
    configuration setting for log files.
-->
<xref linkend="functions-admin-genfile-table"/>で示されている関数はサーバをホスティングしているマシン上のファイルに対し、ネイティブのアクセスを提供します。
ユーザが<literal>pg_read_server_files</literal>ロールを与えられていない限り、データベースクラスタディレクトリと<varname>log_directory</varname>に存在するファイルのみがアクセス可能です。
クラスタディレクトリ内のファイルに対して相対パスを、そしてログファイルに対しては<varname>log_directory</varname>構成設定に一致するパスを使用してください。
これらの関数は特に記述がある場合を除き、スーパーユーザだけが使用できます。
   </para>

   <para>
<!--
    Note that granting users the EXECUTE privilege on
    <function>pg_read_file()</function>, or related functions, allows them the
    ability to read any file on the server which the database can read and
    that those reads bypass all in-database privilege checks.  This means that,
    among other things, a user with this access is able to read the contents of the
    <literal>pg_authid</literal> table where authentication information is contained,
    as well as read any file in the database.  Therefore, granting access to these
    functions should be carefully considered.
-->
ユーザに対して<function>pg_read_file()</function>あるいは関連する関数へのEXECUTE権限を許可することは、サーバ上のデータベースが読むことのできるすべてのファイルに対して読み出し許可を与えることになること、こうした読み出しについてはデータベース内のあらゆる権限チェックがすり抜けられることに注意してください。
これはつまり、この権限を持っているユーザは、とりわけ認証情報が含まれる<literal>pg_authid</literal>テーブルの内容を読むことができることを意味します。
ですから、これらの関数には注意深くアクセス許可を与えるべきです。
   </para>

   <table id="functions-admin-genfile-table">
<!--
    <title>Generic File Access Functions</title>
-->
    <title>汎用ファイルアクセス関数</title>
    <tgroup cols="3">
     <thead>
<!--
      <row><entry>Name</entry> <entry>Return Type</entry> <entry>Description</entry>
-->
      <row><entry>名前</entry> <entry>戻り型</entry> <entry>説明</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry>
        <literal><function>pg_ls_dir(<parameter>dirname</parameter> <type>text</type> [, <parameter>missing_ok</parameter> <type>boolean</type>, <parameter>include_dot_dirs</parameter> <type>boolean</type>])</function></literal>
       </entry>
       <entry><type>setof text</type></entry>
       <entry>
<!--
        List the contents of a directory.  Restricted to superusers by default, but other users can be granted EXECUTE to run the function.
-->
ディレクトリの内容を一覧表示する。デフォルトではスーパーユーザに制限されるが、他のユーザにEXECUTEを許可することによりこの関数を実行できる
       </entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_ls_logdir()</function></literal>
       </entry>
       <entry><type>setof record</type></entry>
       <entry>
<!--
        List the name, size, and last modification time of files in the log
        directory. Access is granted to members of the <literal>pg_monitor</literal>
        role and may be granted to other non-superuser roles.
-->
ログディレクトリ内のファイルの名前、サイズ、最終更新時刻を一覧表示します。
<literal>pg_monitor</literal>ロールのメンバーにはアクセス権が付与されており、他の非スーパーユーザのロールにもアクセス権を付与することができます。
       </entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_ls_waldir()</function></literal>
       </entry>
       <entry><type>setof record</type></entry>
       <entry>
<!--
        List the name, size, and last modification time of files in the WAL
        directory. Access is granted to members of the <literal>pg_monitor</literal>
        role and may be granted to other non-superuser roles.
-->
WALディレクトリ内のファイルの名前、サイズ、最終更新時刻を一覧表示します。
<literal>pg_monitor</literal>ロールのメンバーにはアクセス権が付与されており、他の非スーパーユーザのロールにもアクセス権を付与することができます。
       </entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_ls_archive_statusdir()</function></literal>
       </entry>
       <entry><type>setof record</type></entry>
       <entry>
<!--
        List the name, size, and last modification time of files in the WAL
        archive status directory. Access is granted to members of the
        <literal>pg_monitor</literal> role and may be granted to other
        non-superuser roles.
-->
WALアーカイブステータスディレクトリ内のファイルの名前、サイズ、最終更新時刻を一覧表示します。
<literal>pg_monitor</literal>ロールのメンバーにはアクセス権が付与されており、他の非スーパーユーザのロールにもアクセス権を付与することができます。
       </entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_ls_tmpdir(<optional><parameter>tablespace</parameter> <type>oid</type></optional>)</function></literal>
       </entry>
       <entry><type>setof record</type></entry>
       <entry>
<!--
        List the name, size, and last modification time of files in the
        temporary directory for <parameter>tablespace</parameter>.  If
        <parameter>tablespace</parameter> is not provided, the
        <literal>pg_default</literal> tablespace is used.  Access is granted
        to members of the <literal>pg_monitor</literal> role and may be
        granted to other non-superuser roles.
-->
<parameter>tablespace</parameter>用の一時ディレクトリ内のファイルの名前、サイズ、最終更新時刻を一覧表示します。
<parameter>tablespace</parameter>が与えられなかった場合は<literal>pg_default</literal>テーブル空間が使用されます。
<literal>pg_monitor</literal>ロールのメンバーにはアクセス権が付与されており、他の非スーパーユーザのロールにもアクセス権を付与することができます。
       </entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_read_file(<parameter>filename</parameter> <type>text</type> [, <parameter>offset</parameter> <type>bigint</type>, <parameter>length</parameter> <type>bigint</type> [, <parameter>missing_ok</parameter> <type>boolean</type>] ])</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
<!--
        Return the contents of a text file.  Restricted to superusers by default, but other users can be granted EXECUTE to run the function.
-->
テキストファイルの内容を返す。デフォルトではスーパーユーザに制限されるが、他のユーザにEXECUTEを許可することによりこの関数を実行できる
       </entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_read_binary_file(<parameter>filename</parameter> <type>text</type> [, <parameter>offset</parameter> <type>bigint</type>, <parameter>length</parameter> <type>bigint</type> [, <parameter>missing_ok</parameter> <type>boolean</type>] ])</function></literal>
       </entry>
       <entry><type>bytea</type></entry>
       <entry>
<!--
        Return the contents of a file.  Restricted to superusers by default, but other users can be granted EXECUTE to run the function.
-->
ファイルの内容を返す。デフォルトではスーパーユーザに制限されるが、他のユーザにEXECUTEを許可することによりこの関数を実行できる
       </entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_stat_file(<parameter>filename</parameter> <type>text</type>[, <parameter>missing_ok</parameter> <type>boolean</type>])</function></literal>
       </entry>
       <entry><type>record</type></entry>
       <entry>
<!--
        Return information about a file.  Restricted to superusers by default, but other users can be granted EXECUTE to run the function.
-->
ファイルについての情報を返す。デフォルトではスーパーユーザに制限されるが、他のユーザにEXECUTEを許可することによりこの関数を実行できる
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
<!--
    Some of these functions take an optional <parameter>missing_ok</parameter> parameter,
    which specifies the behavior when the file or directory does not exist.
    If <literal>true</literal>, the function returns NULL (except
    <function>pg_ls_dir</function>, which returns an empty result set). If
    <literal>false</literal>, an error is raised. The default is <literal>false</literal>.
-->
これらの関数の一部はオプションで<parameter>missing_ok</parameter>パラメータをとり、ファイルまたはディレクトリが存在しない場合の動作を指定できます。
<literal>true</literal>の場合、関数はNULLを返します（ただし、<function>pg_ls_dir</function>は空の結果集合を返します）。
<literal>false</literal>の場合はエラーが発生します。
デフォルトは<literal>false</literal>です。
   </para>

   <indexterm>
    <primary>pg_ls_dir</primary>
   </indexterm>
   <para>
<!--
    <function>pg_ls_dir</function> returns the names of all files (and directories
    and other special files) in the specified directory. The <parameter>
    include_dot_dirs</parameter> indicates whether <quote>.</quote> and <quote>..</quote> are
    included in the result set. The default is to exclude them
    (<literal>false</literal>), but including them can be useful when
    <parameter>missing_ok</parameter> is <literal>true</literal>, to distinguish an
    empty directory from an non-existent directory.
-->
<function>pg_ls_dir</function>は、指定されたディレクトリ内のすべてのファイル（およびディレクトリと他の特殊ファイル）の名前を返します。
<parameter>include_dot_dirs</parameter>は<quote>.</quote>と<quote>..</quote>が結果集合に含まれるかどうかを指定します。
デフォルト(<literal>false</literal>)ではそれらを除外しますが、それらを含めると、<parameter>missing_ok</parameter>が<literal>true</literal>の場合は、空のディレクトリと存在しないディレクトリを区別するために役立つでしょう。
   </para>

   <indexterm>
    <primary>pg_ls_logdir</primary>
   </indexterm>
   <para>
<!--
    <function>pg_ls_logdir</function> returns the name, size, and last modified time
    (mtime) of each file in the log directory. By default, only superusers
    and members of the <literal>pg_monitor</literal> role can use this function.
    Access may be granted to others using <command>GRANT</command>.
-->
<function>pg_ls_logdir</function>はログディレクトリ内の各ファイルについて、名前、サイズ、最終更新時刻（mtime）を返します。
デフォルトでは、スーパーユーザと<literal>pg_monitor</literal>ロールのメンバーだけがこの関数を使用できます。
<command>GRANT</command>を使って他のロールにアクセス権を付与することができます。
   </para>

   <indexterm>
    <primary>pg_ls_waldir</primary>
   </indexterm>
   <para>
<!--
    <function>pg_ls_waldir</function> returns the name, size, and last modified time
    (mtime) of each file in the write ahead log (WAL) directory. By
    default only superusers and members of the <literal>pg_monitor</literal> role
    can use this function. Access may be granted to others using
    <command>GRANT</command>.
-->
<function>pg_ls_waldir</function>は先行書き込みログ（WAL）ディレクトリ内の各ファイルについて、名前、サイズ、最終更新時刻（mtime）を返します。
デフォルトでは、スーパーユーザと<literal>pg_monitor</literal>ロールのメンバーだけがこの関数を使用できます。
<command>GRANT</command>を使って他のロールにアクセス権を付与することができます。
   </para>

   <indexterm>
    <primary>pg_ls_archive_statusdir</primary>
   </indexterm>
   <para>
<!--
    <function>pg_ls_archive_statusdir</function> returns the name, size, and
    last modified time (mtime) of each file in the WAL archive status
    directory <filename>pg_wal/archive_status</filename>. By default only
    superusers and members of the <literal>pg_monitor</literal> role can
    use this function. Access may be granted to others using
    <command>GRANT</command>.
-->
<function>pg_ls_archive_statusdir</function>はWALアーカイブディレクトリ内の各ファイルについて、名前、サイズ、最終更新時刻（mtime）を返します。
デフォルトでは、スーパーユーザと<literal>pg_monitor</literal>ロールのメンバーだけがこの関数を使用できます。
<command>GRANT</command>を使って他のロールにアクセス権を付与することができます。
   </para>

   <indexterm>
    <primary>pg_ls_tmpdir</primary>
   </indexterm>
   <para>
<!--
    <function>pg_ls_tmpdir</function> returns the name, size, and last modified
    time (mtime) of each file in the temporary file directory for the specified
    <parameter>tablespace</parameter>.  If <parameter>tablespace</parameter> is
    not provided, the <literal>pg_default</literal> tablespace is used.  By
    default only superusers and members of the <literal>pg_monitor</literal>
    role can use this function.  Access may be granted to others using
    <command>GRANT</command>.
-->
<function>pg_ls_tmpdir</function>は指定された<parameter>tablespace</parameter>用の一時ディレクトリ内のファイルの名前、サイズ、最終更新時刻を一覧表示します。
<parameter>tablespace</parameter>が与えられなかった場合は<literal>pg_default</literal>テーブル空間が使用されます。
デフォルトでは、スーパーユーザと<literal>pg_monitor</literal>ロールのメンバーだけがこの関数を使用できます。
<command>GRANT</command>を使って他のロールにアクセス権を付与することができます。
   </para>

   <indexterm>
    <primary>pg_read_file</primary>
   </indexterm>
   <para>
<!--
    <function>pg_read_file</function> returns part of a text file, starting
    at the given <parameter>offset</parameter>, returning at most <parameter>length</parameter>
    bytes (less if the end of file is reached first).  If <parameter>offset</parameter>
    is negative, it is relative to the end of the file.
    If <parameter>offset</parameter> and <parameter>length</parameter> are omitted, the entire
    file is returned.  The bytes read from the file are interpreted as a string
    in the server encoding; an error is thrown if they are not valid in that
    encoding.
-->
<function>pg_read_file</function>は与えられた<parameter>offset</parameter>から始まり、最大<parameter>length</parameter>バイト（先にファイルの終りに到達すればこれより少なくなります）テキストファイルの一部分を返します。
<parameter>offset</parameter>が負の場合にはファイルの終りから数えた位置から読み出します。
<parameter>offset</parameter>と<parameter>length</parameter>が省略された場合、ファイル全体が返されます。
ファイルから読み込まれたバイトは、そのサーバの符号化方式での文字列として解釈されます。
読み込んだバイト列がその符号化方式において有効でない場合にはエラーが投げられます。
   </para>

   <indexterm>
    <primary>pg_read_binary_file</primary>
   </indexterm>
   <para>
<!--
    <function>pg_read_binary_file</function> is similar to
    <function>pg_read_file</function>, except that the result is a <type>bytea</type> value;
    accordingly, no encoding checks are performed.
    In combination with the <function>convert_from</function> function, this function
    can be used to read a file in a specified encoding:
-->
<function>pg_read_binary_file</function>は、結果が<type>bytea</type>値となり、従って符号化の検査がされないことを除き、<function>pg_read_file</function>と似ています。
<function>convert_from</function>関数と組み合わせることで、この関数を、指定した符号化方式でファイルの読み込むために使うことができます。
    
<programlisting>
SELECT convert_from(pg_read_binary_file('file_in_utf8.txt'), 'UTF8');
</programlisting>
   </para>

   <indexterm>
    <primary>pg_stat_file</primary>
   </indexterm>
   <para>
<!--
    <function>pg_stat_file</function> returns a record containing the file
    size, last accessed time stamp, last modified time stamp,
    last file status change time stamp (Unix platforms only),
    file creation time stamp (Windows only), and a <type>boolean</type>
    indicating if it is a directory.  Typical usages include:
-->
<function>pg_stat_file</function>はファイル容量、最終アクセス時刻、最終更新時刻、最後にファイルステータスを変更した時刻（これはUnixプラットフォームのみ）、ファイル作成時刻（Windowsのみ）および、ディレクトリかどうかを示す<type>boolean</type>を返します。
典型的な使用方法を示します。
<programlisting>
SELECT * FROM pg_stat_file('filename');
SELECT (pg_stat_file('filename')).modification;
</programlisting>
   </para>

  </sect2>

  <sect2 id="functions-advisory-locks">
<!--
   <title>Advisory Lock Functions</title>
-->
   <title>勧告的ロック用関数</title>

   <para>
<!--
    The functions shown in <xref linkend="functions-advisory-locks-table"/>
    manage advisory locks.  For details about proper use of these functions,
    see <xref linkend="advisory-locks"/>.
-->
<xref linkend="functions-advisory-locks-table"/>に示す関数は勧告的ロックを管理します。
これらの関数の適切な使用方法についての詳細は、<xref linkend="advisory-locks"/>を参照してください。
   </para>

   <table id="functions-advisory-locks-table">
<!--
    <title>Advisory Lock Functions</title>
-->
    <title>勧告的ロック用関数</title>
    <tgroup cols="3">
     <thead>
<!--
      <row><entry>Name</entry> <entry>Return Type</entry> <entry>Description</entry>
-->
      <row><entry>名前</entry> <entry>戻り型</entry> <entry>説明</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry>
        <literal><function>pg_advisory_lock(<parameter>key</parameter> <type>bigint</type>)</function></literal>
       </entry>
       <entry><type>void</type></entry>
<!--
       <entry>Obtain exclusive session level advisory lock</entry>
-->
       <entry>セッションレベルの排他勧告的ロックを獲得</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_advisory_lock(<parameter>key1</parameter> <type>int</type>, <parameter>key2</parameter> <type>int</type>)</function></literal>
       </entry>
       <entry><type>void</type></entry>
<!--
       <entry>Obtain exclusive session level advisory lock</entry>
-->
       <entry>セッションレベルの排他勧告的ロックを獲得</entry>
      </row>

      <row>
       <entry>
        <literal><function>pg_advisory_lock_shared(<parameter>key</parameter> <type>bigint</type>)</function></literal>
       </entry>
       <entry><type>void</type></entry>
<!--
       <entry>Obtain shared session level advisory lock</entry>
-->
       <entry>セッションレベルの共有勧告的ロックを獲得</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_advisory_lock_shared(<parameter>key1</parameter> <type>int</type>, <parameter>key2</parameter> <type>int</type>)</function></literal>
       </entry>
       <entry><type>void</type></entry>
<!--
       <entry>Obtain shared session level advisory lock</entry>
-->
       <entry>セッションレベルの共有勧告的ロックを獲得</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_advisory_unlock(<parameter>key</parameter> <type>bigint</type>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>Release an exclusive session level advisory lock</entry>
-->
       <entry>セッションレベルの排他勧告的ロックを解放</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_advisory_unlock(<parameter>key1</parameter> <type>int</type>, <parameter>key2</parameter> <type>int</type>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>Release an exclusive session level advisory lock</entry>
-->
       <entry>セッションレベルの排他勧告的ロックを解放</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_advisory_unlock_all()</function></literal>
       </entry>
       <entry><type>void</type></entry>
<!--
       <entry>Release all session level advisory locks held by the current session</entry>
-->
       <entry>現在のセッションで保持している全てのセッションレベルの勧告的ロックを解放</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_advisory_unlock_shared(<parameter>key</parameter> <type>bigint</type>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>Release a shared session level advisory lock</entry>
-->
       <entry>セッションレベルの共有勧告的ロックを解放</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_advisory_unlock_shared(<parameter>key1</parameter> <type>int</type>, <parameter>key2</parameter> <type>int</type>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>Release a shared session level advisory lock</entry>
-->
       <entry>セッションレベルの共有勧告的ロックの解放</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_advisory_xact_lock(<parameter>key</parameter> <type>bigint</type>)</function></literal>
       </entry>
       <entry><type>void</type></entry>
<!--
       <entry>Obtain exclusive transaction level advisory lock</entry>
-->
       <entry>トランザクションレベルの排他勧告的ロックの獲得</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_advisory_xact_lock(<parameter>key1</parameter> <type>int</type>, <parameter>key2</parameter> <type>int</type>)</function></literal>
       </entry>
       <entry><type>void</type></entry>
<!--
       <entry>Obtain exclusive transaction level advisory lock</entry>
-->
       <entry>トランザクションレベルの排他勧告的ロックの獲得</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_advisory_xact_lock_shared(<parameter>key</parameter> <type>bigint</type>)</function></literal>
       </entry>
       <entry><type>void</type></entry>
<!--
       <entry>Obtain shared transaction level advisory lock</entry>
-->
       <entry>トランザクションレベルの共有勧告的ロックの獲得</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_advisory_xact_lock_shared(<parameter>key1</parameter> <type>int</type>, <parameter>key2</parameter> <type>int</type>)</function></literal>
       </entry>
       <entry><type>void</type></entry>
<!--
       <entry>Obtain shared transaction level advisory lock</entry>
-->
       <entry>トランザクションレベルの共有勧告的ロックの獲得</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_try_advisory_lock(<parameter>key</parameter> <type>bigint</type>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>Obtain exclusive session level advisory lock if available</entry>
-->
       <entry>可能ならばセッションレベルの排他勧告的ロックを獲得</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_try_advisory_lock(<parameter>key1</parameter> <type>int</type>, <parameter>key2</parameter> <type>int</type>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>Obtain exclusive session level advisory lock if available</entry>
-->
       <entry>可能ならばセッションレベルの排他勧告的ロックを獲得</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_try_advisory_lock_shared(<parameter>key</parameter> <type>bigint</type>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>Obtain shared session level advisory lock if available</entry>
-->
       <entry>可能ならばセッションレベルの共有勧告的ロックを獲得</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_try_advisory_lock_shared(<parameter>key1</parameter> <type>int</type>, <parameter>key2</parameter> <type>int</type>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>Obtain shared session level advisory lock if available</entry>
-->
       <entry>可能ならばセッションレベルの共有勧告的ロックを獲得</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_try_advisory_xact_lock(<parameter>key</parameter> <type>bigint</type>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>Obtain exclusive transaction level advisory lock if available</entry>
-->
       <entry>可能ならばトランザクションレベルの排他勧告的ロックの獲得</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_try_advisory_xact_lock(<parameter>key1</parameter> <type>int</type>, <parameter>key2</parameter> <type>int</type>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>Obtain exclusive transaction level advisory lock if available</entry>
-->
       <entry>可能ならばトランザクションレベルの排他勧告的ロックの獲得</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_try_advisory_xact_lock_shared(<parameter>key</parameter> <type>bigint</type>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>Obtain shared transaction level advisory lock if available</entry>
-->
       <entry>可能ならばトランザクションレベルの共有勧告的ロックの獲得</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_try_advisory_xact_lock_shared(<parameter>key1</parameter> <type>int</type>, <parameter>key2</parameter> <type>int</type>)</function></literal>
       </entry>
       <entry><type>boolean</type></entry>
<!--
       <entry>Obtain shared transaction level advisory lock if available</entry>
-->
       <entry>可能ならばトランザクションレベルの共有勧告的ロックの獲得</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <indexterm>
    <primary>pg_advisory_lock</primary>
   </indexterm>
   <para>
<!--
    <function>pg_advisory_lock</function> locks an application-defined resource,
    which can be identified either by a single 64-bit key value or two
    32-bit key values (note that these two key spaces do not overlap).
    If another session already holds a lock on the same resource identifier,
    this function will wait until the resource becomes available.  The lock
    is exclusive.  Multiple lock requests stack, so that if the same resource
    is locked three times it must then be unlocked three times to be
    released for other sessions' use.
-->
<function>pg_advisory_lock</function>は、アプリケーションが定義したリソースをロックします。キーは単一の64ビットキー値、または、２つの32ビットキー（この2つのキー空間は重複しないことに注意）によって識別されます。
もし、別のセッションが同一リソースに対するロックを保持している場合、関数はリソースが利用可能になるまで待機します。ロックは排他ロックです。
複数のロック要求があればスタックに積まれるため、同一リソースが３回ロックされた場合、他のセッションが使用できるように解放するためにはロック解除を３回行わなければなりません。
   </para>

   <indexterm>
    <primary>pg_advisory_lock_shared</primary>
   </indexterm>
   <para>
<!--
    <function>pg_advisory_lock_shared</function> works the same as
    <function>pg_advisory_lock</function>,
    except the lock can be shared with other sessions requesting shared locks.
    Only would-be exclusive lockers are locked out.
-->
<function>pg_advisory_lock_shared</function>の動作は<function>pg_advisory_lock</function>と同じですが、他のセッションの共有ロックと共有できるロックである点が異なります。
排他ロック要求のみ締め出されます。
   </para>

   <indexterm>
    <primary>pg_try_advisory_lock</primary>
   </indexterm>
   <para>
<!--
    <function>pg_try_advisory_lock</function> is similar to
    <function>pg_advisory_lock</function>, except the function will not wait for the
    lock to become available.  It will either obtain the lock immediately and
    return <literal>true</literal>, or return <literal>false</literal> if the lock cannot be
    acquired immediately.
-->
<function>pg_try_advisory_lock</function>は<function>pg_advisory_lock</function>と同様ですが、この関数の場合、ロックが利用可能になるまで待機しません。
ロックを即座に取得し<literal>true</literal>を返すか、ロックを即座に獲得できなかった場合に<literal>false</literal>を返すかのいずれかです。
   </para>

   <indexterm>
    <primary>pg_try_advisory_lock_shared</primary>
   </indexterm>
   <para>
<!--
    <function>pg_try_advisory_lock_shared</function> works the same as
    <function>pg_try_advisory_lock</function>, except it attempts to acquire
    a shared rather than an exclusive lock.
-->
<function>pg_try_advisory_lock_shared</function>の動作は <function>pg_try_advisory_lock</function>と同じですが、排他ロックではなく共有ロックの獲得を試みます。
   </para>

   <indexterm>
    <primary>pg_advisory_unlock</primary>
   </indexterm>
   <para>
<!--
    <function>pg_advisory_unlock</function> will release a previously-acquired
    exclusive session level advisory lock.  It
    returns <literal>true</literal> if the lock is successfully released.
    If the lock was not held, it will return <literal>false</literal>,
    and in addition, an SQL warning will be reported by the server.
-->
<function>pg_advisory_unlock</function>は、事前に獲得したセッションレベルの勧告的排他ロックを解放します。ロックの解放に成功した場合、<literal>true</literal>を返します。ロックを保持していない場合、<literal>false</literal>を返し、さらに、SQL警告がサーバから報告されます。
   </para>

   <indexterm>
    <primary>pg_advisory_unlock_shared</primary>
   </indexterm>
   <para>
<!--
    <function>pg_advisory_unlock_shared</function> works the same as
    <function>pg_advisory_unlock</function>,
    except it releases a shared session level advisory lock.
-->
<function>pg_advisory_unlock_shared</function>の動作は<function>pg_advisory_unlock</function>と同じですが、セッションレベルの勧告的共有ロックを解放する点が異なります。
   </para>

   <indexterm>
    <primary>pg_advisory_unlock_all</primary>
   </indexterm>
   <para>
<!--
    <function>pg_advisory_unlock_all</function> will release all session level advisory
    locks held by the current session.  (This function is implicitly invoked
    at session end, even if the client disconnects ungracefully.)
-->
<function>pg_advisory_unlock_all</function>は、現在のセッションで保持するセッションレベルの勧告的ロックをすべて解放します。
（この関数は、クライアントとの接続がぶざまに切れた場合でも、セッション終了時に暗黙的に呼び出されます。)
   </para>

   <indexterm>
    <primary>pg_advisory_xact_lock</primary>
   </indexterm>
   <para>
<!--
    <function>pg_advisory_xact_lock</function> works the same as
    <function>pg_advisory_lock</function>, except the lock is automatically released
    at the end of the current transaction and cannot be released explicitly.
-->
<function>pg_advisory_xact_lock</function>の動作は<function>pg_advisory_lock</function>と同じですが、現在のトランザクションの終了時に自動的にロックが解放され、明示的なロックの解放はできません。
   </para>

   <indexterm>
    <primary>pg_advisory_xact_lock_shared</primary>
   </indexterm>
   <para>
<!--
    <function>pg_advisory_xact_lock_shared</function> works the same as
    <function>pg_advisory_lock_shared</function>, except the lock is automatically released
    at the end of the current transaction and cannot be released explicitly.
-->
<function>pg_advisory_xact_lock_shared</function>の動作は<function>pg_advisory_lock_shared</function>と同じですが、現在のトランザクションの終了時に自動的にロックが解放され、明示的なロックの解放はできません。
   </para>

   <indexterm>
    <primary>pg_try_advisory_xact_lock</primary>
   </indexterm>
   <para>
<!--
    <function>pg_try_advisory_xact_lock</function> works the same as
    <function>pg_try_advisory_lock</function>, except the lock, if acquired,
    is automatically released at the end of the current transaction and
    cannot be released explicitly.
-->
<function>pg_try_advisory_xact_lock</function>の動作は<function>pg_try_advisory_lock</function>と同じですが、ロックが獲得できた場合は現在のトランザクションの終了時に自動的にロックが解放され、明示的なロックの解放はできません。
   </para>

   <indexterm>
    <primary>pg_try_advisory_xact_lock_shared</primary>
   </indexterm>
   <para>
<!--
    <function>pg_try_advisory_xact_lock_shared</function> works the same as
    <function>pg_try_advisory_lock_shared</function>, except the lock, if acquired,
    is automatically released at the end of the current transaction and
    cannot be released explicitly.
-->
<function>pg_try_advisory_xact_lock_shared</function>の動作は<function>pg_try_advisory_lock_shared</function>と同じですが、ロックが獲得できた場合は現在のトランザクションの終了時に自動的にロックが解放され、明示的なロックの解放はできません。
   </para>

  </sect2>

  </sect1>

  <sect1 id="functions-trigger">
<!--
   <title>Trigger Functions</title>
-->
   <title>トリガ関数</title>

   <indexterm>
     <primary>suppress_redundant_updates_trigger</primary>
   </indexterm>

   <para>
<!--
      Currently <productname>PostgreSQL</productname> provides one built in trigger
      function, <function>suppress_redundant_updates_trigger</function>,
      which will prevent any update
      that does not actually change the data in the row from taking place, in
      contrast to the normal behavior which always performs the update
      regardless of whether or not the data has changed. (This normal behavior
      makes updates run faster, since no checking is required, and is also
      useful in certain cases.)
-->
現在、<productname>PostgreSQL</productname>は、１つの組み込みトリガ関数<function>suppress_redundant_updates_trigger</function>を提供しており、通常の動作、つまりデータが変更されようがされまいがに関わらず常に更新をする場合とは正反対に、行のデータを実際に変更しない更新が起こらないようにします。
（この通常の動作は、検査を必要としないため更新をより迅速に行い、場合によっては便利です。）
    </para>

    <para>
<!--
      Ideally, you should normally avoid running updates that don't actually
      change the data in the record. Redundant updates can cost considerable
      unnecessary time, especially if there are lots of indexes to alter,
      and space in dead rows that will eventually have to be vacuumed.
      However, detecting such situations in client code is not
      always easy, or even possible, and writing expressions to detect
      them can be error-prone. An alternative is to use
      <function>suppress_redundant_updates_trigger</function>, which will skip
      updates that don't change the data. You should use this with care,
      however. The trigger takes a small but non-trivial time for each record,
      so if most of the records affected by an update are actually changed,
      use of this trigger will actually make the update run slower.
-->
理想的には、通常実際レコード内のデータを変更しない更新の実行を避けるべきです。
冗長な更新により、特に変更対象の多くのインデックスが存在する場合、無視できない不要な時間にかかるコストが発生することがあります。
また、最後にはバキュームしなければならなくなる不要行が場所を取ることになります。
しかし、こうした状況をクライアント側で判定することは常に簡単ではありません。
また、可能であったとしても、それを検知するための式の記述はエラーを招きがちです。
他の方法として、<function>suppress_redundant_updates_trigger</function>を使用することがあります。
これはデータを変更しない更新を飛ばします。
しかしこの関数は注意して使用しなければなりません。
このトリガはレコードごとに小さな、しかし僅かではない時間がかかります。
このため、更新が影響するレコードのほとんどが実際に変更された場合、このトリガは確実に更新の実行を低速にします。
    </para>

    <para>
<!--
      The <function>suppress_redundant_updates_trigger</function> function can be
      added to a table like this:
-->
<function>suppress_redundant_updates_trigger</function>関数は以下のようにテーブルに追加できます。
<programlisting>
CREATE TRIGGER z_min_update
BEFORE UPDATE ON tablename
FOR EACH ROW EXECUTE FUNCTION suppress_redundant_updates_trigger();
</programlisting>
<!--
      In most cases, you would want to fire this trigger last for each row.
      Bearing in mind that triggers fire in name order, you would then
      choose a trigger name that comes after the name of any other trigger
      you might have on the table.
-->
ほとんどの場合、それぞれの行に対しこのトリガを最後に起動させる必要が生じます。
トリガは名前順に起動されることを判っているとして、テーブル上に存在する可能性のある他のトリガの名前の後に続くようトリガ名を選択できます。
    </para>
    <para>
<!--
       For more information about creating triggers, see
        <xref linkend="sql-createtrigger"/>.
-->
トリガ作成についてより詳細は<xref linkend="sql-createtrigger"/>を参照ください。
    </para>
  </sect1>

  <sect1 id="functions-event-triggers">
<!--
   <title>Event Trigger Functions</title>
-->
   <title>イベントトリガ関数</title>

   <para>
<!--
    <productname>PostgreSQL</productname> provides these helper functions
    to retrieve information from event triggers.
-->
<productname>PostgreSQL</productname>はイベントトリガについての情報を取得するために以下のヘルパ関数を提供しています。
   </para>

   <para>
<!--
    For more information about event triggers,
    see <xref linkend="event-triggers"/>.
-->
イベントトリガについての詳細は<xref linkend="event-triggers"/>を参照して下さい。
   </para>

  <sect2 id="pg-event-trigger-ddl-command-end-functions">
<!--
   <title>Capturing Changes at Command End</title>
-->
   <title>コマンド側での変更を捕らえる</title>

   <indexterm>
    <primary>pg_event_trigger_ddl_commands</primary>
   </indexterm>

   <para>
<!--
    <function>pg_event_trigger_ddl_commands</function> returns a list of
    <acronym>DDL</acronym> commands executed by each user action,
    when invoked in a function attached to a
    <literal>ddl_command_end</literal> event trigger.  If called in any other
    context, an error is raised.
    <function>pg_event_trigger_ddl_commands</function> returns one row for each
    base command executed; some commands that are a single SQL sentence
    may return more than one row.  This function returns the following
    columns:
-->
<function>pg_event_trigger_ddl_commands</function>が<literal>ddl_command_end</literal>イベントトリガーに付与された関数から起動されると、各ユーザの操作によって実行された<acronym>DDL</acronym>コマンドの一覧を返します。
それ以外の環境から呼び出された場合はエラーが発生します。
<function>pg_event_trigger_ddl_commands</function>は、実行された基となるコマンドのそれぞれについて1行を返します。
1つのSQL文として実行されるいくつかのコマンドに対して、複数の行が返されることもあります。
この関数は以下の列を返します。

    <informaltable>
     <tgroup cols="3">
      <thead>
       <row>
<!--
        <entry>Name</entry>
        <entry>Type</entry>
        <entry>Description</entry>
-->
        <entry>名前</entry>
        <entry>型</entry>
        <entry>説明</entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry><literal>classid</literal></entry>
<!--
        <entry><type>oid</type></entry>
-->
        <entry>OID of catalog the object belongs in</entry>
        <entry>オブジェクトが属するカタログのOID</entry>
       </row>
       <row>
        <entry><literal>objid</literal></entry>
        <entry><type>oid</type></entry>
<!--
        <entry>OID of the object itself</entry>
-->
        <entry>カタログ内のオブジェクトのOID</entry>
       </row>
       <row>
        <entry><literal>objsubid</literal></entry>
        <entry><type>integer</type></entry>
<!--
        <entry>Sub-object ID (e.g. attribute number for a column)</entry>
-->
        <entry>オブジェクトのサブID（例：列の属性番号）</entry>
       </row>
       <row>
        <entry><literal>command_tag</literal></entry>
        <entry><type>text</type></entry>
<!--
        <entry>Command tag</entry>
-->
        <entry>コマンドのタグ</entry>
       </row>
       <row>
        <entry><literal>object_type</literal></entry>
        <entry><type>text</type></entry>
<!--
        <entry>Type of the object</entry>
-->
        <entry>オブジェクトの型</entry>
       </row>
       <row>
        <entry><literal>schema_name</literal></entry>
        <entry><type>text</type></entry>
        <entry>
<!--
         Name of the schema the object belongs in, if any; otherwise <literal>NULL</literal>.
         No quoting is applied.
-->
オブジェクトが属するスキーマの名前（あれば）。
なければ<literal>NULL</literal>。
引用符づけされない。
        </entry>
       </row>
       <row>
        <entry><literal>object_identity</literal></entry>
        <entry><type>text</type></entry>
        <entry>
<!--
         Text rendering of the object identity, schema-qualified. Each
         identifier included in the identity is quoted if necessary.
-->
オブジェクトの識別をテキスト表現したもので、スキーマ修飾される。
識別内に存在する各識別子は、必要なら引用符で括られる。
        </entry>
       </row>
       <row>
        <entry><literal>in_extension</literal></entry>
        <entry><type>bool</type></entry>
<!--
        <entry>True if the command is part of an extension script</entry>
-->
        <entry>コマンドが拡張のスクリプトの一部なら真</entry>
       </row>
       <row>
        <entry><literal>command</literal></entry>
        <entry><type>pg_ddl_command</type></entry>
        <entry>
<!--
         A complete representation of the command, in internal format.
         This cannot be output directly, but it can be passed to other
         functions to obtain different pieces of information about the
         command.
-->
コマンドを内部形式で完全に表現したもの。
これを直接出力することはできないが、コマンドについて他の情報を得るために、他の関数に渡すことができる。
        </entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>
   </para>
  </sect2>

  <sect2 id="pg-event-trigger-sql-drop-functions">
<!--
   <title>Processing Objects Dropped by a DDL Command</title>
-->
   <title>DDLコマンドで削除されたオブジェクトの処理</title>

   <indexterm>
     <primary>pg_event_trigger_dropped_objects</primary>
   </indexterm>

   <para>
<!--
    <function>pg_event_trigger_dropped_objects</function> returns a list of all objects
    dropped by the command in whose <literal>sql_drop</literal> event it is called.
    If called in any other context,
    <function>pg_event_trigger_dropped_objects</function> raises an error.
    <function>pg_event_trigger_dropped_objects</function> returns the following columns:
-->
関数<function>pg_event_trigger_dropped_objects</function>は、それが呼ばれた<literal>sql_drop</literal>イベントのコマンドにより削除された全てのオブジェクトのリストを返します。
その他いかなる状況で呼ばれた場合、<function>pg_event_trigger_dropped_objects</function>はエラーを生じさせます。
<function>pg_event_trigger_dropped_objects</function>は以下の列を返します。

    <informaltable>
     <tgroup cols="3">
      <thead>
       <row>
<!--
        <entry>Name</entry>
        <entry>Type</entry>
        <entry>Description</entry>
-->
        <entry>名前</entry>
        <entry>型</entry>
        <entry>説明</entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry><literal>classid</literal></entry>
<!--
        <entry><type>oid</type></entry>
        <entry>OID of catalog the object belonged in</entry>
-->
        <entry>オブジェクトが所属するカタログのOID</entry>
       </row>
       <row>
        <entry><literal>objid</literal></entry>
        <entry><type>oid</type></entry>
<!--
        <entry>OID of the object itself</entry>
-->
        <entry>カタログ内に所有するオブジェクトのOID</entry>
       </row>
       <row>
        <entry><literal>objsubid</literal></entry>
        <entry><type>integer</type></entry>
<!--
        <entry>Sub-object ID (e.g. attribute number for a column)</entry>
-->
        <entry> (列の属性番号のような)オブジェクトの副id</entry>
       </row>
       <row>
        <entry><literal>original</literal></entry>
        <entry><type>bool</type></entry>
<!--
        <entry>True if this was one of the root object(s) of the deletion</entry>
-->
        <entry>これが削除のルートオブジェクトの一つなら真</entry>
       </row>
       <row>
        <entry><literal>normal</literal></entry>
        <entry><type>bool</type></entry>
        <entry>
<!--
         True if there was a normal dependency relationship
         in the dependency graph leading to this object
-->
このオブジェクトへと至る依存関係グラフで、通常の依存があるなら真
        </entry>
       </row>
       <row>
        <entry><literal>is_temporary</literal></entry>
        <entry><type>bool</type></entry>
        <entry>
<!--
         True if this was a temporary object
-->
オブジェクトが一時オブジェクトであったなら真
        </entry>
       </row>
       <row>
        <entry><literal>object_type</literal></entry>
        <entry><type>text</type></entry>
<!--
        <entry>Type of the object</entry>
-->
        <entry>オブジェクトの型</entry>
       </row>
       <row>
        <entry><literal>schema_name</literal></entry>
        <entry><type>text</type></entry>
        <entry>
<!--
         Name of the schema the object belonged in, if any; otherwise <literal>NULL</literal>.
         No quoting is applied.
-->
オブジェクトが所属しているスキーマの名前（あれば）。
なければ<literal>NULL</literal>。
引用符づけされない。
        </entry>
       </row>
       <row>
        <entry><literal>object_name</literal></entry>
        <entry><type>text</type></entry>
        <entry>
<!--
         Name of the object, if the combination of schema and name can be
         used as a unique identifier for the object; otherwise <literal>NULL</literal>.
         No quoting is applied, and name is never schema-qualified.
-->
スキーマと名前の組み合わせがオブジェクトに対する一意の識別子として使用可能な場合はオブジェクトの名前。そうでないときは<literal>NULL</literal>。
引用符は適用されず、名前は決してスキーマで修飾されない。
        </entry>
       </row>
       <row>
        <entry><literal>object_identity</literal></entry>
        <entry><type>text</type></entry>
        <entry>
<!--
         Text rendering of the object identity, schema-qualified. Each
         identifier included in the identity is quoted if necessary.
-->
オブジェクト識別のテキスト表現で、スキーマ修飾される。
識別内に存在する各識別子は必要であれば引用符で括られる。
        </entry>
       </row>
       <row>
        <entry><literal>address_names</literal></entry>
        <entry><type>text[]</type></entry>
        <entry>
<!--
         An array that, together with <literal>object_type</literal> and
         <literal>address_args</literal>, can be used by
         the <function>pg_get_object_address()</function> function to
         recreate the object address in a remote server containing an
         identically named object of the same kind
-->
<literal>object_type</literal>および<literal>address_args</literal>と一緒に<function>pg_get_object_address()</function>で使うことで、同じ種類で全く同じ名前のオブジェクトを含むリモートサーバ内のオブジェクトアドレスを再作成できる配列。
        </entry>
       </row>
       <row>
        <entry><literal>address_args</literal></entry>
        <entry><type>text[]</type></entry>
        <entry>
<!--
         Complement for <literal>address_names</literal>
-->
<literal>address_names</literal>の補足。
        </entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>
   </para>

   <para>
<!--
    The <function>pg_event_trigger_dropped_objects</function> function can be used
    in an event trigger like this:
-->
関数<function>pg_event_trigger_dropped_objects</function>は以下のようにイベントトリガとして使用可能です。
<programlisting>
CREATE FUNCTION test_event_trigger_for_drops()
        RETURNS event_trigger LANGUAGE plpgsql AS $$
DECLARE
    obj record;
BEGIN
    FOR obj IN SELECT * FROM pg_event_trigger_dropped_objects()
    LOOP
        RAISE NOTICE '% dropped object: % %.% %',
                     tg_tag,
                     obj.object_type,
                     obj.schema_name,
                     obj.object_name,
                     obj.object_identity;
    END LOOP;
END
$$;
CREATE EVENT TRIGGER test_event_trigger_for_drops
   ON sql_drop
   EXECUTE FUNCTION test_event_trigger_for_drops();
</programlisting>
    </para>
  </sect2>

  <sect2 id="pg-event-trigger-table-rewrite-functions">
<!--
   <title>Handling a Table Rewrite Event</title>
-->
   <title>テーブル書き換えイベントの処理</title>

   <para>
<!--
    The functions shown in
    <xref linkend="functions-event-trigger-table-rewrite"/>
    provide information about a table for which a
    <literal>table_rewrite</literal> event has just been called.
    If called in any other context, an error is raised.
-->
<xref linkend="functions-event-trigger-table-rewrite"/>に示す関数は、<literal>table_rewrite</literal>イベントが呼び出されたばかりのテーブルについての情報を提供します。
それ以外の状況で呼び出された場合はエラーが発生します。
   </para>

   <table id="functions-event-trigger-table-rewrite">
<!--
    <title>Table Rewrite Information</title>
-->
    <title>テーブル書き換え情報</title>
    <tgroup cols="3">
     <thead>
<!--
      <row><entry>Name</entry> <entry>Return Type</entry> <entry>Description</entry></row>
-->
      <row><entry>名前</entry> <entry>戻り型</entry> <entry>説明</entry></row>
     </thead>

     <tbody>
      <row>
       <entry>
        <indexterm><primary>pg_event_trigger_table_rewrite_oid</primary></indexterm>
        <literal><function>pg_event_trigger_table_rewrite_oid()</function></literal>
       </entry>
       <entry><type>Oid</type></entry>
<!--
       <entry>The OID of the table about to be rewritten.</entry>
-->
       <entry>書き換えようとされているテーブルのOID</entry>
      </row>

      <row>
       <entry>
        <indexterm><primary>pg_event_trigger_table_rewrite_reason</primary></indexterm>
        <literal><function>pg_event_trigger_table_rewrite_reason()</function></literal>
       </entry>
       <entry><type>int</type></entry>
       <entry>
<!--
        The reason code(s) explaining the reason for rewriting. The exact
        meaning of the codes is release dependent.
-->
書き換えの理由を説明する理由コード。
コードの正確な意味はリリースに依存する。
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
<!--
    The <function>pg_event_trigger_table_rewrite_oid</function> function can be used
    in an event trigger like this:
-->
<function>pg_event_trigger_table_rewrite_oid</function>関数はイベントトリガ内で以下のように使うことができます。
<programlisting>
CREATE FUNCTION test_event_trigger_table_rewrite_oid()
 RETURNS event_trigger
 LANGUAGE plpgsql AS
$$
BEGIN
  RAISE NOTICE 'rewriting table % for reason %',
                pg_event_trigger_table_rewrite_oid()::regclass,
                pg_event_trigger_table_rewrite_reason();
END;
$$;

CREATE EVENT TRIGGER test_table_rewrite_oid
                  ON table_rewrite
   EXECUTE FUNCTION test_event_trigger_table_rewrite_oid();
</programlisting>
    </para>
  </sect2>
  </sect1>

<!-- split-func4-end -->

  <sect1 id="functions-statistics">
<!--
   <title>Statistics Information Functions</title>
-->
   <title>統計情報関数</title>

   <indexterm zone="functions-statistics">
<!--
    <primary>function</primary>
    <secondary>statistics</secondary>
-->
    <primary>関数</primary>
    <secondary>統計</secondary>
   </indexterm>

   <para>
<!--
    <productname>PostgreSQL</productname> provides a function to inspect complex
    statistics defined using the <command>CREATE STATISTICS</command> command.
-->
<productname>PostgreSQL</productname>は<command>CREATE STATISTICS</command>コマンドを使って定義した複雑な統計を調べる関数を提供しています。
   </para>

  <sect2 id="functions-statistics-mcv">
<!--
   <title>Inspecting MCV Lists</title>
-->
   <title>MCVリストの調査</title>

   <indexterm>
     <primary>pg_mcv_list_items</primary>
     <secondary>pg_mcv_list</secondary>
   </indexterm>

   <para>
<!--
    <function>pg_mcv_list_items</function> returns a list of all items
    stored in a multi-column <acronym>MCV</acronym> list, and returns the
    following columns:
-->
<function>pg_mcv_list_items</function>は複数列<acronym>MCV</acronym>リストに格納されたすべての項目を列挙し、次の列を返します。

    <informaltable>
     <tgroup cols="3">
      <thead>
       <row>
<!--
        <entry>Name</entry>
        <entry>Type</entry>
        <entry>Description</entry>
-->
        <entry>名前</entry>
        <entry>型</entry>
        <entry>説明</entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry><literal>index</literal></entry>
        <entry><type>int</type></entry>
<!--
        <entry>index of the item in the <acronym>MCV</acronym> list</entry>
-->
        <entry><acronym>MCV</acronym>リスト内の項目のインデックス</entry>
       </row>
       <row>
        <entry><literal>values</literal></entry>
        <entry><type>text[]</type></entry>
<!--
        <entry>values stored in the MCV item</entry>
-->
        <entry>MCV項目に格納された値</entry>
       </row>
       <row>
        <entry><literal>nulls</literal></entry>
        <entry><type>boolean[]</type></entry>
<!--
        <entry>flags identifying <literal>NULL</literal> values</entry>
-->
        <entry><literal>NULL</literal>値を識別するフラグ</entry>
       </row>
       <row>
        <entry><literal>frequency</literal></entry>
        <entry><type>double precision</type></entry>
<!--
        <entry>frequency of this <acronym>MCV</acronym> item</entry>
-->
        <entry>この<acronym>MCV</acronym>項目の頻度</entry>
       </row>
       <row>
        <entry><literal>base_frequency</literal></entry>
        <entry><type>double precision</type></entry>
<!--
        <entry>base frequency of this <acronym>MCV</acronym> item</entry>
-->
        <entry>この<acronym>MCV</acronym>項目のベース頻度</entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>
   </para>

   <para>
<!--
    The <function>pg_mcv_list_items</function> function can be used like this:
-->
<function>pg_mcv_list_items</function>関数は次のように使用することができます。

<programlisting>
SELECT m.* FROM pg_statistic_ext join pg_statistic_ext_data on (oid = stxoid),
                pg_mcv_list_items(stxdmcv) m WHERE stxname = 'stts';
</programlisting>

<!--
     Values of the <type>pg_mcv_list</type> can be obtained only from the
     <literal>pg_statistic_ext_data.stxdmcv</literal> column.
-->
<type>pg_mcv_list</type>の値は<literal>pg_statistic_ext_data.stxdmcv</literal>列からのみ得られます。
   </para>
  </sect2>

  </sect1>

</chapter>
